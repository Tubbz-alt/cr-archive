<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Proxy.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,603 ***</span>
   * questions.
   */
  
  package java.lang.reflect;
  
<span class="line-modified">! import java.io.ByteArrayOutputStream;</span>
<span class="line-modified">! import java.io.DataOutputStream;</span>
<span class="line-modified">! import java.io.File;</span>
  import java.io.IOException;
<span class="line-modified">! import java.io.OutputStream;</span>
<span class="line-removed">- import java.lang.reflect.Array;</span>
<span class="line-removed">- import java.lang.reflect.Method;</span>
  import java.nio.file.Files;
  import java.nio.file.Path;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.LinkedList;
  import java.util.List;
  import java.util.ListIterator;
  import java.util.Map;
<span class="line-modified">! import sun.security.action.GetBooleanAction;</span>
  
  /**
   * ProxyGenerator contains the code to generate a dynamic proxy class
   * for the java.lang.reflect.Proxy API.
<span class="line-modified">!  *</span>
<span class="line-modified">!  * The external interfaces to ProxyGenerator is the static</span>
   * &quot;generateProxyClass&quot; method.
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author      Peter Jones</span>
<span class="line-removed">-  * @since       1.3</span>
   */
<span class="line-modified">! class ProxyGenerator {</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * In the comments below, &quot;JVMS&quot; refers to The Java Virtual Machine</span>
<span class="line-removed">-      * Specification Second Edition and &quot;JLS&quot; refers to the original</span>
<span class="line-removed">-      * version of The Java Language Specification, unless otherwise</span>
<span class="line-removed">-      * specified.</span>
<span class="line-removed">-      */</span>
  
<span class="line-modified">!     /* generate 1.5-era class file version */</span>
<span class="line-modified">!     private static final int CLASSFILE_MAJOR_VERSION = 49;</span>
<span class="line-modified">!     private static final int CLASSFILE_MINOR_VERSION = 0;</span>
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * beginning of constants copied from</span>
<span class="line-modified">!      * sun.tools.java.RuntimeConstants (which no longer exists):</span>
<span class="line-removed">-      */</span>
  
<span class="line-modified">!     /* constant pool tags */</span>
<span class="line-modified">!     private static final int CONSTANT_UTF8              = 1;</span>
<span class="line-modified">!     private static final int CONSTANT_UNICODE           = 2;</span>
<span class="line-removed">-     private static final int CONSTANT_INTEGER           = 3;</span>
<span class="line-removed">-     private static final int CONSTANT_FLOAT             = 4;</span>
<span class="line-removed">-     private static final int CONSTANT_LONG              = 5;</span>
<span class="line-removed">-     private static final int CONSTANT_DOUBLE            = 6;</span>
<span class="line-removed">-     private static final int CONSTANT_CLASS             = 7;</span>
<span class="line-removed">-     private static final int CONSTANT_STRING            = 8;</span>
<span class="line-removed">-     private static final int CONSTANT_FIELD             = 9;</span>
<span class="line-removed">-     private static final int CONSTANT_METHOD            = 10;</span>
<span class="line-removed">-     private static final int CONSTANT_INTERFACEMETHOD   = 11;</span>
<span class="line-removed">-     private static final int CONSTANT_NAMEANDTYPE       = 12;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* access and modifier flags */</span>
<span class="line-removed">-     private static final int ACC_PUBLIC                 = 0x00000001;</span>
<span class="line-removed">-     private static final int ACC_PRIVATE                = 0x00000002;</span>
<span class="line-removed">- //  private static final int ACC_PROTECTED              = 0x00000004;</span>
<span class="line-removed">-     private static final int ACC_STATIC                 = 0x00000008;</span>
<span class="line-removed">-     private static final int ACC_FINAL                  = 0x00000010;</span>
<span class="line-removed">- //  private static final int ACC_SYNCHRONIZED           = 0x00000020;</span>
<span class="line-removed">- //  private static final int ACC_VOLATILE               = 0x00000040;</span>
<span class="line-removed">- //  private static final int ACC_TRANSIENT              = 0x00000080;</span>
<span class="line-removed">- //  private static final int ACC_NATIVE                 = 0x00000100;</span>
<span class="line-removed">- //  private static final int ACC_INTERFACE              = 0x00000200;</span>
<span class="line-removed">- //  private static final int ACC_ABSTRACT               = 0x00000400;</span>
<span class="line-removed">-     private static final int ACC_SUPER                  = 0x00000020;</span>
<span class="line-removed">- //  private static final int ACC_STRICT                 = 0x00000800;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* opcodes */</span>
<span class="line-removed">- //  private static final int opc_nop                    = 0;</span>
<span class="line-removed">-     private static final int opc_aconst_null            = 1;</span>
<span class="line-removed">- //  private static final int opc_iconst_m1              = 2;</span>
<span class="line-removed">-     private static final int opc_iconst_0               = 3;</span>
<span class="line-removed">- //  private static final int opc_iconst_1               = 4;</span>
<span class="line-removed">- //  private static final int opc_iconst_2               = 5;</span>
<span class="line-removed">- //  private static final int opc_iconst_3               = 6;</span>
<span class="line-removed">- //  private static final int opc_iconst_4               = 7;</span>
<span class="line-removed">- //  private static final int opc_iconst_5               = 8;</span>
<span class="line-removed">- //  private static final int opc_lconst_0               = 9;</span>
<span class="line-removed">- //  private static final int opc_lconst_1               = 10;</span>
<span class="line-removed">- //  private static final int opc_fconst_0               = 11;</span>
<span class="line-removed">- //  private static final int opc_fconst_1               = 12;</span>
<span class="line-removed">- //  private static final int opc_fconst_2               = 13;</span>
<span class="line-removed">- //  private static final int opc_dconst_0               = 14;</span>
<span class="line-removed">- //  private static final int opc_dconst_1               = 15;</span>
<span class="line-removed">-     private static final int opc_bipush                 = 16;</span>
<span class="line-removed">-     private static final int opc_sipush                 = 17;</span>
<span class="line-removed">-     private static final int opc_ldc                    = 18;</span>
<span class="line-removed">-     private static final int opc_ldc_w                  = 19;</span>
<span class="line-removed">- //  private static final int opc_ldc2_w                 = 20;</span>
<span class="line-removed">-     private static final int opc_iload                  = 21;</span>
<span class="line-removed">-     private static final int opc_lload                  = 22;</span>
<span class="line-removed">-     private static final int opc_fload                  = 23;</span>
<span class="line-removed">-     private static final int opc_dload                  = 24;</span>
<span class="line-removed">-     private static final int opc_aload                  = 25;</span>
<span class="line-removed">-     private static final int opc_iload_0                = 26;</span>
<span class="line-removed">- //  private static final int opc_iload_1                = 27;</span>
<span class="line-removed">- //  private static final int opc_iload_2                = 28;</span>
<span class="line-removed">- //  private static final int opc_iload_3                = 29;</span>
<span class="line-removed">-     private static final int opc_lload_0                = 30;</span>
<span class="line-removed">- //  private static final int opc_lload_1                = 31;</span>
<span class="line-removed">- //  private static final int opc_lload_2                = 32;</span>
<span class="line-removed">- //  private static final int opc_lload_3                = 33;</span>
<span class="line-removed">-     private static final int opc_fload_0                = 34;</span>
<span class="line-removed">- //  private static final int opc_fload_1                = 35;</span>
<span class="line-removed">- //  private static final int opc_fload_2                = 36;</span>
<span class="line-removed">- //  private static final int opc_fload_3                = 37;</span>
<span class="line-removed">-     private static final int opc_dload_0                = 38;</span>
<span class="line-removed">- //  private static final int opc_dload_1                = 39;</span>
<span class="line-removed">- //  private static final int opc_dload_2                = 40;</span>
<span class="line-removed">- //  private static final int opc_dload_3                = 41;</span>
<span class="line-removed">-     private static final int opc_aload_0                = 42;</span>
<span class="line-removed">- //  private static final int opc_aload_1                = 43;</span>
<span class="line-removed">- //  private static final int opc_aload_2                = 44;</span>
<span class="line-removed">- //  private static final int opc_aload_3                = 45;</span>
<span class="line-removed">- //  private static final int opc_iaload                 = 46;</span>
<span class="line-removed">- //  private static final int opc_laload                 = 47;</span>
<span class="line-removed">- //  private static final int opc_faload                 = 48;</span>
<span class="line-removed">- //  private static final int opc_daload                 = 49;</span>
<span class="line-removed">- //  private static final int opc_aaload                 = 50;</span>
<span class="line-removed">- //  private static final int opc_baload                 = 51;</span>
<span class="line-removed">- //  private static final int opc_caload                 = 52;</span>
<span class="line-removed">- //  private static final int opc_saload                 = 53;</span>
<span class="line-removed">- //  private static final int opc_istore                 = 54;</span>
<span class="line-removed">- //  private static final int opc_lstore                 = 55;</span>
<span class="line-removed">- //  private static final int opc_fstore                 = 56;</span>
<span class="line-removed">- //  private static final int opc_dstore                 = 57;</span>
<span class="line-removed">-     private static final int opc_astore                 = 58;</span>
<span class="line-removed">- //  private static final int opc_istore_0               = 59;</span>
<span class="line-removed">- //  private static final int opc_istore_1               = 60;</span>
<span class="line-removed">- //  private static final int opc_istore_2               = 61;</span>
<span class="line-removed">- //  private static final int opc_istore_3               = 62;</span>
<span class="line-removed">- //  private static final int opc_lstore_0               = 63;</span>
<span class="line-removed">- //  private static final int opc_lstore_1               = 64;</span>
<span class="line-removed">- //  private static final int opc_lstore_2               = 65;</span>
<span class="line-removed">- //  private static final int opc_lstore_3               = 66;</span>
<span class="line-removed">- //  private static final int opc_fstore_0               = 67;</span>
<span class="line-removed">- //  private static final int opc_fstore_1               = 68;</span>
<span class="line-removed">- //  private static final int opc_fstore_2               = 69;</span>
<span class="line-removed">- //  private static final int opc_fstore_3               = 70;</span>
<span class="line-removed">- //  private static final int opc_dstore_0               = 71;</span>
<span class="line-removed">- //  private static final int opc_dstore_1               = 72;</span>
<span class="line-removed">- //  private static final int opc_dstore_2               = 73;</span>
<span class="line-removed">- //  private static final int opc_dstore_3               = 74;</span>
<span class="line-removed">-     private static final int opc_astore_0               = 75;</span>
<span class="line-removed">- //  private static final int opc_astore_1               = 76;</span>
<span class="line-removed">- //  private static final int opc_astore_2               = 77;</span>
<span class="line-removed">- //  private static final int opc_astore_3               = 78;</span>
<span class="line-removed">- //  private static final int opc_iastore                = 79;</span>
<span class="line-removed">- //  private static final int opc_lastore                = 80;</span>
<span class="line-removed">- //  private static final int opc_fastore                = 81;</span>
<span class="line-removed">- //  private static final int opc_dastore                = 82;</span>
<span class="line-removed">-     private static final int opc_aastore                = 83;</span>
<span class="line-removed">- //  private static final int opc_bastore                = 84;</span>
<span class="line-removed">- //  private static final int opc_castore                = 85;</span>
<span class="line-removed">- //  private static final int opc_sastore                = 86;</span>
<span class="line-removed">-     private static final int opc_pop                    = 87;</span>
<span class="line-removed">- //  private static final int opc_pop2                   = 88;</span>
<span class="line-removed">-     private static final int opc_dup                    = 89;</span>
<span class="line-removed">- //  private static final int opc_dup_x1                 = 90;</span>
<span class="line-removed">- //  private static final int opc_dup_x2                 = 91;</span>
<span class="line-removed">- //  private static final int opc_dup2                   = 92;</span>
<span class="line-removed">- //  private static final int opc_dup2_x1                = 93;</span>
<span class="line-removed">- //  private static final int opc_dup2_x2                = 94;</span>
<span class="line-removed">- //  private static final int opc_swap                   = 95;</span>
<span class="line-removed">- //  private static final int opc_iadd                   = 96;</span>
<span class="line-removed">- //  private static final int opc_ladd                   = 97;</span>
<span class="line-removed">- //  private static final int opc_fadd                   = 98;</span>
<span class="line-removed">- //  private static final int opc_dadd                   = 99;</span>
<span class="line-removed">- //  private static final int opc_isub                   = 100;</span>
<span class="line-removed">- //  private static final int opc_lsub                   = 101;</span>
<span class="line-removed">- //  private static final int opc_fsub                   = 102;</span>
<span class="line-removed">- //  private static final int opc_dsub                   = 103;</span>
<span class="line-removed">- //  private static final int opc_imul                   = 104;</span>
<span class="line-removed">- //  private static final int opc_lmul                   = 105;</span>
<span class="line-removed">- //  private static final int opc_fmul                   = 106;</span>
<span class="line-removed">- //  private static final int opc_dmul                   = 107;</span>
<span class="line-removed">- //  private static final int opc_idiv                   = 108;</span>
<span class="line-removed">- //  private static final int opc_ldiv                   = 109;</span>
<span class="line-removed">- //  private static final int opc_fdiv                   = 110;</span>
<span class="line-removed">- //  private static final int opc_ddiv                   = 111;</span>
<span class="line-removed">- //  private static final int opc_irem                   = 112;</span>
<span class="line-removed">- //  private static final int opc_lrem                   = 113;</span>
<span class="line-removed">- //  private static final int opc_frem                   = 114;</span>
<span class="line-removed">- //  private static final int opc_drem                   = 115;</span>
<span class="line-removed">- //  private static final int opc_ineg                   = 116;</span>
<span class="line-removed">- //  private static final int opc_lneg                   = 117;</span>
<span class="line-removed">- //  private static final int opc_fneg                   = 118;</span>
<span class="line-removed">- //  private static final int opc_dneg                   = 119;</span>
<span class="line-removed">- //  private static final int opc_ishl                   = 120;</span>
<span class="line-removed">- //  private static final int opc_lshl                   = 121;</span>
<span class="line-removed">- //  private static final int opc_ishr                   = 122;</span>
<span class="line-removed">- //  private static final int opc_lshr                   = 123;</span>
<span class="line-removed">- //  private static final int opc_iushr                  = 124;</span>
<span class="line-removed">- //  private static final int opc_lushr                  = 125;</span>
<span class="line-removed">- //  private static final int opc_iand                   = 126;</span>
<span class="line-removed">- //  private static final int opc_land                   = 127;</span>
<span class="line-removed">- //  private static final int opc_ior                    = 128;</span>
<span class="line-removed">- //  private static final int opc_lor                    = 129;</span>
<span class="line-removed">- //  private static final int opc_ixor                   = 130;</span>
<span class="line-removed">- //  private static final int opc_lxor                   = 131;</span>
<span class="line-removed">- //  private static final int opc_iinc                   = 132;</span>
<span class="line-removed">- //  private static final int opc_i2l                    = 133;</span>
<span class="line-removed">- //  private static final int opc_i2f                    = 134;</span>
<span class="line-removed">- //  private static final int opc_i2d                    = 135;</span>
<span class="line-removed">- //  private static final int opc_l2i                    = 136;</span>
<span class="line-removed">- //  private static final int opc_l2f                    = 137;</span>
<span class="line-removed">- //  private static final int opc_l2d                    = 138;</span>
<span class="line-removed">- //  private static final int opc_f2i                    = 139;</span>
<span class="line-removed">- //  private static final int opc_f2l                    = 140;</span>
<span class="line-removed">- //  private static final int opc_f2d                    = 141;</span>
<span class="line-removed">- //  private static final int opc_d2i                    = 142;</span>
<span class="line-removed">- //  private static final int opc_d2l                    = 143;</span>
<span class="line-removed">- //  private static final int opc_d2f                    = 144;</span>
<span class="line-removed">- //  private static final int opc_i2b                    = 145;</span>
<span class="line-removed">- //  private static final int opc_i2c                    = 146;</span>
<span class="line-removed">- //  private static final int opc_i2s                    = 147;</span>
<span class="line-removed">- //  private static final int opc_lcmp                   = 148;</span>
<span class="line-removed">- //  private static final int opc_fcmpl                  = 149;</span>
<span class="line-removed">- //  private static final int opc_fcmpg                  = 150;</span>
<span class="line-removed">- //  private static final int opc_dcmpl                  = 151;</span>
<span class="line-removed">- //  private static final int opc_dcmpg                  = 152;</span>
<span class="line-removed">- //  private static final int opc_ifeq                   = 153;</span>
<span class="line-removed">- //  private static final int opc_ifne                   = 154;</span>
<span class="line-removed">- //  private static final int opc_iflt                   = 155;</span>
<span class="line-removed">- //  private static final int opc_ifge                   = 156;</span>
<span class="line-removed">- //  private static final int opc_ifgt                   = 157;</span>
<span class="line-removed">- //  private static final int opc_ifle                   = 158;</span>
<span class="line-removed">- //  private static final int opc_if_icmpeq              = 159;</span>
<span class="line-removed">- //  private static final int opc_if_icmpne              = 160;</span>
<span class="line-removed">- //  private static final int opc_if_icmplt              = 161;</span>
<span class="line-removed">- //  private static final int opc_if_icmpge              = 162;</span>
<span class="line-removed">- //  private static final int opc_if_icmpgt              = 163;</span>
<span class="line-removed">- //  private static final int opc_if_icmple              = 164;</span>
<span class="line-removed">- //  private static final int opc_if_acmpeq              = 165;</span>
<span class="line-removed">- //  private static final int opc_if_acmpne              = 166;</span>
<span class="line-removed">- //  private static final int opc_goto                   = 167;</span>
<span class="line-removed">- //  private static final int opc_jsr                    = 168;</span>
<span class="line-removed">- //  private static final int opc_ret                    = 169;</span>
<span class="line-removed">- //  private static final int opc_tableswitch            = 170;</span>
<span class="line-removed">- //  private static final int opc_lookupswitch           = 171;</span>
<span class="line-removed">-     private static final int opc_ireturn                = 172;</span>
<span class="line-removed">-     private static final int opc_lreturn                = 173;</span>
<span class="line-removed">-     private static final int opc_freturn                = 174;</span>
<span class="line-removed">-     private static final int opc_dreturn                = 175;</span>
<span class="line-removed">-     private static final int opc_areturn                = 176;</span>
<span class="line-removed">-     private static final int opc_return                 = 177;</span>
<span class="line-removed">-     private static final int opc_getstatic              = 178;</span>
<span class="line-removed">-     private static final int opc_putstatic              = 179;</span>
<span class="line-removed">-     private static final int opc_getfield               = 180;</span>
<span class="line-removed">- //  private static final int opc_putfield               = 181;</span>
<span class="line-removed">-     private static final int opc_invokevirtual          = 182;</span>
<span class="line-removed">-     private static final int opc_invokespecial          = 183;</span>
<span class="line-removed">-     private static final int opc_invokestatic           = 184;</span>
<span class="line-removed">-     private static final int opc_invokeinterface        = 185;</span>
<span class="line-removed">-     private static final int opc_new                    = 187;</span>
<span class="line-removed">- //  private static final int opc_newarray               = 188;</span>
<span class="line-removed">-     private static final int opc_anewarray              = 189;</span>
<span class="line-removed">- //  private static final int opc_arraylength            = 190;</span>
<span class="line-removed">-     private static final int opc_athrow                 = 191;</span>
<span class="line-removed">-     private static final int opc_checkcast              = 192;</span>
<span class="line-removed">- //  private static final int opc_instanceof             = 193;</span>
<span class="line-removed">- //  private static final int opc_monitorenter           = 194;</span>
<span class="line-removed">- //  private static final int opc_monitorexit            = 195;</span>
<span class="line-removed">-     private static final int opc_wide                   = 196;</span>
<span class="line-removed">- //  private static final int opc_multianewarray         = 197;</span>
<span class="line-removed">- //  private static final int opc_ifnull                 = 198;</span>
<span class="line-removed">- //  private static final int opc_ifnonnull              = 199;</span>
<span class="line-removed">- //  private static final int opc_goto_w                 = 200;</span>
<span class="line-removed">- //  private static final int opc_jsr_w                  = 201;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // end of constants copied from sun.tools.java.RuntimeConstants</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** name of the superclass of proxy classes */</span>
<span class="line-removed">-     private static final String superclassName = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** name of field for storing a proxy instance&#39;s invocation handler */</span>
<span class="line-removed">-     private static final String handlerFieldName = &quot;h&quot;;</span>
  
<span class="line-modified">!     /** debugging flag for saving generated class files */</span>
<span class="line-modified">!     private static final boolean saveGeneratedFiles =</span>
<span class="line-modified">!         java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!             new GetBooleanAction(</span>
<span class="line-modified">!                 &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;)).booleanValue();</span>
  
      /**
<span class="line-modified">!      * Generate a public proxy class given a name and a list of proxy interfaces.</span>
       */
<span class="line-modified">!     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed">-                                      Class&lt;?&gt;[] interfaces) {</span>
<span class="line-removed">-         return generateProxyClass(name, interfaces, (ACC_PUBLIC | ACC_FINAL | ACC_SUPER));</span>
<span class="line-removed">-     }</span>
  
      /**
<span class="line-modified">!      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param name        the class name of the proxy class</span>
<span class="line-removed">-      * @param interfaces  proxy interfaces</span>
<span class="line-removed">-      * @param accessFlags access flags of the proxy class</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed">-                                      Class&lt;?&gt;[] interfaces,</span>
<span class="line-removed">-                                      int accessFlags)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);</span>
<span class="line-removed">-         final byte[] classFile = gen.generateClassFile();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (saveGeneratedFiles) {</span>
              java.security.AccessController.doPrivileged(
<span class="line-modified">!             new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!                 public Void run() {</span>
<span class="line-removed">-                     try {</span>
<span class="line-removed">-                         int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-removed">-                         Path path;</span>
<span class="line-removed">-                         if (i &gt; 0) {</span>
<span class="line-removed">-                             Path dir = Path.of(name.substring(0, i).replace(&#39;.&#39;, File.separatorChar));</span>
<span class="line-removed">-                             Files.createDirectories(dir);</span>
<span class="line-removed">-                             path = dir.resolve(name.substring(i+1, name.length()) + &quot;.class&quot;);</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         Files.write(path, classFile);</span>
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     } catch (IOException e) {</span>
<span class="line-removed">-                         throw new InternalError(</span>
<span class="line-removed">-                             &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return classFile;</span>
<span class="line-modified">!     }</span>
  
<span class="line-removed">-     /* preloaded Method objects for methods in java.lang.Object */</span>
<span class="line-removed">-     private static Method hashCodeMethod;</span>
<span class="line-removed">-     private static Method equalsMethod;</span>
<span class="line-removed">-     private static Method toStringMethod;</span>
      static {
          try {
<span class="line-modified">!             hashCodeMethod = Object.class.getMethod(&quot;hashCode&quot;);</span>
<span class="line-modified">!             equalsMethod =</span>
<span class="line-modified">!                 Object.class.getMethod(&quot;equals&quot;, new Class&lt;?&gt;[] { Object.class });</span>
<span class="line-removed">-             toStringMethod = Object.class.getMethod(&quot;toString&quot;);</span>
          } catch (NoSuchMethodException e) {
              throw new NoSuchMethodError(e.getMessage());
          }
      }
  
<span class="line-modified">!     /** name of proxy class */</span>
<span class="line-modified">!     private String className;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /** proxy interfaces */</span>
<span class="line-removed">-     private Class&lt;?&gt;[] interfaces;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** proxy class access flags */</span>
<span class="line-removed">-     private int accessFlags;</span>
  
<span class="line-modified">!     /** constant pool of class being generated */</span>
<span class="line-modified">!     private ConstantPool cp = new ConstantPool();</span>
  
<span class="line-modified">!     /** FieldInfo struct for each field of generated class */</span>
<span class="line-modified">!     private List&lt;FieldInfo&gt; fields = new ArrayList&lt;&gt;();</span>
  
<span class="line-modified">!     /** MethodInfo struct for each method of generated class */</span>
<span class="line-modified">!     private List&lt;MethodInfo&gt; methods = new ArrayList&lt;&gt;();</span>
  
      /**
<span class="line-modified">!      * maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified">!      * proxy methods with that signature</span>
       */
<span class="line-modified">!     private Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new HashMap&lt;&gt;();</span>
  
<span class="line-modified">!     /** count of ProxyMethod objects added to proxyMethods */</span>
<span class="line-modified">!     private int proxyMethodCount = 0;</span>
  
      /**
       * Construct a ProxyGenerator to generate a proxy class with the
       * specified name and for the given interfaces.
<span class="line-modified">!      *</span>
       * A ProxyGenerator object contains the state for the ongoing
       * generation of a particular proxy class.
       */
<span class="line-modified">!     private ProxyGenerator(String className, Class&lt;?&gt;[] interfaces, int accessFlags) {</span>
          this.className = className;
          this.interfaces = interfaces;
          this.accessFlags = accessFlags;
      }
  
      /**
<span class="line-modified">!      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified">!      * class file generation process.</span>
       */
<span class="line-modified">!     private byte[] generateClassFile() {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /* ============================================================</span>
<span class="line-modified">!          * Step 1: Assemble ProxyMethod objects for all methods to</span>
<span class="line-modified">!          * generate proxy dispatching code for.</span>
<span class="line-modified">!          */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Record that proxy methods are needed for the hashCode, equals,</span>
<span class="line-removed">-          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-removed">-          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-removed">-          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-removed">-          * proxy interfaces.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         addProxyMethod(hashCodeMethod, Object.class);</span>
<span class="line-removed">-         addProxyMethod(equalsMethod, Object.class);</span>
<span class="line-removed">-         addProxyMethod(toStringMethod, Object.class);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Now record all of the methods from the proxy interfaces, giving</span>
<span class="line-removed">-          * earlier interfaces precedence over later ones with duplicate</span>
<span class="line-removed">-          * methods.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed">-             for (Method m : intf.getMethods()) {</span>
<span class="line-removed">-                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-removed">-                     addProxyMethod(m, intf);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * For each set of proxy methods with the same signature,</span>
<span class="line-removed">-          * verify that the methods&#39; return types are compatible.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed">-             checkReturnTypes(sigmethods);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /* ============================================================</span>
<span class="line-removed">-          * Step 2: Assemble FieldInfo and MethodInfo structs for all of</span>
<span class="line-removed">-          * fields and methods in the class we are generating.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             methods.add(generateConstructor());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed">-                 for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     // add static field for method&#39;s Method object</span>
<span class="line-removed">-                     fields.add(new FieldInfo(pm.methodFieldName,</span>
<span class="line-removed">-                         &quot;Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-removed">-                          ACC_PRIVATE | ACC_STATIC));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     // generate code for proxy method and add it</span>
<span class="line-removed">-                     methods.add(pm.generateMethod());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             methods.add(generateStaticInitializer());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         } catch (IOException e) {</span>
<span class="line-removed">-             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (methods.size() &gt; 65535) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (fields.size() &gt; 65535) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /* ============================================================</span>
<span class="line-removed">-          * Step 3: Write the final class file.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed">-          * following items before starting to write the final class file.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         cp.getClass(dotToSlash(className));</span>
<span class="line-removed">-         cp.getClass(superclassName);</span>
<span class="line-removed">-         for (Class&lt;?&gt; intf: interfaces) {</span>
<span class="line-removed">-             cp.getClass(dotToSlash(intf.getName()));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * Disallow new constant pool additions beyond this point, since</span>
<span class="line-removed">-          * we are about to write the final constant pool table.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         cp.setReadOnly();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-removed">-         DataOutputStream dout = new DataOutputStream(bout);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * Write all the items of the &quot;ClassFile&quot; structure.</span>
<span class="line-removed">-              * See JVMS section 4.1.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-                                         // u4 magic;</span>
<span class="line-removed">-             dout.writeInt(0xCAFEBABE);</span>
<span class="line-removed">-                                         // u2 minor_version;</span>
<span class="line-removed">-             dout.writeShort(CLASSFILE_MINOR_VERSION);</span>
<span class="line-removed">-                                         // u2 major_version;</span>
<span class="line-removed">-             dout.writeShort(CLASSFILE_MAJOR_VERSION);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             cp.write(dout);             // (write constant pool)</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                         // u2 access_flags;</span>
<span class="line-removed">-             dout.writeShort(accessFlags);</span>
<span class="line-removed">-                                         // u2 this_class;</span>
<span class="line-removed">-             dout.writeShort(cp.getClass(dotToSlash(className)));</span>
<span class="line-removed">-                                         // u2 super_class;</span>
<span class="line-removed">-             dout.writeShort(cp.getClass(superclassName));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                         // u2 interfaces_count;</span>
<span class="line-removed">-             dout.writeShort(interfaces.length);</span>
<span class="line-removed">-                                         // u2 interfaces[interfaces_count];</span>
<span class="line-removed">-             for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed">-                 dout.writeShort(cp.getClass(</span>
<span class="line-removed">-                     dotToSlash(intf.getName())));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                         // u2 fields_count;</span>
<span class="line-removed">-             dout.writeShort(fields.size());</span>
<span class="line-removed">-                                         // field_info fields[fields_count];</span>
<span class="line-removed">-             for (FieldInfo f : fields) {</span>
<span class="line-removed">-                 f.write(dout);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                         // u2 methods_count;</span>
<span class="line-removed">-             dout.writeShort(methods.size());</span>
<span class="line-removed">-                                         // method_info methods[methods_count];</span>
<span class="line-removed">-             for (MethodInfo m : methods) {</span>
<span class="line-removed">-                 m.write(dout);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                          // u2 attributes_count;</span>
<span class="line-removed">-             dout.writeShort(0); // (no ClassFile attributes for proxy classes)</span>
  
<span class="line-modified">!         } catch (IOException e) {</span>
<span class="line-modified">!             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>
          }
  
<span class="line-modified">!         return bout.toByteArray();</span>
      }
  
      /**
<span class="line-modified">!      * Add another method to be proxied, either by creating a new</span>
<span class="line-removed">-      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-removed">-      * method.</span>
       *
<span class="line-modified">!      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-modified">!      * found through, which may be different from (a subinterface of)</span>
<span class="line-removed">-      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-removed">-      * object passed for a given name and descriptor identifies the</span>
<span class="line-removed">-      * Method object (and thus the declaring class) that will be</span>
<span class="line-removed">-      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-removed">-      * set of duplicate methods.</span>
       */
<span class="line-modified">!     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-modified">!         String name = m.getName();</span>
<span class="line-modified">!         Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span>
<span class="line-modified">!         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-modified">!         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         String sig = name + getParameterDescriptors(parameterTypes);</span>
<span class="line-modified">!         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.get(sig);</span>
<span class="line-removed">-         if (sigmethods != null) {</span>
<span class="line-removed">-             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed">-                 if (returnType == pm.returnType) {</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * Found a match: reduce exception types to the</span>
<span class="line-removed">-                      * greatest set of exceptions that can thrown</span>
<span class="line-removed">-                      * compatibly with the throws clauses of both</span>
<span class="line-removed">-                      * overridden methods.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-                     collectCompatibleTypes(</span>
<span class="line-removed">-                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-removed">-                     collectCompatibleTypes(</span>
<span class="line-removed">-                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-removed">-                     pm.exceptionTypes = new Class&lt;?&gt;[legalExceptions.size()];</span>
<span class="line-removed">-                     pm.exceptionTypes =</span>
<span class="line-removed">-                         legalExceptions.toArray(pm.exceptionTypes);</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             sigmethods = new ArrayList&lt;&gt;(3);</span>
<span class="line-removed">-             proxyMethods.put(sig, sigmethods);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         sigmethods.add(new ProxyMethod(name, parameterTypes, returnType,</span>
<span class="line-removed">-                                        exceptionTypes, fromClass));</span>
      }
  
      /**
       * For a given set of proxy methods with the same signature, check
       * that their return types are compatible according to the Proxy
<span class="line-new-header">--- 23,195 ---</span>
   * questions.
   */
  
  package java.lang.reflect;
  
<span class="line-modified">! import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-modified">! import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-modified">! import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-added">+ import jdk.internal.org.objectweb.asm.Opcodes;</span>
<span class="line-added">+ import sun.security.action.GetBooleanAction;</span>
<span class="line-added">+ </span>
  import java.io.IOException;
<span class="line-modified">! import java.lang.invoke.MethodType;</span>
  import java.nio.file.Files;
  import java.nio.file.Path;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Arrays;</span>
  import java.util.HashMap;
<span class="line-added">+ import java.util.LinkedHashMap;</span>
  import java.util.LinkedList;
  import java.util.List;
  import java.util.ListIterator;
  import java.util.Map;
<span class="line-modified">! </span>
<span class="line-added">+ import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  
  /**
   * ProxyGenerator contains the code to generate a dynamic proxy class
   * for the java.lang.reflect.Proxy API.
<span class="line-modified">!  * &lt;p&gt;</span>
<span class="line-modified">!  * The external interface to ProxyGenerator is the static</span>
   * &quot;generateProxyClass&quot; method.
   */
<span class="line-modified">! final class ProxyGenerator extends ClassWriter {</span>
  
<span class="line-modified">!     private static final String JL_CLASS = &quot;java/lang/Class&quot;;</span>
<span class="line-modified">!     private static final String JL_OBJECT = &quot;java/lang/Object&quot;;</span>
<span class="line-modified">!     private static final String JL_THROWABLE = &quot;java/lang/Throwable&quot;;</span>
<span class="line-added">+     private static final String JL_CLASS_NOT_FOUND_EX = &quot;java/lang/ClassNotFoundException&quot;;</span>
<span class="line-added">+     private static final String JL_NO_CLASS_DEF_FOUND_ERROR = &quot;java/lang/NoClassDefFoundError&quot;;</span>
<span class="line-added">+     private static final String JL_NO_SUCH_METHOD_EX = &quot;java/lang/NoSuchMethodException&quot;;</span>
<span class="line-added">+     private static final String JL_NO_SUCH_METHOD_ERROR = &quot;java/lang/NoSuchMethodError&quot;;</span>
  
<span class="line-modified">!     private static final String JLR_INVOCATION_HANDLER = &quot;java/lang/reflect/InvocationHandler&quot;;</span>
<span class="line-modified">!     private static final String JLR_PROXY = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-modified">!     private static final String JLR_UNDECLARED_THROWABLE_EX = &quot;java/lang/reflect/UndeclaredThrowableException&quot;;</span>
  
<span class="line-modified">!     private static final String LJL_CLASS = &quot;Ljava/lang/Class;&quot;;</span>
<span class="line-modified">!     private static final String LJLR_METHOD = &quot;Ljava/lang/reflect/Method;&quot;;</span>
<span class="line-modified">!     private static final String LJLR_INVOCATION_HANDLER = &quot;Ljava/lang/reflect/InvocationHandler;&quot;;</span>
  
<span class="line-modified">!     private static final String MJLR_INVOCATIONHANDLER = &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;</span>
<span class="line-modified">!     private static final String NAME_CLINIT = &quot;&lt;clinit&gt;&quot;;</span>
<span class="line-modified">! </span>
<span class="line-added">+     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>
  
      /**
<span class="line-modified">!      * name of field for storing a proxy instance&#39;s invocation handler</span>
       */
<span class="line-modified">!     private static final String handlerFieldName = &quot;h&quot;;</span>
  
      /**
<span class="line-modified">!      * debugging flag for saving generated class files</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static final boolean saveGeneratedFiles =</span>
              java.security.AccessController.doPrivileged(
<span class="line-modified">!                     new GetBooleanAction(</span>
<span class="line-modified">!                             &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;));</span>
  
<span class="line-modified">!     /* Preloaded ProxyMethod objects for methods in java.lang.Object */</span>
<span class="line-modified">!     private final static ProxyMethod hashCodeMethod;</span>
<span class="line-added">+     private final static ProxyMethod equalsMethod;</span>
<span class="line-added">+     private final static ProxyMethod toStringMethod;</span>
  
      static {
          try {
<span class="line-modified">!             hashCodeMethod = new ProxyMethod(Object.class.getMethod(&quot;hashCode&quot;), &quot;m0&quot;);</span>
<span class="line-modified">!             equalsMethod = new ProxyMethod(Object.class.getMethod(&quot;equals&quot;, Object.class), &quot;m1&quot;);</span>
<span class="line-modified">!             toStringMethod = new ProxyMethod(Object.class.getMethod(&quot;toString&quot;), &quot;m2&quot;);</span>
          } catch (NoSuchMethodException e) {
              throw new NoSuchMethodError(e.getMessage());
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Class loader</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private final ClassLoader loader;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Name of proxy class</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final String className;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Proxy interfaces</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final List&lt;Class&lt;?&gt;&gt; interfaces;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Proxy class access flags</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final int accessFlags;</span>
  
      /**
<span class="line-modified">!      * Maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified">!      * proxy methods with that signature.</span>
<span class="line-added">+      * Kept in insertion order to make it easier to compare old and new.</span>
       */
<span class="line-modified">!     private final Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new LinkedHashMap&lt;&gt;();</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Ordinal of next ProxyMethod object added to proxyMethods.</span>
<span class="line-added">+      * Indexes are reserved for hashcode(0), equals(1), toString(2).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int proxyMethodCount = 3;</span>
  
      /**
       * Construct a ProxyGenerator to generate a proxy class with the
       * specified name and for the given interfaces.
<span class="line-modified">!      * &lt;p&gt;</span>
       * A ProxyGenerator object contains the state for the ongoing
       * generation of a particular proxy class.
       */
<span class="line-modified">!     private ProxyGenerator(ClassLoader loader, String className, List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-added">+                            int accessFlags) {</span>
<span class="line-added">+         super(ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-added">+         this.loader = loader;</span>
          this.className = className;
          this.interfaces = interfaces;
          this.accessFlags = accessFlags;
      }
  
      /**
<span class="line-modified">!      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * @param name        the class name of the proxy class</span>
<span class="line-added">+      * @param interfaces  proxy interfaces</span>
<span class="line-added">+      * @param accessFlags access flags of the proxy class</span>
       */
<span class="line-modified">!     static byte[] generateProxyClass(ClassLoader loader,</span>
<span class="line-modified">!                                      final String name,</span>
<span class="line-modified">!                                      List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-modified">!                                      int accessFlags) {</span>
<span class="line-modified">!         ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);</span>
<span class="line-modified">!         final byte[] classFile = gen.generateClassFile();</span>
  
<span class="line-modified">!         if (saveGeneratedFiles) {</span>
<span class="line-modified">!             java.security.AccessController.doPrivileged(</span>
<span class="line-added">+                     new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-added">+                         public Void run() {</span>
<span class="line-added">+                             try {</span>
<span class="line-added">+                                 int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-added">+                                 Path path;</span>
<span class="line-added">+                                 if (i &gt; 0) {</span>
<span class="line-added">+                                     Path dir = Path.of(dotToSlash(name.substring(0, i)));</span>
<span class="line-added">+                                     Files.createDirectories(dir);</span>
<span class="line-added">+                                     path = dir.resolve(name.substring(i + 1) + &quot;.class&quot;);</span>
<span class="line-added">+                                 } else {</span>
<span class="line-added">+                                     path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 Files.write(path, classFile);</span>
<span class="line-added">+                                 return null;</span>
<span class="line-added">+                             } catch (IOException e) {</span>
<span class="line-added">+                                 throw new InternalError(</span>
<span class="line-added">+                                         &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     });</span>
          }
  
<span class="line-modified">!         return classFile;</span>
      }
  
      /**
<span class="line-modified">!      * Return an array of the type names from an array of Classes.</span>
       *
<span class="line-modified">!      * @param classes an array of classes or interfaces</span>
<span class="line-modified">!      * @return the array of class names; or null if there are no classes</span>
       */
<span class="line-modified">!     private static String[] typeNames(List&lt;Class&lt;?&gt;&gt; classes) {</span>
<span class="line-modified">!         if (classes == null || classes.size() == 0)</span>
<span class="line-modified">!             return null;</span>
<span class="line-modified">!         int size = classes.size();</span>
<span class="line-modified">!         String[] ifaces = new String[size];</span>
<span class="line-modified">!         for (int i = 0; i &lt; size; i++)</span>
<span class="line-modified">!             ifaces[i] = dotToSlash(classes.get(i).getName());</span>
<span class="line-modified">!         return ifaces;</span>
      }
  
      /**
       * For a given set of proxy methods with the same signature, check
       * that their return types are compatible according to the Proxy
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,20 ***</span>
           * List of return types that are not yet known to be
           * assignable from (&quot;covered&quot; by) any of the others.
           */
          LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
  
<span class="line-modified">!     nextNewReturnType:</span>
          for (ProxyMethod pm : methods) {
              Class&lt;?&gt; newReturnType = pm.returnType;
              if (newReturnType.isPrimitive()) {
                  throw new IllegalArgumentException(
<span class="line-modified">!                     &quot;methods with same signature &quot; +</span>
<span class="line-modified">!                     getFriendlyMethodSignature(pm.methodName,</span>
<span class="line-modified">!                                                pm.parameterTypes) +</span>
<span class="line-modified">!                     &quot; but incompatible return types: &quot; +</span>
<span class="line-removed">-                     newReturnType.getName() + &quot; and others&quot;);</span>
              }
              boolean added = false;
  
              /*
               * Compare the new return type to the existing uncovered
<span class="line-new-header">--- 235,19 ---</span>
           * List of return types that are not yet known to be
           * assignable from (&quot;covered&quot; by) any of the others.
           */
          LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
  
<span class="line-modified">!         nextNewReturnType:</span>
          for (ProxyMethod pm : methods) {
              Class&lt;?&gt; newReturnType = pm.returnType;
              if (newReturnType.isPrimitive()) {
                  throw new IllegalArgumentException(
<span class="line-modified">!                         &quot;methods with same signature &quot; +</span>
<span class="line-modified">!                                 pm.shortSignature +</span>
<span class="line-modified">!                                 &quot; but incompatible return types: &quot; +</span>
<span class="line-modified">!                                 newReturnType.getName() + &quot; and others&quot;);</span>
              }
              boolean added = false;
  
              /*
               * Compare the new return type to the existing uncovered
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,1326 ***</span>
           * not assignable from any of the others.
           */
          if (uncoveredReturnTypes.size() &gt; 1) {
              ProxyMethod pm = methods.get(0);
              throw new IllegalArgumentException(
<span class="line-modified">!                 &quot;methods with same signature &quot; +</span>
<span class="line-modified">!                 getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) +</span>
<span class="line-modified">!                 &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
          }
      }
  
      /**
<span class="line-modified">!      * A FieldInfo object contains information about a particular field</span>
<span class="line-modified">!      * in the class being generated.  The class mirrors the data items of</span>
<span class="line-modified">!      * the &quot;field_info&quot; structure of the class file format (see JVMS 4.5).</span>
       */
<span class="line-modified">!     private class FieldInfo {</span>
<span class="line-modified">!         public int accessFlags;</span>
<span class="line-modified">!         public String name;</span>
<span class="line-removed">-         public String descriptor;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public FieldInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed">-             this.name = name;</span>
<span class="line-removed">-             this.descriptor = descriptor;</span>
<span class="line-removed">-             this.accessFlags = accessFlags;</span>
  
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed">-              * following items before starting to write the final class file.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             cp.getUtf8(name);</span>
<span class="line-removed">-             cp.getUtf8(descriptor);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         public void write(DataOutputStream out) throws IOException {</span>
              /*
<span class="line-modified">!              * Write all the items of the &quot;field_info&quot; structure.</span>
<span class="line-modified">!              * See JVMS section 4.5.</span>
               */
<span class="line-modified">!                                         // u2 access_flags;</span>
<span class="line-modified">!             out.writeShort(accessFlags);</span>
<span class="line-modified">!                                         // u2 name_index;</span>
<span class="line-modified">!             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified">!                                         // u2 descriptor_index;</span>
<span class="line-modified">!             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified">!                                         // u2 attributes_count;</span>
<span class="line-modified">!             out.writeShort(0);  // (no field_info attributes for proxy classes)</span>
          }
      }
  
      /**
<span class="line-modified">!      * An ExceptionTableEntry object holds values for the data items of</span>
<span class="line-modified">!      * an entry in the &quot;exception_table&quot; item of the &quot;Code&quot; attribute of</span>
<span class="line-modified">!      * &quot;method_info&quot; structures (see JVMS 4.7.3).</span>
       */
<span class="line-modified">!     private static class ExceptionTableEntry {</span>
<span class="line-modified">!         public short startPc;</span>
<span class="line-modified">!         public short endPc;</span>
<span class="line-removed">-         public short handlerPc;</span>
<span class="line-removed">-         public short catchType;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public ExceptionTableEntry(short startPc, short endPc,</span>
<span class="line-removed">-                                    short handlerPc, short catchType)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             this.startPc = startPc;</span>
<span class="line-removed">-             this.endPc = endPc;</span>
<span class="line-removed">-             this.handlerPc = handlerPc;</span>
<span class="line-removed">-             this.catchType = catchType;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     };</span>
  
      /**
<span class="line-modified">!      * A MethodInfo object contains information about a particular method</span>
<span class="line-modified">!      * in the class being generated.  This class mirrors the data items of</span>
<span class="line-modified">!      * the &quot;method_info&quot; structure of the class file format (see JVMS 4.6).</span>
       */
<span class="line-modified">!     private class MethodInfo {</span>
<span class="line-modified">!         public int accessFlags;</span>
<span class="line-modified">!         public String name;</span>
<span class="line-modified">!         public String descriptor;</span>
<span class="line-modified">!         public short maxStack;</span>
<span class="line-removed">-         public short maxLocals;</span>
<span class="line-removed">-         public ByteArrayOutputStream code = new ByteArrayOutputStream();</span>
<span class="line-removed">-         public List&lt;ExceptionTableEntry&gt; exceptionTable =</span>
<span class="line-removed">-             new ArrayList&lt;ExceptionTableEntry&gt;();</span>
<span class="line-removed">-         public short[] declaredExceptions;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public MethodInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed">-             this.name = name;</span>
<span class="line-removed">-             this.descriptor = descriptor;</span>
<span class="line-removed">-             this.accessFlags = accessFlags;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed">-              * following items before starting to write the final class file.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             cp.getUtf8(name);</span>
<span class="line-removed">-             cp.getUtf8(descriptor);</span>
<span class="line-removed">-             cp.getUtf8(&quot;Code&quot;);</span>
<span class="line-removed">-             cp.getUtf8(&quot;Exceptions&quot;);</span>
          }
  
<span class="line-modified">!         public void write(DataOutputStream out) throws IOException {</span>
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * Write all the items of the &quot;method_info&quot; structure.</span>
<span class="line-modified">!              * See JVMS section 4.6.</span>
<span class="line-modified">!              */</span>
<span class="line-modified">!                                         // u2 access_flags;</span>
<span class="line-modified">!             out.writeShort(accessFlags);</span>
<span class="line-modified">!                                         // u2 name_index;</span>
<span class="line-modified">!             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified">!                                         // u2 descriptor_index;</span>
<span class="line-modified">!             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified">!                                         // u2 attributes_count;</span>
<span class="line-modified">!             out.writeShort(2);  // (two method_info attributes:)</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Write &quot;Code&quot; attribute. See JVMS section 4.7.3.</span>
<span class="line-modified">! </span>
<span class="line-modified">!                                         // u2 attribute_name_index;</span>
<span class="line-modified">!             out.writeShort(cp.getUtf8(&quot;Code&quot;));</span>
<span class="line-modified">!                                         // u4 attribute_length;</span>
<span class="line-modified">!             out.writeInt(12 + code.size() + 8 * exceptionTable.size());</span>
<span class="line-removed">-                                         // u2 max_stack;</span>
<span class="line-removed">-             out.writeShort(maxStack);</span>
<span class="line-removed">-                                         // u2 max_locals;</span>
<span class="line-removed">-             out.writeShort(maxLocals);</span>
<span class="line-removed">-                                         // u2 code_length;</span>
<span class="line-removed">-             out.writeInt(code.size());</span>
<span class="line-removed">-                                         // u1 code[code_length];</span>
<span class="line-removed">-             code.writeTo(out);</span>
<span class="line-removed">-                                         // u2 exception_table_length;</span>
<span class="line-removed">-             out.writeShort(exceptionTable.size());</span>
<span class="line-removed">-             for (ExceptionTableEntry e : exceptionTable) {</span>
<span class="line-removed">-                                         // u2 start_pc;</span>
<span class="line-removed">-                 out.writeShort(e.startPc);</span>
<span class="line-removed">-                                         // u2 end_pc;</span>
<span class="line-removed">-                 out.writeShort(e.endPc);</span>
<span class="line-removed">-                                         // u2 handler_pc;</span>
<span class="line-removed">-                 out.writeShort(e.handlerPc);</span>
<span class="line-removed">-                                         // u2 catch_type;</span>
<span class="line-removed">-                 out.writeShort(e.catchType);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                                         // u2 attributes_count;</span>
<span class="line-removed">-             out.writeShort(0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // write &quot;Exceptions&quot; attribute.  See JVMS section 4.7.4.</span>
<span class="line-removed">- </span>
<span class="line-removed">-                                         // u2 attribute_name_index;</span>
<span class="line-removed">-             out.writeShort(cp.getUtf8(&quot;Exceptions&quot;));</span>
<span class="line-removed">-                                         // u4 attributes_length;</span>
<span class="line-removed">-             out.writeInt(2 + 2 * declaredExceptions.length);</span>
<span class="line-removed">-                                         // u2 number_of_exceptions;</span>
<span class="line-removed">-             out.writeShort(declaredExceptions.length);</span>
<span class="line-removed">-                         // u2 exception_index_table[number_of_exceptions];</span>
<span class="line-removed">-             for (short value : declaredExceptions) {</span>
<span class="line-removed">-                 out.writeShort(value);</span>
              }
          }
<span class="line-removed">- </span>
      }
  
      /**
<span class="line-modified">!      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified">!      * being generated: a method whose implementation will encode and</span>
<span class="line-modified">!      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>
       */
<span class="line-modified">!     private class ProxyMethod {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         public String methodName;</span>
<span class="line-removed">-         public Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-removed">-         public Class&lt;?&gt; returnType;</span>
<span class="line-removed">-         public Class&lt;?&gt;[] exceptionTypes;</span>
<span class="line-removed">-         public Class&lt;?&gt; fromClass;</span>
<span class="line-removed">-         public String methodFieldName;</span>
  
<span class="line-modified">!         private ProxyMethod(String methodName, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-modified">!                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-modified">!                             Class&lt;?&gt; fromClass)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             this.methodName = methodName;</span>
<span class="line-modified">!             this.parameterTypes = parameterTypes;</span>
<span class="line-modified">!             this.returnType = returnType;</span>
<span class="line-removed">-             this.exceptionTypes = exceptionTypes;</span>
<span class="line-removed">-             this.fromClass = fromClass;</span>
<span class="line-removed">-             this.methodFieldName = &quot;m&quot; + proxyMethodCount++;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Return a MethodInfo object for this method, including generating</span>
<span class="line-modified">!          * the code and exception table entry.</span>
           */
<span class="line-modified">!         private MethodInfo generateMethod() throws IOException {</span>
<span class="line-modified">!             String desc = getMethodDescriptor(parameterTypes, returnType);</span>
<span class="line-modified">!             MethodInfo minfo = new MethodInfo(methodName, desc,</span>
<span class="line-removed">-                 ACC_PUBLIC | ACC_FINAL);</span>
  
<span class="line-modified">!             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-modified">!             int nextSlot = 1;</span>
<span class="line-modified">!             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-modified">!                 parameterSlot[i] = nextSlot;</span>
<span class="line-modified">!                 nextSlot += getWordsPerType(parameterTypes[i]);</span>
              }
<span class="line-modified">!             int localSlot0 = nextSlot;</span>
<span class="line-removed">-             short pc, tryBegin = 0, tryEnd;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             code_aload(0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             out.writeByte(opc_getfield);</span>
<span class="line-removed">-             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">-                 superclassName,</span>
<span class="line-removed">-                 handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));</span>
  
<span class="line-modified">!             code_aload(0, out);</span>
  
<span class="line-modified">!             out.writeByte(opc_getstatic);</span>
<span class="line-removed">-             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">-                 dotToSlash(className),</span>
<span class="line-removed">-                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
  
<span class="line-modified">!             if (parameterTypes.length &gt; 0) {</span>
  
<span class="line-modified">!                 code_ipush(parameterTypes.length, out);</span>
  
<span class="line-modified">!                 out.writeByte(opc_anewarray);</span>
<span class="line-removed">-                 out.writeShort(cp.getClass(&quot;java/lang/Object&quot;));</span>
  
<span class="line-modified">!                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
  
<span class="line-modified">!                     out.writeByte(opc_dup);</span>
  
<span class="line-modified">!                     code_ipush(i, out);</span>
  
<span class="line-modified">!                     codeWrapArgument(parameterTypes[i], parameterSlot[i], out);</span>
  
<span class="line-modified">!                     out.writeByte(opc_aastore);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else {</span>
  
<span class="line-modified">!                 out.writeByte(opc_aconst_null);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             out.writeByte(opc_invokeinterface);</span>
<span class="line-modified">!             out.writeShort(cp.getInterfaceMethodRef(</span>
<span class="line-modified">!                 &quot;java/lang/reflect/InvocationHandler&quot;,</span>
<span class="line-modified">!                 &quot;invoke&quot;,</span>
<span class="line-modified">!                 &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-modified">!                     &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;));</span>
<span class="line-removed">-             out.writeByte(4);</span>
<span class="line-removed">-             out.writeByte(0);</span>
  
<span class="line-modified">!             if (returnType == void.class) {</span>
  
<span class="line-modified">!                 out.writeByte(opc_pop);</span>
  
<span class="line-modified">!                 out.writeByte(opc_return);</span>
  
<span class="line-modified">!             } else {</span>
  
<span class="line-modified">!                 codeUnwrapReturnValue(returnType, out);</span>
              }
  
<span class="line-modified">!             tryEnd = pc = (short) minfo.code.size();</span>
  
              List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
              if (catchList.size() &gt; 0) {
<span class="line-removed">- </span>
                  for (Class&lt;?&gt; ex : catchList) {
<span class="line-modified">!                     minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-modified">!                         tryBegin, tryEnd, pc,</span>
<span class="line-removed">-                         cp.getClass(dotToSlash(ex.getName()))));</span>
                  }
  
<span class="line-modified">!                 out.writeByte(opc_athrow);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 pc = (short) minfo.code.size();</span>
<span class="line-modified">! </span>
<span class="line-removed">-                 minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">-                     tryBegin, tryEnd, pc, cp.getClass(&quot;java/lang/Throwable&quot;)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 code_astore(localSlot0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 out.writeByte(opc_new);</span>
<span class="line-removed">-                 out.writeShort(cp.getClass(</span>
<span class="line-removed">-                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 out.writeByte(opc_dup);</span>
  
<span class="line-modified">!                 code_aload(localSlot0, out);</span>
  
<span class="line-modified">!                 out.writeByte(opc_invokespecial);</span>
  
<span class="line-modified">!                 out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">!                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;,</span>
<span class="line-modified">!                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;));</span>
  
<span class="line-modified">!                 out.writeByte(opc_athrow);</span>
              }
  
<span class="line-modified">!             if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">-                 throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             minfo.maxStack = 10;</span>
<span class="line-modified">!             minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-modified">!             minfo.declaredExceptions = new short[exceptionTypes.length];</span>
<span class="line-removed">-             for (int i = 0; i &lt; exceptionTypes.length; i++) {</span>
<span class="line-removed">-                 minfo.declaredExceptions[i] = cp.getClass(</span>
<span class="line-removed">-                     dotToSlash(exceptionTypes[i].getName()));</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             return minfo;</span>
          }
  
          /**
           * Generate code for wrapping an argument of the given type
           * whose value can be found at the specified local variable
           * index, in order for it to be passed (as an Object) to the
<span class="line-modified">!          * invocation handler&#39;s &quot;invoke&quot; method.  The code is written</span>
<span class="line-removed">-          * to the supplied stream.</span>
           */
<span class="line-modified">!         private void codeWrapArgument(Class&lt;?&gt; type, int slot,</span>
<span class="line-removed">-                                       DataOutputStream out)</span>
<span class="line-removed">-             throws IOException</span>
<span class="line-removed">-         {</span>
              if (type.isPrimitive()) {
                  PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
  
                  if (type == int.class ||
<span class="line-modified">!                     type == boolean.class ||</span>
<span class="line-modified">!                     type == byte.class ||</span>
<span class="line-modified">!                     type == char.class ||</span>
<span class="line-modified">!                     type == short.class)</span>
<span class="line-modified">!                 {</span>
<span class="line-removed">-                     code_iload(slot, out);</span>
                  } else if (type == long.class) {
<span class="line-modified">!                     code_lload(slot, out);</span>
                  } else if (type == float.class) {
<span class="line-modified">!                     code_fload(slot, out);</span>
                  } else if (type == double.class) {
<span class="line-modified">!                     code_dload(slot, out);</span>
                  } else {
                      throw new AssertionError();
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 out.writeByte(opc_invokestatic);</span>
<span class="line-removed">-                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-                     prim.wrapperClassName,</span>
<span class="line-removed">-                     &quot;valueOf&quot;, prim.wrapperValueOfDesc));</span>
<span class="line-removed">- </span>
              } else {
<span class="line-modified">! </span>
<span class="line-removed">-                 code_aload(slot, out);</span>
              }
          }
  
          /**
           * Generate code for unwrapping a return value of the given
           * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<span class="line-modified">!          * Object) to its correct type.  The code is written to the</span>
<span class="line-removed">-          * supplied stream.</span>
           */
<span class="line-modified">!         private void codeUnwrapReturnValue(Class&lt;?&gt; type, DataOutputStream out)</span>
<span class="line-removed">-             throws IOException</span>
<span class="line-removed">-         {</span>
              if (type.isPrimitive()) {
                  PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
  
<span class="line-modified">!                 out.writeByte(opc_checkcast);</span>
<span class="line-modified">!                 out.writeShort(cp.getClass(prim.wrapperClassName));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">-                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-                     prim.wrapperClassName,</span>
<span class="line-removed">-                     prim.unwrapMethodName, prim.unwrapMethodDesc));</span>
  
                  if (type == int.class ||
<span class="line-modified">!                     type == boolean.class ||</span>
<span class="line-modified">!                     type == byte.class ||</span>
<span class="line-modified">!                     type == char.class ||</span>
<span class="line-modified">!                     type == short.class)</span>
<span class="line-modified">!                 {</span>
<span class="line-removed">-                     out.writeByte(opc_ireturn);</span>
                  } else if (type == long.class) {
<span class="line-modified">!                     out.writeByte(opc_lreturn);</span>
                  } else if (type == float.class) {
<span class="line-modified">!                     out.writeByte(opc_freturn);</span>
                  } else if (type == double.class) {
<span class="line-modified">!                     out.writeByte(opc_dreturn);</span>
                  } else {
                      throw new AssertionError();
                  }
<span class="line-removed">- </span>
              } else {
<span class="line-modified">! </span>
<span class="line-modified">!                 out.writeByte(opc_checkcast);</span>
<span class="line-removed">-                 out.writeShort(cp.getClass(dotToSlash(type.getName())));</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 out.writeByte(opc_areturn);</span>
              }
          }
  
          /**
           * Generate code for initializing the static field that stores
<span class="line-modified">!          * the Method object for this proxy method.  The code is written</span>
<span class="line-removed">-          * to the supplied stream.</span>
           */
<span class="line-modified">!         private void codeFieldInitialization(DataOutputStream out)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             codeClassForName(fromClass, out);</span>
  
<span class="line-modified">!             code_ldc(cp.getString(methodName), out);</span>
  
<span class="line-modified">!             code_ipush(parameterTypes.length, out);</span>
  
<span class="line-modified">!             out.writeByte(opc_anewarray);</span>
<span class="line-removed">-             out.writeShort(cp.getClass(&quot;java/lang/Class&quot;));</span>
  
              for (int i = 0; i &lt; parameterTypes.length; i++) {
<span class="line-modified">! </span>
<span class="line-modified">!                 out.writeByte(opc_dup);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 code_ipush(i, out);</span>
  
                  if (parameterTypes[i].isPrimitive()) {
                      PrimitiveTypeInfo prim =
<span class="line-modified">!                         PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     out.writeByte(opc_getstatic);</span>
<span class="line-removed">-                     out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">-                         prim.wrapperClassName, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;));</span>
<span class="line-removed">- </span>
                  } else {
<span class="line-modified">!                     codeClassForName(parameterTypes[i], out);</span>
                  }
<span class="line-modified">! </span>
<span class="line-removed">-                 out.writeByte(opc_aastore);</span>
              }
  
<span class="line-modified">!             out.writeByte(opc_invokevirtual);</span>
<span class="line-modified">!             out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">!                 &quot;java/lang/Class&quot;,</span>
<span class="line-removed">-                 &quot;getMethod&quot;,</span>
<span class="line-removed">-                 &quot;(Ljava/lang/String;[Ljava/lang/Class;)&quot; +</span>
<span class="line-removed">-                 &quot;Ljava/lang/reflect/Method;&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             out.writeByte(opc_putstatic);</span>
<span class="line-removed">-             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">-                 dotToSlash(className),</span>
<span class="line-removed">-                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
          }
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Generate the constructor method for the proxy class.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private MethodInfo generateConstructor() throws IOException {</span>
<span class="line-removed">-         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">-             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,</span>
<span class="line-removed">-             ACC_PUBLIC);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         code_aload(0, out);</span>
  
<span class="line-modified">!         code_aload(1, out);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             superclassName,</span>
<span class="line-removed">-             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_return);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         minfo.maxStack = 10;</span>
<span class="line-removed">-         minfo.maxLocals = 2;</span>
<span class="line-removed">-         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return minfo;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Generate the static initializer method for the proxy class.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private MethodInfo generateStaticInitializer() throws IOException {</span>
<span class="line-removed">-         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">-             &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, ACC_STATIC);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int localSlot0 = 1;</span>
<span class="line-removed">-         short pc, tryBegin = 0, tryEnd;</span>
  
<span class="line-modified">!         DataOutputStream out = new DataOutputStream(minfo.code);</span>
  
<span class="line-modified">!         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-modified">!             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-modified">!                 pm.codeFieldInitialization(out);</span>
              }
          }
  
<span class="line-modified">!         out.writeByte(opc_return);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         tryEnd = pc = (short) minfo.code.size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">-             tryBegin, tryEnd, pc,</span>
<span class="line-removed">-             cp.getClass(&quot;java/lang/NoSuchMethodException&quot;)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         code_astore(localSlot0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_new);</span>
<span class="line-removed">-         out.writeShort(cp.getClass(&quot;java/lang/NoSuchMethodError&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_dup);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         code_aload(localSlot0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             &quot;java/lang/NoSuchMethodError&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_athrow);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         pc = (short) minfo.code.size();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">-             tryBegin, tryEnd, pc,</span>
<span class="line-removed">-             cp.getClass(&quot;java/lang/ClassNotFoundException&quot;)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         code_astore(localSlot0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_new);</span>
<span class="line-removed">-         out.writeShort(cp.getClass(&quot;java/lang/NoClassDefFoundError&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_dup);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         code_aload(localSlot0, out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             &quot;java/lang/NoClassDefFoundError&quot;,</span>
<span class="line-removed">-             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_athrow);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         minfo.maxStack = 10;</span>
<span class="line-removed">-         minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-removed">-         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return minfo;</span>
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified">!      */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * The following methods generate code for the load or store operation</span>
<span class="line-removed">-      * indicated by their name for the given local variable.  The code is</span>
<span class="line-removed">-      * written to the supplied stream.</span>
       */
  
<span class="line-modified">!     private void code_iload(int lvar, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void code_lload(int lvar, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void code_fload(int lvar, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     private void code_dload(int lvar, DataOutputStream out)</span>
<span class="line-modified">!         throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private void code_aload(int lvar, DataOutputStream out)</span>
<span class="line-modified">!         throws IOException</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">! //  private void code_istore(int lvar, DataOutputStream out)</span>
<span class="line-modified">! //      throws IOException</span>
<span class="line-removed">- //  {</span>
<span class="line-removed">- //      codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out);</span>
<span class="line-removed">- //  }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //  private void code_lstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">- //      throws IOException</span>
<span class="line-removed">- //  {</span>
<span class="line-removed">- //      codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out);</span>
<span class="line-removed">- //  }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //  private void code_fstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">- //      throws IOException</span>
<span class="line-removed">- //  {</span>
<span class="line-removed">- //      codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out);</span>
<span class="line-removed">- //  }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //  private void code_dstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">- //      throws IOException</span>
<span class="line-removed">- //  {</span>
<span class="line-removed">- //      codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out);</span>
<span class="line-removed">- //  }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void code_astore(int lvar, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate code for a load or store instruction for the given local</span>
<span class="line-removed">-      * variable.  The code is written to the supplied stream.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &quot;opcode&quot; indicates the opcode form of the desired load or store</span>
<span class="line-removed">-      * instruction that takes an explicit local variable index, and</span>
<span class="line-removed">-      * &quot;opcode_0&quot; indicates the corresponding form of the instruction</span>
<span class="line-removed">-      * with the implicit index 0.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private void codeLocalLoadStore(int lvar, int opcode, int opcode_0,</span>
<span class="line-removed">-                                     DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         assert lvar &gt;= 0 &amp;&amp; lvar &lt;= 0xFFFF;</span>
<span class="line-removed">-         if (lvar &lt;= 3) {</span>
<span class="line-removed">-             out.writeByte(opcode_0 + lvar);</span>
<span class="line-removed">-         } else if (lvar &lt;= 0xFF) {</span>
<span class="line-removed">-             out.writeByte(opcode);</span>
<span class="line-removed">-             out.writeByte(lvar &amp; 0xFF);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * Use the &quot;wide&quot; instruction modifier for local variable</span>
<span class="line-removed">-              * indexes that do not fit into an unsigned byte.</span>
               */
<span class="line-modified">!             out.writeByte(opc_wide);</span>
<span class="line-modified">!             out.writeByte(opcode);</span>
<span class="line-modified">!             out.writeShort(lvar &amp; 0xFFFF);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate code for an &quot;ldc&quot; instruction for the given constant pool</span>
<span class="line-removed">-      * index (the &quot;ldc_w&quot; instruction is used if the index does not fit</span>
<span class="line-removed">-      * into an unsigned byte).  The code is written to the supplied stream.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private void code_ldc(int index, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         assert index &gt;= 0 &amp;&amp; index &lt;= 0xFFFF;</span>
<span class="line-removed">-         if (index &lt;= 0xFF) {</span>
<span class="line-removed">-             out.writeByte(opc_ldc);</span>
<span class="line-removed">-             out.writeByte(index &amp; 0xFF);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             out.writeByte(opc_ldc_w);</span>
<span class="line-removed">-             out.writeShort(index &amp; 0xFFFF);</span>
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate code to push a constant integer value on to the operand</span>
<span class="line-modified">!      * stack, using the &quot;iconst_&lt;i&gt;&quot;, &quot;bipush&quot;, or &quot;sipush&quot; instructions</span>
<span class="line-removed">-      * depending on the size of the value.  The code is written to the</span>
<span class="line-removed">-      * supplied stream.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private void code_ipush(int value, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (value &gt;= -1 &amp;&amp; value &lt;= 5) {</span>
<span class="line-removed">-             out.writeByte(opc_iconst_0 + value);</span>
<span class="line-removed">-         } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">-             out.writeByte(opc_bipush);</span>
<span class="line-removed">-             out.writeByte(value &amp; 0xFF);</span>
<span class="line-removed">-         } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">-             out.writeByte(opc_sipush);</span>
<span class="line-removed">-             out.writeShort(value &amp; 0xFFFF);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new AssertionError();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-removed">-      * class to get its Class object at runtime.  The code is written to</span>
<span class="line-removed">-      * the supplied stream.  Note that the code generated by this method</span>
<span class="line-removed">-      * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private void codeClassForName(Class&lt;?&gt; cl, DataOutputStream out)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         code_ldc(cp.getString(cl.getName()), out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         out.writeByte(opc_invokestatic);</span>
<span class="line-removed">-         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">-             &quot;java/lang/Class&quot;,</span>
<span class="line-removed">-             &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * ==================== General Utility Methods ====================</span>
<span class="line-removed">-      */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-removed">-      * separator, the external representation used by the Java language</span>
<span class="line-removed">-      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-removed">-      * package separator, the representation used in the class file</span>
<span class="line-removed">-      * format (see JVMS section 4.2).</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static String dotToSlash(String name) {</span>
<span class="line-removed">-         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return the &quot;method descriptor&quot; string for a method with the given</span>
<span class="line-removed">-      * parameter types and return type.  See JVMS section 4.3.3.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static String getMethodDescriptor(Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-removed">-                                               Class&lt;?&gt; returnType)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return getParameterDescriptors(parameterTypes) +</span>
<span class="line-removed">-             ((returnType == void.class) ? &quot;V&quot; : getFieldType(returnType));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return the list of &quot;parameter descriptor&quot; strings enclosed in</span>
<span class="line-removed">-      * parentheses corresponding to the given parameter types (in other</span>
<span class="line-removed">-      * words, a method descriptor without a return descriptor).  This</span>
<span class="line-removed">-      * string is useful for constructing string keys for methods without</span>
<span class="line-removed">-      * regard to their return type.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static String getParameterDescriptors(Class&lt;?&gt;[] parameterTypes) {</span>
<span class="line-removed">-         StringBuilder desc = new StringBuilder(&quot;(&quot;);</span>
<span class="line-removed">-         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">-             desc.append(getFieldType(parameterTypes[i]));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         desc.append(&#39;)&#39;);</span>
<span class="line-removed">-         return desc.toString();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return the &quot;field type&quot; string for the given type, appropriate for</span>
<span class="line-removed">-      * a field descriptor, a parameter descriptor, or a return descriptor</span>
<span class="line-removed">-      * other than &quot;void&quot;.  See JVMS section 4.3.2.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static String getFieldType(Class&lt;?&gt; type) {</span>
<span class="line-removed">-         if (type.isPrimitive()) {</span>
<span class="line-removed">-             return PrimitiveTypeInfo.get(type).baseTypeString;</span>
<span class="line-removed">-         } else if (type.isArray()) {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * According to JLS 20.3.2, the getName() method on Class does</span>
<span class="line-removed">-              * return the VM type descriptor format for array classes (only);</span>
<span class="line-removed">-              * using that should be quicker than the otherwise obvious code:</span>
<span class="line-removed">-              *</span>
<span class="line-removed">-              *     return &quot;[&quot; + getTypeDescriptor(type.getComponentType());</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             return type.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return &quot;L&quot; + dotToSlash(type.getName()) + &quot;;&quot;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns a human-readable string representing the signature of a</span>
<span class="line-removed">-      * method with the given name and parameter types.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static String getFriendlyMethodSignature(String name,</span>
<span class="line-removed">-                                                      Class&lt;?&gt;[] parameterTypes)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         StringBuilder sig = new StringBuilder(name);</span>
<span class="line-removed">-         sig.append(&#39;(&#39;);</span>
<span class="line-removed">-         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">-             if (i &gt; 0) {</span>
<span class="line-removed">-                 sig.append(&#39;,&#39;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             Class&lt;?&gt; parameterType = parameterTypes[i];</span>
<span class="line-removed">-             int dimensions = 0;</span>
<span class="line-removed">-             while (parameterType.isArray()) {</span>
<span class="line-removed">-                 parameterType = parameterType.getComponentType();</span>
<span class="line-removed">-                 dimensions++;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             sig.append(parameterType.getName());</span>
<span class="line-removed">-             while (dimensions-- &gt; 0) {</span>
<span class="line-removed">-                 sig.append(&quot;[]&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         sig.append(&#39;)&#39;);</span>
<span class="line-removed">-         return sig.toString();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-removed">-      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-removed">-      * section 3.6.1.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-removed">-      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-removed">-      * was removed for the second edition.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-removed">-         if (type == long.class || type == double.class) {</span>
<span class="line-removed">-             return 2;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return 1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-removed">-      * are not already contained in the list and are assignable to at</span>
<span class="line-removed">-      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * This method is useful for computing the greatest common set of</span>
<span class="line-removed">-      * declared exceptions from duplicate methods inherited from</span>
<span class="line-removed">-      * different interfaces.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-removed">-                                                Class&lt;?&gt;[] with,</span>
<span class="line-removed">-                                                List&lt;Class&lt;?&gt;&gt; list)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         for (Class&lt;?&gt; fc: from) {</span>
<span class="line-removed">-             if (!list.contains(fc)) {</span>
<span class="line-removed">-                 for (Class&lt;?&gt; wc: with) {</span>
<span class="line-removed">-                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-removed">-                         list.add(fc);</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-removed">-      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-removed">-      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-removed">-      * implementation before catching other Throwables and wrapping them</span>
<span class="line-removed">-      * in UndeclaredThrowableExceptions.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-removed">-      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-removed">-      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-removed">-      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-removed">-      * list (if none of their superclasses are contained), since those</span>
<span class="line-removed">-      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-removed">-      * subclasses will never appear in the returned list.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-removed">-      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-removed">-      * need to be caught.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-removed">-         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-                                                 // unique exceptions to catch</span>
<span class="line-removed">- </span>
<span class="line-removed">-         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-removed">-         uniqueList.add(RuntimeException.class);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     nextException:</span>
<span class="line-removed">-         for (Class&lt;?&gt; ex: exceptions) {</span>
<span class="line-removed">-             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-removed">-                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-removed">-                  * can, at most, throw Throwable anyway.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 uniqueList.clear();</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * Compare this exception against the current list of</span>
<span class="line-removed">-              * exceptions that need to be caught:</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             for (int j = 0; j &lt; uniqueList.size();) {</span>
<span class="line-removed">-                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-removed">-                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * if a superclass of this exception is already on</span>
<span class="line-removed">-                      * the list to catch, then ignore this one and continue;</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     continue nextException;</span>
<span class="line-removed">-                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * if a subclass of this exception is on the list</span>
<span class="line-removed">-                      * to catch, then remove it;</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     uniqueList.remove(j);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     j++;        // else continue comparing.</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-removed">-             uniqueList.add(ex);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return uniqueList;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-removed">-      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-removed">-      * primitive type can be obtained using the static &quot;get&quot; method.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static class PrimitiveTypeInfo {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2) */</span>
<span class="line-removed">-         public String baseTypeString;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** name of corresponding wrapper class */</span>
<span class="line-removed">-         public String wrapperClassName;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** method descriptor for wrapper class &quot;valueOf&quot; factory method */</span>
<span class="line-removed">-         public String wrapperValueOfDesc;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** name of wrapper class method for retrieving primitive value */</span>
<span class="line-removed">-         public String unwrapMethodName;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** descriptor of same method */</span>
<span class="line-removed">-         public String unwrapMethodDesc;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static Map&lt;Class&lt;?&gt;,PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
<span class="line-removed">-         static {</span>
<span class="line-removed">-             add(byte.class, Byte.class);</span>
<span class="line-removed">-             add(char.class, Character.class);</span>
<span class="line-removed">-             add(double.class, Double.class);</span>
<span class="line-removed">-             add(float.class, Float.class);</span>
<span class="line-removed">-             add(int.class, Integer.class);</span>
<span class="line-removed">-             add(long.class, Long.class);</span>
<span class="line-removed">-             add(short.class, Short.class);</span>
<span class="line-removed">-             add(boolean.class, Boolean.class);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">-             table.put(primitiveClass,</span>
<span class="line-removed">-                       new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">-             assert primitiveClass.isPrimitive();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             baseTypeString =</span>
<span class="line-removed">-                 Array.newInstance(primitiveClass, 0)</span>
<span class="line-removed">-                 .getClass().getName().substring(1);</span>
<span class="line-removed">-             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-removed">-             wrapperValueOfDesc =</span>
<span class="line-removed">-                 &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-removed">-             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-removed">-             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>
          }
  
          public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
              return table.get(cl);
          }
      }
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * A ConstantPool object represents the constant pool of a class file</span>
<span class="line-removed">-      * being generated.  This representation of a constant pool is designed</span>
<span class="line-removed">-      * specifically for use by ProxyGenerator; in particular, it assumes</span>
<span class="line-removed">-      * that constant pool entries will not need to be resorted (for example,</span>
<span class="line-removed">-      * by their type, as the Java compiler does), so that the final index</span>
<span class="line-removed">-      * value can be assigned and used when an entry is first created.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * Note that new entries cannot be created after the constant pool has</span>
<span class="line-removed">-      * been written to a class file.  To prevent such logic errors, a</span>
<span class="line-removed">-      * ConstantPool instance can be marked &quot;read only&quot;, so that further</span>
<span class="line-removed">-      * attempts to add new entries will fail with a runtime exception.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * See JVMS section 4.4 for more information about the constant pool</span>
<span class="line-removed">-      * of a class file.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static class ConstantPool {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * list of constant pool entries, in constant pool index order.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * This list is used when writing the constant pool to a stream</span>
<span class="line-removed">-          * and for assigning the next index value.  Note that element 0</span>
<span class="line-removed">-          * of this list corresponds to constant pool index 1.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private List&lt;Entry&gt; pool = new ArrayList&lt;&gt;(32);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * maps constant pool data of all types to constant pool indexes.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * This map is used to look up the index of an existing entry for</span>
<span class="line-removed">-          * values of all types.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private Map&lt;Object,Integer&gt; map = new HashMap&lt;&gt;(16);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /** true if no new constant pool entries may be added */</span>
<span class="line-removed">-         private boolean readOnly = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_Utf8 entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getUtf8(String s) {</span>
<span class="line-removed">-             if (s == null) {</span>
<span class="line-removed">-                 throw new NullPointerException();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return getValue(s);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_Integer entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getInteger(int i) {</span>
<span class="line-removed">-             return getValue(i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_Float entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getFloat(float f) {</span>
<span class="line-removed">-             return getValue(f);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_Class entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getClass(String name) {</span>
<span class="line-removed">-             short utf8Index = getUtf8(name);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_CLASS, utf8Index));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_String entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getString(String s) {</span>
<span class="line-removed">-             short utf8Index = getUtf8(s);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_STRING, utf8Index));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_FieldRef entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getFieldRef(String className,</span>
<span class="line-removed">-                                  String name, String descriptor)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             short classIndex = getClass(className);</span>
<span class="line-removed">-             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_FIELD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_MethodRef entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getMethodRef(String className,</span>
<span class="line-removed">-                                   String name, String descriptor)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             short classIndex = getClass(className);</span>
<span class="line-removed">-             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_METHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_InterfaceMethodRef entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getInterfaceMethodRef(String className, String name,</span>
<span class="line-removed">-                                            String descriptor)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             short classIndex = getClass(className);</span>
<span class="line-removed">-             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for a CONSTANT_NameAndType entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public short getNameAndType(String name, String descriptor) {</span>
<span class="line-removed">-             short nameIndex = getUtf8(name);</span>
<span class="line-removed">-             short descriptorIndex = getUtf8(descriptor);</span>
<span class="line-removed">-             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">-                 CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Set this ConstantPool instance to be &quot;read only&quot;.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * After this method has been called, further requests to get</span>
<span class="line-removed">-          * an index for a non-existent entry will cause an InternalError</span>
<span class="line-removed">-          * to be thrown instead of creating of the entry.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public void setReadOnly() {</span>
<span class="line-removed">-             readOnly = true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Write this constant pool to a stream as part of</span>
<span class="line-removed">-          * the class file format.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * This consists of writing the &quot;constant_pool_count&quot; and</span>
<span class="line-removed">-          * &quot;constant_pool[]&quot; items of the &quot;ClassFile&quot; structure, as</span>
<span class="line-removed">-          * described in JVMS section 4.1.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         public void write(OutputStream out) throws IOException {</span>
<span class="line-removed">-             DataOutputStream dataOut = new DataOutputStream(out);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // constant_pool_count: number of entries plus one</span>
<span class="line-removed">-             dataOut.writeShort(pool.size() + 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             for (Entry e : pool) {</span>
<span class="line-removed">-                 e.write(dataOut);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Add a new constant pool entry and return its index.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private short addEntry(Entry entry) {</span>
<span class="line-removed">-             pool.add(entry);</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-              * Note that this way of determining the index of the</span>
<span class="line-removed">-              * added entry is wrong if this pool supports</span>
<span class="line-removed">-              * CONSTANT_Long or CONSTANT_Double entries.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             if (pool.size() &gt;= 65535) {</span>
<span class="line-removed">-                 throw new IllegalArgumentException(</span>
<span class="line-removed">-                     &quot;constant pool size limit exceeded&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return (short) pool.size();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">-          * a direct value.  The type of the given object determines the</span>
<span class="line-removed">-          * type of the desired entry as follows:</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          *      java.lang.String        CONSTANT_Utf8</span>
<span class="line-removed">-          *      java.lang.Integer       CONSTANT_Integer</span>
<span class="line-removed">-          *      java.lang.Float         CONSTANT_Float</span>
<span class="line-removed">-          *      java.lang.Long          CONSTANT_Long</span>
<span class="line-removed">-          *      java.lang.Double        CONSTANT_DOUBLE</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private short getValue(Object key) {</span>
<span class="line-removed">-             Integer index = map.get(key);</span>
<span class="line-removed">-             if (index != null) {</span>
<span class="line-removed">-                 return index.shortValue();</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 if (readOnly) {</span>
<span class="line-removed">-                     throw new InternalError(</span>
<span class="line-removed">-                         &quot;late constant pool addition: &quot; + key);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 short i = addEntry(new ValueEntry(key));</span>
<span class="line-removed">-                 map.put(key, (int)i);</span>
<span class="line-removed">-                 return i;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">-          * references to other constant pool entries.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private short getIndirect(IndirectEntry e) {</span>
<span class="line-removed">-             Integer index = map.get(e);</span>
<span class="line-removed">-             if (index != null) {</span>
<span class="line-removed">-                 return index.shortValue();</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 if (readOnly) {</span>
<span class="line-removed">-                     throw new InternalError(&quot;late constant pool addition&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 short i = addEntry(e);</span>
<span class="line-removed">-                 map.put(e, (int)i);</span>
<span class="line-removed">-                 return i;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Entry is the abstact superclass of all constant pool entry types</span>
<span class="line-removed">-          * that can be stored in the &quot;pool&quot; list; its purpose is to define a</span>
<span class="line-removed">-          * common method for writing constant pool entries to a class file.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private abstract static class Entry {</span>
<span class="line-removed">-             public abstract void write(DataOutputStream out)</span>
<span class="line-removed">-                 throws IOException;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * ValueEntry represents a constant pool entry of a type that</span>
<span class="line-removed">-          * contains a direct value (see the comments for the &quot;getValue&quot;</span>
<span class="line-removed">-          * method for a list of such types).</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * ValueEntry objects are not used as keys for their entries in the</span>
<span class="line-removed">-          * Map &quot;map&quot;, so no useful hashCode or equals methods are defined.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static class ValueEntry extends Entry {</span>
<span class="line-removed">-             private Object value;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public ValueEntry(Object value) {</span>
<span class="line-removed">-                 this.value = value;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">-                 if (value instanceof String) {</span>
<span class="line-removed">-                     out.writeByte(CONSTANT_UTF8);</span>
<span class="line-removed">-                     out.writeUTF((String) value);</span>
<span class="line-removed">-                 } else if (value instanceof Integer) {</span>
<span class="line-removed">-                     out.writeByte(CONSTANT_INTEGER);</span>
<span class="line-removed">-                     out.writeInt(((Integer) value).intValue());</span>
<span class="line-removed">-                 } else if (value instanceof Float) {</span>
<span class="line-removed">-                     out.writeByte(CONSTANT_FLOAT);</span>
<span class="line-removed">-                     out.writeFloat(((Float) value).floatValue());</span>
<span class="line-removed">-                 } else if (value instanceof Long) {</span>
<span class="line-removed">-                     out.writeByte(CONSTANT_LONG);</span>
<span class="line-removed">-                     out.writeLong(((Long) value).longValue());</span>
<span class="line-removed">-                 } else if (value instanceof Double) {</span>
<span class="line-removed">-                     out.writeDouble(CONSTANT_DOUBLE);</span>
<span class="line-removed">-                     out.writeDouble(((Double) value).doubleValue());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     throw new InternalError(&quot;bogus value entry: &quot; + value);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * IndirectEntry represents a constant pool entry of a type that</span>
<span class="line-removed">-          * references other constant pool entries, i.e., the following types:</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          *      CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref,</span>
<span class="line-removed">-          *      CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and</span>
<span class="line-removed">-          *      CONSTANT_NameAndType.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * Each of these entry types contains either one or two indexes of</span>
<span class="line-removed">-          * other constant pool entries.</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * IndirectEntry objects are used as the keys for their entries in</span>
<span class="line-removed">-          * the Map &quot;map&quot;, so the hashCode and equals methods are overridden</span>
<span class="line-removed">-          * to allow matching.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static class IndirectEntry extends Entry {</span>
<span class="line-removed">-             private int tag;</span>
<span class="line-removed">-             private short index0;</span>
<span class="line-removed">-             private short index1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             /**</span>
<span class="line-removed">-              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">-              * that contains one index of another entry.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             public IndirectEntry(int tag, short index) {</span>
<span class="line-removed">-                 this.tag = tag;</span>
<span class="line-removed">-                 this.index0 = index;</span>
<span class="line-removed">-                 this.index1 = 0;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             /**</span>
<span class="line-removed">-              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">-              * that contains two indexes for other entries.</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             public IndirectEntry(int tag, short index0, short index1) {</span>
<span class="line-removed">-                 this.tag = tag;</span>
<span class="line-removed">-                 this.index0 = index0;</span>
<span class="line-removed">-                 this.index1 = index1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">-                 out.writeByte(tag);</span>
<span class="line-removed">-                 out.writeShort(index0);</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * If this entry type contains two indexes, write</span>
<span class="line-removed">-                  * out the second, too.</span>
<span class="line-removed">-                  */</span>
<span class="line-removed">-                 if (tag == CONSTANT_FIELD ||</span>
<span class="line-removed">-                     tag == CONSTANT_METHOD ||</span>
<span class="line-removed">-                     tag == CONSTANT_INTERFACEMETHOD ||</span>
<span class="line-removed">-                     tag == CONSTANT_NAMEANDTYPE)</span>
<span class="line-removed">-                 {</span>
<span class="line-removed">-                     out.writeShort(index1);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public int hashCode() {</span>
<span class="line-removed">-                 return tag + index0 + index1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public boolean equals(Object obj) {</span>
<span class="line-removed">-                 if (obj instanceof IndirectEntry) {</span>
<span class="line-removed">-                     IndirectEntry other = (IndirectEntry) obj;</span>
<span class="line-removed">-                     if (tag == other.tag &amp;&amp;</span>
<span class="line-removed">-                         index0 == other.index0 &amp;&amp; index1 == other.index1)</span>
<span class="line-removed">-                     {</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 298,667 ---</span>
           * not assignable from any of the others.
           */
          if (uncoveredReturnTypes.size() &gt; 1) {
              ProxyMethod pm = methods.get(0);
              throw new IllegalArgumentException(
<span class="line-modified">!                     &quot;methods with same signature &quot; +</span>
<span class="line-modified">!                             pm.shortSignature +</span>
<span class="line-modified">!                             &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
          }
      }
  
      /**
<span class="line-modified">!      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-modified">!      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-modified">!      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-added">+      * implementation before catching other Throwables and wrapping them</span>
<span class="line-added">+      * in UndeclaredThrowableExceptions.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-added">+      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-added">+      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-added">+      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-added">+      * list (if none of their superclasses are contained), since those</span>
<span class="line-added">+      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-added">+      * subclasses will never appear in the returned list.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-added">+      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-added">+      * need to be caught.</span>
       */
<span class="line-modified">!     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-modified">!         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         // unique exceptions to catch</span>
  
<span class="line-modified">!         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-modified">!         uniqueList.add(RuntimeException.class);</span>
  
<span class="line-modified">!         nextException:</span>
<span class="line-added">+         for (Class&lt;?&gt; ex : exceptions) {</span>
<span class="line-added">+             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-added">+                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-added">+                  * can, at most, throw Throwable anyway.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 uniqueList.clear();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
              /*
<span class="line-modified">!              * Compare this exception against the current list of</span>
<span class="line-modified">!              * exceptions that need to be caught:</span>
               */
<span class="line-modified">!             for (int j = 0; j &lt; uniqueList.size(); ) {</span>
<span class="line-modified">!                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-modified">!                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-modified">!                     /*</span>
<span class="line-modified">!                      * if a superclass of this exception is already on</span>
<span class="line-modified">!                      * the list to catch, then ignore this one and continue;</span>
<span class="line-modified">!                      */</span>
<span class="line-modified">!                     continue nextException;</span>
<span class="line-added">+                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-added">+                     /*</span>
<span class="line-added">+                      * if a subclass of this exception is on the list</span>
<span class="line-added">+                      * to catch, then remove it;</span>
<span class="line-added">+                      */</span>
<span class="line-added">+                     uniqueList.remove(j);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     j++;        // else continue comparing.</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-added">+             uniqueList.add(ex);</span>
          }
<span class="line-added">+         return uniqueList;</span>
      }
  
      /**
<span class="line-modified">!      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-modified">!      * separator, the external representation used by the Java language</span>
<span class="line-modified">!      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-added">+      * package separator, the representation used in the class file</span>
<span class="line-added">+      * format (see JVMS section {@jvms 4.2}).</span>
       */
<span class="line-modified">!     private static String dotToSlash(String name) {</span>
<span class="line-modified">!         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-modified">!     }</span>
  
      /**
<span class="line-modified">!      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-modified">!      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-modified">!      * section 3.6.1.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-added">+      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-added">+      * was removed for the second edition.</span>
       */
<span class="line-modified">!     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-modified">!         if (type == long.class || type == double.class) {</span>
<span class="line-modified">!             return 2;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return 1;</span>
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-modified">!      * are not already contained in the list and are assignable to at</span>
<span class="line-modified">!      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-modified">!      * This method is useful for computing the greatest common set of</span>
<span class="line-modified">!      * declared exceptions from duplicate methods inherited from</span>
<span class="line-modified">!      * different interfaces.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-modified">!                                                Class&lt;?&gt;[] with,</span>
<span class="line-modified">!                                                List&lt;Class&lt;?&gt;&gt; list) {</span>
<span class="line-modified">!         for (Class&lt;?&gt; fc : from) {</span>
<span class="line-modified">!             if (!list.contains(fc)) {</span>
<span class="line-modified">!                 for (Class&lt;?&gt; wc : with) {</span>
<span class="line-modified">!                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-modified">!                         list.add(fc);</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Returns the {@link ClassLoader} to be used by the default implementation of {@link</span>
<span class="line-modified">!      * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}&#39;s runtime type by</span>
<span class="line-modified">!      * default.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return ClassLoader</span>
       */
<span class="line-modified">!     protected ClassLoader getClassLoader() {</span>
<span class="line-modified">!         return loader;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified">!      * class file generation process.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private byte[] generateClassFile() {</span>
<span class="line-modified">!         visit(V14, accessFlags, dotToSlash(className), null,</span>
<span class="line-modified">!                 JLR_PROXY, typeNames(interfaces));</span>
  
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * Add proxy methods for the hashCode, equals,</span>
<span class="line-modified">!          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-added">+          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-added">+          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-added">+          * proxy interfaces.</span>
           */
<span class="line-modified">!         addProxyMethod(hashCodeMethod);</span>
<span class="line-modified">!         addProxyMethod(equalsMethod);</span>
<span class="line-modified">!         addProxyMethod(toStringMethod);</span>
  
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * Accumulate all of the methods from the proxy interfaces.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-modified">!             for (Method m : intf.getMethods()) {</span>
<span class="line-added">+                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-added">+                     addProxyMethod(m, intf);</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         /*</span>
<span class="line-added">+          * For each set of proxy methods with the same signature,</span>
<span class="line-added">+          * verify that the methods&#39; return types are compatible.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">+             checkReturnTypes(sigmethods);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         generateConstructor();</span>
  
<span class="line-modified">!         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">+             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">+                 // add static field for the Method object</span>
<span class="line-added">+                 visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,</span>
<span class="line-added">+                         LJLR_METHOD, null, null);</span>
  
<span class="line-modified">!                 // Generate code for proxy method</span>
<span class="line-added">+                 pm.generateMethod(this, className);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         generateStaticInitializer();</span>
  
<span class="line-modified">!         return toByteArray();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Add another method to be proxied, either by creating a new</span>
<span class="line-added">+      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-added">+      * method.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-added">+      * found through, which may be different from (a subinterface of)</span>
<span class="line-added">+      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-added">+      * object passed for a given name and descriptor identifies the</span>
<span class="line-added">+      * Method object (and thus the declaring class) that will be</span>
<span class="line-added">+      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-added">+      * set of duplicate methods.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-added">+         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-added">+         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
  
<span class="line-modified">!         String sig = m.toShortSignature();</span>
<span class="line-added">+         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added">+                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added">+         for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">+             if (returnType == pm.returnType) {</span>
<span class="line-added">+                 /*</span>
<span class="line-added">+                  * Found a match: reduce exception types to the</span>
<span class="line-added">+                  * greatest set of exceptions that can be thrown</span>
<span class="line-added">+                  * compatibly with the throws clauses of both</span>
<span class="line-added">+                  * overridden methods.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-added">+                 collectCompatibleTypes(</span>
<span class="line-added">+                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-added">+                 collectCompatibleTypes(</span>
<span class="line-added">+                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-added">+                 pm.exceptionTypes = legalExceptions.toArray(EMPTY_CLASS_ARRAY);</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         sigmethods.add(new ProxyMethod(m, sig, m.getParameterTypes(), returnType,</span>
<span class="line-added">+                 exceptionTypes, fromClass,</span>
<span class="line-added">+                 &quot;m&quot; + proxyMethodCount++));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Add an existing ProxyMethod (hashcode, equals, toString).</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pm an existing ProxyMethod</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void addProxyMethod(ProxyMethod pm) {</span>
<span class="line-added">+         String sig = pm.shortSignature;</span>
<span class="line-added">+         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added">+                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added">+         sigmethods.add(pm);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate the constructor method for the proxy class.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     private void generateConstructor() {</span>
<span class="line-added">+         MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,</span>
<span class="line-added">+                 MJLR_INVOCATIONHANDLER, null, null);</span>
<span class="line-added">+         ctor.visitParameter(null, 0);</span>
<span class="line-added">+         ctor.visitCode();</span>
<span class="line-added">+         ctor.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">+         ctor.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">+         ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,</span>
<span class="line-added">+                 MJLR_INVOCATIONHANDLER, false);</span>
<span class="line-added">+         ctor.visitInsn(RETURN);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">+         ctor.visitMaxs(-1, -1);</span>
<span class="line-added">+         ctor.visitEnd();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Generate the static initializer method for the proxy class.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void generateStaticInitializer() {</span>
<span class="line-added">+ </span>
<span class="line-added">+         MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,</span>
<span class="line-added">+                 &quot;()V&quot;, null, null);</span>
<span class="line-added">+         mv.visitCode();</span>
<span class="line-added">+         Label L_startBlock = new Label();</span>
<span class="line-added">+         Label L_endBlock = new Label();</span>
<span class="line-added">+         Label L_NoMethodHandler = new Label();</span>
<span class="line-added">+         Label L_NoClassHandler = new Label();</span>
<span class="line-added">+ </span>
<span class="line-added">+         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,</span>
<span class="line-added">+                 JL_NO_SUCH_METHOD_EX);</span>
<span class="line-added">+         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,</span>
<span class="line-added">+                 JL_CLASS_NOT_FOUND_EX);</span>
<span class="line-added">+ </span>
<span class="line-added">+         mv.visitLabel(L_startBlock);</span>
<span class="line-added">+         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">+             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">+                 pm.codeFieldInitialization(mv, className);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         mv.visitInsn(RETURN);</span>
<span class="line-added">+         mv.visitLabel(L_endBlock);</span>
<span class="line-added">+         // Generate exception handler</span>
<span class="line-added">+ </span>
<span class="line-added">+         mv.visitLabel(L_NoMethodHandler);</span>
<span class="line-added">+         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">+         mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);</span>
<span class="line-added">+         mv.visitInsn(DUP);</span>
<span class="line-added">+         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">+         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added">+                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added">+         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,</span>
<span class="line-added">+                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added">+         mv.visitInsn(ATHROW);</span>
<span class="line-added">+ </span>
<span class="line-added">+         mv.visitLabel(L_NoClassHandler);</span>
<span class="line-added">+         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">+         mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);</span>
<span class="line-added">+         mv.visitInsn(DUP);</span>
<span class="line-added">+         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">+         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added">+                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added">+         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,</span>
<span class="line-added">+                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added">+         mv.visitInsn(ATHROW);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">+         mv.visitMaxs(-1, -1);</span>
<span class="line-added">+         mv.visitEnd();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified">!      * being generated: a method whose implementation will encode and</span>
<span class="line-modified">!      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static class ProxyMethod {</span>
  
<span class="line-modified">!         private final Method method;</span>
<span class="line-added">+         private final String shortSignature;</span>
<span class="line-added">+         private final Class&lt;?&gt; fromClass;</span>
<span class="line-added">+         private final Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-added">+         private final Class&lt;?&gt; returnType;</span>
<span class="line-added">+         private final String methodFieldName;</span>
<span class="line-added">+         private Class&lt;?&gt;[] exceptionTypes;</span>
  
<span class="line-modified">!         private ProxyMethod(Method method, String sig, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-added">+                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-added">+                             Class&lt;?&gt; fromClass, String methodFieldName) {</span>
<span class="line-added">+             this.method = method;</span>
<span class="line-added">+             this.shortSignature = sig;</span>
<span class="line-added">+             this.parameterTypes = parameterTypes;</span>
<span class="line-added">+             this.returnType = returnType;</span>
<span class="line-added">+             this.exceptionTypes = exceptionTypes;</span>
<span class="line-added">+             this.fromClass = fromClass;</span>
<span class="line-added">+             this.methodFieldName = methodFieldName;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Create a new specific ProxyMethod with a specific field name</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param method          The method for which to create a proxy</span>
<span class="line-added">+          * @param methodFieldName the fieldName to generate</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private ProxyMethod(Method method, String methodFieldName) {</span>
<span class="line-added">+             this(method, method.toShortSignature(),</span>
<span class="line-added">+                     method.getParameterTypes(), method.getReturnType(),</span>
<span class="line-added">+                     method.getExceptionTypes(), method.getDeclaringClass(), methodFieldName);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Generate this method, including the code and exception table entry.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private void generateMethod(ClassWriter cw, String className) {</span>
<span class="line-added">+             MethodType mt = MethodType.methodType(returnType, parameterTypes);</span>
<span class="line-added">+             String desc = mt.toMethodDescriptorString();</span>
<span class="line-added">+             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_FINAL,</span>
<span class="line-added">+                     method.getName(), desc, null,</span>
<span class="line-added">+                     typeNames(Arrays.asList(exceptionTypes)));</span>
  
<span class="line-modified">!             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-added">+             int nextSlot = 1;</span>
<span class="line-added">+             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-added">+                 parameterSlot[i] = nextSlot;</span>
<span class="line-added">+                 nextSlot += getWordsPerType(parameterTypes[i]);</span>
              }
  
<span class="line-modified">!             mv.visitCode();</span>
<span class="line-added">+             Label L_startBlock = new Label();</span>
<span class="line-added">+             Label L_endBlock = new Label();</span>
<span class="line-added">+             Label L_RuntimeHandler = new Label();</span>
<span class="line-added">+             Label L_ThrowableHandler = new Label();</span>
  
              List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
              if (catchList.size() &gt; 0) {
                  for (Class&lt;?&gt; ex : catchList) {
<span class="line-modified">!                     mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,</span>
<span class="line-modified">!                             dotToSlash(ex.getName()));</span>
                  }
  
<span class="line-modified">!                 mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,</span>
<span class="line-modified">!                         JL_THROWABLE);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             mv.visitLabel(L_startBlock);</span>
  
<span class="line-modified">!             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">+             mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,</span>
<span class="line-added">+                     LJLR_INVOCATION_HANDLER);</span>
<span class="line-added">+             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">+             mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,</span>
<span class="line-added">+                     LJLR_METHOD);</span>
  
<span class="line-modified">!             if (parameterTypes.length &gt; 0) {</span>
<span class="line-added">+                 // Create an array and fill with the parameters converting primitives to wrappers</span>
<span class="line-added">+                 emitIconstInsn(mv, parameterTypes.length);</span>
<span class="line-added">+                 mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);</span>
<span class="line-added">+                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-added">+                     mv.visitInsn(DUP);</span>
<span class="line-added">+                     emitIconstInsn(mv, i);</span>
<span class="line-added">+                     codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);</span>
<span class="line-added">+                     mv.visitInsn(Opcodes.AASTORE);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 mv.visitInsn(Opcodes.ACONST_NULL);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,</span>
<span class="line-modified">!                     &quot;invoke&quot;,</span>
<span class="line-modified">!                     &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-added">+                             &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;, true);</span>
  
<span class="line-modified">!             if (returnType == void.class) {</span>
<span class="line-added">+                 mv.visitInsn(POP);</span>
<span class="line-added">+                 mv.visitInsn(RETURN);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 codeUnwrapReturnValue(mv, returnType);</span>
              }
  
<span class="line-modified">!             mv.visitLabel(L_endBlock);</span>
  
<span class="line-modified">!             // Generate exception handler</span>
<span class="line-modified">!             mv.visitLabel(L_RuntimeHandler);</span>
<span class="line-modified">!             mv.visitInsn(ATHROW);   // just rethrow the exception</span>
  
<span class="line-modified">!             mv.visitLabel(L_ThrowableHandler);</span>
<span class="line-added">+             mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">+             mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);</span>
<span class="line-added">+             mv.visitInsn(DUP);</span>
<span class="line-added">+             mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">+             mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,</span>
<span class="line-added">+                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;, false);</span>
<span class="line-added">+             mv.visitInsn(ATHROW);</span>
<span class="line-added">+             // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">+             mv.visitMaxs(-1, -1);</span>
<span class="line-added">+             mv.visitEnd();</span>
          }
  
          /**
           * Generate code for wrapping an argument of the given type
           * whose value can be found at the specified local variable
           * index, in order for it to be passed (as an Object) to the
<span class="line-modified">!          * invocation handler&#39;s &quot;invoke&quot; method.</span>
           */
<span class="line-modified">!         private void codeWrapArgument(MethodVisitor mv, Class&lt;?&gt; type, int slot) {</span>
              if (type.isPrimitive()) {
                  PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
  
                  if (type == int.class ||
<span class="line-modified">!                         type == boolean.class ||</span>
<span class="line-modified">!                         type == byte.class ||</span>
<span class="line-modified">!                         type == char.class ||</span>
<span class="line-modified">!                         type == short.class) {</span>
<span class="line-modified">!                     mv.visitVarInsn(ILOAD, slot);</span>
                  } else if (type == long.class) {
<span class="line-modified">!                     mv.visitVarInsn(LLOAD, slot);</span>
                  } else if (type == float.class) {
<span class="line-modified">!                     mv.visitVarInsn(FLOAD, slot);</span>
                  } else if (type == double.class) {
<span class="line-modified">!                     mv.visitVarInsn(DLOAD, slot);</span>
                  } else {
                      throw new AssertionError();
                  }
<span class="line-modified">!                 mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, &quot;valueOf&quot;,</span>
<span class="line-modified">!                         prim.wrapperValueOfDesc, false);</span>
              } else {
<span class="line-modified">!                 mv.visitVarInsn(ALOAD, slot);</span>
              }
          }
  
          /**
           * Generate code for unwrapping a return value of the given
           * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<span class="line-modified">!          * Object) to its correct type.</span>
           */
<span class="line-modified">!         private void codeUnwrapReturnValue(MethodVisitor mv, Class&lt;?&gt; type) {</span>
              if (type.isPrimitive()) {
                  PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
  
<span class="line-modified">!                 mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);</span>
<span class="line-modified">!                 mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-modified">!                         prim.wrapperClassName,</span>
<span class="line-modified">!                         prim.unwrapMethodName, prim.unwrapMethodDesc, false);</span>
  
                  if (type == int.class ||
<span class="line-modified">!                         type == boolean.class ||</span>
<span class="line-modified">!                         type == byte.class ||</span>
<span class="line-modified">!                         type == char.class ||</span>
<span class="line-modified">!                         type == short.class) {</span>
<span class="line-modified">!                     mv.visitInsn(IRETURN);</span>
                  } else if (type == long.class) {
<span class="line-modified">!                     mv.visitInsn(LRETURN);</span>
                  } else if (type == float.class) {
<span class="line-modified">!                     mv.visitInsn(FRETURN);</span>
                  } else if (type == double.class) {
<span class="line-modified">!                     mv.visitInsn(DRETURN);</span>
                  } else {
                      throw new AssertionError();
                  }
              } else {
<span class="line-modified">!                 mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));</span>
<span class="line-modified">!                 mv.visitInsn(ARETURN);</span>
              }
          }
  
          /**
           * Generate code for initializing the static field that stores
<span class="line-modified">!          * the Method object for this proxy method.</span>
           */
<span class="line-modified">!         private void codeFieldInitialization(MethodVisitor mv, String className) {</span>
<span class="line-modified">!             codeClassForName(mv, fromClass);</span>
  
<span class="line-modified">!             mv.visitLdcInsn(method.getName());</span>
  
<span class="line-modified">!             emitIconstInsn(mv, parameterTypes.length);</span>
  
<span class="line-modified">!             mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);</span>
  
<span class="line-added">+             // Construct an array with the parameter types mapping primitives to Wrapper types</span>
              for (int i = 0; i &lt; parameterTypes.length; i++) {
<span class="line-modified">!                 mv.visitInsn(DUP);</span>
<span class="line-modified">!                 emitIconstInsn(mv, i);</span>
  
                  if (parameterTypes[i].isPrimitive()) {
                      PrimitiveTypeInfo prim =
<span class="line-modified">!                             PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified">!                     mv.visitFieldInsn(GETSTATIC,</span>
<span class="line-modified">!                             prim.wrapperClassName, &quot;TYPE&quot;, LJL_CLASS);</span>
                  } else {
<span class="line-modified">!                     codeClassForName(mv, parameterTypes[i]);</span>
                  }
<span class="line-modified">!                 mv.visitInsn(Opcodes.AASTORE);</span>
              }
<span class="line-added">+             // lookup the method</span>
<span class="line-added">+             mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-added">+                     JL_CLASS,</span>
<span class="line-added">+                     &quot;getMethod&quot;,</span>
<span class="line-added">+                     &quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-added">+                     false);</span>
  
<span class="line-modified">!             mv.visitFieldInsn(PUTSTATIC,</span>
<span class="line-modified">!                     dotToSlash(className),</span>
<span class="line-modified">!                     methodFieldName, LJLR_METHOD);</span>
          }
  
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified">!          */</span>
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-added">+          * class to get its Class object at runtime.  The code is written to</span>
<span class="line-added">+          * the supplied stream.  Note that the code generated by this method</span>
<span class="line-added">+          * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private void codeClassForName(MethodVisitor mv, Class&lt;?&gt; cl) {</span>
<span class="line-added">+             mv.visitLdcInsn(cl.getName());</span>
<span class="line-added">+             mv.visitMethodInsn(INVOKESTATIC,</span>
<span class="line-added">+                     JL_CLASS,</span>
<span class="line-added">+                     &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;, false);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Visit a bytecode for a constant.</span>
<span class="line-modified">!          *</span>
<span class="line-added">+          * @param mv  The MethodVisitor</span>
<span class="line-added">+          * @param cst The constant value</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private void emitIconstInsn(MethodVisitor mv, final int cst) {</span>
<span class="line-added">+             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-added">+                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-added">+             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-added">+                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-added">+             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-added">+                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 mv.visitLdcInsn(cst);</span>
              }
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public String toString() {</span>
<span class="line-modified">!             return method.toShortString();</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-modified">!      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-modified">!      * primitive type can be obtained using the static &quot;get&quot; method.</span>
       */
<span class="line-added">+     private static class PrimitiveTypeInfo {</span>
  
<span class="line-modified">!         private static Map&lt;Class&lt;?&gt;, PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
  
<span class="line-modified">!         static {</span>
<span class="line-modified">!             add(byte.class, Byte.class);</span>
<span class="line-modified">!             add(char.class, Character.class);</span>
<span class="line-modified">!             add(double.class, Double.class);</span>
<span class="line-modified">!             add(float.class, Float.class);</span>
<span class="line-added">+             add(int.class, Integer.class);</span>
<span class="line-added">+             add(long.class, Long.class);</span>
<span class="line-added">+             add(short.class, Short.class);</span>
<span class="line-added">+             add(boolean.class, Boolean.class);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * name of corresponding wrapper class</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         private String wrapperClassName;</span>
<span class="line-modified">!         /**</span>
<span class="line-added">+          * method descriptor for wrapper class &quot;valueOf&quot; factory method</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private String wrapperValueOfDesc;</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * name of wrapper class method for retrieving primitive value</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private String unwrapMethodName;</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * descriptor of same method</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private String unwrapMethodDesc;</span>
  
<span class="line-modified">!         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified">!             assert primitiveClass.isPrimitive();</span>
  
<span class="line-modified">!             /**</span>
<span class="line-modified">!              * &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2)</span>
               */
<span class="line-modified">!             String baseTypeString =</span>
<span class="line-modified">!                     Array.newInstance(primitiveClass, 0)</span>
<span class="line-modified">!                             .getClass().getName().substring(1);</span>
<span class="line-modified">!             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-modified">!             wrapperValueOfDesc =</span>
<span class="line-modified">!                     &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-modified">!             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-modified">!             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>
          }
  
<span class="line-modified">!         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified">!             table.put(primitiveClass,</span>
<span class="line-modified">!                     new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>
          }
  
          public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
              return table.get(cl);
          }
      }
  }
</pre>
<center><a href="Proxy.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
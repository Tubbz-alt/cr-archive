<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/StringConcatHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCoding.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringIndexOutOfBoundsException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/StringConcatHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 



 28 /**
 29  * Helper for string concatenation. These methods are mostly looked up with private lookups
 30  * from {@link java.lang.invoke.StringConcatFactory}, and used in {@link java.lang.invoke.MethodHandle}
 31  * combinators there.
 32  */
 33 final class StringConcatHelper {
 34 
 35     private StringConcatHelper() {
 36         // no instantiation
 37     }
 38 
 39     /**
 40      * Check for overflow, throw exception on overflow.
<span class="line-modified"> 41      * @param lengthCoder String length and coder</span>
<span class="line-modified"> 42      * @return lengthCoder</span>


 43      */
 44     private static long checkOverflow(long lengthCoder) {
 45         if ((int)lengthCoder &gt;= 0) {
 46             return lengthCoder;
 47         }
 48         throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
 49     }
 50 
 51     /**
 52      * Mix value length and coder into current length and coder.
<span class="line-modified"> 53      * @param current current length</span>
<span class="line-modified"> 54      * @param value   value to mix in</span>
<span class="line-modified"> 55      * @return new length and coder</span>

 56      */
<span class="line-modified"> 57     static long mix(long current, boolean value) {</span>
<span class="line-modified"> 58         return checkOverflow(current + (value ? 4 : 5));</span>
 59     }
 60 
 61     /**
 62      * Mix value length and coder into current length and coder.
<span class="line-modified"> 63      * @param current current length</span>
<span class="line-modified"> 64      * @param value   value to mix in</span>
<span class="line-modified"> 65      * @return new length and coder</span>

 66      */
<span class="line-modified"> 67     static long mix(long current, byte value) {</span>
<span class="line-modified"> 68         return mix(current, (int)value);</span>
 69     }
 70 
 71     /**
 72      * Mix value length and coder into current length and coder.
<span class="line-modified"> 73      * @param current current length</span>
<span class="line-modified"> 74      * @param value   value to mix in</span>
<span class="line-modified"> 75      * @return new length and coder</span>

 76      */
<span class="line-modified"> 77     static long mix(long current, char value) {</span>
<span class="line-modified"> 78         return checkOverflow(current + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
 79     }
 80 
 81     /**
 82      * Mix value length and coder into current length and coder.
<span class="line-modified"> 83      * @param current current length</span>
<span class="line-modified"> 84      * @param value   value to mix in</span>
<span class="line-modified"> 85      * @return new length and coder</span>

 86      */
<span class="line-modified"> 87     static long mix(long current, short value) {</span>
<span class="line-modified"> 88         return mix(current, (int)value);</span>
 89     }
 90 
 91     /**
 92      * Mix value length and coder into current length and coder.
<span class="line-modified"> 93      * @param current current length</span>
<span class="line-modified"> 94      * @param value   value to mix in</span>
<span class="line-modified"> 95      * @return new length and coder</span>

 96      */
<span class="line-modified"> 97     static long mix(long current, int value) {</span>
<span class="line-modified"> 98         return checkOverflow(current + Integer.stringSize(value));</span>
 99     }
100 
101     /**
102      * Mix value length and coder into current length and coder.
<span class="line-modified">103      * @param current current length</span>
<span class="line-modified">104      * @param value   value to mix in</span>
<span class="line-modified">105      * @return new length and coder</span>

106      */
<span class="line-modified">107     static long mix(long current, long value) {</span>
<span class="line-modified">108         return checkOverflow(current + Long.stringSize(value));</span>
109     }
110 
111     /**
112      * Mix value length and coder into current length and coder.
<span class="line-modified">113      * @param current current length</span>
<span class="line-modified">114      * @param value   value to mix in</span>
<span class="line-modified">115      * @return new length and coder</span>

116      */
<span class="line-modified">117     static long mix(long current, String value) {</span>
<span class="line-modified">118         current += value.length();</span>
119         if (value.coder() == String.UTF16) {
<span class="line-modified">120             current |= UTF16;</span>
121         }
<span class="line-modified">122         return checkOverflow(current);</span>
123     }
124 
125     /**
126      * Prepends the stringly representation of boolean value into buffer,
127      * given the coder and final index. Index is measured in chars, not in bytes!
128      *
129      * @param indexCoder final char index in the buffer, along with coder packed
130      *                   into higher bits.
131      * @param buf        buffer to append to
132      * @param value      boolean value to encode
133      * @return           updated index (coder value retained)
134      */
<span class="line-modified">135     static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
136         int index = (int)indexCoder;
137         if (indexCoder &lt; UTF16) {
138             if (value) {
139                 buf[--index] = &#39;e&#39;;
140                 buf[--index] = &#39;u&#39;;
141                 buf[--index] = &#39;r&#39;;
142                 buf[--index] = &#39;t&#39;;
143             } else {
144                 buf[--index] = &#39;e&#39;;
145                 buf[--index] = &#39;s&#39;;
146                 buf[--index] = &#39;l&#39;;
147                 buf[--index] = &#39;a&#39;;
148                 buf[--index] = &#39;f&#39;;
149             }
150             return index;
151         } else {
152             if (value) {
153                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
154                 StringUTF16.putChar(buf, --index, &#39;u&#39;);
155                 StringUTF16.putChar(buf, --index, &#39;r&#39;);
156                 StringUTF16.putChar(buf, --index, &#39;t&#39;);
157             } else {
158                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
159                 StringUTF16.putChar(buf, --index, &#39;s&#39;);
160                 StringUTF16.putChar(buf, --index, &#39;l&#39;);
161                 StringUTF16.putChar(buf, --index, &#39;a&#39;);
162                 StringUTF16.putChar(buf, --index, &#39;f&#39;);
163             }
164             return index | UTF16;
165         }
166     }
167 
168     /**
<span class="line-modified">169      * Prepends the stringly representation of byte value into buffer,</span>
170      * given the coder and final index. Index is measured in chars, not in bytes!
171      *
172      * @param indexCoder final char index in the buffer, along with coder packed
173      *                   into higher bits.
174      * @param buf        buffer to append to
<span class="line-modified">175      * @param value      byte value to encode</span>


176      * @return           updated index (coder value retained)
177      */
<span class="line-modified">178     static long prepend(long indexCoder, byte[] buf, byte value) {</span>
<span class="line-modified">179         return prepend(indexCoder, buf, (int)value);</span>






















180     }
181 
182     /**
183      * Prepends the stringly representation of char value into buffer,
184      * given the coder and final index. Index is measured in chars, not in bytes!
185      *
186      * @param indexCoder final char index in the buffer, along with coder packed
187      *                   into higher bits.
188      * @param buf        buffer to append to
189      * @param value      char value to encode
190      * @return           updated index (coder value retained)
191      */
<span class="line-modified">192     static long prepend(long indexCoder, byte[] buf, char value) {</span>
193         if (indexCoder &lt; UTF16) {
194             buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
195         } else {
196             StringUTF16.putChar(buf, (int)(--indexCoder), value);
197         }
198         return indexCoder;
199     }
200 
201     /**
<span class="line-modified">202      * Prepends the stringly representation of short value into buffer,</span>
203      * given the coder and final index. Index is measured in chars, not in bytes!
204      *
205      * @param indexCoder final char index in the buffer, along with coder packed
206      *                   into higher bits.
207      * @param buf        buffer to append to
<span class="line-modified">208      * @param value      short value to encode</span>


209      * @return           updated index (coder value retained)
210      */
<span class="line-modified">211     static long prepend(long indexCoder, byte[] buf, short value) {</span>
<span class="line-modified">212         return prepend(indexCoder, buf, (int)value);</span>






















213     }
214 
215     /**
216      * Prepends the stringly representation of integer value into buffer,
217      * given the coder and final index. Index is measured in chars, not in bytes!
218      *
219      * @param indexCoder final char index in the buffer, along with coder packed
220      *                   into higher bits.
221      * @param buf        buffer to append to
222      * @param value      integer value to encode
223      * @return           updated index (coder value retained)
224      */
<span class="line-modified">225     static long prepend(long indexCoder, byte[] buf, int value) {</span>
226         if (indexCoder &lt; UTF16) {
227             return Integer.getChars(value, (int)indexCoder, buf);
228         } else {
229             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
230         }
231     }
232 



















233     /**
234      * Prepends the stringly representation of long value into buffer,
235      * given the coder and final index. Index is measured in chars, not in bytes!
236      *
237      * @param indexCoder final char index in the buffer, along with coder packed
238      *                   into higher bits.
239      * @param buf        buffer to append to
240      * @param value      long value to encode
241      * @return           updated index (coder value retained)
242      */
<span class="line-modified">243     static long prepend(long indexCoder, byte[] buf, long value) {</span>
244         if (indexCoder &lt; UTF16) {
245             return Long.getChars(value, (int)indexCoder, buf);
246         } else {
247             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
248         }
249     }
250 



















251     /**
252      * Prepends the stringly representation of String value into buffer,
253      * given the coder and final index. Index is measured in chars, not in bytes!
254      *
255      * @param indexCoder final char index in the buffer, along with coder packed
256      *                   into higher bits.
257      * @param buf        buffer to append to
258      * @param value      String value to encode
259      * @return           updated index (coder value retained)
260      */
<span class="line-modified">261     static long prepend(long indexCoder, byte[] buf, String value) {</span>
262         indexCoder -= value.length();
263         if (indexCoder &lt; UTF16) {
264             value.getBytes(buf, (int)indexCoder, String.LATIN1);
265         } else {
266             value.getBytes(buf, (int)indexCoder, String.UTF16);
267         }
268         return indexCoder;
269     }
270 



















271     /**
272      * Instantiates the String with given buffer and coder
273      * @param buf           buffer to use
274      * @param indexCoder    remaining index (should be zero) and coder
275      * @return String       resulting string
276      */
277     static String newString(byte[] buf, long indexCoder) {
278         // Use the private, non-copying constructor (unsafe!)
279         if (indexCoder == LATIN1) {
280             return new String(buf, String.LATIN1);
281         } else if (indexCoder == UTF16) {
282             return new String(buf, String.UTF16);
283         } else {
284             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
285         }
286     }
287 





































288     private static final long LATIN1 = (long)String.LATIN1 &lt;&lt; 32;
289 
290     private static final long UTF16 = (long)String.UTF16 &lt;&lt; 32;
291 















292     /**
293      * Provides the initial coder for the String.
294      * @return initial coder, adjusted into the upper half
295      */
296     static long initialCoder() {
297         return String.COMPACT_STRINGS ? LATIN1 : UTF16;
298     }
299 
300 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
<span class="line-added"> 28 import jdk.internal.misc.Unsafe;</span>
<span class="line-added"> 29 import jdk.internal.vm.annotation.ForceInline;</span>
<span class="line-added"> 30 </span>
 31 /**
 32  * Helper for string concatenation. These methods are mostly looked up with private lookups
 33  * from {@link java.lang.invoke.StringConcatFactory}, and used in {@link java.lang.invoke.MethodHandle}
 34  * combinators there.
 35  */
 36 final class StringConcatHelper {
 37 
 38     private StringConcatHelper() {
 39         // no instantiation
 40     }
 41 
 42     /**
 43      * Check for overflow, throw exception on overflow.
<span class="line-modified"> 44      *</span>
<span class="line-modified"> 45      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-added"> 46      *                    the upper word.</span>
<span class="line-added"> 47      * @return            the given parameter value, if valid</span>
 48      */
 49     private static long checkOverflow(long lengthCoder) {
 50         if ((int)lengthCoder &gt;= 0) {
 51             return lengthCoder;
 52         }
 53         throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
 54     }
 55 
 56     /**
 57      * Mix value length and coder into current length and coder.
<span class="line-modified"> 58      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 59      *                    the upper word.</span>
<span class="line-modified"> 60      * @param value       value to mix in</span>
<span class="line-added"> 61      * @return            new length and coder</span>
 62      */
<span class="line-modified"> 63     static long mix(long lengthCoder, boolean value) {</span>
<span class="line-modified"> 64         return checkOverflow(lengthCoder + (value ? 4 : 5));</span>
 65     }
 66 
 67     /**
 68      * Mix value length and coder into current length and coder.
<span class="line-modified"> 69      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 70      *                    the upper word.</span>
<span class="line-modified"> 71      * @param value       value to mix in</span>
<span class="line-added"> 72      * @return            new length and coder</span>
 73      */
<span class="line-modified"> 74     static long mix(long lengthCoder, byte value) {</span>
<span class="line-modified"> 75         return mix(lengthCoder, (int)value);</span>
 76     }
 77 
 78     /**
 79      * Mix value length and coder into current length and coder.
<span class="line-modified"> 80      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 81      *                    the upper word.</span>
<span class="line-modified"> 82      * @param value       value to mix in</span>
<span class="line-added"> 83      * @return            new length and coder</span>
 84      */
<span class="line-modified"> 85     static long mix(long lengthCoder, char value) {</span>
<span class="line-modified"> 86         return checkOverflow(lengthCoder + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
 87     }
 88 
 89     /**
 90      * Mix value length and coder into current length and coder.
<span class="line-modified"> 91      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 92      *                    the upper word.</span>
<span class="line-modified"> 93      * @param value       value to mix in</span>
<span class="line-added"> 94      * @return            new length and coder</span>
 95      */
<span class="line-modified"> 96     static long mix(long lengthCoder, short value) {</span>
<span class="line-modified"> 97         return mix(lengthCoder, (int)value);</span>
 98     }
 99 
100     /**
101      * Mix value length and coder into current length and coder.
<span class="line-modified">102      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">103      *                    the upper word.</span>
<span class="line-modified">104      * @param value       value to mix in</span>
<span class="line-added">105      * @return            new length and coder</span>
106      */
<span class="line-modified">107     static long mix(long lengthCoder, int value) {</span>
<span class="line-modified">108         return checkOverflow(lengthCoder + Integer.stringSize(value));</span>
109     }
110 
111     /**
112      * Mix value length and coder into current length and coder.
<span class="line-modified">113      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">114      *                    the upper word.</span>
<span class="line-modified">115      * @param value       value to mix in</span>
<span class="line-added">116      * @return            new length and coder</span>
117      */
<span class="line-modified">118     static long mix(long lengthCoder, long value) {</span>
<span class="line-modified">119         return checkOverflow(lengthCoder + Long.stringSize(value));</span>
120     }
121 
122     /**
123      * Mix value length and coder into current length and coder.
<span class="line-modified">124      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">125      *                    the upper word.</span>
<span class="line-modified">126      * @param value       value to mix in</span>
<span class="line-added">127      * @return            new length and coder</span>
128      */
<span class="line-modified">129     static long mix(long lengthCoder, String value) {</span>
<span class="line-modified">130         lengthCoder += value.length();</span>
131         if (value.coder() == String.UTF16) {
<span class="line-modified">132             lengthCoder |= UTF16;</span>
133         }
<span class="line-modified">134         return checkOverflow(lengthCoder);</span>
135     }
136 
137     /**
138      * Prepends the stringly representation of boolean value into buffer,
139      * given the coder and final index. Index is measured in chars, not in bytes!
140      *
141      * @param indexCoder final char index in the buffer, along with coder packed
142      *                   into higher bits.
143      * @param buf        buffer to append to
144      * @param value      boolean value to encode
145      * @return           updated index (coder value retained)
146      */
<span class="line-modified">147     private static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
148         int index = (int)indexCoder;
149         if (indexCoder &lt; UTF16) {
150             if (value) {
151                 buf[--index] = &#39;e&#39;;
152                 buf[--index] = &#39;u&#39;;
153                 buf[--index] = &#39;r&#39;;
154                 buf[--index] = &#39;t&#39;;
155             } else {
156                 buf[--index] = &#39;e&#39;;
157                 buf[--index] = &#39;s&#39;;
158                 buf[--index] = &#39;l&#39;;
159                 buf[--index] = &#39;a&#39;;
160                 buf[--index] = &#39;f&#39;;
161             }
162             return index;
163         } else {
164             if (value) {
165                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
166                 StringUTF16.putChar(buf, --index, &#39;u&#39;);
167                 StringUTF16.putChar(buf, --index, &#39;r&#39;);
168                 StringUTF16.putChar(buf, --index, &#39;t&#39;);
169             } else {
170                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
171                 StringUTF16.putChar(buf, --index, &#39;s&#39;);
172                 StringUTF16.putChar(buf, --index, &#39;l&#39;);
173                 StringUTF16.putChar(buf, --index, &#39;a&#39;);
174                 StringUTF16.putChar(buf, --index, &#39;f&#39;);
175             }
176             return index | UTF16;
177         }
178     }
179 
180     /**
<span class="line-modified">181      * Prepends constant and the stringly representation of value into buffer,</span>
182      * given the coder and final index. Index is measured in chars, not in bytes!
183      *
184      * @param indexCoder final char index in the buffer, along with coder packed
185      *                   into higher bits.
186      * @param buf        buffer to append to
<span class="line-modified">187      * @param prefix     a constant to prepend before value</span>
<span class="line-added">188      * @param value      boolean value to encode</span>
<span class="line-added">189      * @param suffix     a constant to prepend after value</span>
190      * @return           updated index (coder value retained)
191      */
<span class="line-modified">192     static long prepend(long indexCoder, byte[] buf, String prefix, boolean value, String suffix) {</span>
<span class="line-modified">193         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">194         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">195         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">196         return indexCoder;</span>
<span class="line-added">197     }</span>
<span class="line-added">198 </span>
<span class="line-added">199     /**</span>
<span class="line-added">200      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">201      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">202      *</span>
<span class="line-added">203      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">204      *                   into higher bits.</span>
<span class="line-added">205      * @param buf        buffer to append to</span>
<span class="line-added">206      * @param prefix     a constant to prepend before value</span>
<span class="line-added">207      * @param value      boolean value to encode</span>
<span class="line-added">208      * @param suffix     a constant to prepend after value</span>
<span class="line-added">209      * @return           updated index (coder value retained)</span>
<span class="line-added">210      */</span>
<span class="line-added">211     static long prepend(long indexCoder, byte[] buf, String prefix, byte value, String suffix) {</span>
<span class="line-added">212         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">213         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">214         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">215         return indexCoder;</span>
216     }
217 
218     /**
219      * Prepends the stringly representation of char value into buffer,
220      * given the coder and final index. Index is measured in chars, not in bytes!
221      *
222      * @param indexCoder final char index in the buffer, along with coder packed
223      *                   into higher bits.
224      * @param buf        buffer to append to
225      * @param value      char value to encode
226      * @return           updated index (coder value retained)
227      */
<span class="line-modified">228     private static long prepend(long indexCoder, byte[] buf, char value) {</span>
229         if (indexCoder &lt; UTF16) {
230             buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
231         } else {
232             StringUTF16.putChar(buf, (int)(--indexCoder), value);
233         }
234         return indexCoder;
235     }
236 
237     /**
<span class="line-modified">238      * Prepends constant and the stringly representation of value into buffer,</span>
239      * given the coder and final index. Index is measured in chars, not in bytes!
240      *
241      * @param indexCoder final char index in the buffer, along with coder packed
242      *                   into higher bits.
243      * @param buf        buffer to append to
<span class="line-modified">244      * @param prefix     a constant to prepend before value</span>
<span class="line-added">245      * @param value      boolean value to encode</span>
<span class="line-added">246      * @param suffix     a constant to prepend after value</span>
247      * @return           updated index (coder value retained)
248      */
<span class="line-modified">249     static long prepend(long indexCoder, byte[] buf, String prefix, char value, String suffix) {</span>
<span class="line-modified">250         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">251         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">252         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">253         return indexCoder;</span>
<span class="line-added">254     }</span>
<span class="line-added">255 </span>
<span class="line-added">256     /**</span>
<span class="line-added">257      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">258      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">259      *</span>
<span class="line-added">260      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">261      *                   into higher bits.</span>
<span class="line-added">262      * @param buf        buffer to append to</span>
<span class="line-added">263      * @param prefix     a constant to prepend before value</span>
<span class="line-added">264      * @param value      boolean value to encode</span>
<span class="line-added">265      * @param suffix     a constant to prepend after value</span>
<span class="line-added">266      * @return           updated index (coder value retained)</span>
<span class="line-added">267      */</span>
<span class="line-added">268     static long prepend(long indexCoder, byte[] buf, String prefix, short value, String suffix) {</span>
<span class="line-added">269         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">270         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">271         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">272         return indexCoder;</span>
273     }
274 
275     /**
276      * Prepends the stringly representation of integer value into buffer,
277      * given the coder and final index. Index is measured in chars, not in bytes!
278      *
279      * @param indexCoder final char index in the buffer, along with coder packed
280      *                   into higher bits.
281      * @param buf        buffer to append to
282      * @param value      integer value to encode
283      * @return           updated index (coder value retained)
284      */
<span class="line-modified">285     private static long prepend(long indexCoder, byte[] buf, int value) {</span>
286         if (indexCoder &lt; UTF16) {
287             return Integer.getChars(value, (int)indexCoder, buf);
288         } else {
289             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
290         }
291     }
292 
<span class="line-added">293     /**</span>
<span class="line-added">294      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">295      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">296      *</span>
<span class="line-added">297      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">298      *                   into higher bits.</span>
<span class="line-added">299      * @param buf        buffer to append to</span>
<span class="line-added">300      * @param prefix     a constant to prepend before value</span>
<span class="line-added">301      * @param value      boolean value to encode</span>
<span class="line-added">302      * @param suffix     a constant to prepend after value</span>
<span class="line-added">303      * @return           updated index (coder value retained)</span>
<span class="line-added">304      */</span>
<span class="line-added">305     static long prepend(long indexCoder, byte[] buf, String prefix, int value, String suffix) {</span>
<span class="line-added">306         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">307         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">308         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">309         return indexCoder;</span>
<span class="line-added">310     }</span>
<span class="line-added">311 </span>
312     /**
313      * Prepends the stringly representation of long value into buffer,
314      * given the coder and final index. Index is measured in chars, not in bytes!
315      *
316      * @param indexCoder final char index in the buffer, along with coder packed
317      *                   into higher bits.
318      * @param buf        buffer to append to
319      * @param value      long value to encode
320      * @return           updated index (coder value retained)
321      */
<span class="line-modified">322     private static long prepend(long indexCoder, byte[] buf, long value) {</span>
323         if (indexCoder &lt; UTF16) {
324             return Long.getChars(value, (int)indexCoder, buf);
325         } else {
326             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
327         }
328     }
329 
<span class="line-added">330     /**</span>
<span class="line-added">331      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">332      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">333      *</span>
<span class="line-added">334      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">335      *                   into higher bits.</span>
<span class="line-added">336      * @param buf        buffer to append to</span>
<span class="line-added">337      * @param prefix     a constant to prepend before value</span>
<span class="line-added">338      * @param value      boolean value to encode</span>
<span class="line-added">339      * @param suffix     a constant to prepend after value</span>
<span class="line-added">340      * @return           updated index (coder value retained)</span>
<span class="line-added">341      */</span>
<span class="line-added">342     static long prepend(long indexCoder, byte[] buf, String prefix, long value, String suffix) {</span>
<span class="line-added">343         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">344         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">345         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">346         return indexCoder;</span>
<span class="line-added">347     }</span>
<span class="line-added">348 </span>
349     /**
350      * Prepends the stringly representation of String value into buffer,
351      * given the coder and final index. Index is measured in chars, not in bytes!
352      *
353      * @param indexCoder final char index in the buffer, along with coder packed
354      *                   into higher bits.
355      * @param buf        buffer to append to
356      * @param value      String value to encode
357      * @return           updated index (coder value retained)
358      */
<span class="line-modified">359     private static long prepend(long indexCoder, byte[] buf, String value) {</span>
360         indexCoder -= value.length();
361         if (indexCoder &lt; UTF16) {
362             value.getBytes(buf, (int)indexCoder, String.LATIN1);
363         } else {
364             value.getBytes(buf, (int)indexCoder, String.UTF16);
365         }
366         return indexCoder;
367     }
368 
<span class="line-added">369     /**</span>
<span class="line-added">370      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">371      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">372      *</span>
<span class="line-added">373      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">374      *                   into higher bits.</span>
<span class="line-added">375      * @param buf        buffer to append to</span>
<span class="line-added">376      * @param prefix     a constant to prepend before value</span>
<span class="line-added">377      * @param value      boolean value to encode</span>
<span class="line-added">378      * @param suffix     a constant to prepend after value</span>
<span class="line-added">379      * @return           updated index (coder value retained)</span>
<span class="line-added">380      */</span>
<span class="line-added">381     static long prepend(long indexCoder, byte[] buf, String prefix, String value, String suffix) {</span>
<span class="line-added">382         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">383         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">384         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">385         return indexCoder;</span>
<span class="line-added">386     }</span>
<span class="line-added">387 </span>
388     /**
389      * Instantiates the String with given buffer and coder
390      * @param buf           buffer to use
391      * @param indexCoder    remaining index (should be zero) and coder
392      * @return String       resulting string
393      */
394     static String newString(byte[] buf, long indexCoder) {
395         // Use the private, non-copying constructor (unsafe!)
396         if (indexCoder == LATIN1) {
397             return new String(buf, String.LATIN1);
398         } else if (indexCoder == UTF16) {
399             return new String(buf, String.UTF16);
400         } else {
401             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
402         }
403     }
404 
<span class="line-added">405     /**</span>
<span class="line-added">406      * Perform a simple concatenation between two objects. Added for startup</span>
<span class="line-added">407      * performance, but also demonstrates the code that would be emitted by</span>
<span class="line-added">408      * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}</span>
<span class="line-added">409      * for two Object arguments.</span>
<span class="line-added">410      *</span>
<span class="line-added">411      * @param first         first argument</span>
<span class="line-added">412      * @param second        second argument</span>
<span class="line-added">413      * @return String       resulting string</span>
<span class="line-added">414      */</span>
<span class="line-added">415     @ForceInline</span>
<span class="line-added">416     static String simpleConcat(Object first, Object second) {</span>
<span class="line-added">417         String s1 = stringOf(first);</span>
<span class="line-added">418         String s2 = stringOf(second);</span>
<span class="line-added">419         // start &quot;mixing&quot; in length and coder or arguments, order is not</span>
<span class="line-added">420         // important</span>
<span class="line-added">421         long indexCoder = mix(initialCoder(), s2);</span>
<span class="line-added">422         indexCoder = mix(indexCoder, s1);</span>
<span class="line-added">423         byte[] buf = newArray(indexCoder);</span>
<span class="line-added">424         // prepend each argument in reverse order, since we prepending</span>
<span class="line-added">425         // from the end of the byte array</span>
<span class="line-added">426         indexCoder = prepend(indexCoder, buf, s2);</span>
<span class="line-added">427         indexCoder = prepend(indexCoder, buf, s1);</span>
<span class="line-added">428         return newString(buf, indexCoder);</span>
<span class="line-added">429     }</span>
<span class="line-added">430 </span>
<span class="line-added">431     /**</span>
<span class="line-added">432      * We need some additional conversion for Objects in general, because</span>
<span class="line-added">433      * {@code String.valueOf(Object)} may return null. String conversion rules</span>
<span class="line-added">434      * in Java state we need to produce &quot;null&quot; String in this case, so we</span>
<span class="line-added">435      * provide a customized version that deals with this problematic corner case.</span>
<span class="line-added">436      */</span>
<span class="line-added">437     static String stringOf(Object value) {</span>
<span class="line-added">438         String s;</span>
<span class="line-added">439         return (value == null || (s = value.toString()) == null) ? &quot;null&quot; : s;</span>
<span class="line-added">440     }</span>
<span class="line-added">441 </span>
442     private static final long LATIN1 = (long)String.LATIN1 &lt;&lt; 32;
443 
444     private static final long UTF16 = (long)String.UTF16 &lt;&lt; 32;
445 
<span class="line-added">446     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-added">447 </span>
<span class="line-added">448     /**</span>
<span class="line-added">449      * Allocates an uninitialized byte array based on the length and coder information</span>
<span class="line-added">450      * in indexCoder</span>
<span class="line-added">451      * @param indexCoder</span>
<span class="line-added">452      * @return the newly allocated byte array</span>
<span class="line-added">453      */</span>
<span class="line-added">454     @ForceInline</span>
<span class="line-added">455     static byte[] newArray(long indexCoder) {</span>
<span class="line-added">456         byte coder = (byte)(indexCoder &gt;&gt; 32);</span>
<span class="line-added">457         int index = (int)indexCoder;</span>
<span class="line-added">458         return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index &lt;&lt; coder);</span>
<span class="line-added">459     }</span>
<span class="line-added">460 </span>
461     /**
462      * Provides the initial coder for the String.
463      * @return initial coder, adjusted into the upper half
464      */
465     static long initialCoder() {
466         return String.COMPACT_STRINGS ? LATIN1 : UTF16;
467     }
468 
469 }
</pre>
</td>
</tr>
</table>
<center><a href="StringCoding.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringIndexOutOfBoundsException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
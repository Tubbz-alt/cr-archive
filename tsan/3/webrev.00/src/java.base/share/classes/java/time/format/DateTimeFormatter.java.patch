diff a/src/java.base/share/classes/java/time/format/DateTimeFormatter.java b/src/java.base/share/classes/java/time/format/DateTimeFormatter.java
--- a/src/java.base/share/classes/java/time/format/DateTimeFormatter.java
+++ b/src/java.base/share/classes/java/time/format/DateTimeFormatter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -148,11 +148,11 @@
  * <p>
  * Some applications may need to use the older {@link Format java.text.Format}
  * class for formatting. The {@link #toFormat()} method returns an
  * implementation of {@code java.text.Format}.
  *
- * <h3 id="predefined">Predefined Formatters</h3>
+ * <h2 id="predefined">Predefined Formatters</h2>
  * <table class="striped" style="text-align:left">
  * <caption>Predefined Formatters</caption>
  * <thead>
  * <tr>
  * <th scope="col">Formatter</th>
@@ -256,11 +256,11 @@
  * <td>'Tue, 3 Jun 2008 11:05:30 GMT'</td>
  * </tr>
  * </tbody>
  * </table>
  *
- * <h3 id="patterns">Patterns for Formatting and Parsing</h3>
+ * <h2 id="patterns">Patterns for Formatting and Parsing</h2>
  * Patterns are based on a simple sequence of letters and symbols.
  * A pattern is used to create a Formatter using the
  * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
  * For example,
  * {@code "d MMM uuuu"} will format 2011-12-03 as '3&nbsp;Dec&nbsp;2011'.
@@ -394,19 +394,20 @@
  * second, with a colon, such as '+01:30:15'. Six or more letters throws
  * {@code IllegalArgumentException}. Pattern letter 'X' (upper case) will output
  * 'Z' when the offset to be output would be zero, whereas pattern letter 'x'
  * (lower case) will output '+00', '+0000', or '+00:00'.
  * <p>
- * <b>Offset O</b>: This formats the localized offset based on the number of
- * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}
- * form of the localized offset, which is localized offset text, such as 'GMT',
- * with hour without leading zero, optional 2-digit minute and second if
- * non-zero, and colon, for example 'GMT+8'. Four letters outputs the
- * {@linkplain TextStyle#FULL full} form, which is localized offset text,
- * such as 'GMT, with 2-digit hour and minute field, optional second field
- * if non-zero, and colon, for example 'GMT+08:00'. Any other count of letters
- * throws {@code IllegalArgumentException}.
+ * <b>Offset O</b>: With a non-zero offset, this formats the localized offset
+ * based on the number of pattern letters. One letter outputs the
+ * {@linkplain TextStyle#SHORT short} form of the localized offset, which is
+ * localized offset text, such as 'GMT', with hour without leading zero, optional
+ * 2-digit minute and second if non-zero, and colon, for example 'GMT+8'. Four
+ * letters outputs the {@linkplain TextStyle#FULL full} form, which is localized
+ * offset text, such as 'GMT, with 2-digit hour and minute field, optional second
+ * field if non-zero, and colon, for example 'GMT+08:00'. If the offset is zero,
+ * only localized text is output. Any other count of letters throws
+ * {@code IllegalArgumentException}.
  * <p>
  * <b>Offset Z</b>: This formats the offset based on the number of pattern
  * letters. One, two or three letters outputs the hour and minute, without a
  * colon, such as '+0130'. The output will be '+0000' when the offset is zero.
  * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
@@ -432,11 +433,11 @@
  * '[', ']', '{', '}', '#' and the single quote will be output directly.
  * Despite this, it is recommended to use single quotes around all characters
  * that you want to output directly to ensure that future changes do not break
  * your application.
  *
- * <h3 id="resolving">Resolving</h3>
+ * <h2 id="resolving">Resolving</h2>
  * Parsing is implemented as a two-phase operation.
  * First, the text is parsed using the layout defined by the formatter, producing
  * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
  * Second, the parsed data is <em>resolved</em>, by validating, combining and
  * simplifying the various fields into more useful ones.

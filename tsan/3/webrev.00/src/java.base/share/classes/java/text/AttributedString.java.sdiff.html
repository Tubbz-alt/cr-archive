<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/AttributedString.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AttributedCharacterIterator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Bidi.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/AttributedString.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 100                     while (index &lt; end) {
 101                         iterator.setIndex(index);
 102 
 103                         Map&lt;Attribute,Object&gt; attrs = iterator.getAttributes();
 104 
 105                         if (mapsDiffer(last, attrs)) {
 106                             setAttributes(attrs, index - start + offset);
 107                         }
 108                         last = attrs;
 109                         index = iterator.getRunLimit();
 110                     }
 111                     offset += (end - start);
 112                 }
 113             }
 114         }
 115     }
 116 
 117     /**
 118      * Constructs an AttributedString instance with the given text.
 119      * @param text The text for this attributed string.
<span class="line-modified"> 120      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</span>
 121      */
 122     public AttributedString(String text) {
 123         if (text == null) {
 124             throw new NullPointerException();
 125         }
 126         this.text = text;
 127     }
 128 
 129     /**
 130      * Constructs an AttributedString instance with the given text and attributes.
 131      * @param text The text for this attributed string.
 132      * @param attributes The attributes that apply to the entire string.
<span class="line-modified"> 133      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; or</span>
<span class="line-modified"> 134      *            &lt;code&gt;attributes&lt;/code&gt; is null.</span>
<span class="line-modified"> 135      * @exception IllegalArgumentException if the text has length 0</span>
 136      * and the attributes parameter is not an empty Map (attributes
 137      * cannot be applied to a 0-length range).
 138      */
 139     public AttributedString(String text,
 140                             Map&lt;? extends Attribute, ?&gt; attributes)
 141     {
 142         if (text == null || attributes == null) {
 143             throw new NullPointerException();
 144         }
 145         this.text = text;
 146 
 147         if (text.isEmpty()) {
 148             if (attributes.isEmpty())
 149                 return;
 150             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 151         }
 152 
 153         int attributeCount = attributes.size();
 154         if (attributeCount &gt; 0) {
 155             createRunAttributeDataVectors();
 156             Vector&lt;Attribute&gt; newRunAttributes = new Vector&lt;&gt;(attributeCount);
 157             Vector&lt;Object&gt; newRunAttributeValues = new Vector&lt;&gt;(attributeCount);
 158             runAttributes[0] = newRunAttributes;
 159             runAttributeValues[0] = newRunAttributeValues;
 160 
 161             Iterator&lt;? extends Map.Entry&lt;? extends Attribute, ?&gt;&gt; iterator = attributes.entrySet().iterator();
 162             while (iterator.hasNext()) {
 163                 Map.Entry&lt;? extends Attribute, ?&gt; entry = iterator.next();
 164                 newRunAttributes.addElement(entry.getKey());
 165                 newRunAttributeValues.addElement(entry.getValue());
 166             }
 167         }
 168     }
 169 
 170     /**
 171      * Constructs an AttributedString instance with the given attributed
 172      * text represented by AttributedCharacterIterator.
 173      * @param text The text for this attributed string.
<span class="line-modified"> 174      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</span>
 175      */
 176     public AttributedString(AttributedCharacterIterator text) {
 177         // If performance is critical, this constructor should be
 178         // implemented here rather than invoking the constructor for a
 179         // subrange. We can avoid some range checking in the loops.
 180         this(text, text.getBeginIndex(), text.getEndIndex(), null);
 181     }
 182 
 183     /**
 184      * Constructs an AttributedString instance with the subrange of
 185      * the given attributed text represented by
 186      * AttributedCharacterIterator. If the given range produces an
 187      * empty text, all attributes will be discarded.  Note that any
 188      * attributes wrapped by an Annotation object are discarded for a
 189      * subrange of the original attribute range.
 190      *
 191      * @param text The text for this attributed string.
 192      * @param beginIndex Index of the first character of the range.
 193      * @param endIndex Index of the character following the last character
 194      * of the range.
<span class="line-modified"> 195      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</span>
<span class="line-modified"> 196      * @exception IllegalArgumentException if the subrange given by</span>
 197      * beginIndex and endIndex is out of the text range.
 198      * @see java.text.Annotation
 199      */
 200     public AttributedString(AttributedCharacterIterator text,
 201                             int beginIndex,
 202                             int endIndex) {
 203         this(text, beginIndex, endIndex, null);
 204     }
 205 
 206     /**
 207      * Constructs an AttributedString instance with the subrange of
 208      * the given attributed text represented by
 209      * AttributedCharacterIterator.  Only attributes that match the
 210      * given attributes will be incorporated into the instance. If the
 211      * given range produces an empty text, all attributes will be
 212      * discarded. Note that any attributes wrapped by an Annotation
 213      * object are discarded for a subrange of the original attribute
 214      * range.
 215      *
 216      * @param text The text for this attributed string.
 217      * @param beginIndex Index of the first character of the range.
 218      * @param endIndex Index of the character following the last character
 219      * of the range.
 220      * @param attributes Specifies attributes to be extracted
 221      * from the text. If null is specified, all available attributes will
 222      * be used.
<span class="line-modified"> 223      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; is null.</span>
<span class="line-modified"> 224      * @exception IllegalArgumentException if the subrange given by</span>
 225      * beginIndex and endIndex is out of the text range.
 226      * @see java.text.Annotation
 227      */
 228     public AttributedString(AttributedCharacterIterator text,
 229                             int beginIndex,
 230                             int endIndex,
 231                             Attribute[] attributes) {
 232         if (text == null) {
 233             throw new NullPointerException();
 234         }
 235 
 236         // Validate the given subrange
 237         int textBeginIndex = text.getBeginIndex();
 238         int textEndIndex = text.getEndIndex();
 239         if (beginIndex &lt; textBeginIndex || endIndex &gt; textEndIndex || beginIndex &gt; endIndex)
 240             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 241 
 242         // Copy the given string
 243         StringBuilder textBuilder = new StringBuilder();
 244         text.setIndex(beginIndex);
</pre>
<hr />
<pre>
 290                             // attribute is applied to any subrange
 291                             if (start &lt; beginIndex)
 292                                 start = beginIndex;
 293                             if (limit &gt; endIndex)
 294                                 limit = endIndex;
 295                             if (start != limit) {
 296                                 addAttribute(attributeKey, value, start - beginIndex, limit - beginIndex);
 297                             }
 298                         }
 299                     }
 300                 }
 301                 text.setIndex(limit);
 302             }
 303         }
 304     }
 305 
 306     /**
 307      * Adds an attribute to the entire string.
 308      * @param attribute the attribute key
 309      * @param value the value of the attribute; may be null
<span class="line-modified"> 310      * @exception NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null.</span>
<span class="line-modified"> 311      * @exception IllegalArgumentException if the AttributedString has length 0</span>
 312      * (attributes cannot be applied to a 0-length range).
 313      */
 314     public void addAttribute(Attribute attribute, Object value) {
 315 
 316         if (attribute == null) {
 317             throw new NullPointerException();
 318         }
 319 
 320         int len = length();
 321         if (len == 0) {
 322             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 323         }
 324 
 325         addAttributeImpl(attribute, value, 0, len);
 326     }
 327 
 328     /**
 329      * Adds an attribute to a subrange of the string.
 330      * @param attribute the attribute key
 331      * @param value The value of the attribute. May be null.
 332      * @param beginIndex Index of the first character of the range.
 333      * @param endIndex Index of the character following the last character of the range.
<span class="line-modified"> 334      * @exception NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null.</span>
<span class="line-modified"> 335      * @exception IllegalArgumentException if beginIndex is less than 0, endIndex is</span>
 336      * greater than the length of the string, or beginIndex and endIndex together don&#39;t
 337      * define a non-empty subrange of the string.
 338      */
 339     public void addAttribute(Attribute attribute, Object value,
 340             int beginIndex, int endIndex) {
 341 
 342         if (attribute == null) {
 343             throw new NullPointerException();
 344         }
 345 
 346         if (beginIndex &lt; 0 || endIndex &gt; length() || beginIndex &gt;= endIndex) {
 347             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 348         }
 349 
 350         addAttributeImpl(attribute, value, beginIndex, endIndex);
 351     }
 352 
 353     /**
 354      * Adds a set of attributes to a subrange of the string.
 355      * @param attributes The attributes to be added to the string.
 356      * @param beginIndex Index of the first character of the range.
 357      * @param endIndex Index of the character following the last
 358      * character of the range.
<span class="line-modified"> 359      * @exception NullPointerException if &lt;code&gt;attributes&lt;/code&gt; is null.</span>
<span class="line-modified"> 360      * @exception IllegalArgumentException if beginIndex is less than</span>
 361      * 0, endIndex is greater than the length of the string, or
 362      * beginIndex and endIndex together don&#39;t define a non-empty
 363      * subrange of the string and the attributes parameter is not an
 364      * empty Map.
 365      */
 366     public void addAttributes(Map&lt;? extends Attribute, ?&gt; attributes,
 367                               int beginIndex, int endIndex)
 368     {
 369         if (attributes == null) {
 370             throw new NullPointerException();
 371         }
 372 
 373         if (beginIndex &lt; 0 || endIndex &gt; length() || beginIndex &gt; endIndex) {
 374             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 375         }
 376         if (beginIndex == endIndex) {
 377             if (attributes.isEmpty())
 378                 return;
 379             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 380         }
</pre>
<hr />
<pre>
 563      *
 564      * @param attributes a list of attributes that the client is interested in
 565      * @return an iterator providing access to the entire text and its selected attributes
 566      */
 567     public AttributedCharacterIterator getIterator(Attribute[] attributes) {
 568         return getIterator(attributes, 0, length());
 569     }
 570 
 571     /**
 572      * Creates an AttributedCharacterIterator instance that provides access to
 573      * selected contents of this string.
 574      * Information about attributes not listed in attributes that the
 575      * implementor may have need not be made accessible through the iterator.
 576      * If the list is null, all available attribute information should be made
 577      * accessible.
 578      *
 579      * @param attributes a list of attributes that the client is interested in
 580      * @param beginIndex the index of the first character
 581      * @param endIndex the index of the character following the last character
 582      * @return an iterator providing access to the text and its attributes
<span class="line-modified"> 583      * @exception IllegalArgumentException if beginIndex is less than 0,</span>
 584      * endIndex is greater than the length of the string, or beginIndex is
 585      * greater than endIndex.
 586      */
 587     public AttributedCharacterIterator getIterator(Attribute[] attributes, int beginIndex, int endIndex) {
 588         return new AttributedStringIterator(attributes, beginIndex, endIndex);
 589     }
 590 
 591     // all (with the exception of length) reading operations are private,
 592     // since AttributedString instances are accessed through iterators.
 593 
 594     // length is package private so that CharacterIteratorFieldDelegate can
 595     // access it without creating an AttributedCharacterIterator.
 596     int length() {
 597         return text.length();
 598     }
 599 
 600     private char charAt(int index) {
 601         return text.charAt(index);
 602     }
 603 
</pre>
<hr />
<pre>
1083             return AttributedString.this.getAttributeCheckRange((Attribute) key, runIndex, beginIndex, endIndex);
1084         }
1085     }
1086 }
1087 
1088 class AttributeEntry implements Map.Entry&lt;Attribute,Object&gt; {
1089 
1090     private Attribute key;
1091     private Object value;
1092 
1093     AttributeEntry(Attribute key, Object value) {
1094         this.key = key;
1095         this.value = value;
1096     }
1097 
1098     public boolean equals(Object o) {
1099         if (!(o instanceof AttributeEntry)) {
1100             return false;
1101         }
1102         AttributeEntry other = (AttributeEntry) o;
<span class="line-modified">1103         return other.key.equals(key) &amp;&amp;</span>
<span class="line-removed">1104             (value == null ? other.value == null : other.value.equals(value));</span>
1105     }
1106 
1107     public Attribute getKey() {
1108         return key;
1109     }
1110 
1111     public Object getValue() {
1112         return value;
1113     }
1114 
1115     public Object setValue(Object newValue) {
1116         throw new UnsupportedOperationException();
1117     }
1118 
1119     public int hashCode() {
1120         return key.hashCode() ^ (value==null ? 0 : value.hashCode());
1121     }
1122 
1123     public String toString() {
1124         return key.toString()+&quot;=&quot;+value.toString();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 100                     while (index &lt; end) {
 101                         iterator.setIndex(index);
 102 
 103                         Map&lt;Attribute,Object&gt; attrs = iterator.getAttributes();
 104 
 105                         if (mapsDiffer(last, attrs)) {
 106                             setAttributes(attrs, index - start + offset);
 107                         }
 108                         last = attrs;
 109                         index = iterator.getRunLimit();
 110                     }
 111                     offset += (end - start);
 112                 }
 113             }
 114         }
 115     }
 116 
 117     /**
 118      * Constructs an AttributedString instance with the given text.
 119      * @param text The text for this attributed string.
<span class="line-modified"> 120      * @throws    NullPointerException if {@code text} is null.</span>
 121      */
 122     public AttributedString(String text) {
 123         if (text == null) {
 124             throw new NullPointerException();
 125         }
 126         this.text = text;
 127     }
 128 
 129     /**
 130      * Constructs an AttributedString instance with the given text and attributes.
 131      * @param text The text for this attributed string.
 132      * @param attributes The attributes that apply to the entire string.
<span class="line-modified"> 133      * @throws    NullPointerException if {@code text} or</span>
<span class="line-modified"> 134      *            {@code attributes} is null.</span>
<span class="line-modified"> 135      * @throws    IllegalArgumentException if the text has length 0</span>
 136      * and the attributes parameter is not an empty Map (attributes
 137      * cannot be applied to a 0-length range).
 138      */
 139     public AttributedString(String text,
 140                             Map&lt;? extends Attribute, ?&gt; attributes)
 141     {
 142         if (text == null || attributes == null) {
 143             throw new NullPointerException();
 144         }
 145         this.text = text;
 146 
 147         if (text.isEmpty()) {
 148             if (attributes.isEmpty())
 149                 return;
 150             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 151         }
 152 
 153         int attributeCount = attributes.size();
 154         if (attributeCount &gt; 0) {
 155             createRunAttributeDataVectors();
 156             Vector&lt;Attribute&gt; newRunAttributes = new Vector&lt;&gt;(attributeCount);
 157             Vector&lt;Object&gt; newRunAttributeValues = new Vector&lt;&gt;(attributeCount);
 158             runAttributes[0] = newRunAttributes;
 159             runAttributeValues[0] = newRunAttributeValues;
 160 
 161             Iterator&lt;? extends Map.Entry&lt;? extends Attribute, ?&gt;&gt; iterator = attributes.entrySet().iterator();
 162             while (iterator.hasNext()) {
 163                 Map.Entry&lt;? extends Attribute, ?&gt; entry = iterator.next();
 164                 newRunAttributes.addElement(entry.getKey());
 165                 newRunAttributeValues.addElement(entry.getValue());
 166             }
 167         }
 168     }
 169 
 170     /**
 171      * Constructs an AttributedString instance with the given attributed
 172      * text represented by AttributedCharacterIterator.
 173      * @param text The text for this attributed string.
<span class="line-modified"> 174      * @throws    NullPointerException if {@code text} is null.</span>
 175      */
 176     public AttributedString(AttributedCharacterIterator text) {
 177         // If performance is critical, this constructor should be
 178         // implemented here rather than invoking the constructor for a
 179         // subrange. We can avoid some range checking in the loops.
 180         this(text, text.getBeginIndex(), text.getEndIndex(), null);
 181     }
 182 
 183     /**
 184      * Constructs an AttributedString instance with the subrange of
 185      * the given attributed text represented by
 186      * AttributedCharacterIterator. If the given range produces an
 187      * empty text, all attributes will be discarded.  Note that any
 188      * attributes wrapped by an Annotation object are discarded for a
 189      * subrange of the original attribute range.
 190      *
 191      * @param text The text for this attributed string.
 192      * @param beginIndex Index of the first character of the range.
 193      * @param endIndex Index of the character following the last character
 194      * of the range.
<span class="line-modified"> 195      * @throws    NullPointerException if {@code text} is null.</span>
<span class="line-modified"> 196      * @throws    IllegalArgumentException if the subrange given by</span>
 197      * beginIndex and endIndex is out of the text range.
 198      * @see java.text.Annotation
 199      */
 200     public AttributedString(AttributedCharacterIterator text,
 201                             int beginIndex,
 202                             int endIndex) {
 203         this(text, beginIndex, endIndex, null);
 204     }
 205 
 206     /**
 207      * Constructs an AttributedString instance with the subrange of
 208      * the given attributed text represented by
 209      * AttributedCharacterIterator.  Only attributes that match the
 210      * given attributes will be incorporated into the instance. If the
 211      * given range produces an empty text, all attributes will be
 212      * discarded. Note that any attributes wrapped by an Annotation
 213      * object are discarded for a subrange of the original attribute
 214      * range.
 215      *
 216      * @param text The text for this attributed string.
 217      * @param beginIndex Index of the first character of the range.
 218      * @param endIndex Index of the character following the last character
 219      * of the range.
 220      * @param attributes Specifies attributes to be extracted
 221      * from the text. If null is specified, all available attributes will
 222      * be used.
<span class="line-modified"> 223      * @throws    NullPointerException if {@code text} is null.</span>
<span class="line-modified"> 224      * @throws    IllegalArgumentException if the subrange given by</span>
 225      * beginIndex and endIndex is out of the text range.
 226      * @see java.text.Annotation
 227      */
 228     public AttributedString(AttributedCharacterIterator text,
 229                             int beginIndex,
 230                             int endIndex,
 231                             Attribute[] attributes) {
 232         if (text == null) {
 233             throw new NullPointerException();
 234         }
 235 
 236         // Validate the given subrange
 237         int textBeginIndex = text.getBeginIndex();
 238         int textEndIndex = text.getEndIndex();
 239         if (beginIndex &lt; textBeginIndex || endIndex &gt; textEndIndex || beginIndex &gt; endIndex)
 240             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 241 
 242         // Copy the given string
 243         StringBuilder textBuilder = new StringBuilder();
 244         text.setIndex(beginIndex);
</pre>
<hr />
<pre>
 290                             // attribute is applied to any subrange
 291                             if (start &lt; beginIndex)
 292                                 start = beginIndex;
 293                             if (limit &gt; endIndex)
 294                                 limit = endIndex;
 295                             if (start != limit) {
 296                                 addAttribute(attributeKey, value, start - beginIndex, limit - beginIndex);
 297                             }
 298                         }
 299                     }
 300                 }
 301                 text.setIndex(limit);
 302             }
 303         }
 304     }
 305 
 306     /**
 307      * Adds an attribute to the entire string.
 308      * @param attribute the attribute key
 309      * @param value the value of the attribute; may be null
<span class="line-modified"> 310      * @throws    NullPointerException if {@code attribute} is null.</span>
<span class="line-modified"> 311      * @throws    IllegalArgumentException if the AttributedString has length 0</span>
 312      * (attributes cannot be applied to a 0-length range).
 313      */
 314     public void addAttribute(Attribute attribute, Object value) {
 315 
 316         if (attribute == null) {
 317             throw new NullPointerException();
 318         }
 319 
 320         int len = length();
 321         if (len == 0) {
 322             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 323         }
 324 
 325         addAttributeImpl(attribute, value, 0, len);
 326     }
 327 
 328     /**
 329      * Adds an attribute to a subrange of the string.
 330      * @param attribute the attribute key
 331      * @param value The value of the attribute. May be null.
 332      * @param beginIndex Index of the first character of the range.
 333      * @param endIndex Index of the character following the last character of the range.
<span class="line-modified"> 334      * @throws    NullPointerException if {@code attribute} is null.</span>
<span class="line-modified"> 335      * @throws    IllegalArgumentException if beginIndex is less than 0, endIndex is</span>
 336      * greater than the length of the string, or beginIndex and endIndex together don&#39;t
 337      * define a non-empty subrange of the string.
 338      */
 339     public void addAttribute(Attribute attribute, Object value,
 340             int beginIndex, int endIndex) {
 341 
 342         if (attribute == null) {
 343             throw new NullPointerException();
 344         }
 345 
 346         if (beginIndex &lt; 0 || endIndex &gt; length() || beginIndex &gt;= endIndex) {
 347             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 348         }
 349 
 350         addAttributeImpl(attribute, value, beginIndex, endIndex);
 351     }
 352 
 353     /**
 354      * Adds a set of attributes to a subrange of the string.
 355      * @param attributes The attributes to be added to the string.
 356      * @param beginIndex Index of the first character of the range.
 357      * @param endIndex Index of the character following the last
 358      * character of the range.
<span class="line-modified"> 359      * @throws    NullPointerException if {@code attributes} is null.</span>
<span class="line-modified"> 360      * @throws    IllegalArgumentException if beginIndex is less than</span>
 361      * 0, endIndex is greater than the length of the string, or
 362      * beginIndex and endIndex together don&#39;t define a non-empty
 363      * subrange of the string and the attributes parameter is not an
 364      * empty Map.
 365      */
 366     public void addAttributes(Map&lt;? extends Attribute, ?&gt; attributes,
 367                               int beginIndex, int endIndex)
 368     {
 369         if (attributes == null) {
 370             throw new NullPointerException();
 371         }
 372 
 373         if (beginIndex &lt; 0 || endIndex &gt; length() || beginIndex &gt; endIndex) {
 374             throw new IllegalArgumentException(&quot;Invalid substring range&quot;);
 375         }
 376         if (beginIndex == endIndex) {
 377             if (attributes.isEmpty())
 378                 return;
 379             throw new IllegalArgumentException(&quot;Can&#39;t add attribute to 0-length text&quot;);
 380         }
</pre>
<hr />
<pre>
 563      *
 564      * @param attributes a list of attributes that the client is interested in
 565      * @return an iterator providing access to the entire text and its selected attributes
 566      */
 567     public AttributedCharacterIterator getIterator(Attribute[] attributes) {
 568         return getIterator(attributes, 0, length());
 569     }
 570 
 571     /**
 572      * Creates an AttributedCharacterIterator instance that provides access to
 573      * selected contents of this string.
 574      * Information about attributes not listed in attributes that the
 575      * implementor may have need not be made accessible through the iterator.
 576      * If the list is null, all available attribute information should be made
 577      * accessible.
 578      *
 579      * @param attributes a list of attributes that the client is interested in
 580      * @param beginIndex the index of the first character
 581      * @param endIndex the index of the character following the last character
 582      * @return an iterator providing access to the text and its attributes
<span class="line-modified"> 583      * @throws    IllegalArgumentException if beginIndex is less than 0,</span>
 584      * endIndex is greater than the length of the string, or beginIndex is
 585      * greater than endIndex.
 586      */
 587     public AttributedCharacterIterator getIterator(Attribute[] attributes, int beginIndex, int endIndex) {
 588         return new AttributedStringIterator(attributes, beginIndex, endIndex);
 589     }
 590 
 591     // all (with the exception of length) reading operations are private,
 592     // since AttributedString instances are accessed through iterators.
 593 
 594     // length is package private so that CharacterIteratorFieldDelegate can
 595     // access it without creating an AttributedCharacterIterator.
 596     int length() {
 597         return text.length();
 598     }
 599 
 600     private char charAt(int index) {
 601         return text.charAt(index);
 602     }
 603 
</pre>
<hr />
<pre>
1083             return AttributedString.this.getAttributeCheckRange((Attribute) key, runIndex, beginIndex, endIndex);
1084         }
1085     }
1086 }
1087 
1088 class AttributeEntry implements Map.Entry&lt;Attribute,Object&gt; {
1089 
1090     private Attribute key;
1091     private Object value;
1092 
1093     AttributeEntry(Attribute key, Object value) {
1094         this.key = key;
1095         this.value = value;
1096     }
1097 
1098     public boolean equals(Object o) {
1099         if (!(o instanceof AttributeEntry)) {
1100             return false;
1101         }
1102         AttributeEntry other = (AttributeEntry) o;
<span class="line-modified">1103         return other.key.equals(key) &amp;&amp; Objects.equals(other.value, value);</span>

1104     }
1105 
1106     public Attribute getKey() {
1107         return key;
1108     }
1109 
1110     public Object getValue() {
1111         return value;
1112     }
1113 
1114     public Object setValue(Object newValue) {
1115         throw new UnsupportedOperationException();
1116     }
1117 
1118     public int hashCode() {
1119         return key.hashCode() ^ (value==null ? 0 : value.hashCode());
1120     }
1121 
1122     public String toString() {
1123         return key.toString()+&quot;=&quot;+value.toString();
</pre>
</td>
</tr>
</table>
<center><a href="AttributedCharacterIterator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Bidi.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
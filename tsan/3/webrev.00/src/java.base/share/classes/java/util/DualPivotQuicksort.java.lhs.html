<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/DualPivotQuicksort.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
<a name="2" id="anc2"></a>


  28 /**
<a name="3" id="anc3"></a><span class="line-modified">  29  * This class implements the Dual-Pivot Quicksort algorithm by</span>
<span class="line-modified">  30  * Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm</span>
<span class="line-modified">  31  * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-modified">  32  * quicksorts to degrade to quadratic performance, and is typically</span>
  33  * faster than traditional (one-pivot) Quicksort implementations.
  34  *
<a name="4" id="anc4"></a><span class="line-modified">  35  * All exposed methods are package-private, designed to be invoked</span>
<span class="line-modified">  36  * from public methods (in class Arrays) after performing any</span>
<span class="line-modified">  37  * necessary array bounds checks and expanding parameters into the</span>
<span class="line-removed">  38  * required forms.</span>
  39  *
  40  * @author Vladimir Yaroslavskiy
  41  * @author Jon Bentley
  42  * @author Josh Bloch
<a name="5" id="anc5"></a>


  43  *
<a name="6" id="anc6"></a><span class="line-modified">  44  * @version 2011.02.11 m765.827.12i:5\7pm</span>
<span class="line-removed">  45  * @since 1.7</span>
  46  */
  47 final class DualPivotQuicksort {
  48 
  49     /**
  50      * Prevents instantiation.
  51      */
  52     private DualPivotQuicksort() {}
  53 
<a name="7" id="anc7"></a><span class="line-modified">  54     /*</span>
<span class="line-modified">  55      * Tuning parameters.</span>
  56      */
<a name="8" id="anc8"></a>
  57 
  58     /**
<a name="9" id="anc9"></a><span class="line-modified">  59      * The maximum number of runs in merge sort.</span>
  60      */
<a name="10" id="anc10"></a><span class="line-modified">  61     private static final int MAX_RUN_COUNT = 67;</span>
  62 
  63     /**
<a name="11" id="anc11"></a><span class="line-modified">  64      * If the length of an array to be sorted is less than this</span>
<span class="line-removed">  65      * constant, Quicksort is used in preference to merge sort.</span>
  66      */
<a name="12" id="anc12"></a><span class="line-modified">  67     private static final int QUICKSORT_THRESHOLD = 286;</span>
  68 
  69     /**
<a name="13" id="anc13"></a><span class="line-modified">  70      * If the length of an array to be sorted is less than this</span>
<span class="line-removed">  71      * constant, insertion sort is used in preference to Quicksort.</span>
  72      */
<a name="14" id="anc14"></a><span class="line-modified">  73     private static final int INSERTION_SORT_THRESHOLD = 47;</span>
  74 
  75     /**
<a name="15" id="anc15"></a><span class="line-modified">  76      * If the length of a byte array to be sorted is greater than this</span>
<span class="line-removed">  77      * constant, counting sort is used in preference to insertion sort.</span>
  78      */
<a name="16" id="anc16"></a><span class="line-modified">  79     private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;</span>
  80 
  81     /**
<a name="17" id="anc17"></a><span class="line-modified">  82      * If the length of a short or char array to be sorted is greater</span>
<span class="line-removed">  83      * than this constant, counting sort is used in preference to Quicksort.</span>
  84      */
<a name="18" id="anc18"></a><span class="line-modified">  85     private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;</span>
  86 
<a name="19" id="anc19"></a><span class="line-modified">  87     /*</span>
<span class="line-modified">  88      * Sorting methods for seven primitive types.</span>
  89      */
<a name="20" id="anc20"></a>
  90 
  91     /**
<a name="21" id="anc21"></a><span class="line-modified">  92      * Sorts the specified range of the array using the given</span>
<span class="line-modified">  93      * workspace array slice if possible for merging</span>
<span class="line-modified">  94      *</span>
<span class="line-removed">  95      * @param a the array to be sorted</span>
<span class="line-removed">  96      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed">  97      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed">  98      * @param work a workspace array (slice)</span>
<span class="line-removed">  99      * @param workBase origin of usable space in work array</span>
<span class="line-removed"> 100      * @param workLen usable size of work array</span>
<span class="line-removed"> 101      */</span>
<span class="line-removed"> 102     static void sort(int[] a, int left, int right,</span>
<span class="line-removed"> 103                      int[] work, int workBase, int workLen) {</span>
<span class="line-removed"> 104         // Use Quicksort on small arrays</span>
<span class="line-removed"> 105         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed"> 106             sort(a, left, right, true);</span>
<span class="line-removed"> 107             return;</span>
<span class="line-removed"> 108         }</span>
 109 
<a name="22" id="anc22"></a><span class="line-modified"> 110         /*</span>
<span class="line-modified"> 111          * Index run[i] is the start of i-th run</span>
<span class="line-modified"> 112          * (ascending or descending sequence).</span>
<span class="line-modified"> 113          */</span>
<span class="line-removed"> 114         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed"> 115         int count = 0; run[0] = left;</span>
 116 
<a name="23" id="anc23"></a><span class="line-modified"> 117         // Check if the array is nearly sorted</span>
<span class="line-modified"> 118         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-modified"> 119             // Equal items in the beginning of the sequence</span>
<span class="line-modified"> 120             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed"> 121                 k++;</span>
<span class="line-removed"> 122             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed"> 123             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed"> 124                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed"> 125             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed"> 126                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed"> 127                 // Transform into an ascending sequence</span>
<span class="line-removed"> 128                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed"> 129                     int t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed"> 130                 }</span>
<span class="line-removed"> 131             }</span>
 132 
<a name="24" id="anc24"></a><span class="line-modified"> 133             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified"> 134             // ascending sequence</span>
<span class="line-modified"> 135             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified"> 136                 count--;</span>
<span class="line-removed"> 137             }</span>
 138 
<a name="25" id="anc25"></a><span class="line-modified"> 139             /*</span>
<span class="line-modified"> 140              * The array is not highly structured,</span>
<span class="line-modified"> 141              * use Quicksort instead of merge sort.</span>
<span class="line-modified"> 142              */</span>
<span class="line-removed"> 143             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-removed"> 144                 sort(a, left, right, true);</span>
<span class="line-removed"> 145                 return;</span>
<span class="line-removed"> 146             }</span>
<span class="line-removed"> 147         }</span>
 148 
<a name="26" id="anc26"></a><span class="line-modified"> 149         // These invariants should hold true:</span>
<span class="line-modified"> 150         //    run[0] = 0</span>
<span class="line-modified"> 151         //    run[&lt;last&gt;] = right + 1; (terminator)</span>

 152 
<a name="27" id="anc27"></a><span class="line-modified"> 153         if (count == 0) {</span>
<span class="line-modified"> 154             // A single equal run</span>
<span class="line-modified"> 155             return;</span>
<span class="line-modified"> 156         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified"> 157             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified"> 158             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified"> 159             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified"> 160             return;</span>
<span class="line-modified"> 161         }</span>
<span class="line-modified"> 162         right++;</span>
<span class="line-modified"> 163         if (run[count] &lt; right) {</span>
<span class="line-modified"> 164             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-modified"> 165             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed"> 166             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed"> 167             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed"> 168             run[++count] = right;</span>
<span class="line-removed"> 169         }</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171         // Determine alternation base for merge</span>
<span class="line-removed"> 172         byte odd = 0;</span>
<span class="line-removed"> 173         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed"> 174 </span>
<span class="line-removed"> 175         // Use or create temporary array b for merging</span>
<span class="line-removed"> 176         int[] b;                 // temp array; alternates with a</span>
<span class="line-removed"> 177         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed"> 178         int blen = right - left; // space needed for b</span>
<span class="line-removed"> 179         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed"> 180             work = new int[blen];</span>
<span class="line-removed"> 181             workBase = 0;</span>
<span class="line-removed"> 182         }</span>
<span class="line-removed"> 183         if (odd == 0) {</span>
<span class="line-removed"> 184             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed"> 185             b = a;</span>
<span class="line-removed"> 186             bo = 0;</span>
<span class="line-removed"> 187             a = work;</span>
<span class="line-removed"> 188             ao = workBase - left;</span>
<span class="line-removed"> 189         } else {</span>
<span class="line-removed"> 190             b = work;</span>
<span class="line-removed"> 191             ao = 0;</span>
<span class="line-removed"> 192             bo = workBase - left;</span>
<span class="line-removed"> 193         }</span>
<span class="line-removed"> 194 </span>
<span class="line-removed"> 195         // Merging</span>
<span class="line-removed"> 196         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed"> 197             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed"> 198                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed"> 199                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed"> 200                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed"> 201                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed"> 202                     } else {</span>
<span class="line-removed"> 203                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed"> 204                     }</span>
<span class="line-removed"> 205                 }</span>
<span class="line-removed"> 206                 run[++last] = hi;</span>
<span class="line-removed"> 207             }</span>
<span class="line-removed"> 208             if ((count &amp; 1) != 0) {</span>
<span class="line-removed"> 209                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed"> 210                     b[i + bo] = a[i + ao]</span>
<span class="line-removed"> 211                 );</span>
<span class="line-removed"> 212                 run[++last] = right;</span>
<span class="line-removed"> 213             }</span>
<span class="line-removed"> 214             int[] t = a; a = b; b = t;</span>
<span class="line-removed"> 215             int o = ao; ao = bo; bo = o;</span>
 216         }
<a name="28" id="anc28"></a>
 217     }
 218 
 219     /**
<a name="29" id="anc29"></a><span class="line-modified"> 220      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>







 221      *
 222      * @param a the array to be sorted
<a name="30" id="anc30"></a><span class="line-modified"> 223      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 224      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified"> 225      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified"> 226      */</span>
<span class="line-modified"> 227     private static void sort(int[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified"> 228         int length = right - left + 1;</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230         // Use insertion sort on tiny arrays</span>
<span class="line-removed"> 231         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed"> 232             if (leftmost) {</span>
<span class="line-removed"> 233                 /*</span>
<span class="line-removed"> 234                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed"> 235                  * optimized for server VM, is used in case of</span>
<span class="line-removed"> 236                  * the leftmost part.</span>
<span class="line-removed"> 237                  */</span>
<span class="line-removed"> 238                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed"> 239                     int ai = a[i + 1];</span>
<span class="line-removed"> 240                     while (ai &lt; a[j]) {</span>
<span class="line-removed"> 241                         a[j + 1] = a[j];</span>
<span class="line-removed"> 242                         if (j-- == left) {</span>
<span class="line-removed"> 243                             break;</span>
<span class="line-removed"> 244                         }</span>
<span class="line-removed"> 245                     }</span>
<span class="line-removed"> 246                     a[j + 1] = ai;</span>
<span class="line-removed"> 247                 }</span>
<span class="line-removed"> 248             } else {</span>
<span class="line-removed"> 249                 /*</span>
<span class="line-removed"> 250                  * Skip the longest ascending sequence.</span>
<span class="line-removed"> 251                  */</span>
<span class="line-removed"> 252                 do {</span>
<span class="line-removed"> 253                     if (left &gt;= right) {</span>
<span class="line-removed"> 254                         return;</span>
<span class="line-removed"> 255                     }</span>
<span class="line-removed"> 256                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="line-removed"> 257 </span>
<span class="line-removed"> 258                 /*</span>
<span class="line-removed"> 259                  * Every element from adjoining part plays the role</span>
<span class="line-removed"> 260                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed"> 261                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed"> 262                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed"> 263                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed"> 264                  * than traditional implementation of insertion sort.</span>
<span class="line-removed"> 265                  */</span>
<span class="line-removed"> 266                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-removed"> 267                     int a1 = a[k], a2 = a[left];</span>
<span class="line-removed"> 268 </span>
<span class="line-removed"> 269                     if (a1 &lt; a2) {</span>
<span class="line-removed"> 270                         a2 = a1; a1 = a[left];</span>
<span class="line-removed"> 271                     }</span>
<span class="line-removed"> 272                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed"> 273                         a[k + 2] = a[k];</span>
<span class="line-removed"> 274                     }</span>
<span class="line-removed"> 275                     a[++k + 1] = a1;</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277                     while (a2 &lt; a[--k]) {</span>
<span class="line-removed"> 278                         a[k + 1] = a[k];</span>
<span class="line-removed"> 279                     }</span>
<span class="line-removed"> 280                     a[k + 1] = a2;</span>
<span class="line-removed"> 281                 }</span>
<span class="line-removed"> 282                 int last = a[right];</span>
 283 
<a name="31" id="anc31"></a><span class="line-modified"> 284                 while (last &lt; a[--right]) {</span>
<span class="line-modified"> 285                     a[right + 1] = a[right];</span>
<span class="line-modified"> 286                 }</span>
<span class="line-modified"> 287                 a[right + 1] = last;</span>
<span class="line-modified"> 288             }</span>
<span class="line-modified"> 289             return;</span>
 290         }
<a name="32" id="anc32"></a>
 291 
<a name="33" id="anc33"></a><span class="line-modified"> 292         // Inexpensive approximation of length / 7</span>
<span class="line-modified"> 293         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-modified"> 294 </span>
<span class="line-modified"> 295         /*</span>
<span class="line-modified"> 296          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-modified"> 297          * center element in the range. These elements will be used for</span>
<span class="line-modified"> 298          * pivot selection as described below. The choice for spacing</span>
<span class="line-modified"> 299          * these elements was empirically determined to work well on</span>
<span class="line-modified"> 300          * a wide variety of inputs.</span>
<span class="line-modified"> 301          */</span>
<span class="line-modified"> 302         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified"> 303         int e2 = e3 - seventh;</span>
<span class="line-modified"> 304         int e1 = e2 - seventh;</span>
<span class="line-modified"> 305         int e4 = e3 + seventh;</span>
<span class="line-removed"> 306         int e5 = e4 + seventh;</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308         // Sort these elements using insertion sort</span>
<span class="line-removed"> 309         if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
 310 
<a name="34" id="anc34"></a><span class="line-modified"> 311         if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 312             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 313         }</span>
<span class="line-modified"> 314         if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified"> 315             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 316                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
 317             }
<a name="35" id="anc35"></a><span class="line-modified"> 318         }</span>
<span class="line-modified"> 319         if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified"> 320             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified"> 321                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 322                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 323                 }</span>

 324             }
<a name="36" id="anc36"></a><span class="line-removed"> 325         }</span>
 326 
<a name="37" id="anc37"></a><span class="line-modified"> 327         // Pointers</span>
<span class="line-modified"> 328         int less  = left;  // The index of the first element of center part</span>
<span class="line-modified"> 329         int great = right; // The index before the first element of right part</span>





 330 
<a name="38" id="anc38"></a><span class="line-removed"> 331         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
 332             /*
<a name="39" id="anc39"></a><span class="line-modified"> 333              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-modified"> 334              * These values are inexpensive approximations of the first and</span>
<span class="line-removed"> 335              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
 336              */
<a name="40" id="anc40"></a><span class="line-modified"> 337             int pivot1 = a[e2];</span>
<span class="line-modified"> 338             int pivot2 = a[e4];</span>


 339 
 340             /*
<a name="41" id="anc41"></a><span class="line-modified"> 341              * The first and the last elements to be sorted are moved to the</span>
<span class="line-modified"> 342              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed"> 343              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed"> 344              * positions, and excluded from subsequent sorting.</span>
 345              */
<a name="42" id="anc42"></a><span class="line-modified"> 346             a[e2] = a[left];</span>
<span class="line-removed"> 347             a[e4] = a[right];</span>
 348 
 349             /*
<a name="43" id="anc43"></a><span class="line-modified"> 350              * Skip elements, which are less or greater than pivot values.</span>



 351              */
<a name="44" id="anc44"></a><span class="line-modified"> 352             while (a[++less] &lt; pivot1);</span>
<span class="line-modified"> 353             while (a[--great] &gt; pivot2);</span>




 354 
 355             /*
<a name="45" id="anc45"></a><span class="line-modified"> 356              * Partitioning:</span>

 357              *
<a name="46" id="anc46"></a><span class="line-modified"> 358              *   left part           center part                   right part</span>
<span class="line-modified"> 359              * +--------------------------------------------------------------+</span>
<span class="line-modified"> 360              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified"> 361              * +--------------------------------------------------------------+</span>
<span class="line-modified"> 362              *               ^                          ^       ^</span>
<span class="line-modified"> 363              *               |                          |       |</span>
<span class="line-modified"> 364              *              less                        k     great</span>
<span class="line-removed"> 365              *</span>
<span class="line-removed"> 366              * Invariants:</span>
<span class="line-removed"> 367              *</span>
<span class="line-removed"> 368              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed"> 369              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed"> 370              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed"> 371              *</span>
<span class="line-removed"> 372              * Pointer k is the first index of ?-part.</span>
 373              */
<a name="47" id="anc47"></a><span class="line-modified"> 374             outer:</span>
<span class="line-modified"> 375             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified"> 376                 int ak = a[k];</span>
<span class="line-modified"> 377                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-modified"> 378                     a[k] = a[less];</span>
<span class="line-modified"> 379                     /*</span>
<span class="line-modified"> 380                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-modified"> 381                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-modified"> 382                      */</span>
<span class="line-modified"> 383                     a[less] = ak;</span>
<span class="line-modified"> 384                     ++less;</span>
<span class="line-modified"> 385                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 386                     while (a[great] &gt; pivot2) {</span>
<span class="line-modified"> 387                         if (great-- == k) {</span>
<span class="line-modified"> 388                             break outer;</span>
<span class="line-modified"> 389                         }</span>
<span class="line-modified"> 390                     }</span>
<span class="line-removed"> 391                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed"> 392                         a[k] = a[less];</span>
<span class="line-removed"> 393                         a[less] = a[great];</span>
<span class="line-removed"> 394                         ++less;</span>
<span class="line-removed"> 395                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed"> 396                         a[k] = a[great];</span>
<span class="line-removed"> 397                     }</span>
<span class="line-removed"> 398                     /*</span>
<span class="line-removed"> 399                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed"> 400                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed"> 401                      */</span>
<span class="line-removed"> 402                     a[great] = ak;</span>
<span class="line-removed"> 403                     --great;</span>
 404                 }
 405             }
 406 
<a name="48" id="anc48"></a><span class="line-modified"> 407             // Swap pivots into their final positions</span>
<span class="line-modified"> 408             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified"> 409             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed"> 410 </span>
<span class="line-removed"> 411             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed"> 412             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed"> 413             sort(a, great + 2, right, false);</span>
 414 
 415             /*
<a name="49" id="anc49"></a><span class="line-modified"> 416              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed"> 417              * swap internal pivot values to ends.</span>
 418              */
<a name="50" id="anc50"></a><span class="line-modified"> 419             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>

 420                 /*
<a name="51" id="anc51"></a><span class="line-modified"> 421                  * Skip elements, which are equal to pivot values.</span>


 422                  */
<a name="52" id="anc52"></a><span class="line-modified"> 423                 while (a[less] == pivot1) {</span>
<span class="line-modified"> 424                     ++less;</span>
<span class="line-removed"> 425                 }</span>
 426 
<a name="53" id="anc53"></a><span class="line-modified"> 427                 while (a[great] == pivot2) {</span>
<span class="line-modified"> 428                     --great;</span>
<span class="line-modified"> 429                 }</span>












 430 
 431                 /*
<a name="54" id="anc54"></a><span class="line-modified"> 432                  * Partitioning:</span>
 433                  *
<a name="55" id="anc55"></a><span class="line-modified"> 434                  *   left part         center part                  right part</span>
<span class="line-modified"> 435                  * +----------------------------------------------------------+</span>
<span class="line-modified"> 436                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified"> 437                  * +----------------------------------------------------------+</span>
<span class="line-modified"> 438                  *              ^                        ^       ^</span>
<span class="line-modified"> 439                  *              |                        |       |</span>
<span class="line-modified"> 440                  *             less                      k     great</span>
 441                  *
 442                  * Invariants:
 443                  *
<a name="56" id="anc56"></a><span class="line-modified"> 444                  *              all in (*,  less) == pivot1</span>
<span class="line-modified"> 445                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified"> 446                  *              all in (great, *) == pivot2</span>
 447                  *
<a name="57" id="anc57"></a><span class="line-modified"> 448                  * Pointer k is the first index of ?-part.</span>
 449                  */
<a name="58" id="anc58"></a><span class="line-modified"> 450                 outer:</span>
<span class="line-removed"> 451                 for (int k = less - 1; ++k &lt;= great; ) {</span>
 452                     int ak = a[k];
<a name="59" id="anc59"></a><span class="line-modified"> 453                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-modified"> 454                         a[k] = a[less];</span>
<span class="line-modified"> 455                         a[less] = ak;</span>
<span class="line-modified"> 456                         ++less;</span>
<span class="line-modified"> 457                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 458                         while (a[great] == pivot2) {</span>
<span class="line-modified"> 459                             if (great-- == k) {</span>
<span class="line-modified"> 460                                 break outer;</span>




 461                             }
 462                         }
<a name="60" id="anc60"></a><span class="line-modified"> 463                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-modified"> 464                             a[k] = a[less];</span>
<span class="line-modified"> 465                             /*</span>
<span class="line-removed"> 466                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed"> 467                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed"> 468                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed"> 469                              * of different signs. Therefore in float and</span>
<span class="line-removed"> 470                              * double sorting methods we have to use more</span>
<span class="line-removed"> 471                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed"> 472                              */</span>
<span class="line-removed"> 473                             a[less] = pivot1;</span>
<span class="line-removed"> 474                             ++less;</span>
<span class="line-removed"> 475                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed"> 476                             a[k] = a[great];</span>
<span class="line-removed"> 477                         }</span>
<span class="line-removed"> 478                         a[great] = ak;</span>
<span class="line-removed"> 479                         --great;</span>
 480                     }
 481                 }
<a name="61" id="anc61"></a><span class="line-removed"> 482             }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484             // Sort center part recursively</span>
<span class="line-removed"> 485             sort(a, less, great, false);</span>
 486 
<a name="62" id="anc62"></a><span class="line-modified"> 487         } else { // Partitioning with one pivot</span>
<span class="line-modified"> 488             /*</span>
<span class="line-modified"> 489              * Use the third of the five sorted elements as pivot.</span>
<span class="line-modified"> 490              * This value is inexpensive approximation of the median.</span>
<span class="line-modified"> 491              */</span>
<span class="line-removed"> 492             int pivot = a[e3];</span>
 493 
<a name="63" id="anc63"></a><span class="line-modified"> 494             /*</span>
<span class="line-modified"> 495              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified"> 496              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified"> 497              *</span>
<span class="line-modified"> 498              *   left part    center part              right part</span>
<span class="line-modified"> 499              * +-------------------------------------------------+</span>
<span class="line-modified"> 500              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-modified"> 501              * +-------------------------------------------------+</span>
<span class="line-modified"> 502              *              ^              ^        ^</span>
<span class="line-modified"> 503              *              |              |        |</span>
<span class="line-removed"> 504              *             less            k      great</span>
<span class="line-removed"> 505              *</span>
<span class="line-removed"> 506              * Invariants:</span>
<span class="line-removed"> 507              *</span>
<span class="line-removed"> 508              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed"> 509              *   all in [less, k)     == pivot</span>
<span class="line-removed"> 510              *   all in (great, right) &gt; pivot</span>
<span class="line-removed"> 511              *</span>
<span class="line-removed"> 512              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 513              */</span>
<span class="line-removed"> 514             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed"> 515                 if (a[k] == pivot) {</span>
<span class="line-removed"> 516                     continue;</span>
<span class="line-removed"> 517                 }</span>
<span class="line-removed"> 518                 int ak = a[k];</span>
<span class="line-removed"> 519                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed"> 520                     a[k] = a[less];</span>
<span class="line-removed"> 521                     a[less] = ak;</span>
<span class="line-removed"> 522                     ++less;</span>
<span class="line-removed"> 523                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed"> 524                     while (a[great] &gt; pivot) {</span>
<span class="line-removed"> 525                         --great;</span>
<span class="line-removed"> 526                     }</span>
<span class="line-removed"> 527                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed"> 528                         a[k] = a[less];</span>
<span class="line-removed"> 529                         a[less] = a[great];</span>
<span class="line-removed"> 530                         ++less;</span>
<span class="line-removed"> 531                     } else { // a[great] == pivot</span>
<span class="line-removed"> 532                         /*</span>
<span class="line-removed"> 533                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed"> 534                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed"> 535                          * if a[great] and pivot are floating-point</span>
<span class="line-removed"> 536                          * zeros of different signs. Therefore in float</span>
<span class="line-removed"> 537                          * and double sorting methods we have to use</span>
<span class="line-removed"> 538                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed"> 539                          */</span>
<span class="line-removed"> 540                         a[k] = pivot;</span>
<span class="line-removed"> 541                     }</span>
<span class="line-removed"> 542                     a[great] = ak;</span>
<span class="line-removed"> 543                     --great;</span>
 544                 }
<a name="64" id="anc64"></a><span class="line-removed"> 545             }</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547             /*</span>
<span class="line-removed"> 548              * Sort left and right parts recursively.</span>
<span class="line-removed"> 549              * All elements from center part are equal</span>
<span class="line-removed"> 550              * and, therefore, already sorted.</span>
<span class="line-removed"> 551              */</span>
<span class="line-removed"> 552             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed"> 553             sort(a, great + 1, right, false);</span>
<span class="line-removed"> 554         }</span>
<span class="line-removed"> 555     }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557     /**</span>
<span class="line-removed"> 558      * Sorts the specified range of the array using the given</span>
<span class="line-removed"> 559      * workspace array slice if possible for merging</span>
<span class="line-removed"> 560      *</span>
<span class="line-removed"> 561      * @param a the array to be sorted</span>
<span class="line-removed"> 562      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed"> 563      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed"> 564      * @param work a workspace array (slice)</span>
<span class="line-removed"> 565      * @param workBase origin of usable space in work array</span>
<span class="line-removed"> 566      * @param workLen usable size of work array</span>
<span class="line-removed"> 567      */</span>
<span class="line-removed"> 568     static void sort(long[] a, int left, int right,</span>
<span class="line-removed"> 569                      long[] work, int workBase, int workLen) {</span>
<span class="line-removed"> 570         // Use Quicksort on small arrays</span>
<span class="line-removed"> 571         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed"> 572             sort(a, left, right, true);</span>
<span class="line-removed"> 573             return;</span>
<span class="line-removed"> 574         }</span>
 575 
<a name="65" id="anc65"></a><span class="line-modified"> 576         /*</span>
<span class="line-removed"> 577          * Index run[i] is the start of i-th run</span>
<span class="line-removed"> 578          * (ascending or descending sequence).</span>
<span class="line-removed"> 579          */</span>
<span class="line-removed"> 580         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed"> 581         int count = 0; run[0] = left;</span>
 582 
<a name="66" id="anc66"></a><span class="line-modified"> 583         // Check if the array is nearly sorted</span>
<span class="line-modified"> 584         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-modified"> 585             // Equal items in the beginning of the sequence</span>
<span class="line-modified"> 586             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-modified"> 587                 k++;</span>
<span class="line-removed"> 588             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed"> 589             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed"> 590                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed"> 591             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed"> 592                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed"> 593                 // Transform into an ascending sequence</span>
<span class="line-removed"> 594                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed"> 595                     long t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed"> 596                 }</span>
<span class="line-removed"> 597             }</span>
 598 
<a name="67" id="anc67"></a><span class="line-modified"> 599             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified"> 600             // ascending sequence</span>
<span class="line-modified"> 601             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified"> 602                 count--;</span>
<span class="line-modified"> 603             }</span>



 604 
<a name="68" id="anc68"></a><span class="line-modified"> 605             /*</span>
<span class="line-modified"> 606              * The array is not highly structured,</span>
<span class="line-modified"> 607              * use Quicksort instead of merge sort.</span>
<span class="line-modified"> 608              */</span>
<span class="line-modified"> 609             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified"> 610                 sort(a, left, right, true);</span>
<span class="line-modified"> 611                 return;</span>
<span class="line-modified"> 612             }</span>
<span class="line-modified"> 613         }</span>












 614 
<a name="69" id="anc69"></a><span class="line-modified"> 615         // These invariants should hold true:</span>
<span class="line-modified"> 616         //    run[0] = 0</span>
<span class="line-removed"> 617         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
 618 
<a name="70" id="anc70"></a><span class="line-modified"> 619         if (count == 0) {</span>
<span class="line-modified"> 620             // A single equal run</span>
<span class="line-removed"> 621             return;</span>
<span class="line-removed"> 622         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-removed"> 623             // Either a single ascending or a transformed descending run.</span>
<span class="line-removed"> 624             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-removed"> 625             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-removed"> 626             return;</span>
<span class="line-removed"> 627         }</span>
<span class="line-removed"> 628         right++;</span>
<span class="line-removed"> 629         if (run[count] &lt; right) {</span>
<span class="line-removed"> 630             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed"> 631             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed"> 632             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed"> 633             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed"> 634             run[++count] = right;</span>
<span class="line-removed"> 635         }</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637         // Determine alternation base for merge</span>
<span class="line-removed"> 638         byte odd = 0;</span>
<span class="line-removed"> 639         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed"> 640 </span>
<span class="line-removed"> 641         // Use or create temporary array b for merging</span>
<span class="line-removed"> 642         long[] b;                 // temp array; alternates with a</span>
<span class="line-removed"> 643         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed"> 644         int blen = right - left; // space needed for b</span>
<span class="line-removed"> 645         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed"> 646             work = new long[blen];</span>
<span class="line-removed"> 647             workBase = 0;</span>
<span class="line-removed"> 648         }</span>
<span class="line-removed"> 649         if (odd == 0) {</span>
<span class="line-removed"> 650             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed"> 651             b = a;</span>
<span class="line-removed"> 652             bo = 0;</span>
<span class="line-removed"> 653             a = work;</span>
<span class="line-removed"> 654             ao = workBase - left;</span>
<span class="line-removed"> 655         } else {</span>
<span class="line-removed"> 656             b = work;</span>
<span class="line-removed"> 657             ao = 0;</span>
<span class="line-removed"> 658             bo = workBase - left;</span>
<span class="line-removed"> 659         }</span>
<span class="line-removed"> 660 </span>
<span class="line-removed"> 661         // Merging</span>
<span class="line-removed"> 662         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed"> 663             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed"> 664                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed"> 665                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed"> 666                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed"> 667                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed"> 668                     } else {</span>
<span class="line-removed"> 669                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed"> 670                     }</span>
<span class="line-removed"> 671                 }</span>
<span class="line-removed"> 672                 run[++last] = hi;</span>
<span class="line-removed"> 673             }</span>
<span class="line-removed"> 674             if ((count &amp; 1) != 0) {</span>
<span class="line-removed"> 675                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed"> 676                     b[i + bo] = a[i + ao]</span>
<span class="line-removed"> 677                 );</span>
<span class="line-removed"> 678                 run[++last] = right;</span>
<span class="line-removed"> 679             }</span>
<span class="line-removed"> 680             long[] t = a; a = b; b = t;</span>
<span class="line-removed"> 681             int o = ao; ao = bo; bo = o;</span>
<span class="line-removed"> 682         }</span>
<span class="line-removed"> 683     }</span>
 684 
<a name="71" id="anc71"></a><span class="line-modified"> 685     /**</span>
<span class="line-modified"> 686      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="line-modified"> 687      *</span>
<span class="line-modified"> 688      * @param a the array to be sorted</span>
<span class="line-modified"> 689      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 690      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed"> 691      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-removed"> 692      */</span>
<span class="line-removed"> 693     private static void sort(long[] a, int left, int right, boolean leftmost) {</span>
<span class="line-removed"> 694         int length = right - left + 1;</span>
<span class="line-removed"> 695 </span>
<span class="line-removed"> 696         // Use insertion sort on tiny arrays</span>
<span class="line-removed"> 697         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed"> 698             if (leftmost) {</span>
<span class="line-removed"> 699                 /*</span>
<span class="line-removed"> 700                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed"> 701                  * optimized for server VM, is used in case of</span>
<span class="line-removed"> 702                  * the leftmost part.</span>
<span class="line-removed"> 703                  */</span>
<span class="line-removed"> 704                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed"> 705                     long ai = a[i + 1];</span>
<span class="line-removed"> 706                     while (ai &lt; a[j]) {</span>
<span class="line-removed"> 707                         a[j + 1] = a[j];</span>
<span class="line-removed"> 708                         if (j-- == left) {</span>
<span class="line-removed"> 709                             break;</span>
 710                         }
 711                     }
<a name="72" id="anc72"></a><span class="line-removed"> 712                     a[j + 1] = ai;</span>
 713                 }
<a name="73" id="anc73"></a><span class="line-modified"> 714             } else {</span>
 715                 /*
<a name="74" id="anc74"></a><span class="line-modified"> 716                  * Skip the longest ascending sequence.</span>
 717                  */
<a name="75" id="anc75"></a><span class="line-modified"> 718                 do {</span>
<span class="line-removed"> 719                     if (left &gt;= right) {</span>
<span class="line-removed"> 720                         return;</span>
<span class="line-removed"> 721                     }</span>
<span class="line-removed"> 722                 } while (a[++left] &gt;= a[left - 1]);</span>
 723 
 724                 /*
<a name="76" id="anc76"></a><span class="line-modified"> 725                  * Every element from adjoining part plays the role</span>
<span class="line-modified"> 726                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-modified"> 727                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed"> 728                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed"> 729                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed"> 730                  * than traditional implementation of insertion sort.</span>
 731                  */
<a name="77" id="anc77"></a><span class="line-modified"> 732                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified"> 733                     long a1 = a[k], a2 = a[left];</span>
<span class="line-modified"> 734 </span>
<span class="line-modified"> 735                     if (a1 &lt; a2) {</span>
<span class="line-removed"> 736                         a2 = a1; a1 = a[left];</span>
<span class="line-removed"> 737                     }</span>
<span class="line-removed"> 738                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed"> 739                         a[k + 2] = a[k];</span>
<span class="line-removed"> 740                     }</span>
<span class="line-removed"> 741                     a[++k + 1] = a1;</span>
<span class="line-removed"> 742 </span>
<span class="line-removed"> 743                     while (a2 &lt; a[--k]) {</span>
<span class="line-removed"> 744                         a[k + 1] = a[k];</span>
<span class="line-removed"> 745                     }</span>
<span class="line-removed"> 746                     a[k + 1] = a2;</span>
<span class="line-removed"> 747                 }</span>
<span class="line-removed"> 748                 long last = a[right];</span>
<span class="line-removed"> 749 </span>
<span class="line-removed"> 750                 while (last &lt; a[--right]) {</span>
<span class="line-removed"> 751                     a[right + 1] = a[right];</span>
 752                 }
<a name="78" id="anc78"></a><span class="line-removed"> 753                 a[right + 1] = last;</span>
 754             }
<a name="79" id="anc79"></a><span class="line-modified"> 755             return;</span>
 756         }
<a name="80" id="anc80"></a>
 757 
<a name="81" id="anc81"></a><span class="line-modified"> 758         // Inexpensive approximation of length / 7</span>
<span class="line-modified"> 759         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-modified"> 760 </span>
<span class="line-modified"> 761         /*</span>
<span class="line-modified"> 762          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-modified"> 763          * center element in the range. These elements will be used for</span>
<span class="line-modified"> 764          * pivot selection as described below. The choice for spacing</span>
<span class="line-modified"> 765          * these elements was empirically determined to work well on</span>
<span class="line-modified"> 766          * a wide variety of inputs.</span>
<span class="line-modified"> 767          */</span>
<span class="line-modified"> 768         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified"> 769         int e2 = e3 - seventh;</span>
<span class="line-modified"> 770         int e1 = e2 - seventh;</span>
<span class="line-modified"> 771         int e4 = e3 + seventh;</span>
<span class="line-modified"> 772         int e5 = e4 + seventh;</span>




 773 
<a name="82" id="anc82"></a><span class="line-modified"> 774         // Sort these elements using insertion sort</span>
<span class="line-modified"> 775         if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>



 776 
<a name="83" id="anc83"></a><span class="line-modified"> 777         if (a[e3] &lt; a[e2]) { long t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 778             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed"> 779         }</span>
<span class="line-removed"> 780         if (a[e4] &lt; a[e3]) { long t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed"> 781             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed"> 782                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed"> 783             }</span>
<span class="line-removed"> 784         }</span>
<span class="line-removed"> 785         if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-removed"> 786             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed"> 787                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed"> 788                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
 789                 }
<a name="84" id="anc84"></a>
 790             }
<a name="85" id="anc85"></a><span class="line-modified"> 791         }</span>
<span class="line-removed"> 792 </span>
<span class="line-removed"> 793         // Pointers</span>
<span class="line-removed"> 794         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed"> 795         int great = right; // The index before the first element of right part</span>
 796 
<a name="86" id="anc86"></a><span class="line-removed"> 797         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
 798             /*
<a name="87" id="anc87"></a><span class="line-modified"> 799              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-modified"> 800              * These values are inexpensive approximations of the first and</span>
<span class="line-modified"> 801              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>




 802              */
<a name="88" id="anc88"></a><span class="line-modified"> 803             long pivot1 = a[e2];</span>
<span class="line-removed"> 804             long pivot2 = a[e4];</span>
 805 
<a name="89" id="anc89"></a><span class="line-modified"> 806             /*</span>
<span class="line-modified"> 807              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed"> 808              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed"> 809              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed"> 810              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed"> 811              */</span>
<span class="line-removed"> 812             a[e2] = a[left];</span>
<span class="line-removed"> 813             a[e4] = a[right];</span>
 814 
<a name="90" id="anc90"></a><span class="line-modified"> 815             /*</span>
<span class="line-removed"> 816              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-removed"> 817              */</span>
<span class="line-removed"> 818             while (a[++less] &lt; pivot1);</span>
<span class="line-removed"> 819             while (a[--great] &gt; pivot2);</span>
 820 
<a name="91" id="anc91"></a><span class="line-removed"> 821             /*</span>
<span class="line-removed"> 822              * Partitioning:</span>
<span class="line-removed"> 823              *</span>
<span class="line-removed"> 824              *   left part           center part                   right part</span>
<span class="line-removed"> 825              * +--------------------------------------------------------------+</span>
<span class="line-removed"> 826              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed"> 827              * +--------------------------------------------------------------+</span>
<span class="line-removed"> 828              *               ^                          ^       ^</span>
<span class="line-removed"> 829              *               |                          |       |</span>
<span class="line-removed"> 830              *              less                        k     great</span>
<span class="line-removed"> 831              *</span>
<span class="line-removed"> 832              * Invariants:</span>
<span class="line-removed"> 833              *</span>
<span class="line-removed"> 834              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed"> 835              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed"> 836              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed"> 837              *</span>
<span class="line-removed"> 838              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 839              */</span>
<span class="line-removed"> 840             outer:</span>
<span class="line-removed"> 841             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed"> 842                 long ak = a[k];</span>
<span class="line-removed"> 843                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed"> 844                     a[k] = a[less];</span>
 845                     /*
<a name="92" id="anc92"></a><span class="line-modified"> 846                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed"> 847                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
 848                      */
<a name="93" id="anc93"></a><span class="line-modified"> 849                     a[less] = ak;</span>
<span class="line-modified"> 850                     ++less;</span>
<span class="line-modified"> 851                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 852                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed"> 853                         if (great-- == k) {</span>
<span class="line-removed"> 854                             break outer;</span>
<span class="line-removed"> 855                         }</span>
 856                     }
<a name="94" id="anc94"></a><span class="line-modified"> 857                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-modified"> 858                         a[k] = a[less];</span>
<span class="line-modified"> 859                         a[less] = a[great];</span>
<span class="line-modified"> 860                         ++less;</span>
<span class="line-modified"> 861                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-modified"> 862                         a[k] = a[great];</span>









 863                     }
<a name="95" id="anc95"></a>
 864                     /*
<a name="96" id="anc96"></a><span class="line-modified"> 865                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed"> 866                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
 867                      */
<a name="97" id="anc97"></a><span class="line-modified"> 868                     a[great] = ak;</span>
<span class="line-modified"> 869                     --great;</span>


 870                 }
 871             }
 872 
<a name="98" id="anc98"></a><span class="line-removed"> 873             // Swap pivots into their final positions</span>
<span class="line-removed"> 874             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed"> 875             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed"> 876 </span>
<span class="line-removed"> 877             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed"> 878             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed"> 879             sort(a, great + 2, right, false);</span>
<span class="line-removed"> 880 </span>
 881             /*
<a name="99" id="anc99"></a><span class="line-modified"> 882              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed"> 883              * swap internal pivot values to ends.</span>
 884              */
<a name="100" id="anc100"></a><span class="line-modified"> 885             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>


 886                 /*
<a name="101" id="anc101"></a><span class="line-modified"> 887                  * Skip elements, which are equal to pivot values.</span>


 888                  */
<a name="102" id="anc102"></a><span class="line-modified"> 889                 while (a[less] == pivot1) {</span>
<span class="line-removed"> 890                     ++less;</span>
<span class="line-removed"> 891                 }</span>
 892 
<a name="103" id="anc103"></a><span class="line-modified"> 893                 while (a[great] == pivot2) {</span>
<span class="line-modified"> 894                     --great;</span>
<span class="line-modified"> 895                 }</span>

 896 
<a name="104" id="anc104"></a><span class="line-modified"> 897                 /*</span>
<span class="line-modified"> 898                  * Partitioning:</span>
<span class="line-removed"> 899                  *</span>
<span class="line-removed"> 900                  *   left part         center part                  right part</span>
<span class="line-removed"> 901                  * +----------------------------------------------------------+</span>
<span class="line-removed"> 902                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed"> 903                  * +----------------------------------------------------------+</span>
<span class="line-removed"> 904                  *              ^                        ^       ^</span>
<span class="line-removed"> 905                  *              |                        |       |</span>
<span class="line-removed"> 906                  *             less                      k     great</span>
<span class="line-removed"> 907                  *</span>
<span class="line-removed"> 908                  * Invariants:</span>
<span class="line-removed"> 909                  *</span>
<span class="line-removed"> 910                  *              all in (*,  less) == pivot1</span>
<span class="line-removed"> 911                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed"> 912                  *              all in (great, *) == pivot2</span>
<span class="line-removed"> 913                  *</span>
<span class="line-removed"> 914                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 915                  */</span>
<span class="line-removed"> 916                 outer:</span>
<span class="line-removed"> 917                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed"> 918                     long ak = a[k];</span>
<span class="line-removed"> 919                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed"> 920                         a[k] = a[less];</span>
<span class="line-removed"> 921                         a[less] = ak;</span>
<span class="line-removed"> 922                         ++less;</span>
<span class="line-removed"> 923                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed"> 924                         while (a[great] == pivot2) {</span>
<span class="line-removed"> 925                             if (great-- == k) {</span>
<span class="line-removed"> 926                                 break outer;</span>
<span class="line-removed"> 927                             }</span>
<span class="line-removed"> 928                         }</span>
<span class="line-removed"> 929                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed"> 930                             a[k] = a[less];</span>
<span class="line-removed"> 931                             /*</span>
<span class="line-removed"> 932                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed"> 933                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed"> 934                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed"> 935                              * of different signs. Therefore in float and</span>
<span class="line-removed"> 936                              * double sorting methods we have to use more</span>
<span class="line-removed"> 937                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed"> 938                              */</span>
<span class="line-removed"> 939                             a[less] = pivot1;</span>
<span class="line-removed"> 940                             ++less;</span>
<span class="line-removed"> 941                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed"> 942                             a[k] = a[great];</span>
<span class="line-removed"> 943                         }</span>
<span class="line-removed"> 944                         a[great] = ak;</span>
<span class="line-removed"> 945                         --great;</span>
 946                     }
<a name="105" id="anc105"></a><span class="line-modified"> 947                 }</span>
<span class="line-removed"> 948             }</span>
 949 
<a name="106" id="anc106"></a><span class="line-modified"> 950             // Sort center part recursively</span>
<span class="line-removed"> 951             sort(a, less, great, false);</span>
 952 
<a name="107" id="anc107"></a><span class="line-modified"> 953         } else { // Partitioning with one pivot</span>
<span class="line-modified"> 954             /*</span>
<span class="line-removed"> 955              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed"> 956              * This value is inexpensive approximation of the median.</span>
<span class="line-removed"> 957              */</span>
<span class="line-removed"> 958             long pivot = a[e3];</span>
<span class="line-removed"> 959 </span>
<span class="line-removed"> 960             /*</span>
<span class="line-removed"> 961              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed"> 962              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed"> 963              *</span>
<span class="line-removed"> 964              *   left part    center part              right part</span>
<span class="line-removed"> 965              * +-------------------------------------------------+</span>
<span class="line-removed"> 966              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed"> 967              * +-------------------------------------------------+</span>
<span class="line-removed"> 968              *              ^              ^        ^</span>
<span class="line-removed"> 969              *              |              |        |</span>
<span class="line-removed"> 970              *             less            k      great</span>
<span class="line-removed"> 971              *</span>
<span class="line-removed"> 972              * Invariants:</span>
<span class="line-removed"> 973              *</span>
<span class="line-removed"> 974              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed"> 975              *   all in [less, k)     == pivot</span>
<span class="line-removed"> 976              *   all in (great, right) &gt; pivot</span>
<span class="line-removed"> 977              *</span>
<span class="line-removed"> 978              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 979              */</span>
<span class="line-removed"> 980             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed"> 981                 if (a[k] == pivot) {</span>
<span class="line-removed"> 982                     continue;</span>
<span class="line-removed"> 983                 }</span>
<span class="line-removed"> 984                 long ak = a[k];</span>
<span class="line-removed"> 985                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed"> 986                     a[k] = a[less];</span>
<span class="line-removed"> 987                     a[less] = ak;</span>
<span class="line-removed"> 988                     ++less;</span>
<span class="line-removed"> 989                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed"> 990                     while (a[great] &gt; pivot) {</span>
<span class="line-removed"> 991                         --great;</span>
 992                     }
<a name="108" id="anc108"></a><span class="line-modified"> 993                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified"> 994                         a[k] = a[less];</span>
<span class="line-modified"> 995                         a[less] = a[great];</span>
<span class="line-modified"> 996                         ++less;</span>
<span class="line-removed"> 997                     } else { // a[great] == pivot</span>
<span class="line-removed"> 998                         /*</span>
<span class="line-removed"> 999                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">1000                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">1001                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">1002                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">1003                          * and double sorting methods we have to use</span>
<span class="line-removed">1004                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">1005                          */</span>
<span class="line-removed">1006                         a[k] = pivot;</span>
1007                     }
<a name="109" id="anc109"></a><span class="line-modified">1008                     a[great] = ak;</span>
<span class="line-removed">1009                     --great;</span>
1010                 }
1011             }
<a name="110" id="anc110"></a><span class="line-removed">1012 </span>
<span class="line-removed">1013             /*</span>
<span class="line-removed">1014              * Sort left and right parts recursively.</span>
<span class="line-removed">1015              * All elements from center part are equal</span>
<span class="line-removed">1016              * and, therefore, already sorted.</span>
<span class="line-removed">1017              */</span>
<span class="line-removed">1018             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed">1019             sort(a, great + 1, right, false);</span>
1020         }
1021     }
1022 
1023     /**
<a name="111" id="anc111"></a><span class="line-modified">1024      * Sorts the specified range of the array using the given</span>
<span class="line-removed">1025      * workspace array slice if possible for merging</span>
1026      *
1027      * @param a the array to be sorted
<a name="112" id="anc112"></a><span class="line-modified">1028      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1029      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1030      * @param work a workspace array (slice)</span>
<span class="line-modified">1031      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1032      * @param workLen usable size of work array</span>
<span class="line-modified">1033      */</span>
<span class="line-removed">1034     static void sort(short[] a, int left, int right,</span>
<span class="line-removed">1035                      short[] work, int workBase, int workLen) {</span>
<span class="line-removed">1036         // Use counting sort on large arrays</span>
<span class="line-removed">1037         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="line-removed">1038             int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="line-removed">1039 </span>
<span class="line-removed">1040             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">1041                 count[a[i] - Short.MIN_VALUE]++</span>
<span class="line-removed">1042             );</span>
<span class="line-removed">1043             for (int i = NUM_SHORT_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">1044                 while (count[--i] == 0);</span>
<span class="line-removed">1045                 short value = (short) (i + Short.MIN_VALUE);</span>
<span class="line-removed">1046                 int s = count[i];</span>
1047 
<a name="113" id="anc113"></a><span class="line-modified">1048                 do {</span>
<span class="line-modified">1049                     a[--k] = value;</span>
<span class="line-modified">1050                 } while (--s &gt; 0);</span>


1051             }
<a name="114" id="anc114"></a><span class="line-removed">1052         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="line-removed">1053             doSort(a, left, right, work, workBase, workLen);</span>
1054         }
1055     }
1056 
<a name="115" id="anc115"></a><span class="line-removed">1057     /** The number of distinct short values. */</span>
<span class="line-removed">1058     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-removed">1059 </span>
1060     /**
<a name="116" id="anc116"></a><span class="line-modified">1061      * Sorts the specified range of the array.</span>
1062      *
1063      * @param a the array to be sorted
<a name="117" id="anc117"></a><span class="line-modified">1064      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1065      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1066      * @param work a workspace array (slice)</span>
<span class="line-modified">1067      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1068      * @param workLen usable size of work array</span>
<span class="line-modified">1069      */</span>
<span class="line-removed">1070     private static void doSort(short[] a, int left, int right,</span>
<span class="line-removed">1071                                short[] work, int workBase, int workLen) {</span>
<span class="line-removed">1072         // Use Quicksort on small arrays</span>
<span class="line-removed">1073         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed">1074             sort(a, left, right, true);</span>
<span class="line-removed">1075             return;</span>
1076         }
<a name="118" id="anc118"></a><span class="line-modified">1077 </span>
<span class="line-modified">1078         /*</span>
<span class="line-modified">1079          * Index run[i] is the start of i-th run</span>
<span class="line-modified">1080          * (ascending or descending sequence).</span>
<span class="line-removed">1081          */</span>
<span class="line-removed">1082         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed">1083         int count = 0; run[0] = left;</span>
<span class="line-removed">1084 </span>
<span class="line-removed">1085         // Check if the array is nearly sorted</span>
<span class="line-removed">1086         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">1087             // Equal items in the beginning of the sequence</span>
<span class="line-removed">1088             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">1089                 k++;</span>
<span class="line-removed">1090             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">1091             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">1092                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">1093             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">1094                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">1095                 // Transform into an ascending sequence</span>
<span class="line-removed">1096                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">1097                     short t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">1098                 }</span>
<span class="line-removed">1099             }</span>
<span class="line-removed">1100 </span>
<span class="line-removed">1101             // Merge a transformed descending sequence followed by an</span>
<span class="line-removed">1102             // ascending sequence</span>
<span class="line-removed">1103             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-removed">1104                 count--;</span>
<span class="line-removed">1105             }</span>
<span class="line-removed">1106 </span>
<span class="line-removed">1107             /*</span>
<span class="line-removed">1108              * The array is not highly structured,</span>
<span class="line-removed">1109              * use Quicksort instead of merge sort.</span>
<span class="line-removed">1110              */</span>
<span class="line-removed">1111             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-removed">1112                 sort(a, left, right, true);</span>
<span class="line-removed">1113                 return;</span>
<span class="line-removed">1114             }</span>
1115         }
<a name="119" id="anc119"></a>
1116 
<a name="120" id="anc120"></a><span class="line-modified">1117         // These invariants should hold true:</span>
<span class="line-modified">1118         //    run[0] = 0</span>
<span class="line-modified">1119         //    run[&lt;last&gt;] = right + 1; (terminator)</span>









1120 
<a name="121" id="anc121"></a><span class="line-modified">1121         if (count == 0) {</span>
<span class="line-modified">1122             // A single equal run</span>
<span class="line-removed">1123             return;</span>
<span class="line-removed">1124         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-removed">1125             // Either a single ascending or a transformed descending run.</span>
<span class="line-removed">1126             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-removed">1127             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-removed">1128             return;</span>
<span class="line-removed">1129         }</span>
<span class="line-removed">1130         right++;</span>
<span class="line-removed">1131         if (run[count] &lt; right) {</span>
<span class="line-removed">1132             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">1133             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">1134             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">1135             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">1136             run[++count] = right;</span>
<span class="line-removed">1137         }</span>
<span class="line-removed">1138 </span>
<span class="line-removed">1139         // Determine alternation base for merge</span>
<span class="line-removed">1140         byte odd = 0;</span>
<span class="line-removed">1141         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">1142 </span>
<span class="line-removed">1143         // Use or create temporary array b for merging</span>
<span class="line-removed">1144         short[] b;                 // temp array; alternates with a</span>
<span class="line-removed">1145         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">1146         int blen = right - left; // space needed for b</span>
<span class="line-removed">1147         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">1148             work = new short[blen];</span>
<span class="line-removed">1149             workBase = 0;</span>
<span class="line-removed">1150         }</span>
<span class="line-removed">1151         if (odd == 0) {</span>
<span class="line-removed">1152             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">1153             b = a;</span>
<span class="line-removed">1154             bo = 0;</span>
<span class="line-removed">1155             a = work;</span>
<span class="line-removed">1156             ao = workBase - left;</span>
<span class="line-removed">1157         } else {</span>
<span class="line-removed">1158             b = work;</span>
<span class="line-removed">1159             ao = 0;</span>
<span class="line-removed">1160             bo = workBase - left;</span>
<span class="line-removed">1161         }</span>
<span class="line-removed">1162 </span>
<span class="line-removed">1163         // Merging</span>
<span class="line-removed">1164         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">1165             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">1166                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">1167                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">1168                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">1169                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">1170                     } else {</span>
<span class="line-removed">1171                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">1172                     }</span>
<span class="line-removed">1173                 }</span>
<span class="line-removed">1174                 run[++last] = hi;</span>
1175             }
<a name="122" id="anc122"></a><span class="line-modified">1176             if ((count &amp; 1) != 0) {</span>
<span class="line-modified">1177                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-modified">1178                     b[i + bo] = a[i + ao]</span>
<span class="line-modified">1179                 );</span>
<span class="line-modified">1180                 run[++last] = right;</span>
1181             }
<a name="123" id="anc123"></a><span class="line-removed">1182             short[] t = a; a = b; b = t;</span>
<span class="line-removed">1183             int o = ao; ao = bo; bo = o;</span>
1184         }
<a name="124" id="anc124"></a>
1185     }
1186 
1187     /**
<a name="125" id="anc125"></a><span class="line-modified">1188      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
1189      *
<a name="126" id="anc126"></a>
1190      * @param a the array to be sorted
<a name="127" id="anc127"></a><span class="line-modified">1191      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1192      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1193      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">1194      */</span>
<span class="line-modified">1195     private static void sort(short[] a, int left, int right, boolean leftmost) {</span>
<span class="line-removed">1196         int length = right - left + 1;</span>
<span class="line-removed">1197 </span>
<span class="line-removed">1198         // Use insertion sort on tiny arrays</span>
<span class="line-removed">1199         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed">1200             if (leftmost) {</span>
<span class="line-removed">1201                 /*</span>
<span class="line-removed">1202                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed">1203                  * optimized for server VM, is used in case of</span>
<span class="line-removed">1204                  * the leftmost part.</span>
<span class="line-removed">1205                  */</span>
<span class="line-removed">1206                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed">1207                     short ai = a[i + 1];</span>
<span class="line-removed">1208                     while (ai &lt; a[j]) {</span>
<span class="line-removed">1209                         a[j + 1] = a[j];</span>
<span class="line-removed">1210                         if (j-- == left) {</span>
<span class="line-removed">1211                             break;</span>
<span class="line-removed">1212                         }</span>
<span class="line-removed">1213                     }</span>
<span class="line-removed">1214                     a[j + 1] = ai;</span>
<span class="line-removed">1215                 }</span>
<span class="line-removed">1216             } else {</span>
<span class="line-removed">1217                 /*</span>
<span class="line-removed">1218                  * Skip the longest ascending sequence.</span>
<span class="line-removed">1219                  */</span>
<span class="line-removed">1220                 do {</span>
<span class="line-removed">1221                     if (left &gt;= right) {</span>
<span class="line-removed">1222                         return;</span>
<span class="line-removed">1223                     }</span>
<span class="line-removed">1224                 } while (a[++left] &gt;= a[left - 1]);</span>
1225 
<a name="128" id="anc128"></a><span class="line-modified">1226                 /*</span>
<span class="line-modified">1227                  * Every element from adjoining part plays the role</span>
<span class="line-modified">1228                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-modified">1229                  * left range check on each iteration. Moreover, we use</span>
<span class="line-modified">1230                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-modified">1231                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-modified">1232                  * than traditional implementation of insertion sort.</span>
<span class="line-modified">1233                  */</span>
<span class="line-removed">1234                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-removed">1235                     short a1 = a[k], a2 = a[left];</span>
1236 
<a name="129" id="anc129"></a><span class="line-modified">1237                     if (a1 &lt; a2) {</span>
<span class="line-modified">1238                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">1239                     }</span>
<span class="line-modified">1240                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed">1241                         a[k + 2] = a[k];</span>
<span class="line-removed">1242                     }</span>
<span class="line-removed">1243                     a[++k + 1] = a1;</span>
1244 
<a name="130" id="anc130"></a><span class="line-modified">1245                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">1246                         a[k + 1] = a[k];</span>
<span class="line-modified">1247                     }</span>
<span class="line-modified">1248                     a[k + 1] = a2;</span>
<span class="line-removed">1249                 }</span>
<span class="line-removed">1250                 short last = a[right];</span>
1251 
<a name="131" id="anc131"></a><span class="line-modified">1252                 while (last &lt; a[--right]) {</span>
<span class="line-modified">1253                     a[right + 1] = a[right];</span>
<span class="line-removed">1254                 }</span>
<span class="line-removed">1255                 a[right + 1] = last;</span>
<span class="line-removed">1256             }</span>
<span class="line-removed">1257             return;</span>
<span class="line-removed">1258         }</span>
1259 
<a name="132" id="anc132"></a><span class="line-modified">1260         // Inexpensive approximation of length / 7</span>
<span class="line-removed">1261         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
1262 
<a name="133" id="anc133"></a><span class="line-modified">1263         /*</span>
<span class="line-modified">1264          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">1265          * center element in the range. These elements will be used for</span>
<span class="line-removed">1266          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">1267          * these elements was empirically determined to work well on</span>
<span class="line-removed">1268          * a wide variety of inputs.</span>
<span class="line-removed">1269          */</span>
<span class="line-removed">1270         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-removed">1271         int e2 = e3 - seventh;</span>
<span class="line-removed">1272         int e1 = e2 - seventh;</span>
<span class="line-removed">1273         int e4 = e3 + seventh;</span>
<span class="line-removed">1274         int e5 = e4 + seventh;</span>
1275 
<a name="134" id="anc134"></a><span class="line-modified">1276         // Sort these elements using insertion sort</span>
<span class="line-modified">1277         if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>




1278 
<a name="135" id="anc135"></a><span class="line-modified">1279         if (a[e3] &lt; a[e2]) { short t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">1280             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1281         }</span>
<span class="line-removed">1282         if (a[e4] &lt; a[e3]) { short t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed">1283             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1284                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1285             }</span>
<span class="line-removed">1286         }</span>
<span class="line-removed">1287         if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-removed">1288             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed">1289                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1290                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1291                 }
1292             }
<a name="136" id="anc136"></a><span class="line-removed">1293         }</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295         // Pointers</span>
<span class="line-removed">1296         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">1297         int great = right; // The index before the first element of right part</span>
<span class="line-removed">1298 </span>
<span class="line-removed">1299         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">1300             /*</span>
<span class="line-removed">1301              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">1302              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">1303              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">1304              */</span>
<span class="line-removed">1305             short pivot1 = a[e2];</span>
<span class="line-removed">1306             short pivot2 = a[e4];</span>
<span class="line-removed">1307 </span>
<span class="line-removed">1308             /*</span>
<span class="line-removed">1309              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">1310              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">1311              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">1312              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed">1313              */</span>
<span class="line-removed">1314             a[e2] = a[left];</span>
<span class="line-removed">1315             a[e4] = a[right];</span>
1316 
1317             /*
<a name="137" id="anc137"></a><span class="line-modified">1318              * Skip elements, which are less or greater than pivot values.</span>
1319              */
<a name="138" id="anc138"></a><span class="line-modified">1320             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">1321             while (a[--great] &gt; pivot2);</span>
1322 
<a name="139" id="anc139"></a><span class="line-removed">1323             /*</span>
<span class="line-removed">1324              * Partitioning:</span>
<span class="line-removed">1325              *</span>
<span class="line-removed">1326              *   left part           center part                   right part</span>
<span class="line-removed">1327              * +--------------------------------------------------------------+</span>
<span class="line-removed">1328              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed">1329              * +--------------------------------------------------------------+</span>
<span class="line-removed">1330              *               ^                          ^       ^</span>
<span class="line-removed">1331              *               |                          |       |</span>
<span class="line-removed">1332              *              less                        k     great</span>
<span class="line-removed">1333              *</span>
<span class="line-removed">1334              * Invariants:</span>
<span class="line-removed">1335              *</span>
<span class="line-removed">1336              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed">1337              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed">1338              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed">1339              *</span>
<span class="line-removed">1340              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1341              */</span>
<span class="line-removed">1342             outer:</span>
<span class="line-removed">1343             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">1344                 short ak = a[k];</span>
<span class="line-removed">1345                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1346                     a[k] = a[less];</span>
1347                     /*
<a name="140" id="anc140"></a><span class="line-modified">1348                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-modified">1349                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
1350                      */
<a name="141" id="anc141"></a><span class="line-modified">1351                     a[less] = ak;</span>
<span class="line-modified">1352                     ++less;</span>
<span class="line-modified">1353                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified">1354                     while (a[great] &gt; pivot2) {</span>
<span class="line-modified">1355                         if (great-- == k) {</span>
<span class="line-removed">1356                             break outer;</span>
<span class="line-removed">1357                         }</span>
<span class="line-removed">1358                     }</span>
<span class="line-removed">1359                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">1360                         a[k] = a[less];</span>
<span class="line-removed">1361                         a[less] = a[great];</span>
<span class="line-removed">1362                         ++less;</span>
<span class="line-removed">1363                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">1364                         a[k] = a[great];</span>
<span class="line-removed">1365                     }</span>
1366                     /*
<a name="142" id="anc142"></a><span class="line-modified">1367                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-modified">1368                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
1369                      */
<a name="143" id="anc143"></a><span class="line-modified">1370                     a[great] = ak;</span>
<span class="line-removed">1371                     --great;</span>
1372                 }
<a name="144" id="anc144"></a><span class="line-removed">1373             }</span>
1374 
<a name="145" id="anc145"></a><span class="line-modified">1375             // Swap pivots into their final positions</span>
<span class="line-modified">1376             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed">1377             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
1378 
<a name="146" id="anc146"></a><span class="line-modified">1379             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">1380             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">1381             sort(a, great + 2, right, false);</span>
1382 
<a name="147" id="anc147"></a><span class="line-modified">1383             /*</span>
<span class="line-removed">1384              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed">1385              * swap internal pivot values to ends.</span>
<span class="line-removed">1386              */</span>
<span class="line-removed">1387             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-removed">1388                 /*</span>
<span class="line-removed">1389                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">1390                  */</span>
<span class="line-removed">1391                 while (a[less] == pivot1) {</span>
<span class="line-removed">1392                     ++less;</span>
<span class="line-removed">1393                 }</span>
1394 
<a name="148" id="anc148"></a><span class="line-modified">1395                 while (a[great] == pivot2) {</span>
<span class="line-modified">1396                     --great;</span>



1397                 }
1398 
<a name="149" id="anc149"></a><span class="line-modified">1399                 /*</span>
<span class="line-removed">1400                  * Partitioning:</span>
<span class="line-removed">1401                  *</span>
<span class="line-removed">1402                  *   left part         center part                  right part</span>
<span class="line-removed">1403                  * +----------------------------------------------------------+</span>
<span class="line-removed">1404                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed">1405                  * +----------------------------------------------------------+</span>
<span class="line-removed">1406                  *              ^                        ^       ^</span>
<span class="line-removed">1407                  *              |                        |       |</span>
<span class="line-removed">1408                  *             less                      k     great</span>
<span class="line-removed">1409                  *</span>
<span class="line-removed">1410                  * Invariants:</span>
<span class="line-removed">1411                  *</span>
<span class="line-removed">1412                  *              all in (*,  less) == pivot1</span>
<span class="line-removed">1413                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed">1414                  *              all in (great, *) == pivot2</span>
<span class="line-removed">1415                  *</span>
<span class="line-removed">1416                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1417                  */</span>
<span class="line-removed">1418                 outer:</span>
<span class="line-removed">1419                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">1420                     short ak = a[k];</span>
<span class="line-removed">1421                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1422                         a[k] = a[less];</span>
<span class="line-removed">1423                         a[less] = ak;</span>
<span class="line-removed">1424                         ++less;</span>
<span class="line-removed">1425                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">1426                         while (a[great] == pivot2) {</span>
<span class="line-removed">1427                             if (great-- == k) {</span>
<span class="line-removed">1428                                 break outer;</span>
<span class="line-removed">1429                             }</span>
<span class="line-removed">1430                         }</span>
<span class="line-removed">1431                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">1432                             a[k] = a[less];</span>
<span class="line-removed">1433                             /*</span>
<span class="line-removed">1434                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">1435                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">1436                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">1437                              * of different signs. Therefore in float and</span>
<span class="line-removed">1438                              * double sorting methods we have to use more</span>
<span class="line-removed">1439                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">1440                              */</span>
<span class="line-removed">1441                             a[less] = pivot1;</span>
<span class="line-removed">1442                             ++less;</span>
<span class="line-removed">1443                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">1444                             a[k] = a[great];</span>
<span class="line-removed">1445                         }</span>
<span class="line-removed">1446                         a[great] = ak;</span>
<span class="line-removed">1447                         --great;</span>
<span class="line-removed">1448                     }</span>
<span class="line-removed">1449                 }</span>
<span class="line-removed">1450             }</span>
1451 
<a name="150" id="anc150"></a><span class="line-modified">1452             // Sort center part recursively</span>
<span class="line-modified">1453             sort(a, less, great, false);</span>



1454 
<a name="151" id="anc151"></a><span class="line-modified">1455         } else { // Partitioning with one pivot</span>
<span class="line-removed">1456             /*</span>
<span class="line-removed">1457              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">1458              * This value is inexpensive approximation of the median.</span>
<span class="line-removed">1459              */</span>
<span class="line-removed">1460             short pivot = a[e3];</span>
1461 
<a name="152" id="anc152"></a><span class="line-modified">1462             /*</span>
<span class="line-modified">1463              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified">1464              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified">1465              *</span>
<span class="line-removed">1466              *   left part    center part              right part</span>
<span class="line-removed">1467              * +-------------------------------------------------+</span>
<span class="line-removed">1468              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">1469              * +-------------------------------------------------+</span>
<span class="line-removed">1470              *              ^              ^        ^</span>
<span class="line-removed">1471              *              |              |        |</span>
<span class="line-removed">1472              *             less            k      great</span>
<span class="line-removed">1473              *</span>
<span class="line-removed">1474              * Invariants:</span>
<span class="line-removed">1475              *</span>
<span class="line-removed">1476              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">1477              *   all in [less, k)     == pivot</span>
<span class="line-removed">1478              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">1479              *</span>
<span class="line-removed">1480              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1481              */</span>
<span class="line-removed">1482             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">1483                 if (a[k] == pivot) {</span>
<span class="line-removed">1484                     continue;</span>
<span class="line-removed">1485                 }</span>
<span class="line-removed">1486                 short ak = a[k];</span>
<span class="line-removed">1487                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">1488                     a[k] = a[less];</span>
<span class="line-removed">1489                     a[less] = ak;</span>
<span class="line-removed">1490                     ++less;</span>
<span class="line-removed">1491                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">1492                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">1493                         --great;</span>
<span class="line-removed">1494                     }</span>
<span class="line-removed">1495                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed">1496                         a[k] = a[less];</span>
<span class="line-removed">1497                         a[less] = a[great];</span>
<span class="line-removed">1498                         ++less;</span>
<span class="line-removed">1499                     } else { // a[great] == pivot</span>
<span class="line-removed">1500                         /*</span>
<span class="line-removed">1501                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">1502                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">1503                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">1504                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">1505                          * and double sorting methods we have to use</span>
<span class="line-removed">1506                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">1507                          */</span>
<span class="line-removed">1508                         a[k] = pivot;</span>
<span class="line-removed">1509                     }</span>
<span class="line-removed">1510                     a[great] = ak;</span>
<span class="line-removed">1511                     --great;</span>
1512                 }
1513             }
<a name="153" id="anc153"></a><span class="line-modified">1514 </span>
<span class="line-removed">1515             /*</span>
<span class="line-removed">1516              * Sort left and right parts recursively.</span>
<span class="line-removed">1517              * All elements from center part are equal</span>
<span class="line-removed">1518              * and, therefore, already sorted.</span>
<span class="line-removed">1519              */</span>
<span class="line-removed">1520             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed">1521             sort(a, great + 1, right, false);</span>
1522         }
<a name="154" id="anc154"></a><span class="line-removed">1523     }</span>
1524 
<a name="155" id="anc155"></a><span class="line-modified">1525     /**</span>
<span class="line-modified">1526      * Sorts the specified range of the array using the given</span>
<span class="line-modified">1527      * workspace array slice if possible for merging</span>
<span class="line-modified">1528      *</span>
<span class="line-modified">1529      * @param a the array to be sorted</span>
<span class="line-removed">1530      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed">1531      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed">1532      * @param work a workspace array (slice)</span>
<span class="line-removed">1533      * @param workBase origin of usable space in work array</span>
<span class="line-removed">1534      * @param workLen usable size of work array</span>
<span class="line-removed">1535      */</span>
<span class="line-removed">1536     static void sort(char[] a, int left, int right,</span>
<span class="line-removed">1537                      char[] work, int workBase, int workLen) {</span>
<span class="line-removed">1538         // Use counting sort on large arrays</span>
<span class="line-removed">1539         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="line-removed">1540             int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="line-removed">1541 </span>
<span class="line-removed">1542             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">1543                 count[a[i]]++</span>
<span class="line-removed">1544             );</span>
<span class="line-removed">1545             for (int i = NUM_CHAR_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">1546                 while (count[--i] == 0);</span>
<span class="line-removed">1547                 char value = (char) i;</span>
<span class="line-removed">1548                 int s = count[i];</span>
1549 
<a name="156" id="anc156"></a><span class="line-modified">1550                 do {</span>
<span class="line-modified">1551                     a[--k] = value;</span>
<span class="line-modified">1552                 } while (--s &gt; 0);</span>

1553             }
<a name="157" id="anc157"></a><span class="line-modified">1554         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="line-removed">1555             doSort(a, left, right, work, workBase, workLen);</span>
1556         }
<a name="158" id="anc158"></a>
1557     }
1558 
<a name="159" id="anc159"></a><span class="line-removed">1559     /** The number of distinct char values. */</span>
<span class="line-removed">1560     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-removed">1561 </span>
1562     /**
<a name="160" id="anc160"></a><span class="line-modified">1563      * Sorts the specified range of the array.</span>
1564      *
<a name="161" id="anc161"></a><span class="line-modified">1565      * @param a the array to be sorted</span>
<span class="line-modified">1566      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1567      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1568      * @param work a workspace array (slice)</span>
<span class="line-modified">1569      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1570      * @param workLen usable size of work array</span>
<span class="line-modified">1571      */</span>
<span class="line-modified">1572     private static void doSort(char[] a, int left, int right,</span>
<span class="line-modified">1573                                char[] work, int workBase, int workLen) {</span>
<span class="line-modified">1574         // Use Quicksort on small arrays</span>
<span class="line-modified">1575         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">1576             sort(a, left, right, true);</span>
<span class="line-modified">1577             return;</span>








1578         }
1579 
1580         /*
<a name="162" id="anc162"></a><span class="line-modified">1581          * Index run[i] is the start of i-th run</span>
<span class="line-removed">1582          * (ascending or descending sequence).</span>
1583          */
<a name="163" id="anc163"></a><span class="line-modified">1584         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">1585         int count = 0; run[0] = left;</span>
<span class="line-removed">1586 </span>
<span class="line-removed">1587         // Check if the array is nearly sorted</span>
<span class="line-removed">1588         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">1589             // Equal items in the beginning of the sequence</span>
<span class="line-removed">1590             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">1591                 k++;</span>
<span class="line-removed">1592             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">1593             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">1594                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">1595             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">1596                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">1597                 // Transform into an ascending sequence</span>
<span class="line-removed">1598                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">1599                     char t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">1600                 }</span>
<span class="line-removed">1601             }</span>
1602 
<a name="164" id="anc164"></a><span class="line-modified">1603             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">1604             // ascending sequence</span>
<span class="line-modified">1605             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">1606                 count--;</span>
<span class="line-removed">1607             }</span>
1608 
<a name="165" id="anc165"></a><span class="line-modified">1609             /*</span>
<span class="line-modified">1610              * The array is not highly structured,</span>
<span class="line-modified">1611              * use Quicksort instead of merge sort.</span>
<span class="line-modified">1612              */</span>
<span class="line-modified">1613             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">1614                 sort(a, left, right, true);</span>
<span class="line-modified">1615                 return;</span>
<span class="line-removed">1616             }</span>
1617         }
1618 
<a name="166" id="anc166"></a><span class="line-modified">1619         // These invariants should hold true:</span>
<span class="line-removed">1620         //    run[0] = 0</span>
<span class="line-removed">1621         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
1622 
<a name="167" id="anc167"></a><span class="line-modified">1623         if (count == 0) {</span>
<span class="line-modified">1624             // A single equal run</span>
<span class="line-modified">1625             return;</span>
<span class="line-modified">1626         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">1627             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">1628             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">1629             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">1630             return;</span>
<span class="line-removed">1631         }</span>
<span class="line-removed">1632         right++;</span>
<span class="line-removed">1633         if (run[count] &lt; right) {</span>
<span class="line-removed">1634             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">1635             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">1636             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">1637             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">1638             run[++count] = right;</span>
<span class="line-removed">1639         }</span>
<span class="line-removed">1640 </span>
<span class="line-removed">1641         // Determine alternation base for merge</span>
<span class="line-removed">1642         byte odd = 0;</span>
<span class="line-removed">1643         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">1644 </span>
<span class="line-removed">1645         // Use or create temporary array b for merging</span>
<span class="line-removed">1646         char[] b;                 // temp array; alternates with a</span>
<span class="line-removed">1647         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">1648         int blen = right - left; // space needed for b</span>
<span class="line-removed">1649         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">1650             work = new char[blen];</span>
<span class="line-removed">1651             workBase = 0;</span>
<span class="line-removed">1652         }</span>
<span class="line-removed">1653         if (odd == 0) {</span>
<span class="line-removed">1654             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">1655             b = a;</span>
<span class="line-removed">1656             bo = 0;</span>
<span class="line-removed">1657             a = work;</span>
<span class="line-removed">1658             ao = workBase - left;</span>
1659         } else {
<a name="168" id="anc168"></a><span class="line-modified">1660             b = work;</span>
<span class="line-removed">1661             ao = 0;</span>
<span class="line-removed">1662             bo = workBase - left;</span>
<span class="line-removed">1663         }</span>
<span class="line-removed">1664 </span>
<span class="line-removed">1665         // Merging</span>
<span class="line-removed">1666         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">1667             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">1668                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">1669                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">1670                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">1671                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">1672                     } else {</span>
<span class="line-removed">1673                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">1674                     }</span>
<span class="line-removed">1675                 }</span>
<span class="line-removed">1676                 run[++last] = hi;</span>
<span class="line-removed">1677             }</span>
<span class="line-removed">1678             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">1679                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">1680                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">1681                 );</span>
<span class="line-removed">1682                 run[++last] = right;</span>
<span class="line-removed">1683             }</span>
<span class="line-removed">1684             char[] t = a; a = b; b = t;</span>
<span class="line-removed">1685             int o = ao; ao = bo; bo = o;</span>
1686         }
<a name="169" id="anc169"></a>
1687     }
1688 
1689     /**
<a name="170" id="anc170"></a><span class="line-modified">1690      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
1691      *
<a name="171" id="anc171"></a><span class="line-modified">1692      * @param a the array to be sorted</span>
<span class="line-modified">1693      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1694      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1695      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">1696      */</span>
<span class="line-modified">1697     private static void sort(char[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">1698         int length = right - left + 1;</span>
<span class="line-modified">1699 </span>
<span class="line-modified">1700         // Use insertion sort on tiny arrays</span>
<span class="line-modified">1701         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">1702             if (leftmost) {</span>
<span class="line-modified">1703                 /*</span>
<span class="line-modified">1704                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">1705                  * optimized for server VM, is used in case of</span>
<span class="line-modified">1706                  * the leftmost part.</span>
<span class="line-modified">1707                  */</span>
<span class="line-modified">1708                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">1709                     char ai = a[i + 1];</span>
<span class="line-modified">1710                     while (ai &lt; a[j]) {</span>
<span class="line-modified">1711                         a[j + 1] = a[j];</span>
<span class="line-modified">1712                         if (j-- == left) {</span>
<span class="line-modified">1713                             break;</span>
<span class="line-modified">1714                         }</span>
<span class="line-removed">1715                     }</span>
<span class="line-removed">1716                     a[j + 1] = ai;</span>
1717                 }
<a name="172" id="anc172"></a><span class="line-modified">1718             } else {</span>
1719                 /*
<a name="173" id="anc173"></a><span class="line-modified">1720                  * Skip the longest ascending sequence.</span>
1721                  */
<a name="174" id="anc174"></a><span class="line-modified">1722                 do {</span>
<span class="line-modified">1723                     if (left &gt;= right) {</span>
<span class="line-modified">1724                         return;</span>
<span class="line-removed">1725                     }</span>
<span class="line-removed">1726                 } while (a[++left] &gt;= a[left - 1]);</span>
1727 
1728                 /*
<a name="175" id="anc175"></a><span class="line-modified">1729                  * Every element from adjoining part plays the role</span>
<span class="line-removed">1730                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">1731                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">1732                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">1733                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">1734                  * than traditional implementation of insertion sort.</span>
1735                  */
<a name="176" id="anc176"></a><span class="line-modified">1736                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">1737                     char a1 = a[k], a2 = a[left];</span>

1738 
<a name="177" id="anc177"></a><span class="line-modified">1739                     if (a1 &lt; a2) {</span>
<span class="line-modified">1740                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">1741                     }</span>
<span class="line-modified">1742                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">1743                         a[k + 2] = a[k];</span>
<span class="line-removed">1744                     }</span>
<span class="line-removed">1745                     a[++k + 1] = a1;</span>
1746 
<a name="178" id="anc178"></a><span class="line-modified">1747                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">1748                         a[k + 1] = a[k];</span>


1749                     }
<a name="179" id="anc179"></a><span class="line-removed">1750                     a[k + 1] = a2;</span>
1751                 }
<a name="180" id="anc180"></a><span class="line-removed">1752                 char last = a[right];</span>
1753 
<a name="181" id="anc181"></a><span class="line-modified">1754                 while (last &lt; a[--right]) {</span>
<span class="line-modified">1755                     a[right + 1] = a[right];</span>
<span class="line-modified">1756                 }</span>
<span class="line-modified">1757                 a[right + 1] = last;</span>








1758             }
<a name="182" id="anc182"></a><span class="line-removed">1759             return;</span>
1760         }
1761 
<a name="183" id="anc183"></a><span class="line-removed">1762         // Inexpensive approximation of length / 7</span>
<span class="line-removed">1763         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">1764 </span>
1765         /*
<a name="184" id="anc184"></a><span class="line-modified">1766          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">1767          * center element in the range. These elements will be used for</span>
<span class="line-removed">1768          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">1769          * these elements was empirically determined to work well on</span>
<span class="line-removed">1770          * a wide variety of inputs.</span>
1771          */
<a name="185" id="anc185"></a><span class="line-modified">1772         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">1773         int e2 = e3 - seventh;</span>
<span class="line-removed">1774         int e1 = e2 - seventh;</span>
<span class="line-removed">1775         int e4 = e3 + seventh;</span>
<span class="line-removed">1776         int e5 = e4 + seventh;</span>
<span class="line-removed">1777 </span>
<span class="line-removed">1778         // Sort these elements using insertion sort</span>
<span class="line-removed">1779         if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1780 </span>
<span class="line-removed">1781         if (a[e3] &lt; a[e2]) { char t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1782             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1783         }
<a name="186" id="anc186"></a><span class="line-modified">1784         if (a[e4] &lt; a[e3]) { char t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">1785             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">1786                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1787             }
1788         }
<a name="187" id="anc187"></a><span class="line-modified">1789         if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">1790             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">1791                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1792                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1793                 }</span>
1794             }
1795         }
<a name="188" id="anc188"></a>





























1796 
<a name="189" id="anc189"></a><span class="line-modified">1797         // Pointers</span>
<span class="line-modified">1798         int less  = left;  // The index of the first element of center part</span>
<span class="line-modified">1799         int great = right; // The index before the first element of right part</span>











1800 
<a name="190" id="anc190"></a><span class="line-removed">1801         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
1802             /*
<a name="191" id="anc191"></a><span class="line-modified">1803              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">1804              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">1805              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
1806              */
<a name="192" id="anc192"></a><span class="line-modified">1807             char pivot1 = a[e2];</span>
<span class="line-modified">1808             char pivot2 = a[e4];</span>


1809 
1810             /*
<a name="193" id="anc193"></a><span class="line-modified">1811              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">1812              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">1813              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">1814              * positions, and excluded from subsequent sorting.</span>
1815              */
<a name="194" id="anc194"></a><span class="line-modified">1816             a[e2] = a[left];</span>
<span class="line-modified">1817             a[e4] = a[right];</span>


1818 
1819             /*
<a name="195" id="anc195"></a><span class="line-modified">1820              * Skip elements, which are less or greater than pivot values.</span>

1821              */
<a name="196" id="anc196"></a><span class="line-modified">1822             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">1823             while (a[--great] &gt; pivot2);</span>


1824 
1825             /*
<a name="197" id="anc197"></a><span class="line-modified">1826              * Partitioning:</span>
<span class="line-modified">1827              *</span>
<span class="line-removed">1828              *   left part           center part                   right part</span>
<span class="line-removed">1829              * +--------------------------------------------------------------+</span>
<span class="line-removed">1830              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed">1831              * +--------------------------------------------------------------+</span>
<span class="line-removed">1832              *               ^                          ^       ^</span>
<span class="line-removed">1833              *               |                          |       |</span>
<span class="line-removed">1834              *              less                        k     great</span>
<span class="line-removed">1835              *</span>
<span class="line-removed">1836              * Invariants:</span>
<span class="line-removed">1837              *</span>
<span class="line-removed">1838              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed">1839              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed">1840              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed">1841              *</span>
<span class="line-removed">1842              * Pointer k is the first index of ?-part.</span>
1843              */
<a name="198" id="anc198"></a><span class="line-modified">1844             outer:</span>
<span class="line-modified">1845             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">1846                 char ak = a[k];</span>
<span class="line-removed">1847                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1848                     a[k] = a[less];</span>
<span class="line-removed">1849                     /*</span>
<span class="line-removed">1850                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">1851                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-removed">1852                      */</span>
<span class="line-removed">1853                     a[less] = ak;</span>
<span class="line-removed">1854                     ++less;</span>
<span class="line-removed">1855                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">1856                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">1857                         if (great-- == k) {</span>
<span class="line-removed">1858                             break outer;</span>
<span class="line-removed">1859                         }</span>
<span class="line-removed">1860                     }</span>
<span class="line-removed">1861                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">1862                         a[k] = a[less];</span>
<span class="line-removed">1863                         a[less] = a[great];</span>
<span class="line-removed">1864                         ++less;</span>
<span class="line-removed">1865                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">1866                         a[k] = a[great];</span>
<span class="line-removed">1867                     }</span>
<span class="line-removed">1868                     /*</span>
<span class="line-removed">1869                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">1870                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed">1871                      */</span>
<span class="line-removed">1872                     a[great] = ak;</span>
<span class="line-removed">1873                     --great;</span>
<span class="line-removed">1874                 }</span>
1875             }
1876 
<a name="199" id="anc199"></a><span class="line-modified">1877             // Swap pivots into their final positions</span>
<span class="line-modified">1878             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified">1879             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-modified">1880 </span>
<span class="line-modified">1881             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">1882             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">1883             sort(a, great + 2, right, false);</span>
1884 
1885             /*
<a name="200" id="anc200"></a><span class="line-modified">1886              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-modified">1887              * swap internal pivot values to ends.</span>


1888              */
<a name="201" id="anc201"></a><span class="line-modified">1889             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">1890                 /*</span>
<span class="line-modified">1891                  * Skip elements, which are equal to pivot values.</span>



























































1892                  */
<a name="202" id="anc202"></a><span class="line-modified">1893                 while (a[less] == pivot1) {</span>
<span class="line-modified">1894                     ++less;</span>














































1895                 }
1896 
<a name="203" id="anc203"></a><span class="line-modified">1897                 while (a[great] == pivot2) {</span>
<span class="line-modified">1898                     --great;</span>














1899                 }
1900 
<a name="204" id="anc204"></a>
















1901                 /*
<a name="205" id="anc205"></a><span class="line-modified">1902                  * Partitioning:</span>
1903                  *
<a name="206" id="anc206"></a><span class="line-modified">1904                  *   left part         center part                  right part</span>
<span class="line-modified">1905                  * +----------------------------------------------------------+</span>
<span class="line-modified">1906                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified">1907                  * +----------------------------------------------------------+</span>
<span class="line-modified">1908                  *              ^                        ^       ^</span>
<span class="line-modified">1909                  *              |                        |       |</span>
<span class="line-modified">1910                  *             less                      k     great</span>
1911                  *
1912                  * Invariants:
1913                  *
<a name="207" id="anc207"></a><span class="line-modified">1914                  *              all in (*,  less) == pivot1</span>
<span class="line-modified">1915                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified">1916                  *              all in (great, *) == pivot2</span>
1917                  *
<a name="208" id="anc208"></a><span class="line-modified">1918                  * Pointer k is the first index of ?-part.</span>
1919                  */
<a name="209" id="anc209"></a><span class="line-modified">1920                 outer:</span>
<span class="line-modified">1921                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">1922                     char ak = a[k];</span>
<span class="line-modified">1923                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-modified">1924                         a[k] = a[less];</span>
<span class="line-modified">1925                         a[less] = ak;</span>
<span class="line-modified">1926                         ++less;</span>
<span class="line-modified">1927                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-modified">1928                         while (a[great] == pivot2) {</span>
<span class="line-modified">1929                             if (great-- == k) {</span>
<span class="line-modified">1930                                 break outer;</span>
1931                             }
<a name="210" id="anc210"></a>


1932                         }
<a name="211" id="anc211"></a><span class="line-removed">1933                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">1934                             a[k] = a[less];</span>
<span class="line-removed">1935                             /*</span>
<span class="line-removed">1936                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">1937                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">1938                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">1939                              * of different signs. Therefore in float and</span>
<span class="line-removed">1940                              * double sorting methods we have to use more</span>
<span class="line-removed">1941                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">1942                              */</span>
<span class="line-removed">1943                             a[less] = pivot1;</span>
<span class="line-removed">1944                             ++less;</span>
<span class="line-removed">1945                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">1946                             a[k] = a[great];</span>
<span class="line-removed">1947                         }</span>
<span class="line-removed">1948                         a[great] = ak;</span>
<span class="line-removed">1949                         --great;</span>
1950                     }
1951                 }
<a name="212" id="anc212"></a>















1952             }
<a name="213" id="anc213"></a>


1953 
<a name="214" id="anc214"></a><span class="line-modified">1954             // Sort center part recursively</span>
<span class="line-modified">1955             sort(a, less, great, false);</span>

















1956 
<a name="215" id="anc215"></a><span class="line-removed">1957         } else { // Partitioning with one pivot</span>
1958             /*
<a name="216" id="anc216"></a><span class="line-modified">1959              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">1960              * This value is inexpensive approximation of the median.</span>
1961              */
<a name="217" id="anc217"></a><span class="line-modified">1962             char pivot = a[e3];</span>








1963 
1964             /*
<a name="218" id="anc218"></a><span class="line-modified">1965              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed">1966              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed">1967              *</span>
<span class="line-removed">1968              *   left part    center part              right part</span>
<span class="line-removed">1969              * +-------------------------------------------------+</span>
<span class="line-removed">1970              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">1971              * +-------------------------------------------------+</span>
<span class="line-removed">1972              *              ^              ^        ^</span>
<span class="line-removed">1973              *              |              |        |</span>
<span class="line-removed">1974              *             less            k      great</span>
<span class="line-removed">1975              *</span>
<span class="line-removed">1976              * Invariants:</span>
1977              *
<a name="219" id="anc219"></a><span class="line-modified">1978              *   all in (left, less)   &lt; pivot</span>
<span class="line-modified">1979              *   all in [less, k)     == pivot</span>
<span class="line-modified">1980              *   all in (great, right) &gt; pivot</span>
<span class="line-modified">1981              *</span>
<span class="line-modified">1982              * Pointer k is the first index of ?-part.</span>
1983              */
<a name="220" id="anc220"></a><span class="line-modified">1984             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-modified">1985                 if (a[k] == pivot) {</span>
<span class="line-modified">1986                     continue;</span>
<span class="line-modified">1987                 }</span>
<span class="line-modified">1988                 char ak = a[k];</span>
<span class="line-modified">1989                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-modified">1990                     a[k] = a[less];</span>
<span class="line-modified">1991                     a[less] = ak;</span>
<span class="line-modified">1992                     ++less;</span>
<span class="line-modified">1993                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-modified">1994                     while (a[great] &gt; pivot) {</span>
<span class="line-modified">1995                         --great;</span>


1996                     }
<a name="221" id="anc221"></a><span class="line-modified">1997                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified">1998                         a[k] = a[less];</span>
<span class="line-modified">1999                         a[less] = a[great];</span>
<span class="line-modified">2000                         ++less;</span>
<span class="line-modified">2001                     } else { // a[great] == pivot</span>
<span class="line-modified">2002                         /*</span>
<span class="line-modified">2003                          * Even though a[great] equals to pivot, the</span>
<span class="line-modified">2004                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-modified">2005                          * if a[great] and pivot are floating-point</span>
<span class="line-modified">2006                          * zeros of different signs. Therefore in float</span>
<span class="line-modified">2007                          * and double sorting methods we have to use</span>
<span class="line-modified">2008                          * more accurate assignment a[k] = a[great].</span>
<span class="line-modified">2009                          */</span>
<span class="line-modified">2010                         a[k] = pivot;</span>








2011                     }
<a name="222" id="anc222"></a><span class="line-modified">2012                     a[great] = ak;</span>
<span class="line-removed">2013                     --great;</span>
2014                 }
2015             }
2016 
2017             /*
<a name="223" id="anc223"></a><span class="line-modified">2018              * Sort left and right parts recursively.</span>
<span class="line-removed">2019              * All elements from center part are equal</span>
<span class="line-removed">2020              * and, therefore, already sorted.</span>
2021              */
<a name="224" id="anc224"></a><span class="line-modified">2022             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">2023             sort(a, great + 1, right, false);</span>































2024         }
2025     }
2026 
<a name="225" id="anc225"></a><span class="line-removed">2027     /** The number of distinct byte values. */</span>
<span class="line-removed">2028     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="line-removed">2029 </span>
2030     /**
<a name="226" id="anc226"></a><span class="line-modified">2031      * Sorts the specified range of the array.</span>
2032      *
2033      * @param a the array to be sorted
<a name="227" id="anc227"></a><span class="line-modified">2034      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2035      * @param right the index of the last element, inclusive, to be sorted</span>
2036      */
<a name="228" id="anc228"></a><span class="line-modified">2037     static void sort(byte[] a, int left, int right) {</span>
<span class="line-modified">2038         // Use counting sort on large arrays</span>
<span class="line-modified">2039         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_BYTE) {</span>
<span class="line-removed">2040             int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="line-removed">2041 </span>
<span class="line-removed">2042             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">2043                 count[a[i] - Byte.MIN_VALUE]++</span>
<span class="line-removed">2044             );</span>
<span class="line-removed">2045             for (int i = NUM_BYTE_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">2046                 while (count[--i] == 0);</span>
<span class="line-removed">2047                 byte value = (byte) (i + Byte.MIN_VALUE);</span>
<span class="line-removed">2048                 int s = count[i];</span>
2049 
<a name="229" id="anc229"></a><span class="line-modified">2050                 do {</span>
<span class="line-modified">2051                     a[--k] = value;</span>
<span class="line-modified">2052                 } while (--s &gt; 0);</span>
<span class="line-removed">2053             }</span>
<span class="line-removed">2054         } else { // Use insertion sort on small arrays</span>
<span class="line-removed">2055             for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed">2056                 byte ai = a[i + 1];</span>
<span class="line-removed">2057                 while (ai &lt; a[j]) {</span>
<span class="line-removed">2058                     a[j + 1] = a[j];</span>
<span class="line-removed">2059                     if (j-- == left) {</span>
<span class="line-removed">2060                         break;</span>
<span class="line-removed">2061                     }</span>
2062                 }
<a name="230" id="anc230"></a><span class="line-modified">2063                 a[j + 1] = ai;</span>
2064             }
2065         }
2066     }
2067 
2068     /**
<a name="231" id="anc231"></a><span class="line-modified">2069      * Sorts the specified range of the array using the given</span>
<span class="line-removed">2070      * workspace array slice if possible for merging</span>
2071      *
2072      * @param a the array to be sorted
<a name="232" id="anc232"></a><span class="line-modified">2073      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2074      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2075      * @param work a workspace array (slice)</span>
<span class="line-modified">2076      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2077      * @param workLen usable size of work array</span>
<span class="line-modified">2078      */</span>
<span class="line-modified">2079     static void sort(float[] a, int left, int right,</span>
<span class="line-modified">2080                      float[] work, int workBase, int workLen) {</span>
<span class="line-modified">2081         /*</span>
<span class="line-modified">2082          * Phase 1: Move NaNs to the end of the array.</span>
<span class="line-modified">2083          */</span>
<span class="line-removed">2084         while (left &lt;= right &amp;&amp; Float.isNaN(a[right])) {</span>
<span class="line-removed">2085             --right;</span>
2086         }
<a name="233" id="anc233"></a><span class="line-modified">2087         for (int k = right; --k &gt;= left; ) {</span>
<span class="line-modified">2088             float ak = a[k];</span>
<span class="line-modified">2089             if (ak != ak) { // a[k] is NaN</span>
<span class="line-modified">2090                 a[k] = a[right];</span>
<span class="line-modified">2091                 a[right] = ak;</span>
<span class="line-modified">2092                 --right;</span>

















2093             }
2094         }
<a name="234" id="anc234"></a>

2095 
<a name="235" id="anc235"></a><span class="line-modified">2096         /*</span>
<span class="line-modified">2097          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="line-modified">2098          */</span>
<span class="line-modified">2099         doSort(a, left, right, work, workBase, workLen);</span>






2100 
2101         /*
<a name="236" id="anc236"></a><span class="line-modified">2102          * Phase 3: Place negative zeros before positive zeros.</span>


2103          */
<a name="237" id="anc237"></a><span class="line-modified">2104         int hi = right;</span>


2105 
2106         /*
<a name="238" id="anc238"></a><span class="line-modified">2107          * Find the first zero, or first positive, or last negative element.</span>
2108          */
<a name="239" id="anc239"></a><span class="line-modified">2109         while (left &lt; hi) {</span>
<span class="line-removed">2110             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="line-removed">2111             float middleValue = a[middle];</span>
2112 
<a name="240" id="anc240"></a><span class="line-modified">2113             if (middleValue &lt; 0.0f) {</span>
<span class="line-modified">2114                 left = middle + 1;</span>
<span class="line-modified">2115             } else {</span>
<span class="line-modified">2116                 hi = middle;</span>



















2117             }
<a name="241" id="anc241"></a><span class="line-removed">2118         }</span>
2119 
<a name="242" id="anc242"></a><span class="line-modified">2120         /*</span>
<span class="line-modified">2121          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="line-modified">2122          */</span>
<span class="line-modified">2123         while (left &lt;= right &amp;&amp; Float.floatToRawIntBits(a[left]) &lt; 0) {</span>
<span class="line-modified">2124             ++left;</span>
















































2125         }
2126 
2127         /*
<a name="243" id="anc243"></a><span class="line-modified">2128          * Move negative zeros to the beginning of the sub-range.</span>
<span class="line-removed">2129          *</span>
<span class="line-removed">2130          * Partitioning:</span>
<span class="line-removed">2131          *</span>
<span class="line-removed">2132          * +----------------------------------------------------+</span>
<span class="line-removed">2133          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="line-removed">2134          * +----------------------------------------------------+</span>
<span class="line-removed">2135          *              ^          ^         ^</span>
<span class="line-removed">2136          *              |          |         |</span>
<span class="line-removed">2137          *             left        p         k</span>
<span class="line-removed">2138          *</span>
<span class="line-removed">2139          * Invariants:</span>
<span class="line-removed">2140          *</span>
<span class="line-removed">2141          *   all in (*,  left)  &lt;  0.0</span>
<span class="line-removed">2142          *   all in [left,  p) == -0.0</span>
<span class="line-removed">2143          *   all in [p,     k) ==  0.0</span>
<span class="line-removed">2144          *   all in [k, right] &gt;=  0.0</span>
<span class="line-removed">2145          *</span>
<span class="line-removed">2146          * Pointer k is the first index of ?-part.</span>
2147          */
<a name="244" id="anc244"></a><span class="line-modified">2148         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="line-modified">2149             float ak = a[k];</span>
<span class="line-modified">2150             if (ak != 0.0f) {</span>
<span class="line-modified">2151                 break;</span>
<span class="line-modified">2152             }</span>
<span class="line-modified">2153             if (Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="line-modified">2154                 a[k] = 0.0f;</span>
<span class="line-removed">2155                 a[++p] = -0.0f;</span>
2156             }
<a name="245" id="anc245"></a>
2157         }
<a name="246" id="anc246"></a>
2158     }
2159 
2160     /**
<a name="247" id="anc247"></a><span class="line-modified">2161      * Sorts the specified range of the array.</span>
2162      *
<a name="248" id="anc248"></a><span class="line-modified">2163      * @param a the array to be sorted</span>
<span class="line-modified">2164      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2165      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2166      * @param work a workspace array (slice)</span>
<span class="line-modified">2167      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2168      * @param workLen usable size of work array</span>
<span class="line-modified">2169      */</span>
<span class="line-modified">2170     private static void doSort(float[] a, int left, int right,</span>
<span class="line-modified">2171                                float[] work, int workBase, int workLen) {</span>
<span class="line-modified">2172         // Use Quicksort on small arrays</span>
<span class="line-modified">2173         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">2174             sort(a, left, right, true);</span>
<span class="line-modified">2175             return;</span>








2176         }
2177 
2178         /*
<a name="249" id="anc249"></a><span class="line-modified">2179          * Index run[i] is the start of i-th run</span>
<span class="line-removed">2180          * (ascending or descending sequence).</span>
2181          */
<a name="250" id="anc250"></a><span class="line-modified">2182         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">2183         int count = 0; run[0] = left;</span>
<span class="line-removed">2184 </span>
<span class="line-removed">2185         // Check if the array is nearly sorted</span>
<span class="line-removed">2186         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">2187             // Equal items in the beginning of the sequence</span>
<span class="line-removed">2188             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">2189                 k++;</span>
<span class="line-removed">2190             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">2191             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">2192                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">2193             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">2194                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">2195                 // Transform into an ascending sequence</span>
<span class="line-removed">2196                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">2197                     float t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">2198                 }</span>
<span class="line-removed">2199             }</span>
2200 
<a name="251" id="anc251"></a><span class="line-modified">2201             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">2202             // ascending sequence</span>
<span class="line-modified">2203             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">2204                 count--;</span>
<span class="line-removed">2205             }</span>
2206 
<a name="252" id="anc252"></a><span class="line-modified">2207             /*</span>
<span class="line-modified">2208              * The array is not highly structured,</span>
<span class="line-modified">2209              * use Quicksort instead of merge sort.</span>
<span class="line-modified">2210              */</span>
<span class="line-modified">2211             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">2212                 sort(a, left, right, true);</span>
<span class="line-modified">2213                 return;</span>
<span class="line-removed">2214             }</span>
2215         }
2216 
<a name="253" id="anc253"></a><span class="line-modified">2217         // These invariants should hold true:</span>
<span class="line-removed">2218         //    run[0] = 0</span>
<span class="line-removed">2219         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
2220 
<a name="254" id="anc254"></a><span class="line-modified">2221         if (count == 0) {</span>
<span class="line-modified">2222             // A single equal run</span>
<span class="line-modified">2223             return;</span>
<span class="line-modified">2224         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">2225             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">2226             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">2227             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">2228             return;</span>
<span class="line-removed">2229         }</span>
<span class="line-removed">2230         right++;</span>
<span class="line-removed">2231         if (run[count] &lt; right) {</span>
<span class="line-removed">2232             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">2233             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">2234             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">2235             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">2236             run[++count] = right;</span>
<span class="line-removed">2237         }</span>
<span class="line-removed">2238 </span>
<span class="line-removed">2239         // Determine alternation base for merge</span>
<span class="line-removed">2240         byte odd = 0;</span>
<span class="line-removed">2241         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">2242 </span>
<span class="line-removed">2243         // Use or create temporary array b for merging</span>
<span class="line-removed">2244         float[] b;                 // temp array; alternates with a</span>
<span class="line-removed">2245         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">2246         int blen = right - left; // space needed for b</span>
<span class="line-removed">2247         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">2248             work = new float[blen];</span>
<span class="line-removed">2249             workBase = 0;</span>
<span class="line-removed">2250         }</span>
<span class="line-removed">2251         if (odd == 0) {</span>
<span class="line-removed">2252             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">2253             b = a;</span>
<span class="line-removed">2254             bo = 0;</span>
<span class="line-removed">2255             a = work;</span>
<span class="line-removed">2256             ao = workBase - left;</span>
2257         } else {
<a name="255" id="anc255"></a><span class="line-modified">2258             b = work;</span>
<span class="line-removed">2259             ao = 0;</span>
<span class="line-removed">2260             bo = workBase - left;</span>
<span class="line-removed">2261         }</span>
<span class="line-removed">2262 </span>
<span class="line-removed">2263         // Merging</span>
<span class="line-removed">2264         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">2265             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">2266                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">2267                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">2268                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">2269                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">2270                     } else {</span>
<span class="line-removed">2271                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">2272                     }</span>
<span class="line-removed">2273                 }</span>
<span class="line-removed">2274                 run[++last] = hi;</span>
<span class="line-removed">2275             }</span>
<span class="line-removed">2276             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">2277                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">2278                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">2279                 );</span>
<span class="line-removed">2280                 run[++last] = right;</span>
<span class="line-removed">2281             }</span>
<span class="line-removed">2282             float[] t = a; a = b; b = t;</span>
<span class="line-removed">2283             int o = ao; ao = bo; bo = o;</span>
2284         }
<a name="256" id="anc256"></a>
2285     }
2286 
2287     /**
<a name="257" id="anc257"></a><span class="line-modified">2288      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
2289      *
<a name="258" id="anc258"></a><span class="line-modified">2290      * @param a the array to be sorted</span>
<span class="line-modified">2291      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2292      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2293      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">2294      */</span>
<span class="line-modified">2295     private static void sort(float[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">2296         int length = right - left + 1;</span>
<span class="line-modified">2297 </span>
<span class="line-modified">2298         // Use insertion sort on tiny arrays</span>
<span class="line-modified">2299         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">2300             if (leftmost) {</span>
<span class="line-modified">2301                 /*</span>
<span class="line-modified">2302                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">2303                  * optimized for server VM, is used in case of</span>
<span class="line-modified">2304                  * the leftmost part.</span>
<span class="line-modified">2305                  */</span>
<span class="line-modified">2306                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">2307                     float ai = a[i + 1];</span>
<span class="line-modified">2308                     while (ai &lt; a[j]) {</span>
<span class="line-modified">2309                         a[j + 1] = a[j];</span>
<span class="line-modified">2310                         if (j-- == left) {</span>
<span class="line-modified">2311                             break;</span>
<span class="line-modified">2312                         }</span>
<span class="line-removed">2313                     }</span>
<span class="line-removed">2314                     a[j + 1] = ai;</span>
2315                 }
<a name="259" id="anc259"></a><span class="line-modified">2316             } else {</span>
2317                 /*
<a name="260" id="anc260"></a><span class="line-modified">2318                  * Skip the longest ascending sequence.</span>
2319                  */
<a name="261" id="anc261"></a><span class="line-modified">2320                 do {</span>
<span class="line-modified">2321                     if (left &gt;= right) {</span>
<span class="line-modified">2322                         return;</span>
<span class="line-removed">2323                     }</span>
<span class="line-removed">2324                 } while (a[++left] &gt;= a[left - 1]);</span>
2325 
2326                 /*
<a name="262" id="anc262"></a><span class="line-modified">2327                  * Every element from adjoining part plays the role</span>
<span class="line-removed">2328                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">2329                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">2330                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">2331                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">2332                  * than traditional implementation of insertion sort.</span>
2333                  */
<a name="263" id="anc263"></a><span class="line-modified">2334                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">2335                     float a1 = a[k], a2 = a[left];</span>

2336 
<a name="264" id="anc264"></a><span class="line-modified">2337                     if (a1 &lt; a2) {</span>
<span class="line-modified">2338                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">2339                     }</span>
<span class="line-modified">2340                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">2341                         a[k + 2] = a[k];</span>
<span class="line-removed">2342                     }</span>
<span class="line-removed">2343                     a[++k + 1] = a1;</span>
2344 
<a name="265" id="anc265"></a><span class="line-modified">2345                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">2346                         a[k + 1] = a[k];</span>


2347                     }
<a name="266" id="anc266"></a><span class="line-removed">2348                     a[k + 1] = a2;</span>
2349                 }
<a name="267" id="anc267"></a><span class="line-removed">2350                 float last = a[right];</span>
2351 
<a name="268" id="anc268"></a><span class="line-modified">2352                 while (last &lt; a[--right]) {</span>
<span class="line-modified">2353                     a[right + 1] = a[right];</span>
<span class="line-modified">2354                 }</span>
<span class="line-modified">2355                 a[right + 1] = last;</span>








2356             }
<a name="269" id="anc269"></a><span class="line-removed">2357             return;</span>
2358         }
2359 
<a name="270" id="anc270"></a><span class="line-removed">2360         // Inexpensive approximation of length / 7</span>
<span class="line-removed">2361         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">2362 </span>
2363         /*
<a name="271" id="anc271"></a><span class="line-modified">2364          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">2365          * center element in the range. These elements will be used for</span>
<span class="line-removed">2366          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">2367          * these elements was empirically determined to work well on</span>
<span class="line-removed">2368          * a wide variety of inputs.</span>
2369          */
<a name="272" id="anc272"></a><span class="line-modified">2370         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">2371         int e2 = e3 - seventh;</span>
<span class="line-removed">2372         int e1 = e2 - seventh;</span>
<span class="line-removed">2373         int e4 = e3 + seventh;</span>
<span class="line-removed">2374         int e5 = e4 + seventh;</span>
<span class="line-removed">2375 </span>
<span class="line-removed">2376         // Sort these elements using insertion sort</span>
<span class="line-removed">2377         if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2378 </span>
<span class="line-removed">2379         if (a[e3] &lt; a[e2]) { float t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2380             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2381         }
<a name="273" id="anc273"></a><span class="line-modified">2382         if (a[e4] &lt; a[e3]) { float t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2383             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">2384                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2385             }
2386         }
<a name="274" id="anc274"></a><span class="line-modified">2387         if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">2388             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2389                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2390                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2391                 }</span>
2392             }
2393         }
<a name="275" id="anc275"></a>
2394 
<a name="276" id="anc276"></a><span class="line-modified">2395         // Pointers</span>
<span class="line-removed">2396         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">2397         int great = right; // The index before the first element of right part</span>
<span class="line-removed">2398 </span>
<span class="line-removed">2399         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">2400             /*</span>
<span class="line-removed">2401              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">2402              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">2403              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">2404              */</span>
<span class="line-removed">2405             float pivot1 = a[e2];</span>
<span class="line-removed">2406             float pivot2 = a[e4];</span>
2407 
<a name="277" id="anc277"></a><span class="line-modified">2408             /*</span>
<span class="line-modified">2409              * The first and the last elements to be sorted are moved to the</span>
<span class="line-modified">2410              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-modified">2411              * is complete, the pivots are swapped back into their final</span>
<span class="line-modified">2412              * positions, and excluded from subsequent sorting.</span>
<span class="line-modified">2413              */</span>
<span class="line-modified">2414             a[e2] = a[left];</span>
<span class="line-modified">2415             a[e4] = a[right];</span>







2416 
<a name="278" id="anc278"></a><span class="line-modified">2417             /*</span>
<span class="line-modified">2418              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-modified">2419              */</span>
<span class="line-modified">2420             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">2421             while (a[--great] &gt; pivot2);</span>













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































2422 
2423             /*
<a name="279" id="anc279"></a><span class="line-modified">2424              * Partitioning:</span>
<span class="line-modified">2425              *</span>
<span class="line-modified">2426              *   left part           center part                   right part</span>
<span class="line-modified">2427              * +--------------------------------------------------------------+</span>
<span class="line-modified">2428              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified">2429              * +--------------------------------------------------------------+</span>
<span class="line-modified">2430              *               ^                          ^       ^</span>
<span class="line-modified">2431              *               |                          |       |</span>
<span class="line-modified">2432              *              less                        k     great</span>
<span class="line-modified">2433              *</span>
<span class="line-modified">2434              * Invariants:</span>












































2435              *
<a name="280" id="anc280"></a><span class="line-modified">2436              *              all in (left, less)   &lt; pivot1</span>
<span class="line-modified">2437              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-modified">2438              *              all in (great, right) &gt; pivot2</span>



































































































































































































































2439              *
<a name="281" id="anc281"></a><span class="line-modified">2440              * Pointer k is the first index of ?-part.</span>




2441              */
<a name="282" id="anc282"></a><span class="line-modified">2442             outer:</span>
<span class="line-modified">2443             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">2444                 float ak = a[k];</span>
<span class="line-modified">2445                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-modified">2446                     a[k] = a[less];</span>



















2447                     /*
<a name="283" id="anc283"></a><span class="line-modified">2448                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">2449                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
2450                      */
<a name="284" id="anc284"></a><span class="line-modified">2451                     a[less] = ak;</span>
<span class="line-modified">2452                     ++less;</span>
<span class="line-modified">2453                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">2454                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">2455                         if (great-- == k) {</span>
<span class="line-removed">2456                             break outer;</span>
<span class="line-removed">2457                         }</span>
<span class="line-removed">2458                     }</span>
<span class="line-removed">2459                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">2460                         a[k] = a[less];</span>
<span class="line-removed">2461                         a[less] = a[great];</span>
<span class="line-removed">2462                         ++less;</span>
<span class="line-removed">2463                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">2464                         a[k] = a[great];</span>
2465                     }
<a name="285" id="anc285"></a>
2466                     /*
<a name="286" id="anc286"></a><span class="line-modified">2467                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">2468                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
2469                      */
<a name="287" id="anc287"></a><span class="line-modified">2470                     a[great] = ak;</span>
<span class="line-modified">2471                     --great;</span>


2472                 }
2473             }
2474 
<a name="288" id="anc288"></a><span class="line-removed">2475             // Swap pivots into their final positions</span>
<span class="line-removed">2476             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed">2477             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed">2478 </span>
<span class="line-removed">2479             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">2480             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">2481             sort(a, great + 2, right, false);</span>
<span class="line-removed">2482 </span>
2483             /*
<a name="289" id="anc289"></a><span class="line-modified">2484              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed">2485              * swap internal pivot values to ends.</span>
2486              */
<a name="290" id="anc290"></a><span class="line-modified">2487             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">2488                 /*</span>
<span class="line-removed">2489                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">2490                  */</span>
<span class="line-removed">2491                 while (a[less] == pivot1) {</span>
<span class="line-removed">2492                     ++less;</span>
<span class="line-removed">2493                 }</span>
<span class="line-removed">2494 </span>
<span class="line-removed">2495                 while (a[great] == pivot2) {</span>
<span class="line-removed">2496                     --great;</span>
<span class="line-removed">2497                 }</span>
2498 
2499                 /*
<a name="291" id="anc291"></a><span class="line-modified">2500                  * Partitioning:</span>
<span class="line-modified">2501                  *</span>
<span class="line-modified">2502                  *   left part         center part                  right part</span>
<span class="line-removed">2503                  * +----------------------------------------------------------+</span>
<span class="line-removed">2504                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed">2505                  * +----------------------------------------------------------+</span>
<span class="line-removed">2506                  *              ^                        ^       ^</span>
<span class="line-removed">2507                  *              |                        |       |</span>
<span class="line-removed">2508                  *             less                      k     great</span>
<span class="line-removed">2509                  *</span>
<span class="line-removed">2510                  * Invariants:</span>
<span class="line-removed">2511                  *</span>
<span class="line-removed">2512                  *              all in (*,  less) == pivot1</span>
<span class="line-removed">2513                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed">2514                  *              all in (great, *) == pivot2</span>
<span class="line-removed">2515                  *</span>
<span class="line-removed">2516                  * Pointer k is the first index of ?-part.</span>
2517                  */
<a name="292" id="anc292"></a><span class="line-modified">2518                 outer:</span>
<span class="line-modified">2519                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">2520                     float ak = a[k];</span>
<span class="line-modified">2521                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">2522                         a[k] = a[less];</span>
<span class="line-removed">2523                         a[less] = ak;</span>
<span class="line-removed">2524                         ++less;</span>
<span class="line-removed">2525                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">2526                         while (a[great] == pivot2) {</span>
<span class="line-removed">2527                             if (great-- == k) {</span>
<span class="line-removed">2528                                 break outer;</span>
<span class="line-removed">2529                             }</span>
<span class="line-removed">2530                         }</span>
<span class="line-removed">2531                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">2532                             a[k] = a[less];</span>
<span class="line-removed">2533                             /*</span>
<span class="line-removed">2534                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">2535                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">2536                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">2537                              * of different signs. Therefore in float and</span>
<span class="line-removed">2538                              * double sorting methods we have to use more</span>
<span class="line-removed">2539                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">2540                              */</span>
<span class="line-removed">2541                             a[less] = a[great];</span>
<span class="line-removed">2542                             ++less;</span>
<span class="line-removed">2543                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">2544                             a[k] = a[great];</span>
<span class="line-removed">2545                         }</span>
<span class="line-removed">2546                         a[great] = ak;</span>
<span class="line-removed">2547                         --great;</span>
2548                     }
<a name="293" id="anc293"></a><span class="line-modified">2549                 }</span>
<span class="line-removed">2550             }</span>
2551 
<a name="294" id="anc294"></a><span class="line-modified">2552             // Sort center part recursively</span>
<span class="line-modified">2553             sort(a, less, great, false);</span>


2554 
<a name="295" id="anc295"></a><span class="line-modified">2555         } else { // Partitioning with one pivot</span>
<span class="line-removed">2556             /*</span>
<span class="line-removed">2557              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">2558              * This value is inexpensive approximation of the median.</span>
<span class="line-removed">2559              */</span>
<span class="line-removed">2560             float pivot = a[e3];</span>
2561 
<a name="296" id="anc296"></a><span class="line-modified">2562             /*</span>
<span class="line-modified">2563              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed">2564              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed">2565              *</span>
<span class="line-removed">2566              *   left part    center part              right part</span>
<span class="line-removed">2567              * +-------------------------------------------------+</span>
<span class="line-removed">2568              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">2569              * +-------------------------------------------------+</span>
<span class="line-removed">2570              *              ^              ^        ^</span>
<span class="line-removed">2571              *              |              |        |</span>
<span class="line-removed">2572              *             less            k      great</span>
<span class="line-removed">2573              *</span>
<span class="line-removed">2574              * Invariants:</span>
<span class="line-removed">2575              *</span>
<span class="line-removed">2576              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">2577              *   all in [less, k)     == pivot</span>
<span class="line-removed">2578              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">2579              *</span>
<span class="line-removed">2580              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">2581              */</span>
<span class="line-removed">2582             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">2583                 if (a[k] == pivot) {</span>
<span class="line-removed">2584                     continue;</span>
<span class="line-removed">2585                 }</span>
<span class="line-removed">2586                 float ak = a[k];</span>
<span class="line-removed">2587                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">2588                     a[k] = a[less];</span>
<span class="line-removed">2589                     a[less] = ak;</span>
<span class="line-removed">2590                     ++less;</span>
<span class="line-removed">2591                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">2592                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">2593                         --great;</span>
2594                     }
<a name="297" id="anc297"></a><span class="line-modified">2595                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified">2596                         a[k] = a[less];</span>
<span class="line-modified">2597                         a[less] = a[great];</span>
<span class="line-modified">2598                         ++less;</span>
<span class="line-removed">2599                     } else { // a[great] == pivot</span>
<span class="line-removed">2600                         /*</span>
<span class="line-removed">2601                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">2602                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">2603                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">2604                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">2605                          * and double sorting methods we have to use</span>
<span class="line-removed">2606                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">2607                          */</span>
<span class="line-removed">2608                         a[k] = a[great];</span>
2609                     }
<a name="298" id="anc298"></a><span class="line-modified">2610                     a[great] = ak;</span>
<span class="line-removed">2611                     --great;</span>
2612                 }
2613             }
<a name="299" id="anc299"></a>

2614 
<a name="300" id="anc300"></a><span class="line-modified">2615             /*</span>
<span class="line-modified">2616              * Sort left and right parts recursively.</span>
<span class="line-modified">2617              * All elements from center part are equal</span>
<span class="line-modified">2618              * and, therefore, already sorted.</span>
<span class="line-modified">2619              */</span>
<span class="line-modified">2620             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">2621             sort(a, great + 1, right, false);</span>










2622         }
2623     }
2624 
2625     /**
<a name="301" id="anc301"></a><span class="line-modified">2626      * Sorts the specified range of the array using the given</span>
<span class="line-removed">2627      * workspace array slice if possible for merging</span>
2628      *
2629      * @param a the array to be sorted
<a name="302" id="anc302"></a><span class="line-modified">2630      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2631      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2632      * @param work a workspace array (slice)</span>
<span class="line-modified">2633      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2634      * @param workLen usable size of work array</span>
<span class="line-modified">2635      */</span>
<span class="line-removed">2636     static void sort(double[] a, int left, int right,</span>
<span class="line-removed">2637                      double[] work, int workBase, int workLen) {</span>
<span class="line-removed">2638         /*</span>
<span class="line-removed">2639          * Phase 1: Move NaNs to the end of the array.</span>
<span class="line-removed">2640          */</span>
<span class="line-removed">2641         while (left &lt;= right &amp;&amp; Double.isNaN(a[right])) {</span>
<span class="line-removed">2642             --right;</span>
2643         }
<a name="303" id="anc303"></a><span class="line-modified">2644         for (int k = right; --k &gt;= left; ) {</span>
<span class="line-modified">2645             double ak = a[k];</span>
<span class="line-modified">2646             if (ak != ak) { // a[k] is NaN</span>
<span class="line-modified">2647                 a[k] = a[right];</span>
<span class="line-modified">2648                 a[right] = ak;</span>
<span class="line-modified">2649                 --right;</span>






















2650             }
2651         }
<a name="304" id="anc304"></a>

2652 
<a name="305" id="anc305"></a><span class="line-modified">2653         /*</span>
<span class="line-modified">2654          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="line-modified">2655          */</span>
<span class="line-modified">2656         doSort(a, left, right, work, workBase, workLen);</span>






2657 
2658         /*
<a name="306" id="anc306"></a><span class="line-modified">2659          * Phase 3: Place negative zeros before positive zeros.</span>


2660          */
<a name="307" id="anc307"></a><span class="line-modified">2661         int hi = right;</span>


2662 
2663         /*
<a name="308" id="anc308"></a><span class="line-modified">2664          * Find the first zero, or first positive, or last negative element.</span>
2665          */
<a name="309" id="anc309"></a><span class="line-modified">2666         while (left &lt; hi) {</span>
<span class="line-removed">2667             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="line-removed">2668             double middleValue = a[middle];</span>
2669 
<a name="310" id="anc310"></a><span class="line-modified">2670             if (middleValue &lt; 0.0d) {</span>
<span class="line-modified">2671                 left = middle + 1;</span>
<span class="line-modified">2672             } else {</span>
<span class="line-modified">2673                 hi = middle;</span>



















2674             }
<a name="311" id="anc311"></a><span class="line-removed">2675         }</span>
2676 
<a name="312" id="anc312"></a><span class="line-modified">2677         /*</span>
<span class="line-modified">2678          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="line-modified">2679          */</span>
<span class="line-modified">2680         while (left &lt;= right &amp;&amp; Double.doubleToRawLongBits(a[left]) &lt; 0) {</span>
<span class="line-modified">2681             ++left;</span>
















































2682         }
2683 
2684         /*
<a name="313" id="anc313"></a><span class="line-modified">2685          * Move negative zeros to the beginning of the sub-range.</span>
<span class="line-removed">2686          *</span>
<span class="line-removed">2687          * Partitioning:</span>
<span class="line-removed">2688          *</span>
<span class="line-removed">2689          * +----------------------------------------------------+</span>
<span class="line-removed">2690          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="line-removed">2691          * +----------------------------------------------------+</span>
<span class="line-removed">2692          *              ^          ^         ^</span>
<span class="line-removed">2693          *              |          |         |</span>
<span class="line-removed">2694          *             left        p         k</span>
<span class="line-removed">2695          *</span>
<span class="line-removed">2696          * Invariants:</span>
<span class="line-removed">2697          *</span>
<span class="line-removed">2698          *   all in (*,  left)  &lt;  0.0</span>
<span class="line-removed">2699          *   all in [left,  p) == -0.0</span>
<span class="line-removed">2700          *   all in [p,     k) ==  0.0</span>
<span class="line-removed">2701          *   all in [k, right] &gt;=  0.0</span>
<span class="line-removed">2702          *</span>
<span class="line-removed">2703          * Pointer k is the first index of ?-part.</span>
2704          */
<a name="314" id="anc314"></a><span class="line-modified">2705         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="line-modified">2706             double ak = a[k];</span>
<span class="line-modified">2707             if (ak != 0.0d) {</span>
<span class="line-modified">2708                 break;</span>
<span class="line-modified">2709             }</span>
<span class="line-modified">2710             if (Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="line-modified">2711                 a[k] = 0.0d;</span>
<span class="line-removed">2712                 a[++p] = -0.0d;</span>
2713             }
<a name="315" id="anc315"></a>
2714         }
<a name="316" id="anc316"></a>
2715     }
2716 
2717     /**
<a name="317" id="anc317"></a><span class="line-modified">2718      * Sorts the specified range of the array.</span>
2719      *
<a name="318" id="anc318"></a><span class="line-modified">2720      * @param a the array to be sorted</span>
<span class="line-modified">2721      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2722      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2723      * @param work a workspace array (slice)</span>
<span class="line-modified">2724      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2725      * @param workLen usable size of work array</span>
<span class="line-modified">2726      */</span>
<span class="line-modified">2727     private static void doSort(double[] a, int left, int right,</span>
<span class="line-modified">2728                                double[] work, int workBase, int workLen) {</span>
<span class="line-modified">2729         // Use Quicksort on small arrays</span>
<span class="line-modified">2730         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">2731             sort(a, left, right, true);</span>
<span class="line-modified">2732             return;</span>








2733         }
2734 
2735         /*
<a name="319" id="anc319"></a><span class="line-modified">2736          * Index run[i] is the start of i-th run</span>
<span class="line-removed">2737          * (ascending or descending sequence).</span>
2738          */
<a name="320" id="anc320"></a><span class="line-modified">2739         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">2740         int count = 0; run[0] = left;</span>
<span class="line-removed">2741 </span>
<span class="line-removed">2742         // Check if the array is nearly sorted</span>
<span class="line-removed">2743         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">2744             // Equal items in the beginning of the sequence</span>
<span class="line-removed">2745             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">2746                 k++;</span>
<span class="line-removed">2747             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">2748             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">2749                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">2750             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">2751                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">2752                 // Transform into an ascending sequence</span>
<span class="line-removed">2753                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">2754                     double t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">2755                 }</span>
<span class="line-removed">2756             }</span>
2757 
<a name="321" id="anc321"></a><span class="line-modified">2758             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">2759             // ascending sequence</span>
<span class="line-modified">2760             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">2761                 count--;</span>
<span class="line-removed">2762             }</span>
2763 
<a name="322" id="anc322"></a><span class="line-modified">2764             /*</span>
<span class="line-modified">2765              * The array is not highly structured,</span>
<span class="line-modified">2766              * use Quicksort instead of merge sort.</span>
<span class="line-modified">2767              */</span>
<span class="line-modified">2768             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">2769                 sort(a, left, right, true);</span>
<span class="line-modified">2770                 return;</span>
<span class="line-removed">2771             }</span>
2772         }
2773 
<a name="323" id="anc323"></a><span class="line-modified">2774         // These invariants should hold true:</span>
<span class="line-removed">2775         //    run[0] = 0</span>
<span class="line-removed">2776         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
2777 
<a name="324" id="anc324"></a><span class="line-modified">2778         if (count == 0) {</span>
<span class="line-modified">2779             // A single equal run</span>
<span class="line-modified">2780             return;</span>
<span class="line-modified">2781         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">2782             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">2783             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">2784             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">2785             return;</span>
<span class="line-removed">2786         }</span>
<span class="line-removed">2787         right++;</span>
<span class="line-removed">2788         if (run[count] &lt; right) {</span>
<span class="line-removed">2789             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">2790             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">2791             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">2792             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">2793             run[++count] = right;</span>
<span class="line-removed">2794         }</span>
<span class="line-removed">2795 </span>
<span class="line-removed">2796         // Determine alternation base for merge</span>
<span class="line-removed">2797         byte odd = 0;</span>
<span class="line-removed">2798         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">2799 </span>
<span class="line-removed">2800         // Use or create temporary array b for merging</span>
<span class="line-removed">2801         double[] b;                 // temp array; alternates with a</span>
<span class="line-removed">2802         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">2803         int blen = right - left; // space needed for b</span>
<span class="line-removed">2804         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">2805             work = new double[blen];</span>
<span class="line-removed">2806             workBase = 0;</span>
<span class="line-removed">2807         }</span>
<span class="line-removed">2808         if (odd == 0) {</span>
<span class="line-removed">2809             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">2810             b = a;</span>
<span class="line-removed">2811             bo = 0;</span>
<span class="line-removed">2812             a = work;</span>
<span class="line-removed">2813             ao = workBase - left;</span>
2814         } else {
<a name="325" id="anc325"></a><span class="line-modified">2815             b = work;</span>
<span class="line-removed">2816             ao = 0;</span>
<span class="line-removed">2817             bo = workBase - left;</span>
<span class="line-removed">2818         }</span>
<span class="line-removed">2819 </span>
<span class="line-removed">2820         // Merging</span>
<span class="line-removed">2821         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">2822             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">2823                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">2824                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">2825                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">2826                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">2827                     } else {</span>
<span class="line-removed">2828                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">2829                     }</span>
<span class="line-removed">2830                 }</span>
<span class="line-removed">2831                 run[++last] = hi;</span>
<span class="line-removed">2832             }</span>
<span class="line-removed">2833             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">2834                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">2835                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">2836                 );</span>
<span class="line-removed">2837                 run[++last] = right;</span>
<span class="line-removed">2838             }</span>
<span class="line-removed">2839             double[] t = a; a = b; b = t;</span>
<span class="line-removed">2840             int o = ao; ao = bo; bo = o;</span>
2841         }
<a name="326" id="anc326"></a>
2842     }
2843 
2844     /**
<a name="327" id="anc327"></a><span class="line-modified">2845      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
2846      *
<a name="328" id="anc328"></a><span class="line-modified">2847      * @param a the array to be sorted</span>
<span class="line-modified">2848      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2849      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2850      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">2851      */</span>
<span class="line-modified">2852     private static void sort(double[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">2853         int length = right - left + 1;</span>
<span class="line-modified">2854 </span>
<span class="line-modified">2855         // Use insertion sort on tiny arrays</span>
<span class="line-modified">2856         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">2857             if (leftmost) {</span>
<span class="line-modified">2858                 /*</span>
<span class="line-modified">2859                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">2860                  * optimized for server VM, is used in case of</span>
<span class="line-modified">2861                  * the leftmost part.</span>
<span class="line-modified">2862                  */</span>
<span class="line-modified">2863                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">2864                     double ai = a[i + 1];</span>
<span class="line-modified">2865                     while (ai &lt; a[j]) {</span>
<span class="line-modified">2866                         a[j + 1] = a[j];</span>
<span class="line-modified">2867                         if (j-- == left) {</span>
<span class="line-modified">2868                             break;</span>
<span class="line-modified">2869                         }</span>
<span class="line-removed">2870                     }</span>
<span class="line-removed">2871                     a[j + 1] = ai;</span>
2872                 }
<a name="329" id="anc329"></a><span class="line-modified">2873             } else {</span>
2874                 /*
<a name="330" id="anc330"></a><span class="line-modified">2875                  * Skip the longest ascending sequence.</span>
2876                  */
<a name="331" id="anc331"></a><span class="line-modified">2877                 do {</span>
<span class="line-modified">2878                     if (left &gt;= right) {</span>
<span class="line-modified">2879                         return;</span>
<span class="line-removed">2880                     }</span>
<span class="line-removed">2881                 } while (a[++left] &gt;= a[left - 1]);</span>
2882 
2883                 /*
<a name="332" id="anc332"></a><span class="line-modified">2884                  * Every element from adjoining part plays the role</span>
<span class="line-removed">2885                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">2886                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">2887                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">2888                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">2889                  * than traditional implementation of insertion sort.</span>
2890                  */
<a name="333" id="anc333"></a><span class="line-modified">2891                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">2892                     double a1 = a[k], a2 = a[left];</span>

2893 
<a name="334" id="anc334"></a><span class="line-modified">2894                     if (a1 &lt; a2) {</span>
<span class="line-modified">2895                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">2896                     }</span>
<span class="line-modified">2897                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">2898                         a[k + 2] = a[k];</span>
<span class="line-removed">2899                     }</span>
<span class="line-removed">2900                     a[++k + 1] = a1;</span>
2901 
<a name="335" id="anc335"></a><span class="line-modified">2902                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">2903                         a[k + 1] = a[k];</span>


2904                     }
<a name="336" id="anc336"></a><span class="line-removed">2905                     a[k + 1] = a2;</span>
2906                 }
<a name="337" id="anc337"></a><span class="line-removed">2907                 double last = a[right];</span>
2908 
<a name="338" id="anc338"></a><span class="line-modified">2909                 while (last &lt; a[--right]) {</span>
<span class="line-modified">2910                     a[right + 1] = a[right];</span>
<span class="line-modified">2911                 }</span>
<span class="line-modified">2912                 a[right + 1] = last;</span>








2913             }
<a name="339" id="anc339"></a><span class="line-removed">2914             return;</span>
2915         }
2916 
<a name="340" id="anc340"></a><span class="line-removed">2917         // Inexpensive approximation of length / 7</span>
<span class="line-removed">2918         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">2919 </span>
2920         /*
<a name="341" id="anc341"></a><span class="line-modified">2921          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">2922          * center element in the range. These elements will be used for</span>
<span class="line-removed">2923          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">2924          * these elements was empirically determined to work well on</span>
<span class="line-removed">2925          * a wide variety of inputs.</span>
2926          */
<a name="342" id="anc342"></a><span class="line-modified">2927         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">2928         int e2 = e3 - seventh;</span>
<span class="line-removed">2929         int e1 = e2 - seventh;</span>
<span class="line-removed">2930         int e4 = e3 + seventh;</span>
<span class="line-removed">2931         int e5 = e4 + seventh;</span>
<span class="line-removed">2932 </span>
<span class="line-removed">2933         // Sort these elements using insertion sort</span>
<span class="line-removed">2934         if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2935 </span>
<span class="line-removed">2936         if (a[e3] &lt; a[e2]) { double t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2937             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2938         }
<a name="343" id="anc343"></a><span class="line-modified">2939         if (a[e4] &lt; a[e3]) { double t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2940             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">2941                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2942             }
2943         }
<a name="344" id="anc344"></a><span class="line-modified">2944         if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">2945             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2946                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2947                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2948                 }</span>
2949             }
2950         }
<a name="345" id="anc345"></a>
2951 
<a name="346" id="anc346"></a><span class="line-modified">2952         // Pointers</span>
<span class="line-removed">2953         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">2954         int great = right; // The index before the first element of right part</span>
<span class="line-removed">2955 </span>
<span class="line-removed">2956         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">2957             /*</span>
<span class="line-removed">2958              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">2959              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">2960              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">2961              */</span>
<span class="line-removed">2962             double pivot1 = a[e2];</span>
<span class="line-removed">2963             double pivot2 = a[e4];</span>
<span class="line-removed">2964 </span>
<span class="line-removed">2965             /*</span>
<span class="line-removed">2966              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">2967              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">2968              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">2969              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed">2970              */</span>
<span class="line-removed">2971             a[e2] = a[left];</span>
<span class="line-removed">2972             a[e4] = a[right];</span>
2973 
<a name="347" id="anc347"></a><span class="line-modified">2974             /*</span>
<span class="line-modified">2975              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-modified">2976              */</span>
<span class="line-modified">2977             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">2978             while (a[--great] &gt; pivot2);</span>













2979 
<a name="348" id="anc348"></a><span class="line-modified">2980             /*</span>
<span class="line-modified">2981              * Partitioning:</span>
<span class="line-modified">2982              *</span>
<span class="line-modified">2983              *   left part           center part                   right part</span>
<span class="line-modified">2984              * +--------------------------------------------------------------+</span>
<span class="line-modified">2985              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified">2986              * +--------------------------------------------------------------+</span>
<span class="line-modified">2987              *               ^                          ^       ^</span>
<span class="line-modified">2988              *               |                          |       |</span>
<span class="line-modified">2989              *              less                        k     great</span>
<span class="line-modified">2990              *</span>
<span class="line-modified">2991              * Invariants:</span>
<span class="line-modified">2992              *</span>
<span class="line-modified">2993              *              all in (left, less)   &lt; pivot1</span>
<span class="line-modified">2994              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-modified">2995              *              all in (great, right) &gt; pivot2</span>
<span class="line-modified">2996              *</span>
<span class="line-modified">2997              * Pointer k is the first index of ?-part.</span>
<span class="line-modified">2998              */</span>
<span class="line-removed">2999             outer:</span>
<span class="line-removed">3000             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">3001                 double ak = a[k];</span>
<span class="line-removed">3002                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">3003                     a[k] = a[less];</span>
<span class="line-removed">3004                     /*</span>
<span class="line-removed">3005                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">3006                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-removed">3007                      */</span>
<span class="line-removed">3008                     a[less] = ak;</span>
<span class="line-removed">3009                     ++less;</span>
<span class="line-removed">3010                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">3011                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">3012                         if (great-- == k) {</span>
<span class="line-removed">3013                             break outer;</span>
<span class="line-removed">3014                         }</span>
<span class="line-removed">3015                     }</span>
<span class="line-removed">3016                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">3017                         a[k] = a[less];</span>
<span class="line-removed">3018                         a[less] = a[great];</span>
<span class="line-removed">3019                         ++less;</span>
<span class="line-removed">3020                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">3021                         a[k] = a[great];</span>
<span class="line-removed">3022                     }</span>
<span class="line-removed">3023                     /*</span>
<span class="line-removed">3024                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">3025                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed">3026                      */</span>
<span class="line-removed">3027                     a[great] = ak;</span>
<span class="line-removed">3028                     --great;</span>
3029                 }
3030             }
<a name="349" id="anc349"></a>

3031 
<a name="350" id="anc350"></a><span class="line-modified">3032             // Swap pivots into their final positions</span>
<span class="line-modified">3033             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified">3034             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-modified">3035 </span>
<span class="line-modified">3036             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-modified">3037             sort(a, left, less - 2, leftmost);</span>
<span class="line-modified">3038             sort(a, great + 2, right, false);</span>











3039 
<a name="351" id="anc351"></a><span class="line-modified">3040             /*</span>
<span class="line-modified">3041              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-modified">3042              * swap internal pivot values to ends.</span>
<span class="line-modified">3043              */</span>
<span class="line-modified">3044             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">3045                 /*</span>
<span class="line-removed">3046                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">3047                  */</span>
<span class="line-removed">3048                 while (a[less] == pivot1) {</span>
<span class="line-removed">3049                     ++less;</span>
<span class="line-removed">3050                 }</span>
3051 
<a name="352" id="anc352"></a><span class="line-modified">3052                 while (a[great] == pivot2) {</span>
<span class="line-modified">3053                     --great;</span>
<span class="line-modified">3054                 }</span>

















3055 
<a name="353" id="anc353"></a><span class="line-modified">3056                 /*</span>
<span class="line-modified">3057                  * Partitioning:</span>
<span class="line-modified">3058                  *</span>
<span class="line-modified">3059                  *   left part         center part                  right part</span>
<span class="line-modified">3060                  * +----------------------------------------------------------+</span>
<span class="line-modified">3061                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified">3062                  * +----------------------------------------------------------+</span>
<span class="line-modified">3063                  *              ^                        ^       ^</span>
<span class="line-modified">3064                  *              |                        |       |</span>
<span class="line-modified">3065                  *             less                      k     great</span>
<span class="line-modified">3066                  *</span>
<span class="line-modified">3067                  * Invariants:</span>
<span class="line-modified">3068                  *</span>
<span class="line-modified">3069                  *              all in (*,  less) == pivot1</span>
<span class="line-modified">3070                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified">3071                  *              all in (great, *) == pivot2</span>
<span class="line-modified">3072                  *</span>
<span class="line-removed">3073                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed">3074                  */</span>
<span class="line-removed">3075                 outer:</span>
<span class="line-removed">3076                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">3077                     double ak = a[k];</span>
<span class="line-removed">3078                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">3079                         a[k] = a[less];</span>
<span class="line-removed">3080                         a[less] = ak;</span>
<span class="line-removed">3081                         ++less;</span>
<span class="line-removed">3082                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">3083                         while (a[great] == pivot2) {</span>
<span class="line-removed">3084                             if (great-- == k) {</span>
<span class="line-removed">3085                                 break outer;</span>
<span class="line-removed">3086                             }</span>
<span class="line-removed">3087                         }</span>
<span class="line-removed">3088                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">3089                             a[k] = a[less];</span>
<span class="line-removed">3090                             /*</span>
<span class="line-removed">3091                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">3092                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">3093                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">3094                              * of different signs. Therefore in float and</span>
<span class="line-removed">3095                              * double sorting methods we have to use more</span>
<span class="line-removed">3096                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">3097                              */</span>
<span class="line-removed">3098                             a[less] = a[great];</span>
<span class="line-removed">3099                             ++less;</span>
<span class="line-removed">3100                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">3101                             a[k] = a[great];</span>
<span class="line-removed">3102                         }</span>
<span class="line-removed">3103                         a[great] = ak;</span>
<span class="line-removed">3104                         --great;</span>
<span class="line-removed">3105                     }</span>
<span class="line-removed">3106                 }</span>
3107             }
<a name="354" id="anc354"></a>

3108 
<a name="355" id="anc355"></a><span class="line-modified">3109             // Sort center part recursively</span>
<span class="line-modified">3110             sort(a, less, great, false);</span>




3111 
<a name="356" id="anc356"></a><span class="line-modified">3112         } else { // Partitioning with one pivot</span>
<span class="line-modified">3113             /*</span>
<span class="line-modified">3114              * Use the third of the five sorted elements as pivot.</span>
<span class="line-modified">3115              * This value is inexpensive approximation of the median.</span>
<span class="line-modified">3116              */</span>
<span class="line-modified">3117             double pivot = a[e3];</span>













3118 
<a name="357" id="anc357"></a><span class="line-modified">3119             /*</span>
<span class="line-modified">3120              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified">3121              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified">3122              *</span>
<span class="line-removed">3123              *   left part    center part              right part</span>
<span class="line-removed">3124              * +-------------------------------------------------+</span>
<span class="line-removed">3125              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">3126              * +-------------------------------------------------+</span>
<span class="line-removed">3127              *              ^              ^        ^</span>
<span class="line-removed">3128              *              |              |        |</span>
<span class="line-removed">3129              *             less            k      great</span>
<span class="line-removed">3130              *</span>
<span class="line-removed">3131              * Invariants:</span>
<span class="line-removed">3132              *</span>
<span class="line-removed">3133              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">3134              *   all in [less, k)     == pivot</span>
<span class="line-removed">3135              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">3136              *</span>
<span class="line-removed">3137              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">3138              */</span>
<span class="line-removed">3139             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">3140                 if (a[k] == pivot) {</span>
<span class="line-removed">3141                     continue;</span>
<span class="line-removed">3142                 }</span>
<span class="line-removed">3143                 double ak = a[k];</span>
<span class="line-removed">3144                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">3145                     a[k] = a[less];</span>
<span class="line-removed">3146                     a[less] = ak;</span>
<span class="line-removed">3147                     ++less;</span>
<span class="line-removed">3148                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">3149                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">3150                         --great;</span>
<span class="line-removed">3151                     }</span>
<span class="line-removed">3152                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed">3153                         a[k] = a[less];</span>
<span class="line-removed">3154                         a[less] = a[great];</span>
<span class="line-removed">3155                         ++less;</span>
<span class="line-removed">3156                     } else { // a[great] == pivot</span>
<span class="line-removed">3157                         /*</span>
<span class="line-removed">3158                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">3159                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">3160                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">3161                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">3162                          * and double sorting methods we have to use</span>
<span class="line-removed">3163                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">3164                          */</span>
<span class="line-removed">3165                         a[k] = a[great];</span>
<span class="line-removed">3166                     }</span>
<span class="line-removed">3167                     a[great] = ak;</span>
<span class="line-removed">3168                     --great;</span>
<span class="line-removed">3169                 }</span>
3170             }
<a name="358" id="anc358"></a>











3171 
<a name="359" id="anc359"></a><span class="line-modified">3172             /*</span>
<span class="line-modified">3173              * Sort left and right parts recursively.</span>
<span class="line-modified">3174              * All elements from center part are equal</span>
<span class="line-modified">3175              * and, therefore, already sorted.</span>
<span class="line-modified">3176              */</span>
<span class="line-modified">3177             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">3178             sort(a, great + 1, right, false);</span>

3179         }
3180     }
3181 }
<a name="360" id="anc360"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="360" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/GregorianCalendar.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FormatterClosedException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/GregorianCalendar.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  36  *
  37  */
  38 
  39 package java.util;
  40 
  41 import java.io.IOException;
  42 import java.io.ObjectInputStream;
  43 import java.time.Instant;
  44 import java.time.ZonedDateTime;
  45 import java.time.temporal.ChronoField;
  46 import sun.util.calendar.BaseCalendar;
  47 import sun.util.calendar.CalendarDate;
  48 import sun.util.calendar.CalendarSystem;
  49 import sun.util.calendar.CalendarUtils;
  50 import sun.util.calendar.Era;
  51 import sun.util.calendar.Gregorian;
  52 import sun.util.calendar.JulianCalendar;
  53 import sun.util.calendar.ZoneInfo;
  54 
  55 /**
<span class="line-modified">  56  * &lt;code&gt;GregorianCalendar&lt;/code&gt; is a concrete subclass of</span>
<span class="line-modified">  57  * &lt;code&gt;Calendar&lt;/code&gt; and provides the standard calendar system</span>
  58  * used by most of the world.
  59  *
<span class="line-modified">  60  * &lt;p&gt; &lt;code&gt;GregorianCalendar&lt;/code&gt; is a hybrid calendar that</span>
  61  * supports both the Julian and Gregorian calendar systems with the
  62  * support of a single discontinuity, which corresponds by default to
  63  * the Gregorian date when the Gregorian calendar was instituted
  64  * (October 15, 1582 in some countries, later in others).  The cutover
  65  * date may be changed by the caller by calling {@link
  66  * #setGregorianChange(Date) setGregorianChange()}.
  67  *
  68  * &lt;p&gt;
  69  * Historically, in those countries which adopted the Gregorian calendar first,
  70  * October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
<span class="line-modified">  71  * this correctly.  Before the Gregorian cutover, &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
  72  * implements the Julian calendar.  The only difference between the Gregorian
  73  * and the Julian calendar is the leap year rule. The Julian calendar specifies
  74  * leap years every four years, whereas the Gregorian calendar omits century
  75  * years which are not divisible by 400.
  76  *
  77  * &lt;p&gt;
<span class="line-modified">  78  * &lt;code&gt;GregorianCalendar&lt;/code&gt; implements &lt;em&gt;proleptic&lt;/em&gt; Gregorian and</span>
  79  * Julian calendars. That is, dates are computed by extrapolating the current
  80  * rules indefinitely far backward and forward in time. As a result,
<span class="line-modified">  81  * &lt;code&gt;GregorianCalendar&lt;/code&gt; may be used for all years to generate</span>
  82  * meaningful and consistent results. However, dates obtained using
<span class="line-modified">  83  * &lt;code&gt;GregorianCalendar&lt;/code&gt; are historically accurate only from March 1, 4</span>
  84  * AD onward, when modern Julian calendar rules were adopted.  Before this date,
  85  * leap year rules were applied irregularly, and before 45 BC the Julian
  86  * calendar did not even exist.
  87  *
  88  * &lt;p&gt;
  89  * Prior to the institution of the Gregorian calendar, New Year&#39;s Day was
  90  * March 25. To avoid confusion, this calendar always uses January 1. A manual
  91  * adjustment may be made if desired for dates that are prior to the Gregorian
  92  * changeover and which fall between January 1 and March 24.
  93  *
<span class="line-modified">  94  * &lt;h3&gt;&lt;a id=&quot;week_and_year&quot;&gt;Week Of Year and Week Year&lt;/a&gt;&lt;/h3&gt;</span>
  95  *
  96  * &lt;p&gt;Values calculated for the {@link Calendar#WEEK_OF_YEAR
  97  * WEEK_OF_YEAR} field range from 1 to 53. The first week of a
  98  * calendar year is the earliest seven day period starting on {@link
  99  * Calendar#getFirstDayOfWeek() getFirstDayOfWeek()} that contains at
 100  * least {@link Calendar#getMinimalDaysInFirstWeek()
 101  * getMinimalDaysInFirstWeek()} days from that year. It thus depends
 102  * on the values of {@code getMinimalDaysInFirstWeek()}, {@code
 103  * getFirstDayOfWeek()}, and the day of the week of January 1. Weeks
 104  * between week 1 of one year and week 1 of the following year
 105  * (exclusive) are numbered sequentially from 2 to 52 or 53 (except
 106  * for year(s) involved in the Julian-Gregorian transition).
 107  *
 108  * &lt;p&gt;The {@code getFirstDayOfWeek()} and {@code
 109  * getMinimalDaysInFirstWeek()} values are initialized using
 110  * locale-dependent resources when constructing a {@code
 111  * GregorianCalendar}. &lt;a id=&quot;iso8601_compatible_setting&quot;&gt;The week
 112  * determination is compatible&lt;/a&gt; with the ISO 8601 standard when {@code
 113  * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 114  * getMinimalDaysInFirstWeek()} is 4, which values are used in locales
</pre>
<hr />
<pre>
 116  * calling {@link Calendar#setFirstDayOfWeek(int) setFirstDayOfWeek()} and
 117  * {@link Calendar#setMinimalDaysInFirstWeek(int)
 118  * setMinimalDaysInFirstWeek()}.
 119  *
 120  * &lt;p&gt;A &lt;a id=&quot;week_year&quot;&gt;&lt;em&gt;week year&lt;/em&gt;&lt;/a&gt; is in sync with a
 121  * {@code WEEK_OF_YEAR} cycle. All weeks between the first and last
 122  * weeks (inclusive) have the same &lt;em&gt;week year&lt;/em&gt; value.
 123  * Therefore, the first and last days of a week year may have
 124  * different calendar year values.
 125  *
 126  * &lt;p&gt;For example, January 1, 1998 is a Thursday. If {@code
 127  * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 128  * getMinimalDaysInFirstWeek()} is 4 (ISO 8601 standard compatible
 129  * setting), then week 1 of 1998 starts on December 29, 1997, and ends
 130  * on January 4, 1998. The week year is 1998 for the last three days
 131  * of calendar year 1997. If, however, {@code getFirstDayOfWeek()} is
 132  * {@code SUNDAY}, then week 1 of 1998 starts on January 4, 1998, and
 133  * ends on January 10, 1998; the first three days of 1998 then are
 134  * part of week 53 of 1997 and their week year is 1997.
 135  *
<span class="line-modified"> 136  * &lt;h4&gt;Week Of Month&lt;/h4&gt;</span>
 137  *
<span class="line-modified"> 138  * &lt;p&gt;Values calculated for the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; field range from 0</span>
 139  * to 6.  Week 1 of a month (the days with &lt;code&gt;WEEK_OF_MONTH =
 140  * 1&lt;/code&gt;) is the earliest set of at least
<span class="line-modified"> 141  * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; contiguous days in that month,</span>
<span class="line-modified"> 142  * ending on the day before &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;.  Unlike</span>
 143  * week 1 of a year, week 1 of a month may be shorter than 7 days, need
<span class="line-modified"> 144  * not start on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;, and will not include days of</span>
 145  * the previous month.  Days of a month before week 1 have a
<span class="line-modified"> 146  * &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.</span>
 147  *
<span class="line-modified"> 148  * &lt;p&gt;For example, if &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;SUNDAY&lt;/code&gt;</span>
<span class="line-modified"> 149  * and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is 4, then the first week of</span>
 150  * January 1998 is Sunday, January 4 through Saturday, January 10.  These days
<span class="line-modified"> 151  * have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.  Thursday, January 1 through</span>
<span class="line-modified"> 152  * Saturday, January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 0.  If</span>
<span class="line-modified"> 153  * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is changed to 3, then January 1</span>
<span class="line-modified"> 154  * through January 3 have a &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; of 1.</span>
 155  *
<span class="line-modified"> 156  * &lt;h4&gt;Default Fields Values&lt;/h4&gt;</span>
 157  *
<span class="line-modified"> 158  * &lt;p&gt;The &lt;code&gt;clear&lt;/code&gt; method sets calendar field(s)</span>
<span class="line-modified"> 159  * undefined. &lt;code&gt;GregorianCalendar&lt;/code&gt; uses the following</span>
 160  * default value for each calendar field if its value is undefined.
 161  *
 162  * &lt;table class=&quot;striped&quot; style=&quot;text-align: left; width: 66%;&quot;&gt;
 163  * &lt;caption style=&quot;display:none&quot;&gt;GregorianCalendar default field values&lt;/caption&gt;
 164  *   &lt;thead&gt;
 165  *     &lt;tr&gt;
 166  *       &lt;th scope=&quot;col&quot;&gt;
 167  *          Field
 168  *       &lt;/th&gt;
 169  *       &lt;th scope=&quot;col&quot;&gt;
 170             Default Value
 171  *       &lt;/th&gt;
 172  *     &lt;/tr&gt;
 173  *   &lt;/thead&gt;
 174  *   &lt;tbody&gt;
 175  *     &lt;tr&gt;
 176  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 177  *              &lt;code&gt;ERA&lt;/code&gt;</span>
 178  *       &lt;/th&gt;
 179  *       &lt;td&gt;
<span class="line-modified"> 180  *              &lt;code&gt;AD&lt;/code&gt;</span>
 181  *       &lt;/td&gt;
 182  *     &lt;/tr&gt;
 183  *     &lt;tr&gt;
 184  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 185  *              &lt;code&gt;YEAR&lt;/code&gt;</span>
 186  *       &lt;/th&gt;
 187  *       &lt;td&gt;
<span class="line-modified"> 188  *              &lt;code&gt;1970&lt;/code&gt;</span>
 189  *       &lt;/td&gt;
 190  *     &lt;/tr&gt;
 191  *     &lt;tr&gt;
 192  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 193  *              &lt;code&gt;MONTH&lt;/code&gt;</span>
 194  *       &lt;/th&gt;
 195  *       &lt;td&gt;
<span class="line-modified"> 196  *              &lt;code&gt;JANUARY&lt;/code&gt;</span>
 197  *       &lt;/td&gt;
 198  *     &lt;/tr&gt;
 199  *     &lt;tr&gt;
 200  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 201  *              &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;</span>
 202  *       &lt;/th&gt;
 203  *       &lt;td&gt;
<span class="line-modified"> 204  *              &lt;code&gt;1&lt;/code&gt;</span>
 205  *       &lt;/td&gt;
 206  *     &lt;/tr&gt;
 207  *     &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 209  *              &lt;code&gt;DAY_OF_WEEK&lt;/code&gt;</span>
 210  *       &lt;/th&gt;
 211  *       &lt;td&gt;
<span class="line-modified"> 212  *              &lt;code&gt;the first day of week&lt;/code&gt;</span>
 213  *       &lt;/td&gt;
 214  *     &lt;/tr&gt;
 215  *     &lt;tr&gt;
 216  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 217  *              &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt;</span>
 218  *       &lt;/th&gt;
 219  *       &lt;td&gt;
<span class="line-modified"> 220  *              &lt;code&gt;0&lt;/code&gt;</span>
 221  *       &lt;/td&gt;
 222  *     &lt;/tr&gt;
 223  *     &lt;tr&gt;
 224  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 225  *              &lt;code&gt;DAY_OF_WEEK_IN_MONTH&lt;/code&gt;</span>
 226  *       &lt;/th&gt;
 227  *       &lt;td&gt;
<span class="line-modified"> 228  *              &lt;code&gt;1&lt;/code&gt;</span>
 229  *       &lt;/td&gt;
 230  *     &lt;/tr&gt;
 231  *     &lt;tr&gt;
 232  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 233  *              &lt;code&gt;AM_PM&lt;/code&gt;</span>
 234  *       &lt;/th&gt;
 235  *       &lt;td&gt;
<span class="line-modified"> 236  *              &lt;code&gt;AM&lt;/code&gt;</span>
 237  *       &lt;/td&gt;
 238  *     &lt;/tr&gt;
 239  *     &lt;tr&gt;
 240  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 241  *              &lt;code&gt;HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND&lt;/code&gt;</span>
 242  *       &lt;/th&gt;
 243  *       &lt;td&gt;
<span class="line-modified"> 244  *              &lt;code&gt;0&lt;/code&gt;</span>
 245  *       &lt;/td&gt;
 246  *     &lt;/tr&gt;
 247  *   &lt;/tbody&gt;
 248  * &lt;/table&gt;
 249  * &lt;br&gt;Default values are not applicable for the fields not listed above.
 250  *
 251  * &lt;p&gt;
 252  * &lt;strong&gt;Example:&lt;/strong&gt;
 253  * &lt;blockquote&gt;
 254  * &lt;pre&gt;
 255  * // get the supported ids for GMT-08:00 (Pacific Standard Time)
 256  * String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
 257  * // if no ids were returned, something is wrong. get out.
 258  * if (ids.length == 0)
 259  *     System.exit(0);
 260  *
 261  *  // begin output
 262  * System.out.println(&quot;Current Time&quot;);
 263  *
 264  * // create a Pacific Standard Time time zone
</pre>
<hr />
<pre>
 343      * implement the modern definition of the calendar even though the
 344      * historical usage differs.  For example, if the Gregorian change is set
 345      * to new Date(Long.MIN_VALUE), we have a pure Gregorian calendar which
 346      * labels dates preceding the invention of the Gregorian calendar in 1582 as
 347      * if the calendar existed then.
 348      *
 349      * Likewise, with the Julian calendar, we assume a consistent
 350      * 4-year leap year rule, even though the historical pattern of
 351      * leap years is irregular, being every 3 years from 45 BCE
 352      * through 9 BCE, then every 4 years from 8 CE onwards, with no
 353      * leap years in-between.  Thus date computations and functions
 354      * such as isLeapYear() are not intended to be historically
 355      * accurate.
 356      */
 357 
 358 //////////////////
 359 // Class Variables
 360 //////////////////
 361 
 362     /**
<span class="line-modified"> 363      * Value of the &lt;code&gt;ERA&lt;/code&gt; field indicating</span>
 364      * the period before the common era (before Christ), also known as BCE.
<span class="line-modified"> 365      * The sequence of years at the transition from &lt;code&gt;BC&lt;/code&gt; to &lt;code&gt;AD&lt;/code&gt; is</span>
 366      * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 367      *
 368      * @see #ERA
 369      */
 370     public static final int BC = 0;
 371 
 372     /**
 373      * Value of the {@link #ERA} field indicating
 374      * the period before the common era, the same value as {@link #BC}.
 375      *
 376      * @see #CE
 377      */
 378     static final int BCE = 0;
 379 
 380     /**
<span class="line-modified"> 381      * Value of the &lt;code&gt;ERA&lt;/code&gt; field indicating</span>
 382      * the common era (Anno Domini), also known as CE.
<span class="line-modified"> 383      * The sequence of years at the transition from &lt;code&gt;BC&lt;/code&gt; to &lt;code&gt;AD&lt;/code&gt; is</span>
 384      * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 385      *
 386      * @see #ERA
 387      */
 388     public static final int AD = 1;
 389 
 390     /**
 391      * Value of the {@link #ERA} field indicating
 392      * the common era, the same value as {@link #AD}.
 393      *
 394      * @see #BCE
 395      */
 396     static final int CE = 1;
 397 
 398     private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
 399     private static final int EPOCH_YEAR     = 1970;
 400 
 401     static final int MONTH_LENGTH[]
 402         = {31,28,31,30,31,30,31,31,30,31,30,31}; // 0-based
 403     static final int LEAP_MONTH_LENGTH[]
</pre>
<hr />
<pre>
 480         292278994,      // YEAR
 481         DECEMBER,       // MONTH
 482         53,             // WEEK_OF_YEAR
 483         6,              // WEEK_OF_MONTH
 484         31,             // DAY_OF_MONTH
 485         366,            // DAY_OF_YEAR
 486         SATURDAY,       // DAY_OF_WEEK
 487         6,              // DAY_OF_WEEK_IN
 488         PM,             // AM_PM
 489         11,             // HOUR
 490         23,             // HOUR_OF_DAY
 491         59,             // MINUTE
 492         59,             // SECOND
 493         999,            // MILLISECOND
 494         14*ONE_HOUR,    // ZONE_OFFSET
 495         2*ONE_HOUR      // DST_OFFSET (double summer time)
 496     };
 497 
 498     // Proclaim serialization compatibility with JDK 1.1
 499     @SuppressWarnings(&quot;FieldNameHidesFieldInSuperclass&quot;)

 500     static final long serialVersionUID = -8125100834729963327L;
 501 
 502     // Reference to the sun.util.calendar.Gregorian instance (singleton).
 503     private static final Gregorian gcal =
 504                                 CalendarSystem.getGregorianCalendar();
 505 
 506     // Reference to the JulianCalendar instance (singleton), set as needed. See
 507     // getJulianCalendarSystem().
 508     private static JulianCalendar jcal;
 509 
 510     // JulianCalendar eras. See getJulianCalendarSystem().
 511     private static Era[] jeras;
 512 
 513     // The default value of gregorianCutover.
 514     static final long DEFAULT_GREGORIAN_CUTOVER = -12219292800000L;
 515 
 516 /////////////////////
 517 // Instance Variables
 518 /////////////////////
 519 
</pre>
<hr />
<pre>
 567     private transient BaseCalendar calsys;
 568 
 569     /**
 570      * Temporary int[2] to get time zone offsets. zoneOffsets[0] gets
 571      * the GMT offset value and zoneOffsets[1] gets the DST saving
 572      * value.
 573      */
 574     private transient int[] zoneOffsets;
 575 
 576     /**
 577      * Temporary storage for saving original fields[] values in
 578      * non-lenient mode.
 579      */
 580     private transient int[] originalFields;
 581 
 582 ///////////////
 583 // Constructors
 584 ///////////////
 585 
 586     /**
<span class="line-modified"> 587      * Constructs a default &lt;code&gt;GregorianCalendar&lt;/code&gt; using the current time</span>
 588      * in the default time zone with the default
 589      * {@link Locale.Category#FORMAT FORMAT} locale.
 590      */
 591     public GregorianCalendar() {
 592         this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));
 593         setZoneShared(true);
 594     }
 595 
 596     /**
<span class="line-modified"> 597      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time</span>
 598      * in the given time zone with the default
 599      * {@link Locale.Category#FORMAT FORMAT} locale.
 600      *
 601      * @param zone the given time zone.
 602      */
 603     public GregorianCalendar(TimeZone zone) {
 604         this(zone, Locale.getDefault(Locale.Category.FORMAT));
 605     }
 606 
 607     /**
<span class="line-modified"> 608      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time</span>
 609      * in the default time zone with the given locale.
 610      *
 611      * @param aLocale the given locale.
 612      */
 613     public GregorianCalendar(Locale aLocale) {
 614         this(TimeZone.getDefaultRef(), aLocale);
 615         setZoneShared(true);
 616     }
 617 
 618     /**
<span class="line-modified"> 619      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; based on the current time</span>
 620      * in the given time zone with the given locale.
 621      *
 622      * @param zone the given time zone.
 623      * @param aLocale the given locale.
 624      */
 625     public GregorianCalendar(TimeZone zone, Locale aLocale) {
 626         super(zone, aLocale);
 627         gdate = (BaseCalendar.Date) gcal.newCalendarDate(zone);
 628         setTimeInMillis(System.currentTimeMillis());
 629     }
 630 
 631     /**
<span class="line-modified"> 632      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date set</span>
 633      * in the default time zone with the default locale.
 634      *
<span class="line-modified"> 635      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 636      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.</span>
 637      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 638      * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.</span>
 639      */
 640     public GregorianCalendar(int year, int month, int dayOfMonth) {
 641         this(year, month, dayOfMonth, 0, 0, 0, 0);
 642     }
 643 
 644     /**
<span class="line-modified"> 645      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date</span>
 646      * and time set for the default time zone with the default locale.
 647      *
<span class="line-modified"> 648      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 649      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.</span>
 650      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 651      * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 652      * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field</span>
 653      * in the calendar.
<span class="line-modified"> 654      * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field</span>
 655      * in the calendar.
 656      */
 657     public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
 658                              int minute) {
 659         this(year, month, dayOfMonth, hourOfDay, minute, 0, 0);
 660     }
 661 
 662     /**
 663      * Constructs a GregorianCalendar with the given date
 664      * and time set for the default time zone with the default locale.
 665      *
<span class="line-modified"> 666      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 667      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.</span>
 668      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 669      * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 670      * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field</span>
 671      * in the calendar.
<span class="line-modified"> 672      * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field</span>
 673      * in the calendar.
<span class="line-modified"> 674      * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field</span>
 675      * in the calendar.
 676      */
 677     public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
 678                              int minute, int second) {
 679         this(year, month, dayOfMonth, hourOfDay, minute, second, 0);
 680     }
 681 
 682     /**
<span class="line-modified"> 683      * Constructs a &lt;code&gt;GregorianCalendar&lt;/code&gt; with the given date</span>
 684      * and time set for the default time zone with the default locale.
 685      *
<span class="line-modified"> 686      * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 687      * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field in the calendar.</span>
 688      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 689      * @param dayOfMonth the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field in the calendar.</span>
<span class="line-modified"> 690      * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field</span>
 691      * in the calendar.
<span class="line-modified"> 692      * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field</span>
 693      * in the calendar.
<span class="line-modified"> 694      * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field</span>
 695      * in the calendar.
<span class="line-modified"> 696      * @param millis the value used to set the &lt;code&gt;MILLISECOND&lt;/code&gt; calendar field</span>
 697      */
 698     GregorianCalendar(int year, int month, int dayOfMonth,
 699                       int hourOfDay, int minute, int second, int millis) {
 700         super();
 701         gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
 702         this.set(YEAR, year);
 703         this.set(MONTH, month);
 704         this.set(DAY_OF_MONTH, dayOfMonth);
 705 
 706         // Set AM_PM and HOUR here to set their stamp values before
 707         // setting HOUR_OF_DAY (6178071).
 708         if (hourOfDay &gt;= 12 &amp;&amp; hourOfDay &lt;= 23) {
 709             // If hourOfDay is a valid PM hour, set the correct PM values
 710             // so that it won&#39;t throw an exception in case it&#39;s set to
 711             // non-lenient later.
 712             this.internalSet(AM_PM, PM);
 713             this.internalSet(HOUR, hourOfDay - 12);
 714         } else {
 715             // The default value for AM_PM is AM.
 716             // We don&#39;t care any out of range value here for leniency.
</pre>
<hr />
<pre>
 727         this.internalSet(MILLISECOND, millis);
 728     }
 729 
 730     /**
 731      * Constructs an empty GregorianCalendar.
 732      *
 733      * @param zone    the given time zone
 734      * @param aLocale the given locale
 735      * @param flag    the flag requesting an empty instance
 736      */
 737     GregorianCalendar(TimeZone zone, Locale locale, boolean flag) {
 738         super(zone, locale);
 739         gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
 740     }
 741 
 742 /////////////////
 743 // Public methods
 744 /////////////////
 745 
 746     /**
<span class="line-modified"> 747      * Sets the &lt;code&gt;GregorianCalendar&lt;/code&gt; change date. This is the point when the switch</span>
 748      * from Julian dates to Gregorian dates occurred. Default is October 15,
 749      * 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.
 750      * &lt;p&gt;
 751      * To obtain a pure Julian calendar, set the change date to
<span class="line-modified"> 752      * &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt;.  To obtain a pure Gregorian calendar,</span>
<span class="line-modified"> 753      * set the change date to &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt;.</span>
 754      *
 755      * @param date the given Gregorian cutover date.
 756      */
 757     public void setGregorianChange(Date date) {
 758         long cutoverTime = date.getTime();
 759         if (cutoverTime == gregorianCutover) {
 760             return;
 761         }
 762         // Before changing the cutover date, make sure to have the
 763         // time of this calendar.
 764         complete();
 765         setGregorianChange(cutoverTime);
 766     }
 767 
 768     private void setGregorianChange(long cutoverTime) {
 769         gregorianCutover = cutoverTime;
 770         gregorianCutoverDate = CalendarUtils.floorDivide(cutoverTime, ONE_DAY)
 771                                 + EPOCH_OFFSET;
 772 
 773         // To provide the &quot;pure&quot; Julian calendar as advertised.
</pre>
<hr />
<pre>
 785         gregorianCutoverYear = d.getYear();
 786 
 787         BaseCalendar julianCal = getJulianCalendarSystem();
 788         d = (BaseCalendar.Date) julianCal.newCalendarDate(TimeZone.NO_TIMEZONE);
 789         julianCal.getCalendarDateFromFixedDate(d, gregorianCutoverDate - 1);
 790         gregorianCutoverYearJulian = d.getNormalizedYear();
 791 
 792         if (time &lt; gregorianCutover) {
 793             // The field values are no longer valid under the new
 794             // cutover date.
 795             setUnnormalized();
 796         }
 797     }
 798 
 799     /**
 800      * Gets the Gregorian Calendar change date.  This is the point when the
 801      * switch from Julian dates to Gregorian dates occurred. Default is
 802      * October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian
 803      * calendar.
 804      *
<span class="line-modified"> 805      * @return the Gregorian cutover date for this &lt;code&gt;GregorianCalendar&lt;/code&gt; object.</span>
 806      */
 807     public final Date getGregorianChange() {
 808         return new Date(gregorianCutover);
 809     }
 810 
 811     /**
<span class="line-modified"> 812      * Determines if the given year is a leap year. Returns &lt;code&gt;true&lt;/code&gt; if</span>
 813      * the given year is a leap year. To specify BC year numbers,
<span class="line-modified"> 814      * &lt;code&gt;1 - year number&lt;/code&gt; must be given. For example, year BC 4 is</span>
 815      * specified as -3.
 816      *
 817      * @param year the given year.
<span class="line-modified"> 818      * @return &lt;code&gt;true&lt;/code&gt; if the given year is a leap year; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
 819      */
 820     public boolean isLeapYear(int year) {
 821         if ((year &amp; 3) != 0) {
 822             return false;
 823         }
 824 
 825         if (year &gt; gregorianCutoverYear) {
 826             return (year%100 != 0) || (year%400 == 0); // Gregorian
 827         }
 828         if (year &lt; gregorianCutoverYearJulian) {
 829             return true; // Julian
 830         }
 831         boolean gregorian;
 832         // If the given year is the Gregorian cutover year, we need to
 833         // determine which calendar system to be applied to February in the year.
 834         if (gregorianCutoverYear == gregorianCutoverYearJulian) {
 835             BaseCalendar.Date d = getCalendarDate(gregorianCutoverDate); // Gregorian
 836             gregorian = d.getMonth() &lt; BaseCalendar.MARCH;
 837         } else {
 838             gregorian = year == gregorianCutoverYear;
 839         }
 840         return gregorian ? (year%100 != 0) || (year%400 == 0) : true;
 841     }
 842 
 843     /**
 844      * Returns {@code &quot;gregory&quot;} as the calendar type.
 845      *
 846      * @return {@code &quot;gregory&quot;}
 847      * @since 1.8
 848      */
 849     @Override
 850     public String getCalendarType() {
 851         return &quot;gregory&quot;;
 852     }
 853 
 854     /**
<span class="line-modified"> 855      * Compares this &lt;code&gt;GregorianCalendar&lt;/code&gt; to the specified</span>
<span class="line-modified"> 856      * &lt;code&gt;Object&lt;/code&gt;. The result is &lt;code&gt;true&lt;/code&gt; if and</span>
<span class="line-modified"> 857      * only if the argument is a &lt;code&gt;GregorianCalendar&lt;/code&gt; object</span>
 858      * that represents the same time value (millisecond offset from
 859      * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
<span class="line-modified"> 860      * &lt;code&gt;Calendar&lt;/code&gt; parameters and Gregorian change date as</span>
 861      * this object.
 862      *
 863      * @param obj the object to compare with.
<span class="line-modified"> 864      * @return &lt;code&gt;true&lt;/code&gt; if this object is equal to &lt;code&gt;obj&lt;/code&gt;;</span>
<span class="line-modified"> 865      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
 866      * @see Calendar#compareTo(Calendar)
 867      */
 868     @Override
 869     public boolean equals(Object obj) {
 870         return obj instanceof GregorianCalendar &amp;&amp;
 871             super.equals(obj) &amp;&amp;
 872             gregorianCutover == ((GregorianCalendar)obj).gregorianCutover;
 873     }
 874 
 875     /**
<span class="line-modified"> 876      * Generates the hash code for this &lt;code&gt;GregorianCalendar&lt;/code&gt; object.</span>
 877      */
 878     @Override
 879     public int hashCode() {
 880         return super.hashCode() ^ (int)gregorianCutoverDate;
 881     }
 882 
 883     /**
 884      * Adds the specified (signed) amount of time to the given calendar field,
 885      * based on the calendar&#39;s rules.
 886      *
<span class="line-modified"> 887      * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of &lt;code&gt;field&lt;/code&gt;</span>
<span class="line-modified"> 888      * after the call minus the value of &lt;code&gt;field&lt;/code&gt; before the</span>
<span class="line-modified"> 889      * call is &lt;code&gt;amount&lt;/code&gt;, modulo any overflow that has occurred in</span>
<span class="line-modified"> 890      * &lt;code&gt;field&lt;/code&gt;. Overflow occurs when a field value exceeds its</span>
 891      * range and, as a result, the next larger field is incremented or
 892      * decremented and the field value is adjusted back into its range.&lt;/p&gt;
 893      *
 894      * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
 895      * invariant, but it is impossible for it to be equal to its
 896      * prior value because of changes in its minimum or maximum after
<span class="line-modified"> 897      * &lt;code&gt;field&lt;/code&gt; is changed, then its value is adjusted to be as close</span>
 898      * as possible to its expected value. A smaller field represents a
<span class="line-modified"> 899      * smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than</span>
<span class="line-modified"> 900      * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields</span>
 901      * that are not expected to be invariant. The calendar system
 902      * determines what fields are expected to be invariant.&lt;/p&gt;
 903      *
 904      * @param field the calendar field.
 905      * @param amount the amount of date or time to be added to the field.
<span class="line-modified"> 906      * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is</span>
<span class="line-modified"> 907      * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,</span>
 908      * or if any calendar fields have out-of-range values in
 909      * non-lenient mode.
 910      */
 911     @Override
 912     public void add(int field, int amount) {
 913         // If amount == 0, do nothing even the given field is out of
 914         // range. This is tested by JCK.
 915         if (amount == 0) {
 916             return;   // Do nothing!
 917         }
 918 
 919         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 920             throw new IllegalArgumentException();
 921         }
 922 
 923         // Sync the time and calendar fields.
 924         complete();
 925 
 926         if (field == YEAR) {
 927             int year = internalGet(YEAR);
</pre>
<hr />
<pre>
1076             int zoneOffset = internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);
1077             setTimeInMillis((fd - EPOCH_OFFSET) * ONE_DAY + timeOfDay - zoneOffset);
1078             zoneOffset -= internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);
1079             // If the time zone offset has changed, then adjust the difference.
1080             if (zoneOffset != 0) {
1081                 setTimeInMillis(time + zoneOffset);
1082                 long fd2 = getCurrentFixedDate();
1083                 // If the adjustment has changed the date, then take
1084                 // the previous one.
1085                 if (fd2 != fd) {
1086                     setTimeInMillis(time - zoneOffset);
1087                 }
1088             }
1089         }
1090     }
1091 
1092     /**
1093      * Adds or subtracts (up/down) a single unit of time on the given time
1094      * field without changing larger fields.
1095      * &lt;p&gt;
<span class="line-modified">1096      * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
1097      * originally set to December 31, 1999. Calling {@link #roll(int,boolean) roll(Calendar.MONTH, true)}
<span class="line-modified">1098      * sets the calendar to January 31, 1999.  The &lt;code&gt;YEAR&lt;/code&gt; field is unchanged</span>
<span class="line-modified">1099      * because it is a larger field than &lt;code&gt;MONTH&lt;/code&gt;.&lt;/p&gt;</span>
1100      *
1101      * @param up indicates if the value of the specified calendar field is to be
<span class="line-modified">1102      * rolled up or rolled down. Use &lt;code&gt;true&lt;/code&gt; if rolling up, &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">1103      * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is</span>
<span class="line-modified">1104      * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,</span>
1105      * or if any calendar fields have out-of-range values in
1106      * non-lenient mode.
1107      * @see #add(int,int)
1108      * @see #set(int,int)
1109      */
1110     @Override
1111     public void roll(int field, boolean up) {
1112         roll(field, up ? +1 : -1);
1113     }
1114 
1115     /**
1116      * Adds a signed amount to the specified calendar field without changing larger fields.
1117      * A negative roll amount means to subtract from field without changing
1118      * larger fields. If the specified amount is 0, this method performs nothing.
1119      *
1120      * &lt;p&gt;This method calls {@link #complete()} before adding the
1121      * amount so that all the calendar fields are normalized. If there
1122      * is any calendar field having an out-of-range value in non-lenient mode, then an
<span class="line-modified">1123      * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</span>
1124      *
1125      * &lt;p&gt;
<span class="line-modified">1126      * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
1127      * originally set to August 31, 1999. Calling &lt;code&gt;roll(Calendar.MONTH,
1128      * 8)&lt;/code&gt; sets the calendar to April 30, &lt;strong&gt;1999&lt;/strong&gt;. Using a
<span class="line-modified">1129      * &lt;code&gt;GregorianCalendar&lt;/code&gt;, the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field cannot</span>
<span class="line-modified">1130      * be 31 in the month April. &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; is set to the closest possible</span>
<span class="line-modified">1131      * value, 30. The &lt;code&gt;YEAR&lt;/code&gt; field maintains the value of 1999 because it</span>
<span class="line-modified">1132      * is a larger field than &lt;code&gt;MONTH&lt;/code&gt;.</span>
1133      * &lt;p&gt;
<span class="line-modified">1134      * &lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
1135      * originally set to Sunday June 6, 1999. Calling
<span class="line-modified">1136      * &lt;code&gt;roll(Calendar.WEEK_OF_MONTH, -1)&lt;/code&gt; sets the calendar to</span>
1137      * Tuesday June 1, 1999, whereas calling
<span class="line-modified">1138      * &lt;code&gt;add(Calendar.WEEK_OF_MONTH, -1)&lt;/code&gt; sets the calendar to</span>
1139      * Sunday May 30, 1999. This is because the roll rule imposes an
<span class="line-modified">1140      * additional constraint: The &lt;code&gt;MONTH&lt;/code&gt; must not change when the</span>
<span class="line-modified">1141      * &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; is rolled. Taken together with add rule 1,</span>
1142      * the resultant date must be between Tuesday June 1 and Saturday June
<span class="line-modified">1143      * 5. According to add rule 2, the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt;, an invariant</span>
<span class="line-modified">1144      * when changing the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt;, is set to Tuesday, the</span>
1145      * closest possible value to Sunday (where Sunday is the first day of the
1146      * week).&lt;/p&gt;
1147      *
1148      * @param field the calendar field.
<span class="line-modified">1149      * @param amount the signed amount to add to &lt;code&gt;field&lt;/code&gt;.</span>
<span class="line-modified">1150      * @exception IllegalArgumentException if &lt;code&gt;field&lt;/code&gt; is</span>
<span class="line-modified">1151      * &lt;code&gt;ZONE_OFFSET&lt;/code&gt;, &lt;code&gt;DST_OFFSET&lt;/code&gt;, or unknown,</span>
1152      * or if any calendar fields have out-of-range values in
1153      * non-lenient mode.
1154      * @see #roll(int,boolean)
1155      * @see #add(int,int)
1156      * @see #set(int,int)
1157      * @since 1.2
1158      */
1159     @Override
1160     public void roll(int field, int amount) {
1161         // If amount == 0, do nothing even the given field is out of
1162         // range. This is tested by JCK.
1163         if (amount == 0) {
1164             return;
1165         }
1166 
1167         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
1168             throw new IllegalArgumentException();
1169         }
1170 
1171         // Sync the time and calendar fields.
</pre>
<hr />
<pre>
1494                 max = monthLength / 7;
1495                 int x = (int)(fd - month1) % 7;
1496                 if (x &lt; lastDays) {
1497                     max++;
1498                 }
1499                 int value = getRolledValue(internalGet(field), amount, min, max) - 1;
1500                 fd = month1 + value * 7 + x;
1501                 BaseCalendar cal = (fd &gt;= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();
1502                 BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);
1503                 cal.getCalendarDateFromFixedDate(d, fd);
1504                 set(DAY_OF_MONTH, d.getDayOfMonth());
1505                 return;
1506             }
1507         }
1508 
1509         set(field, getRolledValue(internalGet(field), amount, min, max));
1510     }
1511 
1512     /**
1513      * Returns the minimum value for the given calendar field of this
<span class="line-modified">1514      * &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The minimum value is</span>
1515      * defined as the smallest value returned by the {@link
1516      * Calendar#get(int) get} method for any possible time value,
1517      * taking into consideration the current values of the
1518      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1519      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1520      * {@link #getGregorianChange() getGregorianChange} and
1521      * {@link Calendar#getTimeZone() getTimeZone} methods.
1522      *
1523      * @param field the calendar field.
1524      * @return the minimum value for the given calendar field.
1525      * @see #getMaximum(int)
1526      * @see #getGreatestMinimum(int)
1527      * @see #getLeastMaximum(int)
1528      * @see #getActualMinimum(int)
1529      * @see #getActualMaximum(int)
1530      */
1531     @Override
1532     public int getMinimum(int field) {
1533         return MIN_VALUES[field];
1534     }
1535 
1536     /**
1537      * Returns the maximum value for the given calendar field of this
<span class="line-modified">1538      * &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The maximum value is</span>
1539      * defined as the largest value returned by the {@link
1540      * Calendar#get(int) get} method for any possible time value,
1541      * taking into consideration the current values of the
1542      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1543      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1544      * {@link #getGregorianChange() getGregorianChange} and
1545      * {@link Calendar#getTimeZone() getTimeZone} methods.
1546      *
1547      * @param field the calendar field.
1548      * @return the maximum value for the given calendar field.
1549      * @see #getMinimum(int)
1550      * @see #getGreatestMinimum(int)
1551      * @see #getLeastMaximum(int)
1552      * @see #getActualMinimum(int)
1553      * @see #getActualMaximum(int)
1554      */
1555     @Override
1556     public int getMaximum(int field) {
1557         switch (field) {
1558         case MONTH:
</pre>
<hr />
<pre>
1567                 // calendar dates are the same or Gregorian dates are
1568                 // larger (i.e., there is a &quot;gap&quot;) after 300-3-1.
1569                 if (gregorianCutoverYear &gt; 200) {
1570                     break;
1571                 }
1572                 // There might be &quot;overlapping&quot; dates.
1573                 GregorianCalendar gc = (GregorianCalendar) clone();
1574                 gc.setLenient(true);
1575                 gc.setTimeInMillis(gregorianCutover);
1576                 int v1 = gc.getActualMaximum(field);
1577                 gc.setTimeInMillis(gregorianCutover-1);
1578                 int v2 = gc.getActualMaximum(field);
1579                 return Math.max(MAX_VALUES[field], Math.max(v1, v2));
1580             }
1581         }
1582         return MAX_VALUES[field];
1583     }
1584 
1585     /**
1586      * Returns the highest minimum value for the given calendar field
<span class="line-modified">1587      * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The highest</span>
1588      * minimum value is defined as the largest value returned by
1589      * {@link #getActualMinimum(int)} for any possible time value,
1590      * taking into consideration the current values of the
1591      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1592      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1593      * {@link #getGregorianChange() getGregorianChange} and
1594      * {@link Calendar#getTimeZone() getTimeZone} methods.
1595      *
1596      * @param field the calendar field.
1597      * @return the highest minimum value for the given calendar field.
1598      * @see #getMinimum(int)
1599      * @see #getMaximum(int)
1600      * @see #getLeastMaximum(int)
1601      * @see #getActualMinimum(int)
1602      * @see #getActualMaximum(int)
1603      */
1604     @Override
1605     public int getGreatestMinimum(int field) {
1606         if (field == DAY_OF_MONTH) {
1607             BaseCalendar.Date d = getGregorianCutoverDate();
1608             long mon1 = getFixedDateMonth1(d, gregorianCutoverDate);
1609             d = getCalendarDate(mon1);
1610             return Math.max(MIN_VALUES[field], d.getDayOfMonth());
1611         }
1612         return MIN_VALUES[field];
1613     }
1614 
1615     /**
1616      * Returns the lowest maximum value for the given calendar field
<span class="line-modified">1617      * of this &lt;code&gt;GregorianCalendar&lt;/code&gt; instance. The lowest</span>
1618      * maximum value is defined as the smallest value returned by
1619      * {@link #getActualMaximum(int)} for any possible time value,
1620      * taking into consideration the current values of the
1621      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1622      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1623      * {@link #getGregorianChange() getGregorianChange} and
1624      * {@link Calendar#getTimeZone() getTimeZone} methods.
1625      *
1626      * @param field the calendar field
1627      * @return the lowest maximum value for the given calendar field.
1628      * @see #getMinimum(int)
1629      * @see #getMaximum(int)
1630      * @see #getGreatestMinimum(int)
1631      * @see #getActualMinimum(int)
1632      * @see #getActualMaximum(int)
1633      */
1634     @Override
1635     public int getLeastMaximum(int field) {
1636         switch (field) {
1637         case MONTH:
</pre>
<hr />
<pre>
1647                 gc.setTimeInMillis(gregorianCutover);
1648                 int v1 = gc.getActualMaximum(field);
1649                 gc.setTimeInMillis(gregorianCutover-1);
1650                 int v2 = gc.getActualMaximum(field);
1651                 return Math.min(LEAST_MAX_VALUES[field], Math.min(v1, v2));
1652             }
1653         }
1654         return LEAST_MAX_VALUES[field];
1655     }
1656 
1657     /**
1658      * Returns the minimum value that this calendar field could have,
1659      * taking into consideration the given time value and the current
1660      * values of the
1661      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1662      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1663      * {@link #getGregorianChange() getGregorianChange} and
1664      * {@link Calendar#getTimeZone() getTimeZone} methods.
1665      *
1666      * &lt;p&gt;For example, if the Gregorian change date is January 10,
<span class="line-modified">1667      * 1970 and the date of this &lt;code&gt;GregorianCalendar&lt;/code&gt; is</span>
1668      * January 20, 1970, the actual minimum value of the
<span class="line-modified">1669      * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field is 10 because the previous date</span>
1670      * of January 10, 1970 is December 27, 1996 (in the Julian
1671      * calendar). Therefore, December 28, 1969 to January 9, 1970
1672      * don&#39;t exist.
1673      *
1674      * @param field the calendar field
1675      * @return the minimum of the given field for the time value of
<span class="line-modified">1676      * this &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
1677      * @see #getMinimum(int)
1678      * @see #getMaximum(int)
1679      * @see #getGreatestMinimum(int)
1680      * @see #getLeastMaximum(int)
1681      * @see #getActualMaximum(int)
1682      * @since 1.2
1683      */
1684     @Override
1685     public int getActualMinimum(int field) {
1686         if (field == DAY_OF_MONTH) {
1687             GregorianCalendar gc = getNormalizedCalendar();
1688             int year = gc.cdate.getNormalizedYear();
1689             if (year == gregorianCutoverYear || year == gregorianCutoverYearJulian) {
1690                 long month1 = getFixedDateMonth1(gc.cdate, gc.calsys.getFixedDate(gc.cdate));
1691                 BaseCalendar.Date d = getCalendarDate(month1);
1692                 return d.getDayOfMonth();
1693             }
1694         }
1695         return getMinimum(field);
1696     }
1697 
1698     /**
1699      * Returns the maximum value that this calendar field could have,
1700      * taking into consideration the given time value and the current
1701      * values of the
1702      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1703      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1704      * {@link #getGregorianChange() getGregorianChange} and
1705      * {@link Calendar#getTimeZone() getTimeZone} methods.
1706      * For example, if the date of this instance is February 1, 2004,
<span class="line-modified">1707      * the actual maximum value of the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field</span>
1708      * is 29 because 2004 is a leap year, and if the date of this
1709      * instance is February 1, 2005, it&#39;s 28.
1710      *
1711      * &lt;p&gt;This method calculates the maximum value of {@link
1712      * Calendar#WEEK_OF_YEAR WEEK_OF_YEAR} based on the {@link
1713      * Calendar#YEAR YEAR} (calendar year) value, not the &lt;a
1714      * href=&quot;#week_year&quot;&gt;week year&lt;/a&gt;. Call {@link
1715      * #getWeeksInWeekYear()} to get the maximum value of {@code
1716      * WEEK_OF_YEAR} in the week year of this {@code GregorianCalendar}.
1717      *
1718      * @param field the calendar field
1719      * @return the maximum of the given field for the time value of
<span class="line-modified">1720      * this &lt;code&gt;GregorianCalendar&lt;/code&gt;</span>
1721      * @see #getMinimum(int)
1722      * @see #getMaximum(int)
1723      * @see #getGreatestMinimum(int)
1724      * @see #getLeastMaximum(int)
1725      * @see #getActualMinimum(int)
1726      * @since 1.2
1727      */
1728     @Override
1729     public int getActualMaximum(int field) {
1730         final int fieldsForFixedMax = ERA_MASK|DAY_OF_WEEK_MASK|HOUR_MASK|AM_PM_MASK|
1731             HOUR_OF_DAY_MASK|MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK|
1732             ZONE_OFFSET_MASK|DST_OFFSET_MASK;
1733         if ((fieldsForFixedMax &amp; (1&lt;&lt;field)) != 0) {
1734             return getMaximum(field);
1735         }
1736 
1737         GregorianCalendar gc = getNormalizedCalendar();
1738         BaseCalendar.Date date = gc.cdate;
1739         BaseCalendar cal = gc.calsys;
1740         int normalizedYear = date.getNormalizedYear();
</pre>
<hr />
<pre>
2165      * the ISO 8601 standard, and that the {@code weekOfYear}
2166      * numbering is compatible with the standard when {@code
2167      * getFirstDayOfWeek()} is {@code MONDAY} and {@code
2168      * getMinimalDaysInFirstWeek()} is 4.
2169      *
2170      * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
2171      * and the instant of time value are calculated upon return.
2172      *
2173      * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year
2174      * range in {@code weekYear}, the {@code weekYear}
2175      * and {@code weekOfYear} values are adjusted in lenient
2176      * mode, or an {@code IllegalArgumentException} is thrown in
2177      * non-lenient mode.
2178      *
2179      * @param weekYear    the week year
2180      * @param weekOfYear  the week number based on {@code weekYear}
2181      * @param dayOfWeek   the day of week value: one of the constants
2182      *                    for the {@link #DAY_OF_WEEK DAY_OF_WEEK} field:
2183      *                    {@link Calendar#SUNDAY SUNDAY}, ...,
2184      *                    {@link Calendar#SATURDAY SATURDAY}.
<span class="line-modified">2185      * @exception IllegalArgumentException</span>
2186      *            if any of the given date specifiers is invalid,
2187      *            or if any of the calendar fields are inconsistent
2188      *            with the given date specifiers in non-lenient mode
2189      * @see GregorianCalendar#isWeekDateSupported()
2190      * @see Calendar#getFirstDayOfWeek()
2191      * @see Calendar#getMinimalDaysInFirstWeek()
2192      * @since 1.7
2193      */
2194     @Override
2195     public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
2196         if (dayOfWeek &lt; SUNDAY || dayOfWeek &gt; SATURDAY) {
2197             throw new IllegalArgumentException(&quot;invalid dayOfWeek: &quot; + dayOfWeek);
2198         }
2199 
2200         // To avoid changing the time of day fields by date
2201         // calculations, use a clone with the GMT time zone.
2202         GregorianCalendar gc = (GregorianCalendar) clone();
2203         gc.setLenient(true);
2204         int era = gc.get(ERA);
2205         gc.clear();
</pre>
<hr />
<pre>
2269         gc.setWeekDate(weekYear, 2, internalGet(DAY_OF_WEEK));
2270         return gc.getActualMaximum(WEEK_OF_YEAR);
2271     }
2272 
2273 /////////////////////////////
2274 // Time =&gt; Fields computation
2275 /////////////////////////////
2276 
2277     /**
2278      * The fixed date corresponding to gdate. If the value is
2279      * Long.MIN_VALUE, the fixed date value is unknown. Currently,
2280      * Julian calendar dates are not cached.
2281      */
2282     private transient long cachedFixedDate = Long.MIN_VALUE;
2283 
2284     /**
2285      * Converts the time value (millisecond offset from the &lt;a
2286      * href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) to calendar field values.
2287      * The time is &lt;em&gt;not&lt;/em&gt;
2288      * recomputed first; to recompute the time, then the fields, call the
<span class="line-modified">2289      * &lt;code&gt;complete&lt;/code&gt; method.</span>
2290      *
2291      * @see Calendar#complete
2292      */
2293     @Override
2294     protected void computeFields() {
2295         int mask;
2296         if (isPartiallyNormalized()) {
2297             // Determine which calendar fields need to be computed.
2298             mask = getSetStateFields();
2299             int fieldMask = ~mask &amp; ALL_FIELDS;
2300             // We have to call computTime in case calsys == null in
2301             // order to set calsys and cdate. (6263644)
2302             if (fieldMask != 0 || calsys == null) {
2303                 mask |= computeFields(fieldMask,
2304                                       mask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK));
2305                 assert mask == ALL_FIELDS;
2306             }
2307         } else {
2308             mask = ALL_FIELDS;
2309             computeFields(mask, 0);
</pre>
<hr />
<pre>
2608         // We can always use `gcal&#39; since Julian and Gregorian are the
2609         // same thing for this calculation.
2610         long fixedDay1st = Gregorian.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,
2611                                                                 getFirstDayOfWeek());
2612         int ndays = (int)(fixedDay1st - fixedDay1);
2613         assert ndays &lt;= 7;
2614         if (ndays &gt;= getMinimalDaysInFirstWeek()) {
2615             fixedDay1st -= 7;
2616         }
2617         int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);
2618         if (normalizedDayOfPeriod &gt;= 0) {
2619             return normalizedDayOfPeriod / 7 + 1;
2620         }
2621         return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;
2622     }
2623 
2624     /**
2625      * Converts calendar field values to the time value (millisecond
2626      * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
2627      *
<span class="line-modified">2628      * @exception IllegalArgumentException if any calendar fields are invalid.</span>
2629      */
2630     @Override
2631     protected void computeTime() {
2632         // In non-lenient mode, perform brief checking of calendar
2633         // fields which have been set externally. Through this
2634         // checking, the field values are stored in originalFields[]
2635         // to see if any of them are normalized later.
2636         if (!isLenient()) {
2637             if (originalFields == null) {
2638                 originalFields = new int[FIELD_COUNT];
2639             }
2640             for (int field = 0; field &lt; FIELD_COUNT; field++) {
2641                 int value = internalGet(field);
2642                 if (isExternallySet(field)) {
2643                     // Quick validation for any out of range values
2644                     if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {
2645                         throw new IllegalArgumentException(getFieldName(field));
2646                     }
2647                 }
2648                 originalFields[field] = value;
</pre>
<hr />
<pre>
3212         if (n &gt; max) {
3213             n -= range;
3214         } else if (n &lt; min) {
3215             n += range;
3216         }
3217         assert n &gt;= min &amp;&amp; n &lt;= max;
3218         return n;
3219     }
3220 
3221     /**
3222      * Returns the ERA.  We need a special method for this because the
3223      * default ERA is CE, but a zero (unset) ERA is BCE.
3224      */
3225     private int internalGetEra() {
3226         return isSet(ERA) ? internalGet(ERA) : CE;
3227     }
3228 
3229     /**
3230      * Updates internal state.
3231      */

3232     private void readObject(ObjectInputStream stream)
3233             throws IOException, ClassNotFoundException {
3234         stream.defaultReadObject();
3235         if (gdate == null) {
3236             gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
3237             cachedFixedDate = Long.MIN_VALUE;
3238         }
3239         setGregorianChange(gregorianCutover);
3240     }
3241 
3242     /**
3243      * Converts this object to a {@code ZonedDateTime} that represents
3244      * the same point on the time-line as this {@code GregorianCalendar}.
3245      * &lt;p&gt;
3246      * Since this object supports a Julian-Gregorian cutover date and
3247      * {@code ZonedDateTime} does not, it is possible that the resulting year,
3248      * month and day will have different values.  The result will represent the
3249      * correct date in the ISO calendar system, which will also be the same value
3250      * for Modified Julian Days.
3251      *
</pre>
<hr />
<pre>
3260 
3261     /**
3262      * Obtains an instance of {@code GregorianCalendar} with the default locale
3263      * from a {@code ZonedDateTime} object.
3264      * &lt;p&gt;
3265      * Since {@code ZonedDateTime} does not support a Julian-Gregorian cutover
3266      * date and uses ISO calendar system, the return GregorianCalendar is a pure
3267      * Gregorian calendar and uses ISO 8601 standard for week definitions,
3268      * which has {@code MONDAY} as the {@link Calendar#getFirstDayOfWeek()
3269      * FirstDayOfWeek} and {@code 4} as the value of the
3270      * {@link Calendar#getMinimalDaysInFirstWeek() MinimalDaysInFirstWeek}.
3271      * &lt;p&gt;
3272      * {@code ZoneDateTime} can store points on the time-line further in the
3273      * future and further in the past than {@code GregorianCalendar}. In this
3274      * scenario, this method will throw an {@code IllegalArgumentException}
3275      * exception.
3276      *
3277      * @param zdt  the zoned date-time object to convert
3278      * @return  the gregorian calendar representing the same point on the
3279      *  time-line as the zoned date-time provided
<span class="line-modified">3280      * @exception NullPointerException if {@code zdt} is null</span>
<span class="line-modified">3281      * @exception IllegalArgumentException if the zoned date-time is too</span>
3282      * large to represent as a {@code GregorianCalendar}
3283      * @since 1.8
3284      */
3285     public static GregorianCalendar from(ZonedDateTime zdt) {
3286         GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(zdt.getZone()));
3287         cal.setGregorianChange(new Date(Long.MIN_VALUE));
3288         cal.setFirstDayOfWeek(MONDAY);
3289         cal.setMinimalDaysInFirstWeek(4);
3290         try {
3291             cal.setTimeInMillis(Math.addExact(Math.multiplyExact(zdt.toEpochSecond(), 1000),
3292                                               zdt.get(ChronoField.MILLI_OF_SECOND)));
3293         } catch (ArithmeticException ex) {
3294             throw new IllegalArgumentException(ex);
3295         }
3296         return cal;
3297     }
3298 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  36  *
  37  */
  38 
  39 package java.util;
  40 
  41 import java.io.IOException;
  42 import java.io.ObjectInputStream;
  43 import java.time.Instant;
  44 import java.time.ZonedDateTime;
  45 import java.time.temporal.ChronoField;
  46 import sun.util.calendar.BaseCalendar;
  47 import sun.util.calendar.CalendarDate;
  48 import sun.util.calendar.CalendarSystem;
  49 import sun.util.calendar.CalendarUtils;
  50 import sun.util.calendar.Era;
  51 import sun.util.calendar.Gregorian;
  52 import sun.util.calendar.JulianCalendar;
  53 import sun.util.calendar.ZoneInfo;
  54 
  55 /**
<span class="line-modified">  56  * {@code GregorianCalendar} is a concrete subclass of</span>
<span class="line-modified">  57  * {@code Calendar} and provides the standard calendar system</span>
  58  * used by most of the world.
  59  *
<span class="line-modified">  60  * &lt;p&gt; {@code GregorianCalendar} is a hybrid calendar that</span>
  61  * supports both the Julian and Gregorian calendar systems with the
  62  * support of a single discontinuity, which corresponds by default to
  63  * the Gregorian date when the Gregorian calendar was instituted
  64  * (October 15, 1582 in some countries, later in others).  The cutover
  65  * date may be changed by the caller by calling {@link
  66  * #setGregorianChange(Date) setGregorianChange()}.
  67  *
  68  * &lt;p&gt;
  69  * Historically, in those countries which adopted the Gregorian calendar first,
  70  * October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
<span class="line-modified">  71  * this correctly.  Before the Gregorian cutover, {@code GregorianCalendar}</span>
  72  * implements the Julian calendar.  The only difference between the Gregorian
  73  * and the Julian calendar is the leap year rule. The Julian calendar specifies
  74  * leap years every four years, whereas the Gregorian calendar omits century
  75  * years which are not divisible by 400.
  76  *
  77  * &lt;p&gt;
<span class="line-modified">  78  * {@code GregorianCalendar} implements &lt;em&gt;proleptic&lt;/em&gt; Gregorian and</span>
  79  * Julian calendars. That is, dates are computed by extrapolating the current
  80  * rules indefinitely far backward and forward in time. As a result,
<span class="line-modified">  81  * {@code GregorianCalendar} may be used for all years to generate</span>
  82  * meaningful and consistent results. However, dates obtained using
<span class="line-modified">  83  * {@code GregorianCalendar} are historically accurate only from March 1, 4</span>
  84  * AD onward, when modern Julian calendar rules were adopted.  Before this date,
  85  * leap year rules were applied irregularly, and before 45 BC the Julian
  86  * calendar did not even exist.
  87  *
  88  * &lt;p&gt;
  89  * Prior to the institution of the Gregorian calendar, New Year&#39;s Day was
  90  * March 25. To avoid confusion, this calendar always uses January 1. A manual
  91  * adjustment may be made if desired for dates that are prior to the Gregorian
  92  * changeover and which fall between January 1 and March 24.
  93  *
<span class="line-modified">  94  * &lt;h2&gt;&lt;a id=&quot;week_and_year&quot;&gt;Week Of Year and Week Year&lt;/a&gt;&lt;/h2&gt;</span>
  95  *
  96  * &lt;p&gt;Values calculated for the {@link Calendar#WEEK_OF_YEAR
  97  * WEEK_OF_YEAR} field range from 1 to 53. The first week of a
  98  * calendar year is the earliest seven day period starting on {@link
  99  * Calendar#getFirstDayOfWeek() getFirstDayOfWeek()} that contains at
 100  * least {@link Calendar#getMinimalDaysInFirstWeek()
 101  * getMinimalDaysInFirstWeek()} days from that year. It thus depends
 102  * on the values of {@code getMinimalDaysInFirstWeek()}, {@code
 103  * getFirstDayOfWeek()}, and the day of the week of January 1. Weeks
 104  * between week 1 of one year and week 1 of the following year
 105  * (exclusive) are numbered sequentially from 2 to 52 or 53 (except
 106  * for year(s) involved in the Julian-Gregorian transition).
 107  *
 108  * &lt;p&gt;The {@code getFirstDayOfWeek()} and {@code
 109  * getMinimalDaysInFirstWeek()} values are initialized using
 110  * locale-dependent resources when constructing a {@code
 111  * GregorianCalendar}. &lt;a id=&quot;iso8601_compatible_setting&quot;&gt;The week
 112  * determination is compatible&lt;/a&gt; with the ISO 8601 standard when {@code
 113  * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 114  * getMinimalDaysInFirstWeek()} is 4, which values are used in locales
</pre>
<hr />
<pre>
 116  * calling {@link Calendar#setFirstDayOfWeek(int) setFirstDayOfWeek()} and
 117  * {@link Calendar#setMinimalDaysInFirstWeek(int)
 118  * setMinimalDaysInFirstWeek()}.
 119  *
 120  * &lt;p&gt;A &lt;a id=&quot;week_year&quot;&gt;&lt;em&gt;week year&lt;/em&gt;&lt;/a&gt; is in sync with a
 121  * {@code WEEK_OF_YEAR} cycle. All weeks between the first and last
 122  * weeks (inclusive) have the same &lt;em&gt;week year&lt;/em&gt; value.
 123  * Therefore, the first and last days of a week year may have
 124  * different calendar year values.
 125  *
 126  * &lt;p&gt;For example, January 1, 1998 is a Thursday. If {@code
 127  * getFirstDayOfWeek()} is {@code MONDAY} and {@code
 128  * getMinimalDaysInFirstWeek()} is 4 (ISO 8601 standard compatible
 129  * setting), then week 1 of 1998 starts on December 29, 1997, and ends
 130  * on January 4, 1998. The week year is 1998 for the last three days
 131  * of calendar year 1997. If, however, {@code getFirstDayOfWeek()} is
 132  * {@code SUNDAY}, then week 1 of 1998 starts on January 4, 1998, and
 133  * ends on January 10, 1998; the first three days of 1998 then are
 134  * part of week 53 of 1997 and their week year is 1997.
 135  *
<span class="line-modified"> 136  * &lt;h3&gt;Week Of Month&lt;/h3&gt;</span>
 137  *
<span class="line-modified"> 138  * &lt;p&gt;Values calculated for the {@code WEEK_OF_MONTH} field range from 0</span>
 139  * to 6.  Week 1 of a month (the days with &lt;code&gt;WEEK_OF_MONTH =
 140  * 1&lt;/code&gt;) is the earliest set of at least
<span class="line-modified"> 141  * {@code getMinimalDaysInFirstWeek()} contiguous days in that month,</span>
<span class="line-modified"> 142  * ending on the day before {@code getFirstDayOfWeek()}.  Unlike</span>
 143  * week 1 of a year, week 1 of a month may be shorter than 7 days, need
<span class="line-modified"> 144  * not start on {@code getFirstDayOfWeek()}, and will not include days of</span>
 145  * the previous month.  Days of a month before week 1 have a
<span class="line-modified"> 146  * {@code WEEK_OF_MONTH} of 0.</span>
 147  *
<span class="line-modified"> 148  * &lt;p&gt;For example, if {@code getFirstDayOfWeek()} is {@code SUNDAY}</span>
<span class="line-modified"> 149  * and {@code getMinimalDaysInFirstWeek()} is 4, then the first week of</span>
 150  * January 1998 is Sunday, January 4 through Saturday, January 10.  These days
<span class="line-modified"> 151  * have a {@code WEEK_OF_MONTH} of 1.  Thursday, January 1 through</span>
<span class="line-modified"> 152  * Saturday, January 3 have a {@code WEEK_OF_MONTH} of 0.  If</span>
<span class="line-modified"> 153  * {@code getMinimalDaysInFirstWeek()} is changed to 3, then January 1</span>
<span class="line-modified"> 154  * through January 3 have a {@code WEEK_OF_MONTH} of 1.</span>
 155  *
<span class="line-modified"> 156  * &lt;h3&gt;Default Fields Values&lt;/h3&gt;</span>
 157  *
<span class="line-modified"> 158  * &lt;p&gt;The {@code clear} method sets calendar field(s)</span>
<span class="line-modified"> 159  * undefined. {@code GregorianCalendar} uses the following</span>
 160  * default value for each calendar field if its value is undefined.
 161  *
 162  * &lt;table class=&quot;striped&quot; style=&quot;text-align: left; width: 66%;&quot;&gt;
 163  * &lt;caption style=&quot;display:none&quot;&gt;GregorianCalendar default field values&lt;/caption&gt;
 164  *   &lt;thead&gt;
 165  *     &lt;tr&gt;
 166  *       &lt;th scope=&quot;col&quot;&gt;
 167  *          Field
 168  *       &lt;/th&gt;
 169  *       &lt;th scope=&quot;col&quot;&gt;
 170             Default Value
 171  *       &lt;/th&gt;
 172  *     &lt;/tr&gt;
 173  *   &lt;/thead&gt;
 174  *   &lt;tbody&gt;
 175  *     &lt;tr&gt;
 176  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 177  *              {@code ERA}</span>
 178  *       &lt;/th&gt;
 179  *       &lt;td&gt;
<span class="line-modified"> 180  *              {@code AD}</span>
 181  *       &lt;/td&gt;
 182  *     &lt;/tr&gt;
 183  *     &lt;tr&gt;
 184  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 185  *              {@code YEAR}</span>
 186  *       &lt;/th&gt;
 187  *       &lt;td&gt;
<span class="line-modified"> 188  *              {@code 1970}</span>
 189  *       &lt;/td&gt;
 190  *     &lt;/tr&gt;
 191  *     &lt;tr&gt;
 192  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 193  *              {@code MONTH}</span>
 194  *       &lt;/th&gt;
 195  *       &lt;td&gt;
<span class="line-modified"> 196  *              {@code JANUARY}</span>
 197  *       &lt;/td&gt;
 198  *     &lt;/tr&gt;
 199  *     &lt;tr&gt;
 200  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 201  *              {@code DAY_OF_MONTH}</span>
 202  *       &lt;/th&gt;
 203  *       &lt;td&gt;
<span class="line-modified"> 204  *              {@code 1}</span>
 205  *       &lt;/td&gt;
 206  *     &lt;/tr&gt;
 207  *     &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 209  *              {@code DAY_OF_WEEK}</span>
 210  *       &lt;/th&gt;
 211  *       &lt;td&gt;
<span class="line-modified"> 212  *              {@code the first day of week}</span>
 213  *       &lt;/td&gt;
 214  *     &lt;/tr&gt;
 215  *     &lt;tr&gt;
 216  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 217  *              {@code WEEK_OF_MONTH}</span>
 218  *       &lt;/th&gt;
 219  *       &lt;td&gt;
<span class="line-modified"> 220  *              {@code 0}</span>
 221  *       &lt;/td&gt;
 222  *     &lt;/tr&gt;
 223  *     &lt;tr&gt;
 224  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 225  *              {@code DAY_OF_WEEK_IN_MONTH}</span>
 226  *       &lt;/th&gt;
 227  *       &lt;td&gt;
<span class="line-modified"> 228  *              {@code 1}</span>
 229  *       &lt;/td&gt;
 230  *     &lt;/tr&gt;
 231  *     &lt;tr&gt;
 232  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 233  *              {@code AM_PM}</span>
 234  *       &lt;/th&gt;
 235  *       &lt;td&gt;
<span class="line-modified"> 236  *              {@code AM}</span>
 237  *       &lt;/td&gt;
 238  *     &lt;/tr&gt;
 239  *     &lt;tr&gt;
 240  *       &lt;th scope=&quot;row&quot;&gt;
<span class="line-modified"> 241  *              {@code HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND}</span>
 242  *       &lt;/th&gt;
 243  *       &lt;td&gt;
<span class="line-modified"> 244  *              {@code 0}</span>
 245  *       &lt;/td&gt;
 246  *     &lt;/tr&gt;
 247  *   &lt;/tbody&gt;
 248  * &lt;/table&gt;
 249  * &lt;br&gt;Default values are not applicable for the fields not listed above.
 250  *
 251  * &lt;p&gt;
 252  * &lt;strong&gt;Example:&lt;/strong&gt;
 253  * &lt;blockquote&gt;
 254  * &lt;pre&gt;
 255  * // get the supported ids for GMT-08:00 (Pacific Standard Time)
 256  * String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
 257  * // if no ids were returned, something is wrong. get out.
 258  * if (ids.length == 0)
 259  *     System.exit(0);
 260  *
 261  *  // begin output
 262  * System.out.println(&quot;Current Time&quot;);
 263  *
 264  * // create a Pacific Standard Time time zone
</pre>
<hr />
<pre>
 343      * implement the modern definition of the calendar even though the
 344      * historical usage differs.  For example, if the Gregorian change is set
 345      * to new Date(Long.MIN_VALUE), we have a pure Gregorian calendar which
 346      * labels dates preceding the invention of the Gregorian calendar in 1582 as
 347      * if the calendar existed then.
 348      *
 349      * Likewise, with the Julian calendar, we assume a consistent
 350      * 4-year leap year rule, even though the historical pattern of
 351      * leap years is irregular, being every 3 years from 45 BCE
 352      * through 9 BCE, then every 4 years from 8 CE onwards, with no
 353      * leap years in-between.  Thus date computations and functions
 354      * such as isLeapYear() are not intended to be historically
 355      * accurate.
 356      */
 357 
 358 //////////////////
 359 // Class Variables
 360 //////////////////
 361 
 362     /**
<span class="line-modified"> 363      * Value of the {@code ERA} field indicating</span>
 364      * the period before the common era (before Christ), also known as BCE.
<span class="line-modified"> 365      * The sequence of years at the transition from {@code BC} to {@code AD} is</span>
 366      * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 367      *
 368      * @see #ERA
 369      */
 370     public static final int BC = 0;
 371 
 372     /**
 373      * Value of the {@link #ERA} field indicating
 374      * the period before the common era, the same value as {@link #BC}.
 375      *
 376      * @see #CE
 377      */
 378     static final int BCE = 0;
 379 
 380     /**
<span class="line-modified"> 381      * Value of the {@code ERA} field indicating</span>
 382      * the common era (Anno Domini), also known as CE.
<span class="line-modified"> 383      * The sequence of years at the transition from {@code BC} to {@code AD} is</span>
 384      * ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 385      *
 386      * @see #ERA
 387      */
 388     public static final int AD = 1;
 389 
 390     /**
 391      * Value of the {@link #ERA} field indicating
 392      * the common era, the same value as {@link #AD}.
 393      *
 394      * @see #BCE
 395      */
 396     static final int CE = 1;
 397 
 398     private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
 399     private static final int EPOCH_YEAR     = 1970;
 400 
 401     static final int MONTH_LENGTH[]
 402         = {31,28,31,30,31,30,31,31,30,31,30,31}; // 0-based
 403     static final int LEAP_MONTH_LENGTH[]
</pre>
<hr />
<pre>
 480         292278994,      // YEAR
 481         DECEMBER,       // MONTH
 482         53,             // WEEK_OF_YEAR
 483         6,              // WEEK_OF_MONTH
 484         31,             // DAY_OF_MONTH
 485         366,            // DAY_OF_YEAR
 486         SATURDAY,       // DAY_OF_WEEK
 487         6,              // DAY_OF_WEEK_IN
 488         PM,             // AM_PM
 489         11,             // HOUR
 490         23,             // HOUR_OF_DAY
 491         59,             // MINUTE
 492         59,             // SECOND
 493         999,            // MILLISECOND
 494         14*ONE_HOUR,    // ZONE_OFFSET
 495         2*ONE_HOUR      // DST_OFFSET (double summer time)
 496     };
 497 
 498     // Proclaim serialization compatibility with JDK 1.1
 499     @SuppressWarnings(&quot;FieldNameHidesFieldInSuperclass&quot;)
<span class="line-added"> 500     @java.io.Serial</span>
 501     static final long serialVersionUID = -8125100834729963327L;
 502 
 503     // Reference to the sun.util.calendar.Gregorian instance (singleton).
 504     private static final Gregorian gcal =
 505                                 CalendarSystem.getGregorianCalendar();
 506 
 507     // Reference to the JulianCalendar instance (singleton), set as needed. See
 508     // getJulianCalendarSystem().
 509     private static JulianCalendar jcal;
 510 
 511     // JulianCalendar eras. See getJulianCalendarSystem().
 512     private static Era[] jeras;
 513 
 514     // The default value of gregorianCutover.
 515     static final long DEFAULT_GREGORIAN_CUTOVER = -12219292800000L;
 516 
 517 /////////////////////
 518 // Instance Variables
 519 /////////////////////
 520 
</pre>
<hr />
<pre>
 568     private transient BaseCalendar calsys;
 569 
 570     /**
 571      * Temporary int[2] to get time zone offsets. zoneOffsets[0] gets
 572      * the GMT offset value and zoneOffsets[1] gets the DST saving
 573      * value.
 574      */
 575     private transient int[] zoneOffsets;
 576 
 577     /**
 578      * Temporary storage for saving original fields[] values in
 579      * non-lenient mode.
 580      */
 581     private transient int[] originalFields;
 582 
 583 ///////////////
 584 // Constructors
 585 ///////////////
 586 
 587     /**
<span class="line-modified"> 588      * Constructs a default {@code GregorianCalendar} using the current time</span>
 589      * in the default time zone with the default
 590      * {@link Locale.Category#FORMAT FORMAT} locale.
 591      */
 592     public GregorianCalendar() {
 593         this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));
 594         setZoneShared(true);
 595     }
 596 
 597     /**
<span class="line-modified"> 598      * Constructs a {@code GregorianCalendar} based on the current time</span>
 599      * in the given time zone with the default
 600      * {@link Locale.Category#FORMAT FORMAT} locale.
 601      *
 602      * @param zone the given time zone.
 603      */
 604     public GregorianCalendar(TimeZone zone) {
 605         this(zone, Locale.getDefault(Locale.Category.FORMAT));
 606     }
 607 
 608     /**
<span class="line-modified"> 609      * Constructs a {@code GregorianCalendar} based on the current time</span>
 610      * in the default time zone with the given locale.
 611      *
 612      * @param aLocale the given locale.
 613      */
 614     public GregorianCalendar(Locale aLocale) {
 615         this(TimeZone.getDefaultRef(), aLocale);
 616         setZoneShared(true);
 617     }
 618 
 619     /**
<span class="line-modified"> 620      * Constructs a {@code GregorianCalendar} based on the current time</span>
 621      * in the given time zone with the given locale.
 622      *
 623      * @param zone the given time zone.
 624      * @param aLocale the given locale.
 625      */
 626     public GregorianCalendar(TimeZone zone, Locale aLocale) {
 627         super(zone, aLocale);
 628         gdate = (BaseCalendar.Date) gcal.newCalendarDate(zone);
 629         setTimeInMillis(System.currentTimeMillis());
 630     }
 631 
 632     /**
<span class="line-modified"> 633      * Constructs a {@code GregorianCalendar} with the given date set</span>
 634      * in the default time zone with the default locale.
 635      *
<span class="line-modified"> 636      * @param year the value used to set the {@code YEAR} calendar field in the calendar.</span>
<span class="line-modified"> 637      * @param month the value used to set the {@code MONTH} calendar field in the calendar.</span>
 638      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 639      * @param dayOfMonth the value used to set the {@code DAY_OF_MONTH} calendar field in the calendar.</span>
 640      */
 641     public GregorianCalendar(int year, int month, int dayOfMonth) {
 642         this(year, month, dayOfMonth, 0, 0, 0, 0);
 643     }
 644 
 645     /**
<span class="line-modified"> 646      * Constructs a {@code GregorianCalendar} with the given date</span>
 647      * and time set for the default time zone with the default locale.
 648      *
<span class="line-modified"> 649      * @param year the value used to set the {@code YEAR} calendar field in the calendar.</span>
<span class="line-modified"> 650      * @param month the value used to set the {@code MONTH} calendar field in the calendar.</span>
 651      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 652      * @param dayOfMonth the value used to set the {@code DAY_OF_MONTH} calendar field in the calendar.</span>
<span class="line-modified"> 653      * @param hourOfDay the value used to set the {@code HOUR_OF_DAY} calendar field</span>
 654      * in the calendar.
<span class="line-modified"> 655      * @param minute the value used to set the {@code MINUTE} calendar field</span>
 656      * in the calendar.
 657      */
 658     public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
 659                              int minute) {
 660         this(year, month, dayOfMonth, hourOfDay, minute, 0, 0);
 661     }
 662 
 663     /**
 664      * Constructs a GregorianCalendar with the given date
 665      * and time set for the default time zone with the default locale.
 666      *
<span class="line-modified"> 667      * @param year the value used to set the {@code YEAR} calendar field in the calendar.</span>
<span class="line-modified"> 668      * @param month the value used to set the {@code MONTH} calendar field in the calendar.</span>
 669      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 670      * @param dayOfMonth the value used to set the {@code DAY_OF_MONTH} calendar field in the calendar.</span>
<span class="line-modified"> 671      * @param hourOfDay the value used to set the {@code HOUR_OF_DAY} calendar field</span>
 672      * in the calendar.
<span class="line-modified"> 673      * @param minute the value used to set the {@code MINUTE} calendar field</span>
 674      * in the calendar.
<span class="line-modified"> 675      * @param second the value used to set the {@code SECOND} calendar field</span>
 676      * in the calendar.
 677      */
 678     public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay,
 679                              int minute, int second) {
 680         this(year, month, dayOfMonth, hourOfDay, minute, second, 0);
 681     }
 682 
 683     /**
<span class="line-modified"> 684      * Constructs a {@code GregorianCalendar} with the given date</span>
 685      * and time set for the default time zone with the default locale.
 686      *
<span class="line-modified"> 687      * @param year the value used to set the {@code YEAR} calendar field in the calendar.</span>
<span class="line-modified"> 688      * @param month the value used to set the {@code MONTH} calendar field in the calendar.</span>
 689      * Month value is 0-based. e.g., 0 for January.
<span class="line-modified"> 690      * @param dayOfMonth the value used to set the {@code DAY_OF_MONTH} calendar field in the calendar.</span>
<span class="line-modified"> 691      * @param hourOfDay the value used to set the {@code HOUR_OF_DAY} calendar field</span>
 692      * in the calendar.
<span class="line-modified"> 693      * @param minute the value used to set the {@code MINUTE} calendar field</span>
 694      * in the calendar.
<span class="line-modified"> 695      * @param second the value used to set the {@code SECOND} calendar field</span>
 696      * in the calendar.
<span class="line-modified"> 697      * @param millis the value used to set the {@code MILLISECOND} calendar field</span>
 698      */
 699     GregorianCalendar(int year, int month, int dayOfMonth,
 700                       int hourOfDay, int minute, int second, int millis) {
 701         super();
 702         gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
 703         this.set(YEAR, year);
 704         this.set(MONTH, month);
 705         this.set(DAY_OF_MONTH, dayOfMonth);
 706 
 707         // Set AM_PM and HOUR here to set their stamp values before
 708         // setting HOUR_OF_DAY (6178071).
 709         if (hourOfDay &gt;= 12 &amp;&amp; hourOfDay &lt;= 23) {
 710             // If hourOfDay is a valid PM hour, set the correct PM values
 711             // so that it won&#39;t throw an exception in case it&#39;s set to
 712             // non-lenient later.
 713             this.internalSet(AM_PM, PM);
 714             this.internalSet(HOUR, hourOfDay - 12);
 715         } else {
 716             // The default value for AM_PM is AM.
 717             // We don&#39;t care any out of range value here for leniency.
</pre>
<hr />
<pre>
 728         this.internalSet(MILLISECOND, millis);
 729     }
 730 
 731     /**
 732      * Constructs an empty GregorianCalendar.
 733      *
 734      * @param zone    the given time zone
 735      * @param aLocale the given locale
 736      * @param flag    the flag requesting an empty instance
 737      */
 738     GregorianCalendar(TimeZone zone, Locale locale, boolean flag) {
 739         super(zone, locale);
 740         gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
 741     }
 742 
 743 /////////////////
 744 // Public methods
 745 /////////////////
 746 
 747     /**
<span class="line-modified"> 748      * Sets the {@code GregorianCalendar} change date. This is the point when the switch</span>
 749      * from Julian dates to Gregorian dates occurred. Default is October 15,
 750      * 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.
 751      * &lt;p&gt;
 752      * To obtain a pure Julian calendar, set the change date to
<span class="line-modified"> 753      * {@code Date(Long.MAX_VALUE)}.  To obtain a pure Gregorian calendar,</span>
<span class="line-modified"> 754      * set the change date to {@code Date(Long.MIN_VALUE)}.</span>
 755      *
 756      * @param date the given Gregorian cutover date.
 757      */
 758     public void setGregorianChange(Date date) {
 759         long cutoverTime = date.getTime();
 760         if (cutoverTime == gregorianCutover) {
 761             return;
 762         }
 763         // Before changing the cutover date, make sure to have the
 764         // time of this calendar.
 765         complete();
 766         setGregorianChange(cutoverTime);
 767     }
 768 
 769     private void setGregorianChange(long cutoverTime) {
 770         gregorianCutover = cutoverTime;
 771         gregorianCutoverDate = CalendarUtils.floorDivide(cutoverTime, ONE_DAY)
 772                                 + EPOCH_OFFSET;
 773 
 774         // To provide the &quot;pure&quot; Julian calendar as advertised.
</pre>
<hr />
<pre>
 786         gregorianCutoverYear = d.getYear();
 787 
 788         BaseCalendar julianCal = getJulianCalendarSystem();
 789         d = (BaseCalendar.Date) julianCal.newCalendarDate(TimeZone.NO_TIMEZONE);
 790         julianCal.getCalendarDateFromFixedDate(d, gregorianCutoverDate - 1);
 791         gregorianCutoverYearJulian = d.getNormalizedYear();
 792 
 793         if (time &lt; gregorianCutover) {
 794             // The field values are no longer valid under the new
 795             // cutover date.
 796             setUnnormalized();
 797         }
 798     }
 799 
 800     /**
 801      * Gets the Gregorian Calendar change date.  This is the point when the
 802      * switch from Julian dates to Gregorian dates occurred. Default is
 803      * October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian
 804      * calendar.
 805      *
<span class="line-modified"> 806      * @return the Gregorian cutover date for this {@code GregorianCalendar} object.</span>
 807      */
 808     public final Date getGregorianChange() {
 809         return new Date(gregorianCutover);
 810     }
 811 
 812     /**
<span class="line-modified"> 813      * Determines if the given year is a leap year. Returns {@code true} if</span>
 814      * the given year is a leap year. To specify BC year numbers,
<span class="line-modified"> 815      * {@code 1 - year number} must be given. For example, year BC 4 is</span>
 816      * specified as -3.
 817      *
 818      * @param year the given year.
<span class="line-modified"> 819      * @return {@code true} if the given year is a leap year; {@code false} otherwise.</span>
 820      */
 821     public boolean isLeapYear(int year) {
 822         if ((year &amp; 3) != 0) {
 823             return false;
 824         }
 825 
 826         if (year &gt; gregorianCutoverYear) {
 827             return (year%100 != 0) || (year%400 == 0); // Gregorian
 828         }
 829         if (year &lt; gregorianCutoverYearJulian) {
 830             return true; // Julian
 831         }
 832         boolean gregorian;
 833         // If the given year is the Gregorian cutover year, we need to
 834         // determine which calendar system to be applied to February in the year.
 835         if (gregorianCutoverYear == gregorianCutoverYearJulian) {
 836             BaseCalendar.Date d = getCalendarDate(gregorianCutoverDate); // Gregorian
 837             gregorian = d.getMonth() &lt; BaseCalendar.MARCH;
 838         } else {
 839             gregorian = year == gregorianCutoverYear;
 840         }
 841         return gregorian ? (year%100 != 0) || (year%400 == 0) : true;
 842     }
 843 
 844     /**
 845      * Returns {@code &quot;gregory&quot;} as the calendar type.
 846      *
 847      * @return {@code &quot;gregory&quot;}
 848      * @since 1.8
 849      */
 850     @Override
 851     public String getCalendarType() {
 852         return &quot;gregory&quot;;
 853     }
 854 
 855     /**
<span class="line-modified"> 856      * Compares this {@code GregorianCalendar} to the specified</span>
<span class="line-modified"> 857      * {@code Object}. The result is {@code true} if and</span>
<span class="line-modified"> 858      * only if the argument is a {@code GregorianCalendar} object</span>
 859      * that represents the same time value (millisecond offset from
 860      * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
<span class="line-modified"> 861      * {@code Calendar} parameters and Gregorian change date as</span>
 862      * this object.
 863      *
 864      * @param obj the object to compare with.
<span class="line-modified"> 865      * @return {@code true} if this object is equal to {@code obj};</span>
<span class="line-modified"> 866      * {@code false} otherwise.</span>
 867      * @see Calendar#compareTo(Calendar)
 868      */
 869     @Override
 870     public boolean equals(Object obj) {
 871         return obj instanceof GregorianCalendar &amp;&amp;
 872             super.equals(obj) &amp;&amp;
 873             gregorianCutover == ((GregorianCalendar)obj).gregorianCutover;
 874     }
 875 
 876     /**
<span class="line-modified"> 877      * Generates the hash code for this {@code GregorianCalendar} object.</span>
 878      */
 879     @Override
 880     public int hashCode() {
 881         return super.hashCode() ^ (int)gregorianCutoverDate;
 882     }
 883 
 884     /**
 885      * Adds the specified (signed) amount of time to the given calendar field,
 886      * based on the calendar&#39;s rules.
 887      *
<span class="line-modified"> 888      * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of {@code field}</span>
<span class="line-modified"> 889      * after the call minus the value of {@code field} before the</span>
<span class="line-modified"> 890      * call is {@code amount}, modulo any overflow that has occurred in</span>
<span class="line-modified"> 891      * {@code field}. Overflow occurs when a field value exceeds its</span>
 892      * range and, as a result, the next larger field is incremented or
 893      * decremented and the field value is adjusted back into its range.&lt;/p&gt;
 894      *
 895      * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
 896      * invariant, but it is impossible for it to be equal to its
 897      * prior value because of changes in its minimum or maximum after
<span class="line-modified"> 898      * {@code field} is changed, then its value is adjusted to be as close</span>
 899      * as possible to its expected value. A smaller field represents a
<span class="line-modified"> 900      * smaller unit of time. {@code HOUR} is a smaller field than</span>
<span class="line-modified"> 901      * {@code DAY_OF_MONTH}. No adjustment is made to smaller fields</span>
 902      * that are not expected to be invariant. The calendar system
 903      * determines what fields are expected to be invariant.&lt;/p&gt;
 904      *
 905      * @param field the calendar field.
 906      * @param amount the amount of date or time to be added to the field.
<span class="line-modified"> 907      * @throws    IllegalArgumentException if {@code field} is</span>
<span class="line-modified"> 908      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,</span>
 909      * or if any calendar fields have out-of-range values in
 910      * non-lenient mode.
 911      */
 912     @Override
 913     public void add(int field, int amount) {
 914         // If amount == 0, do nothing even the given field is out of
 915         // range. This is tested by JCK.
 916         if (amount == 0) {
 917             return;   // Do nothing!
 918         }
 919 
 920         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 921             throw new IllegalArgumentException();
 922         }
 923 
 924         // Sync the time and calendar fields.
 925         complete();
 926 
 927         if (field == YEAR) {
 928             int year = internalGet(YEAR);
</pre>
<hr />
<pre>
1077             int zoneOffset = internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);
1078             setTimeInMillis((fd - EPOCH_OFFSET) * ONE_DAY + timeOfDay - zoneOffset);
1079             zoneOffset -= internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET);
1080             // If the time zone offset has changed, then adjust the difference.
1081             if (zoneOffset != 0) {
1082                 setTimeInMillis(time + zoneOffset);
1083                 long fd2 = getCurrentFixedDate();
1084                 // If the adjustment has changed the date, then take
1085                 // the previous one.
1086                 if (fd2 != fd) {
1087                     setTimeInMillis(time - zoneOffset);
1088                 }
1089             }
1090         }
1091     }
1092 
1093     /**
1094      * Adds or subtracts (up/down) a single unit of time on the given time
1095      * field without changing larger fields.
1096      * &lt;p&gt;
<span class="line-modified">1097      * &lt;em&gt;Example&lt;/em&gt;: Consider a {@code GregorianCalendar}</span>
1098      * originally set to December 31, 1999. Calling {@link #roll(int,boolean) roll(Calendar.MONTH, true)}
<span class="line-modified">1099      * sets the calendar to January 31, 1999.  The {@code YEAR} field is unchanged</span>
<span class="line-modified">1100      * because it is a larger field than {@code MONTH}.&lt;/p&gt;</span>
1101      *
1102      * @param up indicates if the value of the specified calendar field is to be
<span class="line-modified">1103      * rolled up or rolled down. Use {@code true} if rolling up, {@code false} otherwise.</span>
<span class="line-modified">1104      * @throws    IllegalArgumentException if {@code field} is</span>
<span class="line-modified">1105      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,</span>
1106      * or if any calendar fields have out-of-range values in
1107      * non-lenient mode.
1108      * @see #add(int,int)
1109      * @see #set(int,int)
1110      */
1111     @Override
1112     public void roll(int field, boolean up) {
1113         roll(field, up ? +1 : -1);
1114     }
1115 
1116     /**
1117      * Adds a signed amount to the specified calendar field without changing larger fields.
1118      * A negative roll amount means to subtract from field without changing
1119      * larger fields. If the specified amount is 0, this method performs nothing.
1120      *
1121      * &lt;p&gt;This method calls {@link #complete()} before adding the
1122      * amount so that all the calendar fields are normalized. If there
1123      * is any calendar field having an out-of-range value in non-lenient mode, then an
<span class="line-modified">1124      * {@code IllegalArgumentException} is thrown.</span>
1125      *
1126      * &lt;p&gt;
<span class="line-modified">1127      * &lt;em&gt;Example&lt;/em&gt;: Consider a {@code GregorianCalendar}</span>
1128      * originally set to August 31, 1999. Calling &lt;code&gt;roll(Calendar.MONTH,
1129      * 8)&lt;/code&gt; sets the calendar to April 30, &lt;strong&gt;1999&lt;/strong&gt;. Using a
<span class="line-modified">1130      * {@code GregorianCalendar}, the {@code DAY_OF_MONTH} field cannot</span>
<span class="line-modified">1131      * be 31 in the month April. {@code DAY_OF_MONTH} is set to the closest possible</span>
<span class="line-modified">1132      * value, 30. The {@code YEAR} field maintains the value of 1999 because it</span>
<span class="line-modified">1133      * is a larger field than {@code MONTH}.</span>
1134      * &lt;p&gt;
<span class="line-modified">1135      * &lt;em&gt;Example&lt;/em&gt;: Consider a {@code GregorianCalendar}</span>
1136      * originally set to Sunday June 6, 1999. Calling
<span class="line-modified">1137      * {@code roll(Calendar.WEEK_OF_MONTH, -1)} sets the calendar to</span>
1138      * Tuesday June 1, 1999, whereas calling
<span class="line-modified">1139      * {@code add(Calendar.WEEK_OF_MONTH, -1)} sets the calendar to</span>
1140      * Sunday May 30, 1999. This is because the roll rule imposes an
<span class="line-modified">1141      * additional constraint: The {@code MONTH} must not change when the</span>
<span class="line-modified">1142      * {@code WEEK_OF_MONTH} is rolled. Taken together with add rule 1,</span>
1143      * the resultant date must be between Tuesday June 1 and Saturday June
<span class="line-modified">1144      * 5. According to add rule 2, the {@code DAY_OF_WEEK}, an invariant</span>
<span class="line-modified">1145      * when changing the {@code WEEK_OF_MONTH}, is set to Tuesday, the</span>
1146      * closest possible value to Sunday (where Sunday is the first day of the
1147      * week).&lt;/p&gt;
1148      *
1149      * @param field the calendar field.
<span class="line-modified">1150      * @param amount the signed amount to add to {@code field}.</span>
<span class="line-modified">1151      * @throws    IllegalArgumentException if {@code field} is</span>
<span class="line-modified">1152      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,</span>
1153      * or if any calendar fields have out-of-range values in
1154      * non-lenient mode.
1155      * @see #roll(int,boolean)
1156      * @see #add(int,int)
1157      * @see #set(int,int)
1158      * @since 1.2
1159      */
1160     @Override
1161     public void roll(int field, int amount) {
1162         // If amount == 0, do nothing even the given field is out of
1163         // range. This is tested by JCK.
1164         if (amount == 0) {
1165             return;
1166         }
1167 
1168         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
1169             throw new IllegalArgumentException();
1170         }
1171 
1172         // Sync the time and calendar fields.
</pre>
<hr />
<pre>
1495                 max = monthLength / 7;
1496                 int x = (int)(fd - month1) % 7;
1497                 if (x &lt; lastDays) {
1498                     max++;
1499                 }
1500                 int value = getRolledValue(internalGet(field), amount, min, max) - 1;
1501                 fd = month1 + value * 7 + x;
1502                 BaseCalendar cal = (fd &gt;= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();
1503                 BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);
1504                 cal.getCalendarDateFromFixedDate(d, fd);
1505                 set(DAY_OF_MONTH, d.getDayOfMonth());
1506                 return;
1507             }
1508         }
1509 
1510         set(field, getRolledValue(internalGet(field), amount, min, max));
1511     }
1512 
1513     /**
1514      * Returns the minimum value for the given calendar field of this
<span class="line-modified">1515      * {@code GregorianCalendar} instance. The minimum value is</span>
1516      * defined as the smallest value returned by the {@link
1517      * Calendar#get(int) get} method for any possible time value,
1518      * taking into consideration the current values of the
1519      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1520      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1521      * {@link #getGregorianChange() getGregorianChange} and
1522      * {@link Calendar#getTimeZone() getTimeZone} methods.
1523      *
1524      * @param field the calendar field.
1525      * @return the minimum value for the given calendar field.
1526      * @see #getMaximum(int)
1527      * @see #getGreatestMinimum(int)
1528      * @see #getLeastMaximum(int)
1529      * @see #getActualMinimum(int)
1530      * @see #getActualMaximum(int)
1531      */
1532     @Override
1533     public int getMinimum(int field) {
1534         return MIN_VALUES[field];
1535     }
1536 
1537     /**
1538      * Returns the maximum value for the given calendar field of this
<span class="line-modified">1539      * {@code GregorianCalendar} instance. The maximum value is</span>
1540      * defined as the largest value returned by the {@link
1541      * Calendar#get(int) get} method for any possible time value,
1542      * taking into consideration the current values of the
1543      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1544      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1545      * {@link #getGregorianChange() getGregorianChange} and
1546      * {@link Calendar#getTimeZone() getTimeZone} methods.
1547      *
1548      * @param field the calendar field.
1549      * @return the maximum value for the given calendar field.
1550      * @see #getMinimum(int)
1551      * @see #getGreatestMinimum(int)
1552      * @see #getLeastMaximum(int)
1553      * @see #getActualMinimum(int)
1554      * @see #getActualMaximum(int)
1555      */
1556     @Override
1557     public int getMaximum(int field) {
1558         switch (field) {
1559         case MONTH:
</pre>
<hr />
<pre>
1568                 // calendar dates are the same or Gregorian dates are
1569                 // larger (i.e., there is a &quot;gap&quot;) after 300-3-1.
1570                 if (gregorianCutoverYear &gt; 200) {
1571                     break;
1572                 }
1573                 // There might be &quot;overlapping&quot; dates.
1574                 GregorianCalendar gc = (GregorianCalendar) clone();
1575                 gc.setLenient(true);
1576                 gc.setTimeInMillis(gregorianCutover);
1577                 int v1 = gc.getActualMaximum(field);
1578                 gc.setTimeInMillis(gregorianCutover-1);
1579                 int v2 = gc.getActualMaximum(field);
1580                 return Math.max(MAX_VALUES[field], Math.max(v1, v2));
1581             }
1582         }
1583         return MAX_VALUES[field];
1584     }
1585 
1586     /**
1587      * Returns the highest minimum value for the given calendar field
<span class="line-modified">1588      * of this {@code GregorianCalendar} instance. The highest</span>
1589      * minimum value is defined as the largest value returned by
1590      * {@link #getActualMinimum(int)} for any possible time value,
1591      * taking into consideration the current values of the
1592      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1593      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1594      * {@link #getGregorianChange() getGregorianChange} and
1595      * {@link Calendar#getTimeZone() getTimeZone} methods.
1596      *
1597      * @param field the calendar field.
1598      * @return the highest minimum value for the given calendar field.
1599      * @see #getMinimum(int)
1600      * @see #getMaximum(int)
1601      * @see #getLeastMaximum(int)
1602      * @see #getActualMinimum(int)
1603      * @see #getActualMaximum(int)
1604      */
1605     @Override
1606     public int getGreatestMinimum(int field) {
1607         if (field == DAY_OF_MONTH) {
1608             BaseCalendar.Date d = getGregorianCutoverDate();
1609             long mon1 = getFixedDateMonth1(d, gregorianCutoverDate);
1610             d = getCalendarDate(mon1);
1611             return Math.max(MIN_VALUES[field], d.getDayOfMonth());
1612         }
1613         return MIN_VALUES[field];
1614     }
1615 
1616     /**
1617      * Returns the lowest maximum value for the given calendar field
<span class="line-modified">1618      * of this {@code GregorianCalendar} instance. The lowest</span>
1619      * maximum value is defined as the smallest value returned by
1620      * {@link #getActualMaximum(int)} for any possible time value,
1621      * taking into consideration the current values of the
1622      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1623      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1624      * {@link #getGregorianChange() getGregorianChange} and
1625      * {@link Calendar#getTimeZone() getTimeZone} methods.
1626      *
1627      * @param field the calendar field
1628      * @return the lowest maximum value for the given calendar field.
1629      * @see #getMinimum(int)
1630      * @see #getMaximum(int)
1631      * @see #getGreatestMinimum(int)
1632      * @see #getActualMinimum(int)
1633      * @see #getActualMaximum(int)
1634      */
1635     @Override
1636     public int getLeastMaximum(int field) {
1637         switch (field) {
1638         case MONTH:
</pre>
<hr />
<pre>
1648                 gc.setTimeInMillis(gregorianCutover);
1649                 int v1 = gc.getActualMaximum(field);
1650                 gc.setTimeInMillis(gregorianCutover-1);
1651                 int v2 = gc.getActualMaximum(field);
1652                 return Math.min(LEAST_MAX_VALUES[field], Math.min(v1, v2));
1653             }
1654         }
1655         return LEAST_MAX_VALUES[field];
1656     }
1657 
1658     /**
1659      * Returns the minimum value that this calendar field could have,
1660      * taking into consideration the given time value and the current
1661      * values of the
1662      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1663      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1664      * {@link #getGregorianChange() getGregorianChange} and
1665      * {@link Calendar#getTimeZone() getTimeZone} methods.
1666      *
1667      * &lt;p&gt;For example, if the Gregorian change date is January 10,
<span class="line-modified">1668      * 1970 and the date of this {@code GregorianCalendar} is</span>
1669      * January 20, 1970, the actual minimum value of the
<span class="line-modified">1670      * {@code DAY_OF_MONTH} field is 10 because the previous date</span>
1671      * of January 10, 1970 is December 27, 1996 (in the Julian
1672      * calendar). Therefore, December 28, 1969 to January 9, 1970
1673      * don&#39;t exist.
1674      *
1675      * @param field the calendar field
1676      * @return the minimum of the given field for the time value of
<span class="line-modified">1677      * this {@code GregorianCalendar}</span>
1678      * @see #getMinimum(int)
1679      * @see #getMaximum(int)
1680      * @see #getGreatestMinimum(int)
1681      * @see #getLeastMaximum(int)
1682      * @see #getActualMaximum(int)
1683      * @since 1.2
1684      */
1685     @Override
1686     public int getActualMinimum(int field) {
1687         if (field == DAY_OF_MONTH) {
1688             GregorianCalendar gc = getNormalizedCalendar();
1689             int year = gc.cdate.getNormalizedYear();
1690             if (year == gregorianCutoverYear || year == gregorianCutoverYearJulian) {
1691                 long month1 = getFixedDateMonth1(gc.cdate, gc.calsys.getFixedDate(gc.cdate));
1692                 BaseCalendar.Date d = getCalendarDate(month1);
1693                 return d.getDayOfMonth();
1694             }
1695         }
1696         return getMinimum(field);
1697     }
1698 
1699     /**
1700      * Returns the maximum value that this calendar field could have,
1701      * taking into consideration the given time value and the current
1702      * values of the
1703      * {@link Calendar#getFirstDayOfWeek() getFirstDayOfWeek},
1704      * {@link Calendar#getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek},
1705      * {@link #getGregorianChange() getGregorianChange} and
1706      * {@link Calendar#getTimeZone() getTimeZone} methods.
1707      * For example, if the date of this instance is February 1, 2004,
<span class="line-modified">1708      * the actual maximum value of the {@code DAY_OF_MONTH} field</span>
1709      * is 29 because 2004 is a leap year, and if the date of this
1710      * instance is February 1, 2005, it&#39;s 28.
1711      *
1712      * &lt;p&gt;This method calculates the maximum value of {@link
1713      * Calendar#WEEK_OF_YEAR WEEK_OF_YEAR} based on the {@link
1714      * Calendar#YEAR YEAR} (calendar year) value, not the &lt;a
1715      * href=&quot;#week_year&quot;&gt;week year&lt;/a&gt;. Call {@link
1716      * #getWeeksInWeekYear()} to get the maximum value of {@code
1717      * WEEK_OF_YEAR} in the week year of this {@code GregorianCalendar}.
1718      *
1719      * @param field the calendar field
1720      * @return the maximum of the given field for the time value of
<span class="line-modified">1721      * this {@code GregorianCalendar}</span>
1722      * @see #getMinimum(int)
1723      * @see #getMaximum(int)
1724      * @see #getGreatestMinimum(int)
1725      * @see #getLeastMaximum(int)
1726      * @see #getActualMinimum(int)
1727      * @since 1.2
1728      */
1729     @Override
1730     public int getActualMaximum(int field) {
1731         final int fieldsForFixedMax = ERA_MASK|DAY_OF_WEEK_MASK|HOUR_MASK|AM_PM_MASK|
1732             HOUR_OF_DAY_MASK|MINUTE_MASK|SECOND_MASK|MILLISECOND_MASK|
1733             ZONE_OFFSET_MASK|DST_OFFSET_MASK;
1734         if ((fieldsForFixedMax &amp; (1&lt;&lt;field)) != 0) {
1735             return getMaximum(field);
1736         }
1737 
1738         GregorianCalendar gc = getNormalizedCalendar();
1739         BaseCalendar.Date date = gc.cdate;
1740         BaseCalendar cal = gc.calsys;
1741         int normalizedYear = date.getNormalizedYear();
</pre>
<hr />
<pre>
2166      * the ISO 8601 standard, and that the {@code weekOfYear}
2167      * numbering is compatible with the standard when {@code
2168      * getFirstDayOfWeek()} is {@code MONDAY} and {@code
2169      * getMinimalDaysInFirstWeek()} is 4.
2170      *
2171      * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
2172      * and the instant of time value are calculated upon return.
2173      *
2174      * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year
2175      * range in {@code weekYear}, the {@code weekYear}
2176      * and {@code weekOfYear} values are adjusted in lenient
2177      * mode, or an {@code IllegalArgumentException} is thrown in
2178      * non-lenient mode.
2179      *
2180      * @param weekYear    the week year
2181      * @param weekOfYear  the week number based on {@code weekYear}
2182      * @param dayOfWeek   the day of week value: one of the constants
2183      *                    for the {@link #DAY_OF_WEEK DAY_OF_WEEK} field:
2184      *                    {@link Calendar#SUNDAY SUNDAY}, ...,
2185      *                    {@link Calendar#SATURDAY SATURDAY}.
<span class="line-modified">2186      * @throws    IllegalArgumentException</span>
2187      *            if any of the given date specifiers is invalid,
2188      *            or if any of the calendar fields are inconsistent
2189      *            with the given date specifiers in non-lenient mode
2190      * @see GregorianCalendar#isWeekDateSupported()
2191      * @see Calendar#getFirstDayOfWeek()
2192      * @see Calendar#getMinimalDaysInFirstWeek()
2193      * @since 1.7
2194      */
2195     @Override
2196     public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
2197         if (dayOfWeek &lt; SUNDAY || dayOfWeek &gt; SATURDAY) {
2198             throw new IllegalArgumentException(&quot;invalid dayOfWeek: &quot; + dayOfWeek);
2199         }
2200 
2201         // To avoid changing the time of day fields by date
2202         // calculations, use a clone with the GMT time zone.
2203         GregorianCalendar gc = (GregorianCalendar) clone();
2204         gc.setLenient(true);
2205         int era = gc.get(ERA);
2206         gc.clear();
</pre>
<hr />
<pre>
2270         gc.setWeekDate(weekYear, 2, internalGet(DAY_OF_WEEK));
2271         return gc.getActualMaximum(WEEK_OF_YEAR);
2272     }
2273 
2274 /////////////////////////////
2275 // Time =&gt; Fields computation
2276 /////////////////////////////
2277 
2278     /**
2279      * The fixed date corresponding to gdate. If the value is
2280      * Long.MIN_VALUE, the fixed date value is unknown. Currently,
2281      * Julian calendar dates are not cached.
2282      */
2283     private transient long cachedFixedDate = Long.MIN_VALUE;
2284 
2285     /**
2286      * Converts the time value (millisecond offset from the &lt;a
2287      * href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;) to calendar field values.
2288      * The time is &lt;em&gt;not&lt;/em&gt;
2289      * recomputed first; to recompute the time, then the fields, call the
<span class="line-modified">2290      * {@code complete} method.</span>
2291      *
2292      * @see Calendar#complete
2293      */
2294     @Override
2295     protected void computeFields() {
2296         int mask;
2297         if (isPartiallyNormalized()) {
2298             // Determine which calendar fields need to be computed.
2299             mask = getSetStateFields();
2300             int fieldMask = ~mask &amp; ALL_FIELDS;
2301             // We have to call computTime in case calsys == null in
2302             // order to set calsys and cdate. (6263644)
2303             if (fieldMask != 0 || calsys == null) {
2304                 mask |= computeFields(fieldMask,
2305                                       mask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK));
2306                 assert mask == ALL_FIELDS;
2307             }
2308         } else {
2309             mask = ALL_FIELDS;
2310             computeFields(mask, 0);
</pre>
<hr />
<pre>
2609         // We can always use `gcal&#39; since Julian and Gregorian are the
2610         // same thing for this calculation.
2611         long fixedDay1st = Gregorian.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,
2612                                                                 getFirstDayOfWeek());
2613         int ndays = (int)(fixedDay1st - fixedDay1);
2614         assert ndays &lt;= 7;
2615         if (ndays &gt;= getMinimalDaysInFirstWeek()) {
2616             fixedDay1st -= 7;
2617         }
2618         int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);
2619         if (normalizedDayOfPeriod &gt;= 0) {
2620             return normalizedDayOfPeriod / 7 + 1;
2621         }
2622         return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;
2623     }
2624 
2625     /**
2626      * Converts calendar field values to the time value (millisecond
2627      * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
2628      *
<span class="line-modified">2629      * @throws    IllegalArgumentException if any calendar fields are invalid.</span>
2630      */
2631     @Override
2632     protected void computeTime() {
2633         // In non-lenient mode, perform brief checking of calendar
2634         // fields which have been set externally. Through this
2635         // checking, the field values are stored in originalFields[]
2636         // to see if any of them are normalized later.
2637         if (!isLenient()) {
2638             if (originalFields == null) {
2639                 originalFields = new int[FIELD_COUNT];
2640             }
2641             for (int field = 0; field &lt; FIELD_COUNT; field++) {
2642                 int value = internalGet(field);
2643                 if (isExternallySet(field)) {
2644                     // Quick validation for any out of range values
2645                     if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {
2646                         throw new IllegalArgumentException(getFieldName(field));
2647                     }
2648                 }
2649                 originalFields[field] = value;
</pre>
<hr />
<pre>
3213         if (n &gt; max) {
3214             n -= range;
3215         } else if (n &lt; min) {
3216             n += range;
3217         }
3218         assert n &gt;= min &amp;&amp; n &lt;= max;
3219         return n;
3220     }
3221 
3222     /**
3223      * Returns the ERA.  We need a special method for this because the
3224      * default ERA is CE, but a zero (unset) ERA is BCE.
3225      */
3226     private int internalGetEra() {
3227         return isSet(ERA) ? internalGet(ERA) : CE;
3228     }
3229 
3230     /**
3231      * Updates internal state.
3232      */
<span class="line-added">3233     @java.io.Serial</span>
3234     private void readObject(ObjectInputStream stream)
3235             throws IOException, ClassNotFoundException {
3236         stream.defaultReadObject();
3237         if (gdate == null) {
3238             gdate = (BaseCalendar.Date) gcal.newCalendarDate(getZone());
3239             cachedFixedDate = Long.MIN_VALUE;
3240         }
3241         setGregorianChange(gregorianCutover);
3242     }
3243 
3244     /**
3245      * Converts this object to a {@code ZonedDateTime} that represents
3246      * the same point on the time-line as this {@code GregorianCalendar}.
3247      * &lt;p&gt;
3248      * Since this object supports a Julian-Gregorian cutover date and
3249      * {@code ZonedDateTime} does not, it is possible that the resulting year,
3250      * month and day will have different values.  The result will represent the
3251      * correct date in the ISO calendar system, which will also be the same value
3252      * for Modified Julian Days.
3253      *
</pre>
<hr />
<pre>
3262 
3263     /**
3264      * Obtains an instance of {@code GregorianCalendar} with the default locale
3265      * from a {@code ZonedDateTime} object.
3266      * &lt;p&gt;
3267      * Since {@code ZonedDateTime} does not support a Julian-Gregorian cutover
3268      * date and uses ISO calendar system, the return GregorianCalendar is a pure
3269      * Gregorian calendar and uses ISO 8601 standard for week definitions,
3270      * which has {@code MONDAY} as the {@link Calendar#getFirstDayOfWeek()
3271      * FirstDayOfWeek} and {@code 4} as the value of the
3272      * {@link Calendar#getMinimalDaysInFirstWeek() MinimalDaysInFirstWeek}.
3273      * &lt;p&gt;
3274      * {@code ZoneDateTime} can store points on the time-line further in the
3275      * future and further in the past than {@code GregorianCalendar}. In this
3276      * scenario, this method will throw an {@code IllegalArgumentException}
3277      * exception.
3278      *
3279      * @param zdt  the zoned date-time object to convert
3280      * @return  the gregorian calendar representing the same point on the
3281      *  time-line as the zoned date-time provided
<span class="line-modified">3282      * @throws    NullPointerException if {@code zdt} is null</span>
<span class="line-modified">3283      * @throws    IllegalArgumentException if the zoned date-time is too</span>
3284      * large to represent as a {@code GregorianCalendar}
3285      * @since 1.8
3286      */
3287     public static GregorianCalendar from(ZonedDateTime zdt) {
3288         GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(zdt.getZone()));
3289         cal.setGregorianChange(new Date(Long.MIN_VALUE));
3290         cal.setFirstDayOfWeek(MONDAY);
3291         cal.setMinimalDaysInFirstWeek(4);
3292         try {
3293             cal.setTimeInMillis(Math.addExact(Math.multiplyExact(zdt.toEpochSecond(), 1000),
3294                                               zdt.get(ChronoField.MILLI_OF_SECOND)));
3295         } catch (ArithmeticException ex) {
3296             throw new IllegalArgumentException(ex);
3297         }
3298         return cal;
3299     }
3300 }
</pre>
</td>
</tr>
</table>
<center><a href="FormatterClosedException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HashMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
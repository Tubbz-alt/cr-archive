<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/FilePermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/FilePermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.security.*;
  30 import java.util.Enumeration;
  31 import java.util.Objects;
  32 import java.util.StringJoiner;
  33 import java.util.Vector;
  34 import java.util.concurrent.ConcurrentHashMap;
  35 
  36 import jdk.internal.access.JavaIOFilePermissionAccess;
  37 import jdk.internal.access.SharedSecrets;
  38 import sun.nio.fs.DefaultFileSystemProvider;
  39 import sun.security.action.GetPropertyAction;
  40 import sun.security.util.FilePermCompat;
  41 import sun.security.util.SecurityConstants;
  42 
  43 /**
  44  * This class represents access to a file or directory.  A FilePermission consists
  45  * of a pathname and a set of actions valid for that pathname.
  46  * &lt;P&gt;
  47  * Pathname is the pathname of the file or directory granted the specified
  48  * actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">  49  * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;) indicates</span>
  50  * all the files and directories contained in that directory. A pathname
  51  * that ends with &quot;/-&quot; indicates (recursively) all files
  52  * and subdirectories contained in that directory. Such a pathname is called
  53  * a wildcard pathname. Otherwise, it&#39;s a simple pathname.
  54  * &lt;P&gt;
  55  * A pathname consisting of the special token {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;}
  56  * matches &lt;b&gt;any&lt;/b&gt; file.
  57  * &lt;P&gt;
  58  * Note: A pathname consisting of a single &quot;*&quot; indicates all the files
  59  * in the current directory, while a pathname consisting of a single &quot;-&quot;
  60  * indicates all the files in the current directory and
  61  * (recursively) all files and subdirectories contained in the current
  62  * directory.
  63  * &lt;P&gt;
  64  * The actions to be granted are passed to the constructor in a string containing
  65  * a list of one or more comma-separated keywords. The possible keywords are
  66  * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;. Their meaning is
  67  * defined as follows:
  68  *
  69  * &lt;DL&gt;
  70  *    &lt;DT&gt; read &lt;DD&gt; read permission
  71  *    &lt;DT&gt; write &lt;DD&gt; write permission
  72  *    &lt;DT&gt; execute
<span class="line-modified">  73  *    &lt;DD&gt; execute permission. Allows &lt;code&gt;Runtime.exec&lt;/code&gt; to</span>
<span class="line-modified">  74  *         be called. Corresponds to &lt;code&gt;SecurityManager.checkExec&lt;/code&gt;.</span>
  75  *    &lt;DT&gt; delete
<span class="line-modified">  76  *    &lt;DD&gt; delete permission. Allows &lt;code&gt;File.delete&lt;/code&gt; to</span>
<span class="line-modified">  77  *         be called. Corresponds to &lt;code&gt;SecurityManager.checkDelete&lt;/code&gt;.</span>
  78  *    &lt;DT&gt; readlink
  79  *    &lt;DD&gt; read link permission. Allows the target of a
  80  *         &lt;a href=&quot;../nio/file/package-summary.html#links&quot;&gt;symbolic link&lt;/a&gt;
  81  *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
  82  *         readSymbolicLink } method.
  83  * &lt;/DL&gt;
  84  * &lt;P&gt;
  85  * The actions string is converted to lowercase before processing.
  86  * &lt;P&gt;
  87  * Be careful when granting FilePermissions. Think about the implications
  88  * of granting read and especially write access to various files and
  89  * directories. The {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} permission with write action is
  90  * especially dangerous. This grants permission to write to the entire
  91  * file system. One thing this effectively allows is replacement of the
  92  * system binary, including the JVM runtime environment.
  93  * &lt;P&gt;
  94  * Please note: Code can always read a file from the same
  95  * directory it&#39;s in (or a subdirectory of that directory); it does not
  96  * need explicit permission to do so.
  97  *
</pre>
<hr />
<pre>
 178     private static final char RECURSIVE_CHAR = &#39;-&#39;;
 179     private static final char WILD_CHAR = &#39;*&#39;;
 180 
 181 //    public String toString() {
 182 //        StringBuffer sb = new StringBuffer();
 183 //        sb.append(&quot;*** FilePermission on &quot; + getName() + &quot; ***&quot;);
 184 //        for (Field f : FilePermission.class.getDeclaredFields()) {
 185 //            if (!Modifier.isStatic(f.getModifiers())) {
 186 //                try {
 187 //                    sb.append(f.getName() + &quot; = &quot; + f.get(this));
 188 //                } catch (Exception e) {
 189 //                    sb.append(f.getName() + &quot; = &quot; + e.toString());
 190 //                }
 191 //                sb.append(&#39;\n&#39;);
 192 //            }
 193 //        }
 194 //        sb.append(&quot;***\n&quot;);
 195 //        return sb.toString();
 196 //    }
 197 

 198     private static final long serialVersionUID = 7930732926638008763L;
 199 
 200     /**
 201      * Use the platform&#39;s default file system to avoid recursive initialization
 202      * issues when the VM is configured to use a custom file system provider.
 203      */
 204     private static final java.nio.file.FileSystem builtInFS =
 205         DefaultFileSystemProvider.theFileSystem();
 206 
 207     private static final Path here = builtInFS.getPath(
 208             GetPropertyAction.privilegedGetProperty(&quot;user.dir&quot;));
 209 
 210     private static final Path EMPTY_PATH = builtInFS.getPath(&quot;&quot;);
 211     private static final Path DASH_PATH = builtInFS.getPath(&quot;-&quot;);
 212     private static final Path DOTDOT_PATH = builtInFS.getPath(&quot;..&quot;);
 213 
 214     /**
 215      * A private constructor that clones some and updates some,
 216      * always with a different name.
 217      * @param input
</pre>
<hr />
<pre>
 349                     npath = npath.getParent();
 350                 }
 351                 if (npath == null) {
 352                     npath = EMPTY_PATH;
 353                 }
 354                 invalid = false;
 355             } catch (InvalidPathException ipe) {
 356                 // Still invalid. For compatibility reason, accept it
 357                 // but make this permission useless.
 358                 npath = builtInFS.getPath(&quot;-u-s-e-l-e-s-s-&quot;);
 359                 invalid = true;
 360             }
 361 
 362         } else {
 363             if ((cpath = getName()) == null)
 364                 throw new NullPointerException(&quot;name can&#39;t be null&quot;);
 365 
 366             this.mask = mask;
 367 
 368             if (cpath.equals(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;)) {

 369                 directory = true;
 370                 recursive = true;
 371                 cpath = &quot;&quot;;
 372                 return;
 373             }
 374 









 375             // store only the canonical cpath if possible
 376             cpath = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 377                 public String run() {
 378                     try {
 379                         String path = cpath;
 380                         if (cpath.endsWith(&quot;*&quot;)) {
 381                             // call getCanonicalPath with a path with wildcard character
 382                             // replaced to avoid calling it with paths that are
 383                             // intended to match all entries in a directory
 384                             path = path.substring(0, path.length() - 1) + &quot;-&quot;;
 385                             path = new File(path).getCanonicalPath();
 386                             return path.substring(0, path.length() - 1) + &quot;*&quot;;
 387                         } else {
 388                             return new File(path).getCanonicalPath();
 389                         }
 390                     } catch (IOException ioe) {
 391                         return cpath;
 392                     }
 393                 }
 394             });
</pre>
<hr />
<pre>
 408                 cpath = cpath.substring(0, --len);
 409             } else {
 410                 // overkill since they are initialized to false, but
 411                 // commented out here to remind us...
 412                 //directory = false;
 413                 //recursive = false;
 414             }
 415 
 416             // XXX: at this point the path should be absolute. die if it isn&#39;t?
 417         }
 418     }
 419 
 420     /**
 421      * Creates a new FilePermission object with the specified actions.
 422      * &lt;i&gt;path&lt;/i&gt; is the pathname of a file or directory, and &lt;i&gt;actions&lt;/i&gt;
 423      * contains a comma-separated list of the desired actions granted on the
 424      * file or directory. Possible actions are
 425      * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;.
 426      *
 427      * &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified"> 428      * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;)</span>
 429      * indicates all the files and directories contained in that directory.
 430      * A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
 431      * subdirectories contained in that directory. The special pathname
 432      * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} matches any file.
 433      *
 434      * &lt;p&gt;A pathname consisting of a single &quot;*&quot; indicates all the files
 435      * in the current directory, while a pathname consisting of a single &quot;-&quot;
 436      * indicates all the files in the current directory and
 437      * (recursively) all files and subdirectories contained in the current
 438      * directory.
 439      *
 440      * &lt;p&gt;A pathname containing an empty string represents an empty path.
 441      *
 442      * @implNote In this implementation, the
<span class="line-modified"> 443      * {@code jdk.io.permissionsUseCanonicalPath} system property dictates how</span>
<span class="line-modified"> 444      * the {@code path} argument is processed and stored.</span>
 445      * &lt;P&gt;
 446      * If the value of the system property is set to {@code true}, {@code path}
 447      * is canonicalized and stored as a String object named {@code cpath}.
 448      * This means a relative path is converted to an absolute path, a Windows
 449      * DOS-style 8.3 path is expanded to a long path, and a symbolic link is
 450      * resolved to its target, etc.
 451      * &lt;P&gt;
 452      * If the value of the system property is set to {@code false}, {@code path}
 453      * is converted to a {@link java.nio.file.Path} object named {@code npath}
 454      * after {@link Path#normalize() normalization}. No canonicalization is
 455      * performed which means the underlying file system is not accessed.
 456      * If an {@link InvalidPathException} is thrown during the conversion,
 457      * this {@code FilePermission} will be labeled as invalid.
 458      * &lt;P&gt;
 459      * In either case, the &quot;*&quot; or &quot;-&quot; character at the end of a wildcard
 460      * {@code path} is removed before canonicalization or normalization.
 461      * It is stored in a separate wildcard flag field.
 462      * &lt;P&gt;
 463      * The default value of the {@code jdk.io.permissionsUseCanonicalPath}
 464      * system property is {@code false} in this implementation.



 465      *
 466      * @param path the pathname of the file/directory.
 467      * @param actions the action string.
 468      *
<span class="line-modified"> 469      * @throws IllegalArgumentException</span>
<span class="line-modified"> 470      *          If actions is &lt;code&gt;null&lt;/code&gt;, empty or contains an action</span>
<span class="line-modified"> 471      *          other than the specified possible actions.</span>
 472      */
 473     public FilePermission(String path, String actions) {
 474         super(path);
 475         init(getMask(actions));
 476     }
 477 
 478     /**
 479      * Creates a new FilePermission object using an action mask.
 480      * More efficient than the FilePermission(String, String) constructor.
 481      * Can be used from within
 482      * code that needs to create a FilePermission object to pass into the
<span class="line-modified"> 483      * &lt;code&gt;implies&lt;/code&gt; method.</span>
 484      *
 485      * @param path the pathname of the file/directory.
 486      * @param mask the action mask to use.
 487      */
 488     // package private for use by the FilePermissionCollection add method
 489     FilePermission(String path, int mask) {
 490         super(path);
 491         init(mask);
 492     }
 493 
 494     /**
 495      * Checks if this FilePermission object &quot;implies&quot; the specified permission.
 496      * &lt;P&gt;
 497      * More specifically, this method returns true if:
 498      * &lt;ul&gt;
 499      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof FilePermission,
 500      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s actions are a proper subset of this
 501      * object&#39;s actions, and
 502      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s pathname is implied by this object&#39;s
 503      *      pathname. For example, &quot;/tmp/*&quot; implies &quot;/tmp/foo&quot;, since
</pre>
<hr />
<pre>
 529      * sequence) from the former the remaining part equals to the latter,
 530      * a simple {@code cpath} is recursively inside a wildcard {@code cpath}
 531      * if and only if the former starts with the latter.
 532      * &lt;p&gt;
 533      * If {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, a
 534      * simple {@code npath} is inside a wildcard {@code npath} if and only if
 535      * {@code  simple_npath.relativize(wildcard_npath)} is exactly &quot;..&quot;,
 536      * a simple {@code npath} is recursively inside a wildcard {@code npath}
 537      * if and only if {@code simple_npath.relativize(wildcard_npath)} is a
 538      * series of one or more &quot;..&quot;. This means &quot;/-&quot; implies &quot;/foo&quot; but not &quot;foo&quot;.
 539      * &lt;p&gt;
 540      * An invalid {@code FilePermission} does not imply any object except for
 541      * itself. An invalid {@code FilePermission} is not implied by any object
 542      * except for itself or a {@code FilePermission} on
 543      * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} whose actions is a superset of this
 544      * invalid {@code FilePermission}. Even if two {@code FilePermission}
 545      * are created with the same invalid path, one does not imply the other.
 546      *
 547      * @param p the permission to check against.
 548      *
<span class="line-modified"> 549      * @return &lt;code&gt;true&lt;/code&gt; if the specified permission is not</span>
<span class="line-modified"> 550      *                  &lt;code&gt;null&lt;/code&gt; and is implied by this object,</span>
<span class="line-modified"> 551      *                  &lt;code&gt;false&lt;/code&gt; otherwise.</span>
 552      */
 553     @Override
 554     public boolean implies(Permission p) {
 555         if (!(p instanceof FilePermission))
 556             return false;
 557 
 558         FilePermission that = (FilePermission) p;
 559 
 560         // we get the effective mask. i.e., the &quot;and&quot; of this and that.
 561         // They must be equal to that.mask for implies to return true.
 562 
 563         return ((this.mask &amp; that.mask) == that.mask) &amp;&amp; impliesIgnoreMask(that);
 564     }
 565 
 566     /**
 567      * Checks if the Permission&#39;s actions are a proper subset of the
 568      * this object&#39;s actions. Returns the effective mask iff the
 569      * this FilePermission&#39;s path also implies that FilePermission&#39;s path.
 570      *
 571      * @param that the FilePermission to check against.
 572      * @return the effective mask
 573      */
 574     boolean impliesIgnoreMask(FilePermission that) {












 575         if (FilePermCompat.nb) {
<span class="line-removed"> 576             if (this == that) {</span>
<span class="line-removed"> 577                 return true;</span>
<span class="line-removed"> 578             }</span>
<span class="line-removed"> 579             if (allFiles) {</span>
<span class="line-removed"> 580                 return true;</span>
<span class="line-removed"> 581             }</span>
<span class="line-removed"> 582             if (this.invalid || that.invalid) {</span>
<span class="line-removed"> 583                 return false;</span>
<span class="line-removed"> 584             }</span>
<span class="line-removed"> 585             if (that.allFiles) {</span>
<span class="line-removed"> 586                 return false;</span>
<span class="line-removed"> 587             }</span>
 588             // Left at least same level of wildness as right
 589             if ((this.recursive &amp;&amp; that.recursive) != that.recursive
 590                     || (this.directory &amp;&amp; that.directory) != that.directory) {
 591                 return false;
 592             }
 593             // Same npath is good as long as both or neither are directories
 594             if (this.npath.equals(that.npath)
 595                     &amp;&amp; this.directory == that.directory) {
 596                 return true;
 597             }
 598             int diff = containsPath(this.npath, that.npath);
 599             // Right inside left is good if recursive
 600             if (diff &gt;= 1 &amp;&amp; recursive) {
 601                 return true;
 602             }
 603             // Right right inside left if it is element in set
 604             if (diff == 1 &amp;&amp; directory &amp;&amp; !that.directory) {
 605                 return true;
 606             }
 607 
</pre>
<hr />
<pre>
 751         // After removing the common heads, they become &quot;../..&quot; and &quot;a&quot;,
 752         // and the distance is (3-1)+(2-1) = 3.
 753         return c1 - i + c2 - i;
 754     }
 755 
 756     /**
 757      * Checks two FilePermission objects for equality. Checks that &lt;i&gt;obj&lt;/i&gt; is
 758      * a FilePermission, and has the same pathname and actions as this object.
 759      *
 760      * @implNote More specifically, two pathnames are the same if and only if
 761      * they have the same wildcard flag and their {@code cpath}
 762      * (if {@code jdk.io.permissionsUseCanonicalPath} is {@code true}) or
 763      * {@code npath} (if {@code jdk.io.permissionsUseCanonicalPath}
 764      * is {@code false}) are equal. Or they are both {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;}.
 765      * &lt;p&gt;
 766      * When {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, an
 767      * invalid {@code FilePermission} does not equal to any object except
 768      * for itself, even if they are created using the same invalid path.
 769      *
 770      * @param obj the object we are testing for equality with this object.
<span class="line-modified"> 771      * @return &lt;code&gt;true&lt;/code&gt; if obj is a FilePermission, and has the same</span>
 772      *          pathname and actions as this FilePermission object,
<span class="line-modified"> 773      *          &lt;code&gt;false&lt;/code&gt; otherwise.</span>
 774      */
 775     @Override
 776     public boolean equals(Object obj) {
 777         if (obj == this)
 778             return true;
 779 
 780         if (! (obj instanceof FilePermission))
 781             return false;
 782 
 783         FilePermission that = (FilePermission) obj;
 784 



 785         if (FilePermCompat.nb) {
<span class="line-removed"> 786             if (this.invalid || that.invalid) {</span>
<span class="line-removed"> 787                 return false;</span>
<span class="line-removed"> 788             }</span>
 789             return (this.mask == that.mask) &amp;&amp;
 790                     (this.allFiles == that.allFiles) &amp;&amp;
 791                     this.npath.equals(that.npath) &amp;&amp;
 792                     Objects.equals(npath2, that.npath2) &amp;&amp;
 793                     (this.directory == that.directory) &amp;&amp;
 794                     (this.recursive == that.recursive);
 795         } else {
 796             return (this.mask == that.mask) &amp;&amp;

 797                     this.cpath.equals(that.cpath) &amp;&amp;
 798                     (this.directory == that.directory) &amp;&amp;
 799                     (this.recursive == that.recursive);
 800         }
 801     }
 802 
 803     /**
 804      * Returns the hash code value for this object.
 805      *
 806      * @return a hash code value for this object.
 807      */
 808     @Override
 809     public int hashCode() {
 810         if (FilePermCompat.nb) {
 811             return Objects.hash(
 812                     mask, allFiles, directory, recursive, npath, npath2, invalid);
 813         } else {
 814             return 0;
 815         }
 816     }
</pre>
<hr />
<pre>
 903 
 904             } else if (i &gt;= 7 &amp;&amp; (a[i-7] == &#39;r&#39; || a[i-7] == &#39;R&#39;) &amp;&amp;
 905                                  (a[i-6] == &#39;e&#39; || a[i-6] == &#39;E&#39;) &amp;&amp;
 906                                  (a[i-5] == &#39;a&#39; || a[i-5] == &#39;A&#39;) &amp;&amp;
 907                                  (a[i-4] == &#39;d&#39; || a[i-4] == &#39;D&#39;) &amp;&amp;
 908                                  (a[i-3] == &#39;l&#39; || a[i-3] == &#39;L&#39;) &amp;&amp;
 909                                  (a[i-2] == &#39;i&#39; || a[i-2] == &#39;I&#39;) &amp;&amp;
 910                                  (a[i-1] == &#39;n&#39; || a[i-1] == &#39;N&#39;) &amp;&amp;
 911                                  (a[i] == &#39;k&#39; || a[i] == &#39;K&#39;))
 912             {
 913                 matchlen = 8;
 914                 mask |= READLINK;
 915 
 916             } else {
 917                 // parse error
 918                 throw new IllegalArgumentException(
 919                         &quot;invalid permission: &quot; + actions);
 920             }
 921 
 922             // make sure we didn&#39;t just match the tail of a word
<span class="line-modified"> 923             // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.</span>
 924             boolean seencomma = false;
 925             while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified"> 926                 switch(a[i-matchlen]) {</span>
<span class="line-removed"> 927                 case &#39;,&#39;:</span>
<span class="line-removed"> 928                     seencomma = true;</span>
<span class="line-removed"> 929                     break;</span>
 930                 case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
 931                 case &#39;\f&#39;: case &#39;\t&#39;:
 932                     break;
 933                 default:




 934                     throw new IllegalArgumentException(
 935                             &quot;invalid permission: &quot; + actions);
 936                 }
 937                 i--;
 938             }
 939 
 940             // point i at the location of the comma minus one (or -1).
 941             i -= matchlen;
 942         }
 943 
 944         return mask;
 945     }
 946 
 947     /**
 948      * Return the current action mask. Used by the FilePermissionCollection.
 949      *
 950      * @return the actions mask.
 951      */
 952     int getMask() {
 953         return mask;
</pre>
<hr />
<pre>
 969         if ((mask &amp; WRITE) == WRITE) {
 970             sj.add(&quot;write&quot;);
 971         }
 972         if ((mask &amp; EXECUTE) == EXECUTE) {
 973             sj.add(&quot;execute&quot;);
 974         }
 975         if ((mask &amp; DELETE) == DELETE) {
 976             sj.add(&quot;delete&quot;);
 977         }
 978         if ((mask &amp; READLINK) == READLINK) {
 979             sj.add(&quot;readlink&quot;);
 980         }
 981 
 982         return sj.toString();
 983     }
 984 
 985     /**
 986      * Returns the &quot;canonical string representation&quot; of the actions.
 987      * That is, this method always returns present actions in the following order:
 988      * read, write, execute, delete, readlink. For example, if this FilePermission
<span class="line-modified"> 989      * object allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;</span>
 990      * will return the string &quot;read,write&quot;.
 991      *
 992      * @return the canonical string representation of the actions.
 993      */
 994     @Override
 995     public String getActions() {
 996         if (actions == null)
 997             actions = getActions(this.mask);
 998 
 999         return actions;
1000     }
1001 
1002     /**
1003      * Returns a new PermissionCollection object for storing FilePermission
1004      * objects.
1005      * &lt;p&gt;
1006      * FilePermission objects must be stored in a manner that allows them
1007      * to be inserted into the collection in any order, but that also enables the
<span class="line-modified">1008      * PermissionCollection &lt;code&gt;implies&lt;/code&gt;</span>
1009      * method to be implemented in an efficient (and consistent) manner.
1010      *
1011      * &lt;p&gt;For example, if you have two FilePermissions:
1012      * &lt;OL&gt;
<span class="line-modified">1013      * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/-&quot;, &quot;read&quot;&lt;/code&gt;</span>
<span class="line-modified">1014      * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/scratch/foo&quot;, &quot;write&quot;&lt;/code&gt;</span>
1015      * &lt;/OL&gt;
1016      *
<span class="line-modified">1017      * &lt;p&gt;and you are calling the &lt;code&gt;implies&lt;/code&gt; method with the FilePermission:</span>
1018      *
1019      * &lt;pre&gt;
1020      *   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
1021      * &lt;/pre&gt;
1022      *
<span class="line-modified">1023      * then the &lt;code&gt;implies&lt;/code&gt; function must</span>
1024      * take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
1025      * permissions, so the effective permission is &quot;read,write&quot;,
<span class="line-modified">1026      * and &lt;code&gt;implies&lt;/code&gt; returns true. The &quot;implies&quot; semantics for</span>
1027      * FilePermissions are handled properly by the PermissionCollection object
<span class="line-modified">1028      * returned by this &lt;code&gt;newPermissionCollection&lt;/code&gt; method.</span>
1029      *
1030      * @return a new PermissionCollection object suitable for storing
1031      * FilePermissions.
1032      */
1033     @Override
1034     public PermissionCollection newPermissionCollection() {
1035         return new FilePermissionCollection();
1036     }
1037 
1038     /**
1039      * WriteObject is called to save the state of the FilePermission
1040      * to a stream. The actions are serialized, and the superclass
1041      * takes care of the name.
1042      */

1043     private void writeObject(ObjectOutputStream s)
1044         throws IOException
1045     {
1046         // Write out the actions. The superclass takes care of the name
1047         // call getActions to make sure actions field is initialized
1048         if (actions == null)
1049             getActions();
1050         s.defaultWriteObject();
1051     }
1052 
1053     /**
1054      * readObject is called to restore the state of the FilePermission from
1055      * a stream.
1056      */

1057     private void readObject(ObjectInputStream s)
1058          throws IOException, ClassNotFoundException
1059     {
1060         // Read in the actions, then restore everything else by calling init.
1061         s.defaultReadObject();
1062         init(getMask(actions));
1063     }
1064 
1065     /**
1066      * Create a cloned FilePermission with a different actions.
1067      * @param effective the new actions
1068      * @return a new object
1069      */
1070     FilePermission withNewActions(int effective) {
1071         return new FilePermission(this.getName(),
1072                 this,
1073                 this.npath,
1074                 this.npath2,
1075                 effective,
1076                 null);
</pre>
<hr />
<pre>
1107 
1108 final class FilePermissionCollection extends PermissionCollection
1109     implements Serializable
1110 {
1111     // Not serialized; see serialization section at end of class
1112     private transient ConcurrentHashMap&lt;String, Permission&gt; perms;
1113 
1114     /**
1115      * Create an empty FilePermissionCollection object.
1116      */
1117     public FilePermissionCollection() {
1118         perms = new ConcurrentHashMap&lt;&gt;();
1119     }
1120 
1121     /**
1122      * Adds a permission to the FilePermissionCollection. The key for the hash is
1123      * permission.path.
1124      *
1125      * @param permission the Permission object to add.
1126      *
<span class="line-modified">1127      * @exception IllegalArgumentException - if the permission is not a</span>
1128      *                                       FilePermission
1129      *
<span class="line-modified">1130      * @exception SecurityException - if this FilePermissionCollection object</span>
1131      *                                has been marked readonly
1132      */
1133     @Override
1134     public void add(Permission permission) {
1135         if (! (permission instanceof FilePermission))
1136             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1137                                                permission);
1138         if (isReadOnly())
1139             throw new SecurityException(
1140                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
1141 
1142         FilePermission fp = (FilePermission)permission;
1143 
1144         // Add permission to map if it is absent, or replace with new
1145         // permission if applicable.
1146         perms.merge(fp.getName(), fp,
1147             new java.util.function.BiFunction&lt;&gt;() {
1148                 @Override
1149                 public Permission apply(Permission existingVal,
1150                                         Permission newVal) {
</pre>
<hr />
<pre>
1176      * the set, false if not.
1177      */
1178     @Override
1179     public boolean implies(Permission permission) {
1180         if (! (permission instanceof FilePermission))
1181             return false;
1182 
1183         FilePermission fperm = (FilePermission) permission;
1184 
1185         int desired = fperm.getMask();
1186         int effective = 0;
1187         int needed = desired;
1188 
1189         for (Permission perm : perms.values()) {
1190             FilePermission fp = (FilePermission)perm;
1191             if (((needed &amp; fp.getMask()) != 0) &amp;&amp; fp.impliesIgnoreMask(fperm)) {
1192                 effective |= fp.getMask();
1193                 if ((effective &amp; desired) == desired) {
1194                     return true;
1195                 }
<span class="line-modified">1196                 needed = (desired ^ effective);</span>
1197             }
1198         }
1199         return false;
1200     }
1201 
1202     /**
1203      * Returns an enumeration of all the FilePermission objects in the
1204      * container.
1205      *
1206      * @return an enumeration of all the FilePermission objects.
1207      */
1208     @Override
1209     public Enumeration&lt;Permission&gt; elements() {
1210         return perms.elements();
1211     }
1212 

1213     private static final long serialVersionUID = 2202956749081564585L;
1214 
1215     // Need to maintain serialization interoperability with earlier releases,
1216     // which had the serializable field:
1217     //    private Vector permissions;
1218 
1219     /**
1220      * @serialField permissions java.util.Vector
1221      *     A list of FilePermission objects.
1222      */

1223     private static final ObjectStreamField[] serialPersistentFields = {
1224         new ObjectStreamField(&quot;permissions&quot;, Vector.class),
1225     };
1226 
1227     /**
1228      * @serialData &quot;permissions&quot; field (a Vector containing the FilePermissions).
1229      */
1230     /*
1231      * Writes the contents of the perms field out as a Vector for
1232      * serialization compatibility with earlier releases.
1233      */

1234     private void writeObject(ObjectOutputStream out) throws IOException {
1235         // Don&#39;t call out.defaultWriteObject()
1236 
1237         // Write out Vector
1238         Vector&lt;Permission&gt; permissions = new Vector&lt;&gt;(perms.values());
1239 
1240         ObjectOutputStream.PutField pfields = out.putFields();
1241         pfields.put(&quot;permissions&quot;, permissions);
1242         out.writeFields();
1243     }
1244 
1245     /*
1246      * Reads in a Vector of FilePermissions and saves them in the perms field.
1247      */

1248     private void readObject(ObjectInputStream in)
1249         throws IOException, ClassNotFoundException
1250     {
1251         // Don&#39;t call defaultReadObject()
1252 
1253         // Read in serialized fields
1254         ObjectInputStream.GetField gfields = in.readFields();
1255 
1256         // Get the one we want
1257         @SuppressWarnings(&quot;unchecked&quot;)
1258         Vector&lt;Permission&gt; permissions = (Vector&lt;Permission&gt;)gfields.get(&quot;permissions&quot;, null);
1259         perms = new ConcurrentHashMap&lt;&gt;(permissions.size());
1260         for (Permission perm : permissions) {
1261             perms.put(perm.getName(), perm);
1262         }
1263     }
1264 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 import java.security.*;
  30 import java.util.Enumeration;
  31 import java.util.Objects;
  32 import java.util.StringJoiner;
  33 import java.util.Vector;
  34 import java.util.concurrent.ConcurrentHashMap;
  35 
  36 import jdk.internal.access.JavaIOFilePermissionAccess;
  37 import jdk.internal.access.SharedSecrets;
  38 import sun.nio.fs.DefaultFileSystemProvider;
  39 import sun.security.action.GetPropertyAction;
  40 import sun.security.util.FilePermCompat;
  41 import sun.security.util.SecurityConstants;
  42 
  43 /**
  44  * This class represents access to a file or directory.  A FilePermission consists
  45  * of a pathname and a set of actions valid for that pathname.
  46  * &lt;P&gt;
  47  * Pathname is the pathname of the file or directory granted the specified
  48  * actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">  49  * the file separator character, {@code File.separatorChar}) indicates</span>
  50  * all the files and directories contained in that directory. A pathname
  51  * that ends with &quot;/-&quot; indicates (recursively) all files
  52  * and subdirectories contained in that directory. Such a pathname is called
  53  * a wildcard pathname. Otherwise, it&#39;s a simple pathname.
  54  * &lt;P&gt;
  55  * A pathname consisting of the special token {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;}
  56  * matches &lt;b&gt;any&lt;/b&gt; file.
  57  * &lt;P&gt;
  58  * Note: A pathname consisting of a single &quot;*&quot; indicates all the files
  59  * in the current directory, while a pathname consisting of a single &quot;-&quot;
  60  * indicates all the files in the current directory and
  61  * (recursively) all files and subdirectories contained in the current
  62  * directory.
  63  * &lt;P&gt;
  64  * The actions to be granted are passed to the constructor in a string containing
  65  * a list of one or more comma-separated keywords. The possible keywords are
  66  * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;. Their meaning is
  67  * defined as follows:
  68  *
  69  * &lt;DL&gt;
  70  *    &lt;DT&gt; read &lt;DD&gt; read permission
  71  *    &lt;DT&gt; write &lt;DD&gt; write permission
  72  *    &lt;DT&gt; execute
<span class="line-modified">  73  *    &lt;DD&gt; execute permission. Allows {@code Runtime.exec} to</span>
<span class="line-modified">  74  *         be called. Corresponds to {@code SecurityManager.checkExec}.</span>
  75  *    &lt;DT&gt; delete
<span class="line-modified">  76  *    &lt;DD&gt; delete permission. Allows {@code File.delete} to</span>
<span class="line-modified">  77  *         be called. Corresponds to {@code SecurityManager.checkDelete}.</span>
  78  *    &lt;DT&gt; readlink
  79  *    &lt;DD&gt; read link permission. Allows the target of a
  80  *         &lt;a href=&quot;../nio/file/package-summary.html#links&quot;&gt;symbolic link&lt;/a&gt;
  81  *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
  82  *         readSymbolicLink } method.
  83  * &lt;/DL&gt;
  84  * &lt;P&gt;
  85  * The actions string is converted to lowercase before processing.
  86  * &lt;P&gt;
  87  * Be careful when granting FilePermissions. Think about the implications
  88  * of granting read and especially write access to various files and
  89  * directories. The {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} permission with write action is
  90  * especially dangerous. This grants permission to write to the entire
  91  * file system. One thing this effectively allows is replacement of the
  92  * system binary, including the JVM runtime environment.
  93  * &lt;P&gt;
  94  * Please note: Code can always read a file from the same
  95  * directory it&#39;s in (or a subdirectory of that directory); it does not
  96  * need explicit permission to do so.
  97  *
</pre>
<hr />
<pre>
 178     private static final char RECURSIVE_CHAR = &#39;-&#39;;
 179     private static final char WILD_CHAR = &#39;*&#39;;
 180 
 181 //    public String toString() {
 182 //        StringBuffer sb = new StringBuffer();
 183 //        sb.append(&quot;*** FilePermission on &quot; + getName() + &quot; ***&quot;);
 184 //        for (Field f : FilePermission.class.getDeclaredFields()) {
 185 //            if (!Modifier.isStatic(f.getModifiers())) {
 186 //                try {
 187 //                    sb.append(f.getName() + &quot; = &quot; + f.get(this));
 188 //                } catch (Exception e) {
 189 //                    sb.append(f.getName() + &quot; = &quot; + e.toString());
 190 //                }
 191 //                sb.append(&#39;\n&#39;);
 192 //            }
 193 //        }
 194 //        sb.append(&quot;***\n&quot;);
 195 //        return sb.toString();
 196 //    }
 197 
<span class="line-added"> 198     @java.io.Serial</span>
 199     private static final long serialVersionUID = 7930732926638008763L;
 200 
 201     /**
 202      * Use the platform&#39;s default file system to avoid recursive initialization
 203      * issues when the VM is configured to use a custom file system provider.
 204      */
 205     private static final java.nio.file.FileSystem builtInFS =
 206         DefaultFileSystemProvider.theFileSystem();
 207 
 208     private static final Path here = builtInFS.getPath(
 209             GetPropertyAction.privilegedGetProperty(&quot;user.dir&quot;));
 210 
 211     private static final Path EMPTY_PATH = builtInFS.getPath(&quot;&quot;);
 212     private static final Path DASH_PATH = builtInFS.getPath(&quot;-&quot;);
 213     private static final Path DOTDOT_PATH = builtInFS.getPath(&quot;..&quot;);
 214 
 215     /**
 216      * A private constructor that clones some and updates some,
 217      * always with a different name.
 218      * @param input
</pre>
<hr />
<pre>
 350                     npath = npath.getParent();
 351                 }
 352                 if (npath == null) {
 353                     npath = EMPTY_PATH;
 354                 }
 355                 invalid = false;
 356             } catch (InvalidPathException ipe) {
 357                 // Still invalid. For compatibility reason, accept it
 358                 // but make this permission useless.
 359                 npath = builtInFS.getPath(&quot;-u-s-e-l-e-s-s-&quot;);
 360                 invalid = true;
 361             }
 362 
 363         } else {
 364             if ((cpath = getName()) == null)
 365                 throw new NullPointerException(&quot;name can&#39;t be null&quot;);
 366 
 367             this.mask = mask;
 368 
 369             if (cpath.equals(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;)) {
<span class="line-added"> 370                 allFiles = true;</span>
 371                 directory = true;
 372                 recursive = true;
 373                 cpath = &quot;&quot;;
 374                 return;
 375             }
 376 
<span class="line-added"> 377             // Validate path by platform&#39;s default file system</span>
<span class="line-added"> 378             try {</span>
<span class="line-added"> 379                 String name = cpath.endsWith(&quot;*&quot;) ? cpath.substring(0, cpath.length() - 1) + &quot;-&quot; : cpath;</span>
<span class="line-added"> 380                 builtInFS.getPath(new File(name).getPath());</span>
<span class="line-added"> 381             } catch (InvalidPathException ipe) {</span>
<span class="line-added"> 382                 invalid = true;</span>
<span class="line-added"> 383                 return;</span>
<span class="line-added"> 384             }</span>
<span class="line-added"> 385 </span>
 386             // store only the canonical cpath if possible
 387             cpath = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 388                 public String run() {
 389                     try {
 390                         String path = cpath;
 391                         if (cpath.endsWith(&quot;*&quot;)) {
 392                             // call getCanonicalPath with a path with wildcard character
 393                             // replaced to avoid calling it with paths that are
 394                             // intended to match all entries in a directory
 395                             path = path.substring(0, path.length() - 1) + &quot;-&quot;;
 396                             path = new File(path).getCanonicalPath();
 397                             return path.substring(0, path.length() - 1) + &quot;*&quot;;
 398                         } else {
 399                             return new File(path).getCanonicalPath();
 400                         }
 401                     } catch (IOException ioe) {
 402                         return cpath;
 403                     }
 404                 }
 405             });
</pre>
<hr />
<pre>
 419                 cpath = cpath.substring(0, --len);
 420             } else {
 421                 // overkill since they are initialized to false, but
 422                 // commented out here to remind us...
 423                 //directory = false;
 424                 //recursive = false;
 425             }
 426 
 427             // XXX: at this point the path should be absolute. die if it isn&#39;t?
 428         }
 429     }
 430 
 431     /**
 432      * Creates a new FilePermission object with the specified actions.
 433      * &lt;i&gt;path&lt;/i&gt; is the pathname of a file or directory, and &lt;i&gt;actions&lt;/i&gt;
 434      * contains a comma-separated list of the desired actions granted on the
 435      * file or directory. Possible actions are
 436      * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;.
 437      *
 438      * &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified"> 439      * the file separator character, {@code File.separatorChar})</span>
 440      * indicates all the files and directories contained in that directory.
 441      * A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
 442      * subdirectories contained in that directory. The special pathname
 443      * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} matches any file.
 444      *
 445      * &lt;p&gt;A pathname consisting of a single &quot;*&quot; indicates all the files
 446      * in the current directory, while a pathname consisting of a single &quot;-&quot;
 447      * indicates all the files in the current directory and
 448      * (recursively) all files and subdirectories contained in the current
 449      * directory.
 450      *
 451      * &lt;p&gt;A pathname containing an empty string represents an empty path.
 452      *
 453      * @implNote In this implementation, the
<span class="line-modified"> 454      * {@systemProperty jdk.io.permissionsUseCanonicalPath} system property</span>
<span class="line-modified"> 455      * dictates how the {@code path} argument is processed and stored.</span>
 456      * &lt;P&gt;
 457      * If the value of the system property is set to {@code true}, {@code path}
 458      * is canonicalized and stored as a String object named {@code cpath}.
 459      * This means a relative path is converted to an absolute path, a Windows
 460      * DOS-style 8.3 path is expanded to a long path, and a symbolic link is
 461      * resolved to its target, etc.
 462      * &lt;P&gt;
 463      * If the value of the system property is set to {@code false}, {@code path}
 464      * is converted to a {@link java.nio.file.Path} object named {@code npath}
 465      * after {@link Path#normalize() normalization}. No canonicalization is
 466      * performed which means the underlying file system is not accessed.
 467      * If an {@link InvalidPathException} is thrown during the conversion,
 468      * this {@code FilePermission} will be labeled as invalid.
 469      * &lt;P&gt;
 470      * In either case, the &quot;*&quot; or &quot;-&quot; character at the end of a wildcard
 471      * {@code path} is removed before canonicalization or normalization.
 472      * It is stored in a separate wildcard flag field.
 473      * &lt;P&gt;
 474      * The default value of the {@code jdk.io.permissionsUseCanonicalPath}
 475      * system property is {@code false} in this implementation.
<span class="line-added"> 476      * &lt;p&gt;</span>
<span class="line-added"> 477      * The value can also be set with a security property using the same name,</span>
<span class="line-added"> 478      * but setting a system property will override the security property value.</span>
 479      *
 480      * @param path the pathname of the file/directory.
 481      * @param actions the action string.
 482      *
<span class="line-modified"> 483      * @throws IllegalArgumentException if actions is {@code null}, empty,</span>
<span class="line-modified"> 484      *         malformed or contains an action other than the specified</span>
<span class="line-modified"> 485      *         possible actions</span>
 486      */
 487     public FilePermission(String path, String actions) {
 488         super(path);
 489         init(getMask(actions));
 490     }
 491 
 492     /**
 493      * Creates a new FilePermission object using an action mask.
 494      * More efficient than the FilePermission(String, String) constructor.
 495      * Can be used from within
 496      * code that needs to create a FilePermission object to pass into the
<span class="line-modified"> 497      * {@code implies} method.</span>
 498      *
 499      * @param path the pathname of the file/directory.
 500      * @param mask the action mask to use.
 501      */
 502     // package private for use by the FilePermissionCollection add method
 503     FilePermission(String path, int mask) {
 504         super(path);
 505         init(mask);
 506     }
 507 
 508     /**
 509      * Checks if this FilePermission object &quot;implies&quot; the specified permission.
 510      * &lt;P&gt;
 511      * More specifically, this method returns true if:
 512      * &lt;ul&gt;
 513      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof FilePermission,
 514      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s actions are a proper subset of this
 515      * object&#39;s actions, and
 516      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s pathname is implied by this object&#39;s
 517      *      pathname. For example, &quot;/tmp/*&quot; implies &quot;/tmp/foo&quot;, since
</pre>
<hr />
<pre>
 543      * sequence) from the former the remaining part equals to the latter,
 544      * a simple {@code cpath} is recursively inside a wildcard {@code cpath}
 545      * if and only if the former starts with the latter.
 546      * &lt;p&gt;
 547      * If {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, a
 548      * simple {@code npath} is inside a wildcard {@code npath} if and only if
 549      * {@code  simple_npath.relativize(wildcard_npath)} is exactly &quot;..&quot;,
 550      * a simple {@code npath} is recursively inside a wildcard {@code npath}
 551      * if and only if {@code simple_npath.relativize(wildcard_npath)} is a
 552      * series of one or more &quot;..&quot;. This means &quot;/-&quot; implies &quot;/foo&quot; but not &quot;foo&quot;.
 553      * &lt;p&gt;
 554      * An invalid {@code FilePermission} does not imply any object except for
 555      * itself. An invalid {@code FilePermission} is not implied by any object
 556      * except for itself or a {@code FilePermission} on
 557      * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} whose actions is a superset of this
 558      * invalid {@code FilePermission}. Even if two {@code FilePermission}
 559      * are created with the same invalid path, one does not imply the other.
 560      *
 561      * @param p the permission to check against.
 562      *
<span class="line-modified"> 563      * @return {@code true} if the specified permission is not</span>
<span class="line-modified"> 564      *                  {@code null} and is implied by this object,</span>
<span class="line-modified"> 565      *                  {@code false} otherwise.</span>
 566      */
 567     @Override
 568     public boolean implies(Permission p) {
 569         if (!(p instanceof FilePermission))
 570             return false;
 571 
 572         FilePermission that = (FilePermission) p;
 573 
 574         // we get the effective mask. i.e., the &quot;and&quot; of this and that.
 575         // They must be equal to that.mask for implies to return true.
 576 
 577         return ((this.mask &amp; that.mask) == that.mask) &amp;&amp; impliesIgnoreMask(that);
 578     }
 579 
 580     /**
 581      * Checks if the Permission&#39;s actions are a proper subset of the
 582      * this object&#39;s actions. Returns the effective mask iff the
 583      * this FilePermission&#39;s path also implies that FilePermission&#39;s path.
 584      *
 585      * @param that the FilePermission to check against.
 586      * @return the effective mask
 587      */
 588     boolean impliesIgnoreMask(FilePermission that) {
<span class="line-added"> 589         if (this == that) {</span>
<span class="line-added"> 590             return true;</span>
<span class="line-added"> 591         }</span>
<span class="line-added"> 592         if (allFiles) {</span>
<span class="line-added"> 593             return true;</span>
<span class="line-added"> 594         }</span>
<span class="line-added"> 595         if (this.invalid || that.invalid) {</span>
<span class="line-added"> 596             return false;</span>
<span class="line-added"> 597         }</span>
<span class="line-added"> 598         if (that.allFiles) {</span>
<span class="line-added"> 599             return false;</span>
<span class="line-added"> 600         }</span>
 601         if (FilePermCompat.nb) {












 602             // Left at least same level of wildness as right
 603             if ((this.recursive &amp;&amp; that.recursive) != that.recursive
 604                     || (this.directory &amp;&amp; that.directory) != that.directory) {
 605                 return false;
 606             }
 607             // Same npath is good as long as both or neither are directories
 608             if (this.npath.equals(that.npath)
 609                     &amp;&amp; this.directory == that.directory) {
 610                 return true;
 611             }
 612             int diff = containsPath(this.npath, that.npath);
 613             // Right inside left is good if recursive
 614             if (diff &gt;= 1 &amp;&amp; recursive) {
 615                 return true;
 616             }
 617             // Right right inside left if it is element in set
 618             if (diff == 1 &amp;&amp; directory &amp;&amp; !that.directory) {
 619                 return true;
 620             }
 621 
</pre>
<hr />
<pre>
 765         // After removing the common heads, they become &quot;../..&quot; and &quot;a&quot;,
 766         // and the distance is (3-1)+(2-1) = 3.
 767         return c1 - i + c2 - i;
 768     }
 769 
 770     /**
 771      * Checks two FilePermission objects for equality. Checks that &lt;i&gt;obj&lt;/i&gt; is
 772      * a FilePermission, and has the same pathname and actions as this object.
 773      *
 774      * @implNote More specifically, two pathnames are the same if and only if
 775      * they have the same wildcard flag and their {@code cpath}
 776      * (if {@code jdk.io.permissionsUseCanonicalPath} is {@code true}) or
 777      * {@code npath} (if {@code jdk.io.permissionsUseCanonicalPath}
 778      * is {@code false}) are equal. Or they are both {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;}.
 779      * &lt;p&gt;
 780      * When {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, an
 781      * invalid {@code FilePermission} does not equal to any object except
 782      * for itself, even if they are created using the same invalid path.
 783      *
 784      * @param obj the object we are testing for equality with this object.
<span class="line-modified"> 785      * @return {@code true} if obj is a FilePermission, and has the same</span>
 786      *          pathname and actions as this FilePermission object,
<span class="line-modified"> 787      *          {@code false} otherwise.</span>
 788      */
 789     @Override
 790     public boolean equals(Object obj) {
 791         if (obj == this)
 792             return true;
 793 
 794         if (! (obj instanceof FilePermission))
 795             return false;
 796 
 797         FilePermission that = (FilePermission) obj;
 798 
<span class="line-added"> 799         if (this.invalid || that.invalid) {</span>
<span class="line-added"> 800             return false;</span>
<span class="line-added"> 801         }</span>
 802         if (FilePermCompat.nb) {



 803             return (this.mask == that.mask) &amp;&amp;
 804                     (this.allFiles == that.allFiles) &amp;&amp;
 805                     this.npath.equals(that.npath) &amp;&amp;
 806                     Objects.equals(npath2, that.npath2) &amp;&amp;
 807                     (this.directory == that.directory) &amp;&amp;
 808                     (this.recursive == that.recursive);
 809         } else {
 810             return (this.mask == that.mask) &amp;&amp;
<span class="line-added"> 811                     (this.allFiles == that.allFiles) &amp;&amp;</span>
 812                     this.cpath.equals(that.cpath) &amp;&amp;
 813                     (this.directory == that.directory) &amp;&amp;
 814                     (this.recursive == that.recursive);
 815         }
 816     }
 817 
 818     /**
 819      * Returns the hash code value for this object.
 820      *
 821      * @return a hash code value for this object.
 822      */
 823     @Override
 824     public int hashCode() {
 825         if (FilePermCompat.nb) {
 826             return Objects.hash(
 827                     mask, allFiles, directory, recursive, npath, npath2, invalid);
 828         } else {
 829             return 0;
 830         }
 831     }
</pre>
<hr />
<pre>
 918 
 919             } else if (i &gt;= 7 &amp;&amp; (a[i-7] == &#39;r&#39; || a[i-7] == &#39;R&#39;) &amp;&amp;
 920                                  (a[i-6] == &#39;e&#39; || a[i-6] == &#39;E&#39;) &amp;&amp;
 921                                  (a[i-5] == &#39;a&#39; || a[i-5] == &#39;A&#39;) &amp;&amp;
 922                                  (a[i-4] == &#39;d&#39; || a[i-4] == &#39;D&#39;) &amp;&amp;
 923                                  (a[i-3] == &#39;l&#39; || a[i-3] == &#39;L&#39;) &amp;&amp;
 924                                  (a[i-2] == &#39;i&#39; || a[i-2] == &#39;I&#39;) &amp;&amp;
 925                                  (a[i-1] == &#39;n&#39; || a[i-1] == &#39;N&#39;) &amp;&amp;
 926                                  (a[i] == &#39;k&#39; || a[i] == &#39;K&#39;))
 927             {
 928                 matchlen = 8;
 929                 mask |= READLINK;
 930 
 931             } else {
 932                 // parse error
 933                 throw new IllegalArgumentException(
 934                         &quot;invalid permission: &quot; + actions);
 935             }
 936 
 937             // make sure we didn&#39;t just match the tail of a word
<span class="line-modified"> 938             // like &quot;ackbarfdelete&quot;.  Also, skip to the comma.</span>
 939             boolean seencomma = false;
 940             while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified"> 941                 switch (c = a[i-matchlen]) {</span>



 942                 case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
 943                 case &#39;\f&#39;: case &#39;\t&#39;:
 944                     break;
 945                 default:
<span class="line-added"> 946                     if (c == &#39;,&#39; &amp;&amp; i &gt; matchlen) {</span>
<span class="line-added"> 947                         seencomma = true;</span>
<span class="line-added"> 948                         break;</span>
<span class="line-added"> 949                     }</span>
 950                     throw new IllegalArgumentException(
 951                             &quot;invalid permission: &quot; + actions);
 952                 }
 953                 i--;
 954             }
 955 
 956             // point i at the location of the comma minus one (or -1).
 957             i -= matchlen;
 958         }
 959 
 960         return mask;
 961     }
 962 
 963     /**
 964      * Return the current action mask. Used by the FilePermissionCollection.
 965      *
 966      * @return the actions mask.
 967      */
 968     int getMask() {
 969         return mask;
</pre>
<hr />
<pre>
 985         if ((mask &amp; WRITE) == WRITE) {
 986             sj.add(&quot;write&quot;);
 987         }
 988         if ((mask &amp; EXECUTE) == EXECUTE) {
 989             sj.add(&quot;execute&quot;);
 990         }
 991         if ((mask &amp; DELETE) == DELETE) {
 992             sj.add(&quot;delete&quot;);
 993         }
 994         if ((mask &amp; READLINK) == READLINK) {
 995             sj.add(&quot;readlink&quot;);
 996         }
 997 
 998         return sj.toString();
 999     }
1000 
1001     /**
1002      * Returns the &quot;canonical string representation&quot; of the actions.
1003      * That is, this method always returns present actions in the following order:
1004      * read, write, execute, delete, readlink. For example, if this FilePermission
<span class="line-modified">1005      * object allows both write and read actions, a call to {@code getActions}</span>
1006      * will return the string &quot;read,write&quot;.
1007      *
1008      * @return the canonical string representation of the actions.
1009      */
1010     @Override
1011     public String getActions() {
1012         if (actions == null)
1013             actions = getActions(this.mask);
1014 
1015         return actions;
1016     }
1017 
1018     /**
1019      * Returns a new PermissionCollection object for storing FilePermission
1020      * objects.
1021      * &lt;p&gt;
1022      * FilePermission objects must be stored in a manner that allows them
1023      * to be inserted into the collection in any order, but that also enables the
<span class="line-modified">1024      * PermissionCollection {@code implies}</span>
1025      * method to be implemented in an efficient (and consistent) manner.
1026      *
1027      * &lt;p&gt;For example, if you have two FilePermissions:
1028      * &lt;OL&gt;
<span class="line-modified">1029      * &lt;LI&gt;  {@code &quot;/tmp/-&quot;, &quot;read&quot;}</span>
<span class="line-modified">1030      * &lt;LI&gt;  {@code &quot;/tmp/scratch/foo&quot;, &quot;write&quot;}</span>
1031      * &lt;/OL&gt;
1032      *
<span class="line-modified">1033      * &lt;p&gt;and you are calling the {@code implies} method with the FilePermission:</span>
1034      *
1035      * &lt;pre&gt;
1036      *   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
1037      * &lt;/pre&gt;
1038      *
<span class="line-modified">1039      * then the {@code implies} function must</span>
1040      * take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
1041      * permissions, so the effective permission is &quot;read,write&quot;,
<span class="line-modified">1042      * and {@code implies} returns true. The &quot;implies&quot; semantics for</span>
1043      * FilePermissions are handled properly by the PermissionCollection object
<span class="line-modified">1044      * returned by this {@code newPermissionCollection} method.</span>
1045      *
1046      * @return a new PermissionCollection object suitable for storing
1047      * FilePermissions.
1048      */
1049     @Override
1050     public PermissionCollection newPermissionCollection() {
1051         return new FilePermissionCollection();
1052     }
1053 
1054     /**
1055      * WriteObject is called to save the state of the FilePermission
1056      * to a stream. The actions are serialized, and the superclass
1057      * takes care of the name.
1058      */
<span class="line-added">1059     @java.io.Serial</span>
1060     private void writeObject(ObjectOutputStream s)
1061         throws IOException
1062     {
1063         // Write out the actions. The superclass takes care of the name
1064         // call getActions to make sure actions field is initialized
1065         if (actions == null)
1066             getActions();
1067         s.defaultWriteObject();
1068     }
1069 
1070     /**
1071      * readObject is called to restore the state of the FilePermission from
1072      * a stream.
1073      */
<span class="line-added">1074     @java.io.Serial</span>
1075     private void readObject(ObjectInputStream s)
1076          throws IOException, ClassNotFoundException
1077     {
1078         // Read in the actions, then restore everything else by calling init.
1079         s.defaultReadObject();
1080         init(getMask(actions));
1081     }
1082 
1083     /**
1084      * Create a cloned FilePermission with a different actions.
1085      * @param effective the new actions
1086      * @return a new object
1087      */
1088     FilePermission withNewActions(int effective) {
1089         return new FilePermission(this.getName(),
1090                 this,
1091                 this.npath,
1092                 this.npath2,
1093                 effective,
1094                 null);
</pre>
<hr />
<pre>
1125 
1126 final class FilePermissionCollection extends PermissionCollection
1127     implements Serializable
1128 {
1129     // Not serialized; see serialization section at end of class
1130     private transient ConcurrentHashMap&lt;String, Permission&gt; perms;
1131 
1132     /**
1133      * Create an empty FilePermissionCollection object.
1134      */
1135     public FilePermissionCollection() {
1136         perms = new ConcurrentHashMap&lt;&gt;();
1137     }
1138 
1139     /**
1140      * Adds a permission to the FilePermissionCollection. The key for the hash is
1141      * permission.path.
1142      *
1143      * @param permission the Permission object to add.
1144      *
<span class="line-modified">1145      * @throws    IllegalArgumentException   if the permission is not a</span>
1146      *                                       FilePermission
1147      *
<span class="line-modified">1148      * @throws    SecurityException   if this FilePermissionCollection object</span>
1149      *                                has been marked readonly
1150      */
1151     @Override
1152     public void add(Permission permission) {
1153         if (! (permission instanceof FilePermission))
1154             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1155                                                permission);
1156         if (isReadOnly())
1157             throw new SecurityException(
1158                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
1159 
1160         FilePermission fp = (FilePermission)permission;
1161 
1162         // Add permission to map if it is absent, or replace with new
1163         // permission if applicable.
1164         perms.merge(fp.getName(), fp,
1165             new java.util.function.BiFunction&lt;&gt;() {
1166                 @Override
1167                 public Permission apply(Permission existingVal,
1168                                         Permission newVal) {
</pre>
<hr />
<pre>
1194      * the set, false if not.
1195      */
1196     @Override
1197     public boolean implies(Permission permission) {
1198         if (! (permission instanceof FilePermission))
1199             return false;
1200 
1201         FilePermission fperm = (FilePermission) permission;
1202 
1203         int desired = fperm.getMask();
1204         int effective = 0;
1205         int needed = desired;
1206 
1207         for (Permission perm : perms.values()) {
1208             FilePermission fp = (FilePermission)perm;
1209             if (((needed &amp; fp.getMask()) != 0) &amp;&amp; fp.impliesIgnoreMask(fperm)) {
1210                 effective |= fp.getMask();
1211                 if ((effective &amp; desired) == desired) {
1212                     return true;
1213                 }
<span class="line-modified">1214                 needed = (desired &amp; ~effective);</span>
1215             }
1216         }
1217         return false;
1218     }
1219 
1220     /**
1221      * Returns an enumeration of all the FilePermission objects in the
1222      * container.
1223      *
1224      * @return an enumeration of all the FilePermission objects.
1225      */
1226     @Override
1227     public Enumeration&lt;Permission&gt; elements() {
1228         return perms.elements();
1229     }
1230 
<span class="line-added">1231     @java.io.Serial</span>
1232     private static final long serialVersionUID = 2202956749081564585L;
1233 
1234     // Need to maintain serialization interoperability with earlier releases,
1235     // which had the serializable field:
1236     //    private Vector permissions;
1237 
1238     /**
1239      * @serialField permissions java.util.Vector
1240      *     A list of FilePermission objects.
1241      */
<span class="line-added">1242     @java.io.Serial</span>
1243     private static final ObjectStreamField[] serialPersistentFields = {
1244         new ObjectStreamField(&quot;permissions&quot;, Vector.class),
1245     };
1246 
1247     /**
1248      * @serialData &quot;permissions&quot; field (a Vector containing the FilePermissions).
1249      */
1250     /*
1251      * Writes the contents of the perms field out as a Vector for
1252      * serialization compatibility with earlier releases.
1253      */
<span class="line-added">1254     @java.io.Serial</span>
1255     private void writeObject(ObjectOutputStream out) throws IOException {
1256         // Don&#39;t call out.defaultWriteObject()
1257 
1258         // Write out Vector
1259         Vector&lt;Permission&gt; permissions = new Vector&lt;&gt;(perms.values());
1260 
1261         ObjectOutputStream.PutField pfields = out.putFields();
1262         pfields.put(&quot;permissions&quot;, permissions);
1263         out.writeFields();
1264     }
1265 
1266     /*
1267      * Reads in a Vector of FilePermissions and saves them in the perms field.
1268      */
<span class="line-added">1269     @java.io.Serial</span>
1270     private void readObject(ObjectInputStream in)
1271         throws IOException, ClassNotFoundException
1272     {
1273         // Don&#39;t call defaultReadObject()
1274 
1275         // Read in serialized fields
1276         ObjectInputStream.GetField gfields = in.readFields();
1277 
1278         // Get the one we want
1279         @SuppressWarnings(&quot;unchecked&quot;)
1280         Vector&lt;Permission&gt; permissions = (Vector&lt;Permission&gt;)gfields.get(&quot;permissions&quot;, null);
1281         perms = new ConcurrentHashMap&lt;&gt;(permissions.size());
1282         for (Permission perm : permissions) {
1283             perms.put(perm.getName(), perm);
1284         }
1285     }
1286 }
</pre>
</td>
</tr>
</table>
<center><a href="FileOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
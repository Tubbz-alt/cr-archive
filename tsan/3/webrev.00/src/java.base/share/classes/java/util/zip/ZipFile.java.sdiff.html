<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
<span class="line-removed">  37 import java.nio.charset.StandardCharsets;</span>
  38 import java.nio.file.InvalidPathException;
  39 import java.nio.file.attribute.BasicFileAttributes;
  40 import java.nio.file.Files;
  41 import java.util.ArrayDeque;
  42 import java.util.ArrayList;
  43 import java.util.Arrays;
  44 import java.util.Collections;
  45 import java.util.Deque;
  46 import java.util.Enumeration;
  47 import java.util.HashMap;
  48 import java.util.Iterator;
  49 import java.util.Objects;
  50 import java.util.NoSuchElementException;
  51 import java.util.Set;
  52 import java.util.Spliterator;
  53 import java.util.Spliterators;
  54 import java.util.WeakHashMap;
  55 import java.util.function.Consumer;
  56 import java.util.function.Function;
  57 import java.util.function.IntFunction;
  58 import java.util.jar.JarEntry;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 import jdk.internal.access.JavaLangAccess;
  62 import jdk.internal.access.JavaUtilZipFileAccess;
  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.perf.PerfCounter;
  66 import jdk.internal.ref.CleanerFactory;
  67 import jdk.internal.vm.annotation.Stable;

  68 
  69 import static java.util.zip.ZipConstants64.*;
  70 import static java.util.zip.ZipUtils.*;
  71 
  72 /**
  73  * This class is used to read entries from a zip file.
  74  *
  75  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  76  * or method in this class will cause a {@link NullPointerException} to be
  77  * thrown.
  78  *
  79  * @apiNote
  80  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  81  * should be called explicitly or by try-with-resources. Subclasses are responsible
  82  * for the cleanup of resources acquired by the subclass. Subclasses that override
  83  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  84  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  85  * {@code finalize} method.
  86  *
  87  * @author      David Connelly
  88  * @since 1.1
  89  */
<span class="line-modified">  90 public</span>
<span class="line-removed">  91 class ZipFile implements ZipConstants, Closeable {</span>
  92 
  93     private final String name;     // zip file name
  94     private volatile boolean closeRequested;
  95     private final @Stable ZipCoder zc;
  96 
  97     // The &quot;resource&quot; used by this zip file that needs to be
  98     // cleaned after use.
  99     // a) the input streams that need to be closed
 100     // b) the list of cached Inflater objects
 101     // c) the &quot;native&quot; source of this zip file.
 102     private final @Stable CleanableResource res;
 103 
 104     private static final int STORED = ZipEntry.STORED;
 105     private static final int DEFLATED = ZipEntry.DEFLATED;
 106 
 107     /**
 108      * Mode flag to open a zip file for reading.
 109      */
 110     public static final int OPEN_READ = 0x1;
 111 
</pre>
<hr />
<pre>
 149      * method is called with the {@code name} argument as its argument to
 150      * ensure the read is allowed.
 151      *
 152      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 153      * decode the entry names and comments
 154      *
 155      * @param file the ZIP file to be opened for reading
 156      * @param mode the mode in which the file is to be opened
 157      * @throws ZipException if a ZIP format error has occurred
 158      * @throws IOException if an I/O error has occurred
 159      * @throws SecurityException if a security manager exists and
 160      *         its {@code checkRead} method
 161      *         doesn&#39;t allow read access to the file,
 162      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 163      *         the file when the {@code OPEN_DELETE} flag is set.
 164      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 165      * @see SecurityManager#checkRead(java.lang.String)
 166      * @since 1.3
 167      */
 168     public ZipFile(File file, int mode) throws IOException {
<span class="line-modified"> 169         this(file, mode, StandardCharsets.UTF_8);</span>
 170     }
 171 
 172     /**
 173      * Opens a ZIP file for reading given the specified File object.
 174      *
 175      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 176      * decode the entry names and comments.
 177      *
 178      * @param file the ZIP file to be opened for reading
 179      * @throws ZipException if a ZIP format error has occurred
 180      * @throws IOException if an I/O error has occurred
 181      */
 182     public ZipFile(File file) throws ZipException, IOException {
 183         this(file, OPEN_READ);
 184     }
 185 
 186     /**
 187      * Opens a new {@code ZipFile} to read from the specified
 188      * {@code File} object in the specified mode.  The mode argument
 189      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
</pre>
<hr />
<pre>
 656         if (name == null || bname.length != nlen) {
 657             // to use the entry name stored in cen, if the passed in name is
 658             // (1) null, invoked from iterator, or
 659             // (2) not equal to the name stored, a slash is appended during
 660             // getEntryPos() search.
 661             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 662                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);
 663             } else {
 664                 name = zc.toString(cen, pos + CENHDR, nlen);
 665             }
 666         }
 667         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
 668         e.flag = flag;
 669         e.xdostime = CENTIM(cen, pos);
 670         e.crc = CENCRC(cen, pos);
 671         e.size = CENLEN(cen, pos);
 672         e.csize = CENSIZ(cen, pos);
 673         e.method = CENHOW(cen, pos);
 674         if (elen != 0) {
 675             int start = pos + CENHDR + nlen;
<span class="line-modified"> 676             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true);</span>
 677         }
 678         if (clen != 0) {
 679             int start = pos + CENHDR + nlen + elen;
 680             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 681                 e.comment = zc.toStringUTF8(cen, start, clen);
 682             } else {
 683                 e.comment = zc.toString(cen, start, clen);
 684             }
 685         }
 686         lastEntryName = e.name;
 687         lastEntryPos = pos;
 688         return e;
 689     }
 690 
 691     /**
 692      * Returns the number of entries in the ZIP file.
 693      *
 694      * @return the number of entries in the ZIP file
 695      * @throws IllegalStateException if the zip file has been closed
 696      */
</pre>
<hr />
<pre>
 850             throw new IllegalStateException(&quot;zip file closed&quot;);
 851         }
 852         if (res.zsrc == null) {
 853             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 854         }
 855     }
 856 
 857     private void ensureOpenOrZipException() throws IOException {
 858         if (closeRequested) {
 859             throw new ZipException(&quot;ZipFile closed&quot;);
 860         }
 861     }
 862 
 863     /*
 864      * Inner class implementing the input stream used to read a
 865      * (possibly compressed) zip file entry.
 866      */
 867     private class ZipFileInputStream extends InputStream {
 868         private volatile boolean closeRequested;
 869         private   long pos;     // current position within entry data

 870         protected long rem;     // number of remaining bytes within entry
 871         protected long size;    // uncompressed size of this entry
 872 
 873         ZipFileInputStream(byte[] cen, int cenpos) {
 874             rem = CENSIZ(cen, cenpos);
 875             size = CENLEN(cen, cenpos);
 876             pos = CENOFF(cen, cenpos);
 877             // zip64
 878             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 879                 pos == ZIP64_MAGICVAL) {
 880                 checkZIP64(cen, cenpos);
 881             }
 882             // negative for lazy initialization, see getDataOffset();
 883             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 884         }
 885 
 886         private void checkZIP64(byte[] cen, int cenpos) {
 887             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 888             int end = off + CENEXT(cen, cenpos);
 889             while (off + 4 &lt; end) {
</pre>
<hr />
<pre>
 921         }
 922 
 923         /*
 924          * The Zip file spec explicitly allows the LOC extra data size to
 925          * be different from the CEN extra data size. Since we cannot trust
 926          * the CEN extra data size, we need to read the LOC to determine
 927          * the entry data offset.
 928          */
 929         private long initDataOffset() throws IOException {
 930             if (pos &lt;= 0) {
 931                 byte[] loc = new byte[LOCHDR];
 932                 pos = -pos;
 933                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 934                 if (len != LOCHDR) {
 935                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 936                 }
 937                 if (LOCSIG(loc) != LOCSIG) {
 938                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 939                 }
 940                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);

 941             }
 942             return pos;
 943         }
 944 
 945         public int read(byte b[], int off, int len) throws IOException {
 946             synchronized (ZipFile.this) {
 947                 ensureOpenOrZipException();
 948                 initDataOffset();
 949                 if (rem == 0) {
 950                     return -1;
 951                 }
 952                 if (len &gt; rem) {
 953                     len = (int) rem;
 954                 }
 955                 if (len &lt;= 0) {
 956                     return 0;
 957                 }
 958                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 959                 if (len &gt; 0) {
 960                     pos += len;
</pre>
<hr />
<pre>
 962                 }
 963             }
 964             if (rem == 0) {
 965                 close();
 966             }
 967             return len;
 968         }
 969 
 970         public int read() throws IOException {
 971             byte[] b = new byte[1];
 972             if (read(b, 0, 1) == 1) {
 973                 return b[0] &amp; 0xff;
 974             } else {
 975                 return -1;
 976             }
 977         }
 978 
 979         public long skip(long n) throws IOException {
 980             synchronized (ZipFile.this) {
 981                 initDataOffset();
<span class="line-modified"> 982                 if (n &gt; rem) {</span>
<span class="line-modified"> 983                     n = rem;</span>











 984                 }
 985                 pos += n;
 986                 rem -= n;
 987             }
 988             if (rem == 0) {
 989                 close();
 990             }
 991             return n;
 992         }
 993 
 994         public int available() {
 995             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
 996         }
 997 
 998         public long size() {
 999             return size;
1000         }
1001 
1002         public void close() {
1003             if (closeRequested) {
</pre>
<hr />
<pre>
1013     }
1014 
1015     /**
1016      * Returns the names of all non-directory entries that begin with
1017      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via
1018      * SharedSecrets, as an optimization when looking up manifest and
1019      * signature file entries. Returns null if no entries were found.
1020      */
1021     private String[] getMetaInfEntryNames() {
1022         synchronized (this) {
1023             ensureOpen();
1024             Source zsrc = res.zsrc;
1025             if (zsrc.metanames == null) {
1026                 return null;
1027             }
1028             String[] names = new String[zsrc.metanames.length];
1029             byte[] cen = zsrc.cen;
1030             for (int i = 0; i &lt; names.length; i++) {
1031                 int pos = zsrc.metanames[i];
1032                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
<span class="line-modified">1033                                       StandardCharsets.UTF_8);</span>
1034             }
1035             return names;
1036         }
1037     }
1038 
1039     private static boolean isWindows;
1040     private static final JavaLangAccess JLA;
1041 
1042     static {
1043         SharedSecrets.setJavaUtilZipFileAccess(
1044             new JavaUtilZipFileAccess() {
1045                 @Override
1046                 public boolean startsWithLocHeader(ZipFile zip) {
1047                     return zip.res.zsrc.startsWithLoc;
1048                 }
1049                 @Override
1050                 public String[] getMetaInfEntryNames(ZipFile zip) {
1051                     return zip.getMetaInfEntryNames();
1052                 }
1053                 @Override
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;

  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
  53 import java.util.WeakHashMap;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.function.IntFunction;
  57 import java.util.jar.JarEntry;
  58 import java.util.stream.Stream;
  59 import java.util.stream.StreamSupport;
  60 import jdk.internal.access.JavaLangAccess;
  61 import jdk.internal.access.JavaUtilZipFileAccess;
  62 import jdk.internal.access.SharedSecrets;
  63 import jdk.internal.misc.VM;
  64 import jdk.internal.perf.PerfCounter;
  65 import jdk.internal.ref.CleanerFactory;
  66 import jdk.internal.vm.annotation.Stable;
<span class="line-added">  67 import sun.nio.cs.UTF_8;</span>
  68 
  69 import static java.util.zip.ZipConstants64.*;
  70 import static java.util.zip.ZipUtils.*;
  71 
  72 /**
  73  * This class is used to read entries from a zip file.
  74  *
  75  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  76  * or method in this class will cause a {@link NullPointerException} to be
  77  * thrown.
  78  *
  79  * @apiNote
  80  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  81  * should be called explicitly or by try-with-resources. Subclasses are responsible
  82  * for the cleanup of resources acquired by the subclass. Subclasses that override
  83  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  84  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  85  * {@code finalize} method.
  86  *
  87  * @author      David Connelly
  88  * @since 1.1
  89  */
<span class="line-modified">  90 public class ZipFile implements ZipConstants, Closeable {</span>

  91 
  92     private final String name;     // zip file name
  93     private volatile boolean closeRequested;
  94     private final @Stable ZipCoder zc;
  95 
  96     // The &quot;resource&quot; used by this zip file that needs to be
  97     // cleaned after use.
  98     // a) the input streams that need to be closed
  99     // b) the list of cached Inflater objects
 100     // c) the &quot;native&quot; source of this zip file.
 101     private final @Stable CleanableResource res;
 102 
 103     private static final int STORED = ZipEntry.STORED;
 104     private static final int DEFLATED = ZipEntry.DEFLATED;
 105 
 106     /**
 107      * Mode flag to open a zip file for reading.
 108      */
 109     public static final int OPEN_READ = 0x1;
 110 
</pre>
<hr />
<pre>
 148      * method is called with the {@code name} argument as its argument to
 149      * ensure the read is allowed.
 150      *
 151      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 152      * decode the entry names and comments
 153      *
 154      * @param file the ZIP file to be opened for reading
 155      * @param mode the mode in which the file is to be opened
 156      * @throws ZipException if a ZIP format error has occurred
 157      * @throws IOException if an I/O error has occurred
 158      * @throws SecurityException if a security manager exists and
 159      *         its {@code checkRead} method
 160      *         doesn&#39;t allow read access to the file,
 161      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 162      *         the file when the {@code OPEN_DELETE} flag is set.
 163      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 164      * @see SecurityManager#checkRead(java.lang.String)
 165      * @since 1.3
 166      */
 167     public ZipFile(File file, int mode) throws IOException {
<span class="line-modified"> 168         this(file, mode, UTF_8.INSTANCE);</span>
 169     }
 170 
 171     /**
 172      * Opens a ZIP file for reading given the specified File object.
 173      *
 174      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 175      * decode the entry names and comments.
 176      *
 177      * @param file the ZIP file to be opened for reading
 178      * @throws ZipException if a ZIP format error has occurred
 179      * @throws IOException if an I/O error has occurred
 180      */
 181     public ZipFile(File file) throws ZipException, IOException {
 182         this(file, OPEN_READ);
 183     }
 184 
 185     /**
 186      * Opens a new {@code ZipFile} to read from the specified
 187      * {@code File} object in the specified mode.  The mode argument
 188      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
</pre>
<hr />
<pre>
 655         if (name == null || bname.length != nlen) {
 656             // to use the entry name stored in cen, if the passed in name is
 657             // (1) null, invoked from iterator, or
 658             // (2) not equal to the name stored, a slash is appended during
 659             // getEntryPos() search.
 660             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 661                 name = zc.toStringUTF8(cen, pos + CENHDR, nlen);
 662             } else {
 663                 name = zc.toString(cen, pos + CENHDR, nlen);
 664             }
 665         }
 666         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);
 667         e.flag = flag;
 668         e.xdostime = CENTIM(cen, pos);
 669         e.crc = CENCRC(cen, pos);
 670         e.size = CENLEN(cen, pos);
 671         e.csize = CENSIZ(cen, pos);
 672         e.method = CENHOW(cen, pos);
 673         if (elen != 0) {
 674             int start = pos + CENHDR + nlen;
<span class="line-modified"> 675             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);</span>
 676         }
 677         if (clen != 0) {
 678             int start = pos + CENHDR + nlen + elen;
 679             if (!zc.isUTF8() &amp;&amp; (flag &amp; USE_UTF8) != 0) {
 680                 e.comment = zc.toStringUTF8(cen, start, clen);
 681             } else {
 682                 e.comment = zc.toString(cen, start, clen);
 683             }
 684         }
 685         lastEntryName = e.name;
 686         lastEntryPos = pos;
 687         return e;
 688     }
 689 
 690     /**
 691      * Returns the number of entries in the ZIP file.
 692      *
 693      * @return the number of entries in the ZIP file
 694      * @throws IllegalStateException if the zip file has been closed
 695      */
</pre>
<hr />
<pre>
 849             throw new IllegalStateException(&quot;zip file closed&quot;);
 850         }
 851         if (res.zsrc == null) {
 852             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 853         }
 854     }
 855 
 856     private void ensureOpenOrZipException() throws IOException {
 857         if (closeRequested) {
 858             throw new ZipException(&quot;ZipFile closed&quot;);
 859         }
 860     }
 861 
 862     /*
 863      * Inner class implementing the input stream used to read a
 864      * (possibly compressed) zip file entry.
 865      */
 866     private class ZipFileInputStream extends InputStream {
 867         private volatile boolean closeRequested;
 868         private   long pos;     // current position within entry data
<span class="line-added"> 869         private   long startingPos; // Start position for the entry data</span>
 870         protected long rem;     // number of remaining bytes within entry
 871         protected long size;    // uncompressed size of this entry
 872 
 873         ZipFileInputStream(byte[] cen, int cenpos) {
 874             rem = CENSIZ(cen, cenpos);
 875             size = CENLEN(cen, cenpos);
 876             pos = CENOFF(cen, cenpos);
 877             // zip64
 878             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 879                 pos == ZIP64_MAGICVAL) {
 880                 checkZIP64(cen, cenpos);
 881             }
 882             // negative for lazy initialization, see getDataOffset();
 883             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 884         }
 885 
 886         private void checkZIP64(byte[] cen, int cenpos) {
 887             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 888             int end = off + CENEXT(cen, cenpos);
 889             while (off + 4 &lt; end) {
</pre>
<hr />
<pre>
 921         }
 922 
 923         /*
 924          * The Zip file spec explicitly allows the LOC extra data size to
 925          * be different from the CEN extra data size. Since we cannot trust
 926          * the CEN extra data size, we need to read the LOC to determine
 927          * the entry data offset.
 928          */
 929         private long initDataOffset() throws IOException {
 930             if (pos &lt;= 0) {
 931                 byte[] loc = new byte[LOCHDR];
 932                 pos = -pos;
 933                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 934                 if (len != LOCHDR) {
 935                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 936                 }
 937                 if (LOCSIG(loc) != LOCSIG) {
 938                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 939                 }
 940                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
<span class="line-added"> 941                 startingPos = pos; // Save starting position for the entry</span>
 942             }
 943             return pos;
 944         }
 945 
 946         public int read(byte b[], int off, int len) throws IOException {
 947             synchronized (ZipFile.this) {
 948                 ensureOpenOrZipException();
 949                 initDataOffset();
 950                 if (rem == 0) {
 951                     return -1;
 952                 }
 953                 if (len &gt; rem) {
 954                     len = (int) rem;
 955                 }
 956                 if (len &lt;= 0) {
 957                     return 0;
 958                 }
 959                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 960                 if (len &gt; 0) {
 961                     pos += len;
</pre>
<hr />
<pre>
 963                 }
 964             }
 965             if (rem == 0) {
 966                 close();
 967             }
 968             return len;
 969         }
 970 
 971         public int read() throws IOException {
 972             byte[] b = new byte[1];
 973             if (read(b, 0, 1) == 1) {
 974                 return b[0] &amp; 0xff;
 975             } else {
 976                 return -1;
 977             }
 978         }
 979 
 980         public long skip(long n) throws IOException {
 981             synchronized (ZipFile.this) {
 982                 initDataOffset();
<span class="line-modified"> 983                 long newPos = pos + n;</span>
<span class="line-modified"> 984                 if (n &gt; 0) {</span>
<span class="line-added"> 985                     // If we overflowed adding the skip value or are moving</span>
<span class="line-added"> 986                     // past EOF, set the skip value to number of bytes remaining</span>
<span class="line-added"> 987                     // to reach EOF</span>
<span class="line-added"> 988                     if (newPos &lt; 0 || n &gt; rem) {</span>
<span class="line-added"> 989                         n = rem;</span>
<span class="line-added"> 990                     }</span>
<span class="line-added"> 991                 } else if (newPos &lt; startingPos) {</span>
<span class="line-added"> 992                     // Tried to position before BOF so set position to the</span>
<span class="line-added"> 993                     // BOF and return the number of bytes we moved backwards</span>
<span class="line-added"> 994                     // to reach BOF</span>
<span class="line-added"> 995                     n = startingPos - pos;</span>
 996                 }
 997                 pos += n;
 998                 rem -= n;
 999             }
1000             if (rem == 0) {
1001                 close();
1002             }
1003             return n;
1004         }
1005 
1006         public int available() {
1007             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
1008         }
1009 
1010         public long size() {
1011             return size;
1012         }
1013 
1014         public void close() {
1015             if (closeRequested) {
</pre>
<hr />
<pre>
1025     }
1026 
1027     /**
1028      * Returns the names of all non-directory entries that begin with
1029      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via
1030      * SharedSecrets, as an optimization when looking up manifest and
1031      * signature file entries. Returns null if no entries were found.
1032      */
1033     private String[] getMetaInfEntryNames() {
1034         synchronized (this) {
1035             ensureOpen();
1036             Source zsrc = res.zsrc;
1037             if (zsrc.metanames == null) {
1038                 return null;
1039             }
1040             String[] names = new String[zsrc.metanames.length];
1041             byte[] cen = zsrc.cen;
1042             for (int i = 0; i &lt; names.length; i++) {
1043                 int pos = zsrc.metanames[i];
1044                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),
<span class="line-modified">1045                                       UTF_8.INSTANCE);</span>
1046             }
1047             return names;
1048         }
1049     }
1050 
1051     private static boolean isWindows;
1052     private static final JavaLangAccess JLA;
1053 
1054     static {
1055         SharedSecrets.setJavaUtilZipFileAccess(
1056             new JavaUtilZipFileAccess() {
1057                 @Override
1058                 public boolean startsWithLocHeader(ZipFile zip) {
1059                     return zip.res.zsrc.startsWithLoc;
1060                 }
1061                 @Override
1062                 public String[] getMetaInfEntryNames(ZipFile zip) {
1063                     return zip.getMetaInfEntryNames();
1064                 }
1065                 @Override
</pre>
</td>
</tr>
</table>
<center><a href="ZipException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/net/SocketImpl.java b/src/java.base/share/classes/java/net/SocketImpl.java
--- a/src/java.base/share/classes/java/net/SocketImpl.java
+++ b/src/java.base/share/classes/java/net/SocketImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,33 +23,68 @@
  * questions.
  */
 
 package java.net;
 
+import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.FileDescriptor;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Objects;
 import java.util.Set;
 
+import sun.net.NetProperties;
+import sun.net.PlatformSocketImpl;
+import sun.nio.ch.NioSocketImpl;
+
 /**
  * The abstract class {@code SocketImpl} is a common superclass
  * of all classes that actually implement sockets. It is used to
  * create both client and server sockets.
- * <p>
- * A "plain" socket implements these methods exactly as
- * described, without attempting to go through a firewall or proxy.
+ *
+ * @implNote Client and server sockets created with the {@code Socket} and
+ * {@code SocketServer} public constructors create a system-default
+ * {@code SocketImpl}. The JDK historically used a {@code SocketImpl}
+ * implementation type named "PlainSocketImpl" that has since been replaced by a
+ * newer implementation. The JDK continues to ship with the older implementation
+ * to allow code to run that depends on unspecified behavior that differs between
+ * the old and new implementations. The old implementation will be used if the
+ * Java virtual machine is started with the system property {@systemProperty
+ * jdk.net.usePlainSocketImpl} set to use the old implementation. It may also be
+ * set in the JDK's network configuration file, located in {@code
+ * ${java.home}/conf/net.properties}. The value of the property is the string
+ * representation of a boolean. If set without a value then it defaults to {@code
+ * true}, hence running with {@code -Djdk.net.usePlainSocketImpl} or {@code
+ * -Djdk.net.usePlainSocketImpl=true} will configure the Java virtual machine
+ * to use the old implementation. The property and old implementation will be
+ * removed in a future version.
  *
  * @author  unascribed
  * @since   1.0
  */
 public abstract class SocketImpl implements SocketOptions {
+    private static final boolean USE_PLAINSOCKETIMPL = usePlainSocketImpl();
+
+    private static boolean usePlainSocketImpl() {
+        PrivilegedAction<String> pa = () -> NetProperties.get("jdk.net.usePlainSocketImpl");
+        String s = AccessController.doPrivileged(pa);
+        return (s != null) && !s.equalsIgnoreCase("false");
+    }
+
     /**
-     * The actual Socket object.
+     * Creates an instance of platform's SocketImpl
      */
-    Socket socket = null;
-    ServerSocket serverSocket = null;
+    @SuppressWarnings("unchecked")
+    static <S extends SocketImpl & PlatformSocketImpl> S createPlatformSocketImpl(boolean server) {
+        if (USE_PLAINSOCKETIMPL) {
+            return (S) new PlainSocketImpl(server);
+        } else {
+            return (S) new NioSocketImpl(server);
+        }
+    }
 
     /**
      * The file descriptor object for this socket.
      */
     protected FileDescriptor fd;
@@ -67,36 +102,41 @@
     /**
      * The local port number to which this socket is connected.
      */
     protected int localport;
 
+    /**
+     * Initialize a new instance of this class
+     */
+    public SocketImpl() { }
+
     /**
      * Creates either a stream or a datagram socket.
      *
      * @param      stream   if {@code true}, create a stream socket;
      *                      otherwise, create a datagram socket.
-     * @exception  IOException  if an I/O error occurs while creating the
+     * @throws     IOException  if an I/O error occurs while creating the
      *               socket.
      */
     protected abstract void create(boolean stream) throws IOException;
 
     /**
      * Connects this socket to the specified port on the named host.
      *
      * @param      host   the name of the remote host.
      * @param      port   the port number.
-     * @exception  IOException  if an I/O error occurs when connecting to the
+     * @throws     IOException  if an I/O error occurs when connecting to the
      *               remote host.
      */
     protected abstract void connect(String host, int port) throws IOException;
 
     /**
      * Connects this socket to the specified port number on the specified host.
      *
      * @param      address   the IP address of the remote host.
      * @param      port      the port number.
-     * @exception  IOException  if an I/O error occurs when attempting a
+     * @throws     IOException  if an I/O error occurs when attempting a
      *               connection.
      */
     protected abstract void connect(InetAddress address, int port) throws IOException;
 
     /**
@@ -104,91 +144,100 @@
      * A timeout of zero is interpreted as an infinite timeout. The connection
      * will then block until established or an error occurs.
      *
      * @param      address   the Socket address of the remote host.
      * @param     timeout  the timeout value, in milliseconds, or zero for no timeout.
-     * @exception  IOException  if an I/O error occurs when attempting a
+     * @throws     IOException  if an I/O error occurs when attempting a
      *               connection.
      * @since 1.4
      */
     protected abstract void connect(SocketAddress address, int timeout) throws IOException;
 
     /**
      * Binds this socket to the specified local IP address and port number.
      *
      * @param      host   an IP address that belongs to a local interface.
      * @param      port   the port number.
-     * @exception  IOException  if an I/O error occurs when binding this socket.
+     * @throws     IOException  if an I/O error occurs when binding this socket.
      */
     protected abstract void bind(InetAddress host, int port) throws IOException;
 
     /**
      * Sets the maximum queue length for incoming connection indications
      * (a request to connect) to the {@code count} argument. If a
      * connection indication arrives when the queue is full, the
      * connection is refused.
      *
      * @param      backlog   the maximum length of the queue.
-     * @exception  IOException  if an I/O error occurs when creating the queue.
+     * @throws     IOException  if an I/O error occurs when creating the queue.
      */
     protected abstract void listen(int backlog) throws IOException;
 
     /**
      * Accepts a connection.
      *
      * @param      s   the accepted connection.
-     * @exception  IOException  if an I/O error occurs when accepting the
+     * @throws     IOException  if an I/O error occurs when accepting the
      *               connection.
      */
     protected abstract void accept(SocketImpl s) throws IOException;
 
     /**
      * Returns an input stream for this socket.
      *
      * @return     a stream for reading from this socket.
-     * @exception  IOException  if an I/O error occurs when creating the
+     * @throws     IOException  if an I/O error occurs when creating the
      *               input stream.
     */
     protected abstract InputStream getInputStream() throws IOException;
 
     /**
      * Returns an output stream for this socket.
      *
      * @return     an output stream for writing to this socket.
-     * @exception  IOException  if an I/O error occurs when creating the
+     * @throws     IOException  if an I/O error occurs when creating the
      *               output stream.
      */
     protected abstract OutputStream getOutputStream() throws IOException;
 
     /**
      * Returns the number of bytes that can be read from this socket
      * without blocking.
      *
      * @return     the number of bytes that can be read from this socket
      *             without blocking.
-     * @exception  IOException  if an I/O error occurs when determining the
+     * @throws     IOException  if an I/O error occurs when determining the
      *               number of bytes available.
      */
     protected abstract int available() throws IOException;
 
     /**
      * Closes this socket.
      *
-     * @exception  IOException  if an I/O error occurs when closing this socket.
+     * @throws     IOException  if an I/O error occurs when closing this socket.
      */
     protected abstract void close() throws IOException;
 
+    /**
+     * Closes this socket, ignoring any IOException that is thrown by close.
+     */
+    void closeQuietly() {
+        try {
+            close();
+        } catch (IOException ignore) { }
+    }
+
     /**
      * Places the input stream for this socket at "end of stream".
      * Any data sent to this socket is acknowledged and then
      * silently discarded.
      *
      * If you read from a socket input stream after invoking this method on the
      * socket, the stream's {@code available} method will return 0, and its
      * {@code read} methods will return {@code -1} (end of stream).
      *
-     * @exception IOException if an I/O error occurs when shutting down this
+     * @throws    IOException if an I/O error occurs when shutting down this
      * socket.
      * @see java.net.Socket#shutdownOutput()
      * @see java.net.Socket#close()
      * @see java.net.Socket#setSoLinger(boolean, int)
      * @since 1.3
@@ -204,11 +253,11 @@
      *
      * If you write to a socket output stream after invoking
      * shutdownOutput() on the socket, the stream will throw
      * an IOException.
      *
-     * @exception IOException if an I/O error occurs when shutting down this
+     * @throws    IOException if an I/O error occurs when shutting down this
      * socket.
      * @see java.net.Socket#shutdownInput()
      * @see java.net.Socket#close()
      * @see java.net.Socket#setSoLinger(boolean, int)
      * @since 1.3
@@ -262,11 +311,11 @@
 
     /**
      * Send one byte of urgent data on the socket.
      * The byte to be sent is the low eight bits of the parameter
      * @param data The byte of data to send
-     * @exception IOException if there is an error
+     * @throws    IOException if there is an error
      *  sending the data.
      * @since 1.4
      */
     protected abstract void sendUrgentData (int data) throws IOException;
 
@@ -278,37 +327,22 @@
      */
     protected int getLocalPort() {
         return localport;
     }
 
-    void setSocket(Socket soc) {
-        this.socket = soc;
-    }
-
-    Socket getSocket() {
-        return socket;
-    }
-
-    void setServerSocket(ServerSocket soc) {
-        this.serverSocket = soc;
-    }
-
-    ServerSocket getServerSocket() {
-        return serverSocket;
-    }
-
     /**
      * Returns the address and port of this socket as a {@code String}.
      *
      * @return  a string representation of this socket.
      */
     public String toString() {
         return "Socket[addr=" + getInetAddress() +
             ",port=" + getPort() + ",localport=" + getLocalPort()  + "]";
     }
 
-    void reset() throws IOException {
+    void reset() {
+        fd = null;
         address = null;
         port = 0;
         localport = 0;
     }
 
@@ -358,122 +392,84 @@
     }
 
     /**
      * Called to set a socket option.
      *
+     * @implSpec
+     * The default implementation of this method first checks that the given
+     * socket option {@code name} is not null, then throws {@code
+     * UnsupportedOperationException}. Subclasses should override this method
+     * with an appropriate implementation.
+     *
      * @param <T> The type of the socket option value
      * @param name The socket option
-     *
      * @param value The value of the socket option. A value of {@code null}
      *              may be valid for some options.
      *
      * @throws UnsupportedOperationException if the SocketImpl does not
      *         support the option
-     *
-     * @throws IOException if an I/O error occurs, or if the socket is closed.
+     * @throws IllegalArgumentException if the value is not valid for
+     *         the option
+     * @throws IOException if an I/O error occurs, or if the socket is closed
+     * @throws NullPointerException if name is {@code null}
      *
      * @since 9
      */
     protected <T> void setOption(SocketOption<T> name, T value) throws IOException {
-        if (name == StandardSocketOptions.SO_KEEPALIVE &&
-                (getSocket() != null)) {
-            setOption(SocketOptions.SO_KEEPALIVE, value);
-        } else if (name == StandardSocketOptions.SO_SNDBUF &&
-                (getSocket() != null)) {
-            setOption(SocketOptions.SO_SNDBUF, value);
-        } else if (name == StandardSocketOptions.SO_RCVBUF) {
-            setOption(SocketOptions.SO_RCVBUF, value);
-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
-            setOption(SocketOptions.SO_REUSEADDR, value);
-        } else if (name == StandardSocketOptions.SO_REUSEPORT &&
-            supportedOptions().contains(name)) {
-            setOption(SocketOptions.SO_REUSEPORT, value);
-        } else if (name == StandardSocketOptions.SO_LINGER &&
-                (getSocket() != null)) {
-            setOption(SocketOptions.SO_LINGER, value);
-        } else if (name == StandardSocketOptions.IP_TOS) {
-            setOption(SocketOptions.IP_TOS, value);
-        } else if (name == StandardSocketOptions.TCP_NODELAY &&
-                (getSocket() != null)) {
-            setOption(SocketOptions.TCP_NODELAY, value);
-        } else {
-            throw new UnsupportedOperationException("unsupported option");
-        }
+        Objects.requireNonNull(name);
+        throw new UnsupportedOperationException("'" + name + "' not supported");
     }
 
     /**
      * Called to get a socket option.
      *
+     * @implSpec
+     * The default implementation of this method first checks that the given
+     * socket option {@code name} is not null, then throws {@code
+     * UnsupportedOperationException}. Subclasses should override this method
+     * with an appropriate implementation.
+     *
      * @param <T> The type of the socket option value
      * @param name The socket option
-     *
      * @return the value of the named option
      *
      * @throws UnsupportedOperationException if the SocketImpl does not
-     *         support the option.
-     *
-     * @throws IOException if an I/O error occurs, or if the socket is closed.
+     *         support the option
+     * @throws IOException if an I/O error occurs, or if the socket is closed
+     * @throws NullPointerException if name is {@code null}
      *
      * @since 9
      */
-    @SuppressWarnings("unchecked")
     protected <T> T getOption(SocketOption<T> name) throws IOException {
-        if (name == StandardSocketOptions.SO_KEEPALIVE &&
-                (getSocket() != null)) {
-            return (T)getOption(SocketOptions.SO_KEEPALIVE);
-        } else if (name == StandardSocketOptions.SO_SNDBUF &&
-                (getSocket() != null)) {
-            return (T)getOption(SocketOptions.SO_SNDBUF);
-        } else if (name == StandardSocketOptions.SO_RCVBUF) {
-            return (T)getOption(SocketOptions.SO_RCVBUF);
-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
-            return (T)getOption(SocketOptions.SO_REUSEADDR);
-        } else if (name == StandardSocketOptions.SO_REUSEPORT &&
-            supportedOptions().contains(name)) {
-            return (T)getOption(SocketOptions.SO_REUSEPORT);
-        } else if (name == StandardSocketOptions.SO_LINGER &&
-                (getSocket() != null)) {
-            return (T)getOption(SocketOptions.SO_LINGER);
-        } else if (name == StandardSocketOptions.IP_TOS) {
-            return (T)getOption(SocketOptions.IP_TOS);
-        } else if (name == StandardSocketOptions.TCP_NODELAY &&
-                (getSocket() != null)) {
-            return (T)getOption(SocketOptions.TCP_NODELAY);
-        } else {
-            throw new UnsupportedOperationException("unsupported option");
-        }
+        Objects.requireNonNull(name);
+        throw new UnsupportedOperationException("'" + name + "' not supported");
     }
 
-    private static final Set<SocketOption<?>> socketOptions;
-
-    private static final Set<SocketOption<?>> serverSocketOptions;
-
-    static {
-        socketOptions = Set.of(StandardSocketOptions.SO_KEEPALIVE,
-                               StandardSocketOptions.SO_SNDBUF,
-                               StandardSocketOptions.SO_RCVBUF,
-                               StandardSocketOptions.SO_REUSEADDR,
-                               StandardSocketOptions.SO_LINGER,
-                               StandardSocketOptions.IP_TOS,
-                               StandardSocketOptions.TCP_NODELAY);
-
-        serverSocketOptions = Set.of(StandardSocketOptions.SO_RCVBUF,
-                                     StandardSocketOptions.SO_REUSEADDR,
-                                     StandardSocketOptions.IP_TOS);
+    /**
+     * Attempts to copy socket options from this SocketImpl to a target SocketImpl.
+     * At this time, only the SO_TIMEOUT make sense to copy.
+     */
+    void copyOptionsTo(SocketImpl target) {
+        try {
+            Object timeout = getOption(SocketOptions.SO_TIMEOUT);
+            if (timeout instanceof Integer) {
+                target.setOption(SocketOptions.SO_TIMEOUT, timeout);
+            }
+        } catch (IOException ignore) { }
     }
 
     /**
      * Returns a set of SocketOptions supported by this impl
      * and by this impl's socket (Socket or ServerSocket)
      *
+     * @implSpec
+     * The default implementation of this method returns an empty set.
+     * Subclasses should override this method with an appropriate implementation.
+     *
      * @return a Set of SocketOptions
      *
      * @since 9
      */
     protected Set<SocketOption<?>> supportedOptions() {
-        if (getSocket() != null) {
-            return socketOptions;
-        } else {
-            return serverSocketOptions;
-        }
+        return Set.of();
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/NumberFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Normalizer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ParseException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/NumberFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,17 ***</span>
  import java.util.concurrent.atomic.AtomicLong;
  import sun.util.locale.provider.LocaleProviderAdapter;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  
  /**
<span class="line-modified">!  * &lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number</span>
   * formats. This class provides the interface for formatting and parsing
<span class="line-modified">!  * numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining</span>
   * which locales have number formats, and what their names are.
   *
   * &lt;p&gt;
<span class="line-modified">!  * &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.</span>
   * Your code can be completely independent of the locale conventions for
   * decimal points, thousands-separators, or even the particular decimal
   * digits used, or whether the number format is even decimal.
   *
   * &lt;p&gt;
<span class="line-new-header">--- 54,17 ---</span>
  import java.util.concurrent.atomic.AtomicLong;
  import sun.util.locale.provider.LocaleProviderAdapter;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  
  /**
<span class="line-modified">!  * {@code NumberFormat} is the abstract base class for all number</span>
   * formats. This class provides the interface for formatting and parsing
<span class="line-modified">!  * numbers. {@code NumberFormat} also provides methods for determining</span>
   * which locales have number formats, and what their names are.
   *
   * &lt;p&gt;
<span class="line-modified">!  * {@code NumberFormat} helps you to format and parse numbers for any locale.</span>
   * Your code can be completely independent of the locale conventions for
   * decimal points, thousands-separators, or even the particular decimal
   * digits used, or whether the number format is even decimal.
   *
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,11 ***</span>
   *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
   * }
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
   * To format a number for a different Locale, specify it in the
<span class="line-modified">!  * call to &lt;code&gt;getInstance&lt;/code&gt;.</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;{@code
   * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-new-header">--- 86,11 ---</span>
   *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
   * }
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
   * To format a number for a different Locale, specify it in the
<span class="line-modified">!  * call to {@code getInstance}.</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;{@code
   * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,29 ***</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;{@code
   * myNumber = nf.parse(myString);
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the</span>
<span class="line-modified">!  * normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an</span>
<span class="line-modified">!  * integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the</span>
   * currency number format. Use {@code getCompactNumberInstance} to get the
   * compact number format to format a number in shorter form. For example,
   * {@code 2000} can be formatted as {@code &quot;2K&quot;} in
<span class="line-modified">!  * {@link java.util.Locale#US US locale}. Use &lt;code&gt;getPercentInstance&lt;/code&gt;</span>
   * to get a format for displaying percentages. With this format, a fraction
   * like 0.53 is displayed as 53%.
   *
   * &lt;p&gt;
   * You can also control the display of numbers with such methods as
<span class="line-modified">!  * &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.</span>
   * If you want even more control over the format or parsing,
   * or want to give your users more control,
<span class="line-modified">!  * you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods</span>
   * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on
   * the factory method used. This will work for the vast majority of locales;
<span class="line-modified">!  * just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you encounter</span>
   * an unusual one.
   *
   * &lt;p&gt;
   * NumberFormat and DecimalFormat are designed such that some controls
   * work for formatting and others work for parsing.  The following is
<span class="line-new-header">--- 105,29 ---</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;{@code
   * myNumber = nf.parse(myString);
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * Use {@code getInstance} or {@code getNumberInstance} to get the</span>
<span class="line-modified">!  * normal number format. Use {@code getIntegerInstance} to get an</span>
<span class="line-modified">!  * integer number format. Use {@code getCurrencyInstance} to get the</span>
   * currency number format. Use {@code getCompactNumberInstance} to get the
   * compact number format to format a number in shorter form. For example,
   * {@code 2000} can be formatted as {@code &quot;2K&quot;} in
<span class="line-modified">!  * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}</span>
   * to get a format for displaying percentages. With this format, a fraction
   * like 0.53 is displayed as 53%.
   *
   * &lt;p&gt;
   * You can also control the display of numbers with such methods as
<span class="line-modified">!  * {@code setMinimumFractionDigits}.</span>
   * If you want even more control over the format or parsing,
   * or want to give your users more control,
<span class="line-modified">!  * you can try casting the {@code NumberFormat} you get from the factory methods</span>
   * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on
   * the factory method used. This will work for the vast majority of locales;
<span class="line-modified">!  * just remember to put it in a {@code try} block in case you encounter</span>
   * an unusual one.
   *
   * &lt;p&gt;
   * NumberFormat and DecimalFormat are designed such that some controls
   * work for formatting and others work for parsing.  The following is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,37 ***</span>
   * if false, 3456.00 &amp;rarr; &quot;3456&quot;
   * This is independent of parsing.  If you want parsing to stop at the decimal
   * point, use setParseIntegerOnly.
   *
   * &lt;p&gt;
<span class="line-modified">!  * You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;</span>
<span class="line-modified">!  * methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to</span>
   * allow you to:
   * &lt;ul&gt;
   * &lt;li&gt; progressively parse through pieces of a string
   * &lt;li&gt; align the decimal point and other areas
   * &lt;/ul&gt;
   * For example, you can align numbers in two ways:
   * &lt;ol&gt;
   * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
<span class="line-modified">!  *      you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with</span>
<span class="line-modified">!  *      &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,</span>
<span class="line-modified">!  *      &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the</span>
   *      last character of the integer and the decimal. Add
   *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
   *
   * &lt;li&gt; If you are using proportional fonts,
   *      instead of padding with spaces, measure the width
<span class="line-modified">!  *      of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.</span>
   *      Then move the pen by
   *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
   *      It also works where there is no decimal, but possibly additional
   *      characters at the end, e.g., with parentheses in negative
   *      numbers: &quot;(12)&quot; for -12.
   * &lt;/ol&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Number formats are generally not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
<span class="line-new-header">--- 147,37 ---</span>
   * if false, 3456.00 &amp;rarr; &quot;3456&quot;
   * This is independent of parsing.  If you want parsing to stop at the decimal
   * point, use setParseIntegerOnly.
   *
   * &lt;p&gt;
<span class="line-modified">!  * You can also use forms of the {@code parse} and {@code format}</span>
<span class="line-modified">!  * methods with {@code ParsePosition} and {@code FieldPosition} to</span>
   * allow you to:
   * &lt;ul&gt;
   * &lt;li&gt; progressively parse through pieces of a string
   * &lt;li&gt; align the decimal point and other areas
   * &lt;/ul&gt;
   * For example, you can align numbers in two ways:
   * &lt;ol&gt;
   * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
<span class="line-modified">!  *      you can pass the {@code FieldPosition} in your format call, with</span>
<span class="line-modified">!  *      {@code field} = {@code INTEGER_FIELD}. On output,</span>
<span class="line-modified">!  *      {@code getEndIndex} will be set to the offset between the</span>
   *      last character of the integer and the decimal. Add
   *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
   *
   * &lt;li&gt; If you are using proportional fonts,
   *      instead of padding with spaces, measure the width
<span class="line-modified">!  *      of the string in pixels from the start to {@code getEndIndex}.</span>
   *      Then move the pen by
   *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
   *      It also works where there is no decimal, but possibly additional
   *      characters at the end, e.g., with parentheses in negative
   *      numbers: &quot;(12)&quot; for -12.
   * &lt;/ol&gt;
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt;
   * Number formats are generally not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,36 ***</span>
       * buffer.
       * The number can be of any subclass of {@link java.lang.Number}.
       * &lt;p&gt;
       * This implementation extracts the number&#39;s value using
       * {@link java.lang.Number#longValue()} for all integral type values that
<span class="line-modified">!      * can be converted to &lt;code&gt;long&lt;/code&gt; without loss of information,</span>
<span class="line-modified">!      * including &lt;code&gt;BigInteger&lt;/code&gt; values with a</span>
       * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
       * and {@link java.lang.Number#doubleValue()} for all other types. It
       * then calls
       * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
       * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
       * This may result in loss of magnitude information and precision for
<span class="line-modified">!      * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values.</span>
       * @param number     the number to format
<span class="line-modified">!      * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted</span>
       *                   text is to be appended
       * @param pos        keeps track on the position of the field within the
       *                   returned string. For example, for formatting a number
       *                   {@code 1234567.89} in {@code Locale.US} locale,
       *                   if the given {@code fieldPosition} is
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 9, respectively for the output string
       *                   {@code 1,234,567.89}.
<span class="line-modified">!      * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</span>
<span class="line-modified">!      * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is</span>
<span class="line-modified">!      *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified">!      *                   &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified">!      * @exception        ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see              java.text.FieldPosition
       */
      @Override
      public StringBuffer format(Object number,
<span class="line-new-header">--- 236,36 ---</span>
       * buffer.
       * The number can be of any subclass of {@link java.lang.Number}.
       * &lt;p&gt;
       * This implementation extracts the number&#39;s value using
       * {@link java.lang.Number#longValue()} for all integral type values that
<span class="line-modified">!      * can be converted to {@code long} without loss of information,</span>
<span class="line-modified">!      * including {@code BigInteger} values with a</span>
       * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
       * and {@link java.lang.Number#doubleValue()} for all other types. It
       * then calls
       * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
       * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
       * This may result in loss of magnitude information and precision for
<span class="line-modified">!      * {@code BigInteger} and {@code BigDecimal} values.</span>
       * @param number     the number to format
<span class="line-modified">!      * @param toAppendTo the {@code StringBuffer} to which the formatted</span>
       *                   text is to be appended
       * @param pos        keeps track on the position of the field within the
       *                   returned string. For example, for formatting a number
       *                   {@code 1234567.89} in {@code Locale.US} locale,
       *                   if the given {@code fieldPosition} is
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 9, respectively for the output string
       *                   {@code 1,234,567.89}.
<span class="line-modified">!      * @return           the value passed in as {@code toAppendTo}</span>
<span class="line-modified">!      * @throws           IllegalArgumentException if {@code number} is</span>
<span class="line-modified">!      *                   null or not an instance of {@code Number}.</span>
<span class="line-modified">!      * @throws           NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified">!      *                   {@code pos} is null</span>
<span class="line-modified">!      * @throws           ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see              java.text.FieldPosition
       */
      @Override
      public StringBuffer format(Object number,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,30 ***</span>
              throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
          }
      }
  
      /**
<span class="line-modified">!      * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.</span>
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">!      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on number parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      @Override
      public final Object parseObject(String source, ParsePosition pos) {
<span class="line-new-header">--- 283,30 ---</span>
              throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
          }
      }
  
      /**
<span class="line-modified">!      * Parses text from a string to produce a {@code Number}.</span>
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * {@code pos}.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of {@code pos} is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * number is returned. The updated {@code pos} can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">!      * changed, the error index of {@code pos} is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on number parsing.
       *
<span class="line-modified">!      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A {@code ParsePosition} object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return A {@code Number} parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      @Override
      public final Object parseObject(String source, ParsePosition pos) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,11 ***</span>
     /**
       * Specialization of format.
       *
       * @param number the double number to format
       * @return the formatted String
<span class="line-modified">!      * @exception        ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public final String format(double number) {
          // Use fast-path for double result if that works
<span class="line-new-header">--- 316,11 ---</span>
     /**
       * Specialization of format.
       *
       * @param number the double number to format
       * @return the formatted String
<span class="line-modified">!      * @throws           ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public final String format(double number) {
          // Use fast-path for double result if that works
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
     /**
       * Specialization of format.
       *
       * @param number the long number to format
       * @return the formatted String
<span class="line-modified">!      * @exception        ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public final String format(long number) {
          return format(number, new StringBuffer(),
<span class="line-new-header">--- 341,11 ---</span>
     /**
       * Specialization of format.
       *
       * @param number the long number to format
       * @return the formatted String
<span class="line-modified">!      * @throws           ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public final String format(long number) {
          return format(number, new StringBuffer(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,11 ***</span>
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 9, respectively for the output string
       *                   {@code 1,234,567.89}.
       * @return the formatted StringBuffer
<span class="line-modified">!      * @exception        ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public abstract StringBuffer format(double number,
                                          StringBuffer toAppendTo,
<span class="line-new-header">--- 365,11 ---</span>
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 9, respectively for the output string
       *                   {@code 1,234,567.89}.
       * @return the formatted StringBuffer
<span class="line-modified">!      * @throws           ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public abstract StringBuffer format(double number,
                                          StringBuffer toAppendTo,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 11, respectively for the output string
       *                   {@code 123,456,789}.
       * @return the formatted StringBuffer
<span class="line-modified">!      * @exception        ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public abstract StringBuffer format(long number,
                                          StringBuffer toAppendTo,
<span class="line-new-header">--- 388,11 ---</span>
       *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
       *                   and end index of {@code fieldPosition} will be set
       *                   to 0 and 11, respectively for the output string
       *                   {@code 123,456,789}.
       * @return the formatted StringBuffer
<span class="line-modified">!      * @throws           ArithmeticException if rounding is needed with rounding</span>
       *                   mode being set to RoundingMode.UNNECESSARY
       * @see java.text.Format#format
       */
      public abstract StringBuffer format(long number,
                                          StringBuffer toAppendTo,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,13 ***</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on number parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">!      * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string.</span>
<span class="line-modified">!      * @exception ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Number parse(String source) throws ParseException {
          ParsePosition parsePosition = new ParsePosition(0);
          Number result = parse(source, parsePosition);
<span class="line-new-header">--- 420,13 ---</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on number parsing.
       *
<span class="line-modified">!      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">!      * @return A {@code Number} parsed from the string.</span>
<span class="line-modified">!      * @throws    ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Number parse(String source) throws ParseException {
          ParsePosition parsePosition = new ParsePosition(0);
          Number result = parse(source, parsePosition);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 573,10 ***</span>
<span class="line-new-header">--- 573,19 ---</span>
      }
  
      /**
       * Returns a currency format for the specified locale.
       *
<span class="line-added">+      * &lt;p&gt;If the specified locale contains the &quot;{@code cf}&quot; (</span>
<span class="line-added">+      * &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt;</span>
<span class="line-added">+      * currency format style&lt;/a&gt;)</span>
<span class="line-added">+      * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,</span>
<span class="line-added">+      * the returned currency format uses the style if it is available.</span>
<span class="line-added">+      * Otherwise, the style uses the default &quot;{@code standard}&quot; currency format.</span>
<span class="line-added">+      * For example, if the style designates &quot;{@code account}&quot;, negative</span>
<span class="line-added">+      * currency amounts use a pair of parentheses in some locales.</span>
<span class="line-added">+      *</span>
       * @param inLocale the desired locale
       * @return the {@code NumberFormat} instance for currency formatting
       */
      public static NumberFormat getCurrencyInstance(Locale inLocale) {
          return getInstance(inLocale, null, CURRENCYSTYLE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,20 ***</span>
          return getInstance(locale, formatStyle, COMPACTSTYLE);
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
<span class="line-modified">!      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to</span>
       * {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available.</span>
       */
      public static Locale[] getAvailableLocales() {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(NumberFormatProvider.class);
          return pool.getAvailableLocales();
<span class="line-new-header">--- 675,20 ---</span>
          return getInstance(locale, formatStyle, COMPACTSTYLE);
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * {@code get*Instance} methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
<span class="line-modified">!      * It must contain at least a {@code Locale} instance equal to</span>
       * {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         {@code NumberFormat} instances are available.</span>
       */
      public static Locale[] getAvailableLocales() {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(NumberFormatProvider.class);
          return pool.getAvailableLocales();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,14 ***</span>
       * way. The returned value may be null if no valid
       * currency could be determined and no currency has been set using
       * {@link #setCurrency(java.util.Currency) setCurrency}.
       * &lt;p&gt;
       * The default implementation throws
<span class="line-modified">!      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @return the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception UnsupportedOperationException if the number format class</span>
       * doesn&#39;t implement currency formatting
       * @since 1.4
       */
      public Currency getCurrency() {
          throw new UnsupportedOperationException();
<span class="line-new-header">--- 886,14 ---</span>
       * way. The returned value may be null if no valid
       * currency could be determined and no currency has been set using
       * {@link #setCurrency(java.util.Currency) setCurrency}.
       * &lt;p&gt;
       * The default implementation throws
<span class="line-modified">!      * {@code UnsupportedOperationException}.</span>
       *
<span class="line-modified">!      * @return the currency used by this number format, or {@code null}</span>
<span class="line-modified">!      * @throws    UnsupportedOperationException if the number format class</span>
       * doesn&#39;t implement currency formatting
       * @since 1.4
       */
      public Currency getCurrency() {
          throw new UnsupportedOperationException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,16 ***</span>
       * Sets the currency used by this number format when formatting
       * currency values. This does not update the minimum or maximum
       * number of fraction digits used by the number format.
       * &lt;p&gt;
       * The default implementation throws
<span class="line-modified">!      * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</span>
       *
       * @param currency the new currency to be used by this number format
<span class="line-modified">!      * @exception UnsupportedOperationException if the number format class</span>
       * doesn&#39;t implement currency formatting
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</span>
       * @since 1.4
       */
      public void setCurrency(Currency currency) {
          throw new UnsupportedOperationException();
      }
<span class="line-new-header">--- 903,16 ---</span>
       * Sets the currency used by this number format when formatting
       * currency values. This does not update the minimum or maximum
       * number of fraction digits used by the number format.
       * &lt;p&gt;
       * The default implementation throws
<span class="line-modified">!      * {@code UnsupportedOperationException}.</span>
       *
       * @param currency the new currency to be used by this number format
<span class="line-modified">!      * @throws    UnsupportedOperationException if the number format class</span>
       * doesn&#39;t implement currency formatting
<span class="line-modified">!      * @throws    NullPointerException if {@code currency} is null</span>
       * @since 1.4
       */
      public void setCurrency(Currency currency) {
          throw new UnsupportedOperationException();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,13 ***</span>
       * The default implementation of this method in NumberFormat
       * always throws {@link java.lang.UnsupportedOperationException}.
       * Subclasses which handle different rounding modes should override
       * this method.
       *
<span class="line-modified">!      * @exception UnsupportedOperationException The default implementation</span>
       *     always throws this exception
<span class="line-modified">!      * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat.</span>
       * @see #setRoundingMode(RoundingMode)
       * @since 1.6
       */
      public RoundingMode getRoundingMode() {
          throw new UnsupportedOperationException();
<span class="line-new-header">--- 922,13 ---</span>
       * The default implementation of this method in NumberFormat
       * always throws {@link java.lang.UnsupportedOperationException}.
       * Subclasses which handle different rounding modes should override
       * this method.
       *
<span class="line-modified">!      * @throws    UnsupportedOperationException The default implementation</span>
       *     always throws this exception
<span class="line-modified">!      * @return The {@code RoundingMode} used for this NumberFormat.</span>
       * @see #setRoundingMode(RoundingMode)
       * @since 1.6
       */
      public RoundingMode getRoundingMode() {
          throw new UnsupportedOperationException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 930,14 ***</span>
       * The default implementation of this method in NumberFormat always
       * throws {@link java.lang.UnsupportedOperationException}.
       * Subclasses which handle different rounding modes should override
       * this method.
       *
<span class="line-modified">!      * @exception UnsupportedOperationException The default implementation</span>
       *     always throws this exception
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null</span>
<span class="line-modified">!      * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</span>
       * @see #getRoundingMode()
       * @since 1.6
       */
      public void setRoundingMode(RoundingMode roundingMode) {
          throw new UnsupportedOperationException();
<span class="line-new-header">--- 939,14 ---</span>
       * The default implementation of this method in NumberFormat always
       * throws {@link java.lang.UnsupportedOperationException}.
       * Subclasses which handle different rounding modes should override
       * this method.
       *
<span class="line-modified">!      * @throws    UnsupportedOperationException The default implementation</span>
       *     always throws this exception
<span class="line-modified">!      * @throws    NullPointerException if {@code roundingMode} is null</span>
<span class="line-modified">!      * @param roundingMode The {@code RoundingMode} to be used</span>
       * @see #getRoundingMode()
       * @since 1.6
       */
      public void setRoundingMode(RoundingMode roundingMode) {
          throw new UnsupportedOperationException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 985,27 ***</span>
      }
  
      /**
       * First, read in the default serializable data.
       *
<span class="line-modified">!      * Then, if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that</span>
       * the stream was written by JDK 1.1,
<span class="line-modified">!      * set the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified">!      * to be equal to the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt;,</span>
<span class="line-modified">!      * since the &lt;code&gt;int&lt;/code&gt; fields were not present in JDK 1.1.</span>
       * Finally, set serialVersionOnStream back to the maximum allowed value so that
       * default serialization will work properly if this object is streamed out again.
       *
<span class="line-modified">!      * &lt;p&gt;If &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;minimumFractionDigits&lt;/code&gt;</span>
<span class="line-modified">!      * is greater than &lt;code&gt;maximumFractionDigits&lt;/code&gt;, then the stream data</span>
<span class="line-modified">!      * is invalid and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
       * In addition, if any of these values is negative, then this method throws
<span class="line-modified">!      * an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
       *
       * @since 1.2
       */
      private void readObject(ObjectInputStream stream)
           throws IOException, ClassNotFoundException
      {
          stream.defaultReadObject();
          if (serialVersionOnStream &lt; 1) {
<span class="line-new-header">--- 994,28 ---</span>
      }
  
      /**
       * First, read in the default serializable data.
       *
<span class="line-modified">!      * Then, if {@code serialVersionOnStream} is less than 1, indicating that</span>
       * the stream was written by JDK 1.1,
<span class="line-modified">!      * set the {@code int} fields such as {@code maximumIntegerDigits}</span>
<span class="line-modified">!      * to be equal to the {@code byte} fields such as {@code maxIntegerDigits},</span>
<span class="line-modified">!      * since the {@code int} fields were not present in JDK 1.1.</span>
       * Finally, set serialVersionOnStream back to the maximum allowed value so that
       * default serialization will work properly if this object is streamed out again.
       *
<span class="line-modified">!      * &lt;p&gt;If {@code minimumIntegerDigits} is greater than</span>
<span class="line-modified">!      * {@code maximumIntegerDigits} or {@code minimumFractionDigits}</span>
<span class="line-modified">!      * is greater than {@code maximumFractionDigits}, then the stream data</span>
<span class="line-modified">!      * is invalid and this method throws an {@code InvalidObjectException}.</span>
       * In addition, if any of these values is negative, then this method throws
<span class="line-modified">!      * an {@code InvalidObjectException}.</span>
       *
       * @since 1.2
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream stream)
           throws IOException, ClassNotFoundException
      {
          stream.defaultReadObject();
          if (serialVersionOnStream &lt; 1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,17 ***</span>
          serialVersionOnStream = currentSerialVersion;
      }
  
      /**
       * Write out the default serializable data, after first setting
<span class="line-modified">!      * the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; to be</span>
<span class="line-modified">!      * equal to the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
<span class="line-modified">!      * (or to &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;, whichever is smaller), for compatibility</span>
       * with the JDK 1.1 version of the stream format.
       *
       * @since 1.2
       */
      private void writeObject(ObjectOutputStream stream)
           throws IOException
      {
          maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?
                             Byte.MAX_VALUE : (byte)maximumIntegerDigits;
<span class="line-new-header">--- 1033,18 ---</span>
          serialVersionOnStream = currentSerialVersion;
      }
  
      /**
       * Write out the default serializable data, after first setting
<span class="line-modified">!      * the {@code byte} fields such as {@code maxIntegerDigits} to be</span>
<span class="line-modified">!      * equal to the {@code int} fields such as {@code maximumIntegerDigits}</span>
<span class="line-modified">!      * (or to {@code Byte.MAX_VALUE}, whichever is smaller), for compatibility</span>
       * with the JDK 1.1 version of the stream format.
       *
       * @since 1.2
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream stream)
           throws IOException
      {
          maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?
                             Byte.MAX_VALUE : (byte)maximumIntegerDigits;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,74 ***</span>
       */
      private boolean groupingUsed = true;
  
      /**
       * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  &lt;code&gt;maxIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;minIntegerDigits&lt;/code&gt;.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">!      * When writing to a stream, &lt;code&gt;maxIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">!      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
       *
       * @serial
       * @see #getMaximumIntegerDigits
       */
      private byte    maxIntegerDigits = 40;
  
      /**
       * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">!      * When writing to a stream, &lt;code&gt;minIntegerDigits&lt;/code&gt; is set to</span>
<span class="line-modified">!      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
       *
       * @serial
       * @see #getMinimumIntegerDigits
       */
      private byte    minIntegerDigits = 1;
  
      /**
       * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">!      * When writing to a stream, &lt;code&gt;maxFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">!      * &lt;code&gt;maximumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
       *
       * @serial
       * @see #getMaximumFractionDigits
       */
      private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits
  
      /**
       * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumFractionDigits&lt;/code&gt; is used instead.</span>
<span class="line-modified">!      * When writing to a stream, &lt;code&gt;minFractionDigits&lt;/code&gt; is set to</span>
<span class="line-modified">!      * &lt;code&gt;minimumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.</span>
       *
       * @serial
       * @see #getMinimumFractionDigits
       */
      private byte    minFractionDigits = 0;
<span class="line-new-header">--- 1074,74 ---</span>
       */
      private boolean groupingUsed = true;
  
      /**
       * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  {@code maxIntegerDigits} must be greater than or equal to</span>
<span class="line-modified">!      * {@code minIntegerDigits}.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * {@code int} field {@code maximumIntegerDigits} is used instead.</span>
<span class="line-modified">!      * When writing to a stream, {@code maxIntegerDigits} is set to</span>
<span class="line-modified">!      * {@code maximumIntegerDigits} or {@code Byte.MAX_VALUE},</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if {@code serialVersionOnStream} is less than 1.</span>
       *
       * @serial
       * @see #getMaximumIntegerDigits
       */
      private byte    maxIntegerDigits = 40;
  
      /**
       * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  {@code minimumIntegerDigits} must be less than or equal to</span>
<span class="line-modified">!      * {@code maximumIntegerDigits}.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * {@code int} field {@code minimumIntegerDigits} is used instead.</span>
<span class="line-modified">!      * When writing to a stream, {@code minIntegerDigits} is set to</span>
<span class="line-modified">!      * {@code minimumIntegerDigits} or {@code Byte.MAX_VALUE},</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if {@code serialVersionOnStream} is less than 1.</span>
       *
       * @serial
       * @see #getMinimumIntegerDigits
       */
      private byte    minIntegerDigits = 1;
  
      /**
       * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  {@code maximumFractionDigits} must be greater than or equal to</span>
<span class="line-modified">!      * {@code minimumFractionDigits}.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * {@code int} field {@code maximumFractionDigits} is used instead.</span>
<span class="line-modified">!      * When writing to a stream, {@code maxFractionDigits} is set to</span>
<span class="line-modified">!      * {@code maximumFractionDigits} or {@code Byte.MAX_VALUE},</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if {@code serialVersionOnStream} is less than 1.</span>
       *
       * @serial
       * @see #getMaximumFractionDigits
       */
      private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits
  
      /**
       * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  {@code minimumFractionDigits} must be less than or equal to</span>
<span class="line-modified">!      * {@code maximumFractionDigits}.</span>
       * &lt;p&gt;
       * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
       * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
<span class="line-modified">!      * {@code int} field {@code minimumFractionDigits} is used instead.</span>
<span class="line-modified">!      * When writing to a stream, {@code minFractionDigits} is set to</span>
<span class="line-modified">!      * {@code minimumFractionDigits} or {@code Byte.MAX_VALUE},</span>
       * whichever is smaller.  When reading from a stream, this field is used
<span class="line-modified">!      * only if {@code serialVersionOnStream} is less than 1.</span>
       *
       * @serial
       * @see #getMinimumFractionDigits
       */
      private byte    minFractionDigits = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1145,96 ***</span>
  
      // new fields for 1.2.  byte is too small for integer digits.
  
      /**
       * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMaximumIntegerDigits
       */
      private int    maximumIntegerDigits = 40;
  
      /**
       * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMinimumIntegerDigits
       */
      private int    minimumIntegerDigits = 1;
  
      /**
       * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMaximumFractionDigits
       */
      private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits
  
      /**
       * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMinimumFractionDigits
       */
      private int    minimumFractionDigits = 0;
  
      static final int currentSerialVersion = 1;
  
      /**
<span class="line-modified">!      * Describes the version of &lt;code&gt;NumberFormat&lt;/code&gt; present on the stream.</span>
       * Possible values are:
       * &lt;ul&gt;
       * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
<span class="line-modified">!      *     In this version, the &lt;code&gt;int&lt;/code&gt; fields such as</span>
<span class="line-modified">!      *     &lt;code&gt;maximumIntegerDigits&lt;/code&gt; were not present, and the &lt;code&gt;byte&lt;/code&gt;</span>
<span class="line-modified">!      *     fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are used instead.</span>
       *
       * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
<span class="line-modified">!      *     &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are ignored,</span>
<span class="line-modified">!      *     and the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;</span>
       *     are used instead.
       * &lt;/ul&gt;
<span class="line-modified">!      * When streaming out a &lt;code&gt;NumberFormat&lt;/code&gt;, the most recent format</span>
<span class="line-modified">!      * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)</span>
       * is always written.
       *
       * @serial
       * @since 1.2
       */
      private int serialVersionOnStream = currentSerialVersion;
  
      // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
      // ID for backward compatibility.
      static final long serialVersionUID = -2308460125733713944L;
  
  
      //
      // class for AttributedCharacterIterator attributes
      //
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">!      * from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">!      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
       *
       * @since 1.4
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
          private static final long serialVersionUID = 7494728892700160890L;
  
          // table of all instances in this class, used by readResolve
          private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);
  
<span class="line-new-header">--- 1156,98 ---</span>
  
      // new fields for 1.2.  byte is too small for integer digits.
  
      /**
       * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  {@code maximumIntegerDigits} must be greater than or equal to</span>
<span class="line-modified">!      * {@code minimumIntegerDigits}.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMaximumIntegerDigits
       */
      private int    maximumIntegerDigits = 40;
  
      /**
       * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">!      * number.  {@code minimumIntegerDigits} must be less than or equal to</span>
<span class="line-modified">!      * {@code maximumIntegerDigits}.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMinimumIntegerDigits
       */
      private int    minimumIntegerDigits = 1;
  
      /**
       * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  {@code maximumFractionDigits} must be greater than or equal to</span>
<span class="line-modified">!      * {@code minimumFractionDigits}.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMaximumFractionDigits
       */
      private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits
  
      /**
       * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">!      * number.  {@code minimumFractionDigits} must be less than or equal to</span>
<span class="line-modified">!      * {@code maximumFractionDigits}.</span>
       *
       * @serial
       * @since 1.2
       * @see #getMinimumFractionDigits
       */
      private int    minimumFractionDigits = 0;
  
      static final int currentSerialVersion = 1;
  
      /**
<span class="line-modified">!      * Describes the version of {@code NumberFormat} present on the stream.</span>
       * Possible values are:
       * &lt;ul&gt;
       * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
<span class="line-modified">!      *     In this version, the {@code int} fields such as</span>
<span class="line-modified">!      *     {@code maximumIntegerDigits} were not present, and the {@code byte}</span>
<span class="line-modified">!      *     fields such as {@code maxIntegerDigits} are used instead.</span>
       *
       * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
<span class="line-modified">!      *     {@code byte} fields such as {@code maxIntegerDigits} are ignored,</span>
<span class="line-modified">!      *     and the {@code int} fields such as {@code maximumIntegerDigits}</span>
       *     are used instead.
       * &lt;/ul&gt;
<span class="line-modified">!      * When streaming out a {@code NumberFormat}, the most recent format</span>
<span class="line-modified">!      * (corresponding to the highest allowable {@code serialVersionOnStream})</span>
       * is always written.
       *
       * @serial
       * @since 1.2
       */
      private int serialVersionOnStream = currentSerialVersion;
  
      // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
      // ID for backward compatibility.
<span class="line-added">+     @java.io.Serial</span>
      static final long serialVersionUID = -2308460125733713944L;
  
  
      //
      // class for AttributedCharacterIterator attributes
      //
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">!      * from {@code NumberFormat.formatToCharacterIterator} and as</span>
<span class="line-modified">!      * field identifiers in {@code FieldPosition}.</span>
       *
       * @since 1.4
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 7494728892700160890L;
  
          // table of all instances in this class, used by readResolve
          private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1256,10 ***</span>
<span class="line-new-header">--- 1269,11 ---</span>
           *
           * @throws InvalidObjectException if the constant could not be resolved.
           * @return resolved NumberFormat.Field constant
           */
          @Override
<span class="line-added">+         @java.io.Serial</span>
          protected Object readResolve() throws InvalidObjectException {
              if (this.getClass() != NumberFormat.Field.class) {
                  throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
              }
  
</pre>
<center><a href="Normalizer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ParseException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
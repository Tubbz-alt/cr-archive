<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MutableCallSite.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
   * questions.
   */
  
  package java.lang.invoke;
  
<span class="line-removed">- import jdk.internal.vm.annotation.Stable;</span>
  import sun.invoke.util.Wrapper;
  
  import java.lang.ref.SoftReference;
  
  import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,27 ***</span>
   * There are a little over 10 times that number of unerased types.
   * No more than half of these are likely to be loaded at once.
   * @author John Rose
   */
  final class MethodTypeForm {
<span class="line-modified">!     final int[] argToSlotTable, slotToArgTable;</span>
<span class="line-modified">!     final long argCounts;               // packed slot &amp; value counts</span>
<span class="line-removed">-     final long primCounts;              // packed prim &amp; double counts</span>
      final MethodType erasedType;        // the canonical erasure
      final MethodType basicType;         // the canonical erasure, with primitives simplified
  
      // Cached adapter information:
<span class="line-modified">!     @Stable final SoftReference&lt;MethodHandle&gt;[] methodHandles;</span>
      // Indexes into methodHandles:
      static final int
              MH_BASIC_INV      =  0,  // cached instance of MH.invokeBasic
              MH_NF_INV         =  1,  // cached helper for LF.NamedFunction
              MH_UNINIT_CS      =  2,  // uninitialized call site
              MH_LIMIT          =  3;
  
      // Cached lambda form information, for basic types only:
<span class="line-modified">!     final @Stable SoftReference&lt;LambdaForm&gt;[] lambdaForms;</span>
      // Indexes into lambdaForms:
      static final int
              LF_INVVIRTUAL              =  0,  // DMH invokeVirtual
              LF_INVSTATIC               =  1,
              LF_INVSPECIAL              =  2,
<span class="line-new-header">--- 43,28 ---</span>
   * There are a little over 10 times that number of unerased types.
   * No more than half of these are likely to be loaded at once.
   * @author John Rose
   */
  final class MethodTypeForm {
<span class="line-modified">!     final short parameterSlotCount;</span>
<span class="line-modified">!     final short primitiveCount;</span>
      final MethodType erasedType;        // the canonical erasure
      final MethodType basicType;         // the canonical erasure, with primitives simplified
  
      // Cached adapter information:
<span class="line-modified">!     final SoftReference&lt;MethodHandle&gt;[] methodHandles;</span>
<span class="line-added">+ </span>
      // Indexes into methodHandles:
      static final int
              MH_BASIC_INV      =  0,  // cached instance of MH.invokeBasic
              MH_NF_INV         =  1,  // cached helper for LF.NamedFunction
              MH_UNINIT_CS      =  2,  // uninitialized call site
              MH_LIMIT          =  3;
  
      // Cached lambda form information, for basic types only:
<span class="line-modified">!     final SoftReference&lt;LambdaForm&gt;[] lambdaForms;</span>
<span class="line-added">+ </span>
      // Indexes into lambdaForms:
      static final int
              LF_INVVIRTUAL              =  0,  // DMH invokeVirtual
              LF_INVSTATIC               =  1,
              LF_INVSPECIAL              =  2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,19 ***</span>
       */
      public MethodType basicType() {
          return basicType;
      }
  
<span class="line-removed">-     private boolean assertIsBasicType() {</span>
<span class="line-removed">-         // primitives must be flattened also</span>
<span class="line-removed">-         assert(erasedType == basicType)</span>
<span class="line-removed">-                 : &quot;erasedType: &quot; + erasedType + &quot; != basicType: &quot; + basicType;</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      public MethodHandle cachedMethodHandle(int which) {
<span class="line-removed">-         assert(assertIsBasicType());</span>
          SoftReference&lt;MethodHandle&gt; entry = methodHandles[which];
          return (entry != null) ? entry.get() : null;
      }
  
      public synchronized MethodHandle setCachedMethodHandle(int which, MethodHandle mh) {
<span class="line-new-header">--- 102,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,11 ***</span>
          methodHandles[which] = new SoftReference&lt;&gt;(mh);
          return mh;
      }
  
      public LambdaForm cachedLambdaForm(int which) {
<span class="line-removed">-         assert(assertIsBasicType());</span>
          SoftReference&lt;LambdaForm&gt; entry = lambdaForms[which];
          return (entry != null) ? entry.get() : null;
      }
  
      public synchronized LambdaForm setCachedLambdaForm(int which, LambdaForm form) {
<span class="line-new-header">--- 121,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,162 ***</span>
      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
      protected MethodTypeForm(MethodType erasedType) {
          this.erasedType = erasedType;
  
          Class&lt;?&gt;[] ptypes = erasedType.ptypes();
<span class="line-modified">!         int ptypeCount = ptypes.length;</span>
<span class="line-removed">-         int pslotCount = ptypeCount;            // temp. estimate</span>
<span class="line-removed">-         int rtypeCount = 1;                     // temp. estimate</span>
<span class="line-removed">-         int rslotCount = 1;                     // temp. estimate</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int[] argToSlotTab = null, slotToArgTab = null;</span>
  
          // Walk the argument types, looking for primitives.
<span class="line-modified">!         int pac = 0, lac = 0, prc = 0, lrc = 0;</span>
<span class="line-modified">!         Class&lt;?&gt;[] epts = ptypes;</span>
<span class="line-modified">!         Class&lt;?&gt;[] bpts = epts;</span>
<span class="line-modified">!         for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="line-modified">!             Class&lt;?&gt; pt = epts[i];</span>
<span class="line-modified">!             if (pt != Object.class) {</span>
<span class="line-modified">!                 ++pac;</span>
<span class="line-modified">!                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="line-modified">!                 if (w.isDoubleWord())  ++lac;</span>
<span class="line-modified">!                 if (w.isSubwordOrInt() &amp;&amp; pt != int.class) {</span>
<span class="line-modified">!                     if (bpts == epts)</span>
<span class="line-modified">!                         bpts = bpts.clone();</span>
<span class="line-modified">!                     bpts[i] = int.class;</span>
                  }
              }
          }
<span class="line-modified">!         pslotCount += lac;                  // #slots = #args + #longs</span>
<span class="line-modified">!         Class&lt;?&gt; rt = erasedType.returnType();</span>
<span class="line-modified">!         Class&lt;?&gt; bt = rt;</span>
<span class="line-modified">!         if (rt != Object.class) {</span>
<span class="line-modified">!             ++prc;          // even void.class counts as a prim here</span>
<span class="line-modified">!             Wrapper w = Wrapper.forPrimitiveType(rt);</span>
<span class="line-modified">!             if (w.isDoubleWord())  ++lrc;</span>
<span class="line-modified">!             if (w.isSubwordOrInt() &amp;&amp; rt != int.class)</span>
<span class="line-removed">-                 bt = int.class;</span>
<span class="line-removed">-             // adjust #slots, #args</span>
<span class="line-removed">-             if (rt == void.class)</span>
<span class="line-removed">-                 rtypeCount = rslotCount = 0;</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-                 rslotCount += lrc;</span>
          }
<span class="line-modified">!         if (epts == bpts &amp;&amp; bt == rt) {</span>
              this.basicType = erasedType;
          } else {
<span class="line-modified">!             this.basicType = MethodType.makeImpl(bt, bpts, true);</span>
              // fill in rest of data from the basic type:
              MethodTypeForm that = this.basicType.form();
              assert(this != that);
<span class="line-modified">!             this.primCounts = that.primCounts;</span>
<span class="line-modified">!             this.argCounts = that.argCounts;</span>
<span class="line-modified">!             this.argToSlotTable = that.argToSlotTable;</span>
<span class="line-removed">-             this.slotToArgTable = that.slotToArgTable;</span>
              this.methodHandles = null;
              this.lambdaForms = null;
<span class="line-removed">-             return;</span>
          }
<span class="line-removed">-         if (lac != 0) {</span>
<span class="line-removed">-             int slot = ptypeCount + lac;</span>
<span class="line-removed">-             slotToArgTab = new int[slot+1];</span>
<span class="line-removed">-             argToSlotTab = new int[1+ptypeCount];</span>
<span class="line-removed">-             argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="line-removed">-             for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="line-removed">-                 Class&lt;?&gt; pt = epts[i];</span>
<span class="line-removed">-                 Wrapper w = Wrapper.forBasicType(pt);</span>
<span class="line-removed">-                 if (w.isDoubleWord())  --slot;</span>
<span class="line-removed">-                 --slot;</span>
<span class="line-removed">-                 slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="line-removed">-                 argToSlotTab[1+i]  = slot;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             assert(slot == 0);  // filled the table</span>
<span class="line-removed">-         } else if (pac != 0) {</span>
<span class="line-removed">-             // have primitives but no long primitives; share slot counts with generic</span>
<span class="line-removed">-             assert(ptypeCount == pslotCount);</span>
<span class="line-removed">-             MethodTypeForm that = MethodType.genericMethodType(ptypeCount).form();</span>
<span class="line-removed">-             assert(this != that);</span>
<span class="line-removed">-             slotToArgTab = that.slotToArgTable;</span>
<span class="line-removed">-             argToSlotTab = that.argToSlotTable;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             int slot = ptypeCount; // first arg is deepest in stack</span>
<span class="line-removed">-             slotToArgTab = new int[slot+1];</span>
<span class="line-removed">-             argToSlotTab = new int[1+ptypeCount];</span>
<span class="line-removed">-             argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="line-removed">-             for (int i = 0; i &lt; ptypeCount; i++) {</span>
<span class="line-removed">-                 --slot;</span>
<span class="line-removed">-                 slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="line-removed">-                 argToSlotTab[1+i]  = slot;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this.primCounts = pack(lrc, prc, lac, pac);</span>
<span class="line-removed">-         this.argCounts = pack(rslotCount, rtypeCount, pslotCount, ptypeCount);</span>
<span class="line-removed">-         this.argToSlotTable = argToSlotTab;</span>
<span class="line-removed">-         this.slotToArgTable = slotToArgTab;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (pslotCount &gt;= 256)  throw newIllegalArgumentException(&quot;too many arguments&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Initialize caches, but only for basic types</span>
<span class="line-removed">-         assert(basicType == erasedType);</span>
<span class="line-removed">-         this.lambdaForms   = new SoftReference[LF_LIMIT];</span>
<span class="line-removed">-         this.methodHandles = new SoftReference[MH_LIMIT];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static long pack(int a, int b, int c, int d) {</span>
<span class="line-removed">-         assert(((a|b|c|d) &amp; ~0xFFFF) == 0);</span>
<span class="line-removed">-         long hw = ((a &lt;&lt; 16) | b), lw = ((c &lt;&lt; 16) | d);</span>
<span class="line-removed">-         return (hw &lt;&lt; 32) | lw;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     private static char unpack(long packed, int word) { // word==0 =&gt; return a, ==3 =&gt; return d</span>
<span class="line-removed">-         assert(word &lt;= 3);</span>
<span class="line-removed">-         return (char)(packed &gt;&gt; ((3-word) * 16));</span>
      }
  
<span class="line-modified">!     public int parameterCount() {                      // # outgoing values</span>
<span class="line-modified">!         return unpack(argCounts, 3);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int parameterSlotCount() {                  // # outgoing interpreter slots</span>
<span class="line-removed">-         return unpack(argCounts, 2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int returnCount() {                         // = 0 (V), or 1</span>
<span class="line-removed">-         return unpack(argCounts, 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int returnSlotCount() {                     // = 0 (V), 2 (J/D), or 1</span>
<span class="line-removed">-         return unpack(argCounts, 0);</span>
      }
<span class="line-modified">!     public int primitiveParameterCount() {</span>
<span class="line-modified">!         return unpack(primCounts, 3);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int longPrimitiveParameterCount() {</span>
<span class="line-removed">-         return unpack(primCounts, 2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int primitiveReturnCount() {                // = 0 (obj), or 1</span>
<span class="line-removed">-         return unpack(primCounts, 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int longPrimitiveReturnCount() {            // = 1 (J/D), or 0</span>
<span class="line-removed">-         return unpack(primCounts, 0);</span>
      }
      public boolean hasPrimitives() {
<span class="line-modified">!         return primCounts != 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public boolean hasNonVoidPrimitives() {</span>
<span class="line-removed">-         if (primCounts == 0)  return false;</span>
<span class="line-removed">-         if (primitiveParameterCount() != 0)  return true;</span>
<span class="line-removed">-         return (primitiveReturnCount() != 0 &amp;&amp; returnCount() != 0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public boolean hasLongPrimitives() {</span>
<span class="line-removed">-         return (longPrimitiveParameterCount() | longPrimitiveReturnCount()) != 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int parameterToArgSlot(int i) {</span>
<span class="line-removed">-         return argToSlotTable[1+i];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     public int argSlotToParameter(int argSlot) {</span>
<span class="line-removed">-         // Note:  Empty slots are represented by zero in this table.</span>
<span class="line-removed">-         // Valid arguments slots contain incremented entries, so as to be non-zero.</span>
<span class="line-removed">-         // We return -1 the caller to mean an empty slot.</span>
<span class="line-removed">-         return slotToArgTable[argSlot] - 1;</span>
      }
  
      static MethodTypeForm findForm(MethodType mt) {
          MethodType erased = canonicalize(mt, ERASE, ERASE);
          if (erased == null) {
<span class="line-new-header">--- 148,69 ---</span>
      @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
      protected MethodTypeForm(MethodType erasedType) {
          this.erasedType = erasedType;
  
          Class&lt;?&gt;[] ptypes = erasedType.ptypes();
<span class="line-modified">!         int pslotCount = ptypes.length;</span>
  
          // Walk the argument types, looking for primitives.
<span class="line-modified">!         short primitiveCount = 0, longArgCount = 0;</span>
<span class="line-modified">!         Class&lt;?&gt;[] erasedPtypes = ptypes;</span>
<span class="line-modified">!         Class&lt;?&gt;[] basicPtypes = erasedPtypes;</span>
<span class="line-modified">!         for (int i = 0; i &lt; erasedPtypes.length; i++) {</span>
<span class="line-modified">!             Class&lt;?&gt; ptype = erasedPtypes[i];</span>
<span class="line-modified">!             if (ptype != Object.class) {</span>
<span class="line-modified">!                 ++primitiveCount;</span>
<span class="line-modified">!                 Wrapper w = Wrapper.forPrimitiveType(ptype);</span>
<span class="line-modified">!                 if (w.isDoubleWord())  ++longArgCount;</span>
<span class="line-modified">!                 if (w.isSubwordOrInt() &amp;&amp; ptype != int.class) {</span>
<span class="line-modified">!                     if (basicPtypes == erasedPtypes)</span>
<span class="line-modified">!                         basicPtypes = basicPtypes.clone();</span>
<span class="line-modified">!                     basicPtypes[i] = int.class;</span>
                  }
              }
          }
<span class="line-modified">!         pslotCount += longArgCount;                  // #slots = #args + #longs</span>
<span class="line-modified">!         Class&lt;?&gt; returnType = erasedType.returnType();</span>
<span class="line-modified">!         Class&lt;?&gt; basicReturnType = returnType;</span>
<span class="line-modified">!         if (returnType != Object.class) {</span>
<span class="line-modified">!             ++primitiveCount; // even void.class counts as a prim here</span>
<span class="line-modified">!             Wrapper w = Wrapper.forPrimitiveType(returnType);</span>
<span class="line-modified">!             if (w.isSubwordOrInt() &amp;&amp; returnType != int.class)</span>
<span class="line-modified">!                 basicReturnType = int.class;</span>
          }
<span class="line-modified">!         if (erasedPtypes == basicPtypes &amp;&amp; basicReturnType == returnType) {</span>
<span class="line-added">+             // Basic type</span>
              this.basicType = erasedType;
<span class="line-added">+ </span>
<span class="line-added">+             if (pslotCount &gt;= 256)  throw newIllegalArgumentException(&quot;too many arguments&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             this.primitiveCount = primitiveCount;</span>
<span class="line-added">+             this.parameterSlotCount = (short)pslotCount;</span>
<span class="line-added">+             this.lambdaForms   = new SoftReference[LF_LIMIT];</span>
<span class="line-added">+             this.methodHandles = new SoftReference[MH_LIMIT];</span>
          } else {
<span class="line-modified">!             this.basicType = MethodType.makeImpl(basicReturnType, basicPtypes, true);</span>
              // fill in rest of data from the basic type:
              MethodTypeForm that = this.basicType.form();
              assert(this != that);
<span class="line-modified">! </span>
<span class="line-modified">!             this.parameterSlotCount = that.parameterSlotCount;</span>
<span class="line-modified">!             this.primitiveCount = that.primitiveCount;</span>
              this.methodHandles = null;
              this.lambdaForms = null;
          }
      }
  
<span class="line-modified">!     public int parameterCount() {</span>
<span class="line-modified">!         return erasedType.parameterCount();</span>
      }
<span class="line-modified">!     public int parameterSlotCount() {</span>
<span class="line-modified">!         return parameterSlotCount;</span>
      }
      public boolean hasPrimitives() {
<span class="line-modified">!         return primitiveCount != 0;</span>
      }
  
      static MethodTypeForm findForm(MethodType mt) {
          MethodType erased = canonicalize(mt, ERASE, ERASE);
          if (erased == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,29 ***</span>
       * according to size.  LONGS means convert all non-void primitives
       * to long, regardless of size.  RAW_RETURN means convert a type
       * (assumed to be a return type) to int if it is smaller than an int,
       * or if it is void.
       */
<span class="line-modified">!     public static final int NO_CHANGE = 0, ERASE = 1, WRAP = 2, UNWRAP = 3, INTS = 4, LONGS = 5, RAW_RETURN = 6;</span>
  
      /** Canonicalize the types in the given method type.
       * If any types change, intern the new type, and return it.
       * Otherwise return null.
       */
      public static MethodType canonicalize(MethodType mt, int howRet, int howArgs) {
          Class&lt;?&gt;[] ptypes = mt.ptypes();
<span class="line-modified">!         Class&lt;?&gt;[] ptc = MethodTypeForm.canonicalizeAll(ptypes, howArgs);</span>
          Class&lt;?&gt; rtype = mt.returnType();
<span class="line-modified">!         Class&lt;?&gt; rtc = MethodTypeForm.canonicalize(rtype, howRet);</span>
<span class="line-modified">!         if (ptc == null &amp;&amp; rtc == null) {</span>
              // It is already canonical.
              return null;
          }
          // Find the erased version of the method type:
<span class="line-modified">!         if (rtc == null)  rtc = rtype;</span>
<span class="line-modified">!         if (ptc == null)  ptc = ptypes;</span>
<span class="line-modified">!         return MethodType.makeImpl(rtc, ptc, true);</span>
      }
  
      /** Canonicalize the given return or param type.
       *  Return null if the type is already canonicalized.
       */
<span class="line-new-header">--- 230,29 ---</span>
       * according to size.  LONGS means convert all non-void primitives
       * to long, regardless of size.  RAW_RETURN means convert a type
       * (assumed to be a return type) to int if it is smaller than an int,
       * or if it is void.
       */
<span class="line-modified">!     public static final int ERASE = 1, WRAP = 2, UNWRAP = 3, INTS = 4, LONGS = 5, RAW_RETURN = 6;</span>
  
      /** Canonicalize the types in the given method type.
       * If any types change, intern the new type, and return it.
       * Otherwise return null.
       */
      public static MethodType canonicalize(MethodType mt, int howRet, int howArgs) {
          Class&lt;?&gt;[] ptypes = mt.ptypes();
<span class="line-modified">!         Class&lt;?&gt;[] ptypesCanonical = canonicalizeAll(ptypes, howArgs);</span>
          Class&lt;?&gt; rtype = mt.returnType();
<span class="line-modified">!         Class&lt;?&gt; rtypeCanonical = canonicalize(rtype, howRet);</span>
<span class="line-modified">!         if (ptypesCanonical == null &amp;&amp; rtypeCanonical == null) {</span>
              // It is already canonical.
              return null;
          }
          // Find the erased version of the method type:
<span class="line-modified">!         if (rtypeCanonical == null)  rtypeCanonical = rtype;</span>
<span class="line-modified">!         if (ptypesCanonical == null)  ptypesCanonical = ptypes;</span>
<span class="line-modified">!         return MethodType.makeImpl(rtypeCanonical, ptypesCanonical, true);</span>
      }
  
      /** Canonicalize the given return or param type.
       *  Return null if the type is already canonicalized.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,13 ***</span>
       */
      static Class&lt;?&gt;[] canonicalizeAll(Class&lt;?&gt;[] ts, int how) {
          Class&lt;?&gt;[] cs = null;
          for (int imax = ts.length, i = 0; i &lt; imax; i++) {
              Class&lt;?&gt; c = canonicalize(ts[i], how);
<span class="line-modified">!             if (c == void.class)</span>
<span class="line-modified">!                 c = null;  // a Void parameter was unwrapped to void; ignore</span>
<span class="line-removed">-             if (c != null) {</span>
                  if (cs == null)
                      cs = ts.clone();
                  cs[i] = c;
              }
          }
<span class="line-new-header">--- 310,12 ---</span>
       */
      static Class&lt;?&gt;[] canonicalizeAll(Class&lt;?&gt;[] ts, int how) {
          Class&lt;?&gt;[] cs = null;
          for (int imax = ts.length, i = 0; i &lt; imax; i++) {
              Class&lt;?&gt; c = canonicalize(ts[i], how);
<span class="line-modified">!             // Void parameters may be unwrapped to void; ignore those</span>
<span class="line-modified">!             if (c != null &amp;&amp; c != void.class) {</span>
                  if (cs == null)
                      cs = ts.clone();
                  cs[i] = c;
              }
          }
</pre>
<center><a href="MethodType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MutableCallSite.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
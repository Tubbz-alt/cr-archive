<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConcurrentHashMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 317      * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell&#39;s
 318      * thesis (http://www.cs.chalmers.se/~phs/).
 319      *
 320      * Notation guide for local variables
 321      * Node:         b, n, f, p for  predecessor, node, successor, aux
 322      * Index:        q, r, d    for index node, right, down.
 323      * Head:         h
 324      * Keys:         k, key
 325      * Values:       v, value
 326      * Comparisons:  c
 327      */
 328 
 329     private static final long serialVersionUID = -8627078645895051609L;
 330 
 331     /**
 332      * The comparator used to maintain order in this map, or null if
 333      * using natural ordering.  (Non-private to simplify access in
 334      * nested classes.)
 335      * @serial
 336      */

 337     final Comparator&lt;? super K&gt; comparator;
 338 
 339     /** Lazily initialized topmost index of the skiplist. */
 340     private transient Index&lt;K,V&gt; head;
 341     /** Lazily initialized element count */
 342     private transient LongAdder adder;
 343     /** Lazily initialized key set */
 344     private transient KeySet&lt;K,V&gt; keySet;
 345     /** Lazily initialized values collection */
 346     private transient Values&lt;K,V&gt; values;
 347     /** Lazily initialized entry set */
 348     private transient EntrySet&lt;K,V&gt; entrySet;
 349     /** Lazily initialized descending map */
 350     private transient SubMap&lt;K,V&gt; descendingMap;
 351 
 352     /**
 353      * Nodes hold keys and values, and are singly linked in sorted
 354      * order, possibly with some intervening marker nodes. The list is
 355      * headed by a header node accessible as head.node. Headers and
 356      * marker nodes have null keys. The val field (but currently not
</pre>
<hr />
<pre>
1112     public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {
1113         this.comparator = m.comparator();
1114         buildFromSorted(m); // initializes transients
1115     }
1116 
1117     /**
1118      * Returns a shallow copy of this {@code ConcurrentSkipListMap}
1119      * instance. (The keys and values themselves are not cloned.)
1120      *
1121      * @return a shallow copy of this map
1122      */
1123     public ConcurrentSkipListMap&lt;K,V&gt; clone() {
1124         try {
1125             @SuppressWarnings(&quot;unchecked&quot;)
1126             ConcurrentSkipListMap&lt;K,V&gt; clone =
1127                 (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();
1128             clone.keySet = null;
1129             clone.entrySet = null;
1130             clone.values = null;
1131             clone.descendingMap = null;

1132             clone.buildFromSorted(this);
1133             return clone;
1134         } catch (CloneNotSupportedException e) {
1135             throw new InternalError();
1136         }
1137     }
1138 
1139     /**
1140      * Streamlined bulk insertion to initialize from elements of
1141      * given sorted map.  Call only from constructor or clone
1142      * method.
1143      */
1144     private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {
1145         if (map == null)
1146             throw new NullPointerException();
1147         Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =
1148             map.entrySet().iterator();
1149 
1150         /*
1151          * Add equally spaced indices at log intervals, using the bits
</pre>
<hr />
<pre>
1694     /**
1695      * Compares the specified object with this map for equality.
1696      * Returns {@code true} if the given object is also a map and the
1697      * two maps represent the same mappings.  More formally, two maps
1698      * {@code m1} and {@code m2} represent the same mappings if
1699      * {@code m1.entrySet().equals(m2.entrySet())}.  This
1700      * operation may return misleading results if either map is
1701      * concurrently modified during execution of this method.
1702      *
1703      * @param o object to be compared for equality with this map
1704      * @return {@code true} if the specified object is equal to this map
1705      */
1706     public boolean equals(Object o) {
1707         if (o == this)
1708             return true;
1709         if (!(o instanceof Map))
1710             return false;
1711         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;
1712         try {
1713             Comparator&lt;? super K&gt; cmp = comparator;
<span class="line-modified">1714             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">1715             Iterator&lt;Map.Entry&lt;?,?&gt;&gt; it =</span>
<span class="line-removed">1716                 (Iterator&lt;Map.Entry&lt;?,?&gt;&gt;)m.entrySet().iterator();</span>
1717             if (m instanceof SortedMap &amp;&amp;
1718                 ((SortedMap&lt;?,?&gt;)m).comparator() == cmp) {
1719                 Node&lt;K,V&gt; b, n;
1720                 if ((b = baseHead()) != null) {
1721                     while ((n = b.next) != null) {
1722                         K k; V v;
1723                         if ((v = n.val) != null &amp;&amp; (k = n.key) != null) {
1724                             if (!it.hasNext())
1725                                 return false;
1726                             Map.Entry&lt;?,?&gt; e = it.next();
1727                             Object mk = e.getKey();
1728                             Object mv = e.getValue();
1729                             if (mk == null || mv == null)
1730                                 return false;
1731                             try {
1732                                 if (cpr(cmp, k, mk) != 0)
1733                                     return false;
1734                             } catch (ClassCastException cce) {
1735                                 return false;
1736                             }
</pre>
<hr />
<pre>
2358 
2359     /**
2360      * Submaps returned by {@link ConcurrentSkipListMap} submap operations
2361      * represent a subrange of mappings of their underlying maps.
2362      * Instances of this class support all methods of their underlying
2363      * maps, differing in that mappings outside their range are ignored,
2364      * and attempts to add mappings outside their ranges result in {@link
2365      * IllegalArgumentException}.  Instances of this class are constructed
2366      * only using the {@code subMap}, {@code headMap}, and {@code tailMap}
2367      * methods of their underlying maps.
2368      *
2369      * @serial include
2370      */
2371     static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
2372         implements ConcurrentNavigableMap&lt;K,V&gt;, Serializable {
2373         private static final long serialVersionUID = -7647078645895051609L;
2374 
2375         /** Underlying map */
2376         final ConcurrentSkipListMap&lt;K,V&gt; m;
2377         /** lower bound key, or null if from start */

2378         private final K lo;
2379         /** upper bound key, or null if to end */

2380         private final K hi;
2381         /** inclusion flag for lo */
2382         private final boolean loInclusive;
2383         /** inclusion flag for hi */
2384         private final boolean hiInclusive;
2385         /** direction */
2386         final boolean isDescending;
2387 
2388         // Lazily initialized view holders
2389         private transient KeySet&lt;K,V&gt; keySetView;
2390         private transient Values&lt;K,V&gt; valuesView;
2391         private transient EntrySet&lt;K,V&gt; entrySetView;
2392 
2393         /**
2394          * Creates a new submap, initializing all fields.
2395          */
2396         SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,
2397                K fromKey, boolean fromInclusive,
2398                K toKey, boolean toInclusive,
2399                boolean isDescending) {
</pre>
</td>
<td>
<hr />
<pre>
 317      * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell&#39;s
 318      * thesis (http://www.cs.chalmers.se/~phs/).
 319      *
 320      * Notation guide for local variables
 321      * Node:         b, n, f, p for  predecessor, node, successor, aux
 322      * Index:        q, r, d    for index node, right, down.
 323      * Head:         h
 324      * Keys:         k, key
 325      * Values:       v, value
 326      * Comparisons:  c
 327      */
 328 
 329     private static final long serialVersionUID = -8627078645895051609L;
 330 
 331     /**
 332      * The comparator used to maintain order in this map, or null if
 333      * using natural ordering.  (Non-private to simplify access in
 334      * nested classes.)
 335      * @serial
 336      */
<span class="line-added"> 337     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
 338     final Comparator&lt;? super K&gt; comparator;
 339 
 340     /** Lazily initialized topmost index of the skiplist. */
 341     private transient Index&lt;K,V&gt; head;
 342     /** Lazily initialized element count */
 343     private transient LongAdder adder;
 344     /** Lazily initialized key set */
 345     private transient KeySet&lt;K,V&gt; keySet;
 346     /** Lazily initialized values collection */
 347     private transient Values&lt;K,V&gt; values;
 348     /** Lazily initialized entry set */
 349     private transient EntrySet&lt;K,V&gt; entrySet;
 350     /** Lazily initialized descending map */
 351     private transient SubMap&lt;K,V&gt; descendingMap;
 352 
 353     /**
 354      * Nodes hold keys and values, and are singly linked in sorted
 355      * order, possibly with some intervening marker nodes. The list is
 356      * headed by a header node accessible as head.node. Headers and
 357      * marker nodes have null keys. The val field (but currently not
</pre>
<hr />
<pre>
1113     public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {
1114         this.comparator = m.comparator();
1115         buildFromSorted(m); // initializes transients
1116     }
1117 
1118     /**
1119      * Returns a shallow copy of this {@code ConcurrentSkipListMap}
1120      * instance. (The keys and values themselves are not cloned.)
1121      *
1122      * @return a shallow copy of this map
1123      */
1124     public ConcurrentSkipListMap&lt;K,V&gt; clone() {
1125         try {
1126             @SuppressWarnings(&quot;unchecked&quot;)
1127             ConcurrentSkipListMap&lt;K,V&gt; clone =
1128                 (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();
1129             clone.keySet = null;
1130             clone.entrySet = null;
1131             clone.values = null;
1132             clone.descendingMap = null;
<span class="line-added">1133             clone.adder = null;</span>
1134             clone.buildFromSorted(this);
1135             return clone;
1136         } catch (CloneNotSupportedException e) {
1137             throw new InternalError();
1138         }
1139     }
1140 
1141     /**
1142      * Streamlined bulk insertion to initialize from elements of
1143      * given sorted map.  Call only from constructor or clone
1144      * method.
1145      */
1146     private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {
1147         if (map == null)
1148             throw new NullPointerException();
1149         Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =
1150             map.entrySet().iterator();
1151 
1152         /*
1153          * Add equally spaced indices at log intervals, using the bits
</pre>
<hr />
<pre>
1696     /**
1697      * Compares the specified object with this map for equality.
1698      * Returns {@code true} if the given object is also a map and the
1699      * two maps represent the same mappings.  More formally, two maps
1700      * {@code m1} and {@code m2} represent the same mappings if
1701      * {@code m1.entrySet().equals(m2.entrySet())}.  This
1702      * operation may return misleading results if either map is
1703      * concurrently modified during execution of this method.
1704      *
1705      * @param o object to be compared for equality with this map
1706      * @return {@code true} if the specified object is equal to this map
1707      */
1708     public boolean equals(Object o) {
1709         if (o == this)
1710             return true;
1711         if (!(o instanceof Map))
1712             return false;
1713         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;
1714         try {
1715             Comparator&lt;? super K&gt; cmp = comparator;
<span class="line-modified">1716             // See JDK-8223553 for Iterator type wildcard rationale</span>
<span class="line-modified">1717             Iterator&lt;? extends Map.Entry&lt;?,?&gt;&gt; it = m.entrySet().iterator();</span>

1718             if (m instanceof SortedMap &amp;&amp;
1719                 ((SortedMap&lt;?,?&gt;)m).comparator() == cmp) {
1720                 Node&lt;K,V&gt; b, n;
1721                 if ((b = baseHead()) != null) {
1722                     while ((n = b.next) != null) {
1723                         K k; V v;
1724                         if ((v = n.val) != null &amp;&amp; (k = n.key) != null) {
1725                             if (!it.hasNext())
1726                                 return false;
1727                             Map.Entry&lt;?,?&gt; e = it.next();
1728                             Object mk = e.getKey();
1729                             Object mv = e.getValue();
1730                             if (mk == null || mv == null)
1731                                 return false;
1732                             try {
1733                                 if (cpr(cmp, k, mk) != 0)
1734                                     return false;
1735                             } catch (ClassCastException cce) {
1736                                 return false;
1737                             }
</pre>
<hr />
<pre>
2359 
2360     /**
2361      * Submaps returned by {@link ConcurrentSkipListMap} submap operations
2362      * represent a subrange of mappings of their underlying maps.
2363      * Instances of this class support all methods of their underlying
2364      * maps, differing in that mappings outside their range are ignored,
2365      * and attempts to add mappings outside their ranges result in {@link
2366      * IllegalArgumentException}.  Instances of this class are constructed
2367      * only using the {@code subMap}, {@code headMap}, and {@code tailMap}
2368      * methods of their underlying maps.
2369      *
2370      * @serial include
2371      */
2372     static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
2373         implements ConcurrentNavigableMap&lt;K,V&gt;, Serializable {
2374         private static final long serialVersionUID = -7647078645895051609L;
2375 
2376         /** Underlying map */
2377         final ConcurrentSkipListMap&lt;K,V&gt; m;
2378         /** lower bound key, or null if from start */
<span class="line-added">2379         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2380         private final K lo;
2381         /** upper bound key, or null if to end */
<span class="line-added">2382         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2383         private final K hi;
2384         /** inclusion flag for lo */
2385         private final boolean loInclusive;
2386         /** inclusion flag for hi */
2387         private final boolean hiInclusive;
2388         /** direction */
2389         final boolean isDescending;
2390 
2391         // Lazily initialized view holders
2392         private transient KeySet&lt;K,V&gt; keySetView;
2393         private transient Values&lt;K,V&gt; valuesView;
2394         private transient EntrySet&lt;K,V&gt; entrySetView;
2395 
2396         /**
2397          * Creates a new submap, initializing all fields.
2398          */
2399         SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,
2400                K fromKey, boolean fromInclusive,
2401                K toKey, boolean toInclusive,
2402                boolean isDescending) {
</pre>
</td>
</tr>
</table>
<center><a href="ConcurrentHashMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
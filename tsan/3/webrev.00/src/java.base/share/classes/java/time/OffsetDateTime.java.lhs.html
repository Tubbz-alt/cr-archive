<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/OffsetDateTime.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time;
  63 
  64 import static java.time.temporal.ChronoField.EPOCH_DAY;
  65 import static java.time.temporal.ChronoField.INSTANT_SECONDS;
  66 import static java.time.temporal.ChronoField.NANO_OF_DAY;
  67 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
  68 import static java.time.temporal.ChronoUnit.FOREVER;
  69 import static java.time.temporal.ChronoUnit.NANOS;
  70 
  71 import java.io.IOException;
  72 import java.io.ObjectInput;
  73 import java.io.ObjectOutput;
  74 import java.io.InvalidObjectException;
  75 import java.io.ObjectInputStream;
  76 import java.io.Serializable;
  77 import java.time.chrono.IsoChronology;
  78 import java.time.format.DateTimeFormatter;
  79 import java.time.format.DateTimeParseException;
  80 import java.time.temporal.ChronoField;
  81 import java.time.temporal.ChronoUnit;
  82 import java.time.temporal.Temporal;
  83 import java.time.temporal.TemporalAccessor;
  84 import java.time.temporal.TemporalAdjuster;
  85 import java.time.temporal.TemporalAmount;
  86 import java.time.temporal.TemporalField;
  87 import java.time.temporal.TemporalQueries;
  88 import java.time.temporal.TemporalQuery;
  89 import java.time.temporal.TemporalUnit;
  90 import java.time.temporal.UnsupportedTemporalTypeException;
  91 import java.time.temporal.ValueRange;
  92 import java.time.zone.ZoneRules;
  93 import java.util.Comparator;
  94 import java.util.Objects;
  95 
  96 /**
  97  * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,
  98  * such as {@code 2007-12-03T10:15:30+01:00}.
  99  * &lt;p&gt;
 100  * {@code OffsetDateTime} is an immutable representation of a date-time with an offset.
 101  * This class stores all date and time fields, to a precision of nanoseconds,
 102  * as well as the offset from UTC/Greenwich. For example, the value
 103  * &quot;2nd October 2007 at 13:45:30.123456789 +02:00&quot; can be stored in an {@code OffsetDateTime}.
 104  * &lt;p&gt;
 105  * {@code OffsetDateTime}, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant
 106  * on the time-line to nanosecond precision.
 107  * {@code Instant} is the simplest, simply representing the instant.
 108  * {@code OffsetDateTime} adds to the instant the offset from UTC/Greenwich, which allows
 109  * the local date-time to be obtained.
 110  * {@code ZonedDateTime} adds full time-zone rules.
 111  * &lt;p&gt;
 112  * It is intended that {@code ZonedDateTime} or {@code Instant} is used to model data
 113  * in simpler applications. This class may be used when modeling date-time concepts in
 114  * more detail, or when communicating to a database or in a network protocol.
 115  *
 116  * &lt;p&gt;
 117  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 118  * class; use of identity-sensitive operations (including reference equality
 119  * ({@code ==}), identity hash code, or synchronization) on instances of
 120  * {@code OffsetDateTime} may have unpredictable results and should be avoided.
 121  * The {@code equals} method should be used for comparisons.
 122  *
 123  * @implSpec
 124  * This class is immutable and thread-safe.
 125  *
 126  * @since 1.8
 127  */
 128 public final class OffsetDateTime
 129         implements Temporal, TemporalAdjuster, Comparable&lt;OffsetDateTime&gt;, Serializable {
 130 
 131     /**
 132      * The minimum supported {@code OffsetDateTime}, &#39;-999999999-01-01T00:00:00+18:00&#39;.
 133      * This is the local date-time of midnight at the start of the minimum date
 134      * in the maximum offset (larger offsets are earlier on the time-line).
 135      * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.
 136      * This could be used by an application as a &quot;far past&quot; date-time.
 137      */
 138     public static final OffsetDateTime MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
 139     /**
 140      * The maximum supported {@code OffsetDateTime}, &#39;+999999999-12-31T23:59:59.999999999-18:00&#39;.
 141      * This is the local date-time just before midnight at the end of the maximum date
 142      * in the minimum offset (larger negative offsets are later on the time-line).
 143      * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.
 144      * This could be used by an application as a &quot;far future&quot; date-time.
 145      */
 146     public static final OffsetDateTime MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
 147 
 148     /**
 149      * Gets a comparator that compares two {@code OffsetDateTime} instances
 150      * based solely on the instant.
 151      * &lt;p&gt;
 152      * This method differs from the comparison in {@link #compareTo} in that it
 153      * only compares the underlying instant.
 154      *
 155      * @return a comparator that compares in time-line order
 156      *
 157      * @see #isAfter
 158      * @see #isBefore
 159      * @see #isEqual
 160      */
 161     public static Comparator&lt;OffsetDateTime&gt; timeLineOrder() {
 162         return OffsetDateTime::compareInstant;
 163     }
 164 
 165     /**
 166      * Compares this {@code OffsetDateTime} to another date-time.
 167      * The comparison is based on the instant.
 168      *
 169      * @param datetime1  the first date-time to compare, not null
 170      * @param datetime2  the other date-time to compare to, not null
 171      * @return the comparator value, negative if less, positive if greater
 172      */
 173     private static int compareInstant(OffsetDateTime datetime1, OffsetDateTime datetime2) {
 174         if (datetime1.getOffset().equals(datetime2.getOffset())) {
 175             return datetime1.toLocalDateTime().compareTo(datetime2.toLocalDateTime());
 176         }
 177         int cmp = Long.compare(datetime1.toEpochSecond(), datetime2.toEpochSecond());
 178         if (cmp == 0) {
 179             cmp = datetime1.toLocalTime().getNano() - datetime2.toLocalTime().getNano();
 180         }
 181         return cmp;
 182     }
 183 
 184     /**
 185      * Serialization version.
 186      */
<a name="2" id="anc2"></a>
 187     private static final long serialVersionUID = 2287754244819255394L;
 188 
 189     /**
 190      * The local date-time.
 191      */
 192     private final LocalDateTime dateTime;
 193     /**
 194      * The offset from UTC/Greenwich.
 195      */
 196     private final ZoneOffset offset;
 197 
 198     //-----------------------------------------------------------------------
 199     /**
 200      * Obtains the current date-time from the system clock in the default time-zone.
 201      * &lt;p&gt;
 202      * This will query the {@link Clock#systemDefaultZone() system clock} in the default
 203      * time-zone to obtain the current date-time.
 204      * The offset will be calculated from the time-zone in the clock.
 205      * &lt;p&gt;
 206      * Using this method will prevent the ability to use an alternate clock for testing
 207      * because the clock is hard-coded.
 208      *
 209      * @return the current date-time using the system clock, not null
 210      */
 211     public static OffsetDateTime now() {
 212         return now(Clock.systemDefaultZone());
 213     }
 214 
 215     /**
 216      * Obtains the current date-time from the system clock in the specified time-zone.
 217      * &lt;p&gt;
 218      * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.
 219      * Specifying the time-zone avoids dependence on the default time-zone.
 220      * The offset will be calculated from the specified time-zone.
 221      * &lt;p&gt;
 222      * Using this method will prevent the ability to use an alternate clock for testing
 223      * because the clock is hard-coded.
 224      *
 225      * @param zone  the zone ID to use, not null
 226      * @return the current date-time using the system clock, not null
 227      */
 228     public static OffsetDateTime now(ZoneId zone) {
 229         return now(Clock.system(zone));
 230     }
 231 
 232     /**
 233      * Obtains the current date-time from the specified clock.
 234      * &lt;p&gt;
 235      * This will query the specified clock to obtain the current date-time.
 236      * The offset will be calculated from the time-zone in the clock.
 237      * &lt;p&gt;
 238      * Using this method allows the use of an alternate clock for testing.
 239      * The alternate clock may be introduced using {@link Clock dependency injection}.
 240      *
 241      * @param clock  the clock to use, not null
 242      * @return the current date-time, not null
 243      */
 244     public static OffsetDateTime now(Clock clock) {
 245         Objects.requireNonNull(clock, &quot;clock&quot;);
 246         final Instant now = clock.instant();  // called once
 247         return ofInstant(now, clock.getZone().getRules().getOffset(now));
 248     }
 249 
 250     //-----------------------------------------------------------------------
 251     /**
 252      * Obtains an instance of {@code OffsetDateTime} from a date, time and offset.
 253      * &lt;p&gt;
 254      * This creates an offset date-time with the specified local date, time and offset.
 255      *
 256      * @param date  the local date, not null
 257      * @param time  the local time, not null
 258      * @param offset  the zone offset, not null
 259      * @return the offset date-time, not null
 260      */
 261     public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset) {
 262         LocalDateTime dt = LocalDateTime.of(date, time);
 263         return new OffsetDateTime(dt, offset);
 264     }
 265 
 266     /**
 267      * Obtains an instance of {@code OffsetDateTime} from a date-time and offset.
 268      * &lt;p&gt;
 269      * This creates an offset date-time with the specified local date-time and offset.
 270      *
 271      * @param dateTime  the local date-time, not null
 272      * @param offset  the zone offset, not null
 273      * @return the offset date-time, not null
 274      */
 275     public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset) {
 276         return new OffsetDateTime(dateTime, offset);
 277     }
 278 
 279     /**
 280      * Obtains an instance of {@code OffsetDateTime} from a year, month, day,
 281      * hour, minute, second, nanosecond and offset.
 282      * &lt;p&gt;
 283      * This creates an offset date-time with the seven specified fields.
 284      * &lt;p&gt;
 285      * This method exists primarily for writing test cases.
 286      * Non test-code will typically use other methods to create an offset time.
 287      * {@code LocalDateTime} has five additional convenience variants of the
 288      * equivalent factory method taking fewer arguments.
 289      * They are not provided here to reduce the footprint of the API.
 290      *
 291      * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
 292      * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
 293      * @param dayOfMonth  the day-of-month to represent, from 1 to 31
 294      * @param hour  the hour-of-day to represent, from 0 to 23
 295      * @param minute  the minute-of-hour to represent, from 0 to 59
 296      * @param second  the second-of-minute to represent, from 0 to 59
 297      * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
 298      * @param offset  the zone offset, not null
 299      * @return the offset date-time, not null
 300      * @throws DateTimeException if the value of any field is out of range, or
 301      *  if the day-of-month is invalid for the month-year
 302      */
 303     public static OffsetDateTime of(
 304             int year, int month, int dayOfMonth,
 305             int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset) {
 306         LocalDateTime dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
 307         return new OffsetDateTime(dt, offset);
 308     }
 309 
 310     //-----------------------------------------------------------------------
 311     /**
 312      * Obtains an instance of {@code OffsetDateTime} from an {@code Instant} and zone ID.
 313      * &lt;p&gt;
 314      * This creates an offset date-time with the same instant as that specified.
 315      * Finding the offset from UTC/Greenwich is simple as there is only one valid
 316      * offset for each instant.
 317      *
 318      * @param instant  the instant to create the date-time from, not null
 319      * @param zone  the time-zone, which may be an offset, not null
 320      * @return the offset date-time, not null
 321      * @throws DateTimeException if the result exceeds the supported range
 322      */
 323     public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {
 324         Objects.requireNonNull(instant, &quot;instant&quot;);
 325         Objects.requireNonNull(zone, &quot;zone&quot;);
 326         ZoneRules rules = zone.getRules();
 327         ZoneOffset offset = rules.getOffset(instant);
 328         LocalDateTime ldt = LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);
 329         return new OffsetDateTime(ldt, offset);
 330     }
 331 
 332     //-----------------------------------------------------------------------
 333     /**
 334      * Obtains an instance of {@code OffsetDateTime} from a temporal object.
 335      * &lt;p&gt;
 336      * This obtains an offset date-time based on the specified temporal.
 337      * A {@code TemporalAccessor} represents an arbitrary set of date and time information,
 338      * which this factory converts to an instance of {@code OffsetDateTime}.
 339      * &lt;p&gt;
 340      * The conversion will first obtain a {@code ZoneOffset} from the temporal object.
 341      * It will then try to obtain a {@code LocalDateTime}, falling back to an {@code Instant} if necessary.
 342      * The result will be the combination of {@code ZoneOffset} with either
 343      * with {@code LocalDateTime} or {@code Instant}.
 344      * Implementations are permitted to perform optimizations such as accessing
 345      * those fields that are equivalent to the relevant objects.
 346      * &lt;p&gt;
 347      * This method matches the signature of the functional interface {@link TemporalQuery}
 348      * allowing it to be used as a query via method reference, {@code OffsetDateTime::from}.
 349      *
 350      * @param temporal  the temporal object to convert, not null
 351      * @return the offset date-time, not null
 352      * @throws DateTimeException if unable to convert to an {@code OffsetDateTime}
 353      */
 354     public static OffsetDateTime from(TemporalAccessor temporal) {
 355         if (temporal instanceof OffsetDateTime) {
 356             return (OffsetDateTime) temporal;
 357         }
 358         try {
 359             ZoneOffset offset = ZoneOffset.from(temporal);
 360             LocalDate date = temporal.query(TemporalQueries.localDate());
 361             LocalTime time = temporal.query(TemporalQueries.localTime());
 362             if (date != null &amp;&amp; time != null) {
 363                 return OffsetDateTime.of(date, time, offset);
 364             } else {
 365                 Instant instant = Instant.from(temporal);
 366                 return OffsetDateTime.ofInstant(instant, offset);
 367             }
 368         } catch (DateTimeException ex) {
 369             throw new DateTimeException(&quot;Unable to obtain OffsetDateTime from TemporalAccessor: &quot; +
 370                     temporal + &quot; of type &quot; + temporal.getClass().getName(), ex);
 371         }
 372     }
 373 
 374     //-----------------------------------------------------------------------
 375     /**
 376      * Obtains an instance of {@code OffsetDateTime} from a text string
 377      * such as {@code 2007-12-03T10:15:30+01:00}.
 378      * &lt;p&gt;
 379      * The string must represent a valid date-time and is parsed using
 380      * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.
 381      *
 382      * @param text  the text to parse such as &quot;2007-12-03T10:15:30+01:00&quot;, not null
 383      * @return the parsed offset date-time, not null
 384      * @throws DateTimeParseException if the text cannot be parsed
 385      */
 386     public static OffsetDateTime parse(CharSequence text) {
 387         return parse(text, DateTimeFormatter.ISO_OFFSET_DATE_TIME);
 388     }
 389 
 390     /**
 391      * Obtains an instance of {@code OffsetDateTime} from a text string using a specific formatter.
 392      * &lt;p&gt;
 393      * The text is parsed using the formatter, returning a date-time.
 394      *
 395      * @param text  the text to parse, not null
 396      * @param formatter  the formatter to use, not null
 397      * @return the parsed offset date-time, not null
 398      * @throws DateTimeParseException if the text cannot be parsed
 399      */
 400     public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter) {
 401         Objects.requireNonNull(formatter, &quot;formatter&quot;);
 402         return formatter.parse(text, OffsetDateTime::from);
 403     }
 404 
 405     //-----------------------------------------------------------------------
 406     /**
 407      * Constructor.
 408      *
 409      * @param dateTime  the local date-time, not null
 410      * @param offset  the zone offset, not null
 411      */
 412     private OffsetDateTime(LocalDateTime dateTime, ZoneOffset offset) {
 413         this.dateTime = Objects.requireNonNull(dateTime, &quot;dateTime&quot;);
 414         this.offset = Objects.requireNonNull(offset, &quot;offset&quot;);
 415     }
 416 
 417     /**
 418      * Returns a new date-time based on this one, returning {@code this} where possible.
 419      *
 420      * @param dateTime  the date-time to create with, not null
 421      * @param offset  the zone offset to create with, not null
 422      */
 423     private OffsetDateTime with(LocalDateTime dateTime, ZoneOffset offset) {
 424         if (this.dateTime == dateTime &amp;&amp; this.offset.equals(offset)) {
 425             return this;
 426         }
 427         return new OffsetDateTime(dateTime, offset);
 428     }
 429 
 430     //-----------------------------------------------------------------------
 431     /**
 432      * Checks if the specified field is supported.
 433      * &lt;p&gt;
 434      * This checks if this date-time can be queried for the specified field.
 435      * If false, then calling the {@link #range(TemporalField) range},
 436      * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
 437      * methods will throw an exception.
 438      * &lt;p&gt;
 439      * If the field is a {@link ChronoField} then the query is implemented here.
 440      * The supported fields are:
 441      * &lt;ul&gt;
 442      * &lt;li&gt;{@code NANO_OF_SECOND}
 443      * &lt;li&gt;{@code NANO_OF_DAY}
 444      * &lt;li&gt;{@code MICRO_OF_SECOND}
 445      * &lt;li&gt;{@code MICRO_OF_DAY}
 446      * &lt;li&gt;{@code MILLI_OF_SECOND}
 447      * &lt;li&gt;{@code MILLI_OF_DAY}
 448      * &lt;li&gt;{@code SECOND_OF_MINUTE}
 449      * &lt;li&gt;{@code SECOND_OF_DAY}
 450      * &lt;li&gt;{@code MINUTE_OF_HOUR}
 451      * &lt;li&gt;{@code MINUTE_OF_DAY}
 452      * &lt;li&gt;{@code HOUR_OF_AMPM}
 453      * &lt;li&gt;{@code CLOCK_HOUR_OF_AMPM}
 454      * &lt;li&gt;{@code HOUR_OF_DAY}
 455      * &lt;li&gt;{@code CLOCK_HOUR_OF_DAY}
 456      * &lt;li&gt;{@code AMPM_OF_DAY}
 457      * &lt;li&gt;{@code DAY_OF_WEEK}
 458      * &lt;li&gt;{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}
 459      * &lt;li&gt;{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}
 460      * &lt;li&gt;{@code DAY_OF_MONTH}
 461      * &lt;li&gt;{@code DAY_OF_YEAR}
 462      * &lt;li&gt;{@code EPOCH_DAY}
 463      * &lt;li&gt;{@code ALIGNED_WEEK_OF_MONTH}
 464      * &lt;li&gt;{@code ALIGNED_WEEK_OF_YEAR}
 465      * &lt;li&gt;{@code MONTH_OF_YEAR}
 466      * &lt;li&gt;{@code PROLEPTIC_MONTH}
 467      * &lt;li&gt;{@code YEAR_OF_ERA}
 468      * &lt;li&gt;{@code YEAR}
 469      * &lt;li&gt;{@code ERA}
 470      * &lt;li&gt;{@code INSTANT_SECONDS}
 471      * &lt;li&gt;{@code OFFSET_SECONDS}
 472      * &lt;/ul&gt;
 473      * All other {@code ChronoField} instances will return false.
 474      * &lt;p&gt;
 475      * If the field is not a {@code ChronoField}, then the result of this method
 476      * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
 477      * passing {@code this} as the argument.
 478      * Whether the field is supported is determined by the field.
 479      *
 480      * @param field  the field to check, null returns false
 481      * @return true if the field is supported on this date-time, false if not
 482      */
 483     @Override
 484     public boolean isSupported(TemporalField field) {
 485         return field instanceof ChronoField || (field != null &amp;&amp; field.isSupportedBy(this));
 486     }
 487 
 488     /**
 489      * Checks if the specified unit is supported.
 490      * &lt;p&gt;
 491      * This checks if the specified unit can be added to, or subtracted from, this date-time.
 492      * If false, then calling the {@link #plus(long, TemporalUnit)} and
 493      * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
 494      * &lt;p&gt;
 495      * If the unit is a {@link ChronoUnit} then the query is implemented here.
 496      * The supported units are:
 497      * &lt;ul&gt;
 498      * &lt;li&gt;{@code NANOS}
 499      * &lt;li&gt;{@code MICROS}
 500      * &lt;li&gt;{@code MILLIS}
 501      * &lt;li&gt;{@code SECONDS}
 502      * &lt;li&gt;{@code MINUTES}
 503      * &lt;li&gt;{@code HOURS}
 504      * &lt;li&gt;{@code HALF_DAYS}
 505      * &lt;li&gt;{@code DAYS}
 506      * &lt;li&gt;{@code WEEKS}
 507      * &lt;li&gt;{@code MONTHS}
 508      * &lt;li&gt;{@code YEARS}
 509      * &lt;li&gt;{@code DECADES}
 510      * &lt;li&gt;{@code CENTURIES}
 511      * &lt;li&gt;{@code MILLENNIA}
 512      * &lt;li&gt;{@code ERAS}
 513      * &lt;/ul&gt;
 514      * All other {@code ChronoUnit} instances will return false.
 515      * &lt;p&gt;
 516      * If the unit is not a {@code ChronoUnit}, then the result of this method
 517      * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
 518      * passing {@code this} as the argument.
 519      * Whether the unit is supported is determined by the unit.
 520      *
 521      * @param unit  the unit to check, null returns false
 522      * @return true if the unit can be added/subtracted, false if not
 523      */
 524     @Override  // override for Javadoc
 525     public boolean isSupported(TemporalUnit unit) {
 526         if (unit instanceof ChronoUnit) {
 527             return unit != FOREVER;
 528         }
 529         return unit != null &amp;&amp; unit.isSupportedBy(this);
 530     }
 531 
 532     //-----------------------------------------------------------------------
 533     /**
 534      * Gets the range of valid values for the specified field.
 535      * &lt;p&gt;
 536      * The range object expresses the minimum and maximum valid values for a field.
 537      * This date-time is used to enhance the accuracy of the returned range.
 538      * If it is not possible to return the range, because the field is not supported
 539      * or for some other reason, an exception is thrown.
 540      * &lt;p&gt;
 541      * If the field is a {@link ChronoField} then the query is implemented here.
 542      * The {@link #isSupported(TemporalField) supported fields} will return
 543      * appropriate range instances.
 544      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 545      * &lt;p&gt;
 546      * If the field is not a {@code ChronoField}, then the result of this method
 547      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
 548      * passing {@code this} as the argument.
 549      * Whether the range can be obtained is determined by the field.
 550      *
 551      * @param field  the field to query the range for, not null
 552      * @return the range of valid values for the field, not null
 553      * @throws DateTimeException if the range for the field cannot be obtained
 554      * @throws UnsupportedTemporalTypeException if the field is not supported
 555      */
 556     @Override
 557     public ValueRange range(TemporalField field) {
 558         if (field instanceof ChronoField) {
 559             if (field == INSTANT_SECONDS || field == OFFSET_SECONDS) {
 560                 return field.range();
 561             }
 562             return dateTime.range(field);
 563         }
 564         return field.rangeRefinedBy(this);
 565     }
 566 
 567     /**
 568      * Gets the value of the specified field from this date-time as an {@code int}.
 569      * &lt;p&gt;
 570      * This queries this date-time for the value of the specified field.
 571      * The returned value will always be within the valid range of values for the field.
 572      * If it is not possible to return the value, because the field is not supported
 573      * or for some other reason, an exception is thrown.
 574      * &lt;p&gt;
 575      * If the field is a {@link ChronoField} then the query is implemented here.
 576      * The {@link #isSupported(TemporalField) supported fields} will return valid
 577      * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},
 578      * {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too
 579      * large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.
 580      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 581      * &lt;p&gt;
 582      * If the field is not a {@code ChronoField}, then the result of this method
 583      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 584      * passing {@code this} as the argument. Whether the value can be obtained,
 585      * and what the value represents, is determined by the field.
 586      *
 587      * @param field  the field to get, not null
 588      * @return the value for the field
 589      * @throws DateTimeException if a value for the field cannot be obtained or
 590      *         the value is outside the range of valid values for the field
 591      * @throws UnsupportedTemporalTypeException if the field is not supported or
 592      *         the range of values exceeds an {@code int}
 593      * @throws ArithmeticException if numeric overflow occurs
 594      */
 595     @Override
 596     public int get(TemporalField field) {
 597         if (field instanceof ChronoField) {
 598             switch ((ChronoField) field) {
 599                 case INSTANT_SECONDS:
 600                     throw new UnsupportedTemporalTypeException(&quot;Invalid field &#39;InstantSeconds&#39; for get() method, use getLong() instead&quot;);
 601                 case OFFSET_SECONDS:
 602                     return getOffset().getTotalSeconds();
 603             }
 604             return dateTime.get(field);
 605         }
 606         return Temporal.super.get(field);
 607     }
 608 
 609     /**
 610      * Gets the value of the specified field from this date-time as a {@code long}.
 611      * &lt;p&gt;
 612      * This queries this date-time for the value of the specified field.
 613      * If it is not possible to return the value, because the field is not supported
 614      * or for some other reason, an exception is thrown.
 615      * &lt;p&gt;
 616      * If the field is a {@link ChronoField} then the query is implemented here.
 617      * The {@link #isSupported(TemporalField) supported fields} will return valid
 618      * values based on this date-time.
 619      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 620      * &lt;p&gt;
 621      * If the field is not a {@code ChronoField}, then the result of this method
 622      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 623      * passing {@code this} as the argument. Whether the value can be obtained,
 624      * and what the value represents, is determined by the field.
 625      *
 626      * @param field  the field to get, not null
 627      * @return the value for the field
 628      * @throws DateTimeException if a value for the field cannot be obtained
 629      * @throws UnsupportedTemporalTypeException if the field is not supported
 630      * @throws ArithmeticException if numeric overflow occurs
 631      */
 632     @Override
 633     public long getLong(TemporalField field) {
 634         if (field instanceof ChronoField) {
 635             switch ((ChronoField) field) {
 636                 case INSTANT_SECONDS: return toEpochSecond();
 637                 case OFFSET_SECONDS: return getOffset().getTotalSeconds();
 638             }
 639             return dateTime.getLong(field);
 640         }
 641         return field.getFrom(this);
 642     }
 643 
 644     //-----------------------------------------------------------------------
 645     /**
 646      * Gets the zone offset, such as &#39;+01:00&#39;.
 647      * &lt;p&gt;
 648      * This is the offset of the local date-time from UTC/Greenwich.
 649      *
 650      * @return the zone offset, not null
 651      */
 652     public ZoneOffset getOffset() {
 653         return offset;
 654     }
 655 
 656     /**
 657      * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring
 658      * that the result has the same local date-time.
 659      * &lt;p&gt;
 660      * This method returns an object with the same {@code LocalDateTime} and the specified {@code ZoneOffset}.
 661      * No calculation is needed or performed.
 662      * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is
 663      * {@code +03:00}, then this method will return {@code 2007-12-03T10:30+03:00}.
 664      * &lt;p&gt;
 665      * To take into account the difference between the offsets, and adjust the time fields,
 666      * use {@link #withOffsetSameInstant}.
 667      * &lt;p&gt;
 668      * This instance is immutable and unaffected by this method call.
 669      *
 670      * @param offset  the zone offset to change to, not null
 671      * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null
 672      */
 673     public OffsetDateTime withOffsetSameLocal(ZoneOffset offset) {
 674         return with(dateTime, offset);
 675     }
 676 
 677     /**
 678      * Returns a copy of this {@code OffsetDateTime} with the specified offset ensuring
 679      * that the result is at the same instant.
 680      * &lt;p&gt;
 681      * This method returns an object with the specified {@code ZoneOffset} and a {@code LocalDateTime}
 682      * adjusted by the difference between the two offsets.
 683      * This will result in the old and new objects representing the same instant.
 684      * This is useful for finding the local time in a different offset.
 685      * For example, if this time represents {@code 2007-12-03T10:30+02:00} and the offset specified is
 686      * {@code +03:00}, then this method will return {@code 2007-12-03T11:30+03:00}.
 687      * &lt;p&gt;
 688      * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.
 689      * &lt;p&gt;
 690      * This instance is immutable and unaffected by this method call.
 691      *
 692      * @param offset  the zone offset to change to, not null
 693      * @return an {@code OffsetDateTime} based on this date-time with the requested offset, not null
 694      * @throws DateTimeException if the result exceeds the supported date range
 695      */
 696     public OffsetDateTime withOffsetSameInstant(ZoneOffset offset) {
 697         if (offset.equals(this.offset)) {
 698             return this;
 699         }
 700         int difference = offset.getTotalSeconds() - this.offset.getTotalSeconds();
 701         LocalDateTime adjusted = dateTime.plusSeconds(difference);
 702         return new OffsetDateTime(adjusted, offset);
 703     }
 704 
 705     //-----------------------------------------------------------------------
 706     /**
 707      * Gets the {@code LocalDateTime} part of this date-time.
 708      * &lt;p&gt;
 709      * This returns a {@code LocalDateTime} with the same year, month, day and time
 710      * as this date-time.
 711      *
 712      * @return the local date-time part of this date-time, not null
 713      */
 714     public LocalDateTime toLocalDateTime() {
 715         return dateTime;
 716     }
 717 
 718     //-----------------------------------------------------------------------
 719     /**
 720      * Gets the {@code LocalDate} part of this date-time.
 721      * &lt;p&gt;
 722      * This returns a {@code LocalDate} with the same year, month and day
 723      * as this date-time.
 724      *
 725      * @return the date part of this date-time, not null
 726      */
 727     public LocalDate toLocalDate() {
 728         return dateTime.toLocalDate();
 729     }
 730 
 731     /**
 732      * Gets the year field.
 733      * &lt;p&gt;
 734      * This method returns the primitive {@code int} value for the year.
 735      * &lt;p&gt;
 736      * The year returned by this method is proleptic as per {@code get(YEAR)}.
 737      * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.
 738      *
 739      * @return the year, from MIN_YEAR to MAX_YEAR
 740      */
 741     public int getYear() {
 742         return dateTime.getYear();
 743     }
 744 
 745     /**
 746      * Gets the month-of-year field from 1 to 12.
 747      * &lt;p&gt;
 748      * This method returns the month as an {@code int} from 1 to 12.
 749      * Application code is frequently clearer if the enum {@link Month}
 750      * is used by calling {@link #getMonth()}.
 751      *
 752      * @return the month-of-year, from 1 to 12
 753      * @see #getMonth()
 754      */
 755     public int getMonthValue() {
 756         return dateTime.getMonthValue();
 757     }
 758 
 759     /**
 760      * Gets the month-of-year field using the {@code Month} enum.
 761      * &lt;p&gt;
 762      * This method returns the enum {@link Month} for the month.
 763      * This avoids confusion as to what {@code int} values mean.
 764      * If you need access to the primitive {@code int} value then the enum
 765      * provides the {@link Month#getValue() int value}.
 766      *
 767      * @return the month-of-year, not null
 768      * @see #getMonthValue()
 769      */
 770     public Month getMonth() {
 771         return dateTime.getMonth();
 772     }
 773 
 774     /**
 775      * Gets the day-of-month field.
 776      * &lt;p&gt;
 777      * This method returns the primitive {@code int} value for the day-of-month.
 778      *
 779      * @return the day-of-month, from 1 to 31
 780      */
 781     public int getDayOfMonth() {
 782         return dateTime.getDayOfMonth();
 783     }
 784 
 785     /**
 786      * Gets the day-of-year field.
 787      * &lt;p&gt;
 788      * This method returns the primitive {@code int} value for the day-of-year.
 789      *
 790      * @return the day-of-year, from 1 to 365, or 366 in a leap year
 791      */
 792     public int getDayOfYear() {
 793         return dateTime.getDayOfYear();
 794     }
 795 
 796     /**
 797      * Gets the day-of-week field, which is an enum {@code DayOfWeek}.
 798      * &lt;p&gt;
 799      * This method returns the enum {@link DayOfWeek} for the day-of-week.
 800      * This avoids confusion as to what {@code int} values mean.
 801      * If you need access to the primitive {@code int} value then the enum
 802      * provides the {@link DayOfWeek#getValue() int value}.
 803      * &lt;p&gt;
 804      * Additional information can be obtained from the {@code DayOfWeek}.
 805      * This includes textual names of the values.
 806      *
 807      * @return the day-of-week, not null
 808      */
 809     public DayOfWeek getDayOfWeek() {
 810         return dateTime.getDayOfWeek();
 811     }
 812 
 813     //-----------------------------------------------------------------------
 814     /**
 815      * Gets the {@code LocalTime} part of this date-time.
 816      * &lt;p&gt;
 817      * This returns a {@code LocalTime} with the same hour, minute, second and
 818      * nanosecond as this date-time.
 819      *
 820      * @return the time part of this date-time, not null
 821      */
 822     public LocalTime toLocalTime() {
 823         return dateTime.toLocalTime();
 824     }
 825 
 826     /**
 827      * Gets the hour-of-day field.
 828      *
 829      * @return the hour-of-day, from 0 to 23
 830      */
 831     public int getHour() {
 832         return dateTime.getHour();
 833     }
 834 
 835     /**
 836      * Gets the minute-of-hour field.
 837      *
 838      * @return the minute-of-hour, from 0 to 59
 839      */
 840     public int getMinute() {
 841         return dateTime.getMinute();
 842     }
 843 
 844     /**
 845      * Gets the second-of-minute field.
 846      *
 847      * @return the second-of-minute, from 0 to 59
 848      */
 849     public int getSecond() {
 850         return dateTime.getSecond();
 851     }
 852 
 853     /**
 854      * Gets the nano-of-second field.
 855      *
 856      * @return the nano-of-second, from 0 to 999,999,999
 857      */
 858     public int getNano() {
 859         return dateTime.getNano();
 860     }
 861 
 862     //-----------------------------------------------------------------------
 863     /**
 864      * Returns an adjusted copy of this date-time.
 865      * &lt;p&gt;
 866      * This returns an {@code OffsetDateTime}, based on this one, with the date-time adjusted.
 867      * The adjustment takes place using the specified adjuster strategy object.
 868      * Read the documentation of the adjuster to understand what adjustment will be made.
 869      * &lt;p&gt;
 870      * A simple adjuster might simply set the one of the fields, such as the year field.
 871      * A more complex adjuster might set the date to the last day of the month.
 872      * A selection of common adjustments is provided in
 873      * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
 874      * These include finding the &quot;last day of the month&quot; and &quot;next Wednesday&quot;.
 875      * Key date-time classes also implement the {@code TemporalAdjuster} interface,
 876      * such as {@link Month} and {@link java.time.MonthDay MonthDay}.
 877      * The adjuster is responsible for handling special cases, such as the varying
 878      * lengths of month and leap years.
 879      * &lt;p&gt;
 880      * For example this code returns a date on the last day of July:
 881      * &lt;pre&gt;
 882      *  import static java.time.Month.*;
 883      *  import static java.time.temporal.TemporalAdjusters.*;
 884      *
 885      *  result = offsetDateTime.with(JULY).with(lastDayOfMonth());
 886      * &lt;/pre&gt;
 887      * &lt;p&gt;
 888      * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement
 889      * {@code TemporalAdjuster}, thus this method can be used to change the date, time or offset:
 890      * &lt;pre&gt;
 891      *  result = offsetDateTime.with(date);
 892      *  result = offsetDateTime.with(time);
 893      *  result = offsetDateTime.with(offset);
 894      * &lt;/pre&gt;
 895      * &lt;p&gt;
 896      * The result of this method is obtained by invoking the
 897      * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
 898      * specified adjuster passing {@code this} as the argument.
 899      * &lt;p&gt;
 900      * This instance is immutable and unaffected by this method call.
 901      *
 902      * @param adjuster the adjuster to use, not null
 903      * @return an {@code OffsetDateTime} based on {@code this} with the adjustment made, not null
 904      * @throws DateTimeException if the adjustment cannot be made
 905      * @throws ArithmeticException if numeric overflow occurs
 906      */
 907     @Override
 908     public OffsetDateTime with(TemporalAdjuster adjuster) {
 909         // optimizations
 910         if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
 911             return with(dateTime.with(adjuster), offset);
 912         } else if (adjuster instanceof Instant) {
 913             return ofInstant((Instant) adjuster, offset);
 914         } else if (adjuster instanceof ZoneOffset) {
 915             return with(dateTime, (ZoneOffset) adjuster);
 916         } else if (adjuster instanceof OffsetDateTime) {
 917             return (OffsetDateTime) adjuster;
 918         }
 919         return (OffsetDateTime) adjuster.adjustInto(this);
 920     }
 921 
 922     /**
 923      * Returns a copy of this date-time with the specified field set to a new value.
 924      * &lt;p&gt;
 925      * This returns an {@code OffsetDateTime}, based on this one, with the value
 926      * for the specified field changed.
 927      * This can be used to change any supported field, such as the year, month or day-of-month.
 928      * If it is not possible to set the value, because the field is not supported or for
 929      * some other reason, an exception is thrown.
 930      * &lt;p&gt;
 931      * In some cases, changing the specified field can cause the resulting date-time to become invalid,
 932      * such as changing the month from 31st January to February would make the day-of-month invalid.
 933      * In cases like this, the field is responsible for resolving the date. Typically it will choose
 934      * the previous valid date, which would be the last valid day of February in this example.
 935      * &lt;p&gt;
 936      * If the field is a {@link ChronoField} then the adjustment is implemented here.
 937      * &lt;p&gt;
 938      * The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.
 939      * The offset and nano-of-second are unchanged.
 940      * If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.
 941      * &lt;p&gt;
 942      * The {@code OFFSET_SECONDS} field will return a date-time with the specified offset.
 943      * The local date-time is unaltered. If the new offset value is outside the valid range
 944      * then a {@code DateTimeException} will be thrown.
 945      * &lt;p&gt;
 946      * The other {@link #isSupported(TemporalField) supported fields} will behave as per
 947      * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.
 948      * In this case, the offset is not part of the calculation and will be unchanged.
 949      * &lt;p&gt;
 950      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 951      * &lt;p&gt;
 952      * If the field is not a {@code ChronoField}, then the result of this method
 953      * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
 954      * passing {@code this} as the argument. In this case, the field determines
 955      * whether and how to adjust the instant.
 956      * &lt;p&gt;
 957      * This instance is immutable and unaffected by this method call.
 958      *
 959      * @param field  the field to set in the result, not null
 960      * @param newValue  the new value of the field in the result
 961      * @return an {@code OffsetDateTime} based on {@code this} with the specified field set, not null
 962      * @throws DateTimeException if the field cannot be set
 963      * @throws UnsupportedTemporalTypeException if the field is not supported
 964      * @throws ArithmeticException if numeric overflow occurs
 965      */
 966     @Override
 967     public OffsetDateTime with(TemporalField field, long newValue) {
 968         if (field instanceof ChronoField) {
 969             ChronoField f = (ChronoField) field;
 970             switch (f) {
 971                 case INSTANT_SECONDS: return ofInstant(Instant.ofEpochSecond(newValue, getNano()), offset);
 972                 case OFFSET_SECONDS: {
 973                     return with(dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
 974                 }
 975             }
 976             return with(dateTime.with(field, newValue), offset);
 977         }
 978         return field.adjustInto(this, newValue);
 979     }
 980 
 981     //-----------------------------------------------------------------------
 982     /**
 983      * Returns a copy of this {@code OffsetDateTime} with the year altered.
 984      * &lt;p&gt;
 985      * The time and offset do not affect the calculation and will be the same in the result.
 986      * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
 987      * &lt;p&gt;
 988      * This instance is immutable and unaffected by this method call.
 989      *
 990      * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR
 991      * @return an {@code OffsetDateTime} based on this date-time with the requested year, not null
 992      * @throws DateTimeException if the year value is invalid
 993      */
 994     public OffsetDateTime withYear(int year) {
 995         return with(dateTime.withYear(year), offset);
 996     }
 997 
 998     /**
 999      * Returns a copy of this {@code OffsetDateTime} with the month-of-year altered.
1000      * &lt;p&gt;
1001      * The time and offset do not affect the calculation and will be the same in the result.
1002      * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
1003      * &lt;p&gt;
1004      * This instance is immutable and unaffected by this method call.
1005      *
1006      * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)
1007      * @return an {@code OffsetDateTime} based on this date-time with the requested month, not null
1008      * @throws DateTimeException if the month-of-year value is invalid
1009      */
1010     public OffsetDateTime withMonth(int month) {
1011         return with(dateTime.withMonth(month), offset);
1012     }
1013 
1014     /**
1015      * Returns a copy of this {@code OffsetDateTime} with the day-of-month altered.
1016      * &lt;p&gt;
1017      * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.
1018      * The time and offset do not affect the calculation and will be the same in the result.
1019      * &lt;p&gt;
1020      * This instance is immutable and unaffected by this method call.
1021      *
1022      * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31
1023      * @return an {@code OffsetDateTime} based on this date-time with the requested day, not null
1024      * @throws DateTimeException if the day-of-month value is invalid,
1025      *  or if the day-of-month is invalid for the month-year
1026      */
1027     public OffsetDateTime withDayOfMonth(int dayOfMonth) {
1028         return with(dateTime.withDayOfMonth(dayOfMonth), offset);
1029     }
1030 
1031     /**
1032      * Returns a copy of this {@code OffsetDateTime} with the day-of-year altered.
1033      * &lt;p&gt;
1034      * The time and offset do not affect the calculation and will be the same in the result.
1035      * If the resulting {@code OffsetDateTime} is invalid, an exception is thrown.
1036      * &lt;p&gt;
1037      * This instance is immutable and unaffected by this method call.
1038      *
1039      * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366
1040      * @return an {@code OffsetDateTime} based on this date with the requested day, not null
1041      * @throws DateTimeException if the day-of-year value is invalid,
1042      *  or if the day-of-year is invalid for the year
1043      */
1044     public OffsetDateTime withDayOfYear(int dayOfYear) {
1045         return with(dateTime.withDayOfYear(dayOfYear), offset);
1046     }
1047 
1048     //-----------------------------------------------------------------------
1049     /**
1050      * Returns a copy of this {@code OffsetDateTime} with the hour-of-day altered.
1051      * &lt;p&gt;
1052      * The date and offset do not affect the calculation and will be the same in the result.
1053      * &lt;p&gt;
1054      * This instance is immutable and unaffected by this method call.
1055      *
1056      * @param hour  the hour-of-day to set in the result, from 0 to 23
1057      * @return an {@code OffsetDateTime} based on this date-time with the requested hour, not null
1058      * @throws DateTimeException if the hour value is invalid
1059      */
1060     public OffsetDateTime withHour(int hour) {
1061         return with(dateTime.withHour(hour), offset);
1062     }
1063 
1064     /**
1065      * Returns a copy of this {@code OffsetDateTime} with the minute-of-hour altered.
1066      * &lt;p&gt;
1067      * The date and offset do not affect the calculation and will be the same in the result.
1068      * &lt;p&gt;
1069      * This instance is immutable and unaffected by this method call.
1070      *
1071      * @param minute  the minute-of-hour to set in the result, from 0 to 59
1072      * @return an {@code OffsetDateTime} based on this date-time with the requested minute, not null
1073      * @throws DateTimeException if the minute value is invalid
1074      */
1075     public OffsetDateTime withMinute(int minute) {
1076         return with(dateTime.withMinute(minute), offset);
1077     }
1078 
1079     /**
1080      * Returns a copy of this {@code OffsetDateTime} with the second-of-minute altered.
1081      * &lt;p&gt;
1082      * The date and offset do not affect the calculation and will be the same in the result.
1083      * &lt;p&gt;
1084      * This instance is immutable and unaffected by this method call.
1085      *
1086      * @param second  the second-of-minute to set in the result, from 0 to 59
1087      * @return an {@code OffsetDateTime} based on this date-time with the requested second, not null
1088      * @throws DateTimeException if the second value is invalid
1089      */
1090     public OffsetDateTime withSecond(int second) {
1091         return with(dateTime.withSecond(second), offset);
1092     }
1093 
1094     /**
1095      * Returns a copy of this {@code OffsetDateTime} with the nano-of-second altered.
1096      * &lt;p&gt;
1097      * The date and offset do not affect the calculation and will be the same in the result.
1098      * &lt;p&gt;
1099      * This instance is immutable and unaffected by this method call.
1100      *
1101      * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
1102      * @return an {@code OffsetDateTime} based on this date-time with the requested nanosecond, not null
1103      * @throws DateTimeException if the nano value is invalid
1104      */
1105     public OffsetDateTime withNano(int nanoOfSecond) {
1106         return with(dateTime.withNano(nanoOfSecond), offset);
1107     }
1108 
1109     //-----------------------------------------------------------------------
1110     /**
1111      * Returns a copy of this {@code OffsetDateTime} with the time truncated.
1112      * &lt;p&gt;
1113      * Truncation returns a copy of the original date-time with fields
1114      * smaller than the specified unit set to zero.
1115      * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
1116      * will set the second-of-minute and nano-of-second field to zero.
1117      * &lt;p&gt;
1118      * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
1119      * that divides into the length of a standard day without remainder.
1120      * This includes all supplied time units on {@link ChronoUnit} and
1121      * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
1122      * &lt;p&gt;
1123      * The offset does not affect the calculation and will be the same in the result.
1124      * &lt;p&gt;
1125      * This instance is immutable and unaffected by this method call.
1126      *
1127      * @param unit  the unit to truncate to, not null
1128      * @return an {@code OffsetDateTime} based on this date-time with the time truncated, not null
1129      * @throws DateTimeException if unable to truncate
1130      * @throws UnsupportedTemporalTypeException if the unit is not supported
1131      */
1132     public OffsetDateTime truncatedTo(TemporalUnit unit) {
1133         return with(dateTime.truncatedTo(unit), offset);
1134     }
1135 
1136     //-----------------------------------------------------------------------
1137     /**
1138      * Returns a copy of this date-time with the specified amount added.
1139      * &lt;p&gt;
1140      * This returns an {@code OffsetDateTime}, based on this one, with the specified amount added.
1141      * The amount is typically {@link Period} or {@link Duration} but may be
1142      * any other type implementing the {@link TemporalAmount} interface.
1143      * &lt;p&gt;
1144      * The calculation is delegated to the amount object by calling
1145      * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
1146      * to implement the addition in any way it wishes, however it typically
1147      * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
1148      * of the amount implementation to determine if it can be successfully added.
1149      * &lt;p&gt;
1150      * This instance is immutable and unaffected by this method call.
1151      *
1152      * @param amountToAdd  the amount to add, not null
1153      * @return an {@code OffsetDateTime} based on this date-time with the addition made, not null
1154      * @throws DateTimeException if the addition cannot be made
1155      * @throws ArithmeticException if numeric overflow occurs
1156      */
1157     @Override
1158     public OffsetDateTime plus(TemporalAmount amountToAdd) {
1159         return (OffsetDateTime) amountToAdd.addTo(this);
1160     }
1161 
1162     /**
1163      * Returns a copy of this date-time with the specified amount added.
1164      * &lt;p&gt;
1165      * This returns an {@code OffsetDateTime}, based on this one, with the amount
1166      * in terms of the unit added. If it is not possible to add the amount, because the
1167      * unit is not supported or for some other reason, an exception is thrown.
1168      * &lt;p&gt;
1169      * If the field is a {@link ChronoUnit} then the addition is implemented by
1170      * {@link LocalDateTime#plus(long, TemporalUnit)}.
1171      * The offset is not part of the calculation and will be unchanged in the result.
1172      * &lt;p&gt;
1173      * If the field is not a {@code ChronoUnit}, then the result of this method
1174      * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
1175      * passing {@code this} as the argument. In this case, the unit determines
1176      * whether and how to perform the addition.
1177      * &lt;p&gt;
1178      * This instance is immutable and unaffected by this method call.
1179      *
1180      * @param amountToAdd  the amount of the unit to add to the result, may be negative
1181      * @param unit  the unit of the amount to add, not null
1182      * @return an {@code OffsetDateTime} based on this date-time with the specified amount added, not null
1183      * @throws DateTimeException if the addition cannot be made
1184      * @throws UnsupportedTemporalTypeException if the unit is not supported
1185      * @throws ArithmeticException if numeric overflow occurs
1186      */
1187     @Override
1188     public OffsetDateTime plus(long amountToAdd, TemporalUnit unit) {
1189         if (unit instanceof ChronoUnit) {
1190             return with(dateTime.plus(amountToAdd, unit), offset);
1191         }
1192         return unit.addTo(this, amountToAdd);
1193     }
1194 
1195     //-----------------------------------------------------------------------
1196     /**
1197      * Returns a copy of this {@code OffsetDateTime} with the specified number of years added.
1198      * &lt;p&gt;
1199      * This method adds the specified amount to the years field in three steps:
1200      * &lt;ol&gt;
1201      * &lt;li&gt;Add the input years to the year field&lt;/li&gt;
1202      * &lt;li&gt;Check if the resulting date would be invalid&lt;/li&gt;
1203      * &lt;li&gt;Adjust the day-of-month to the last valid day if necessary&lt;/li&gt;
1204      * &lt;/ol&gt;
1205      * &lt;p&gt;
1206      * For example, 2008-02-29 (leap year) plus one year would result in the
1207      * invalid date 2009-02-29 (standard year). Instead of returning an invalid
1208      * result, the last valid day of the month, 2009-02-28, is selected instead.
1209      * &lt;p&gt;
1210      * This instance is immutable and unaffected by this method call.
1211      *
1212      * @param years  the years to add, may be negative
1213      * @return an {@code OffsetDateTime} based on this date-time with the years added, not null
1214      * @throws DateTimeException if the result exceeds the supported date range
1215      */
1216     public OffsetDateTime plusYears(long years) {
1217         return with(dateTime.plusYears(years), offset);
1218     }
1219 
1220     /**
1221      * Returns a copy of this {@code OffsetDateTime} with the specified number of months added.
1222      * &lt;p&gt;
1223      * This method adds the specified amount to the months field in three steps:
1224      * &lt;ol&gt;
1225      * &lt;li&gt;Add the input months to the month-of-year field&lt;/li&gt;
1226      * &lt;li&gt;Check if the resulting date would be invalid&lt;/li&gt;
1227      * &lt;li&gt;Adjust the day-of-month to the last valid day if necessary&lt;/li&gt;
1228      * &lt;/ol&gt;
1229      * &lt;p&gt;
1230      * For example, 2007-03-31 plus one month would result in the invalid date
1231      * 2007-04-31. Instead of returning an invalid result, the last valid day
1232      * of the month, 2007-04-30, is selected instead.
1233      * &lt;p&gt;
1234      * This instance is immutable and unaffected by this method call.
1235      *
1236      * @param months  the months to add, may be negative
1237      * @return an {@code OffsetDateTime} based on this date-time with the months added, not null
1238      * @throws DateTimeException if the result exceeds the supported date range
1239      */
1240     public OffsetDateTime plusMonths(long months) {
1241         return with(dateTime.plusMonths(months), offset);
1242     }
1243 
1244     /**
1245      * Returns a copy of this OffsetDateTime with the specified number of weeks added.
1246      * &lt;p&gt;
1247      * This method adds the specified amount in weeks to the days field incrementing
1248      * the month and year fields as necessary to ensure the result remains valid.
1249      * The result is only invalid if the maximum/minimum year is exceeded.
1250      * &lt;p&gt;
1251      * For example, 2008-12-31 plus one week would result in 2009-01-07.
1252      * &lt;p&gt;
1253      * This instance is immutable and unaffected by this method call.
1254      *
1255      * @param weeks  the weeks to add, may be negative
1256      * @return an {@code OffsetDateTime} based on this date-time with the weeks added, not null
1257      * @throws DateTimeException if the result exceeds the supported date range
1258      */
1259     public OffsetDateTime plusWeeks(long weeks) {
1260         return with(dateTime.plusWeeks(weeks), offset);
1261     }
1262 
1263     /**
1264      * Returns a copy of this OffsetDateTime with the specified number of days added.
1265      * &lt;p&gt;
1266      * This method adds the specified amount to the days field incrementing the
1267      * month and year fields as necessary to ensure the result remains valid.
1268      * The result is only invalid if the maximum/minimum year is exceeded.
1269      * &lt;p&gt;
1270      * For example, 2008-12-31 plus one day would result in 2009-01-01.
1271      * &lt;p&gt;
1272      * This instance is immutable and unaffected by this method call.
1273      *
1274      * @param days  the days to add, may be negative
1275      * @return an {@code OffsetDateTime} based on this date-time with the days added, not null
1276      * @throws DateTimeException if the result exceeds the supported date range
1277      */
1278     public OffsetDateTime plusDays(long days) {
1279         return with(dateTime.plusDays(days), offset);
1280     }
1281 
1282     /**
1283      * Returns a copy of this {@code OffsetDateTime} with the specified number of hours added.
1284      * &lt;p&gt;
1285      * This instance is immutable and unaffected by this method call.
1286      *
1287      * @param hours  the hours to add, may be negative
1288      * @return an {@code OffsetDateTime} based on this date-time with the hours added, not null
1289      * @throws DateTimeException if the result exceeds the supported date range
1290      */
1291     public OffsetDateTime plusHours(long hours) {
1292         return with(dateTime.plusHours(hours), offset);
1293     }
1294 
1295     /**
1296      * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes added.
1297      * &lt;p&gt;
1298      * This instance is immutable and unaffected by this method call.
1299      *
1300      * @param minutes  the minutes to add, may be negative
1301      * @return an {@code OffsetDateTime} based on this date-time with the minutes added, not null
1302      * @throws DateTimeException if the result exceeds the supported date range
1303      */
1304     public OffsetDateTime plusMinutes(long minutes) {
1305         return with(dateTime.plusMinutes(minutes), offset);
1306     }
1307 
1308     /**
1309      * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds added.
1310      * &lt;p&gt;
1311      * This instance is immutable and unaffected by this method call.
1312      *
1313      * @param seconds  the seconds to add, may be negative
1314      * @return an {@code OffsetDateTime} based on this date-time with the seconds added, not null
1315      * @throws DateTimeException if the result exceeds the supported date range
1316      */
1317     public OffsetDateTime plusSeconds(long seconds) {
1318         return with(dateTime.plusSeconds(seconds), offset);
1319     }
1320 
1321     /**
1322      * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds added.
1323      * &lt;p&gt;
1324      * This instance is immutable and unaffected by this method call.
1325      *
1326      * @param nanos  the nanos to add, may be negative
1327      * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds added, not null
1328      * @throws DateTimeException if the unit cannot be added to this type
1329      */
1330     public OffsetDateTime plusNanos(long nanos) {
1331         return with(dateTime.plusNanos(nanos), offset);
1332     }
1333 
1334     //-----------------------------------------------------------------------
1335     /**
1336      * Returns a copy of this date-time with the specified amount subtracted.
1337      * &lt;p&gt;
1338      * This returns an {@code OffsetDateTime}, based on this one, with the specified amount subtracted.
1339      * The amount is typically {@link Period} or {@link Duration} but may be
1340      * any other type implementing the {@link TemporalAmount} interface.
1341      * &lt;p&gt;
1342      * The calculation is delegated to the amount object by calling
1343      * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
1344      * to implement the subtraction in any way it wishes, however it typically
1345      * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
1346      * of the amount implementation to determine if it can be successfully subtracted.
1347      * &lt;p&gt;
1348      * This instance is immutable and unaffected by this method call.
1349      *
1350      * @param amountToSubtract  the amount to subtract, not null
1351      * @return an {@code OffsetDateTime} based on this date-time with the subtraction made, not null
1352      * @throws DateTimeException if the subtraction cannot be made
1353      * @throws ArithmeticException if numeric overflow occurs
1354      */
1355     @Override
1356     public OffsetDateTime minus(TemporalAmount amountToSubtract) {
1357         return (OffsetDateTime) amountToSubtract.subtractFrom(this);
1358     }
1359 
1360     /**
1361      * Returns a copy of this date-time with the specified amount subtracted.
1362      * &lt;p&gt;
1363      * This returns an {@code OffsetDateTime}, based on this one, with the amount
1364      * in terms of the unit subtracted. If it is not possible to subtract the amount,
1365      * because the unit is not supported or for some other reason, an exception is thrown.
1366      * &lt;p&gt;
1367      * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
1368      * See that method for a full description of how addition, and thus subtraction, works.
1369      * &lt;p&gt;
1370      * This instance is immutable and unaffected by this method call.
1371      *
1372      * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
1373      * @param unit  the unit of the amount to subtract, not null
1374      * @return an {@code OffsetDateTime} based on this date-time with the specified amount subtracted, not null
1375      * @throws DateTimeException if the subtraction cannot be made
1376      * @throws UnsupportedTemporalTypeException if the unit is not supported
1377      * @throws ArithmeticException if numeric overflow occurs
1378      */
1379     @Override
1380     public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit) {
1381         return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
1382     }
1383 
1384     //-----------------------------------------------------------------------
1385     /**
1386      * Returns a copy of this {@code OffsetDateTime} with the specified number of years subtracted.
1387      * &lt;p&gt;
1388      * This method subtracts the specified amount from the years field in three steps:
1389      * &lt;ol&gt;
1390      * &lt;li&gt;Subtract the input years from the year field&lt;/li&gt;
1391      * &lt;li&gt;Check if the resulting date would be invalid&lt;/li&gt;
1392      * &lt;li&gt;Adjust the day-of-month to the last valid day if necessary&lt;/li&gt;
1393      * &lt;/ol&gt;
1394      * &lt;p&gt;
1395      * For example, 2008-02-29 (leap year) minus one year would result in the
1396      * invalid date 2007-02-29 (standard year). Instead of returning an invalid
1397      * result, the last valid day of the month, 2007-02-28, is selected instead.
1398      * &lt;p&gt;
1399      * This instance is immutable and unaffected by this method call.
1400      *
1401      * @param years  the years to subtract, may be negative
1402      * @return an {@code OffsetDateTime} based on this date-time with the years subtracted, not null
1403      * @throws DateTimeException if the result exceeds the supported date range
1404      */
1405     public OffsetDateTime minusYears(long years) {
1406         return (years == Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));
1407     }
1408 
1409     /**
1410      * Returns a copy of this {@code OffsetDateTime} with the specified number of months subtracted.
1411      * &lt;p&gt;
1412      * This method subtracts the specified amount from the months field in three steps:
1413      * &lt;ol&gt;
1414      * &lt;li&gt;Subtract the input months from the month-of-year field&lt;/li&gt;
1415      * &lt;li&gt;Check if the resulting date would be invalid&lt;/li&gt;
1416      * &lt;li&gt;Adjust the day-of-month to the last valid day if necessary&lt;/li&gt;
1417      * &lt;/ol&gt;
1418      * &lt;p&gt;
1419      * For example, 2007-03-31 minus one month would result in the invalid date
1420      * 2007-02-31. Instead of returning an invalid result, the last valid day
1421      * of the month, 2007-02-28, is selected instead.
1422      * &lt;p&gt;
1423      * This instance is immutable and unaffected by this method call.
1424      *
1425      * @param months  the months to subtract, may be negative
1426      * @return an {@code OffsetDateTime} based on this date-time with the months subtracted, not null
1427      * @throws DateTimeException if the result exceeds the supported date range
1428      */
1429     public OffsetDateTime minusMonths(long months) {
1430         return (months == Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));
1431     }
1432 
1433     /**
1434      * Returns a copy of this {@code OffsetDateTime} with the specified number of weeks subtracted.
1435      * &lt;p&gt;
1436      * This method subtracts the specified amount in weeks from the days field decrementing
1437      * the month and year fields as necessary to ensure the result remains valid.
1438      * The result is only invalid if the maximum/minimum year is exceeded.
1439      * &lt;p&gt;
1440      * For example, 2009-01-07 minus one week would result in 2008-12-31.
1441      * &lt;p&gt;
1442      * This instance is immutable and unaffected by this method call.
1443      *
1444      * @param weeks  the weeks to subtract, may be negative
1445      * @return an {@code OffsetDateTime} based on this date-time with the weeks subtracted, not null
1446      * @throws DateTimeException if the result exceeds the supported date range
1447      */
1448     public OffsetDateTime minusWeeks(long weeks) {
1449         return (weeks == Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));
1450     }
1451 
1452     /**
1453      * Returns a copy of this {@code OffsetDateTime} with the specified number of days subtracted.
1454      * &lt;p&gt;
1455      * This method subtracts the specified amount from the days field decrementing the
1456      * month and year fields as necessary to ensure the result remains valid.
1457      * The result is only invalid if the maximum/minimum year is exceeded.
1458      * &lt;p&gt;
1459      * For example, 2009-01-01 minus one day would result in 2008-12-31.
1460      * &lt;p&gt;
1461      * This instance is immutable and unaffected by this method call.
1462      *
1463      * @param days  the days to subtract, may be negative
1464      * @return an {@code OffsetDateTime} based on this date-time with the days subtracted, not null
1465      * @throws DateTimeException if the result exceeds the supported date range
1466      */
1467     public OffsetDateTime minusDays(long days) {
1468         return (days == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));
1469     }
1470 
1471     /**
1472      * Returns a copy of this {@code OffsetDateTime} with the specified number of hours subtracted.
1473      * &lt;p&gt;
1474      * This instance is immutable and unaffected by this method call.
1475      *
1476      * @param hours  the hours to subtract, may be negative
1477      * @return an {@code OffsetDateTime} based on this date-time with the hours subtracted, not null
1478      * @throws DateTimeException if the result exceeds the supported date range
1479      */
1480     public OffsetDateTime minusHours(long hours) {
1481         return (hours == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hours));
1482     }
1483 
1484     /**
1485      * Returns a copy of this {@code OffsetDateTime} with the specified number of minutes subtracted.
1486      * &lt;p&gt;
1487      * This instance is immutable and unaffected by this method call.
1488      *
1489      * @param minutes  the minutes to subtract, may be negative
1490      * @return an {@code OffsetDateTime} based on this date-time with the minutes subtracted, not null
1491      * @throws DateTimeException if the result exceeds the supported date range
1492      */
1493     public OffsetDateTime minusMinutes(long minutes) {
1494         return (minutes == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutes));
1495     }
1496 
1497     /**
1498      * Returns a copy of this {@code OffsetDateTime} with the specified number of seconds subtracted.
1499      * &lt;p&gt;
1500      * This instance is immutable and unaffected by this method call.
1501      *
1502      * @param seconds  the seconds to subtract, may be negative
1503      * @return an {@code OffsetDateTime} based on this date-time with the seconds subtracted, not null
1504      * @throws DateTimeException if the result exceeds the supported date range
1505      */
1506     public OffsetDateTime minusSeconds(long seconds) {
1507         return (seconds == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-seconds));
1508     }
1509 
1510     /**
1511      * Returns a copy of this {@code OffsetDateTime} with the specified number of nanoseconds subtracted.
1512      * &lt;p&gt;
1513      * This instance is immutable and unaffected by this method call.
1514      *
1515      * @param nanos  the nanos to subtract, may be negative
1516      * @return an {@code OffsetDateTime} based on this date-time with the nanoseconds subtracted, not null
1517      * @throws DateTimeException if the result exceeds the supported date range
1518      */
1519     public OffsetDateTime minusNanos(long nanos) {
1520         return (nanos == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanos));
1521     }
1522 
1523     //-----------------------------------------------------------------------
1524     /**
1525      * Queries this date-time using the specified query.
1526      * &lt;p&gt;
1527      * This queries this date-time using the specified query strategy object.
1528      * The {@code TemporalQuery} object defines the logic to be used to
1529      * obtain the result. Read the documentation of the query to understand
1530      * what the result of this method will be.
1531      * &lt;p&gt;
1532      * The result of this method is obtained by invoking the
1533      * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
1534      * specified query passing {@code this} as the argument.
1535      *
1536      * @param &lt;R&gt; the type of the result
1537      * @param query  the query to invoke, not null
1538      * @return the query result, null may be returned (defined by the query)
1539      * @throws DateTimeException if unable to query (defined by the query)
1540      * @throws ArithmeticException if numeric overflow occurs (defined by the query)
1541      */
1542     @SuppressWarnings(&quot;unchecked&quot;)
1543     @Override
1544     public &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) {
1545         if (query == TemporalQueries.offset() || query == TemporalQueries.zone()) {
1546             return (R) getOffset();
1547         } else if (query == TemporalQueries.zoneId()) {
1548             return null;
1549         } else if (query == TemporalQueries.localDate()) {
1550             return (R) toLocalDate();
1551         } else if (query == TemporalQueries.localTime()) {
1552             return (R) toLocalTime();
1553         } else if (query == TemporalQueries.chronology()) {
1554             return (R) IsoChronology.INSTANCE;
1555         } else if (query == TemporalQueries.precision()) {
1556             return (R) NANOS;
1557         }
1558         // inline TemporalAccessor.super.query(query) as an optimization
1559         // non-JDK classes are not permitted to make this optimization
1560         return query.queryFrom(this);
1561     }
1562 
1563     /**
1564      * Adjusts the specified temporal object to have the same offset, date
1565      * and time as this object.
1566      * &lt;p&gt;
1567      * This returns a temporal object of the same observable type as the input
1568      * with the offset, date and time changed to be the same as this.
1569      * &lt;p&gt;
1570      * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
1571      * three times, passing {@link ChronoField#EPOCH_DAY},
1572      * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.
1573      * &lt;p&gt;
1574      * In most cases, it is clearer to reverse the calling pattern by using
1575      * {@link Temporal#with(TemporalAdjuster)}:
1576      * &lt;pre&gt;
1577      *   // these two lines are equivalent, but the second approach is recommended
1578      *   temporal = thisOffsetDateTime.adjustInto(temporal);
1579      *   temporal = temporal.with(thisOffsetDateTime);
1580      * &lt;/pre&gt;
1581      * &lt;p&gt;
1582      * This instance is immutable and unaffected by this method call.
1583      *
1584      * @param temporal  the target object to be adjusted, not null
1585      * @return the adjusted object, not null
1586      * @throws DateTimeException if unable to make the adjustment
1587      * @throws ArithmeticException if numeric overflow occurs
1588      */
1589     @Override
1590     public Temporal adjustInto(Temporal temporal) {
1591         // OffsetDateTime is treated as three separate fields, not an instant
1592         // this produces the most consistent set of results overall
1593         // the offset is set after the date and time, as it is typically a small
1594         // tweak to the result, with ZonedDateTime frequently ignoring the offset
1595         return temporal
1596                 .with(EPOCH_DAY, toLocalDate().toEpochDay())
1597                 .with(NANO_OF_DAY, toLocalTime().toNanoOfDay())
1598                 .with(OFFSET_SECONDS, getOffset().getTotalSeconds());
1599     }
1600 
1601     /**
1602      * Calculates the amount of time until another date-time in terms of the specified unit.
1603      * &lt;p&gt;
1604      * This calculates the amount of time between two {@code OffsetDateTime}
1605      * objects in terms of a single {@code TemporalUnit}.
1606      * The start and end points are {@code this} and the specified date-time.
1607      * The result will be negative if the end is before the start.
1608      * For example, the amount in days between two date-times can be calculated
1609      * using {@code startDateTime.until(endDateTime, DAYS)}.
1610      * &lt;p&gt;
1611      * The {@code Temporal} passed to this method is converted to a
1612      * {@code OffsetDateTime} using {@link #from(TemporalAccessor)}.
1613      * If the offset differs between the two date-times, the specified
1614      * end date-time is normalized to have the same offset as this date-time.
1615      * &lt;p&gt;
1616      * The calculation returns a whole number, representing the number of
1617      * complete units between the two date-times.
1618      * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z
1619      * will only be one month as it is one minute short of two months.
1620      * &lt;p&gt;
1621      * There are two equivalent ways of using this method.
1622      * The first is to invoke this method.
1623      * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
1624      * &lt;pre&gt;
1625      *   // these two lines are equivalent
1626      *   amount = start.until(end, MONTHS);
1627      *   amount = MONTHS.between(start, end);
1628      * &lt;/pre&gt;
1629      * The choice should be made based on which makes the code more readable.
1630      * &lt;p&gt;
1631      * The calculation is implemented in this method for {@link ChronoUnit}.
1632      * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
1633      * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},
1634      * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},
1635      * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.
1636      * Other {@code ChronoUnit} values will throw an exception.
1637      * &lt;p&gt;
1638      * If the unit is not a {@code ChronoUnit}, then the result of this method
1639      * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
1640      * passing {@code this} as the first argument and the converted input temporal
1641      * as the second argument.
1642      * &lt;p&gt;
1643      * This instance is immutable and unaffected by this method call.
1644      *
1645      * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null
1646      * @param unit  the unit to measure the amount in, not null
1647      * @return the amount of time between this date-time and the end date-time
1648      * @throws DateTimeException if the amount cannot be calculated, or the end
1649      *  temporal cannot be converted to an {@code OffsetDateTime}
1650      * @throws UnsupportedTemporalTypeException if the unit is not supported
1651      * @throws ArithmeticException if numeric overflow occurs
1652      */
1653     @Override
1654     public long until(Temporal endExclusive, TemporalUnit unit) {
1655         OffsetDateTime end = OffsetDateTime.from(endExclusive);
1656         if (unit instanceof ChronoUnit) {
<a name="3" id="anc3"></a><span class="line-modified">1657             end = end.withOffsetSameInstant(offset);</span>
<span class="line-modified">1658             return dateTime.until(end.dateTime, unit);</span>






1659         }
1660         return unit.between(this, end);
1661     }
1662 
1663     /**
1664      * Formats this date-time using the specified formatter.
1665      * &lt;p&gt;
1666      * This date-time will be passed to the formatter to produce a string.
1667      *
1668      * @param formatter  the formatter to use, not null
1669      * @return the formatted date-time string, not null
1670      * @throws DateTimeException if an error occurs during printing
1671      */
1672     public String format(DateTimeFormatter formatter) {
1673         Objects.requireNonNull(formatter, &quot;formatter&quot;);
1674         return formatter.format(this);
1675     }
1676 
1677     //-----------------------------------------------------------------------
1678     /**
1679      * Combines this date-time with a time-zone to create a {@code ZonedDateTime}
1680      * ensuring that the result has the same instant.
1681      * &lt;p&gt;
1682      * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.
1683      * This conversion will ignore the visible local date-time and use the underlying instant instead.
1684      * This avoids any problems with local time-line gaps or overlaps.
1685      * The result might have different values for fields such as hour, minute an even day.
1686      * &lt;p&gt;
1687      * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.
1688      * To use the offset as the zone ID, use {@link #toZonedDateTime()}.
1689      *
1690      * @param zone  the time-zone to use, not null
1691      * @return the zoned date-time formed from this date-time, not null
1692      */
1693     public ZonedDateTime atZoneSameInstant(ZoneId zone) {
1694         return ZonedDateTime.ofInstant(dateTime, offset, zone);
1695     }
1696 
1697     /**
1698      * Combines this date-time with a time-zone to create a {@code ZonedDateTime}
1699      * trying to keep the same local date and time.
1700      * &lt;p&gt;
1701      * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.
1702      * Where possible, the result will have the same local date-time as this object.
1703      * &lt;p&gt;
1704      * Time-zone rules, such as daylight savings, mean that not every time on the
1705      * local time-line exists. If the local date-time is in a gap or overlap according to
1706      * the rules then a resolver is used to determine the resultant local time and offset.
1707      * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}
1708      * to retain the offset from this instance if possible.
1709      * &lt;p&gt;
1710      * Finer control over gaps and overlaps is available in two ways.
1711      * If you simply want to use the later offset at overlaps then call
1712      * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.
1713      * &lt;p&gt;
1714      * To create a zoned date-time at the same instant irrespective of the local time-line,
1715      * use {@link #atZoneSameInstant(ZoneId)}.
1716      * To use the offset as the zone ID, use {@link #toZonedDateTime()}.
1717      *
1718      * @param zone  the time-zone to use, not null
1719      * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null
1720      */
1721     public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {
1722         return ZonedDateTime.ofLocal(dateTime, zone, offset);
1723     }
1724 
1725     //-----------------------------------------------------------------------
1726     /**
1727      * Converts this date-time to an {@code OffsetTime}.
1728      * &lt;p&gt;
1729      * This returns an offset time with the same local time and offset.
1730      *
1731      * @return an OffsetTime representing the time and offset, not null
1732      */
1733     public OffsetTime toOffsetTime() {
1734         return OffsetTime.of(dateTime.toLocalTime(), offset);
1735     }
1736 
1737     /**
1738      * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.
1739      * &lt;p&gt;
1740      * This creates the simplest possible {@code ZonedDateTime} using the offset
1741      * as the zone ID.
1742      * &lt;p&gt;
1743      * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and
1744      * {@link #atZoneSimilarLocal(ZoneId)}.
1745      *
1746      * @return a zoned date-time representing the same local date-time and offset, not null
1747      */
1748     public ZonedDateTime toZonedDateTime() {
1749         return ZonedDateTime.of(dateTime, offset);
1750     }
1751 
1752     /**
1753      * Converts this date-time to an {@code Instant}.
1754      * &lt;p&gt;
1755      * This returns an {@code Instant} representing the same point on the
1756      * time-line as this date-time.
1757      *
1758      * @return an {@code Instant} representing the same instant, not null
1759      */
1760     public Instant toInstant() {
1761         return dateTime.toInstant(offset);
1762     }
1763 
1764     /**
1765      * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.
1766      * &lt;p&gt;
1767      * This allows this date-time to be converted to a value of the
1768      * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily
1769      * intended for low-level conversions rather than general application usage.
1770      *
1771      * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z
1772      */
1773     public long toEpochSecond() {
1774         return dateTime.toEpochSecond(offset);
1775     }
1776 
1777     //-----------------------------------------------------------------------
1778     /**
1779      * Compares this date-time to another date-time.
1780      * &lt;p&gt;
1781      * The comparison is based on the instant then on the local date-time.
1782      * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
1783      * &lt;p&gt;
1784      * For example, the following is the comparator order:
1785      * &lt;ol&gt;
1786      * &lt;li&gt;{@code 2008-12-03T10:30+01:00}&lt;/li&gt;
1787      * &lt;li&gt;{@code 2008-12-03T11:00+01:00}&lt;/li&gt;
1788      * &lt;li&gt;{@code 2008-12-03T12:00+02:00}&lt;/li&gt;
1789      * &lt;li&gt;{@code 2008-12-03T11:30+01:00}&lt;/li&gt;
1790      * &lt;li&gt;{@code 2008-12-03T12:00+01:00}&lt;/li&gt;
1791      * &lt;li&gt;{@code 2008-12-03T12:30+01:00}&lt;/li&gt;
1792      * &lt;/ol&gt;
1793      * Values #2 and #3 represent the same instant on the time-line.
1794      * When two values represent the same instant, the local date-time is compared
1795      * to distinguish them. This step is needed to make the ordering
1796      * consistent with {@code equals()}.
1797      *
1798      * @param other  the other date-time to compare to, not null
1799      * @return the comparator value, negative if less, positive if greater
1800      */
1801     @Override
1802     public int compareTo(OffsetDateTime other) {
1803         int cmp = compareInstant(this, other);
1804         if (cmp == 0) {
1805             cmp = toLocalDateTime().compareTo(other.toLocalDateTime());
1806         }
1807         return cmp;
1808     }
1809 
1810     //-----------------------------------------------------------------------
1811     /**
1812      * Checks if the instant of this date-time is after that of the specified date-time.
1813      * &lt;p&gt;
1814      * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it
1815      * only compares the instant of the date-time. This is equivalent to using
1816      * {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.
1817      *
1818      * @param other  the other date-time to compare to, not null
1819      * @return true if this is after the instant of the specified date-time
1820      */
1821     public boolean isAfter(OffsetDateTime other) {
1822         long thisEpochSec = toEpochSecond();
1823         long otherEpochSec = other.toEpochSecond();
1824         return thisEpochSec &gt; otherEpochSec ||
1825             (thisEpochSec == otherEpochSec &amp;&amp; toLocalTime().getNano() &gt; other.toLocalTime().getNano());
1826     }
1827 
1828     /**
1829      * Checks if the instant of this date-time is before that of the specified date-time.
1830      * &lt;p&gt;
1831      * This method differs from the comparison in {@link #compareTo} in that it
1832      * only compares the instant of the date-time. This is equivalent to using
1833      * {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.
1834      *
1835      * @param other  the other date-time to compare to, not null
1836      * @return true if this is before the instant of the specified date-time
1837      */
1838     public boolean isBefore(OffsetDateTime other) {
1839         long thisEpochSec = toEpochSecond();
1840         long otherEpochSec = other.toEpochSecond();
1841         return thisEpochSec &lt; otherEpochSec ||
1842             (thisEpochSec == otherEpochSec &amp;&amp; toLocalTime().getNano() &lt; other.toLocalTime().getNano());
1843     }
1844 
1845     /**
1846      * Checks if the instant of this date-time is equal to that of the specified date-time.
1847      * &lt;p&gt;
1848      * This method differs from the comparison in {@link #compareTo} and {@link #equals}
1849      * in that it only compares the instant of the date-time. This is equivalent to using
1850      * {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.
1851      *
1852      * @param other  the other date-time to compare to, not null
1853      * @return true if the instant equals the instant of the specified date-time
1854      */
1855     public boolean isEqual(OffsetDateTime other) {
1856         return toEpochSecond() == other.toEpochSecond() &amp;&amp;
1857                 toLocalTime().getNano() == other.toLocalTime().getNano();
1858     }
1859 
1860     //-----------------------------------------------------------------------
1861     /**
1862      * Checks if this date-time is equal to another date-time.
1863      * &lt;p&gt;
1864      * The comparison is based on the local date-time and the offset.
1865      * To compare for the same instant on the time-line, use {@link #isEqual}.
1866      * Only objects of type {@code OffsetDateTime} are compared, other types return false.
1867      *
1868      * @param obj  the object to check, null returns false
1869      * @return true if this is equal to the other date-time
1870      */
1871     @Override
1872     public boolean equals(Object obj) {
1873         if (this == obj) {
1874             return true;
1875         }
1876         if (obj instanceof OffsetDateTime) {
1877             OffsetDateTime other = (OffsetDateTime) obj;
1878             return dateTime.equals(other.dateTime) &amp;&amp; offset.equals(other.offset);
1879         }
1880         return false;
1881     }
1882 
1883     /**
1884      * A hash code for this date-time.
1885      *
1886      * @return a suitable hash code
1887      */
1888     @Override
1889     public int hashCode() {
1890         return dateTime.hashCode() ^ offset.hashCode();
1891     }
1892 
1893     //-----------------------------------------------------------------------
1894     /**
1895      * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30+01:00}.
1896      * &lt;p&gt;
1897      * The output will be one of the following ISO-8601 formats:
1898      * &lt;ul&gt;
1899      * &lt;li&gt;{@code uuuu-MM-dd&#39;T&#39;HH:mmXXXXX}&lt;/li&gt;
1900      * &lt;li&gt;{@code uuuu-MM-dd&#39;T&#39;HH:mm:ssXXXXX}&lt;/li&gt;
1901      * &lt;li&gt;{@code uuuu-MM-dd&#39;T&#39;HH:mm:ss.SSSXXXXX}&lt;/li&gt;
1902      * &lt;li&gt;{@code uuuu-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSXXXXX}&lt;/li&gt;
1903      * &lt;li&gt;{@code uuuu-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSSSSXXXXX}&lt;/li&gt;
1904      * &lt;/ul&gt;
1905      * The format used will be the shortest that outputs the full value of
1906      * the time where the omitted parts are implied to be zero.
1907      *
1908      * @return a string representation of this date-time, not null
1909      */
1910     @Override
1911     public String toString() {
1912         return dateTime.toString() + offset.toString();
1913     }
1914 
1915     //-----------------------------------------------------------------------
1916     /**
1917      * Writes the object using a
1918      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1919      * @serialData
1920      * &lt;pre&gt;
1921      *  out.writeByte(10);  // identifies an OffsetDateTime
1922      *  // the &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.LocalDateTime&quot;&gt;datetime&lt;/a&gt; excluding the one byte header
1923      *  // the &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.ZoneOffset&quot;&gt;offset&lt;/a&gt; excluding the one byte header
1924      * &lt;/pre&gt;
1925      *
1926      * @return the instance of {@code Ser}, not null
1927      */
<a name="4" id="anc4"></a>
1928     private Object writeReplace() {
1929         return new Ser(Ser.OFFSET_DATE_TIME_TYPE, this);
1930     }
1931 
1932     /**
1933      * Defend against malicious streams.
1934      *
1935      * @param s the stream to read
1936      * @throws InvalidObjectException always
1937      */
<a name="5" id="anc5"></a>
1938     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1939         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1940     }
1941 
1942     void writeExternal(ObjectOutput out) throws IOException {
1943         dateTime.writeExternal(out);
1944         offset.writeExternal(out);
1945     }
1946 
1947     static OffsetDateTime readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
1948         LocalDateTime dateTime = LocalDateTime.readExternal(in);
1949         ZoneOffset offset = ZoneOffset.readExternal(in);
1950         return OffsetDateTime.of(dateTime, offset);
1951     }
1952 
1953 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
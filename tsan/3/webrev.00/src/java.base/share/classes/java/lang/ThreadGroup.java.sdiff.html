<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/ThreadGroup.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadDeath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Throwable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ThreadGroup.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35  * has a parent.
  36  * &lt;p&gt;
  37  * A thread is allowed to access information about its own thread
  38  * group, but not to access information about its thread group&#39;s
  39  * parent thread group or any other thread groups.
  40  *
  41  * @author  unascribed
  42  * @since   1.0
  43  */
  44 /* The locking strategy for this code is to try to lock only one level of the
  45  * tree wherever possible, but otherwise to lock from the bottom up.
  46  * That is, from child thread groups to parents.
  47  * This has the advantage of limiting the number of locks that need to be held
  48  * and in particular avoids having to grab the lock for the root thread group,
  49  * (or a global lock) which would be a source of contention on a
  50  * multi-processor system with many thread groups.
  51  * This policy often leads to taking a snapshot of the state of a thread group
  52  * and working off of that snapshot, rather than holding the thread group locked
  53  * while we work on the children.
  54  */
<span class="line-modified">  55 public</span>
<span class="line-removed">  56 class ThreadGroup implements Thread.UncaughtExceptionHandler {</span>
  57     private final ThreadGroup parent;
  58     String name;
  59     int maxPriority;
  60     boolean destroyed;
  61     boolean daemon;
  62 
  63     int nUnstartedThreads = 0;
  64     int nthreads;
  65     Thread threads[];
  66 
  67     int ngroups;
  68     ThreadGroup groups[];
  69 
  70     /**
  71      * Creates an empty Thread group that is not in any Thread group.
  72      * This method is used to create the system Thread group.
  73      */
  74     private ThreadGroup() {     // called from C code
  75         this.name = &quot;system&quot;;
  76         this.maxPriority = Thread.MAX_PRIORITY;
</pre>
<hr />
<pre>
 649 
 650     /**
 651      * Suspends all threads in this thread group.
 652      * &lt;p&gt;
 653      * First, the {@code checkAccess} method of this thread group is
 654      * called with no arguments; this may result in a security exception.
 655      * &lt;p&gt;
 656      * This method then calls the {@code suspend} method on all the
 657      * threads in this thread group and in all of its subgroups.
 658      *
 659      * @throws     SecurityException  if the current thread is not allowed
 660      *               to access this thread group or any of the threads in
 661      *               the thread group.
 662      * @see        java.lang.Thread#suspend()
 663      * @see        java.lang.SecurityException
 664      * @see        java.lang.ThreadGroup#checkAccess()
 665      * @since      1.0
 666      * @deprecated    This method is inherently deadlock-prone.  See
 667      *     {@link Thread#suspend} for details.
 668      */
<span class="line-modified"> 669     @Deprecated(since=&quot;1.2&quot;)</span>
<span class="line-modified"> 670     @SuppressWarnings(&quot;deprecation&quot;)</span>
 671     public final void suspend() {
 672         if (stopOrSuspend(true))
 673             Thread.currentThread().suspend();
 674     }
 675 
 676     /**
 677      * Helper method: recursively stops or suspends (as directed by the
 678      * boolean argument) all of the threads in this thread group and its
 679      * subgroups, except the current thread.  This method returns true
 680      * if (and only if) the current thread is found to be in this thread
 681      * group or one of its subgroups.
 682      */
<span class="line-modified"> 683     @SuppressWarnings(&quot;deprecation&quot;)</span>
 684     private boolean stopOrSuspend(boolean suspend) {
 685         boolean suicide = false;
 686         Thread us = Thread.currentThread();
 687         int ngroupsSnapshot;
 688         ThreadGroup[] groupsSnapshot = null;
 689         synchronized (this) {
 690             checkAccess();
 691             for (int i = 0 ; i &lt; nthreads ; i++) {
 692                 if (threads[i]==us)
 693                     suicide = true;
 694                 else if (suspend)
 695                     threads[i].suspend();
 696                 else
 697                     threads[i].stop();
 698             }
 699 
 700             ngroupsSnapshot = ngroups;
 701             if (groups != null) {
 702                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 703             }
</pre>
<hr />
<pre>
 712      * Resumes all threads in this thread group.
 713      * &lt;p&gt;
 714      * First, the {@code checkAccess} method of this thread group is
 715      * called with no arguments; this may result in a security exception.
 716      * &lt;p&gt;
 717      * This method then calls the {@code resume} method on all the
 718      * threads in this thread group and in all of its sub groups.
 719      *
 720      * @throws     SecurityException  if the current thread is not allowed to
 721      *               access this thread group or any of the threads in the
 722      *               thread group.
 723      * @see        java.lang.SecurityException
 724      * @see        java.lang.Thread#resume()
 725      * @see        java.lang.ThreadGroup#checkAccess()
 726      * @since      1.0
 727      * @deprecated    This method is used solely in conjunction with
 728      *       {@code Thread.suspend} and {@code ThreadGroup.suspend},
 729      *       both of which have been deprecated, as they are inherently
 730      *       deadlock-prone.  See {@link Thread#suspend} for details.
 731      */
<span class="line-modified"> 732     @Deprecated(since=&quot;1.2&quot;)</span>
<span class="line-modified"> 733     @SuppressWarnings(&quot;deprecation&quot;)</span>
 734     public final void resume() {
 735         int ngroupsSnapshot;
 736         ThreadGroup[] groupsSnapshot;
 737         synchronized (this) {
 738             checkAccess();
 739             for (int i = 0 ; i &lt; nthreads ; i++) {
 740                 threads[i].resume();
 741             }
 742             ngroupsSnapshot = ngroups;
 743             if (groups != null) {
 744                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 745             } else {
 746                 groupsSnapshot = null;
 747             }
 748         }
 749         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 750             groupsSnapshot[i].resume();
 751         }
 752     }
 753 
</pre>
<hr />
<pre>
1053             if (ueh != null) {
1054                 ueh.uncaughtException(t, e);
1055             } else if (!(e instanceof ThreadDeath)) {
1056                 System.err.print(&quot;Exception in thread \&quot;&quot;
1057                                  + t.getName() + &quot;\&quot; &quot;);
1058                 e.printStackTrace(System.err);
1059             }
1060         }
1061     }
1062 
1063     /**
1064      * Used by VM to control lowmem implicit suspension.
1065      *
1066      * @param b boolean to allow or disallow suspension
1067      * @return true on success
1068      * @since   1.1
1069      * @deprecated The definition of this call depends on {@link #suspend},
1070      *             which is deprecated.  Further, the behavior of this call
1071      *             was never specified.
1072      */
<span class="line-modified">1073     @Deprecated(since=&quot;1.2&quot;)</span>
1074     public boolean allowThreadSuspension(boolean b) {
1075         return true;
1076     }
1077 
1078     /**
1079      * Returns a string representation of this Thread group.
1080      *
1081      * @return  a string representation of this thread group.
1082      * @since   1.0
1083      */
1084     public String toString() {
1085         return getClass().getName() + &quot;[name=&quot; + getName() + &quot;,maxpri=&quot; + maxPriority + &quot;]&quot;;
1086     }
1087 }
</pre>
</td>
<td>
<hr />
<pre>
  35  * has a parent.
  36  * &lt;p&gt;
  37  * A thread is allowed to access information about its own thread
  38  * group, but not to access information about its thread group&#39;s
  39  * parent thread group or any other thread groups.
  40  *
  41  * @author  unascribed
  42  * @since   1.0
  43  */
  44 /* The locking strategy for this code is to try to lock only one level of the
  45  * tree wherever possible, but otherwise to lock from the bottom up.
  46  * That is, from child thread groups to parents.
  47  * This has the advantage of limiting the number of locks that need to be held
  48  * and in particular avoids having to grab the lock for the root thread group,
  49  * (or a global lock) which would be a source of contention on a
  50  * multi-processor system with many thread groups.
  51  * This policy often leads to taking a snapshot of the state of a thread group
  52  * and working off of that snapshot, rather than holding the thread group locked
  53  * while we work on the children.
  54  */
<span class="line-modified">  55 public class ThreadGroup implements Thread.UncaughtExceptionHandler {</span>

  56     private final ThreadGroup parent;
  57     String name;
  58     int maxPriority;
  59     boolean destroyed;
  60     boolean daemon;
  61 
  62     int nUnstartedThreads = 0;
  63     int nthreads;
  64     Thread threads[];
  65 
  66     int ngroups;
  67     ThreadGroup groups[];
  68 
  69     /**
  70      * Creates an empty Thread group that is not in any Thread group.
  71      * This method is used to create the system Thread group.
  72      */
  73     private ThreadGroup() {     // called from C code
  74         this.name = &quot;system&quot;;
  75         this.maxPriority = Thread.MAX_PRIORITY;
</pre>
<hr />
<pre>
 648 
 649     /**
 650      * Suspends all threads in this thread group.
 651      * &lt;p&gt;
 652      * First, the {@code checkAccess} method of this thread group is
 653      * called with no arguments; this may result in a security exception.
 654      * &lt;p&gt;
 655      * This method then calls the {@code suspend} method on all the
 656      * threads in this thread group and in all of its subgroups.
 657      *
 658      * @throws     SecurityException  if the current thread is not allowed
 659      *               to access this thread group or any of the threads in
 660      *               the thread group.
 661      * @see        java.lang.Thread#suspend()
 662      * @see        java.lang.SecurityException
 663      * @see        java.lang.ThreadGroup#checkAccess()
 664      * @since      1.0
 665      * @deprecated    This method is inherently deadlock-prone.  See
 666      *     {@link Thread#suspend} for details.
 667      */
<span class="line-modified"> 668     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
<span class="line-modified"> 669     @SuppressWarnings(&quot;removal&quot;)</span>
 670     public final void suspend() {
 671         if (stopOrSuspend(true))
 672             Thread.currentThread().suspend();
 673     }
 674 
 675     /**
 676      * Helper method: recursively stops or suspends (as directed by the
 677      * boolean argument) all of the threads in this thread group and its
 678      * subgroups, except the current thread.  This method returns true
 679      * if (and only if) the current thread is found to be in this thread
 680      * group or one of its subgroups.
 681      */
<span class="line-modified"> 682     @SuppressWarnings({&quot;deprecation&quot;, &quot;removal&quot;})</span>
 683     private boolean stopOrSuspend(boolean suspend) {
 684         boolean suicide = false;
 685         Thread us = Thread.currentThread();
 686         int ngroupsSnapshot;
 687         ThreadGroup[] groupsSnapshot = null;
 688         synchronized (this) {
 689             checkAccess();
 690             for (int i = 0 ; i &lt; nthreads ; i++) {
 691                 if (threads[i]==us)
 692                     suicide = true;
 693                 else if (suspend)
 694                     threads[i].suspend();
 695                 else
 696                     threads[i].stop();
 697             }
 698 
 699             ngroupsSnapshot = ngroups;
 700             if (groups != null) {
 701                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 702             }
</pre>
<hr />
<pre>
 711      * Resumes all threads in this thread group.
 712      * &lt;p&gt;
 713      * First, the {@code checkAccess} method of this thread group is
 714      * called with no arguments; this may result in a security exception.
 715      * &lt;p&gt;
 716      * This method then calls the {@code resume} method on all the
 717      * threads in this thread group and in all of its sub groups.
 718      *
 719      * @throws     SecurityException  if the current thread is not allowed to
 720      *               access this thread group or any of the threads in the
 721      *               thread group.
 722      * @see        java.lang.SecurityException
 723      * @see        java.lang.Thread#resume()
 724      * @see        java.lang.ThreadGroup#checkAccess()
 725      * @since      1.0
 726      * @deprecated    This method is used solely in conjunction with
 727      *       {@code Thread.suspend} and {@code ThreadGroup.suspend},
 728      *       both of which have been deprecated, as they are inherently
 729      *       deadlock-prone.  See {@link Thread#suspend} for details.
 730      */
<span class="line-modified"> 731     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
<span class="line-modified"> 732     @SuppressWarnings(&quot;removal&quot;)</span>
 733     public final void resume() {
 734         int ngroupsSnapshot;
 735         ThreadGroup[] groupsSnapshot;
 736         synchronized (this) {
 737             checkAccess();
 738             for (int i = 0 ; i &lt; nthreads ; i++) {
 739                 threads[i].resume();
 740             }
 741             ngroupsSnapshot = ngroups;
 742             if (groups != null) {
 743                 groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);
 744             } else {
 745                 groupsSnapshot = null;
 746             }
 747         }
 748         for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {
 749             groupsSnapshot[i].resume();
 750         }
 751     }
 752 
</pre>
<hr />
<pre>
1052             if (ueh != null) {
1053                 ueh.uncaughtException(t, e);
1054             } else if (!(e instanceof ThreadDeath)) {
1055                 System.err.print(&quot;Exception in thread \&quot;&quot;
1056                                  + t.getName() + &quot;\&quot; &quot;);
1057                 e.printStackTrace(System.err);
1058             }
1059         }
1060     }
1061 
1062     /**
1063      * Used by VM to control lowmem implicit suspension.
1064      *
1065      * @param b boolean to allow or disallow suspension
1066      * @return true on success
1067      * @since   1.1
1068      * @deprecated The definition of this call depends on {@link #suspend},
1069      *             which is deprecated.  Further, the behavior of this call
1070      *             was never specified.
1071      */
<span class="line-modified">1072     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
1073     public boolean allowThreadSuspension(boolean b) {
1074         return true;
1075     }
1076 
1077     /**
1078      * Returns a string representation of this Thread group.
1079      *
1080      * @return  a string representation of this thread group.
1081      * @since   1.0
1082      */
1083     public String toString() {
1084         return getClass().getName() + &quot;[name=&quot; + getName() + &quot;,maxpri=&quot; + maxPriority + &quot;]&quot;;
1085     }
1086 }
</pre>
</td>
</tr>
</table>
<center><a href="ThreadDeath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Throwable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
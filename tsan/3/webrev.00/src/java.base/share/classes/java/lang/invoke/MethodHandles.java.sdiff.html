<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleStatics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  75  * A lookup, combinator, or factory method will fail and throw an
  76  * {@code IllegalArgumentException} if the created method handle&#39;s type
  77  * would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;.
  78  *
  79  * @author John Rose, JSR 292 EG
  80  * @since 1.7
  81  */
  82 public class MethodHandles {
  83 
  84     private MethodHandles() { }  // do not instantiate
  85 
  86     static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
  87 
  88     // See IMPL_LOOKUP below.
  89 
  90     //// Method handle creation from ordinary methods.
  91 
  92     /**
  93      * Returns a {@link Lookup lookup object} with
  94      * full capabilities to emulate all supported bytecode behaviors of the caller.
<span class="line-modified">  95      * These capabilities include &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt; to the caller.</span>
  96      * Factory methods on the lookup object can create
  97      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
  98      * for any member that the caller has access to via bytecodes,
  99      * including protected and private fields and methods.
 100      * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
 101      * Do not store it in place where untrusted code can access it.
 102      * &lt;p&gt;
 103      * This method is caller sensitive, which means that it may return different
 104      * values to different callers.
<span class="line-modified"> 105      * @return a lookup object for the caller of this method, with private access</span>

 106      */
 107     @CallerSensitive
 108     @ForceInline // to ensure Reflection.getCallerClass optimization
 109     public static Lookup lookup() {
 110         return new Lookup(Reflection.getCallerClass());
 111     }
 112 
 113     /**
 114      * This reflected$lookup method is the alternate implementation of
 115      * the lookup method when being invoked by reflection.
 116      */
 117     @CallerSensitive
 118     private static Lookup reflected$lookup() {
 119         Class&lt;?&gt; caller = Reflection.getCallerClass();
 120         if (caller.getClassLoader() == null) {
 121             throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+caller);
 122         }
 123         return new Lookup(caller);
 124     }
 125 
 126     /**
 127      * Returns a {@link Lookup lookup object} which is trusted minimally.
<span class="line-modified"> 128      * The lookup has the {@code PUBLIC} and {@code UNCONDITIONAL} modes.</span>
 129      * It can only be used to create method handles to public members of
 130      * public classes in packages that are exported unconditionally.
 131      * &lt;p&gt;
 132      * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
 133      * of this lookup object will be {@link java.lang.Object}.
 134      *
 135      * @apiNote The use of Object is conventional, and because the lookup modes are
 136      * limited, there is no special access provided to the internals of Object, its package
<span class="line-modified"> 137      * or its module. Consequently, the lookup context of this lookup object will be the</span>
<span class="line-modified"> 138      * bootstrap class loader, which means it cannot find user classes.</span>

 139      *
 140      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 141      * &lt;em&gt;Discussion:&lt;/em&gt;
 142      * The lookup class can be changed to any other class {@code C} using an expression of the form
 143      * {@link Lookup#in publicLookup().in(C.class)}.
<span class="line-removed"> 144      * but may change the lookup context by virtue of changing the class loader.</span>
 145      * A public lookup object is always subject to
 146      * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
 147      * Also, it cannot access
 148      * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
 149      * @return a lookup object which is trusted minimally
 150      *
 151      * @revised 9
 152      * @spec JPMS
 153      */
 154     public static Lookup publicLookup() {
 155         return Lookup.PUBLIC_LOOKUP;
 156     }
 157 
 158     /**
<span class="line-modified"> 159      * Returns a {@link Lookup lookup object} with full capabilities to emulate all</span>
<span class="line-modified"> 160      * supported bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;</span>
<span class="line-modified"> 161      * private access&lt;/a&gt;, on a target class.</span>
<span class="line-modified"> 162      * This method checks that a caller, specified as a {@code Lookup} object, is allowed to</span>
<span class="line-modified"> 163      * do &lt;em&gt;deep reflection&lt;/em&gt; on the target class. If {@code m1} is the module containing</span>
<span class="line-modified"> 164      * the {@link Lookup#lookupClass() lookup class}, and {@code m2} is the module containing</span>
<span class="line-modified"> 165      * the target class, then this check ensures that</span>


 166      * &lt;ul&gt;
<span class="line-modified"> 167      *     &lt;li&gt;{@code m1} {@link Module#canRead reads} {@code m2}.&lt;/li&gt;</span>
<span class="line-modified"> 168      *     &lt;li&gt;{@code m2} {@link Module#isOpen(String,Module) opens} the package containing</span>
<span class="line-modified"> 169      *     the target class to at least {@code m1}.&lt;/li&gt;</span>
<span class="line-modified"> 170      *     &lt;li&gt;The lookup has the {@link Lookup#MODULE MODULE} lookup mode.&lt;/li&gt;</span>




















 171      * &lt;/ul&gt;
 172      * &lt;p&gt;
<span class="line-modified"> 173      * If there is a security manager, its {@code checkPermission} method is called to</span>
<span class="line-modified"> 174      * check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)}.</span>
<span class="line-modified"> 175      * @apiNote The {@code MODULE} lookup mode serves to authenticate that the lookup object</span>
<span class="line-modified"> 176      * was created by code in the caller module (or derived from a lookup object originally</span>
<span class="line-modified"> 177      * created by the caller). A lookup object with the {@code MODULE} lookup mode can be</span>
<span class="line-modified"> 178      * shared with trusted parties without giving away {@code PRIVATE} and {@code PACKAGE}</span>
<span class="line-modified"> 179      * access to the caller.</span>






 180      * @param targetClass the target class
<span class="line-modified"> 181      * @param lookup the caller lookup object</span>
 182      * @return a lookup object for the target class, with private access
<span class="line-modified"> 183      * @throws IllegalArgumentException if {@code targetClass} is a primitve type or array class</span>
 184      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
<span class="line-removed"> 185      * @throws IllegalAccessException if the access check specified above fails</span>
 186      * @throws SecurityException if denied by the security manager

 187      * @since 9
 188      * @spec JPMS
 189      * @see Lookup#dropLookupMode

 190      */
<span class="line-modified"> 191     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup lookup) throws IllegalAccessException {</span>
 192         SecurityManager sm = System.getSecurityManager();
 193         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 194         if (targetClass.isPrimitive())
 195             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 196         if (targetClass.isArray())
 197             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
<span class="line-modified"> 198         Module targetModule = targetClass.getModule();</span>
<span class="line-modified"> 199         Module callerModule = lookup.lookupClass().getModule();</span>
<span class="line-modified"> 200         if (!callerModule.canRead(targetModule))</span>
<span class="line-modified"> 201             throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);</span>
<span class="line-modified"> 202         if (targetModule.isNamed()) {</span>
<span class="line-modified"> 203             String pn = targetClass.getPackageName();</span>
<span class="line-modified"> 204             assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;</span>
<span class="line-modified"> 205             if (!targetModule.isOpen(pn, callerModule))</span>
<span class="line-modified"> 206                 throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);</span>
<span class="line-modified"> 207         }</span>
<span class="line-modified"> 208         if ((lookup.lookupModes() &amp; Lookup.MODULE) == 0)</span>
<span class="line-modified"> 209             throw new IllegalAccessException(&quot;lookup does not have MODULE lookup mode&quot;);</span>
















 210         if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 211             IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 212             if (logger != null) {
<span class="line-modified"> 213                 logger.logIfOpenedForIllegalAccess(lookup, targetClass);</span>
 214             }
 215         }
<span class="line-modified"> 216         return new Lookup(targetClass);</span>
 217     }
 218 
 219     /**
 220      * Performs an unchecked &quot;crack&quot; of a
 221      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 222      * The result is as if the user had obtained a lookup object capable enough
 223      * to crack the target method handle, called
 224      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 225      * on the target to obtain its symbolic reference, and then called
 226      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 227      * to resolve the symbolic reference to a member.
 228      * &lt;p&gt;
 229      * If there is a security manager, its {@code checkPermission} method
 230      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 231      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 232      * @param target a direct method handle to crack into symbolic reference components
 233      * @param expected a class object representing the desired result type {@code T}
 234      * @return a reference to the method, constructor, or field object
<span class="line-modified"> 235      * @exception SecurityException if the caller is not privileged to call {@code setAccessible}</span>
<span class="line-modified"> 236      * @exception NullPointerException if either argument is {@code null}</span>
<span class="line-modified"> 237      * @exception IllegalArgumentException if the target is not a direct method handle</span>
<span class="line-modified"> 238      * @exception ClassCastException if the member is not of the expected type</span>
 239      * @since 1.8
 240      */
<span class="line-modified"> 241     public static &lt;T extends Member&gt; T</span>
<span class="line-removed"> 242     reflectAs(Class&lt;T&gt; expected, MethodHandle target) {</span>
 243         SecurityManager smgr = System.getSecurityManager();
 244         if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
 245         Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
 246         return lookup.revealDirect(target).reflectAs(expected, lookup);
 247     }
 248     // Copied from AccessibleObject, as used by Method.setAccessible, etc.:
 249     private static final java.security.Permission ACCESS_PERMISSION =
 250         new ReflectPermission(&quot;suppressAccessChecks&quot;);
 251 
 252     /**
 253      * A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
 254      * when the creation requires access checking.
 255      * Method handles do not perform
 256      * access checks when they are called, but rather when they are created.
 257      * Therefore, method handle access
 258      * restrictions must be enforced when a method handle is created.
 259      * The caller class against which those restrictions are enforced
 260      * is known as the {@linkplain #lookupClass() lookup class}.
 261      * &lt;p&gt;
 262      * A lookup class which needs to create method handles will call
 263      * {@link MethodHandles#lookup() MethodHandles.lookup} to create a factory for itself.
 264      * When the {@code Lookup} factory object is created, the identity of the lookup class is
 265      * determined, and securely stored in the {@code Lookup} object.
 266      * The lookup class (or its delegates) may then use factory methods
 267      * on the {@code Lookup} object to create method handles for access-checked members.
 268      * This includes all methods, constructors, and fields which are allowed to the lookup class,
 269      * even private ones.
 270      *
<span class="line-modified"> 271      * &lt;h1&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h1&gt;</span>
 272      * The factory methods on a {@code Lookup} object correspond to all major
 273      * use cases for methods, constructors, and fields.
 274      * Each method handle created by a factory method is the functional
 275      * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
<span class="line-modified"> 276      * (Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)</span>

 277      * Here is a summary of the correspondence between these factory methods and
 278      * the behavior of the resulting method handles:
 279      * &lt;table class=&quot;striped&quot;&gt;
 280      * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
 281      * &lt;thead&gt;
 282      * &lt;tr&gt;
 283      *     &lt;th scope=&quot;col&quot;&gt;&lt;a id=&quot;equiv&quot;&gt;&lt;/a&gt;lookup expression&lt;/th&gt;
 284      *     &lt;th scope=&quot;col&quot;&gt;member&lt;/th&gt;
 285      *     &lt;th scope=&quot;col&quot;&gt;bytecode behavior&lt;/th&gt;
 286      * &lt;/tr&gt;
 287      * &lt;/thead&gt;
 288      * &lt;tbody&gt;
 289      * &lt;tr&gt;
 290      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 291      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
 292      * &lt;/tr&gt;
 293      * &lt;tr&gt;
 294      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<span class="line-modified"> 295      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) C.f;}&lt;/td&gt;</span>
 296      * &lt;/tr&gt;
 297      * &lt;tr&gt;
 298      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 299      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
 300      * &lt;/tr&gt;
 301      * &lt;tr&gt;
 302      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 303      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code C.f = arg;}&lt;/td&gt;
 304      * &lt;/tr&gt;
 305      * &lt;tr&gt;
 306      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 307      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) this.m(arg*);}&lt;/td&gt;
 308      * &lt;/tr&gt;
 309      * &lt;tr&gt;
 310      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 311      *     &lt;td&gt;{@code static}&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) C.m(arg*);}&lt;/td&gt;
 312      * &lt;/tr&gt;
 313      * &lt;tr&gt;
 314      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/th&gt;
 315      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
</pre>
<hr />
<pre>
 318      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/th&gt;
 319      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code new C(arg*);}&lt;/td&gt;
 320      * &lt;/tr&gt;
 321      * &lt;tr&gt;
 322      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/th&gt;
 323      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) aField.get(thisOrNull);}&lt;/td&gt;
 324      * &lt;/tr&gt;
 325      * &lt;tr&gt;
 326      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/th&gt;
 327      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code aField.set(thisOrNull, arg);}&lt;/td&gt;
 328      * &lt;/tr&gt;
 329      * &lt;tr&gt;
 330      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
 331      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
 332      * &lt;/tr&gt;
 333      * &lt;tr&gt;
 334      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
 335      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
 336      * &lt;/tr&gt;
 337      * &lt;tr&gt;
<span class="line-modified"> 338      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;</span>
<span class="line-modified"> 339      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;</span>
 340      * &lt;/tr&gt;
 341      * &lt;tr&gt;
 342      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
 343      *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
 344      * &lt;/tr&gt;
 345      * &lt;/tbody&gt;
 346      * &lt;/table&gt;
 347      *
 348      * Here, the type {@code C} is the class or interface being searched for a member,
 349      * documented as a parameter named {@code refc} in the lookup methods.
 350      * The method type {@code MT} is composed from the return type {@code T}
 351      * and the sequence of argument types {@code A*}.
 352      * The constructor also has a sequence of argument types {@code A*} and
 353      * is deemed to return the newly-created object of type {@code C}.
 354      * Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
 355      * The formal parameter {@code this} stands for the self-reference of type {@code C};
 356      * if it is present, it is always the leading argument to the method handle invocation.
 357      * (In the case of some {@code protected} members, {@code this} may be
 358      * restricted in type to the lookup class; see below.)
 359      * The name {@code arg} stands for all the other method handle arguments.
 360      * In the code examples for the Core Reflection API, the name {@code thisOrNull}
 361      * stands for a null reference if the accessed method or field is static,
 362      * and {@code this} otherwise.
 363      * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
<span class="line-modified"> 364      * for reflective objects corresponding to the given members.</span>
 365      * &lt;p&gt;
 366      * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
 367      * as if by {@code ldc CONSTANT_Class}.
 368      * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
 369      * &lt;p&gt;
 370      * In cases where the given member is of variable arity (i.e., a method or constructor)
 371      * the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
 372      * In all other cases, the returned method handle will be of fixed arity.
 373      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 374      * &lt;em&gt;Discussion:&lt;/em&gt;
 375      * The equivalence between looked-up method handles and underlying
 376      * class members and bytecode behaviors
 377      * can break down in a few ways:
 378      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 379      * &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&#39;s loader,
 380      * the lookup can still succeed, even when there is no equivalent
 381      * Java expression or bytecoded constant.
 382      * &lt;li&gt;Likewise, if {@code T} or {@code MT}
 383      * is not symbolically accessible from the lookup class&#39;s loader,
 384      * the lookup can still succeed.
 385      * For example, lookups for {@code MethodHandle.invokeExact} and
 386      * {@code MethodHandle.invoke} will always succeed, regardless of requested type.
 387      * &lt;li&gt;If there is a security manager installed, it can forbid the lookup
 388      * on various grounds (&lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;see below&lt;/a&gt;).
 389      * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}
 390      * constant is not subject to security manager checks.
 391      * &lt;li&gt;If the looked-up method has a
 392      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;very large arity&lt;/a&gt;,
 393      * the method handle creation may fail with an
 394      * {@code IllegalArgumentException}, due to the method handle type having
 395      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters.&lt;/a&gt;
 396      * &lt;/ul&gt;
 397      *
<span class="line-modified"> 398      * &lt;h1&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h1&gt;</span>
 399      * Access checks are applied in the factory methods of {@code Lookup},
 400      * when a method handle is created.
 401      * This is a key difference from the Core Reflection API, since
 402      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 403      * performs access checking against every caller, on every call.
 404      * &lt;p&gt;
 405      * All access checks start from a {@code Lookup} object, which
 406      * compares its recorded lookup class against all requests to
 407      * create method handles.
 408      * A single {@code Lookup} object can be used to create any number
 409      * of access-checked method handles, all checked against a single
 410      * lookup class.
 411      * &lt;p&gt;
 412      * A {@code Lookup} object can be shared with other trusted code,
 413      * such as a metaobject protocol.
 414      * A shared {@code Lookup} object delegates the capability
 415      * to create method handles on private members of the lookup class.
 416      * Even if privileged code uses the {@code Lookup} object,
 417      * the access checking is confined to the privileges of the
 418      * original lookup class.
 419      * &lt;p&gt;
 420      * A lookup can fail, because
 421      * the containing class is not accessible to the lookup class, or
 422      * because the desired class member is missing, or because the
 423      * desired class member is not accessible to the lookup class, or
 424      * because the lookup object is not trusted enough to access the member.




 425      * In any of these cases, a {@code ReflectiveOperationException} will be
 426      * thrown from the attempted lookup.  The exact class will be one of
 427      * the following:
 428      * &lt;ul&gt;
 429      * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
 430      * &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
 431      * &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
 432      * &lt;/ul&gt;
 433      * &lt;p&gt;
 434      * In general, the conditions under which a method handle may be
 435      * looked up for a method {@code M} are no more restrictive than the conditions
 436      * under which the lookup class could have compiled, verified, and resolved a call to {@code M}.
 437      * Where the JVM would raise exceptions like {@code NoSuchMethodError},
 438      * a method handle lookup will generally raise a corresponding
 439      * checked exception, such as {@code NoSuchMethodException}.
 440      * And the effect of invoking the method handle resulting from the lookup
 441      * is &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;exactly equivalent&lt;/a&gt;
 442      * to executing the compiled, verified, and resolved call to {@code M}.
 443      * The same point is true of fields and constructors.
 444      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 445      * &lt;em&gt;Discussion:&lt;/em&gt;
 446      * Access checks only apply to named and reflected methods,
 447      * constructors, and fields.
 448      * Other method handle creation methods, such as
 449      * {@link MethodHandle#asType MethodHandle.asType},
 450      * do not require any access checks, and are used
 451      * independently of any {@code Lookup} object.
 452      * &lt;p&gt;
 453      * If the desired member is {@code protected}, the usual JVM rules apply,
 454      * including the requirement that the lookup class must either be in the
 455      * same package as the desired member, or must inherit that member.
<span class="line-modified"> 456      * (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.)</span>

 457      * In addition, if the desired member is a non-static field or method
 458      * in a different package, the resulting method handle may only be applied
 459      * to objects of the lookup class or one of its subclasses.
 460      * This requirement is enforced by narrowing the type of the leading
 461      * {@code this} parameter from {@code C}
 462      * (which will necessarily be a superclass of the lookup class)
 463      * to the lookup class itself.
 464      * &lt;p&gt;
 465      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 466      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 467      * the current class.  Again, this requirement is enforced by narrowing the
 468      * type of the leading parameter to the resulting method handle.
<span class="line-modified"> 469      * (See the Java Virtual Machine Specification, section 4.10.1.9.)</span>
 470      * &lt;p&gt;
 471      * The JVM represents constructors and static initializer blocks as internal methods
 472      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 473      * The internal syntax of invocation instructions allows them to refer to such internal
 474      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 475      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 476      * &lt;p&gt;
 477      * If the relationship between nested types is expressed directly through the
 478      * {@code NestHost} and {@code NestMembers} attributes
<span class="line-modified"> 479      * (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29),</span>

 480      * then the associated {@code Lookup} object provides direct access to
 481      * the lookup class and all of its nestmates
 482      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 483      * Otherwise, access between nested classes is obtained by the Java compiler creating
 484      * a wrapper method to access a private method of another class in the same nest.
 485      * For example, a nested class {@code C.D}
 486      * can access private members within other related classes such as
 487      * {@code C}, {@code C.D.E}, or {@code C.B},
 488      * but the Java compiler may need to generate wrapper methods in
 489      * those related classes.  In such cases, a {@code Lookup} object on
 490      * {@code C.E} would be unable to access those private members.
 491      * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
 492      * which can transform a lookup on {@code C.E} into one on any of those other
 493      * classes, without special elevation of privilege.
 494      * &lt;p&gt;
 495      * The accesses permitted to a given lookup object may be limited,
 496      * according to its set of {@link #lookupModes lookupModes},
 497      * to a subset of members normally accessible to the lookup class.
 498      * For example, the {@link MethodHandles#publicLookup publicLookup}
 499      * method produces a lookup object which is only allowed to access
 500      * public members in public classes of exported packages.
 501      * The caller sensitive method {@link MethodHandles#lookup lookup}
 502      * produces a lookup object with full capabilities relative to
 503      * its caller class, to emulate all supported bytecode behaviors.
 504      * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
 505      * with fewer access modes than the original lookup object.
 506      *
 507      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 508      * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
<span class="line-modified"> 509      * &lt;em&gt;Discussion of private access:&lt;/em&gt;</span>
 510      * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
 511      * if its {@linkplain #lookupModes lookup modes}
 512      * include the possibility of accessing {@code private} members
 513      * (which includes the private members of nestmates).
 514      * As documented in the relevant methods elsewhere,
 515      * only lookups with private access possess the following capabilities:
 516      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 517      * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates
<span class="line-removed"> 518      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,</span>
<span class="line-removed"> 519      *     such as {@code Class.forName}</span>
 520      * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
 521      * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
 522      *     for classes accessible to the lookup class
 523      * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
 524      *     within the same package member
 525      * &lt;/ul&gt;
 526      * &lt;p style=&quot;font-size:smaller;&quot;&gt;












 527      * Each of these permissions is a consequence of the fact that a lookup object
 528      * with private access can be securely traced back to an originating class,
 529      * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
 530      * can be reliably determined and emulated by method handles.
 531      *
<span class="line-modified"> 532      * &lt;h1&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h1&gt;</span>




























































































































































































































































































































































































































































































































 533      * Although bytecode instructions can only refer to classes in
 534      * a related class loader, this API can search for methods in any
 535      * class, as long as a reference to its {@code Class} object is
 536      * available.  Such cross-loader references are also possible with the
 537      * Core Reflection API, and are impossible to bytecode instructions
 538      * such as {@code invokestatic} or {@code getfield}.
 539      * There is a {@linkplain java.lang.SecurityManager security manager API}
 540      * to allow applications to check such cross-loader references.
 541      * These checks apply to both the {@code MethodHandles.Lookup} API
 542      * and the Core Reflection API
 543      * (as found on {@link java.lang.Class Class}).
 544      * &lt;p&gt;
 545      * If a security manager is present, member and class lookups are subject to
 546      * additional checks.
 547      * From one to three calls are made to the security manager.
 548      * Any of these calls can refuse access by throwing a
 549      * {@link java.lang.SecurityException SecurityException}.
 550      * Define {@code smgr} as the security manager,
 551      * {@code lookc} as the lookup class of the current lookup object,
 552      * {@code refc} as the containing class in which the member
 553      * is being sought, and {@code defc} as the class in which the
 554      * member is actually defined.
 555      * (If a class or other type is being accessed,
 556      * the {@code refc} and {@code defc} values are the class itself.)
 557      * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;
 558      * if the current lookup object does not have
<span class="line-modified"> 559      * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
 560      * The calls are made according to the following rules:
 561      * &lt;ul&gt;
 562      * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
 563      *     If {@code lookc} is not present, or if its class loader is not
 564      *     the same as or an ancestor of the class loader of {@code refc},
 565      *     then {@link SecurityManager#checkPackageAccess
 566      *     smgr.checkPackageAccess(refcPkg)} is called,
 567      *     where {@code refcPkg} is the package of {@code refc}.
 568      * &lt;li&gt;&lt;b&gt;Step 2a:&lt;/b&gt;
 569      *     If the retrieved member is not public and
 570      *     {@code lookc} is not present, then
 571      *     {@link SecurityManager#checkPermission smgr.checkPermission}
 572      *     with {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)} is called.
 573      * &lt;li&gt;&lt;b&gt;Step 2b:&lt;/b&gt;
 574      *     If the retrieved class has a {@code null} class loader,
 575      *     and {@code lookc} is not present, then
 576      *     {@link SecurityManager#checkPermission smgr.checkPermission}
 577      *     with {@code RuntimePermission(&quot;getClassLoader&quot;)} is called.
 578      * &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
 579      *     If the retrieved member is not public,
 580      *     and if {@code lookc} is not present,
 581      *     and if {@code defc} and {@code refc} are different,
 582      *     then {@link SecurityManager#checkPackageAccess
 583      *     smgr.checkPackageAccess(defcPkg)} is called,
 584      *     where {@code defcPkg} is the package of {@code defc}.
 585      * &lt;/ul&gt;
 586      * Security checks are performed after other access checks have passed.
 587      * Therefore, the above rules presuppose a member or class that is public,
 588      * or else that is being accessed from a lookup class that has
 589      * rights to access the member or class.






 590      *
<span class="line-modified"> 591      * &lt;h1&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h1&gt;</span>
 592      * A small number of Java methods have a special property called caller sensitivity.
 593      * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
 594      * identity of its immediate caller.
 595      * &lt;p&gt;
 596      * If a method handle for a caller-sensitive method is requested,
 597      * the general rules for &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply,
 598      * but they take account of the lookup class in a special way.
 599      * The resulting method handle behaves as if it were called
 600      * from an instruction contained in the lookup class,
 601      * so that the caller-sensitive method detects the lookup class.
 602      * (By contrast, the invoker of the method handle is disregarded.)
 603      * Thus, in the case of caller-sensitive methods,
 604      * different lookup classes may give rise to
 605      * differently behaving method handles.
 606      * &lt;p&gt;
 607      * In cases where the lookup object is
 608      * {@link MethodHandles#publicLookup() publicLookup()},
<span class="line-modified"> 609      * or some other lookup object without</span>
<span class="line-modified"> 610      * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;,</span>
 611      * the lookup class is disregarded.
 612      * In such cases, no caller-sensitive method handle can be created,
 613      * access is forbidden, and the lookup fails with an
 614      * {@code IllegalAccessException}.
 615      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 616      * &lt;em&gt;Discussion:&lt;/em&gt;
 617      * For example, the caller-sensitive method
 618      * {@link java.lang.Class#forName(String) Class.forName(x)}
 619      * can return varying classes or throw varying exceptions,
 620      * depending on the class loader of the class that calls it.
 621      * A public lookup of {@code Class.forName} will fail, because
 622      * there is no reasonable way to determine its bytecode behavior.
 623      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 624      * If an application caches method handles for broad sharing,
 625      * it should use {@code publicLookup()} to create them.
 626      * If there is a lookup of {@code Class.forName}, it will fail,
 627      * and the application must take appropriate action in that case.
 628      * It may be that a later lookup, perhaps during the invocation of a
 629      * bootstrap method, can incorporate the specific identity
 630      * of the caller, making the method accessible.
 631      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 632      * The function {@code MethodHandles.lookup} is caller sensitive
 633      * so that there can be a secure foundation for lookups.
 634      * Nearly all other methods in the JSR 292 API rely on lookup
 635      * objects to check access requests.
 636      *
 637      * @revised 9
 638      */
 639     public static final
 640     class Lookup {
 641         /** The class on behalf of whom the lookup is being performed. */
 642         private final Class&lt;?&gt; lookupClass;
 643 



 644         /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */
 645         private final int allowedModes;
 646 
 647         static {
 648             Reflection.registerFieldsToFilter(Lookup.class, Set.of(&quot;lookupClass&quot;, &quot;allowedModes&quot;));
 649         }
 650 
 651         /** A single-bit mask representing {@code public} access,
 652          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 653          *  The value, {@code 0x01}, happens to be the same as the value of the
 654          *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.




 655          */
 656         public static final int PUBLIC = Modifier.PUBLIC;
 657 
 658         /** A single-bit mask representing {@code private} access,
 659          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 660          *  The value, {@code 0x02}, happens to be the same as the value of the
 661          *  {@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.
 662          */
 663         public static final int PRIVATE = Modifier.PRIVATE;
 664 
 665         /** A single-bit mask representing {@code protected} access,
 666          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 667          *  The value, {@code 0x04}, happens to be the same as the value of the
 668          *  {@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.
 669          */
 670         public static final int PROTECTED = Modifier.PROTECTED;
 671 
 672         /** A single-bit mask representing {@code package} access (default access),
 673          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 674          *  The value is {@code 0x08}, which does not correspond meaningfully to
 675          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
 676          */
 677         public static final int PACKAGE = Modifier.STATIC;
 678 
<span class="line-modified"> 679         /** A single-bit mask representing {@code module} access (default access),</span>
 680          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 681          *  The value is {@code 0x10}, which does not correspond meaningfully to
 682          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
 683          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
 684          *  with this lookup mode can access all public types in the module of the
 685          *  lookup class and public types in packages exported by other modules
 686          *  to the module of the lookup class.




 687          *  @since 9
 688          *  @spec JPMS
 689          */
 690         public static final int MODULE = PACKAGE &lt;&lt; 1;
 691 
 692         /** A single-bit mask representing {@code unconditional} access
 693          *  which may contribute to the result of {@link #lookupModes lookupModes}.
 694          *  The value is {@code 0x20}, which does not correspond meaningfully to
 695          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
 696          *  A {@code Lookup} with this lookup mode assumes {@linkplain
 697          *  java.lang.Module#canRead(java.lang.Module) readability}.
<span class="line-modified"> 698          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}</span>
<span class="line-modified"> 699          *  with this lookup mode can access all public members of public types</span>
<span class="line-removed"> 700          *  of all modules where the type is in a package that is {@link</span>
 701          *  java.lang.Module#isExported(String) exported unconditionally}.





 702          *  @since 9
 703          *  @spec JPMS
 704          *  @see #publicLookup()
 705          */
 706         public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
 707 
 708         private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
 709         private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
 710         private static final int TRUSTED   = -1;
 711 




 712         private static int fixmods(int mods) {
 713             mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
<span class="line-modified"> 714             return (mods != 0) ? mods : (PACKAGE | MODULE | UNCONDITIONAL);</span>


 715         }
 716 
 717         /** Tells which class is performing the lookup.  It is this class against
 718          *  which checks are performed for visibility and access permissions.
 719          *  &lt;p&gt;



 720          *  The class implies a maximum level of access permission,
 721          *  but the permissions may be additionally limited by the bitmask
 722          *  {@link #lookupModes lookupModes}, which controls whether non-public members
 723          *  can be accessed.
 724          *  @return the lookup class, on behalf of which this lookup object finds members

 725          */
 726         public Class&lt;?&gt; lookupClass() {
 727             return lookupClass;
 728         }
 729 





















 730         // This is just for calling out to MethodHandleImpl.
 731         private Class&lt;?&gt; lookupClassOrNull() {
<span class="line-modified"> 732             return (allowedModes == TRUSTED) ? null : lookupClass;</span>







 733         }
 734 
 735         /** Tells which access-protection classes of members this lookup object can produce.
 736          *  The result is a bit-mask of the bits
 737          *  {@linkplain #PUBLIC PUBLIC (0x01)},
 738          *  {@linkplain #PRIVATE PRIVATE (0x02)},
 739          *  {@linkplain #PROTECTED PROTECTED (0x04)},
 740          *  {@linkplain #PACKAGE PACKAGE (0x08)},
 741          *  {@linkplain #MODULE MODULE (0x10)},
 742          *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.
 743          *  &lt;p&gt;
 744          *  A freshly-created lookup object
 745          *  on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&#39;s class} has
 746          *  all possible bits set, except {@code UNCONDITIONAL}.
 747          *  A lookup object on a new lookup class
 748          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}
 749          *  may have some mode bits set to zero.
 750          *  Mode bits can also be
 751          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#dropLookupMode directly cleared}.
 752          *  Once cleared, mode bits cannot be restored from the downgraded lookup object.
 753          *  The purpose of this is to restrict access via the new lookup object,
 754          *  so that it can access only names which can be reached by the original
 755          *  lookup object, and also by the new lookup class.
 756          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
 757          *  @see #in
 758          *  @see #dropLookupMode
 759          *
 760          *  @revised 9
 761          *  @spec JPMS
 762          */
 763         public int lookupModes() {
 764             return allowedModes &amp; ALL_MODES;
 765         }
 766 
 767         /** Embody the current class (the lookupClass) as a lookup class
 768          * for method handle creation.
 769          * Must be called by from a method in this package,
 770          * which in turn is called by a method not in this package.
 771          */
 772         Lookup(Class&lt;?&gt; lookupClass) {
<span class="line-modified"> 773             this(lookupClass, FULL_POWER_MODES);</span>
 774             // make sure we haven&#39;t accidentally picked up a privileged class:
 775             checkUnprivilegedlookupClass(lookupClass);
 776         }
 777 
<span class="line-modified"> 778         private Lookup(Class&lt;?&gt; lookupClass, int allowedModes) {</span>



 779             this.lookupClass = lookupClass;

 780             this.allowedModes = allowedModes;
 781         }
 782 






 783         /**
 784          * Creates a lookup on the specified new lookup class.
 785          * The resulting object will report the specified
 786          * class as its own {@link #lookupClass() lookupClass}.

 787          * &lt;p&gt;
 788          * However, the resulting {@code Lookup} object is guaranteed
 789          * to have no more access capabilities than the original.
 790          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified"> 791          * &lt;li&gt;If the old lookup class is in a {@link Module#isNamed() named} module, and</span>
<span class="line-modified"> 792          * the new lookup class is in a different module {@code M}, then no members, not</span>
<span class="line-removed"> 793          * even public members in {@code M}&#39;s exported packages, will be accessible.</span>
<span class="line-removed"> 794          * The exception to this is when this lookup is {@link #publicLookup()</span>
<span class="line-removed"> 795          * publicLookup}, in which case {@code PUBLIC} access is not lost.</span>
<span class="line-removed"> 796          * &lt;li&gt;If the old lookup class is in an unnamed module, and the new lookup class</span>
<span class="line-removed"> 797          * is a different module then {@link #MODULE MODULE} access is lost.</span>
<span class="line-removed"> 798          * &lt;li&gt;If the new lookup class differs from the old one then {@code UNCONDITIONAL} is lost.</span>
 799          * &lt;li&gt;If the new lookup class is in a different package
<span class="line-modified"> 800          * than the old one, protected and default (package) members will not be accessible.</span>

 801          * &lt;li&gt;If the new lookup class is not within the same package member
 802          * as the old one, private members will not be accessible, and protected members
<span class="line-modified"> 803          * will not be accessible by virtue of inheritance.</span>

 804          * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified"> 805          * &lt;li&gt;If the new lookup class is not accessible to the old lookup class,</span>
<span class="line-modified"> 806          * then no members, not even public members, will be accessible.</span>
<span class="line-modified"> 807          * (In all other cases, public members will continue to be accessible.)</span>




 808          * &lt;/ul&gt;
 809          * &lt;p&gt;










 810          * The resulting lookup&#39;s capabilities for loading classes
 811          * (used during {@link #findClass} invocations)
 812          * are determined by the lookup class&#39; loader,
 813          * which may change due to this operation.
<span class="line-modified"> 814          *</span>
 815          * @param requestedLookupClass the desired lookup class for the new lookup object
 816          * @return a lookup object which reports the desired lookup class, or the same object
 817          * if there is no change

 818          * @throws NullPointerException if the argument is null
 819          *
 820          * @revised 9
 821          * @spec JPMS


 822          */
 823         public Lookup in(Class&lt;?&gt; requestedLookupClass) {
 824             Objects.requireNonNull(requestedLookupClass);





 825             if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
<span class="line-modified"> 826                 return new Lookup(requestedLookupClass, FULL_POWER_MODES);</span>
 827             if (requestedLookupClass == this.lookupClass)
 828                 return this;  // keep same capabilities
 829             int newModes = (allowedModes &amp; FULL_POWER_MODES);
<span class="line-modified"> 830             if (!VerifyAccess.isSameModule(this.lookupClass, requestedLookupClass)) {</span>
<span class="line-modified"> 831                 // Need to drop all access when teleporting from a named module to another</span>
<span class="line-modified"> 832                 // module. The exception is publicLookup where PUBLIC is not lost.</span>
<span class="line-modified"> 833                 if (this.lookupClass.getModule().isNamed()</span>
<span class="line-modified"> 834                     &amp;&amp; (this.allowedModes &amp; UNCONDITIONAL) == 0)</span>





 835                     newModes = 0;
<span class="line-modified"> 836                 else</span>
<span class="line-modified"> 837                     newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);</span>



 838             }
 839             if ((newModes &amp; PACKAGE) != 0
 840                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
 841                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
 842             }
 843             // Allow nestmate lookups to be created without special privilege:
 844             if ((newModes &amp; PRIVATE) != 0
 845                 &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
 846                 newModes &amp;= ~(PRIVATE|PROTECTED);
 847             }
<span class="line-modified"> 848             if ((newModes &amp; PUBLIC) != 0</span>
<span class="line-modified"> 849                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, allowedModes)) {</span>
 850                 // The requested class it not accessible from the lookup class.
 851                 // No permissions.
 852                 newModes = 0;
 853             }
<span class="line-modified"> 854 </span>
<span class="line-removed"> 855             checkUnprivilegedlookupClass(requestedLookupClass);</span>
<span class="line-removed"> 856             return new Lookup(requestedLookupClass, newModes);</span>
 857         }
 858 
<span class="line-removed"> 859 </span>
 860         /**
 861          * Creates a lookup on the same lookup class which this lookup object
 862          * finds members, but with a lookup mode that has lost the given lookup mode.
 863          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
 864          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED} or {@link #PRIVATE PRIVATE}.
<span class="line-modified"> 865          * {@link #PROTECTED PROTECTED} and {@link #UNCONDITIONAL UNCONDITIONAL} are always</span>
<span class="line-modified"> 866          * dropped and so the resulting lookup mode will never have these access capabilities.</span>
 867          * When dropping {@code PACKAGE} then the resulting lookup will not have {@code PACKAGE}
 868          * or {@code PRIVATE} access. When dropping {@code MODULE} then the resulting lookup will
 869          * not have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access. If {@code PUBLIC}

 870          * is dropped then the resulting lookup has no access.













 871          * @param modeToDrop the lookup mode to drop
 872          * @return a lookup object which lacks the indicated mode, or the same object if there is no change
 873          * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
 874          * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
 875          * @see MethodHandles#privateLookupIn
 876          * @since 9
 877          */
 878         public Lookup dropLookupMode(int modeToDrop) {
 879             int oldModes = lookupModes();
<span class="line-modified"> 880             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED | UNCONDITIONAL);</span>
 881             switch (modeToDrop) {
<span class="line-modified"> 882                 case PUBLIC: newModes &amp;= ~(ALL_MODES); break;</span>
 883                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
 884                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
 885                 case PROTECTED:
 886                 case PRIVATE:
 887                 case UNCONDITIONAL: break;
 888                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
 889             }
 890             if (newModes == oldModes) return this;  // return self if no change
<span class="line-modified"> 891             return new Lookup(lookupClass(), newModes);</span>
 892         }
 893 
 894         /**
 895          * Defines a class to the same class loader and in the same runtime package and
 896          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
 897          * {@linkplain #lookupClass() lookup class}.
 898          *
 899          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
 900          * {@link #PACKAGE PACKAGE} access as default (package) members will be
 901          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
 902          * that the lookup object was created by a caller in the runtime package (or derived
 903          * from a lookup originally created by suitably privileged code to a target class in
 904          * the runtime package). &lt;/p&gt;
 905          *
 906          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
 907          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
 908          * same package as the lookup class. &lt;/p&gt;
 909          *
 910          * &lt;p&gt; This method does not run the class initializer. The class initializer may
 911          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
 912          * Specification&lt;/em&gt;. &lt;/p&gt;
 913          *
<span class="line-modified"> 914          * &lt;p&gt; If there is a security manager, its {@code checkPermission} method is first called</span>
<span class="line-modified"> 915          * to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;</span>

 916          *
 917          * @param bytes the class bytes
 918          * @return the {@code Class} object for the class
 919          * @throws IllegalArgumentException the bytes are for a class in a different package
 920          * to the lookup class
 921          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
 922          * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
 923          * verified ({@code VerifyError}), is already defined, or another linkage error occurs
<span class="line-modified"> 924          * @throws SecurityException if denied by the security manager</span>

 925          * @throws NullPointerException if {@code bytes} is {@code null}
 926          * @since 9
 927          * @spec JPMS
 928          * @see Lookup#privateLookupIn
 929          * @see Lookup#dropLookupMode
 930          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
 931          */
 932         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
<span class="line-modified"> 933             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-modified"> 934             if (sm != null)</span>
<span class="line-modified"> 935                 sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));</span>


 936             if ((lookupModes() &amp; PACKAGE) == 0)
 937                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
<span class="line-removed"> 938             assert (lookupModes() &amp; (MODULE|PUBLIC)) != 0;</span>
 939 
 940             // parse class bytes to get class name (in internal form)
 941             bytes = bytes.clone();
 942             String name;
 943             try {
 944                 ClassReader reader = new ClassReader(bytes);
 945                 name = reader.getClassName();
 946             } catch (RuntimeException e) {
 947                 // ASM exceptions are poorly specified
 948                 ClassFormatError cfe = new ClassFormatError();
 949                 cfe.initCause(e);
 950                 throw cfe;
 951             }
 952 
 953             // get package and class name in binary form
 954             String cn, pn;
 955             int index = name.lastIndexOf(&#39;/&#39;);
 956             if (index == -1) {
 957                 cn = name;
 958                 pn = &quot;&quot;;
</pre>
<hr />
<pre>
 976             ProtectionDomain pd = cachedProtectionDomain;
 977             if (pd == null) {
 978                 cachedProtectionDomain = pd = protectionDomain(lookupClass);
 979             }
 980             return pd;
 981         }
 982 
 983         private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {
 984             PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;
 985             return AccessController.doPrivileged(pa);
 986         }
 987 
 988         // cached protection domain
 989         private volatile ProtectionDomain cachedProtectionDomain;
 990 
 991 
 992         // Make sure outer class is initialized first.
 993         static { IMPL_NAMES.getClass(); }
 994 
 995         /** Package-private version of lookup which is trusted. */
<span class="line-modified"> 996         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, TRUSTED);</span>
 997 
 998         /** Version of lookup which is trusted minimally.
 999          *  It can only be used to create method handles to publicly accessible
1000          *  members in packages that are exported unconditionally.
1001          */
<span class="line-modified">1002         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, (PUBLIC|UNCONDITIONAL));</span>
1003 
1004         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
1005             String name = lookupClass.getName();
1006             if (name.startsWith(&quot;java.lang.invoke.&quot;))
1007                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
1008         }
1009 
1010         /**
1011          * Displays the name of the class from which lookups are to be made.


1012          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
1013          * If there are restrictions on the access permitted to this lookup,
1014          * this is indicated by adding a suffix to the class name, consisting
1015          * of a slash and a keyword.  The keyword represents the strongest
1016          * allowed access, and is chosen as follows:
1017          * &lt;ul&gt;
1018          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.

1019          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
<span class="line-removed">1020          * &lt;li&gt;If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.</span>
1021          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
<span class="line-modified">1022          * &lt;li&gt;If only public, module and package access are allowed, the suffix is &quot;/package&quot;.</span>
<span class="line-modified">1023          * &lt;li&gt;If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.</span>
1024          * &lt;/ul&gt;
<span class="line-modified">1025          * If none of the above cases apply, it is the case that full</span>
<span class="line-modified">1026          * access (public, module, package, private, and protected) is allowed.</span>
1027          * In this case, no suffix is added.
1028          * This is true only of an object obtained originally from
1029          * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
1030          * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
1031          * always have restricted access, and will display a suffix.
1032          * &lt;p&gt;
1033          * (It may seem strange that protected access should be
1034          * stronger than private access.  Viewed independently from
1035          * package access, protected access is the first to be lost,
1036          * because it requires a direct subclass relationship between
1037          * caller and callee.)
1038          * @see #in
1039          *
1040          * @revised 9
1041          * @spec JPMS
1042          */
1043         @Override
1044         public String toString() {
1045             String cname = lookupClass.getName();


1046             switch (allowedModes) {
1047             case 0:  // no privileges
1048                 return cname + &quot;/noaccess&quot;;


1049             case PUBLIC:
1050                 return cname + &quot;/public&quot;;
<span class="line-removed">1051             case PUBLIC|UNCONDITIONAL:</span>
<span class="line-removed">1052                 return cname  + &quot;/publicLookup&quot;;</span>
1053             case PUBLIC|MODULE:
1054                 return cname + &quot;/module&quot;;

1055             case PUBLIC|MODULE|PACKAGE:
1056                 return cname + &quot;/package&quot;;
<span class="line-modified">1057             case FULL_POWER_MODES &amp; ~PROTECTED:</span>
<span class="line-modified">1058                 return cname + &quot;/private&quot;;</span>

1059             case FULL_POWER_MODES:

1060                 return cname;
1061             case TRUSTED:
1062                 return &quot;/trusted&quot;;  // internal only; not exported
1063             default:  // Should not happen, but it&#39;s a bitfield...
1064                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
1065                 assert(false) : cname;
1066                 return cname;
1067             }
1068         }
1069 
1070         /**
1071          * Produces a method handle for a static method.
1072          * The type of the method handle will be that of the method.
1073          * (Since static methods do not take receivers, there is no
1074          * additional receiver argument inserted into the method handle type,
1075          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
1076          * The method and all its argument types must be accessible to the lookup object.
1077          * &lt;p&gt;
1078          * The returned method handle will have
1079          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
</pre>
<hr />
<pre>
1082          * If the returned method handle is invoked, the method&#39;s class will
1083          * be initialized, if it has not already been initialized.
1084          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
1085          * &lt;blockquote&gt;&lt;pre&gt;{@code
1086 import static java.lang.invoke.MethodHandles.*;
1087 import static java.lang.invoke.MethodType.*;
1088 ...
1089 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
1090   &quot;asList&quot;, methodType(List.class, Object[].class));
1091 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
1092          * }&lt;/pre&gt;&lt;/blockquote&gt;
1093          * @param refc the class from which the method is accessed
1094          * @param name the name of the method
1095          * @param type the type of the method
1096          * @return the desired method handle
1097          * @throws NoSuchMethodException if the method does not exist
1098          * @throws IllegalAccessException if access checking fails,
1099          *                                or if the method is not {@code static},
1100          *                                or if the method&#39;s variable arity modifier bit
1101          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1102          * @exception SecurityException if a security manager is present and it</span>
1103          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1104          * @throws NullPointerException if any argument is null
1105          */
<span class="line-modified">1106         public</span>
<span class="line-removed">1107         MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {</span>
1108             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-modified">1109             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerClass(method));</span>
1110         }
1111 
1112         /**
1113          * Produces a method handle for a virtual method.
1114          * The type of the method handle will be that of the method,
1115          * with the receiver type (usually {@code refc}) prepended.
1116          * The method and all its argument types must be accessible to the lookup object.
1117          * &lt;p&gt;
1118          * When called, the handle will treat the first argument as a receiver
1119          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
1120          * implementation to enter.
1121          * For private methods the named method in {@code refc} will be invoked on the receiver.
1122          * (The dispatching action is identical with that performed by an
1123          * {@code invokevirtual} or {@code invokeinterface} instruction.)
1124          * &lt;p&gt;
1125          * The first argument will be of type {@code refc} if the lookup
1126          * class has full privileges to access the member.  Otherwise
1127          * the member must be {@code protected} and the first argument
1128          * will be restricted in type to the lookup class.
1129          * &lt;p&gt;
</pre>
<hr />
<pre>
1167 assertEquals(&quot;def&quot;, MH_subSequence.invoke(&quot;abcdefghi&quot;, 3, 6).toString());
1168 // constructor &quot;internal method&quot; must be accessed differently:
1169 MethodType MT_newString = methodType(void.class); //()V for new String()
1170 try { assertEquals(&quot;impossible&quot;, lookup()
1171         .findVirtual(String.class, &quot;&lt;init&gt;&quot;, MT_newString));
1172  } catch (NoSuchMethodException ex) { } // OK
1173 MethodHandle MH_newString = publicLookup()
1174   .findConstructor(String.class, MT_newString);
1175 assertEquals(&quot;&quot;, (String) MH_newString.invokeExact());
1176          * }&lt;/pre&gt;&lt;/blockquote&gt;
1177          *
1178          * @param refc the class or interface from which the method is accessed
1179          * @param name the name of the method
1180          * @param type the type of the method, with the receiver argument omitted
1181          * @return the desired method handle
1182          * @throws NoSuchMethodException if the method does not exist
1183          * @throws IllegalAccessException if access checking fails,
1184          *                                or if the method is {@code static},
1185          *                                or if the method&#39;s variable arity modifier bit
1186          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1187          * @exception SecurityException if a security manager is present and it</span>
1188          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1189          * @throws NullPointerException if any argument is null
1190          */
1191         public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1192             if (refc == MethodHandle.class) {
1193                 MethodHandle mh = findVirtualForMH(name, type);
1194                 if (mh != null)  return mh;
1195             } else if (refc == VarHandle.class) {
1196                 MethodHandle mh = findVirtualForVH(name, type);
1197                 if (mh != null)  return mh;
1198             }
1199             byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
1200             MemberName method = resolveOrFail(refKind, refc, name, type);
<span class="line-modified">1201             return getDirectMethod(refKind, refc, method, findBoundCallerClass(method));</span>
1202         }
1203         private MethodHandle findVirtualForMH(String name, MethodType type) {
1204             // these names require special lookups because of the implicit MethodType argument
1205             if (&quot;invoke&quot;.equals(name))
1206                 return invoker(type);
1207             if (&quot;invokeExact&quot;.equals(name))
1208                 return exactInvoker(type);
1209             assert(!MemberName.isMethodHandleInvokeName(name));
1210             return null;
1211         }
1212         private MethodHandle findVirtualForVH(String name, MethodType type) {
1213             try {
1214                 return varHandleInvoker(VarHandle.AccessMode.valueFromMethodName(name), type);
1215             } catch (IllegalArgumentException e) {
1216                 return null;
1217             }
1218         }
1219 
1220         /**
1221          * Produces a method handle which creates an object and initializes it, using
</pre>
<hr />
<pre>
1241 MethodHandle MH_newArrayList = publicLookup().findConstructor(
1242   ArrayList.class, methodType(void.class, Collection.class));
1243 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
1244 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
1245 assert(orig != copy);
1246 assertEquals(orig, copy);
1247 // a variable-arity constructor:
1248 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
1249   ProcessBuilder.class, methodType(void.class, String[].class));
1250 ProcessBuilder pb = (ProcessBuilder)
1251   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
1252 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
1253          * }&lt;/pre&gt;&lt;/blockquote&gt;
1254          * @param refc the class or interface from which the method is accessed
1255          * @param type the type of the method, with the receiver argument omitted, and a void return type
1256          * @return the desired method handle
1257          * @throws NoSuchMethodException if the constructor does not exist
1258          * @throws IllegalAccessException if access checking fails
1259          *                                or if the method&#39;s variable arity modifier bit
1260          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1261          * @exception SecurityException if a security manager is present and it</span>
1262          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1263          * @throws NullPointerException if any argument is null
1264          */
1265         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1266             if (refc.isArray()) {
1267                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
1268             }
1269             String name = &quot;&lt;init&gt;&quot;;
1270             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
1271             return getDirectConstructor(refc, ctor);
1272         }
1273 
1274         /**
<span class="line-modified">1275          * Looks up a class by name from the lookup context defined by this {@code Lookup} object. The static</span>
<span class="line-modified">1276          * initializer of the class is not run.</span>


1277          * &lt;p&gt;
<span class="line-modified">1278          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class}, its class</span>
<span class="line-modified">1279          * loader, and the {@linkplain #lookupModes() lookup modes}. In particular, the method first attempts to</span>
<span class="line-removed">1280          * load the requested class, and then determines whether the class is accessible to this lookup object.</span>
1281          *
1282          * @param targetName the fully qualified name of the class to be looked up.
1283          * @return the requested class.
<span class="line-modified">1284          * @exception SecurityException if a security manager is present and it</span>
<span class="line-modified">1285          *            &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
1286          * @throws LinkageError if the linkage fails
1287          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
1288          * @throws IllegalAccessException if the class is not accessible, using the allowed access
1289          * modes.
<span class="line-removed">1290          * @exception SecurityException if a security manager is present and it</span>
<span class="line-removed">1291          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
1292          * @since 9

1293          */
1294         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
1295             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
1296             return accessClass(targetClass);
1297         }
1298 
1299         /**
<span class="line-modified">1300          * Determines if a class can be accessed from the lookup context defined by this {@code Lookup} object. The</span>
<span class="line-modified">1301          * static initializer of the class is not run.</span>
1302          * &lt;p&gt;
<span class="line-modified">1303          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class} and the</span>
<span class="line-modified">1304          * {@linkplain #lookupModes() lookup modes}.</span>















1305          *
<span class="line-modified">1306          * @param targetClass the class to be access-checked</span>



































1307          *

1308          * @return the class that has been access-checked
<span class="line-modified">1309          *</span>
<span class="line-modified">1310          * @throws IllegalAccessException if the class is not accessible from the lookup class, using the allowed access</span>
<span class="line-modified">1311          * modes.</span>
<span class="line-removed">1312          * @exception SecurityException if a security manager is present and it</span>
1313          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1314          * @since 9

1315          */
1316         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
<span class="line-modified">1317             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, allowedModes)) {</span>
1318                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);
1319             }
1320             checkSecurityManager(targetClass, null);
1321             return targetClass;
1322         }
1323 
1324         /**
1325          * Produces an early-bound method handle for a virtual method.
1326          * It will bypass checks for overriding methods on the receiver,
1327          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
1328          * instruction from within the explicitly specified {@code specialCaller}.
1329          * The type of the method handle will be that of the method,
1330          * with a suitably restricted receiver type prepended.
1331          * (The receiver type will be {@code specialCaller} or a subtype.)
1332          * The method and all its argument types must be accessible
1333          * to the lookup object.
1334          * &lt;p&gt;
1335          * Before method resolution,
1336          * if the explicitly specified caller class is not identical with the
1337          * lookup class, or if this lookup object does not have
</pre>
<hr />
<pre>
1373 assertEquals(&quot;[]&quot;, (String) MH_super.invokeExact(l));
1374 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(l));
1375 assertEquals(&quot;[]&quot;, (String) MH_duper.invokeExact(l)); // ArrayList method
1376 try { assertEquals(&quot;inaccessible&quot;, Listie.lookup().findSpecial(
1377         String.class, &quot;toString&quot;, methodType(String.class), Listie.class));
1378  } catch (IllegalAccessException ex) { } // OK
1379 Listie subl = new Listie() { public String toString() { return &quot;[subclass]&quot;; } };
1380 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(subl)); // Listie method
1381          * }&lt;/pre&gt;&lt;/blockquote&gt;
1382          *
1383          * @param refc the class or interface from which the method is accessed
1384          * @param name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)
1385          * @param type the type of the method, with the receiver argument omitted
1386          * @param specialCaller the proposed calling class to perform the {@code invokespecial}
1387          * @return the desired method handle
1388          * @throws NoSuchMethodException if the method does not exist
1389          * @throws IllegalAccessException if access checking fails,
1390          *                                or if the method is {@code static},
1391          *                                or if the method&#39;s variable arity modifier bit
1392          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1393          * @exception SecurityException if a security manager is present and it</span>
1394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1395          * @throws NullPointerException if any argument is null
1396          */
1397         public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,
1398                                         Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {
1399             checkSpecialCaller(specialCaller, refc);
1400             Lookup specialLookup = this.in(specialCaller);
1401             MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="line-modified">1402             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerClass(method));</span>
1403         }
1404 
1405         /**
1406          * Produces a method handle giving read access to a non-static field.
1407          * The type of the method handle will have a return type of the field&#39;s
1408          * value type.
1409          * The method handle&#39;s single argument will be the instance containing
1410          * the field.
1411          * Access checking is performed immediately on behalf of the lookup class.
1412          * @param refc the class or interface from which the method is accessed
1413          * @param name the field&#39;s name
1414          * @param type the field&#39;s type
1415          * @return a method handle which can load values from the field
1416          * @throws NoSuchFieldException if the field does not exist
1417          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">1418          * @exception SecurityException if a security manager is present and it</span>
1419          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1420          * @throws NullPointerException if any argument is null
1421          * @see #findVarHandle(Class, String, Class)
1422          */
1423         public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1424             MemberName field = resolveOrFail(REF_getField, refc, name, type);
1425             return getDirectField(REF_getField, refc, field);
1426         }
1427 
1428         /**
1429          * Produces a method handle giving write access to a non-static field.
1430          * The type of the method handle will have a void return type.
1431          * The method handle will take two arguments, the instance containing
1432          * the field, and the value to be stored.
1433          * The second argument will be of the field&#39;s value type.
1434          * Access checking is performed immediately on behalf of the lookup class.
1435          * @param refc the class or interface from which the method is accessed
1436          * @param name the field&#39;s name
1437          * @param type the field&#39;s type
1438          * @return a method handle which can store values into the field
1439          * @throws NoSuchFieldException if the field does not exist
1440          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">1441          * @exception SecurityException if a security manager is present and it</span>

1442          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1443          * @throws NullPointerException if any argument is null
1444          * @see #findVarHandle(Class, String, Class)
1445          */
1446         public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1447             MemberName field = resolveOrFail(REF_putField, refc, name, type);
1448             return getDirectField(REF_putField, refc, field);
1449         }
1450 
1451         /**
1452          * Produces a VarHandle giving access to a non-static field {@code name}
1453          * of type {@code type} declared in a class of type {@code recv}.
1454          * The VarHandle&#39;s variable type is {@code type} and it has one
1455          * coordinate type, {@code recv}.
1456          * &lt;p&gt;
1457          * Access checking is performed immediately on behalf of the lookup
1458          * class.
1459          * &lt;p&gt;
1460          * Certain access modes of the returned VarHandle are unsupported under
1461          * the following conditions:
</pre>
<hr />
<pre>
1494          * There are many possible NaN values that are considered to be
1495          * {@code NaN} in Java, although no IEEE 754 floating-point operation
1496          * provided by Java can distinguish between them.  Operation failure can
1497          * occur if the expected or witness value is a NaN value and it is
1498          * transformed (perhaps in a platform specific manner) into another NaN
1499          * value, and thus has a different bitwise representation (see
1500          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
1501          * details).
1502          * The values {@code -0.0} and {@code +0.0} have different bitwise
1503          * representations but are considered equal when using the primitive
1504          * {@code ==} operator.  Operation failure can occur if, for example, a
1505          * numeric algorithm computes an expected value to be say {@code -0.0}
1506          * and previously computed the witness value to be say {@code +0.0}.
1507          * @param recv the receiver class, of type {@code R}, that declares the
1508          * non-static field
1509          * @param name the field&#39;s name
1510          * @param type the field&#39;s type, of type {@code T}
1511          * @return a VarHandle giving access to non-static fields.
1512          * @throws NoSuchFieldException if the field does not exist
1513          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">1514          * @exception SecurityException if a security manager is present and it</span>
1515          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1516          * @throws NullPointerException if any argument is null
1517          * @since 9
1518          */
1519         public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1520             MemberName getField = resolveOrFail(REF_getField, recv, name, type);
1521             MemberName putField = resolveOrFail(REF_putField, recv, name, type);
1522             return getFieldVarHandle(REF_getField, REF_putField, recv, getField, putField);
1523         }
1524 
1525         /**
1526          * Produces a method handle giving read access to a static field.
1527          * The type of the method handle will have a return type of the field&#39;s
1528          * value type.
1529          * The method handle will take no arguments.
1530          * Access checking is performed immediately on behalf of the lookup class.
1531          * &lt;p&gt;
1532          * If the returned method handle is invoked, the field&#39;s class will
1533          * be initialized, if it has not already been initialized.
1534          * @param refc the class or interface from which the method is accessed
1535          * @param name the field&#39;s name
1536          * @param type the field&#39;s type
1537          * @return a method handle which can load values from the field
1538          * @throws NoSuchFieldException if the field does not exist
1539          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">1540          * @exception SecurityException if a security manager is present and it</span>
1541          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1542          * @throws NullPointerException if any argument is null
1543          */
1544         public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1545             MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
1546             return getDirectField(REF_getStatic, refc, field);
1547         }
1548 
1549         /**
1550          * Produces a method handle giving write access to a static field.
1551          * The type of the method handle will have a void return type.
1552          * The method handle will take a single
1553          * argument, of the field&#39;s value type, the value to be stored.
1554          * Access checking is performed immediately on behalf of the lookup class.
1555          * &lt;p&gt;
1556          * If the returned method handle is invoked, the field&#39;s class will
1557          * be initialized, if it has not already been initialized.
1558          * @param refc the class or interface from which the method is accessed
1559          * @param name the field&#39;s name
1560          * @param type the field&#39;s type
1561          * @return a method handle which can store values into the field
1562          * @throws NoSuchFieldException if the field does not exist
1563          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">1564          * @exception SecurityException if a security manager is present and it</span>

1565          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1566          * @throws NullPointerException if any argument is null
1567          */
1568         public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1569             MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
1570             return getDirectField(REF_putStatic, refc, field);
1571         }
1572 
1573         /**
1574          * Produces a VarHandle giving access to a static field {@code name} of
1575          * type {@code type} declared in a class of type {@code decl}.
1576          * The VarHandle&#39;s variable type is {@code type} and it has no
1577          * coordinate types.
1578          * &lt;p&gt;
1579          * Access checking is performed immediately on behalf of the lookup
1580          * class.
1581          * &lt;p&gt;
1582          * If the returned VarHandle is operated on, the declaring class will be
1583          * initialized, if it has not already been initialized.
1584          * &lt;p&gt;
</pre>
<hr />
<pre>
1618          * unexpectedly fail.
1619          * There are many possible NaN values that are considered to be
1620          * {@code NaN} in Java, although no IEEE 754 floating-point operation
1621          * provided by Java can distinguish between them.  Operation failure can
1622          * occur if the expected or witness value is a NaN value and it is
1623          * transformed (perhaps in a platform specific manner) into another NaN
1624          * value, and thus has a different bitwise representation (see
1625          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
1626          * details).
1627          * The values {@code -0.0} and {@code +0.0} have different bitwise
1628          * representations but are considered equal when using the primitive
1629          * {@code ==} operator.  Operation failure can occur if, for example, a
1630          * numeric algorithm computes an expected value to be say {@code -0.0}
1631          * and previously computed the witness value to be say {@code +0.0}.
1632          * @param decl the class that declares the static field
1633          * @param name the field&#39;s name
1634          * @param type the field&#39;s type, of type {@code T}
1635          * @return a VarHandle giving access to a static field
1636          * @throws NoSuchFieldException if the field does not exist
1637          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">1638          * @exception SecurityException if a security manager is present and it</span>
1639          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1640          * @throws NullPointerException if any argument is null
1641          * @since 9
1642          */
1643         public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
1644             MemberName getField = resolveOrFail(REF_getStatic, decl, name, type);
1645             MemberName putField = resolveOrFail(REF_putStatic, decl, name, type);
1646             return getFieldVarHandle(REF_getStatic, REF_putStatic, decl, getField, putField);
1647         }
1648 
1649         /**
1650          * Produces an early-bound method handle for a non-static method.
1651          * The receiver must have a supertype {@code defc} in which a method
1652          * of the given name and type is accessible to the lookup class.
1653          * The method and all its argument types must be accessible to the lookup object.
1654          * The type of the method handle will be that of the method,
1655          * without any insertion of an additional receiver parameter.
1656          * The given receiver will be bound into the method handle,
1657          * so that every call to the method handle will invoke the
1658          * requested method on the given receiver.
</pre>
<hr />
<pre>
1672 MethodHandle mh0 = lookup().findVirtual(defc, name, type);
1673 MethodHandle mh1 = mh0.bindTo(receiver);
1674 mh1 = mh1.withVarargs(mh0.isVarargsCollector());
1675 return mh1;
1676          * }&lt;/pre&gt;&lt;/blockquote&gt;
1677          * where {@code defc} is either {@code receiver.getClass()} or a super
1678          * type of that class, in which the requested method is accessible
1679          * to the lookup class.
1680          * (Unlike {@code bind}, {@code bindTo} does not preserve variable arity.
1681          * Also, {@code bindTo} may throw a {@code ClassCastException} in instances where {@code bind} would
1682          * throw an {@code IllegalAccessException}, as in the case where the member is {@code protected} and
1683          * the receiver is restricted by {@code findVirtual} to the lookup class.)
1684          * @param receiver the object from which the method is accessed
1685          * @param name the name of the method
1686          * @param type the type of the method, with the receiver argument omitted
1687          * @return the desired method handle
1688          * @throws NoSuchMethodException if the method does not exist
1689          * @throws IllegalAccessException if access checking fails
1690          *                                or if the method&#39;s variable arity modifier bit
1691          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1692          * @exception SecurityException if a security manager is present and it</span>
1693          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1694          * @throws NullPointerException if any argument is null
1695          * @see MethodHandle#bindTo
1696          * @see #findVirtual
1697          */
1698         public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1699             Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE
1700             MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="line-modified">1701             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerClass(method));</span>
1702             if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
1703                 throw new IllegalAccessException(&quot;The restricted defining class &quot; +
1704                                                  mh.type().leadingReferenceParameter().getName() +
1705                                                  &quot; is not assignable from receiver class &quot; +
1706                                                  receiver.getClass().getName());
1707             }
1708             return mh.bindArgumentL(0, receiver).setVarargs(method);
1709         }
1710 
1711         /**
1712          * Makes a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
1713          * to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.
1714          * If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
1715          * If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
1716          * Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
1717          * The type of the method handle will be that of the method,
1718          * with the receiver type prepended (but only if it is non-static).
1719          * If the method&#39;s {@code accessible} flag is not set,
1720          * access checking is performed immediately on behalf of the lookup class.
1721          * If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
</pre>
<hr />
<pre>
1733          *                                or if the method&#39;s variable arity modifier bit
1734          *                                is set and {@code asVarargsCollector} fails
1735          * @throws NullPointerException if the argument is null
1736          */
1737         public MethodHandle unreflect(Method m) throws IllegalAccessException {
1738             if (m.getDeclaringClass() == MethodHandle.class) {
1739                 MethodHandle mh = unreflectForMH(m);
1740                 if (mh != null)  return mh;
1741             }
1742             if (m.getDeclaringClass() == VarHandle.class) {
1743                 MethodHandle mh = unreflectForVH(m);
1744                 if (mh != null)  return mh;
1745             }
1746             MemberName method = new MemberName(m);
1747             byte refKind = method.getReferenceKind();
1748             if (refKind == REF_invokeSpecial)
1749                 refKind = REF_invokeVirtual;
1750             assert(method.isMethod());
1751             @SuppressWarnings(&quot;deprecation&quot;)
1752             Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">1753             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerClass(method));</span>
1754         }
1755         private MethodHandle unreflectForMH(Method m) {
1756             // these names require special lookups because they throw UnsupportedOperationException
1757             if (MemberName.isMethodHandleInvokeName(m.getName()))
1758                 return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));
1759             return null;
1760         }
1761         private MethodHandle unreflectForVH(Method m) {
1762             // these names require special lookups because they throw UnsupportedOperationException
1763             if (MemberName.isVarHandleMethodInvokeName(m.getName()))
1764                 return MethodHandleImpl.fakeVarHandleInvoke(new MemberName(m));
1765             return null;
1766         }
1767 
1768         /**
1769          * Produces a method handle for a reflected method.
1770          * It will bypass checks for overriding methods on the receiver,
1771          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
1772          * instruction from within the explicitly specified {@code specialCaller}.
1773          * The type of the method handle will be that of the method,
</pre>
<hr />
<pre>
1779          * &lt;p&gt;
1780          * Before method resolution,
1781          * if the explicitly specified caller class is not identical with the
1782          * lookup class, or if this lookup object does not have
1783          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
1784          * privileges, the access fails.
1785          * &lt;p&gt;
1786          * The returned method handle will have
1787          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
1788          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
1789          * @param m the reflected method
1790          * @param specialCaller the class nominally calling the method
1791          * @return a method handle which can invoke the reflected method
1792          * @throws IllegalAccessException if access checking fails,
1793          *                                or if the method is {@code static},
1794          *                                or if the method&#39;s variable arity modifier bit
1795          *                                is set and {@code asVarargsCollector} fails
1796          * @throws NullPointerException if any argument is null
1797          */
1798         public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {
<span class="line-modified">1799             checkSpecialCaller(specialCaller, null);</span>
1800             Lookup specialLookup = this.in(specialCaller);
1801             MemberName method = new MemberName(m, true);
1802             assert(method.isMethod());
1803             // ignore m.isAccessible:  this is a new kind of access
<span class="line-modified">1804             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerClass(method));</span>
1805         }
1806 
1807         /**
1808          * Produces a method handle for a reflected constructor.
1809          * The type of the method handle will be that of the constructor,
1810          * with the return type changed to the declaring class.
1811          * The method handle will perform a {@code newInstance} operation,
1812          * creating a new instance of the constructor&#39;s class on the
1813          * arguments passed to the method handle.
1814          * &lt;p&gt;
1815          * If the constructor&#39;s {@code accessible} flag is not set,
1816          * access checking is performed immediately on behalf of the lookup class.
1817          * &lt;p&gt;
1818          * The returned method handle will have
1819          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
1820          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
1821          * &lt;p&gt;
1822          * If the returned method handle is invoked, the constructor&#39;s class will
1823          * be initialized, if it has not already been initialized.
1824          * @param c the reflected constructor
1825          * @return a method handle which can invoke the reflected constructor
1826          * @throws IllegalAccessException if access checking fails
1827          *                                or if the method&#39;s variable arity modifier bit
1828          *                                is set and {@code asVarargsCollector} fails
1829          * @throws NullPointerException if the argument is null
1830          */
1831         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
1832             MemberName ctor = new MemberName(c);
1833             assert(ctor.isConstructor());
1834             @SuppressWarnings(&quot;deprecation&quot;)
1835             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
1836             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);
1837         }
1838 
1839         /**
1840          * Produces a method handle giving read access to a reflected field.
1841          * The type of the method handle will have a return type of the field&#39;s
1842          * value type.
<span class="line-modified">1843          * If the field is static, the method handle will take no arguments.</span>
1844          * Otherwise, its single argument will be the instance containing
1845          * the field.
<span class="line-modified">1846          * If the field&#39;s {@code accessible} flag is not set,</span>
1847          * access checking is performed immediately on behalf of the lookup class.
1848          * &lt;p&gt;
1849          * If the field is static, and
1850          * if the returned method handle is invoked, the field&#39;s class will
1851          * be initialized, if it has not already been initialized.
1852          * @param f the reflected field
1853          * @return a method handle which can load values from the reflected field
1854          * @throws IllegalAccessException if access checking fails
1855          * @throws NullPointerException if the argument is null
1856          */
1857         public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
1858             return unreflectField(f, false);
1859         }
<span class="line-removed">1860         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {</span>
<span class="line-removed">1861             MemberName field = new MemberName(f, isSetter);</span>
<span class="line-removed">1862             assert(isSetter</span>
<span class="line-removed">1863                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())</span>
<span class="line-removed">1864                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));</span>
<span class="line-removed">1865             @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">1866             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;</span>
<span class="line-removed">1867             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);</span>
<span class="line-removed">1868         }</span>
1869 
1870         /**
1871          * Produces a method handle giving write access to a reflected field.
1872          * The type of the method handle will have a void return type.
<span class="line-modified">1873          * If the field is static, the method handle will take a single</span>
1874          * argument, of the field&#39;s value type, the value to be stored.
1875          * Otherwise, the two arguments will be the instance containing
1876          * the field, and the value to be stored.
<span class="line-modified">1877          * If the field&#39;s {@code accessible} flag is not set,</span>
1878          * access checking is performed immediately on behalf of the lookup class.
1879          * &lt;p&gt;
<span class="line-modified">1880          * If the field is static, and</span>








1881          * if the returned method handle is invoked, the field&#39;s class will
1882          * be initialized, if it has not already been initialized.
1883          * @param f the reflected field
1884          * @return a method handle which can store values into the reflected field
<span class="line-modified">1885          * @throws IllegalAccessException if access checking fails</span>


1886          * @throws NullPointerException if the argument is null
1887          */
1888         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
1889             return unreflectField(f, true);
1890         }
1891 












1892         /**
1893          * Produces a VarHandle giving access to a reflected field {@code f}
1894          * of type {@code T} declared in a class of type {@code R}.
1895          * The VarHandle&#39;s variable type is {@code T}.
1896          * If the field is non-static the VarHandle has one coordinate type,
1897          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
1898          * coordinate types.
1899          * &lt;p&gt;
1900          * Access checking is performed immediately on behalf of the lookup
1901          * class, regardless of the value of the field&#39;s {@code accessible}
1902          * flag.
1903          * &lt;p&gt;
1904          * If the field is static, and if the returned VarHandle is operated
1905          * on, the field&#39;s declaring class will be initialized, if it has not
1906          * already been initialized.
1907          * &lt;p&gt;
1908          * Certain access modes of the returned VarHandle are unsupported under
1909          * the following conditions:
1910          * &lt;ul&gt;
1911          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
</pre>
<hr />
<pre>
1961          * @since 9
1962          */
1963         public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
1964             MemberName getField = new MemberName(f, false);
1965             MemberName putField = new MemberName(f, true);
1966             return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),
1967                                                       f.getDeclaringClass(), getField, putField);
1968         }
1969 
1970         /**
1971          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
1972          * created by this lookup object or a similar one.
1973          * Security and access checks are performed to ensure that this lookup object
1974          * is capable of reproducing the target method handle.
1975          * This means that the cracking may fail if target is a direct method handle
1976          * but was created by an unrelated lookup object.
1977          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
1978          * and was created by a lookup object for a different class.
1979          * @param target a direct method handle to crack into symbolic reference components
1980          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
<span class="line-modified">1981          * @exception SecurityException if a security manager is present and it</span>
1982          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1983          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
<span class="line-modified">1984          * @exception NullPointerException if the target is {@code null}</span>
1985          * @see MethodHandleInfo
1986          * @since 1.8
1987          */
1988         public MethodHandleInfo revealDirect(MethodHandle target) {
1989             MemberName member = target.internalMemberName();
1990             if (member == null || (!member.isResolved() &amp;&amp;
1991                                    !member.isMethodHandleInvoke() &amp;&amp;
1992                                    !member.isVarHandleMethodInvoke()))
1993                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
1994             Class&lt;?&gt; defc = member.getDeclaringClass();
1995             byte refKind = member.getReferenceKind();
1996             assert(MethodHandleNatives.refKindIsValid(refKind));
1997             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
1998                 // Devirtualized method invocation is usually formally virtual.
1999                 // To avoid creating extra MemberName objects for this common case,
2000                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
2001                 refKind = REF_invokeVirtual;
2002             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
2003                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
2004                 refKind = REF_invokeInterface;
2005             // Check SM permissions and member access before cracking.
2006             try {
2007                 checkAccess(refKind, defc, member);
2008                 checkSecurityManager(defc, member);
2009             } catch (IllegalAccessException ex) {
2010                 throw new IllegalArgumentException(ex);
2011             }
2012             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
2013                 Class&lt;?&gt; callerClass = target.internalCallerClass();
<span class="line-modified">2014                 if (!hasPrivateAccess() || callerClass != lookupClass())</span>
2015                     throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
2016             }
2017             // Produce the handle to the results.
2018             return new InfoFromMemberName(this, member, refKind);
2019         }
2020 
2021         /// Helper methods, all package-private.
2022 
2023         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2024             checkSymbolicClass(refc);  // do this before attempting to resolve
2025             Objects.requireNonNull(name);
2026             Objects.requireNonNull(type);
2027             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
2028                                             NoSuchFieldException.class);
2029         }
2030 
2031         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2032             checkSymbolicClass(refc);  // do this before attempting to resolve
2033             Objects.requireNonNull(name);
2034             Objects.requireNonNull(type);
</pre>
<hr />
<pre>
2047 
2048         MemberName resolveOrNull(byte refKind, MemberName member) {
2049             // do this before attempting to resolve
2050             if (!isClassAccessible(member.getDeclaringClass())) {
2051                 return null;
2052             }
2053             Objects.requireNonNull(member.getName());
2054             Objects.requireNonNull(member.getType());
2055             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
2056         }
2057 
2058         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
2059             if (!isClassAccessible(refc)) {
2060                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
2061             }
2062         }
2063 
2064         boolean isClassAccessible(Class&lt;?&gt; refc) {
2065             Objects.requireNonNull(refc);
2066             Class&lt;?&gt; caller = lookupClassOrNull();
<span class="line-modified">2067             return caller == null || VerifyAccess.isClassAccessible(refc, caller, allowedModes);</span>
2068         }
2069 
2070         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
2071         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
2072             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)
2073                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);
2074         }
2075 
2076 
2077         /**
2078          * Find my trustable caller class if m is a caller sensitive method.
<span class="line-modified">2079          * If this lookup object has private access, then the caller class is the lookupClass.</span>
2080          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
2081          */
<span class="line-modified">2082         Class&lt;?&gt; findBoundCallerClass(MemberName m) throws IllegalAccessException {</span>
<span class="line-modified">2083             Class&lt;?&gt; callerClass = null;</span>
<span class="line-modified">2084             if (MethodHandleNatives.isCallerSensitive(m)) {</span>
<span class="line-modified">2085                 // Only lookups with private access are allowed to resolve caller-sensitive methods</span>
<span class="line-removed">2086                 if (hasPrivateAccess()) {</span>
<span class="line-removed">2087                     callerClass = lookupClass;</span>
<span class="line-removed">2088                 } else {</span>
<span class="line-removed">2089                     throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>
<span class="line-removed">2090                 }</span>
2091             }
<span class="line-modified">2092             return callerClass;</span>
2093         }
2094 
2095         /**
<span class="line-modified">2096          * Returns {@code true} if this lookup has {@code PRIVATE} access.</span>
<span class="line-modified">2097          * @return {@code true} if this lookup has {@code PRIVATE} access.</span>





2098          * @since 9
2099          */

2100         public boolean hasPrivateAccess() {
<span class="line-modified">2101             return (allowedModes &amp; PRIVATE) != 0;</span>














2102         }
2103 
2104         /**
2105          * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
2106          * Determines a trustable caller class to compare with refc, the symbolic reference class.
<span class="line-modified">2107          * If this lookup object has private access, then the caller class is the lookupClass.</span>
2108          */
2109         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {


2110             SecurityManager smgr = System.getSecurityManager();
2111             if (smgr == null)  return;
<span class="line-removed">2112             if (allowedModes == TRUSTED)  return;</span>
2113 
2114             // Step 1:
<span class="line-modified">2115             boolean fullPowerLookup = hasPrivateAccess();</span>
2116             if (!fullPowerLookup ||
2117                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
2118                 ReflectUtil.checkPackageAccess(refc);
2119             }
2120 
2121             if (m == null) {  // findClass or accessClass
2122                 // Step 2b:
2123                 if (!fullPowerLookup) {
2124                     smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
2125                 }
2126                 return;
2127             }
2128 
2129             // Step 2a:
2130             if (m.isPublic()) return;
2131             if (!fullPowerLookup) {
2132                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
2133             }
2134 
2135             // Step 3:
</pre>
<hr />
<pre>
2184                 // All arrays simply inherit Object.clone.
2185                 // But for access checking logic, we make Object.clone
2186                 // (normally protected) appear to be public.
2187                 // Later on, when the DirectMethodHandle is created,
2188                 // its leading argument will be restricted to the
2189                 // requested array type.
2190                 // N.B. The return type is not adjusted, because
2191                 // that is *not* the bytecode behavior.
2192                 mods ^= Modifier.PROTECTED | Modifier.PUBLIC;
2193             }
2194             if (Modifier.isProtected(mods) &amp;&amp; refKind == REF_newInvokeSpecial) {
2195                 // cannot &quot;new&quot; a protected ctor in a different package
2196                 mods ^= Modifier.PROTECTED;
2197             }
2198             if (Modifier.isFinal(mods) &amp;&amp;
2199                     MethodHandleNatives.refKindIsSetter(refKind))
2200                 throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);
2201             int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE
2202             if ((requestedModes &amp; allowedModes) != 0) {
2203                 if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
<span class="line-modified">2204                                                     mods, lookupClass(), allowedModes))</span>
2205                     return;
2206             } else {
2207                 // Protected members can also be checked as if they were package-private.
2208                 if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0
2209                         &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))
2210                     return;
2211             }
2212             throw m.makeAccessException(accessFailedMessage(refc, m), this);
2213         }
2214 
2215         String accessFailedMessage(Class&lt;?&gt; refc, MemberName m) {
2216             Class&lt;?&gt; defc = m.getDeclaringClass();
2217             int mods = m.getModifiers();
2218             // check the class first:
2219             boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
2220                                (defc == refc ||
2221                                 Modifier.isPublic(refc.getModifiers())));
2222             if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
<span class="line-modified">2223                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), FULL_POWER_MODES) &amp;&amp;</span>

2224                            (defc == refc ||
<span class="line-modified">2225                             VerifyAccess.isClassAccessible(refc, lookupClass(), FULL_POWER_MODES)));</span>
2226             }
2227             if (!classOK)
2228                 return &quot;class is not public&quot;;
2229             if (Modifier.isPublic(mods))
2230                 return &quot;access to public member failed&quot;;  // (how?, module not readable?)
2231             if (Modifier.isPrivate(mods))
2232                 return &quot;member is private&quot;;
2233             if (Modifier.isProtected(mods))
2234                 return &quot;member is protected&quot;;
2235             return &quot;member is private to package&quot;;
2236         }
2237 
2238         private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {
2239             int allowedModes = this.allowedModes;
2240             if (allowedModes == TRUSTED)  return;
<span class="line-modified">2241             if (!hasPrivateAccess()</span>
2242                 || (specialCaller != lookupClass()
2243                        // ensure non-abstract methods in superinterfaces can be special-invoked
2244                     &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))
2245                 throw new MemberName(specialCaller).
2246                     makeAccessException(&quot;no private access for invokespecial&quot;, this);
2247         }
2248 
2249         private boolean restrictProtectedReceiver(MemberName method) {
2250             // The accessing class only has the right to use a protected member
2251             // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
2252             if (!method.isProtected() || method.isStatic()
2253                 || allowedModes == TRUSTED
2254                 || method.getDeclaringClass() == lookupClass()
2255                 || VerifyAccess.isSamePackage(method.getDeclaringClass(), lookupClass()))
2256                 return false;
2257             return true;
2258         }
2259         private MethodHandle restrictReceiver(MemberName method, DirectMethodHandle mh, Class&lt;?&gt; caller) throws IllegalAccessException {
2260             assert(!method.isStatic());
2261             // receiver type of mh is too wide; narrow to caller
2262             if (!method.getDeclaringClass().isAssignableFrom(caller)) {
2263                 throw method.makeAccessException(&quot;caller class must be a subclass below the method&quot;, caller);
2264             }
2265             MethodType rawType = mh.type();
2266             if (caller.isAssignableFrom(rawType.parameterType(0))) return mh; // no need to restrict; already narrow
2267             MethodType narrowType = rawType.changeParameterType(0, caller);
2268             assert(!mh.isVarargsCollector());  // viewAsType will lose varargs-ness
2269             assert(mh.viewAsTypeChecks(narrowType, true));
2270             return mh.copyWith(narrowType, mh.form);
2271         }
2272 
2273         /** Check access and get the requested method. */
<span class="line-modified">2274         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
2275             final boolean doRestrict    = true;
2276             final boolean checkSecurity = true;
<span class="line-modified">2277             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
2278         }
2279         /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */
<span class="line-modified">2280         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
2281             final boolean doRestrict    = false;
2282             final boolean checkSecurity = true;
<span class="line-modified">2283             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
2284         }
2285         /** Check access and get the requested method, eliding security manager checks. */
<span class="line-modified">2286         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
2287             final boolean doRestrict    = true;
2288             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<span class="line-modified">2289             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
2290         }
2291         /** Common code for all methods; do not call directly except from immediately above. */
2292         private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
2293                                                    boolean checkSecurity,
<span class="line-modified">2294                                                    boolean doRestrict, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
<span class="line-modified">2295 </span>
2296             checkMethod(refKind, refc, method);
2297             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
2298             if (checkSecurity)
2299                 checkSecurityManager(refc, method);
2300             assert(!method.isMethodHandleInvoke());
2301 
2302             if (refKind == REF_invokeSpecial &amp;&amp;
2303                 refc != lookupClass() &amp;&amp;
2304                 !refc.isInterface() &amp;&amp;
2305                 refc != lookupClass().getSuperclass() &amp;&amp;
2306                 refc.isAssignableFrom(lookupClass())) {
2307                 assert(!method.getName().equals(&quot;&lt;init&gt;&quot;));  // not this code path
2308 
2309                 // Per JVMS 6.5, desc. of invokespecial instruction:
2310                 // If the method is in a superclass of the LC,
2311                 // and if our original search was above LC.super,
2312                 // repeat the search (symbolic lookup) from LC.super
2313                 // and continue with the direct superclass of that class,
2314                 // and so forth, until a match is found or no further superclasses exist.
2315                 // FIXME: MemberName.resolve should handle this instead.
2316                 Class&lt;?&gt; refcAsSuper = lookupClass();
2317                 MemberName m2;
2318                 do {
2319                     refcAsSuper = refcAsSuper.getSuperclass();
2320                     m2 = new MemberName(refcAsSuper,
2321                                         method.getName(),
2322                                         method.getMethodType(),
2323                                         REF_invokeSpecial);
2324                     m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());
2325                 } while (m2 == null &amp;&amp;         // no method is found yet
2326                          refc != refcAsSuper); // search up to refc
2327                 if (m2 == null)  throw new InternalError(method.toString());
2328                 method = m2;
2329                 refc = refcAsSuper;
2330                 // redo basic checks
2331                 checkMethod(refKind, refc, method);
2332             }
<span class="line-removed">2333 </span>
2334             DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
2335             MethodHandle mh = dmh;
2336             // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
2337             if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||
2338                     (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {
2339                 mh = restrictReceiver(method, dmh, lookupClass());
2340             }
<span class="line-modified">2341             mh = maybeBindCaller(method, mh, boundCallerClass);</span>
2342             mh = mh.setVarargs(method);
2343             return mh;
2344         }
<span class="line-modified">2345         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh,</span>
<span class="line-removed">2346                                              Class&lt;?&gt; boundCallerClass)</span>
2347                                              throws IllegalAccessException {
<span class="line-modified">2348             if (allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))</span>
2349                 return mh;
<span class="line-modified">2350             Class&lt;?&gt; hostClass = lookupClass;</span>
<span class="line-modified">2351             if (!hasPrivateAccess())  // caller must have private access</span>
<span class="line-modified">2352                 hostClass = boundCallerClass;  // boundCallerClass came from a security manager style stack walk</span>
<span class="line-modified">2353             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, hostClass);</span>



2354             // Note: caller will apply varargs after this step happens.
2355             return cbmh;
2356         }

2357         /** Check access and get the requested field. */
2358         private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
2359             final boolean checkSecurity = true;
2360             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
2361         }
2362         /** Check access and get the requested field, eliding security manager checks. */
2363         private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
2364             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
2365             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
2366         }
2367         /** Common code for all fields; do not call directly except from immediately above. */
2368         private MethodHandle getDirectFieldCommon(byte refKind, Class&lt;?&gt; refc, MemberName field,
2369                                                   boolean checkSecurity) throws IllegalAccessException {
2370             checkField(refKind, refc, field);
2371             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
2372             if (checkSecurity)
2373                 checkSecurityManager(refc, field);
2374             DirectMethodHandle dmh = DirectMethodHandle.make(refc, field);
2375             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp;
2376                                     restrictProtectedReceiver(field));
</pre>
<hr />
<pre>
2432         /** Check access and get the requested constructor, eliding security manager checks. */
2433         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
2434             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
2435             return getDirectConstructorCommon(refc, ctor, checkSecurity);
2436         }
2437         /** Common code for all constructors; do not call directly except from immediately above. */
2438         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
2439                                                   boolean checkSecurity) throws IllegalAccessException {
2440             assert(ctor.isConstructor());
2441             checkAccess(REF_newInvokeSpecial, refc, ctor);
2442             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
2443             if (checkSecurity)
2444                 checkSecurityManager(refc, ctor);
2445             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
2446             return DirectMethodHandle.make(ctor).setVarargs(ctor);
2447         }
2448 
2449         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
2450          */
2451         /*non-public*/
<span class="line-modified">2452         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type) throws ReflectiveOperationException {</span>

2453             if (!(type instanceof Class || type instanceof MethodType))
2454                 throw new InternalError(&quot;unresolved MemberName&quot;);
2455             MemberName member = new MemberName(refKind, defc, name, type);
2456             MethodHandle mh = LOOKASIDE_TABLE.get(member);
2457             if (mh != null) {
2458                 checkSymbolicClass(defc);
2459                 return mh;
2460             }
2461             if (defc == MethodHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
2462                 // Treat MethodHandle.invoke and invokeExact specially.
2463                 mh = findVirtualForMH(member.getName(), member.getMethodType());
2464                 if (mh != null) {
2465                     return mh;
2466                 }
2467             } else if (defc == VarHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
2468                 // Treat signature-polymorphic methods on VarHandle specially.
2469                 mh = findVirtualForVH(member.getName(), member.getMethodType());
2470                 if (mh != null) {
2471                     return mh;
2472                 }
2473             }
2474             MemberName resolved = resolveOrFail(refKind, member);
2475             mh = getDirectMethodForConstant(refKind, defc, resolved);
2476             if (mh instanceof DirectMethodHandle
2477                     &amp;&amp; canBeCached(refKind, defc, resolved)) {
2478                 MemberName key = mh.internalMemberName();
2479                 if (key != null) {
2480                     key = key.asNormalOriginal();
2481                 }
2482                 if (member.equals(key)) {  // better safe than sorry
2483                     LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);
2484                 }
2485             }
2486             return mh;
2487         }
<span class="line-modified">2488         private</span>
<span class="line-removed">2489         boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {</span>
2490             if (refKind == REF_invokeSpecial) {
2491                 return false;
2492             }
2493             if (!Modifier.isPublic(defc.getModifiers()) ||
2494                     !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
2495                     !member.isPublic() ||
2496                     member.isCallerSensitive()) {
2497                 return false;
2498             }
2499             ClassLoader loader = defc.getClassLoader();
2500             if (loader != null) {
2501                 ClassLoader sysl = ClassLoader.getSystemClassLoader();
2502                 boolean found = false;
2503                 while (sysl != null) {
2504                     if (loader == sysl) { found = true; break; }
2505                     sysl = sysl.getParent();
2506                 }
2507                 if (!found) {
2508                     return false;
2509                 }
2510             }
2511             try {
2512                 MemberName resolved2 = publicLookup().resolveOrNull(refKind,
2513                     new MemberName(refKind, defc, member.getName(), member.getType()));
2514                 if (resolved2 == null) {
2515                     return false;
2516                 }
2517                 checkSecurityManager(defc, resolved2);
2518             } catch (SecurityException ex) {
2519                 return false;
2520             }
2521             return true;
2522         }
<span class="line-modified">2523         private</span>
<span class="line-removed">2524         MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)</span>
2525                 throws ReflectiveOperationException {
2526             if (MethodHandleNatives.refKindIsField(refKind)) {
2527                 return getDirectFieldNoSecurityManager(refKind, defc, member);
2528             } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
<span class="line-modified">2529                 return getDirectMethodNoSecurityManager(refKind, defc, member, lookupClass);</span>
2530             } else if (refKind == REF_newInvokeSpecial) {
2531                 return getDirectConstructorNoSecurityManager(defc, member);
2532             }
2533             // oops
2534             throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
2535         }
2536 
2537         static ConcurrentHashMap&lt;MemberName, DirectMethodHandle&gt; LOOKASIDE_TABLE = new ConcurrentHashMap&lt;&gt;();
2538     }
2539 
2540     /**
2541      * Produces a method handle constructing arrays of a desired type,
2542      * as if by the {@code anewarray} bytecode.
2543      * The return type of the method handle will be the array type.
2544      * The type of its sole argument will be {@code int}, which specifies the size of the array.
2545      *
2546      * &lt;p&gt; If the returned method handle is invoked with a negative
2547      * array size, a {@code NegativeArraySizeException} will be thrown.
2548      *
2549      * @param arrayClass an array type
2550      * @return a method handle which can create arrays of the given type
2551      * @throws NullPointerException if the argument is {@code null}
2552      * @throws IllegalArgumentException if {@code arrayClass} is not an array type
2553      * @see java.lang.reflect.Array#newInstance(Class, int)
2554      * @jvms 6.5 {@code anewarray} Instruction
2555      * @since 9
2556      */
<span class="line-modified">2557     public static</span>
<span class="line-removed">2558     MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
2559         if (!arrayClass.isArray()) {
2560             throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
2561         }
2562         MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
2563                 bindTo(arrayClass.getComponentType());
2564         return ani.asType(ani.type().changeReturnType(arrayClass));
2565     }
2566 
2567     /**
2568      * Produces a method handle returning the length of an array,
2569      * as if by the {@code arraylength} bytecode.
2570      * The type of the method handle will have {@code int} as return type,
2571      * and its sole argument will be the array type.
2572      *
2573      * &lt;p&gt; If the returned method handle is invoked with a {@code null}
2574      * array reference, a {@code NullPointerException} will be thrown.
2575      *
2576      * @param arrayClass an array type
2577      * @return a method handle which can retrieve the length of an array of the given array type
2578      * @throws NullPointerException if the argument is {@code null}
2579      * @throws IllegalArgumentException if arrayClass is not an array type
2580      * @jvms 6.5 {@code arraylength} Instruction
2581      * @since 9
2582      */
<span class="line-modified">2583     public static</span>
<span class="line-removed">2584     MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
2585         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
2586     }
2587 
2588     /**
2589      * Produces a method handle giving read access to elements of an array,
2590      * as if by the {@code aaload} bytecode.
2591      * The type of the method handle will have a return type of the array&#39;s
2592      * element type.  Its first argument will be the array type,
2593      * and the second will be {@code int}.
2594      *
2595      * &lt;p&gt; When the returned method handle is invoked,
2596      * the array reference and array index are checked.
2597      * A {@code NullPointerException} will be thrown if the array reference
2598      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
2599      * thrown if the index is negative or if it is greater than or equal to
2600      * the length of the array.
2601      *
2602      * @param arrayClass an array type
2603      * @return a method handle which can load values from the given array type
2604      * @throws NullPointerException if the argument is null
2605      * @throws  IllegalArgumentException if arrayClass is not an array type
2606      * @jvms 6.5 {@code aaload} Instruction
2607      */
<span class="line-modified">2608     public static</span>
<span class="line-removed">2609     MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
2610         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
2611     }
2612 
2613     /**
2614      * Produces a method handle giving write access to elements of an array,
2615      * as if by the {@code astore} bytecode.
2616      * The type of the method handle will have a void return type.
2617      * Its last argument will be the array&#39;s element type.
2618      * The first and second arguments will be the array type and int.
2619      *
2620      * &lt;p&gt; When the returned method handle is invoked,
2621      * the array reference and array index are checked.
2622      * A {@code NullPointerException} will be thrown if the array reference
2623      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
2624      * thrown if the index is negative or if it is greater than or equal to
2625      * the length of the array.
2626      *
2627      * @param arrayClass the class of an array
2628      * @return a method handle which can store values into the array type
2629      * @throws NullPointerException if the argument is null
2630      * @throws IllegalArgumentException if arrayClass is not an array type
2631      * @jvms 6.5 {@code aastore} Instruction
2632      */
<span class="line-modified">2633     public static</span>
<span class="line-removed">2634     MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
2635         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
2636     }
2637 
2638     /**
2639      * Produces a VarHandle giving access to elements of an array of type
2640      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
2641      * of {@code arrayClass} and the list of coordinate types is
2642      * {@code (arrayClass, int)}, where the {@code int} coordinate type
2643      * corresponds to an argument that is an index into an array.
2644      * &lt;p&gt;
2645      * Certain access modes of the returned VarHandle are unsupported under
2646      * the following conditions:
2647      * &lt;ul&gt;
2648      * &lt;li&gt;if the component type is anything other than {@code byte},
2649      *     {@code short}, {@code char}, {@code int}, {@code long},
2650      *     {@code float}, or {@code double} then numeric atomic update access
2651      *     modes are unsupported.
2652      * &lt;li&gt;if the field type is anything other than {@code boolean},
2653      *     {@code byte}, {@code short}, {@code char}, {@code int} or
2654      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
2678      * unexpectedly fail.
2679      * There are many possible NaN values that are considered to be
2680      * {@code NaN} in Java, although no IEEE 754 floating-point operation
2681      * provided by Java can distinguish between them.  Operation failure can
2682      * occur if the expected or witness value is a NaN value and it is
2683      * transformed (perhaps in a platform specific manner) into another NaN
2684      * value, and thus has a different bitwise representation (see
2685      * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2686      * details).
2687      * The values {@code -0.0} and {@code +0.0} have different bitwise
2688      * representations but are considered equal when using the primitive
2689      * {@code ==} operator.  Operation failure can occur if, for example, a
2690      * numeric algorithm computes an expected value to be say {@code -0.0}
2691      * and previously computed the witness value to be say {@code +0.0}.
2692      * @param arrayClass the class of an array, of type {@code T[]}
2693      * @return a VarHandle giving access to elements of an array
2694      * @throws NullPointerException if the arrayClass is null
2695      * @throws IllegalArgumentException if arrayClass is not an array type
2696      * @since 9
2697      */
<span class="line-modified">2698     public static</span>
<span class="line-removed">2699     VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
2700         return VarHandles.makeArrayElementHandle(arrayClass);
2701     }
2702 
2703     /**
2704      * Produces a VarHandle giving access to elements of a {@code byte[]} array
2705      * viewed as if it were a different primitive array type, such as
2706      * {@code int[]} or {@code long[]}.
2707      * The VarHandle&#39;s variable type is the component type of
2708      * {@code viewArrayClass} and the list of coordinate types is
2709      * {@code (byte[], int)}, where the {@code int} coordinate type
2710      * corresponds to an argument that is an index into a {@code byte[]} array.
2711      * The returned VarHandle accesses bytes at an index in a {@code byte[]}
2712      * array, composing bytes to or from a value of the component type of
2713      * {@code viewArrayClass} according to the given endianness.
2714      * &lt;p&gt;
2715      * The supported component types (variables types) are {@code short},
2716      * {@code char}, {@code int}, {@code long}, {@code float} and
2717      * {@code double}.
2718      * &lt;p&gt;
2719      * Access of bytes at a given index will result in an
</pre>
<hr />
<pre>
2759      * boolean isMisaligned = misalignedAtIndex != 0;
2760      * }&lt;/pre&gt;
2761      * &lt;p&gt;
2762      * If the variable type is {@code float} or {@code double} then atomic
2763      * update access modes compare values using their bitwise representation
2764      * (see {@link Float#floatToRawIntBits} and
2765      * {@link Double#doubleToRawLongBits}, respectively).
2766      * @param viewArrayClass the view array class, with a component type of
2767      * type {@code T}
2768      * @param byteOrder the endianness of the view array elements, as
2769      * stored in the underlying {@code byte} array
2770      * @return a VarHandle giving access to elements of a {@code byte[]} array
2771      * viewed as if elements corresponding to the components type of the view
2772      * array class
2773      * @throws NullPointerException if viewArrayClass or byteOrder is null
2774      * @throws IllegalArgumentException if viewArrayClass is not an array type
2775      * @throws UnsupportedOperationException if the component type of
2776      * viewArrayClass is not supported as a variable type
2777      * @since 9
2778      */
<span class="line-modified">2779     public static</span>
<span class="line-removed">2780     VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
2781                                      ByteOrder byteOrder) throws IllegalArgumentException {
2782         Objects.requireNonNull(byteOrder);
2783         return VarHandles.byteArrayViewHandle(viewArrayClass,
2784                                               byteOrder == ByteOrder.BIG_ENDIAN);
2785     }
2786 
2787     /**
2788      * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
2789      * viewed as if it were an array of elements of a different primitive
2790      * component type to that of {@code byte}, such as {@code int[]} or
2791      * {@code long[]}.
2792      * The VarHandle&#39;s variable type is the component type of
2793      * {@code viewArrayClass} and the list of coordinate types is
2794      * {@code (ByteBuffer, int)}, where the {@code int} coordinate type
2795      * corresponds to an argument that is an index into a {@code byte[]} array.
2796      * The returned VarHandle accesses bytes at an index in a
2797      * {@code ByteBuffer}, composing bytes to or from a value of the component
2798      * type of {@code viewArrayClass} according to the given endianness.
2799      * &lt;p&gt;
2800      * The supported component types (variables types) are {@code short},
</pre>
<hr />
<pre>
2847      * }&lt;/pre&gt;
2848      * &lt;p&gt;
2849      * If the variable type is {@code float} or {@code double} then atomic
2850      * update access modes compare values using their bitwise representation
2851      * (see {@link Float#floatToRawIntBits} and
2852      * {@link Double#doubleToRawLongBits}, respectively).
2853      * @param viewArrayClass the view array class, with a component type of
2854      * type {@code T}
2855      * @param byteOrder the endianness of the view array elements, as
2856      * stored in the underlying {@code ByteBuffer} (Note this overrides the
2857      * endianness of a {@code ByteBuffer})
2858      * @return a VarHandle giving access to elements of a {@code ByteBuffer}
2859      * viewed as if elements corresponding to the components type of the view
2860      * array class
2861      * @throws NullPointerException if viewArrayClass or byteOrder is null
2862      * @throws IllegalArgumentException if viewArrayClass is not an array type
2863      * @throws UnsupportedOperationException if the component type of
2864      * viewArrayClass is not supported as a variable type
2865      * @since 9
2866      */
<span class="line-modified">2867     public static</span>
<span class="line-removed">2868     VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
2869                                       ByteOrder byteOrder) throws IllegalArgumentException {
2870         Objects.requireNonNull(byteOrder);
2871         return VarHandles.makeByteBufferViewHandle(viewArrayClass,
2872                                                    byteOrder == ByteOrder.BIG_ENDIAN);
2873     }
2874 
2875 
2876     /// method handle invocation (reflective style)
2877 
2878     /**
2879      * Produces a method handle which will invoke any method handle of the
2880      * given {@code type}, with a given number of trailing arguments replaced by
2881      * a single trailing {@code Object[]} array.
2882      * The resulting invoker will be a method handle with the following
2883      * arguments:
2884      * &lt;ul&gt;
2885      * &lt;li&gt;a single {@code MethodHandle} target
2886      * &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
2887      * &lt;li&gt;an {@code Object[]} array containing trailing arguments
2888      * &lt;/ul&gt;
</pre>
<hr />
<pre>
2904      * not have the correct number of elements, the invoker will throw
2905      * an {@link IllegalArgumentException} instead of invoking the target.
2906      * &lt;p&gt;
2907      * This method is equivalent to the following code (though it may be more efficient):
2908      * &lt;blockquote&gt;&lt;pre&gt;{@code
2909 MethodHandle invoker = MethodHandles.invoker(type);
2910 int spreadArgCount = type.parameterCount() - leadingArgCount;
2911 invoker = invoker.asSpreader(Object[].class, spreadArgCount);
2912 return invoker;
2913      * }&lt;/pre&gt;&lt;/blockquote&gt;
2914      * This method throws no reflective or security exceptions.
2915      * @param type the desired target type
2916      * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target
2917      * @return a method handle suitable for invoking any method handle of the given type
2918      * @throws NullPointerException if {@code type} is null
2919      * @throws IllegalArgumentException if {@code leadingArgCount} is not in
2920      *                  the range from 0 to {@code type.parameterCount()} inclusive,
2921      *                  or if the resulting method handle&#39;s type would have
2922      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
2923      */
<span class="line-modified">2924     public static</span>
<span class="line-removed">2925     MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {</span>
2926         if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
2927             throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
2928         type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
2929         return type.invokers().spreadInvoker(leadingArgCount);
2930     }
2931 
2932     /**
2933      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
2934      * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
2935      * The resulting invoker will have a type which is
2936      * exactly equal to the desired type, except that it will accept
2937      * an additional leading argument of type {@code MethodHandle}.
2938      * &lt;p&gt;
2939      * This method is equivalent to the following code (though it may be more efficient):
2940      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}
2941      *
2942      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2943      * &lt;em&gt;Discussion:&lt;/em&gt;
2944      * Invoker method handles can be useful when working with variable method handles
2945      * of unknown types.
</pre>
<hr />
<pre>
2947      * handle {@code M}, extract its type {@code T},
2948      * look up the invoker method {@code X} for {@code T},
2949      * and call the invoker method, as {@code X.invoke(T, A...)}.
2950      * (It would not work to call {@code X.invokeExact}, since the type {@code T}
2951      * is unknown.)
2952      * If spreading, collecting, or other argument transformations are required,
2953      * they can be applied once to the invoker {@code X} and reused on many {@code M}
2954      * method handle values, as long as they are compatible with the type of {@code X}.
2955      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2956      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
2957      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
2958      * on the declared {@code invokeExact} or {@code invoke} method will raise an
2959      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
2960      * &lt;p&gt;
2961      * This method throws no reflective or security exceptions.
2962      * @param type the desired target type
2963      * @return a method handle suitable for invoking any method handle of the given type
2964      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
2965      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
2966      */
<span class="line-modified">2967     public static</span>
<span class="line-removed">2968     MethodHandle exactInvoker(MethodType type) {</span>
2969         return type.invokers().exactInvoker();
2970     }
2971 
2972     /**
2973      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
2974      * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
2975      * The resulting invoker will have a type which is
2976      * exactly equal to the desired type, except that it will accept
2977      * an additional leading argument of type {@code MethodHandle}.
2978      * &lt;p&gt;
2979      * Before invoking its target, if the target differs from the expected type,
2980      * the invoker will apply reference casts as
2981      * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
2982      * Similarly, the return value will be converted as necessary.
2983      * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
2984      * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
2985      * &lt;p&gt;
2986      * This method is equivalent to the following code (though it may be more efficient):
2987      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
2988      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2989      * &lt;em&gt;Discussion:&lt;/em&gt;
2990      * A {@linkplain MethodType#genericMethodType general method type} is one which
2991      * mentions only {@code Object} arguments and return values.
2992      * An invoker for such a type is capable of calling any method handle
2993      * of the same arity as the general type.
2994      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
2995      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
2996      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
2997      * on the declared {@code invokeExact} or {@code invoke} method will raise an
2998      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
2999      * &lt;p&gt;
3000      * This method throws no reflective or security exceptions.
3001      * @param type the desired target type
3002      * @return a method handle suitable for invoking any method handle convertible to the given type
3003      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
3004      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3005      */
<span class="line-modified">3006     public static</span>
<span class="line-removed">3007     MethodHandle invoker(MethodType type) {</span>
3008         return type.invokers().genericInvoker();
3009     }
3010 
3011     /**
3012      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3013      * invoke a signature-polymorphic access mode method on any VarHandle whose
3014      * associated access mode type is compatible with the given type.
3015      * The resulting invoker will have a type which is exactly equal to the
3016      * desired given type, except that it will accept an additional leading
3017      * argument of type {@code VarHandle}.
3018      *
3019      * @param accessMode the VarHandle access mode
3020      * @param type the desired target type
3021      * @return a method handle suitable for invoking an access mode method of
3022      *         any VarHandle whose access mode type is of the given type.
3023      * @since 9
3024      */
<span class="line-modified">3025     static public</span>
<span class="line-removed">3026     MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
3027         return type.invokers().varHandleMethodExactInvoker(accessMode);
3028     }
3029 
3030     /**
3031      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3032      * invoke a signature-polymorphic access mode method on any VarHandle whose
3033      * associated access mode type is compatible with the given type.
3034      * The resulting invoker will have a type which is exactly equal to the
3035      * desired given type, except that it will accept an additional leading
3036      * argument of type {@code VarHandle}.
3037      * &lt;p&gt;
3038      * Before invoking its target, if the access mode type differs from the
3039      * desired given type, the invoker will apply reference casts as necessary
3040      * and box, unbox, or widen primitive values, as if by
3041      * {@link MethodHandle#asType asType}.  Similarly, the return value will be
3042      * converted as necessary.
3043      * &lt;p&gt;
3044      * This method is equivalent to the following code (though it may be more
3045      * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
3046      *
3047      * @param accessMode the VarHandle access mode
3048      * @param type the desired target type
3049      * @return a method handle suitable for invoking an access mode method of
3050      *         any VarHandle whose access mode type is convertible to the given
3051      *         type.
3052      * @since 9
3053      */
<span class="line-modified">3054     static public</span>
<span class="line-removed">3055     MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
3056         return type.invokers().varHandleMethodInvoker(accessMode);
3057     }
3058 
<span class="line-modified">3059     static /*non-public*/</span>
<span class="line-modified">3060     MethodHandle basicInvoker(MethodType type) {</span>
3061         return type.invokers().basicInvoker();
3062     }
3063 
3064      /// method handle modification (creation from other method handles)
3065 
3066     /**
3067      * Produces a method handle which adapts the type of the
3068      * given method handle to a new type by pairwise argument and return type conversion.
3069      * The original type and new type must have the same number of arguments.
3070      * The resulting method handle is guaranteed to report a type
3071      * which is equal to the desired new type.
3072      * &lt;p&gt;
3073      * If the original type and new type are equal, returns target.
3074      * &lt;p&gt;
3075      * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
3076      * and some additional conversions are also applied if those conversions fail.
3077      * Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
3078      * if possible, before or instead of any conversions done by {@code asType}:
3079      * &lt;ul&gt;
3080      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
</pre>
<hr />
<pre>
3090      *     then a Java casting conversion (JLS 5.5) is applied.
3091      *     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
3092      *     widening and/or narrowing.)
3093      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
3094      *     conversion will be applied at runtime, possibly followed
3095      *     by a Java casting conversion (JLS 5.5) on the primitive value,
3096      *     possibly followed by a conversion from byte to boolean by testing
3097      *     the low-order bit.
3098      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
3099      *     and if the reference is null at runtime, a zero value is introduced.
3100      * &lt;/ul&gt;
3101      * @param target the method handle to invoke after arguments are retyped
3102      * @param newType the expected type of the new method handle
3103      * @return a method handle which delegates to the target after performing
3104      *           any necessary argument conversions, and arranges for any
3105      *           necessary return value conversions
3106      * @throws NullPointerException if either argument is null
3107      * @throws WrongMethodTypeException if the conversion cannot be made
3108      * @see MethodHandle#asType
3109      */
<span class="line-modified">3110     public static</span>
<span class="line-removed">3111     MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {</span>
3112         explicitCastArgumentsChecks(target, newType);
3113         // use the asTypeCache when possible:
3114         MethodType oldType = target.type();
3115         if (oldType == newType)  return target;
3116         if (oldType.explicitCastEquivalentToAsType(newType)) {
3117             return target.asFixedArity().asType(newType);
3118         }
3119         return MethodHandleImpl.makePairwiseConvert(target, newType, false);
3120     }
3121 
3122     private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType) {
3123         if (target.type().parameterCount() != newType.parameterCount()) {
3124             throw new WrongMethodTypeException(&quot;cannot explicitly cast &quot; + target + &quot; to &quot; + newType);
3125         }
3126     }
3127 
3128     /**
3129      * Produces a method handle which adapts the calling sequence of the
3130      * given method handle to a new type, by reordering the arguments.
3131      * The resulting method handle is guaranteed to report a type
</pre>
<hr />
<pre>
3170 assert(add.type().equals(intfn2));
3171 MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
3172 assert(twice.type().equals(intfn1));
3173 assert((int)twice.invokeExact(21) == 42);
3174      * }&lt;/pre&gt;&lt;/blockquote&gt;
3175      * &lt;p&gt;
3176      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
3177      * variable-arity method handle}, even if the original target method handle was.
3178      * @param target the method handle to invoke after arguments are reordered
3179      * @param newType the expected type of the new method handle
3180      * @param reorder an index array which controls the reordering
3181      * @return a method handle which delegates to the target after it
3182      *           drops unused arguments and moves and/or duplicates the other arguments
3183      * @throws NullPointerException if any argument is null
3184      * @throws IllegalArgumentException if the index array length is not equal to
3185      *                  the arity of the target, or if any index array element
3186      *                  not a valid index for a parameter of {@code newType},
3187      *                  or if two corresponding parameter types in
3188      *                  {@code target.type()} and {@code newType} are not identical,
3189      */
<span class="line-modified">3190     public static</span>
<span class="line-removed">3191     MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {</span>
3192         reorder = reorder.clone();  // get a private copy
3193         MethodType oldType = target.type();
3194         permuteArgumentChecks(reorder, newType, oldType);
3195         // first detect dropped arguments and handle them separately
3196         int[] originalReorder = reorder;
3197         BoundMethodHandle result = target.rebind();
3198         LambdaForm form = result.form;
3199         int newArity = newType.parameterCount();
3200         // Normalize the reordering into a real permutation,
3201         // by removing duplicates and adding dropped elements.
3202         // This somewhat improves lambda form caching, as well
3203         // as simplifying the transform by breaking it up into steps.
3204         for (int ddIdx; (ddIdx = findFirstDupOrDrop(reorder, newArity)) != 0; ) {
3205             if (ddIdx &gt; 0) {
3206                 // We found a duplicated entry at reorder[ddIdx].
3207                 // Example:  (x,y,z)-&gt;asList(x,y,z)
3208                 // permuted by [1*,0,1] =&gt; (a0,a1)=&gt;asList(a1,a0,a1)
3209                 // permuted by [0,1,0*] =&gt; (a0,a1)=&gt;asList(a0,a1,a0)
3210                 // The starred element corresponds to the argument
3211                 // deleted by the dupArgumentForm transform.
</pre>
<hr />
<pre>
3330             if (!bad)  return true;
3331         }
3332         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
3333     }
3334 
3335     /**
3336      * Produces a method handle of the requested return type which returns the given
3337      * constant value every time it is invoked.
3338      * &lt;p&gt;
3339      * Before the method handle is returned, the passed-in value is converted to the requested type.
3340      * If the requested type is primitive, widening primitive conversions are attempted,
3341      * else reference conversions are attempted.
3342      * &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
3343      * @param type the return type of the desired method handle
3344      * @param value the value to return
3345      * @return a method handle of the given return type and no arguments, which always returns the given value
3346      * @throws NullPointerException if the {@code type} argument is null
3347      * @throws ClassCastException if the value cannot be converted to the required return type
3348      * @throws IllegalArgumentException if the given type is {@code void.class}
3349      */
<span class="line-modified">3350     public static</span>
<span class="line-removed">3351     MethodHandle constant(Class&lt;?&gt; type, Object value) {</span>
3352         if (type.isPrimitive()) {
3353             if (type == void.class)
3354                 throw newIllegalArgumentException(&quot;void type&quot;);
3355             Wrapper w = Wrapper.forPrimitiveType(type);
3356             value = w.convert(value, type);
3357             if (w.zero().equals(value))
3358                 return zero(w, type);
3359             return insertArguments(identity(type), 0, value);
3360         } else {
3361             if (value == null)
3362                 return zero(Wrapper.OBJECT, type);
3363             return identity(type).bindTo(value);
3364         }
3365     }
3366 
3367     /**
3368      * Produces a method handle which returns its sole argument when invoked.
3369      * @param type the type of the sole parameter and return value of the desired method handle
3370      * @return a unary method handle which accepts and returns the given type
3371      * @throws NullPointerException if the argument is null
3372      * @throws IllegalArgumentException if the given type is {@code void.class}
3373      */
<span class="line-modified">3374     public static</span>
<span class="line-removed">3375     MethodHandle identity(Class&lt;?&gt; type) {</span>
3376         Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
3377         int pos = btw.ordinal();
3378         MethodHandle ident = IDENTITY_MHS[pos];
3379         if (ident == null) {
3380             ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
3381         }
3382         if (ident.type().returnType() == type)
3383             return ident;
3384         // something like identity(Foo.class); do not bother to intern these
3385         assert (btw == Wrapper.OBJECT);
3386         return makeIdentity(type);
3387     }
3388 
3389     /**
3390      * Produces a constant method handle of the requested return type which
3391      * returns the default value for that type every time it is invoked.
3392      * The resulting constant method handle will have no side effects.
3393      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
3394      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
3395      * since {@code explicitCastArguments} converts {@code null} to default values.
</pre>
<hr />
<pre>
3485      * The {@code pos} argument selects which parameters are to be bound.
3486      * It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
3487      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
3488      * and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
3489      * &lt;p&gt;
3490      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
3491      * variable-arity method handle}, even if the original target method handle was.
3492      * @param target the method handle to invoke after the argument is inserted
3493      * @param pos where to insert the argument (zero for the first)
3494      * @param values the series of arguments to insert
3495      * @return a method handle which inserts an additional argument,
3496      *         before calling the original method handle
3497      * @throws NullPointerException if the target or the {@code values} array is null
3498      * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than
3499      *         {@code N - L} where {@code N} is the arity of the target method handle and {@code L}
3500      *         is the length of the values array.
3501      * @throws ClassCastException if an argument does not match the corresponding bound parameter
3502      *         type.
3503      * @see MethodHandle#bindTo
3504      */
<span class="line-modified">3505     public static</span>
<span class="line-removed">3506     MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {</span>
3507         int insCount = values.length;
3508         Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
3509         if (insCount == 0)  return target;
3510         BoundMethodHandle result = target.rebind();
3511         for (int i = 0; i &lt; insCount; i++) {
3512             Object value = values[i];
3513             Class&lt;?&gt; ptype = ptypes[pos+i];
3514             if (ptype.isPrimitive()) {
3515                 result = insertArgumentPrimitive(result, pos, ptype, value);
3516             } else {
3517                 value = ptype.cast(value);  // throw CCE if needed
3518                 result = result.bindArgumentL(pos, value);
3519             }
3520         }
3521         return result;
3522     }
3523 
3524     private static BoundMethodHandle insertArgumentPrimitive(BoundMethodHandle result, int pos,
3525                                                              Class&lt;?&gt; ptype, Object value) {
3526         Wrapper w = Wrapper.forPrimitiveType(ptype);
</pre>
<hr />
<pre>
3561      * &lt;p&gt;
3562      * &lt;b&gt;Example:&lt;/b&gt;
3563      * &lt;blockquote&gt;&lt;pre&gt;{@code
3564 import static java.lang.invoke.MethodHandles.*;
3565 import static java.lang.invoke.MethodType.*;
3566 ...
3567 MethodHandle cat = lookup().findVirtual(String.class,
3568   &quot;concat&quot;, methodType(String.class, String.class));
3569 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
3570 MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
3571 MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
3572 assertEquals(bigType, d0.type());
3573 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
3574      * }&lt;/pre&gt;&lt;/blockquote&gt;
3575      * &lt;p&gt;
3576      * This method is also equivalent to the following code:
3577      * &lt;blockquote&gt;&lt;pre&gt;
3578      * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
3579      * &lt;/pre&gt;&lt;/blockquote&gt;
3580      * @param target the method handle to invoke after the arguments are dropped
<span class="line-removed">3581      * @param valueTypes the type(s) of the argument(s) to drop</span>
3582      * @param pos position of first argument to drop (zero for the leftmost)

3583      * @return a method handle which drops arguments of the given types,
3584      *         before calling the original method handle
3585      * @throws NullPointerException if the target is null,
3586      *                              or if the {@code valueTypes} list or any of its elements is null
3587      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
3588      *                  or if {@code pos} is negative or greater than the arity of the target,
3589      *                  or if the new method handle&#39;s type would have too many parameters
3590      */
<span class="line-modified">3591     public static</span>
<span class="line-removed">3592     MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
3593         return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
3594     }
3595 
3596     private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
3597         return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
3598     }
3599 
<span class="line-modified">3600     private static</span>
<span class="line-removed">3601     MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
3602         MethodType oldType = target.type();  // get NPE
3603         int dropped = dropArgumentChecks(oldType, pos, valueTypes);
3604         MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
3605         if (dropped == 0)  return target;
3606         BoundMethodHandle result = target.rebind();
3607         LambdaForm lform = result.form;
3608         int insertFormArg = 1 + pos;
3609         for (Class&lt;?&gt; ptype : valueTypes) {
3610             lform = lform.editor().addArgumentForm(insertFormArg++, BasicType.basicType(ptype));
3611         }
3612         result = result.copyWith(newType, lform);
3613         return result;
3614     }
3615 
3616     private static int dropArgumentChecks(MethodType oldType, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
3617         int dropped = valueTypes.size();
3618         MethodType.checkSlotCount(dropped);
3619         int outargs = oldType.parameterCount();
3620         int inargs  = outargs + dropped;
3621         if (pos &lt; 0 || pos &gt; outargs)
</pre>
<hr />
<pre>
3643 import static java.lang.invoke.MethodType.*;
3644 ...
3645 MethodHandle cat = lookup().findVirtual(String.class,
3646   &quot;concat&quot;, methodType(String.class, String.class));
3647 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
3648 MethodHandle d0 = dropArguments(cat, 0, String.class);
3649 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
3650 MethodHandle d1 = dropArguments(cat, 1, String.class);
3651 assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
3652 MethodHandle d2 = dropArguments(cat, 2, String.class);
3653 assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
3654 MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
3655 assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
3656      * }&lt;/pre&gt;&lt;/blockquote&gt;
3657      * &lt;p&gt;
3658      * This method is also equivalent to the following code:
3659      * &lt;blockquote&gt;&lt;pre&gt;
3660      * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
3661      * &lt;/pre&gt;&lt;/blockquote&gt;
3662      * @param target the method handle to invoke after the arguments are dropped
<span class="line-removed">3663      * @param valueTypes the type(s) of the argument(s) to drop</span>
3664      * @param pos position of first argument to drop (zero for the leftmost)

3665      * @return a method handle which drops arguments of the given types,
3666      *         before calling the original method handle
3667      * @throws NullPointerException if the target is null,
3668      *                              or if the {@code valueTypes} array or any of its elements is null
3669      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
3670      *                  or if {@code pos} is negative or greater than the arity of the target,
3671      *                  or if the new method handle&#39;s type would have
3672      *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3673      */
<span class="line-modified">3674     public static</span>
<span class="line-removed">3675     MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
3676         return dropArguments0(target, pos, copyTypes(valueTypes));
3677     }
3678 
3679     // private version which allows caller some freedom with error handling
3680     private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
3681                                       boolean nullOnFailure) {
3682         newTypes = copyTypes(newTypes.toArray());
3683         List&lt;Class&lt;?&gt;&gt; oldTypes = target.type().parameterList();
3684         int match = oldTypes.size();
3685         if (skip != 0) {
3686             if (skip &lt; 0 || skip &gt; match) {
3687                 throw newIllegalArgumentException(&quot;illegal skip&quot;, skip, target);
3688             }
3689             oldTypes = oldTypes.subList(skip, match);
3690             match -= skip;
3691         }
3692         List&lt;Class&lt;?&gt;&gt; addTypes = newTypes;
3693         int add = addTypes.size();
3694         if (pos != 0) {
3695             if (pos &lt; 0 || pos &gt; add) {
</pre>
<hr />
<pre>
3761 if (h1.type().parameterCount() &lt; h2.type().parameterCount())
3762     h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
3763 else
3764     h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
3765 MethodHandle h3 = guardWithTest(h0, h1, h2);
3766 assertEquals(&quot;xy&quot;, h3.invoke(&quot;x&quot;, &quot;y&quot;, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
3767      * }&lt;/pre&gt;&lt;/blockquote&gt;
3768      * @param target the method handle to adapt
3769      * @param skip number of targets parameters to disregard (they will be unchanged)
3770      * @param newTypes the list of types to match {@code target}&#39;s parameter type list to
3771      * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
3772      * @return a possibly adapted method handle
3773      * @throws NullPointerException if either argument is null
3774      * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
3775      *         or if {@code skip} is negative or greater than the arity of the target,
3776      *         or if {@code pos} is negative or greater than the newTypes list size,
3777      *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
3778      *         {@code pos}.
3779      * @since 9
3780      */
<span class="line-modified">3781     public static</span>
<span class="line-removed">3782     MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {</span>
3783         Objects.requireNonNull(target);
3784         Objects.requireNonNull(newTypes);
3785         return dropArgumentsToMatch(target, skip, newTypes, pos, false);
3786     }
3787 
3788     /**
3789      * Adapts a target method handle by pre-processing
3790      * one or more of its arguments, each with its own unary filter function,
3791      * and then calling the target with each pre-processed argument
3792      * replaced by the result of its corresponding filter function.
3793      * &lt;p&gt;
3794      * The pre-processing is performed by one or more method handles,
3795      * specified in the elements of the {@code filters} array.
3796      * The first element of the filter array corresponds to the {@code pos}
3797      * argument of the target, and so on in sequence.
3798      * The filter functions are invoked in left to right order.
3799      * &lt;p&gt;
3800      * Null arguments in the array are treated as identity functions,
3801      * and the corresponding arguments left unchanged.
3802      * (If there are no non-null elements in the array, the original target is returned.)
</pre>
<hr />
<pre>
3845      * T adapter(P... p, V[i]... v[i], B... b) {
3846      *   return target(p..., filter[i](v[i])..., b...);
3847      * }
3848      * }&lt;/pre&gt;&lt;/blockquote&gt;
3849      * &lt;p&gt;
3850      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
3851      * variable-arity method handle}, even if the original target method handle was.
3852      *
3853      * @param target the method handle to invoke after arguments are filtered
3854      * @param pos the position of the first argument to filter
3855      * @param filters method handles to call initially on filtered arguments
3856      * @return method handle which incorporates the specified argument filtering logic
3857      * @throws NullPointerException if the target is null
3858      *                              or if the {@code filters} array is null
3859      * @throws IllegalArgumentException if a non-null element of {@code filters}
3860      *          does not match a corresponding argument type of target as described above,
3861      *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
3862      *          or if the resulting method handle&#39;s type would have
3863      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3864      */
<span class="line-modified">3865     public static</span>
<span class="line-removed">3866     MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {</span>
3867         // In method types arguments start at index 0, while the LF
3868         // editor have the MH receiver at position 0 - adjust appropriately.
3869         final int MH_RECEIVER_OFFSET = 1;
3870         filterArgumentsCheckArity(target, pos, filters);
3871         MethodHandle adapter = target;
3872 
3873         // keep track of currently matched filters, as to optimize repeated filters
3874         int index = 0;
3875         int[] positions = new int[filters.length];
3876         MethodHandle filter = null;
3877 
3878         // process filters in reverse order so that the invocation of
3879         // the resulting adapter will invoke the filters in left-to-right order
3880         for (int i = filters.length - 1; i &gt;= 0; --i) {
3881             MethodHandle newFilter = filters[i];
3882             if (newFilter == null) continue;  // ignore null elements of filters
3883 
3884             // flush changes on update
3885             if (filter != newFilter) {
3886                 if (filter != null) {
</pre>
<hr />
<pre>
3904         }
3905         return adapter;
3906     }
3907 
3908     private static MethodHandle filterRepeatedArgument(MethodHandle adapter, MethodHandle filter, int[] positions) {
3909         MethodType targetType = adapter.type();
3910         MethodType filterType = filter.type();
3911         BoundMethodHandle result = adapter.rebind();
3912         Class&lt;?&gt; newParamType = filterType.parameterType(0);
3913 
3914         Class&lt;?&gt;[] ptypes = targetType.ptypes().clone();
3915         for (int pos : positions) {
3916             ptypes[pos - 1] = newParamType;
3917         }
3918         MethodType newType = MethodType.makeImpl(targetType.rtype(), ptypes, true);
3919 
3920         LambdaForm lform = result.editor().filterRepeatedArgumentForm(BasicType.basicType(newParamType), positions);
3921         return result.copyWithExtendL(newType, lform, filter);
3922     }
3923 
<span class="line-modified">3924     /*non-public*/ static</span>
<span class="line-modified">3925     MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {</span>
3926         filterArgumentChecks(target, pos, filter);
3927         MethodType targetType = target.type();
3928         MethodType filterType = filter.type();
3929         BoundMethodHandle result = target.rebind();
3930         Class&lt;?&gt; newParamType = filterType.parameterType(0);
3931         LambdaForm lform = result.editor().filterArgumentForm(1 + pos, BasicType.basicType(newParamType));
3932         MethodType newType = targetType.changeParameterType(pos, newParamType);
3933         result = result.copyWithExtendL(newType, lform, filter);
3934         return result;
3935     }
3936 
3937     private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters) {
3938         MethodType targetType = target.type();
3939         int maxPos = targetType.parameterCount();
3940         if (pos + filters.length &gt; maxPos)
3941             throw newIllegalArgumentException(&quot;too many filters&quot;);
3942     }
3943 
3944     private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
3945         MethodType targetType = target.type();
</pre>
<hr />
<pre>
4051      * Other equivalences are possible but would require argument permutation.
4052      * &lt;p&gt;
4053      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4054      * variable-arity method handle}, even if the original target method handle was.
4055      *
4056      * @param target the method handle to invoke after filtering the subsequence of arguments
4057      * @param pos the position of the first adapter argument to pass to the filter,
4058      *            and/or the target argument which receives the result of the filter
4059      * @param filter method handle to call on the subsequence of arguments
4060      * @return method handle which incorporates the specified argument subsequence filtering logic
4061      * @throws NullPointerException if either argument is null
4062      * @throws IllegalArgumentException if the return type of {@code filter}
4063      *          is non-void and is not the same as the {@code pos} argument of the target,
4064      *          or if {@code pos} is not between 0 and the target&#39;s arity, inclusive,
4065      *          or if the resulting method handle&#39;s type would have
4066      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4067      * @see MethodHandles#foldArguments
4068      * @see MethodHandles#filterArguments
4069      * @see MethodHandles#filterReturnValue
4070      */
<span class="line-modified">4071     public static</span>
<span class="line-removed">4072     MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {</span>
4073         MethodType newType = collectArgumentsChecks(target, pos, filter);
4074         MethodType collectorType = filter.type();
4075         BoundMethodHandle result = target.rebind();
4076         LambdaForm lform;
4077         if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
4078             lform = result.editor().collectArgumentArrayForm(1 + pos, filter);
4079             if (lform != null) {
4080                 return result.copyWith(newType, lform);
4081             }
4082         }
4083         lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());
4084         return result.copyWithExtendL(newType, lform, filter);
4085     }
4086 
4087     private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
4088         MethodType targetType = target.type();
4089         MethodType filterType = filter.type();
4090         Class&lt;?&gt; rtype = filterType.returnType();
4091         List&lt;Class&lt;?&gt;&gt; filterArgs = filterType.parameterList();
4092         if (rtype == void.class) {
</pre>
<hr />
<pre>
4145      *   return filter2();
4146      * }
4147      * // and if the filter has a void return:
4148      * T target3(A...);
4149      * void filter3(V);
4150      * void adapter3(A... a) {
4151      *   T t = target3(a...);
4152      *   filter3(t);
4153      * }
4154      * }&lt;/pre&gt;&lt;/blockquote&gt;
4155      * &lt;p&gt;
4156      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4157      * variable-arity method handle}, even if the original target method handle was.
4158      * @param target the method handle to invoke before filtering the return value
4159      * @param filter method handle to call on the return value
4160      * @return method handle which incorporates the specified return value filtering logic
4161      * @throws NullPointerException if either argument is null
4162      * @throws IllegalArgumentException if the argument list of {@code filter}
4163      *          does not match the return type of target as described above
4164      */
<span class="line-modified">4165     public static</span>
<span class="line-removed">4166     MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {</span>
4167         MethodType targetType = target.type();
4168         MethodType filterType = filter.type();
4169         filterReturnValueChecks(targetType, filterType);
4170         BoundMethodHandle result = target.rebind();
4171         BasicType rtype = BasicType.basicType(filterType.returnType());
4172         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
4173         MethodType newType = targetType.changeReturnType(filterType.returnType());
4174         result = result.copyWithExtendL(newType, lform, filter);
4175         return result;
4176     }
4177 
4178     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
4179         Class&lt;?&gt; rtype = targetType.returnType();
4180         int filterValues = filterType.parameterCount();
4181         if (filterValues == 0
4182                 ? (rtype != void.class)
4183                 : (rtype != filterType.parameterType(0) || filterValues != 1))
4184             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4185     }
4186 
</pre>
<hr />
<pre>
4254      * void combiner2(A...);
4255      * T adapter2(A... a, B... b) {
4256      *   combiner2(a...);
4257      *   return target2(a..., b...);
4258      * }
4259      * }&lt;/pre&gt;&lt;/blockquote&gt;
4260      * &lt;p&gt;
4261      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4262      * variable-arity method handle}, even if the original target method handle was.
4263      * @param target the method handle to invoke after arguments are combined
4264      * @param combiner method handle to call initially on the incoming arguments
4265      * @return method handle which incorporates the specified argument folding logic
4266      * @throws NullPointerException if either argument is null
4267      * @throws IllegalArgumentException if {@code combiner}&#39;s return type
4268      *          is non-void and not the same as the first argument type of
4269      *          the target, or if the initial {@code N} argument types
4270      *          of the target
4271      *          (skipping one matching the {@code combiner}&#39;s return type)
4272      *          are not identical with the argument types of {@code combiner}
4273      */
<span class="line-modified">4274     public static</span>
<span class="line-removed">4275     MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {</span>
4276         return foldArguments(target, 0, combiner);
4277     }
4278 
4279     /**
4280      * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
4281      * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
4282      * before the folded arguments.
4283      * &lt;p&gt;
4284      * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
4285      * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
4286      * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
4287      * 0.
4288      *
4289      * @apiNote Example:
4290      * &lt;blockquote&gt;&lt;pre&gt;{@code
4291     import static java.lang.invoke.MethodHandles.*;
4292     import static java.lang.invoke.MethodType.*;
4293     ...
4294     MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
4295     &quot;println&quot;, methodType(void.class, String.class))
</pre>
<hr />
<pre>
4382         return rtype;
4383     }
4384 
4385     /**
4386      * Adapts a target method handle by pre-processing some of its arguments, then calling the target with the result
4387      * of the pre-processing replacing the argument at the given position.
4388      *
4389      * @param target the method handle to invoke after arguments are combined
4390      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
4391      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
4392      * @param combiner method handle to call initially on the incoming arguments
4393      * @param argPositions indexes of the target to pick arguments sent to the combiner from
4394      * @return method handle which incorporates the specified argument folding logic
4395      * @throws NullPointerException if either argument is null
4396      * @throws IllegalArgumentException if either of the following two conditions holds:
4397      *          (1) {@code combiner}&#39;s return type is not the same as the argument type at position
4398      *              {@code pos} of the target signature;
4399      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are
4400      *              not identical with the argument types of {@code combiner}.
4401      */
<span class="line-modified">4402     /*non-public*/ static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>

4403         return argumentsWithCombiner(true, target, position, combiner, argPositions);
4404     }
4405 
4406     /**
4407      * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of
4408      * the pre-processing inserted into the original sequence of arguments at the given position.
4409      *
4410      * @param target the method handle to invoke after arguments are combined
4411      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
4412      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
4413      * @param combiner method handle to call initially on the incoming arguments
4414      * @param argPositions indexes of the target to pick arguments sent to the combiner from
4415      * @return method handle which incorporates the specified argument folding logic
4416      * @throws NullPointerException if either argument is null
4417      * @throws IllegalArgumentException if either of the following two conditions holds:
4418      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
4419      *              {@code pos} of the target signature;
4420      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature
4421      *              (skipping {@code position} where the {@code combiner}&#39;s return will be folded in) are not identical
4422      *              with the argument types of {@code combiner}.
4423      */
<span class="line-modified">4424     /*non-public*/ static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>

4425         return argumentsWithCombiner(false, target, position, combiner, argPositions);
4426     }
4427 
4428     private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
4429         MethodType targetType = target.type();
4430         MethodType combinerType = combiner.type();
4431         Class&lt;?&gt; rtype = argumentsWithCombinerChecks(position, filter, targetType, combinerType, argPositions);
4432         BoundMethodHandle result = target.rebind();
4433 
4434         MethodType newType = targetType;
4435         LambdaForm lform;
4436         if (filter) {
4437             lform = result.editor().filterArgumentsForm(1 + position, combinerType.basicType(), argPositions);
4438         } else {
4439             boolean dropResult = rtype == void.class;
4440             lform = result.editor().foldArgumentsForm(1 + position, dropResult, combinerType.basicType(), argPositions);
4441             if (!dropResult) {
4442                 newType = newType.dropParameterTypes(position, position + 1);
4443             }
4444         }
</pre>
<hr />
<pre>
4491      * T fallback(A...,B...);
4492      * T adapter(A... a,B... b) {
4493      *   if (test(a...))
4494      *     return target(a..., b...);
4495      *   else
4496      *     return fallback(a..., b...);
4497      * }
4498      * }&lt;/pre&gt;&lt;/blockquote&gt;
4499      * Note that the test arguments ({@code a...} in the pseudocode) cannot
4500      * be modified by execution of the test, and so are passed unchanged
4501      * from the caller to the target or fallback as appropriate.
4502      * @param test method handle used for test, must return boolean
4503      * @param target method handle to call if test passes
4504      * @param fallback method handle to call if test fails
4505      * @return method handle which incorporates the specified if/then/else logic
4506      * @throws NullPointerException if any argument is null
4507      * @throws IllegalArgumentException if {@code test} does not return boolean,
4508      *          or if all three method types do not match (with the return
4509      *          type of {@code test} changed to match that of the target).
4510      */
<span class="line-modified">4511     public static</span>
<span class="line-removed">4512     MethodHandle guardWithTest(MethodHandle test,</span>
4513                                MethodHandle target,
4514                                MethodHandle fallback) {
4515         MethodType gtype = test.type();
4516         MethodType ttype = target.type();
4517         MethodType ftype = fallback.type();
4518         if (!ttype.equals(ftype))
4519             throw misMatchedTypes(&quot;target and fallback types&quot;, ttype, ftype);
4520         if (gtype.returnType() != boolean.class)
4521             throw newIllegalArgumentException(&quot;guard type is not a predicate &quot;+gtype);
4522         List&lt;Class&lt;?&gt;&gt; targs = ttype.parameterList();
4523         test = dropArgumentsToMatch(test, 0, targs, 0, true);
4524         if (test == null) {
4525             throw misMatchedTypes(&quot;target and test types&quot;, ttype, gtype);
4526         }
4527         return MethodHandleImpl.makeGuardWithTest(test, target, fallback);
4528     }
4529 
4530     static &lt;T&gt; RuntimeException misMatchedTypes(String what, T t1, T t2) {
4531         return newIllegalArgumentException(what + &quot; must match: &quot; + t1 + &quot; != &quot; + t2);
4532     }
</pre>
<hr />
<pre>
4564      * be modified by execution of the target, and so are passed unchanged
4565      * from the caller to the handler, if the handler is invoked.
4566      * &lt;p&gt;
4567      * The target and handler must return the same type, even if the handler
4568      * always throws.  (This might happen, for instance, because the handler
4569      * is simulating a {@code finally} clause).
4570      * To create such a throwing handler, compose the handler creation logic
4571      * with {@link #throwException throwException},
4572      * in order to create a method handle of the correct return type.
4573      * @param target method handle to call
4574      * @param exType the type of exception which the handler will catch
4575      * @param handler method handle to call if a matching exception is thrown
4576      * @return method handle which incorporates the specified try/catch logic
4577      * @throws NullPointerException if any argument is null
4578      * @throws IllegalArgumentException if {@code handler} does not accept
4579      *          the given exception type, or if the method handle types do
4580      *          not match in their return types and their
4581      *          corresponding parameters
4582      * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
4583      */
<span class="line-modified">4584     public static</span>
<span class="line-removed">4585     MethodHandle catchException(MethodHandle target,</span>
4586                                 Class&lt;? extends Throwable&gt; exType,
4587                                 MethodHandle handler) {
4588         MethodType ttype = target.type();
4589         MethodType htype = handler.type();
4590         if (!Throwable.class.isAssignableFrom(exType))
4591             throw new ClassCastException(exType.getName());
4592         if (htype.parameterCount() &lt; 1 ||
4593             !htype.parameterType(0).isAssignableFrom(exType))
4594             throw newIllegalArgumentException(&quot;handler does not accept exception type &quot;+exType);
4595         if (htype.returnType() != ttype.returnType())
4596             throw misMatchedTypes(&quot;target and handler return types&quot;, ttype, htype);
4597         handler = dropArgumentsToMatch(handler, 1, ttype.parameterList(), 0, true);
4598         if (handler == null) {
4599             throw misMatchedTypes(&quot;target and handler types&quot;, ttype, htype);
4600         }
4601         return MethodHandleImpl.makeGuardWithCatch(target, exType, handler);
4602     }
4603 
4604     /**
4605      * Produces a method handle which will throw exceptions of the given {@code exType}.
4606      * The method handle will accept a single argument of {@code exType},
4607      * and immediately throw it as an exception.
4608      * The method type will nominally specify a return of {@code returnType}.
4609      * The return type may be anything convenient:  It doesn&#39;t matter to the
4610      * method handle&#39;s behavior, since it will never return normally.
4611      * @param returnType the return type of the desired method handle
4612      * @param exType the parameter type of the desired method handle
4613      * @return method handle which can throw the given exceptions
4614      * @throws NullPointerException if either argument is null
4615      */
<span class="line-modified">4616     public static</span>
<span class="line-removed">4617     MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {</span>
4618         if (!Throwable.class.isAssignableFrom(exType))
4619             throw new ClassCastException(exType.getName());
4620         return MethodHandleImpl.throwException(methodType(returnType, exType));
4621     }
4622 
4623     /**
4624      * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
4625      * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
4626      * delivers the loop&#39;s result, which is the return value of the resulting handle.
4627      * &lt;p&gt;
4628      * Intuitively, every loop is formed by one or more &quot;clauses&quot;, each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
4629      * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
4630      * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
4631      * terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
4632      * &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.
4633      * &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable {@code v}.
4634      * &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
4635      * &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop&#39;s return value.
4636      * &lt;/ul&gt;
4637      * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.
</pre>
<hr />
<pre>
4944             MethodHandle in = init.get(i);
4945             MethodHandle st = step.get(i);
4946             if (in == null &amp;&amp; st == null) {
4947                 iterationVariableTypes.add(void.class);
4948             } else if (in != null &amp;&amp; st != null) {
4949                 loopChecks1a(i, in, st);
4950                 iterationVariableTypes.add(in.type().returnType());
4951             } else {
4952                 iterationVariableTypes.add(in == null ? st.type().returnType() : in.type().returnType());
4953             }
4954         }
4955         final List&lt;Class&lt;?&gt;&gt; commonPrefix = iterationVariableTypes.stream().filter(t -&gt; t != void.class).
4956                 collect(Collectors.toList());
4957 
4958         // Step 1B: determine loop parameters (A...).
4959         final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
4960         loopChecks1b(init, commonSuffix);
4961 
4962         // Step 1C: determine loop return type.
4963         // Step 1D: check other types.
<span class="line-modified">4964         final Class&lt;?&gt; loopReturnType = fini.stream().filter(Objects::nonNull).map(MethodHandle::type).</span>
<span class="line-modified">4965                 map(MethodType::returnType).findFirst().orElse(void.class);</span>


4966         loopChecks1cd(pred, fini, loopReturnType);
4967 
4968         // Step 2: determine parameter lists.
4969         final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
4970         commonParameterSequence.addAll(commonSuffix);
4971         loopChecks2(step, pred, fini, commonParameterSequence);
4972 
4973         // Step 3: fill in omitted functions.
4974         for (int i = 0; i &lt; nclauses; ++i) {
4975             Class&lt;?&gt; t = iterationVariableTypes.get(i);
4976             if (init.get(i) == null) {
4977                 init.set(i, empty(methodType(t, commonSuffix)));
4978             }
4979             if (step.get(i) == null) {
4980                 step.set(i, dropArgumentsToMatch(identityOrVoid(t), 0, commonParameterSequence, i));
4981             }
4982             if (pred.get(i) == null) {
4983                 pred.set(i, dropArguments0(constant(boolean.class, true), 0, commonParameterSequence));
4984             }
4985             if (fini.get(i) == null) {
</pre>
<hr />
<pre>
5903                 // special case; if the iterator handle is null and the external
5904                 // parameter list is not empty then the first parameter must be
5905                 // assignable to Iterable
5906                 iterableType = externalParamList.get(0);
5907                 if (!Iterable.class.isAssignableFrom(iterableType)) {
5908                     throw newIllegalArgumentException(
5909                             &quot;inferred first loop argument must inherit from Iterable: &quot; + iterableType);
5910                 }
5911             }
5912         }
5913         if (init != null) {
5914             MethodType initType = init.type();
5915             if (initType.returnType() != returnType ||
5916                     !initType.effectivelyIdenticalParameters(0, externalParamList)) {
5917                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, externalParamList));
5918             }
5919         }
5920         return iterableType;  // help the caller a bit
5921     }
5922 
<span class="line-modified">5923     /*non-public*/ static MethodHandle swapArguments(MethodHandle mh, int i, int j) {</span>

5924         // there should be a better way to uncross my wires
5925         int arity = mh.type().parameterCount();
5926         int[] order = new int[arity];
5927         for (int k = 0; k &lt; arity; k++)  order[k] = k;
5928         order[i] = j; order[j] = i;
5929         Class&lt;?&gt;[] types = mh.type().parameterArray();
5930         Class&lt;?&gt; ti = types[i]; types[i] = types[j]; types[j] = ti;
5931         MethodType swapType = methodType(mh.type().returnType(), types);
5932         return permuteArguments(mh, swapType, order);
5933     }
5934 
5935     /**
5936      * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
5937      * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
5938      * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
5939      * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
5940      * value returned from the {@code cleanup} handle&#39;s execution will be the result of the execution of the
5941      * {@code try-finally} handle.
5942      * &lt;p&gt;
5943      * The {@code cleanup} handle will be passed one or two additional leading arguments.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  75  * A lookup, combinator, or factory method will fail and throw an
  76  * {@code IllegalArgumentException} if the created method handle&#39;s type
  77  * would have &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;.
  78  *
  79  * @author John Rose, JSR 292 EG
  80  * @since 1.7
  81  */
  82 public class MethodHandles {
  83 
  84     private MethodHandles() { }  // do not instantiate
  85 
  86     static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
  87 
  88     // See IMPL_LOOKUP below.
  89 
  90     //// Method handle creation from ordinary methods.
  91 
  92     /**
  93      * Returns a {@link Lookup lookup object} with
  94      * full capabilities to emulate all supported bytecode behaviors of the caller.
<span class="line-modified">  95      * These capabilities include {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} to the caller.</span>
  96      * Factory methods on the lookup object can create
  97      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
  98      * for any member that the caller has access to via bytecodes,
  99      * including protected and private fields and methods.
 100      * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
 101      * Do not store it in place where untrusted code can access it.
 102      * &lt;p&gt;
 103      * This method is caller sensitive, which means that it may return different
 104      * values to different callers.
<span class="line-modified"> 105      * @return a lookup object for the caller of this method, with</span>
<span class="line-added"> 106      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}</span>
 107      */
 108     @CallerSensitive
 109     @ForceInline // to ensure Reflection.getCallerClass optimization
 110     public static Lookup lookup() {
 111         return new Lookup(Reflection.getCallerClass());
 112     }
 113 
 114     /**
 115      * This reflected$lookup method is the alternate implementation of
 116      * the lookup method when being invoked by reflection.
 117      */
 118     @CallerSensitive
 119     private static Lookup reflected$lookup() {
 120         Class&lt;?&gt; caller = Reflection.getCallerClass();
 121         if (caller.getClassLoader() == null) {
 122             throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+caller);
 123         }
 124         return new Lookup(caller);
 125     }
 126 
 127     /**
 128      * Returns a {@link Lookup lookup object} which is trusted minimally.
<span class="line-modified"> 129      * The lookup has the {@code UNCONDITIONAL} mode.</span>
 130      * It can only be used to create method handles to public members of
 131      * public classes in packages that are exported unconditionally.
 132      * &lt;p&gt;
 133      * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
 134      * of this lookup object will be {@link java.lang.Object}.
 135      *
 136      * @apiNote The use of Object is conventional, and because the lookup modes are
 137      * limited, there is no special access provided to the internals of Object, its package
<span class="line-modified"> 138      * or its module.  This public lookup object or other lookup object with</span>
<span class="line-modified"> 139      * {@code UNCONDITIONAL} mode assumes readability. Consequently, the lookup class</span>
<span class="line-added"> 140      * is not used to determine the lookup context.</span>
 141      *
 142      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 143      * &lt;em&gt;Discussion:&lt;/em&gt;
 144      * The lookup class can be changed to any other class {@code C} using an expression of the form
 145      * {@link Lookup#in publicLookup().in(C.class)}.

 146      * A public lookup object is always subject to
 147      * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
 148      * Also, it cannot access
 149      * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
 150      * @return a lookup object which is trusted minimally
 151      *
 152      * @revised 9
 153      * @spec JPMS
 154      */
 155     public static Lookup publicLookup() {
 156         return Lookup.PUBLIC_LOOKUP;
 157     }
 158 
 159     /**
<span class="line-modified"> 160      * Returns a {@link Lookup lookup} object on a target class to emulate all supported</span>
<span class="line-modified"> 161      * bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
<span class="line-modified"> 162      * The returned lookup object can provide access to classes in modules and packages,</span>
<span class="line-modified"> 163      * and members of those classes, outside the normal rules of Java access control,</span>
<span class="line-modified"> 164      * instead conforming to the more permissive rules for modular &lt;em&gt;deep reflection&lt;/em&gt;.</span>
<span class="line-modified"> 165      * &lt;p&gt;</span>
<span class="line-modified"> 166      * A caller, specified as a {@code Lookup} object, in module {@code M1} is</span>
<span class="line-added"> 167      * allowed to do deep reflection on module {@code M2} and package of the target class</span>
<span class="line-added"> 168      * if and only if all of the following conditions are {@code true}:</span>
 169      * &lt;ul&gt;
<span class="line-modified"> 170      * &lt;li&gt;If there is a security manager, its {@code checkPermission} method is</span>
<span class="line-modified"> 171      * called to check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} and</span>
<span class="line-modified"> 172      * that must return normally.</span>
<span class="line-modified"> 173      * &lt;li&gt;The caller lookup object must have {@linkplain Lookup#hasFullPrivilegeAccess()</span>
<span class="line-added"> 174      * full privilege access}.  Specifically:</span>
<span class="line-added"> 175      *   &lt;ul&gt;</span>
<span class="line-added"> 176      *     &lt;li&gt;The caller lookup object must have the {@link Lookup#MODULE MODULE} lookup mode.</span>
<span class="line-added"> 177      *         (This is because otherwise there would be no way to ensure the original lookup</span>
<span class="line-added"> 178      *         creator was a member of any particular module, and so any subsequent checks</span>
<span class="line-added"> 179      *         for readability and qualified exports would become ineffective.)</span>
<span class="line-added"> 180      *     &lt;li&gt;The caller lookup object must have {@link Lookup#PRIVATE PRIVATE} access.</span>
<span class="line-added"> 181      *         (This is because an application intending to share intra-module access</span>
<span class="line-added"> 182      *         using {@link Lookup#MODULE MODULE} alone will inadvertently also share</span>
<span class="line-added"> 183      *         deep reflection to its own module.)</span>
<span class="line-added"> 184      *   &lt;/ul&gt;</span>
<span class="line-added"> 185      * &lt;li&gt;The target class must be a proper class, not a primitive or array class.</span>
<span class="line-added"> 186      * (Thus, {@code M2} is well-defined.)</span>
<span class="line-added"> 187      * &lt;li&gt;If the caller module {@code M1} differs from</span>
<span class="line-added"> 188      * the target module {@code M2} then both of the following must be true:</span>
<span class="line-added"> 189      *   &lt;ul&gt;</span>
<span class="line-added"> 190      *     &lt;li&gt;{@code M1} {@link Module#canRead reads} {@code M2}.&lt;/li&gt;</span>
<span class="line-added"> 191      *     &lt;li&gt;{@code M2} {@link Module#isOpen(String,Module) opens} the package</span>
<span class="line-added"> 192      *         containing the target class to at least {@code M1}.&lt;/li&gt;</span>
<span class="line-added"> 193      *   &lt;/ul&gt;</span>
 194      * &lt;/ul&gt;
 195      * &lt;p&gt;
<span class="line-modified"> 196      * If any of the above checks is violated, this method fails with an</span>
<span class="line-modified"> 197      * exception.</span>
<span class="line-modified"> 198      * &lt;p&gt;</span>
<span class="line-modified"> 199      * Otherwise, if {@code M1} and {@code M2} are the same module, this method</span>
<span class="line-modified"> 200      * returns a {@code Lookup} on {@code targetClass} with</span>
<span class="line-modified"> 201      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and</span>
<span class="line-modified"> 202      * {@code null} previous lookup class.</span>
<span class="line-added"> 203      * &lt;p&gt;</span>
<span class="line-added"> 204      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method</span>
<span class="line-added"> 205      * returns a {@code Lookup} on {@code targetClass} that records</span>
<span class="line-added"> 206      * the lookup class of the caller as the new previous lookup class and</span>
<span class="line-added"> 207      * drops {@code MODULE} access from the full privilege access.</span>
<span class="line-added"> 208      *</span>
 209      * @param targetClass the target class
<span class="line-modified"> 210      * @param caller the caller lookup object</span>
 211      * @return a lookup object for the target class, with private access
<span class="line-modified"> 212      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class</span>
 213      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}

 214      * @throws SecurityException if denied by the security manager
<span class="line-added"> 215      * @throws IllegalAccessException if any of the other access checks specified above fails</span>
 216      * @since 9
 217      * @spec JPMS
 218      * @see Lookup#dropLookupMode
<span class="line-added"> 219      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
 220      */
<span class="line-modified"> 221     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {</span>
 222         SecurityManager sm = System.getSecurityManager();
 223         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 224         if (targetClass.isPrimitive())
 225             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 226         if (targetClass.isArray())
 227             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
<span class="line-modified"> 228         // Ensure that we can reason accurately about private and module access.</span>
<span class="line-modified"> 229         if (!caller.hasFullPrivilegeAccess())</span>
<span class="line-modified"> 230             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);</span>
<span class="line-modified"> 231 </span>
<span class="line-modified"> 232         // previous lookup class is never set if it has MODULE access</span>
<span class="line-modified"> 233         assert caller.previousLookupClass() == null;</span>
<span class="line-modified"> 234 </span>
<span class="line-modified"> 235         Class&lt;?&gt; callerClass = caller.lookupClass();</span>
<span class="line-modified"> 236         Module callerModule = callerClass.getModule();  // M1</span>
<span class="line-modified"> 237         Module targetModule = targetClass.getModule();  // M2</span>
<span class="line-modified"> 238         Class&lt;?&gt; newPreviousClass = null;</span>
<span class="line-modified"> 239         int newModes = Lookup.FULL_POWER_MODES;</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241         if (targetModule != callerModule) {</span>
<span class="line-added"> 242             if (!callerModule.canRead(targetModule))</span>
<span class="line-added"> 243                 throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);</span>
<span class="line-added"> 244             if (targetModule.isNamed()) {</span>
<span class="line-added"> 245                 String pn = targetClass.getPackageName();</span>
<span class="line-added"> 246                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;</span>
<span class="line-added"> 247                 if (!targetModule.isOpen(pn, callerModule))</span>
<span class="line-added"> 248                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);</span>
<span class="line-added"> 249             }</span>
<span class="line-added"> 250 </span>
<span class="line-added"> 251             // M2 != M1, set previous lookup class to M1 and drop MODULE access</span>
<span class="line-added"> 252             newPreviousClass = callerClass;</span>
<span class="line-added"> 253             newModes &amp;= ~Lookup.MODULE;</span>
<span class="line-added"> 254         }</span>
<span class="line-added"> 255 </span>
 256         if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 257             IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 258             if (logger != null) {
<span class="line-modified"> 259                 logger.logIfOpenedForIllegalAccess(caller, targetClass);</span>
 260             }
 261         }
<span class="line-modified"> 262         return Lookup.newLookup(targetClass, newPreviousClass, newModes);</span>
 263     }
 264 
 265     /**
 266      * Performs an unchecked &quot;crack&quot; of a
 267      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 268      * The result is as if the user had obtained a lookup object capable enough
 269      * to crack the target method handle, called
 270      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 271      * on the target to obtain its symbolic reference, and then called
 272      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 273      * to resolve the symbolic reference to a member.
 274      * &lt;p&gt;
 275      * If there is a security manager, its {@code checkPermission} method
 276      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 277      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 278      * @param target a direct method handle to crack into symbolic reference components
 279      * @param expected a class object representing the desired result type {@code T}
 280      * @return a reference to the method, constructor, or field object
<span class="line-modified"> 281      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}</span>
<span class="line-modified"> 282      * @throws    NullPointerException if either argument is {@code null}</span>
<span class="line-modified"> 283      * @throws    IllegalArgumentException if the target is not a direct method handle</span>
<span class="line-modified"> 284      * @throws    ClassCastException if the member is not of the expected type</span>
 285      * @since 1.8
 286      */
<span class="line-modified"> 287     public static &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, MethodHandle target) {</span>

 288         SecurityManager smgr = System.getSecurityManager();
 289         if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
 290         Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
 291         return lookup.revealDirect(target).reflectAs(expected, lookup);
 292     }
 293     // Copied from AccessibleObject, as used by Method.setAccessible, etc.:
 294     private static final java.security.Permission ACCESS_PERMISSION =
 295         new ReflectPermission(&quot;suppressAccessChecks&quot;);
 296 
 297     /**
 298      * A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
 299      * when the creation requires access checking.
 300      * Method handles do not perform
 301      * access checks when they are called, but rather when they are created.
 302      * Therefore, method handle access
 303      * restrictions must be enforced when a method handle is created.
 304      * The caller class against which those restrictions are enforced
 305      * is known as the {@linkplain #lookupClass() lookup class}.
 306      * &lt;p&gt;
 307      * A lookup class which needs to create method handles will call
 308      * {@link MethodHandles#lookup() MethodHandles.lookup} to create a factory for itself.
 309      * When the {@code Lookup} factory object is created, the identity of the lookup class is
 310      * determined, and securely stored in the {@code Lookup} object.
 311      * The lookup class (or its delegates) may then use factory methods
 312      * on the {@code Lookup} object to create method handles for access-checked members.
 313      * This includes all methods, constructors, and fields which are allowed to the lookup class,
 314      * even private ones.
 315      *
<span class="line-modified"> 316      * &lt;h2&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h2&gt;</span>
 317      * The factory methods on a {@code Lookup} object correspond to all major
 318      * use cases for methods, constructors, and fields.
 319      * Each method handle created by a factory method is the functional
 320      * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
<span class="line-modified"> 321      * (Bytecode behaviors are described in section {@jvms 5.4.3.5} of</span>
<span class="line-added"> 322      * the Java Virtual Machine Specification.)</span>
 323      * Here is a summary of the correspondence between these factory methods and
 324      * the behavior of the resulting method handles:
 325      * &lt;table class=&quot;striped&quot;&gt;
 326      * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
 327      * &lt;thead&gt;
 328      * &lt;tr&gt;
 329      *     &lt;th scope=&quot;col&quot;&gt;&lt;a id=&quot;equiv&quot;&gt;&lt;/a&gt;lookup expression&lt;/th&gt;
 330      *     &lt;th scope=&quot;col&quot;&gt;member&lt;/th&gt;
 331      *     &lt;th scope=&quot;col&quot;&gt;bytecode behavior&lt;/th&gt;
 332      * &lt;/tr&gt;
 333      * &lt;/thead&gt;
 334      * &lt;tbody&gt;
 335      * &lt;tr&gt;
 336      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 337      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
 338      * &lt;/tr&gt;
 339      * &lt;tr&gt;
 340      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<span class="line-modified"> 341      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) C.f;}&lt;/td&gt;</span>
 342      * &lt;/tr&gt;
 343      * &lt;tr&gt;
 344      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 345      *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
 346      * &lt;/tr&gt;
 347      * &lt;tr&gt;
 348      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
 349      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code C.f = arg;}&lt;/td&gt;
 350      * &lt;/tr&gt;
 351      * &lt;tr&gt;
 352      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 353      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) this.m(arg*);}&lt;/td&gt;
 354      * &lt;/tr&gt;
 355      * &lt;tr&gt;
 356      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
 357      *     &lt;td&gt;{@code static}&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) C.m(arg*);}&lt;/td&gt;
 358      * &lt;/tr&gt;
 359      * &lt;tr&gt;
 360      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/th&gt;
 361      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
</pre>
<hr />
<pre>
 364      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/th&gt;
 365      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code new C(arg*);}&lt;/td&gt;
 366      * &lt;/tr&gt;
 367      * &lt;tr&gt;
 368      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/th&gt;
 369      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) aField.get(thisOrNull);}&lt;/td&gt;
 370      * &lt;/tr&gt;
 371      * &lt;tr&gt;
 372      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/th&gt;
 373      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code aField.set(thisOrNull, arg);}&lt;/td&gt;
 374      * &lt;/tr&gt;
 375      * &lt;tr&gt;
 376      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
 377      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
 378      * &lt;/tr&gt;
 379      * &lt;tr&gt;
 380      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
 381      *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
 382      * &lt;/tr&gt;
 383      * &lt;tr&gt;
<span class="line-modified"> 384      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSpecial lookup.unreflectSpecial(aMethod,this.class)}&lt;/th&gt;</span>
<span class="line-modified"> 385      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;</span>
 386      * &lt;/tr&gt;
 387      * &lt;tr&gt;
 388      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
 389      *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
 390      * &lt;/tr&gt;
 391      * &lt;/tbody&gt;
 392      * &lt;/table&gt;
 393      *
 394      * Here, the type {@code C} is the class or interface being searched for a member,
 395      * documented as a parameter named {@code refc} in the lookup methods.
 396      * The method type {@code MT} is composed from the return type {@code T}
 397      * and the sequence of argument types {@code A*}.
 398      * The constructor also has a sequence of argument types {@code A*} and
 399      * is deemed to return the newly-created object of type {@code C}.
 400      * Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
 401      * The formal parameter {@code this} stands for the self-reference of type {@code C};
 402      * if it is present, it is always the leading argument to the method handle invocation.
 403      * (In the case of some {@code protected} members, {@code this} may be
 404      * restricted in type to the lookup class; see below.)
 405      * The name {@code arg} stands for all the other method handle arguments.
 406      * In the code examples for the Core Reflection API, the name {@code thisOrNull}
 407      * stands for a null reference if the accessed method or field is static,
 408      * and {@code this} otherwise.
 409      * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
<span class="line-modified"> 410      * for reflective objects corresponding to the given members declared in type {@code C}.</span>
 411      * &lt;p&gt;
 412      * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
 413      * as if by {@code ldc CONSTANT_Class}.
 414      * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
 415      * &lt;p&gt;
 416      * In cases where the given member is of variable arity (i.e., a method or constructor)
 417      * the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
 418      * In all other cases, the returned method handle will be of fixed arity.
 419      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 420      * &lt;em&gt;Discussion:&lt;/em&gt;
 421      * The equivalence between looked-up method handles and underlying
 422      * class members and bytecode behaviors
 423      * can break down in a few ways:
 424      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 425      * &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&#39;s loader,
 426      * the lookup can still succeed, even when there is no equivalent
 427      * Java expression or bytecoded constant.
 428      * &lt;li&gt;Likewise, if {@code T} or {@code MT}
 429      * is not symbolically accessible from the lookup class&#39;s loader,
 430      * the lookup can still succeed.
 431      * For example, lookups for {@code MethodHandle.invokeExact} and
 432      * {@code MethodHandle.invoke} will always succeed, regardless of requested type.
 433      * &lt;li&gt;If there is a security manager installed, it can forbid the lookup
 434      * on various grounds (&lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;see below&lt;/a&gt;).
 435      * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}
 436      * constant is not subject to security manager checks.
 437      * &lt;li&gt;If the looked-up method has a
 438      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;very large arity&lt;/a&gt;,
 439      * the method handle creation may fail with an
 440      * {@code IllegalArgumentException}, due to the method handle type having
 441      * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters.&lt;/a&gt;
 442      * &lt;/ul&gt;
 443      *
<span class="line-modified"> 444      * &lt;h2&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h2&gt;</span>
 445      * Access checks are applied in the factory methods of {@code Lookup},
 446      * when a method handle is created.
 447      * This is a key difference from the Core Reflection API, since
 448      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
 449      * performs access checking against every caller, on every call.
 450      * &lt;p&gt;
 451      * All access checks start from a {@code Lookup} object, which
 452      * compares its recorded lookup class against all requests to
 453      * create method handles.
 454      * A single {@code Lookup} object can be used to create any number
 455      * of access-checked method handles, all checked against a single
 456      * lookup class.
 457      * &lt;p&gt;
 458      * A {@code Lookup} object can be shared with other trusted code,
 459      * such as a metaobject protocol.
 460      * A shared {@code Lookup} object delegates the capability
 461      * to create method handles on private members of the lookup class.
 462      * Even if privileged code uses the {@code Lookup} object,
 463      * the access checking is confined to the privileges of the
 464      * original lookup class.
 465      * &lt;p&gt;
 466      * A lookup can fail, because
 467      * the containing class is not accessible to the lookup class, or
 468      * because the desired class member is missing, or because the
 469      * desired class member is not accessible to the lookup class, or
 470      * because the lookup object is not trusted enough to access the member.
<span class="line-added"> 471      * In the case of a field setter function on a {@code final} field,</span>
<span class="line-added"> 472      * finality enforcement is treated as a kind of access control,</span>
<span class="line-added"> 473      * and the lookup will fail, except in special cases of</span>
<span class="line-added"> 474      * {@link Lookup#unreflectSetter Lookup.unreflectSetter}.</span>
 475      * In any of these cases, a {@code ReflectiveOperationException} will be
 476      * thrown from the attempted lookup.  The exact class will be one of
 477      * the following:
 478      * &lt;ul&gt;
 479      * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
 480      * &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
 481      * &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
 482      * &lt;/ul&gt;
 483      * &lt;p&gt;
 484      * In general, the conditions under which a method handle may be
 485      * looked up for a method {@code M} are no more restrictive than the conditions
 486      * under which the lookup class could have compiled, verified, and resolved a call to {@code M}.
 487      * Where the JVM would raise exceptions like {@code NoSuchMethodError},
 488      * a method handle lookup will generally raise a corresponding
 489      * checked exception, such as {@code NoSuchMethodException}.
 490      * And the effect of invoking the method handle resulting from the lookup
 491      * is &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;exactly equivalent&lt;/a&gt;
 492      * to executing the compiled, verified, and resolved call to {@code M}.
 493      * The same point is true of fields and constructors.
 494      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 495      * &lt;em&gt;Discussion:&lt;/em&gt;
 496      * Access checks only apply to named and reflected methods,
 497      * constructors, and fields.
 498      * Other method handle creation methods, such as
 499      * {@link MethodHandle#asType MethodHandle.asType},
 500      * do not require any access checks, and are used
 501      * independently of any {@code Lookup} object.
 502      * &lt;p&gt;
 503      * If the desired member is {@code protected}, the usual JVM rules apply,
 504      * including the requirement that the lookup class must either be in the
 505      * same package as the desired member, or must inherit that member.
<span class="line-modified"> 506      * (See the Java Virtual Machine Specification, sections {@jvms</span>
<span class="line-added"> 507      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)</span>
 508      * In addition, if the desired member is a non-static field or method
 509      * in a different package, the resulting method handle may only be applied
 510      * to objects of the lookup class or one of its subclasses.
 511      * This requirement is enforced by narrowing the type of the leading
 512      * {@code this} parameter from {@code C}
 513      * (which will necessarily be a superclass of the lookup class)
 514      * to the lookup class itself.
 515      * &lt;p&gt;
 516      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 517      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 518      * the current class.  Again, this requirement is enforced by narrowing the
 519      * type of the leading parameter to the resulting method handle.
<span class="line-modified"> 520      * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)</span>
 521      * &lt;p&gt;
 522      * The JVM represents constructors and static initializer blocks as internal methods
 523      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 524      * The internal syntax of invocation instructions allows them to refer to such internal
 525      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 526      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 527      * &lt;p&gt;
 528      * If the relationship between nested types is expressed directly through the
 529      * {@code NestHost} and {@code NestMembers} attributes
<span class="line-modified"> 530      * (see the Java Virtual Machine Specification, sections {@jvms</span>
<span class="line-added"> 531      * 4.7.28} and {@jvms 4.7.29}),</span>
 532      * then the associated {@code Lookup} object provides direct access to
 533      * the lookup class and all of its nestmates
 534      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 535      * Otherwise, access between nested classes is obtained by the Java compiler creating
 536      * a wrapper method to access a private method of another class in the same nest.
 537      * For example, a nested class {@code C.D}
 538      * can access private members within other related classes such as
 539      * {@code C}, {@code C.D.E}, or {@code C.B},
 540      * but the Java compiler may need to generate wrapper methods in
 541      * those related classes.  In such cases, a {@code Lookup} object on
 542      * {@code C.E} would be unable to access those private members.
 543      * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
 544      * which can transform a lookup on {@code C.E} into one on any of those other
 545      * classes, without special elevation of privilege.
 546      * &lt;p&gt;
 547      * The accesses permitted to a given lookup object may be limited,
 548      * according to its set of {@link #lookupModes lookupModes},
 549      * to a subset of members normally accessible to the lookup class.
 550      * For example, the {@link MethodHandles#publicLookup publicLookup}
 551      * method produces a lookup object which is only allowed to access
 552      * public members in public classes of exported packages.
 553      * The caller sensitive method {@link MethodHandles#lookup lookup}
 554      * produces a lookup object with full capabilities relative to
 555      * its caller class, to emulate all supported bytecode behaviors.
 556      * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
 557      * with fewer access modes than the original lookup object.
 558      *
 559      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 560      * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
<span class="line-modified"> 561      * &lt;em&gt;Discussion of private and module access:&lt;/em&gt;</span>
 562      * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
 563      * if its {@linkplain #lookupModes lookup modes}
 564      * include the possibility of accessing {@code private} members
 565      * (which includes the private members of nestmates).
 566      * As documented in the relevant methods elsewhere,
 567      * only lookups with private access possess the following capabilities:
 568      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
 569      * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates


 570      * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
 571      * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
 572      *     for classes accessible to the lookup class
 573      * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
 574      *     within the same package member
 575      * &lt;/ul&gt;
 576      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<span class="line-added"> 577      * Similarly, a lookup with module access ensures that the original lookup creator was</span>
<span class="line-added"> 578      * a member in the same module as the lookup class.</span>
<span class="line-added"> 579      * &lt;p style=&quot;font-size:smaller;&quot;&gt;</span>
<span class="line-added"> 580      * Private and module access are independently determined modes; a lookup may have</span>
<span class="line-added"> 581      * either or both or neither.  A lookup which possesses both access modes is said to</span>
<span class="line-added"> 582      * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has</span>
<span class="line-added"> 583      * the following additional capability:</span>
<span class="line-added"> 584      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;</span>
<span class="line-added"> 585      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,</span>
<span class="line-added"> 586      *     such as {@code Class.forName}</span>
<span class="line-added"> 587      * &lt;/ul&gt;</span>
<span class="line-added"> 588      * &lt;p style=&quot;font-size:smaller;&quot;&gt;</span>
 589      * Each of these permissions is a consequence of the fact that a lookup object
 590      * with private access can be securely traced back to an originating class,
 591      * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
 592      * can be reliably determined and emulated by method handles.
 593      *
<span class="line-modified"> 594      * &lt;h2&gt;&lt;a id=&quot;cross-module-lookup&quot;&gt;&lt;/a&gt;Cross-module lookups&lt;/h2&gt;</span>
<span class="line-added"> 595      * When a lookup class in one module {@code M1} accesses a class in another module</span>
<span class="line-added"> 596      * {@code M2}, extra access checking is performed beyond the access mode bits.</span>
<span class="line-added"> 597      * A {@code Lookup} with {@link #PUBLIC} mode and a lookup class in {@code M1}</span>
<span class="line-added"> 598      * can access public types in {@code M2} when {@code M2} is readable to {@code M1}</span>
<span class="line-added"> 599      * and when the type is in a package of {@code M2} that is exported to</span>
<span class="line-added"> 600      * at least {@code M1}.</span>
<span class="line-added"> 601      * &lt;p&gt;</span>
<span class="line-added"> 602      * A {@code Lookup} on {@code C} can also &lt;em&gt;teleport&lt;/em&gt; to a target class</span>
<span class="line-added"> 603      * via {@link #in(Class) Lookup.in} and {@link MethodHandles#privateLookupIn(Class, Lookup)</span>
<span class="line-added"> 604      * MethodHandles.privateLookupIn} methods.</span>
<span class="line-added"> 605      * Teleporting across modules will always record the original lookup class as</span>
<span class="line-added"> 606      * the &lt;em&gt;{@linkplain #previousLookupClass() previous lookup class}&lt;/em&gt;</span>
<span class="line-added"> 607      * and drops {@link Lookup#MODULE MODULE} access.</span>
<span class="line-added"> 608      * If the target class is in the same module as the lookup class {@code C},</span>
<span class="line-added"> 609      * then the target class becomes the new lookup class</span>
<span class="line-added"> 610      * and there is no change to the previous lookup class.</span>
<span class="line-added"> 611      * If the target class is in a different module from {@code M1} ({@code C}&#39;s module),</span>
<span class="line-added"> 612      * {@code C} becomes the new previous lookup class</span>
<span class="line-added"> 613      * and the target class becomes the new lookup class.</span>
<span class="line-added"> 614      * In that case, if there was already a previous lookup class in {@code M0},</span>
<span class="line-added"> 615      * and it differs from {@code M1} and {@code M2}, then the resulting lookup</span>
<span class="line-added"> 616      * drops all privileges.</span>
<span class="line-added"> 617      * For example,</span>
<span class="line-added"> 618      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added"> 619      * {@code</span>
<span class="line-added"> 620      * Lookup lookup = MethodHandles.lookup();   // in class C</span>
<span class="line-added"> 621      * Lookup lookup2 = lookup.in(D.class);</span>
<span class="line-added"> 622      * MethodHandle mh = lookup2.findStatic(E.class, &quot;m&quot;, MT);</span>
<span class="line-added"> 623      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 624      * &lt;p&gt;</span>
<span class="line-added"> 625      * The {@link #lookup()} factory method produces a {@code Lookup} object</span>
<span class="line-added"> 626      * with {@code null} previous lookup class.</span>
<span class="line-added"> 627      * {@link Lookup#in lookup.in(D.class)} transforms the {@code lookup} on class {@code C}</span>
<span class="line-added"> 628      * to class {@code D} without elevation of privileges.</span>
<span class="line-added"> 629      * If {@code C} and {@code D} are in the same module,</span>
<span class="line-added"> 630      * {@code lookup2} records {@code D} as the new lookup class and keeps the</span>
<span class="line-added"> 631      * same previous lookup class as the original {@code lookup}, or</span>
<span class="line-added"> 632      * {@code null} if not present.</span>
<span class="line-added"> 633      * &lt;p&gt;</span>
<span class="line-added"> 634      * When a {@code Lookup} teleports from a class</span>
<span class="line-added"> 635      * in one nest to another nest, {@code PRIVATE} access is dropped.</span>
<span class="line-added"> 636      * When a {@code Lookup} teleports from a class in one package to</span>
<span class="line-added"> 637      * another package, {@code PACKAGE} access is dropped.</span>
<span class="line-added"> 638      * When a {@code Lookup} teleports from a class in one module to another module,</span>
<span class="line-added"> 639      * {@code MODULE} access is dropped.</span>
<span class="line-added"> 640      * Teleporting across modules drops the ability to access non-exported classes</span>
<span class="line-added"> 641      * in both the module of the new lookup class and the module of the old lookup class</span>
<span class="line-added"> 642      * and the resulting {@code Lookup} remains only {@code PUBLIC} access.</span>
<span class="line-added"> 643      * A {@code Lookup} can teleport back and forth to a class in the module of</span>
<span class="line-added"> 644      * the lookup class and the module of the previous class lookup.</span>
<span class="line-added"> 645      * Teleporting across modules can only decrease access but cannot increase it.</span>
<span class="line-added"> 646      * Teleporting to some third module drops all accesses.</span>
<span class="line-added"> 647      * &lt;p&gt;</span>
<span class="line-added"> 648      * In the above example, if {@code C} and {@code D} are in different modules,</span>
<span class="line-added"> 649      * {@code lookup2} records {@code D} as its lookup class and</span>
<span class="line-added"> 650      * {@code C} as its previous lookup class and {@code lookup2} has only</span>
<span class="line-added"> 651      * {@code PUBLIC} access. {@code lookup2} can teleport to other class in</span>
<span class="line-added"> 652      * {@code C}&#39;s module and {@code D}&#39;s module.</span>
<span class="line-added"> 653      * If class {@code E} is in a third module, {@code lookup2.in(E.class)} creates</span>
<span class="line-added"> 654      * a {@code Lookup} on {@code E} with no access and {@code lookup2}&#39;s lookup</span>
<span class="line-added"> 655      * class {@code D} is recorded as its previous lookup class.</span>
<span class="line-added"> 656      * &lt;p&gt;</span>
<span class="line-added"> 657      * Teleporting across modules restricts access to the public types that</span>
<span class="line-added"> 658      * both the lookup class and the previous lookup class can equally access</span>
<span class="line-added"> 659      * (see below).</span>
<span class="line-added"> 660      * &lt;p&gt;</span>
<span class="line-added"> 661      * {@link MethodHandles#privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn(T.class, lookup)}</span>
<span class="line-added"> 662      * can be used to teleport a {@code lookup} from class {@code C} to class {@code T}</span>
<span class="line-added"> 663      * and create a new {@code Lookup} with &lt;a href=&quot;#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="line-added"> 664      * if the lookup class is allowed to do &lt;em&gt;deep reflection&lt;/em&gt; on {@code T}.</span>
<span class="line-added"> 665      * The {@code lookup} must have {@link #MODULE} and {@link #PRIVATE} access</span>
<span class="line-added"> 666      * to call {@code privateLookupIn}.</span>
<span class="line-added"> 667      * A {@code lookup} on {@code C} in module {@code M1} is allowed to do deep reflection</span>
<span class="line-added"> 668      * on all classes in {@code M1}.  If {@code T} is in {@code M1}, {@code privateLookupIn}</span>
<span class="line-added"> 669      * produces a new {@code Lookup} on {@code T} with full capabilities.</span>
<span class="line-added"> 670      * A {@code lookup} on {@code C} is also allowed</span>
<span class="line-added"> 671      * to do deep reflection on {@code T} in another module {@code M2} if</span>
<span class="line-added"> 672      * {@code M1} reads {@code M2} and {@code M2} {@link Module#isOpen(String,Module) opens}</span>
<span class="line-added"> 673      * the package containing {@code T} to at least {@code M1}.</span>
<span class="line-added"> 674      * {@code T} becomes the new lookup class and {@code C} becomes the new previous</span>
<span class="line-added"> 675      * lookup class and {@code MODULE} access is dropped from the resulting {@code Lookup}.</span>
<span class="line-added"> 676      * The resulting {@code Lookup} can be used to do member lookup or teleport</span>
<span class="line-added"> 677      * to another lookup class by calling {@link #in Lookup::in}.  But</span>
<span class="line-added"> 678      * it cannot be used to obtain another private {@code Lookup} by calling</span>
<span class="line-added"> 679      * {@link MethodHandles#privateLookupIn(Class, Lookup) privateLookupIn}</span>
<span class="line-added"> 680      * because it has no {@code MODULE} access.</span>
<span class="line-added"> 681      *</span>
<span class="line-added"> 682      * &lt;h2&gt;&lt;a id=&quot;module-access-check&quot;&gt;&lt;/a&gt;Cross-module access checks&lt;/h2&gt;</span>
<span class="line-added"> 683      *</span>
<span class="line-added"> 684      * A {@code Lookup} with {@link #PUBLIC} or with {@link #UNCONDITIONAL} mode</span>
<span class="line-added"> 685      * allows cross-module access. The access checking is performed with respect</span>
<span class="line-added"> 686      * to both the lookup class and the previous lookup class if present.</span>
<span class="line-added"> 687      * &lt;p&gt;</span>
<span class="line-added"> 688      * A {@code Lookup} with {@link #UNCONDITIONAL} mode can access public type</span>
<span class="line-added"> 689      * in all modules when the type is in a package that is {@linkplain Module#isExported(String)</span>
<span class="line-added"> 690      * exported unconditionally}.</span>
<span class="line-added"> 691      * &lt;p&gt;</span>
<span class="line-added"> 692      * If a {@code Lookup} on {@code LC} in {@code M1} has no previous lookup class,</span>
<span class="line-added"> 693      * the lookup with {@link #PUBLIC} mode can access all public types in modules</span>
<span class="line-added"> 694      * that are readable to {@code M1} and the type is in a package that is exported</span>
<span class="line-added"> 695      * at least to {@code M1}.</span>
<span class="line-added"> 696      * &lt;p&gt;</span>
<span class="line-added"> 697      * If a {@code Lookup} on {@code LC} in {@code M1} has a previous lookup class</span>
<span class="line-added"> 698      * {@code PLC} on {@code M0}, the lookup with {@link #PUBLIC} mode can access</span>
<span class="line-added"> 699      * the intersection of all public types that are accessible to {@code M1}</span>
<span class="line-added"> 700      * with all public types that are accessible to {@code M0}. {@code M0}</span>
<span class="line-added"> 701      * reads {@code M1} and hence the set of accessible types includes:</span>
<span class="line-added"> 702      *</span>
<span class="line-added"> 703      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added"> 704      * &lt;caption style=&quot;display:none&quot;&gt;</span>
<span class="line-added"> 705      * Public types in the following packages are accessible to the</span>
<span class="line-added"> 706      * lookup class and the previous lookup class.</span>
<span class="line-added"> 707      * &lt;/caption&gt;</span>
<span class="line-added"> 708      * &lt;thead&gt;</span>
<span class="line-added"> 709      * &lt;tr&gt;</span>
<span class="line-added"> 710      * &lt;th scope=&quot;col&quot;&gt;Equally accessible types to {@code M0} and {@code M1}&lt;/th&gt;</span>
<span class="line-added"> 711      * &lt;/tr&gt;</span>
<span class="line-added"> 712      * &lt;/thead&gt;</span>
<span class="line-added"> 713      * &lt;tbody&gt;</span>
<span class="line-added"> 714      * &lt;tr&gt;</span>
<span class="line-added"> 715      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M1}&lt;/th&gt;</span>
<span class="line-added"> 716      * &lt;/tr&gt;</span>
<span class="line-added"> 717      * &lt;tr&gt;</span>
<span class="line-added"> 718      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M0} if {@code M1} reads {@code M0}&lt;/th&gt;</span>
<span class="line-added"> 719      * &lt;/tr&gt;</span>
<span class="line-added"> 720      * &lt;tr&gt;</span>
<span class="line-added"> 721      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from a third module {@code M2}</span>
<span class="line-added"> 722      * if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;</span>
<span class="line-added"> 723      * &lt;/tr&gt;</span>
<span class="line-added"> 724      * &lt;tr&gt;</span>
<span class="line-added"> 725      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M1} to {@code M0}&lt;/th&gt;</span>
<span class="line-added"> 726      * &lt;/tr&gt;</span>
<span class="line-added"> 727      * &lt;tr&gt;</span>
<span class="line-added"> 728      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M0} to {@code M1}</span>
<span class="line-added"> 729      * if {@code M1} reads {@code M0}&lt;/th&gt;</span>
<span class="line-added"> 730      * &lt;/tr&gt;</span>
<span class="line-added"> 731      * &lt;tr&gt;</span>
<span class="line-added"> 732      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from a third module {@code M2} to</span>
<span class="line-added"> 733      * both {@code M0} and {@code M1} if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;</span>
<span class="line-added"> 734      * &lt;/tr&gt;</span>
<span class="line-added"> 735      * &lt;/tbody&gt;</span>
<span class="line-added"> 736      * &lt;/table&gt;</span>
<span class="line-added"> 737      *</span>
<span class="line-added"> 738      * &lt;h2&gt;&lt;a id=&quot;access-modes&quot;&gt;&lt;/a&gt;Access modes&lt;/h2&gt;</span>
<span class="line-added"> 739      *</span>
<span class="line-added"> 740      * The table below shows the access modes of a {@code Lookup} produced by</span>
<span class="line-added"> 741      * any of the following factory or transformation methods:</span>
<span class="line-added"> 742      * &lt;ul&gt;</span>
<span class="line-added"> 743      * &lt;li&gt;{@link #lookup() MethodHandles.lookup()}&lt;/li&gt;</span>
<span class="line-added"> 744      * &lt;li&gt;{@link #publicLookup() MethodHandles.publicLookup()}&lt;/li&gt;</span>
<span class="line-added"> 745      * &lt;li&gt;{@link #privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn}&lt;/li&gt;</span>
<span class="line-added"> 746      * &lt;li&gt;{@link Lookup#in}&lt;/li&gt;</span>
<span class="line-added"> 747      * &lt;li&gt;{@link Lookup#dropLookupMode(int)}&lt;/li&gt;</span>
<span class="line-added"> 748      * &lt;/ul&gt;</span>
<span class="line-added"> 749      *</span>
<span class="line-added"> 750      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added"> 751      * &lt;caption style=&quot;display:none&quot;&gt;</span>
<span class="line-added"> 752      * Access mode summary</span>
<span class="line-added"> 753      * &lt;/caption&gt;</span>
<span class="line-added"> 754      * &lt;thead&gt;</span>
<span class="line-added"> 755      * &lt;tr&gt;</span>
<span class="line-added"> 756      * &lt;th scope=&quot;col&quot;&gt;Lookup object&lt;/th&gt;</span>
<span class="line-added"> 757      * &lt;th style=&quot;text-align:center&quot;&gt;protected&lt;/th&gt;</span>
<span class="line-added"> 758      * &lt;th style=&quot;text-align:center&quot;&gt;private&lt;/th&gt;</span>
<span class="line-added"> 759      * &lt;th style=&quot;text-align:center&quot;&gt;package&lt;/th&gt;</span>
<span class="line-added"> 760      * &lt;th style=&quot;text-align:center&quot;&gt;module&lt;/th&gt;</span>
<span class="line-added"> 761      * &lt;th style=&quot;text-align:center&quot;&gt;public&lt;/th&gt;</span>
<span class="line-added"> 762      * &lt;/tr&gt;</span>
<span class="line-added"> 763      * &lt;/thead&gt;</span>
<span class="line-added"> 764      * &lt;tbody&gt;</span>
<span class="line-added"> 765      * &lt;tr&gt;</span>
<span class="line-added"> 766      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL = MethodHandles.lookup()} in {@code C}&lt;/th&gt;</span>
<span class="line-added"> 767      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="line-added"> 768      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 769      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 770      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 771      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 772      * &lt;/tr&gt;</span>
<span class="line-added"> 773      * &lt;tr&gt;</span>
<span class="line-added"> 774      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same package&lt;/th&gt;</span>
<span class="line-added"> 775      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 776      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 777      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 778      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 779      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 780      * &lt;/tr&gt;</span>
<span class="line-added"> 781      * &lt;tr&gt;</span>
<span class="line-added"> 782      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same module&lt;/th&gt;</span>
<span class="line-added"> 783      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 784      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 785      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 786      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 787      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 788      * &lt;/tr&gt;</span>
<span class="line-added"> 789      * &lt;tr&gt;</span>
<span class="line-added"> 790      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(D)} different module&lt;/th&gt;</span>
<span class="line-added"> 791      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 792      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 793      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 794      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 795      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 796      * &lt;/tr&gt;</span>
<span class="line-added"> 797      * &lt;tr&gt;</span>
<span class="line-added"> 798      * &lt;td&gt;{@code CL.in(D).in(C)} hop back to module&lt;/td&gt;</span>
<span class="line-added"> 799      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 800      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 801      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 802      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 803      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 804      * &lt;/tr&gt;</span>
<span class="line-added"> 805      * &lt;tr&gt;</span>
<span class="line-added"> 806      * &lt;td&gt;{@code PRI1 = privateLookupIn(C1,CL)}&lt;/td&gt;</span>
<span class="line-added"> 807      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="line-added"> 808      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 809      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 810      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 811      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 812      * &lt;/tr&gt;</span>
<span class="line-added"> 813      * &lt;tr&gt;</span>
<span class="line-added"> 814      * &lt;td&gt;{@code PRI1a = privateLookupIn(C,PRI1)}&lt;/td&gt;</span>
<span class="line-added"> 815      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="line-added"> 816      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 817      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 818      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 819      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 820      * &lt;/tr&gt;</span>
<span class="line-added"> 821      * &lt;tr&gt;</span>
<span class="line-added"> 822      * &lt;td&gt;{@code PRI1.in(C1)} same package&lt;/td&gt;</span>
<span class="line-added"> 823      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 824      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 825      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 826      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 827      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 828      * &lt;/tr&gt;</span>
<span class="line-added"> 829      * &lt;tr&gt;</span>
<span class="line-added"> 830      * &lt;td&gt;{@code PRI1.in(C1)} different package&lt;/td&gt;</span>
<span class="line-added"> 831      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 832      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 833      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 834      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 835      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 836      * &lt;/tr&gt;</span>
<span class="line-added"> 837      * &lt;tr&gt;</span>
<span class="line-added"> 838      * &lt;td&gt;{@code PRI1.in(D)} different module&lt;/td&gt;</span>
<span class="line-added"> 839      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 840      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 841      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 842      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 843      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 844      * &lt;/tr&gt;</span>
<span class="line-added"> 845      * &lt;tr&gt;</span>
<span class="line-added"> 846      * &lt;td&gt;{@code PRI1.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="line-added"> 847      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 848      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 849      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 850      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 851      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 852      * &lt;/tr&gt;</span>
<span class="line-added"> 853      * &lt;tr&gt;</span>
<span class="line-added"> 854      * &lt;td&gt;{@code PRI1.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="line-added"> 855      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 856      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 857      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 858      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 859      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 860      * &lt;/tr&gt;</span>
<span class="line-added"> 861      * &lt;tr&gt;</span>
<span class="line-added"> 862      * &lt;td&gt;{@code PRI1.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="line-added"> 863      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 864      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 865      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 866      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 867      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 868      * &lt;/tr&gt;</span>
<span class="line-added"> 869      * &lt;tr&gt;</span>
<span class="line-added"> 870      * &lt;td&gt;{@code PRI1.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="line-added"> 871      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 872      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 873      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 874      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 875      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 876      * &lt;/tr&gt;</span>
<span class="line-added"> 877      * &lt;tr&gt;</span>
<span class="line-added"> 878      * &lt;td&gt;{@code PRI1.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="line-added"> 879      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 880      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 881      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 882      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 883      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added"> 884      * &lt;tr&gt;</span>
<span class="line-added"> 885      * &lt;td&gt;{@code PRI2 = privateLookupIn(D,CL)}&lt;/td&gt;</span>
<span class="line-added"> 886      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="line-added"> 887      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 888      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 889      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 890      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 891      * &lt;/tr&gt;</span>
<span class="line-added"> 892      * &lt;tr&gt;</span>
<span class="line-added"> 893      * &lt;td&gt;{@code privateLookupIn(D,PRI1)}&lt;/td&gt;</span>
<span class="line-added"> 894      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="line-added"> 895      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 896      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 897      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 898      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 899      * &lt;/tr&gt;</span>
<span class="line-added"> 900      * &lt;tr&gt;</span>
<span class="line-added"> 901      * &lt;td&gt;{@code privateLookupIn(C,PRI2)} fails&lt;/td&gt;</span>
<span class="line-added"> 902      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 903      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 904      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 905      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 906      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;</span>
<span class="line-added"> 907      * &lt;/tr&gt;</span>
<span class="line-added"> 908      * &lt;tr&gt;</span>
<span class="line-added"> 909      * &lt;td&gt;{@code PRI2.in(D2)} same package&lt;/td&gt;</span>
<span class="line-added"> 910      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 911      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 912      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 913      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 914      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 915      * &lt;/tr&gt;</span>
<span class="line-added"> 916      * &lt;tr&gt;</span>
<span class="line-added"> 917      * &lt;td&gt;{@code PRI2.in(D2)} different package&lt;/td&gt;</span>
<span class="line-added"> 918      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 919      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 920      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 921      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 922      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 923      * &lt;/tr&gt;</span>
<span class="line-added"> 924      * &lt;tr&gt;</span>
<span class="line-added"> 925      * &lt;td&gt;{@code PRI2.in(C1)} hop back to module&lt;/td&gt;</span>
<span class="line-added"> 926      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 927      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 928      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 929      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 930      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 931      * &lt;/tr&gt;</span>
<span class="line-added"> 932      * &lt;tr&gt;</span>
<span class="line-added"> 933      * &lt;td&gt;{@code PRI2.in(E)} hop to third module&lt;/td&gt;</span>
<span class="line-added"> 934      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 935      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 936      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 937      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 938      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added"> 939      * &lt;/tr&gt;</span>
<span class="line-added"> 940      * &lt;tr&gt;</span>
<span class="line-added"> 941      * &lt;td&gt;{@code PRI2.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="line-added"> 942      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 943      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 944      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 945      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 946      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 947      * &lt;/tr&gt;</span>
<span class="line-added"> 948      * &lt;tr&gt;</span>
<span class="line-added"> 949      * &lt;td&gt;{@code PRI2.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="line-added"> 950      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 951      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 952      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 953      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 954      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 955      * &lt;/tr&gt;</span>
<span class="line-added"> 956      * &lt;tr&gt;</span>
<span class="line-added"> 957      * &lt;td&gt;{@code PRI2.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="line-added"> 958      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 959      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 960      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 961      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 962      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 963      * &lt;/tr&gt;</span>
<span class="line-added"> 964      * &lt;tr&gt;</span>
<span class="line-added"> 965      * &lt;td&gt;{@code PRI2.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="line-added"> 966      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 967      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 968      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 969      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 970      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="line-added"> 971      * &lt;/tr&gt;</span>
<span class="line-added"> 972      * &lt;tr&gt;</span>
<span class="line-added"> 973      * &lt;td&gt;{@code PRI2.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="line-added"> 974      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 975      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 976      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 977      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 978      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added"> 979      * &lt;/tr&gt;</span>
<span class="line-added"> 980      * &lt;tr&gt;</span>
<span class="line-added"> 981      * &lt;td&gt;{@code CL.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="line-added"> 982      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 983      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="line-added"> 984      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 985      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 986      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 987      * &lt;/tr&gt;</span>
<span class="line-added"> 988      * &lt;tr&gt;</span>
<span class="line-added"> 989      * &lt;td&gt;{@code CL.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="line-added"> 990      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 991      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 992      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="line-added"> 993      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added"> 994      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added"> 995      * &lt;/tr&gt;</span>
<span class="line-added"> 996      * &lt;tr&gt;</span>
<span class="line-added"> 997      * &lt;td&gt;{@code CL.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="line-added"> 998      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added"> 999      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1000      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1001      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="line-added">1002      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added">1003      * &lt;/tr&gt;</span>
<span class="line-added">1004      * &lt;tr&gt;</span>
<span class="line-added">1005      * &lt;td&gt;{@code CL.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="line-added">1006      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1007      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1008      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1009      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1010      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="line-added">1011      * &lt;/tr&gt;</span>
<span class="line-added">1012      * &lt;tr&gt;</span>
<span class="line-added">1013      * &lt;td&gt;{@code CL.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="line-added">1014      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1015      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1016      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1017      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1018      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added">1019      * &lt;/tr&gt;</span>
<span class="line-added">1020      * &lt;tr&gt;</span>
<span class="line-added">1021      * &lt;td&gt;{@code PUB = publicLookup()}&lt;/td&gt;</span>
<span class="line-added">1022      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1023      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1024      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1025      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1026      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="line-added">1027      * &lt;/tr&gt;</span>
<span class="line-added">1028      * &lt;tr&gt;</span>
<span class="line-added">1029      * &lt;td&gt;{@code PUB.in(D)} different module&lt;/td&gt;</span>
<span class="line-added">1030      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1031      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1032      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1033      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1034      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="line-added">1035      * &lt;/tr&gt;</span>
<span class="line-added">1036      * &lt;tr&gt;</span>
<span class="line-added">1037      * &lt;td&gt;{@code PUB.in(D).in(E)} third module&lt;/td&gt;</span>
<span class="line-added">1038      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1039      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1040      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1041      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1042      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="line-added">1043      * &lt;/tr&gt;</span>
<span class="line-added">1044      * &lt;tr&gt;</span>
<span class="line-added">1045      * &lt;td&gt;{@code PUB.dropLookupMode(UNCONDITIONAL)}&lt;/td&gt;</span>
<span class="line-added">1046      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1047      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1048      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1049      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1050      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added">1051      * &lt;/tr&gt;</span>
<span class="line-added">1052      * &lt;tr&gt;</span>
<span class="line-added">1053      * &lt;td&gt;{@code privateLookupIn(C1,PUB)} fails&lt;/td&gt;</span>
<span class="line-added">1054      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1055      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1056      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1057      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1058      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;</span>
<span class="line-added">1059      * &lt;/tr&gt;</span>
<span class="line-added">1060      * &lt;tr&gt;</span>
<span class="line-added">1061      * &lt;td&gt;{@code ANY.in(X)}, for inaccessible {@code X}&lt;/td&gt;</span>
<span class="line-added">1062      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1063      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1064      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1065      * &lt;td&gt;&lt;/td&gt;</span>
<span class="line-added">1066      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="line-added">1067      * &lt;/tr&gt;</span>
<span class="line-added">1068      * &lt;/tbody&gt;</span>
<span class="line-added">1069      * &lt;/table&gt;</span>
<span class="line-added">1070      *</span>
<span class="line-added">1071      * &lt;p&gt;</span>
<span class="line-added">1072      * Notes:</span>
<span class="line-added">1073      * &lt;ul&gt;</span>
<span class="line-added">1074      * &lt;li&gt;Class {@code C} and class {@code C1} are in module {@code M1},</span>
<span class="line-added">1075      *     but {@code D} and {@code D2} are in module {@code M2}, and {@code E}</span>
<span class="line-added">1076      *     is in module {@code M3}. {@code X} stands for class which is inaccessible</span>
<span class="line-added">1077      *     to the lookup. {@code ANY} stands for any of the example lookups.&lt;/li&gt;</span>
<span class="line-added">1078      * &lt;li&gt;{@code PRO} indicates {@link #PROTECTED} bit set,</span>
<span class="line-added">1079      *     {@code PRI} indicates {@link #PRIVATE} bit set,</span>
<span class="line-added">1080      *     {@code PAC} indicates {@link #PACKAGE} bit set,</span>
<span class="line-added">1081      *     {@code MOD} indicates {@link #MODULE} bit set,</span>
<span class="line-added">1082      *     {@code 1R} and {@code 2R} indicate {@link #PUBLIC} bit set,</span>
<span class="line-added">1083      *     {@code U} indicates {@link #UNCONDITIONAL} bit set,</span>
<span class="line-added">1084      *     {@code IAE} indicates {@code IllegalAccessException} thrown.&lt;/li&gt;</span>
<span class="line-added">1085      * &lt;li&gt;Public access comes in three kinds:</span>
<span class="line-added">1086      * &lt;ul&gt;</span>
<span class="line-added">1087      * &lt;li&gt;unconditional ({@code U}): the lookup assumes readability.</span>
<span class="line-added">1088      *     The lookup has {@code null} previous lookup class.</span>
<span class="line-added">1089      * &lt;li&gt;one-module-reads ({@code 1R}): the module access checking is</span>
<span class="line-added">1090      *     performed with respect to the lookup class.  The lookup has {@code null}</span>
<span class="line-added">1091      *     previous lookup class.</span>
<span class="line-added">1092      * &lt;li&gt;two-module-reads ({@code 2R}): the module access checking is</span>
<span class="line-added">1093      *     performed with respect to the lookup class and the previous lookup class.</span>
<span class="line-added">1094      *     The lookup has a non-null previous lookup class which is in a</span>
<span class="line-added">1095      *     different module from the current lookup class.</span>
<span class="line-added">1096      * &lt;/ul&gt;</span>
<span class="line-added">1097      * &lt;li&gt;Any attempt to reach a third module loses all access.&lt;/li&gt;</span>
<span class="line-added">1098      * &lt;li&gt;If a target class {@code X} is not accessible to {@code Lookup::in}</span>
<span class="line-added">1099      * all access modes are dropped.&lt;/li&gt;</span>
<span class="line-added">1100      * &lt;/ul&gt;</span>
<span class="line-added">1101      *</span>
<span class="line-added">1102      * &lt;h2&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h2&gt;</span>
1103      * Although bytecode instructions can only refer to classes in
1104      * a related class loader, this API can search for methods in any
1105      * class, as long as a reference to its {@code Class} object is
1106      * available.  Such cross-loader references are also possible with the
1107      * Core Reflection API, and are impossible to bytecode instructions
1108      * such as {@code invokestatic} or {@code getfield}.
1109      * There is a {@linkplain java.lang.SecurityManager security manager API}
1110      * to allow applications to check such cross-loader references.
1111      * These checks apply to both the {@code MethodHandles.Lookup} API
1112      * and the Core Reflection API
1113      * (as found on {@link java.lang.Class Class}).
1114      * &lt;p&gt;
1115      * If a security manager is present, member and class lookups are subject to
1116      * additional checks.
1117      * From one to three calls are made to the security manager.
1118      * Any of these calls can refuse access by throwing a
1119      * {@link java.lang.SecurityException SecurityException}.
1120      * Define {@code smgr} as the security manager,
1121      * {@code lookc} as the lookup class of the current lookup object,
1122      * {@code refc} as the containing class in which the member
1123      * is being sought, and {@code defc} as the class in which the
1124      * member is actually defined.
1125      * (If a class or other type is being accessed,
1126      * the {@code refc} and {@code defc} values are the class itself.)
1127      * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;
1128      * if the current lookup object does not have
<span class="line-modified">1129      * {@linkplain #hasFullPrivilegeAccess() full privilege access}.</span>
1130      * The calls are made according to the following rules:
1131      * &lt;ul&gt;
1132      * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
1133      *     If {@code lookc} is not present, or if its class loader is not
1134      *     the same as or an ancestor of the class loader of {@code refc},
1135      *     then {@link SecurityManager#checkPackageAccess
1136      *     smgr.checkPackageAccess(refcPkg)} is called,
1137      *     where {@code refcPkg} is the package of {@code refc}.
1138      * &lt;li&gt;&lt;b&gt;Step 2a:&lt;/b&gt;
1139      *     If the retrieved member is not public and
1140      *     {@code lookc} is not present, then
1141      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1142      *     with {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)} is called.
1143      * &lt;li&gt;&lt;b&gt;Step 2b:&lt;/b&gt;
1144      *     If the retrieved class has a {@code null} class loader,
1145      *     and {@code lookc} is not present, then
1146      *     {@link SecurityManager#checkPermission smgr.checkPermission}
1147      *     with {@code RuntimePermission(&quot;getClassLoader&quot;)} is called.
1148      * &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
1149      *     If the retrieved member is not public,
1150      *     and if {@code lookc} is not present,
1151      *     and if {@code defc} and {@code refc} are different,
1152      *     then {@link SecurityManager#checkPackageAccess
1153      *     smgr.checkPackageAccess(defcPkg)} is called,
1154      *     where {@code defcPkg} is the package of {@code defc}.
1155      * &lt;/ul&gt;
1156      * Security checks are performed after other access checks have passed.
1157      * Therefore, the above rules presuppose a member or class that is public,
1158      * or else that is being accessed from a lookup class that has
1159      * rights to access the member or class.
<span class="line-added">1160      * &lt;p&gt;</span>
<span class="line-added">1161      * If a security manager is present and the current lookup object does not have</span>
<span class="line-added">1162      * {@linkplain #hasFullPrivilegeAccess() full privilege access}, then</span>
<span class="line-added">1163      * {@link #defineClass(byte[]) defineClass}</span>
<span class="line-added">1164      * calls {@link SecurityManager#checkPermission smgr.checkPermission}</span>
<span class="line-added">1165      * with {@code RuntimePermission(&quot;defineClass&quot;)}.</span>
1166      *
<span class="line-modified">1167      * &lt;h2&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h2&gt;</span>
1168      * A small number of Java methods have a special property called caller sensitivity.
1169      * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
1170      * identity of its immediate caller.
1171      * &lt;p&gt;
1172      * If a method handle for a caller-sensitive method is requested,
1173      * the general rules for &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply,
1174      * but they take account of the lookup class in a special way.
1175      * The resulting method handle behaves as if it were called
1176      * from an instruction contained in the lookup class,
1177      * so that the caller-sensitive method detects the lookup class.
1178      * (By contrast, the invoker of the method handle is disregarded.)
1179      * Thus, in the case of caller-sensitive methods,
1180      * different lookup classes may give rise to
1181      * differently behaving method handles.
1182      * &lt;p&gt;
1183      * In cases where the lookup object is
1184      * {@link MethodHandles#publicLookup() publicLookup()},
<span class="line-modified">1185      * or some other lookup object without the</span>
<span class="line-modified">1186      * {@linkplain #hasFullPrivilegeAccess() full privilege access},</span>
1187      * the lookup class is disregarded.
1188      * In such cases, no caller-sensitive method handle can be created,
1189      * access is forbidden, and the lookup fails with an
1190      * {@code IllegalAccessException}.
1191      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1192      * &lt;em&gt;Discussion:&lt;/em&gt;
1193      * For example, the caller-sensitive method
1194      * {@link java.lang.Class#forName(String) Class.forName(x)}
1195      * can return varying classes or throw varying exceptions,
1196      * depending on the class loader of the class that calls it.
1197      * A public lookup of {@code Class.forName} will fail, because
1198      * there is no reasonable way to determine its bytecode behavior.
1199      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1200      * If an application caches method handles for broad sharing,
1201      * it should use {@code publicLookup()} to create them.
1202      * If there is a lookup of {@code Class.forName}, it will fail,
1203      * and the application must take appropriate action in that case.
1204      * It may be that a later lookup, perhaps during the invocation of a
1205      * bootstrap method, can incorporate the specific identity
1206      * of the caller, making the method accessible.
1207      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
1208      * The function {@code MethodHandles.lookup} is caller sensitive
1209      * so that there can be a secure foundation for lookups.
1210      * Nearly all other methods in the JSR 292 API rely on lookup
1211      * objects to check access requests.
1212      *
1213      * @revised 9
1214      */
1215     public static final
1216     class Lookup {
1217         /** The class on behalf of whom the lookup is being performed. */
1218         private final Class&lt;?&gt; lookupClass;
1219 
<span class="line-added">1220         /** previous lookup class */</span>
<span class="line-added">1221         private final Class&lt;?&gt; prevLookupClass;</span>
<span class="line-added">1222 </span>
1223         /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */
1224         private final int allowedModes;
1225 
1226         static {
1227             Reflection.registerFieldsToFilter(Lookup.class, Set.of(&quot;lookupClass&quot;, &quot;allowedModes&quot;));
1228         }
1229 
1230         /** A single-bit mask representing {@code public} access,
1231          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1232          *  The value, {@code 0x01}, happens to be the same as the value of the
1233          *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.
<span class="line-added">1234          *  &lt;p&gt;</span>
<span class="line-added">1235          *  A {@code Lookup} with this lookup mode performs cross-module access check</span>
<span class="line-added">1236          *  with respect to the {@linkplain #lookupClass() lookup class} and</span>
<span class="line-added">1237          *  {@linkplain #previousLookupClass() previous lookup class} if present.</span>
1238          */
1239         public static final int PUBLIC = Modifier.PUBLIC;
1240 
1241         /** A single-bit mask representing {@code private} access,
1242          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1243          *  The value, {@code 0x02}, happens to be the same as the value of the
1244          *  {@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.
1245          */
1246         public static final int PRIVATE = Modifier.PRIVATE;
1247 
1248         /** A single-bit mask representing {@code protected} access,
1249          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1250          *  The value, {@code 0x04}, happens to be the same as the value of the
1251          *  {@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.
1252          */
1253         public static final int PROTECTED = Modifier.PROTECTED;
1254 
1255         /** A single-bit mask representing {@code package} access (default access),
1256          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1257          *  The value is {@code 0x08}, which does not correspond meaningfully to
1258          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1259          */
1260         public static final int PACKAGE = Modifier.STATIC;
1261 
<span class="line-modified">1262         /** A single-bit mask representing {@code module} access,</span>
1263          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1264          *  The value is {@code 0x10}, which does not correspond meaningfully to
1265          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1266          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
1267          *  with this lookup mode can access all public types in the module of the
1268          *  lookup class and public types in packages exported by other modules
1269          *  to the module of the lookup class.
<span class="line-added">1270          *  &lt;p&gt;</span>
<span class="line-added">1271          *  If this lookup mode is set, the {@linkplain #previousLookupClass()</span>
<span class="line-added">1272          *  previous lookup class} is always {@code null}.</span>
<span class="line-added">1273          *</span>
1274          *  @since 9
1275          *  @spec JPMS
1276          */
1277         public static final int MODULE = PACKAGE &lt;&lt; 1;
1278 
1279         /** A single-bit mask representing {@code unconditional} access
1280          *  which may contribute to the result of {@link #lookupModes lookupModes}.
1281          *  The value is {@code 0x20}, which does not correspond meaningfully to
1282          *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
1283          *  A {@code Lookup} with this lookup mode assumes {@linkplain
1284          *  java.lang.Module#canRead(java.lang.Module) readability}.
<span class="line-modified">1285          *  This lookup mode can access all public members of public types</span>
<span class="line-modified">1286          *  of all modules when the type is in a package that is {@link</span>

1287          *  java.lang.Module#isExported(String) exported unconditionally}.
<span class="line-added">1288          *</span>
<span class="line-added">1289          *  &lt;p&gt;</span>
<span class="line-added">1290          *  If this lookup mode is set, the {@linkplain #previousLookupClass()</span>
<span class="line-added">1291          *  previous lookup class} is always {@code null}.</span>
<span class="line-added">1292          *</span>
1293          *  @since 9
1294          *  @spec JPMS
1295          *  @see #publicLookup()
1296          */
1297         public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
1298 
1299         private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
1300         private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
1301         private static final int TRUSTED   = -1;
1302 
<span class="line-added">1303         /*</span>
<span class="line-added">1304          * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL</span>
<span class="line-added">1305          * Adjust 0 =&gt; PACKAGE</span>
<span class="line-added">1306          */</span>
1307         private static int fixmods(int mods) {
1308             mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
<span class="line-modified">1309             if (Modifier.isPublic(mods))</span>
<span class="line-added">1310                 mods |= UNCONDITIONAL;</span>
<span class="line-added">1311             return (mods != 0) ? mods : PACKAGE;</span>
1312         }
1313 
1314         /** Tells which class is performing the lookup.  It is this class against
1315          *  which checks are performed for visibility and access permissions.
1316          *  &lt;p&gt;
<span class="line-added">1317          *  If this lookup object has a {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="line-added">1318          *  access checks are performed against both the lookup class and the previous lookup class.</span>
<span class="line-added">1319          *  &lt;p&gt;</span>
1320          *  The class implies a maximum level of access permission,
1321          *  but the permissions may be additionally limited by the bitmask
1322          *  {@link #lookupModes lookupModes}, which controls whether non-public members
1323          *  can be accessed.
1324          *  @return the lookup class, on behalf of which this lookup object finds members
<span class="line-added">1325          *  @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
1326          */
1327         public Class&lt;?&gt; lookupClass() {
1328             return lookupClass;
1329         }
1330 
<span class="line-added">1331         /** Reports a lookup class in another module that this lookup object</span>
<span class="line-added">1332          * was previously teleported from, or {@code null}.</span>
<span class="line-added">1333          * &lt;p&gt;</span>
<span class="line-added">1334          * A {@code Lookup} object produced by the factory methods, such as the</span>
<span class="line-added">1335          * {@link #lookup() lookup()} and {@link #publicLookup() publicLookup()} method,</span>
<span class="line-added">1336          * has {@code null} previous lookup class.</span>
<span class="line-added">1337          * A {@code Lookup} object has a non-null previous lookup class</span>
<span class="line-added">1338          * when this lookup was teleported from an old lookup class</span>
<span class="line-added">1339          * in one module to a new lookup class in another module.</span>
<span class="line-added">1340          *</span>
<span class="line-added">1341          * @return the lookup class in another module that this lookup object was</span>
<span class="line-added">1342          *         previously teleported from, or {@code null}</span>
<span class="line-added">1343          * @since 14</span>
<span class="line-added">1344          * @see #in(Class)</span>
<span class="line-added">1345          * @see MethodHandles#privateLookupIn(Class, Lookup)</span>
<span class="line-added">1346          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
<span class="line-added">1347          */</span>
<span class="line-added">1348         public Class&lt;?&gt; previousLookupClass() {</span>
<span class="line-added">1349             return prevLookupClass;</span>
<span class="line-added">1350         }</span>
<span class="line-added">1351 </span>
1352         // This is just for calling out to MethodHandleImpl.
1353         private Class&lt;?&gt; lookupClassOrNull() {
<span class="line-modified">1354             if (allowedModes == TRUSTED) {</span>
<span class="line-added">1355                 return null;</span>
<span class="line-added">1356             }</span>
<span class="line-added">1357             if (allowedModes == UNCONDITIONAL) {</span>
<span class="line-added">1358                 // use Object as the caller to pass to VM doing resolution</span>
<span class="line-added">1359                 return Object.class;</span>
<span class="line-added">1360             }</span>
<span class="line-added">1361             return lookupClass;</span>
1362         }
1363 
1364         /** Tells which access-protection classes of members this lookup object can produce.
1365          *  The result is a bit-mask of the bits
1366          *  {@linkplain #PUBLIC PUBLIC (0x01)},
1367          *  {@linkplain #PRIVATE PRIVATE (0x02)},
1368          *  {@linkplain #PROTECTED PROTECTED (0x04)},
1369          *  {@linkplain #PACKAGE PACKAGE (0x08)},
1370          *  {@linkplain #MODULE MODULE (0x10)},
1371          *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.
1372          *  &lt;p&gt;
1373          *  A freshly-created lookup object
1374          *  on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&#39;s class} has
1375          *  all possible bits set, except {@code UNCONDITIONAL}.
1376          *  A lookup object on a new lookup class
1377          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}
1378          *  may have some mode bits set to zero.
1379          *  Mode bits can also be
1380          *  {@linkplain java.lang.invoke.MethodHandles.Lookup#dropLookupMode directly cleared}.
1381          *  Once cleared, mode bits cannot be restored from the downgraded lookup object.
1382          *  The purpose of this is to restrict access via the new lookup object,
1383          *  so that it can access only names which can be reached by the original
1384          *  lookup object, and also by the new lookup class.
1385          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
1386          *  @see #in
1387          *  @see #dropLookupMode
1388          *
1389          *  @revised 9
1390          *  @spec JPMS
1391          */
1392         public int lookupModes() {
1393             return allowedModes &amp; ALL_MODES;
1394         }
1395 
1396         /** Embody the current class (the lookupClass) as a lookup class
1397          * for method handle creation.
1398          * Must be called by from a method in this package,
1399          * which in turn is called by a method not in this package.
1400          */
1401         Lookup(Class&lt;?&gt; lookupClass) {
<span class="line-modified">1402             this(lookupClass, null, FULL_POWER_MODES);</span>
1403             // make sure we haven&#39;t accidentally picked up a privileged class:
1404             checkUnprivilegedlookupClass(lookupClass);
1405         }
1406 
<span class="line-modified">1407         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {</span>
<span class="line-added">1408             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0</span>
<span class="line-added">1409                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());</span>
<span class="line-added">1410             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();</span>
1411             this.lookupClass = lookupClass;
<span class="line-added">1412             this.prevLookupClass = prevLookupClass;</span>
1413             this.allowedModes = allowedModes;
1414         }
1415 
<span class="line-added">1416         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {</span>
<span class="line-added">1417             // make sure we haven&#39;t accidentally picked up a privileged class:</span>
<span class="line-added">1418             checkUnprivilegedlookupClass(lookupClass);</span>
<span class="line-added">1419             return new Lookup(lookupClass, prevLookupClass, allowedModes);</span>
<span class="line-added">1420         }</span>
<span class="line-added">1421 </span>
1422         /**
1423          * Creates a lookup on the specified new lookup class.
1424          * The resulting object will report the specified
1425          * class as its own {@link #lookupClass() lookupClass}.
<span class="line-added">1426          *</span>
1427          * &lt;p&gt;
1428          * However, the resulting {@code Lookup} object is guaranteed
1429          * to have no more access capabilities than the original.
1430          * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="line-modified">1431          * &lt;li&gt;If the new lookup class is in a different module from the old one,</span>
<span class="line-modified">1432          * i.e. {@link #MODULE MODULE} access is lost.</span>






1433          * &lt;li&gt;If the new lookup class is in a different package
<span class="line-modified">1434          * than the old one, protected and default (package) members will not be accessible,</span>
<span class="line-added">1435          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.</span>
1436          * &lt;li&gt;If the new lookup class is not within the same package member
1437          * as the old one, private members will not be accessible, and protected members
<span class="line-modified">1438          * will not be accessible by virtue of inheritance,</span>
<span class="line-added">1439          * i.e. {@link #PRIVATE PRIVATE} access is lost.</span>
1440          * (Protected members may continue to be accessible because of package sharing.)
<span class="line-modified">1441          * &lt;li&gt;If the new lookup class is not</span>
<span class="line-modified">1442          * {@linkplain #accessClass(Class) accessible} to this lookup,</span>
<span class="line-modified">1443          * then no members, not even public members, will be accessible</span>
<span class="line-added">1444          * i.e. all access modes are lost.</span>
<span class="line-added">1445          * &lt;li&gt;If the new lookup class, the old lookup class and the previous lookup class</span>
<span class="line-added">1446          * are all in different modules i.e. teleporting to a third module,</span>
<span class="line-added">1447          * all access modes are lost.</span>
1448          * &lt;/ul&gt;
1449          * &lt;p&gt;
<span class="line-added">1450          * The new previous lookup class is chosen as follows:</span>
<span class="line-added">1451          * &lt;ul&gt;</span>
<span class="line-added">1452          * &lt;li&gt;If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,</span>
<span class="line-added">1453          * the new previous lookup class is {@code null}.</span>
<span class="line-added">1454          * &lt;li&gt;If the new lookup class is in the same module as the old lookup class,</span>
<span class="line-added">1455          * the new previous lookup class is the old previous lookup class.</span>
<span class="line-added">1456          * &lt;li&gt;If the new lookup class is in a different module from the old lookup class,</span>
<span class="line-added">1457          * the new previous lookup class is the old lookup class.</span>
<span class="line-added">1458          *&lt;/ul&gt;</span>
<span class="line-added">1459          * &lt;p&gt;</span>
1460          * The resulting lookup&#39;s capabilities for loading classes
1461          * (used during {@link #findClass} invocations)
1462          * are determined by the lookup class&#39; loader,
1463          * which may change due to this operation.
<span class="line-modified">1464          * &lt;p&gt;</span>
1465          * @param requestedLookupClass the desired lookup class for the new lookup object
1466          * @return a lookup object which reports the desired lookup class, or the same object
1467          * if there is no change
<span class="line-added">1468          * @throws IllegalArgumentException if {@code requestedLookupClass} is a primitive type or void or array class</span>
1469          * @throws NullPointerException if the argument is null
1470          *
1471          * @revised 9
1472          * @spec JPMS
<span class="line-added">1473          * @see #accessClass(Class)</span>
<span class="line-added">1474          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
1475          */
1476         public Lookup in(Class&lt;?&gt; requestedLookupClass) {
1477             Objects.requireNonNull(requestedLookupClass);
<span class="line-added">1478             if (requestedLookupClass.isPrimitive())</span>
<span class="line-added">1479                 throw new IllegalArgumentException(requestedLookupClass + &quot; is a primitive class&quot;);</span>
<span class="line-added">1480             if (requestedLookupClass.isArray())</span>
<span class="line-added">1481                 throw new IllegalArgumentException(requestedLookupClass + &quot; is an array class&quot;);</span>
<span class="line-added">1482 </span>
1483             if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
<span class="line-modified">1484                 return new Lookup(requestedLookupClass, null, FULL_POWER_MODES);</span>
1485             if (requestedLookupClass == this.lookupClass)
1486                 return this;  // keep same capabilities
1487             int newModes = (allowedModes &amp; FULL_POWER_MODES);
<span class="line-modified">1488             Module fromModule = this.lookupClass.getModule();</span>
<span class="line-modified">1489             Module targetModule = requestedLookupClass.getModule();</span>
<span class="line-modified">1490             Class&lt;?&gt; plc = this.previousLookupClass();</span>
<span class="line-modified">1491             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="line-modified">1492                 assert plc == null;</span>
<span class="line-added">1493                 newModes = UNCONDITIONAL;</span>
<span class="line-added">1494             } else if (fromModule != targetModule) {</span>
<span class="line-added">1495                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {</span>
<span class="line-added">1496                     // allow hopping back and forth between fromModule and plc&#39;s module</span>
<span class="line-added">1497                     // but not the third module</span>
1498                     newModes = 0;
<span class="line-modified">1499                 }</span>
<span class="line-modified">1500                 // drop MODULE access</span>
<span class="line-added">1501                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);</span>
<span class="line-added">1502                 // teleport from this lookup class</span>
<span class="line-added">1503                 plc = this.lookupClass;</span>
1504             }
1505             if ((newModes &amp; PACKAGE) != 0
1506                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
1507                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
1508             }
1509             // Allow nestmate lookups to be created without special privilege:
1510             if ((newModes &amp; PRIVATE) != 0
1511                 &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
1512                 newModes &amp;= ~(PRIVATE|PROTECTED);
1513             }
<span class="line-modified">1514             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0</span>
<span class="line-modified">1515                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {</span>
1516                 // The requested class it not accessible from the lookup class.
1517                 // No permissions.
1518                 newModes = 0;
1519             }
<span class="line-modified">1520             return newLookup(requestedLookupClass, plc, newModes);</span>


1521         }
1522 

1523         /**
1524          * Creates a lookup on the same lookup class which this lookup object
1525          * finds members, but with a lookup mode that has lost the given lookup mode.
1526          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
1527          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED} or {@link #PRIVATE PRIVATE}.
<span class="line-modified">1528          * {@link #PROTECTED PROTECTED} is always</span>
<span class="line-modified">1529          * dropped and so the resulting lookup mode will never have this access capability.</span>
1530          * When dropping {@code PACKAGE} then the resulting lookup will not have {@code PACKAGE}
1531          * or {@code PRIVATE} access. When dropping {@code MODULE} then the resulting lookup will
1532          * not have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access. If {@code PUBLIC}
<span class="line-added">1533          * is dropped then the resulting lookup has no access. If {@code UNCONDITIONAL}</span>
1534          * is dropped then the resulting lookup has no access.
<span class="line-added">1535          *</span>
<span class="line-added">1536          * @apiNote</span>
<span class="line-added">1537          * A lookup with {@code PACKAGE} but not {@code PRIVATE} mode can safely</span>
<span class="line-added">1538          * delegate non-public access within the package of the lookup class without</span>
<span class="line-added">1539          * conferring  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
<span class="line-added">1540          * A lookup with {@code MODULE} but not</span>
<span class="line-added">1541          * {@code PACKAGE} mode can safely delegate {@code PUBLIC} access within</span>
<span class="line-added">1542          * the module of the lookup class without conferring package access.</span>
<span class="line-added">1543          * A lookup with a {@linkplain #previousLookupClass() previous lookup class}</span>
<span class="line-added">1544          * (and {@code PUBLIC} but not {@code MODULE} mode) can safely delegate access</span>
<span class="line-added">1545          * to public classes accessible to both the module of the lookup class</span>
<span class="line-added">1546          * and the module of the previous lookup class.</span>
<span class="line-added">1547          *</span>
1548          * @param modeToDrop the lookup mode to drop
1549          * @return a lookup object which lacks the indicated mode, or the same object if there is no change
1550          * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
1551          * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
1552          * @see MethodHandles#privateLookupIn
1553          * @since 9
1554          */
1555         public Lookup dropLookupMode(int modeToDrop) {
1556             int oldModes = lookupModes();
<span class="line-modified">1557             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);</span>
1558             switch (modeToDrop) {
<span class="line-modified">1559                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;</span>
1560                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
1561                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
1562                 case PROTECTED:
1563                 case PRIVATE:
1564                 case UNCONDITIONAL: break;
1565                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
1566             }
1567             if (newModes == oldModes) return this;  // return self if no change
<span class="line-modified">1568             return newLookup(lookupClass(), previousLookupClass(), newModes);</span>
1569         }
1570 
1571         /**
1572          * Defines a class to the same class loader and in the same runtime package and
1573          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
1574          * {@linkplain #lookupClass() lookup class}.
1575          *
1576          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
1577          * {@link #PACKAGE PACKAGE} access as default (package) members will be
1578          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
1579          * that the lookup object was created by a caller in the runtime package (or derived
1580          * from a lookup originally created by suitably privileged code to a target class in
1581          * the runtime package). &lt;/p&gt;
1582          *
1583          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1584          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1585          * same package as the lookup class. &lt;/p&gt;
1586          *
1587          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1588          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1589          * Specification&lt;/em&gt;. &lt;/p&gt;
1590          *
<span class="line-modified">1591          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain</span>
<span class="line-modified">1592          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method</span>
<span class="line-added">1593          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;</span>
1594          *
1595          * @param bytes the class bytes
1596          * @return the {@code Class} object for the class
1597          * @throws IllegalArgumentException the bytes are for a class in a different package
1598          * to the lookup class
1599          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
1600          * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
1601          * verified ({@code VerifyError}), is already defined, or another linkage error occurs
<span class="line-modified">1602          * @throws SecurityException if a security manager is present and it</span>
<span class="line-added">1603          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
1604          * @throws NullPointerException if {@code bytes} is {@code null}
1605          * @since 9
1606          * @spec JPMS
1607          * @see Lookup#privateLookupIn
1608          * @see Lookup#dropLookupMode
1609          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1610          */
1611         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
<span class="line-modified">1612             if (!hasFullPrivilegeAccess()) {</span>
<span class="line-modified">1613                 SecurityManager sm = System.getSecurityManager();</span>
<span class="line-modified">1614                 if (sm != null)</span>
<span class="line-added">1615                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));</span>
<span class="line-added">1616             }</span>
1617             if ((lookupModes() &amp; PACKAGE) == 0)
1618                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);

1619 
1620             // parse class bytes to get class name (in internal form)
1621             bytes = bytes.clone();
1622             String name;
1623             try {
1624                 ClassReader reader = new ClassReader(bytes);
1625                 name = reader.getClassName();
1626             } catch (RuntimeException e) {
1627                 // ASM exceptions are poorly specified
1628                 ClassFormatError cfe = new ClassFormatError();
1629                 cfe.initCause(e);
1630                 throw cfe;
1631             }
1632 
1633             // get package and class name in binary form
1634             String cn, pn;
1635             int index = name.lastIndexOf(&#39;/&#39;);
1636             if (index == -1) {
1637                 cn = name;
1638                 pn = &quot;&quot;;
</pre>
<hr />
<pre>
1656             ProtectionDomain pd = cachedProtectionDomain;
1657             if (pd == null) {
1658                 cachedProtectionDomain = pd = protectionDomain(lookupClass);
1659             }
1660             return pd;
1661         }
1662 
1663         private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {
1664             PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;
1665             return AccessController.doPrivileged(pa);
1666         }
1667 
1668         // cached protection domain
1669         private volatile ProtectionDomain cachedProtectionDomain;
1670 
1671 
1672         // Make sure outer class is initialized first.
1673         static { IMPL_NAMES.getClass(); }
1674 
1675         /** Package-private version of lookup which is trusted. */
<span class="line-modified">1676         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);</span>
1677 
1678         /** Version of lookup which is trusted minimally.
1679          *  It can only be used to create method handles to publicly accessible
1680          *  members in packages that are exported unconditionally.
1681          */
<span class="line-modified">1682         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);</span>
1683 
1684         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
1685             String name = lookupClass.getName();
1686             if (name.startsWith(&quot;java.lang.invoke.&quot;))
1687                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
1688         }
1689 
1690         /**
1691          * Displays the name of the class from which lookups are to be made.
<span class="line-added">1692          * followed with &quot;/&quot; and the name of the {@linkplain #previousLookupClass()</span>
<span class="line-added">1693          * previous lookup class} if present.</span>
1694          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
1695          * If there are restrictions on the access permitted to this lookup,
1696          * this is indicated by adding a suffix to the class name, consisting
1697          * of a slash and a keyword.  The keyword represents the strongest
1698          * allowed access, and is chosen as follows:
1699          * &lt;ul&gt;
1700          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
<span class="line-added">1701          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.</span>
1702          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.

1703          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
<span class="line-modified">1704          * &lt;li&gt;If public and package access are allowed, the suffix is &quot;/package&quot;.</span>
<span class="line-modified">1705          * &lt;li&gt;If public, package, and private access are allowed, the suffix is &quot;/private&quot;.</span>
1706          * &lt;/ul&gt;
<span class="line-modified">1707          * If none of the above cases apply, it is the case that full access</span>
<span class="line-modified">1708          * (public, module, package, private, and protected) is allowed.</span>
1709          * In this case, no suffix is added.
1710          * This is true only of an object obtained originally from
1711          * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
1712          * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
1713          * always have restricted access, and will display a suffix.
1714          * &lt;p&gt;
1715          * (It may seem strange that protected access should be
1716          * stronger than private access.  Viewed independently from
1717          * package access, protected access is the first to be lost,
1718          * because it requires a direct subclass relationship between
1719          * caller and callee.)
1720          * @see #in
1721          *
1722          * @revised 9
1723          * @spec JPMS
1724          */
1725         @Override
1726         public String toString() {
1727             String cname = lookupClass.getName();
<span class="line-added">1728             if (prevLookupClass != null)</span>
<span class="line-added">1729                 cname += &quot;/&quot; + prevLookupClass.getName();</span>
1730             switch (allowedModes) {
1731             case 0:  // no privileges
1732                 return cname + &quot;/noaccess&quot;;
<span class="line-added">1733             case UNCONDITIONAL:</span>
<span class="line-added">1734                 return cname + &quot;/publicLookup&quot;;</span>
1735             case PUBLIC:
1736                 return cname + &quot;/public&quot;;


1737             case PUBLIC|MODULE:
1738                 return cname + &quot;/module&quot;;
<span class="line-added">1739             case PUBLIC|PACKAGE:</span>
1740             case PUBLIC|MODULE|PACKAGE:
1741                 return cname + &quot;/package&quot;;
<span class="line-modified">1742             case FULL_POWER_MODES &amp; (~PROTECTED):</span>
<span class="line-modified">1743             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):</span>
<span class="line-added">1744                     return cname + &quot;/private&quot;;</span>
1745             case FULL_POWER_MODES:
<span class="line-added">1746             case FULL_POWER_MODES &amp; (~MODULE):</span>
1747                 return cname;
1748             case TRUSTED:
1749                 return &quot;/trusted&quot;;  // internal only; not exported
1750             default:  // Should not happen, but it&#39;s a bitfield...
1751                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
1752                 assert(false) : cname;
1753                 return cname;
1754             }
1755         }
1756 
1757         /**
1758          * Produces a method handle for a static method.
1759          * The type of the method handle will be that of the method.
1760          * (Since static methods do not take receivers, there is no
1761          * additional receiver argument inserted into the method handle type,
1762          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
1763          * The method and all its argument types must be accessible to the lookup object.
1764          * &lt;p&gt;
1765          * The returned method handle will have
1766          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
</pre>
<hr />
<pre>
1769          * If the returned method handle is invoked, the method&#39;s class will
1770          * be initialized, if it has not already been initialized.
1771          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
1772          * &lt;blockquote&gt;&lt;pre&gt;{@code
1773 import static java.lang.invoke.MethodHandles.*;
1774 import static java.lang.invoke.MethodType.*;
1775 ...
1776 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
1777   &quot;asList&quot;, methodType(List.class, Object[].class));
1778 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
1779          * }&lt;/pre&gt;&lt;/blockquote&gt;
1780          * @param refc the class from which the method is accessed
1781          * @param name the name of the method
1782          * @param type the type of the method
1783          * @return the desired method handle
1784          * @throws NoSuchMethodException if the method does not exist
1785          * @throws IllegalAccessException if access checking fails,
1786          *                                or if the method is not {@code static},
1787          *                                or if the method&#39;s variable arity modifier bit
1788          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1789          * @throws    SecurityException if a security manager is present and it</span>
1790          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1791          * @throws NullPointerException if any argument is null
1792          */
<span class="line-modified">1793         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {</span>

1794             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-modified">1795             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));</span>
1796         }
1797 
1798         /**
1799          * Produces a method handle for a virtual method.
1800          * The type of the method handle will be that of the method,
1801          * with the receiver type (usually {@code refc}) prepended.
1802          * The method and all its argument types must be accessible to the lookup object.
1803          * &lt;p&gt;
1804          * When called, the handle will treat the first argument as a receiver
1805          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
1806          * implementation to enter.
1807          * For private methods the named method in {@code refc} will be invoked on the receiver.
1808          * (The dispatching action is identical with that performed by an
1809          * {@code invokevirtual} or {@code invokeinterface} instruction.)
1810          * &lt;p&gt;
1811          * The first argument will be of type {@code refc} if the lookup
1812          * class has full privileges to access the member.  Otherwise
1813          * the member must be {@code protected} and the first argument
1814          * will be restricted in type to the lookup class.
1815          * &lt;p&gt;
</pre>
<hr />
<pre>
1853 assertEquals(&quot;def&quot;, MH_subSequence.invoke(&quot;abcdefghi&quot;, 3, 6).toString());
1854 // constructor &quot;internal method&quot; must be accessed differently:
1855 MethodType MT_newString = methodType(void.class); //()V for new String()
1856 try { assertEquals(&quot;impossible&quot;, lookup()
1857         .findVirtual(String.class, &quot;&lt;init&gt;&quot;, MT_newString));
1858  } catch (NoSuchMethodException ex) { } // OK
1859 MethodHandle MH_newString = publicLookup()
1860   .findConstructor(String.class, MT_newString);
1861 assertEquals(&quot;&quot;, (String) MH_newString.invokeExact());
1862          * }&lt;/pre&gt;&lt;/blockquote&gt;
1863          *
1864          * @param refc the class or interface from which the method is accessed
1865          * @param name the name of the method
1866          * @param type the type of the method, with the receiver argument omitted
1867          * @return the desired method handle
1868          * @throws NoSuchMethodException if the method does not exist
1869          * @throws IllegalAccessException if access checking fails,
1870          *                                or if the method is {@code static},
1871          *                                or if the method&#39;s variable arity modifier bit
1872          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1873          * @throws    SecurityException if a security manager is present and it</span>
1874          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1875          * @throws NullPointerException if any argument is null
1876          */
1877         public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1878             if (refc == MethodHandle.class) {
1879                 MethodHandle mh = findVirtualForMH(name, type);
1880                 if (mh != null)  return mh;
1881             } else if (refc == VarHandle.class) {
1882                 MethodHandle mh = findVirtualForVH(name, type);
1883                 if (mh != null)  return mh;
1884             }
1885             byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
1886             MemberName method = resolveOrFail(refKind, refc, name, type);
<span class="line-modified">1887             return getDirectMethod(refKind, refc, method, findBoundCallerLookup(method));</span>
1888         }
1889         private MethodHandle findVirtualForMH(String name, MethodType type) {
1890             // these names require special lookups because of the implicit MethodType argument
1891             if (&quot;invoke&quot;.equals(name))
1892                 return invoker(type);
1893             if (&quot;invokeExact&quot;.equals(name))
1894                 return exactInvoker(type);
1895             assert(!MemberName.isMethodHandleInvokeName(name));
1896             return null;
1897         }
1898         private MethodHandle findVirtualForVH(String name, MethodType type) {
1899             try {
1900                 return varHandleInvoker(VarHandle.AccessMode.valueFromMethodName(name), type);
1901             } catch (IllegalArgumentException e) {
1902                 return null;
1903             }
1904         }
1905 
1906         /**
1907          * Produces a method handle which creates an object and initializes it, using
</pre>
<hr />
<pre>
1927 MethodHandle MH_newArrayList = publicLookup().findConstructor(
1928   ArrayList.class, methodType(void.class, Collection.class));
1929 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
1930 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
1931 assert(orig != copy);
1932 assertEquals(orig, copy);
1933 // a variable-arity constructor:
1934 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
1935   ProcessBuilder.class, methodType(void.class, String[].class));
1936 ProcessBuilder pb = (ProcessBuilder)
1937   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
1938 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
1939          * }&lt;/pre&gt;&lt;/blockquote&gt;
1940          * @param refc the class or interface from which the method is accessed
1941          * @param type the type of the method, with the receiver argument omitted, and a void return type
1942          * @return the desired method handle
1943          * @throws NoSuchMethodException if the constructor does not exist
1944          * @throws IllegalAccessException if access checking fails
1945          *                                or if the method&#39;s variable arity modifier bit
1946          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">1947          * @throws    SecurityException if a security manager is present and it</span>
1948          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1949          * @throws NullPointerException if any argument is null
1950          */
1951         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
1952             if (refc.isArray()) {
1953                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
1954             }
1955             String name = &quot;&lt;init&gt;&quot;;
1956             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
1957             return getDirectConstructor(refc, ctor);
1958         }
1959 
1960         /**
<span class="line-modified">1961          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,</span>
<span class="line-modified">1962          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.</span>
<span class="line-added">1963          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,</span>
<span class="line-added">1964          * and then determines whether the class is accessible to this lookup object.</span>
1965          * &lt;p&gt;
<span class="line-modified">1966          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},</span>
<span class="line-modified">1967          * its class loader, and the {@linkplain #lookupModes() lookup modes}.</span>

1968          *
1969          * @param targetName the fully qualified name of the class to be looked up.
1970          * @return the requested class.
<span class="line-modified">1971          * @throws SecurityException if a security manager is present and it</span>
<span class="line-modified">1972          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
1973          * @throws LinkageError if the linkage fails
1974          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
1975          * @throws IllegalAccessException if the class is not accessible, using the allowed access
1976          * modes.


1977          * @since 9
<span class="line-added">1978          * @jvms 5.4.3.1 Class and Interface Resolution</span>
1979          */
1980         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
1981             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
1982             return accessClass(targetClass);
1983         }
1984 
1985         /**
<span class="line-modified">1986          * Determines if a class can be accessed from the lookup context defined by</span>
<span class="line-modified">1987          * this {@code Lookup} object. The static initializer of the class is not run.</span>
1988          * &lt;p&gt;
<span class="line-modified">1989          * If the {@code targetClass} is in the same module as the lookup class,</span>
<span class="line-modified">1990          * the lookup class is {@code LC} in module {@code M1} and</span>
<span class="line-added">1991          * the previous lookup class is in module {@code M0} or</span>
<span class="line-added">1992          * {@code null} if not present,</span>
<span class="line-added">1993          * {@code targetClass} is accessible if and only if one of the following is true:</span>
<span class="line-added">1994          * &lt;ul&gt;</span>
<span class="line-added">1995          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is</span>
<span class="line-added">1996          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;</span>
<span class="line-added">1997          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is</span>
<span class="line-added">1998          *     in the same runtime package of {@code LC}.&lt;/li&gt;</span>
<span class="line-added">1999          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is</span>
<span class="line-added">2000          *     a public type in {@code M1}.&lt;/li&gt;</span>
<span class="line-added">2001          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is</span>
<span class="line-added">2002          *     a public type in a package exported by {@code M1} to at least  {@code M0}</span>
<span class="line-added">2003          *     if the previous lookup class is present; otherwise, {@code targetClass}</span>
<span class="line-added">2004          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;</span>
<span class="line-added">2005          * &lt;/ul&gt;</span>
2006          *
<span class="line-modified">2007          * &lt;p&gt;</span>
<span class="line-added">2008          * Otherwise, if this lookup has {@link #UNCONDITIONAL} access, this lookup</span>
<span class="line-added">2009          * can access public types in all modules when the type is in a package</span>
<span class="line-added">2010          * that is exported unconditionally.</span>
<span class="line-added">2011          * &lt;p&gt;</span>
<span class="line-added">2012          * Otherwise, the target class is in a different module from {@code lookupClass},</span>
<span class="line-added">2013          * and if this lookup does not have {@code PUBLIC} access, {@code lookupClass}</span>
<span class="line-added">2014          * is inaccessible.</span>
<span class="line-added">2015          * &lt;p&gt;</span>
<span class="line-added">2016          * Otherwise, if this lookup has no {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="line-added">2017          * {@code M1} is the module containing {@code lookupClass} and</span>
<span class="line-added">2018          * {@code M2} is the module containing {@code targetClass},</span>
<span class="line-added">2019          * then {@code targetClass} is accessible if and only if</span>
<span class="line-added">2020          * &lt;ul&gt;</span>
<span class="line-added">2021          * &lt;li&gt;{@code M1} reads {@code M2}, and</span>
<span class="line-added">2022          * &lt;li&gt;{@code targetClass} is public and in a package exported by</span>
<span class="line-added">2023          *     {@code M2} at least to {@code M1}.</span>
<span class="line-added">2024          * &lt;/ul&gt;</span>
<span class="line-added">2025          * &lt;p&gt;</span>
<span class="line-added">2026          * Otherwise, if this lookup has a {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="line-added">2027          * {@code M1} and {@code M2} are as before, and {@code M0} is the module</span>
<span class="line-added">2028          * containing the previous lookup class, then {@code targetClass} is accessible</span>
<span class="line-added">2029          * if and only if one of the following is true:</span>
<span class="line-added">2030          * &lt;ul&gt;</span>
<span class="line-added">2031          * &lt;li&gt;{@code targetClass} is in {@code M0} and {@code M1}</span>
<span class="line-added">2032          *     {@linkplain Module#reads reads} {@code M0} and the type is</span>
<span class="line-added">2033          *     in a package that is exported to at least {@code M1}.</span>
<span class="line-added">2034          * &lt;li&gt;{@code targetClass} is in {@code M1} and {@code M0}</span>
<span class="line-added">2035          *     {@linkplain Module#reads reads} {@code M1} and the type is</span>
<span class="line-added">2036          *     in a package that is exported to at least {@code M0}.</span>
<span class="line-added">2037          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}</span>
<span class="line-added">2038          *     and {@code M1} reads {@code M2} and the type is in a package</span>
<span class="line-added">2039          *     that is exported to at least both {@code M0} and {@code M2}.</span>
<span class="line-added">2040          * &lt;/ul&gt;</span>
<span class="line-added">2041          * &lt;p&gt;</span>
<span class="line-added">2042          * Otherwise, {@code targetClass} is not accessible.</span>
2043          *
<span class="line-added">2044          * @param targetClass the class to be access-checked</span>
2045          * @return the class that has been access-checked
<span class="line-modified">2046          * @throws IllegalAccessException if the class is not accessible from the lookup class</span>
<span class="line-modified">2047          * and previous lookup class, if present, using the allowed access modes.</span>
<span class="line-modified">2048          * @throws    SecurityException if a security manager is present and it</span>

2049          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2050          * @since 9
<span class="line-added">2051          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
2052          */
2053         public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
<span class="line-modified">2054             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {</span>
2055                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);
2056             }
2057             checkSecurityManager(targetClass, null);
2058             return targetClass;
2059         }
2060 
2061         /**
2062          * Produces an early-bound method handle for a virtual method.
2063          * It will bypass checks for overriding methods on the receiver,
2064          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2065          * instruction from within the explicitly specified {@code specialCaller}.
2066          * The type of the method handle will be that of the method,
2067          * with a suitably restricted receiver type prepended.
2068          * (The receiver type will be {@code specialCaller} or a subtype.)
2069          * The method and all its argument types must be accessible
2070          * to the lookup object.
2071          * &lt;p&gt;
2072          * Before method resolution,
2073          * if the explicitly specified caller class is not identical with the
2074          * lookup class, or if this lookup object does not have
</pre>
<hr />
<pre>
2110 assertEquals(&quot;[]&quot;, (String) MH_super.invokeExact(l));
2111 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(l));
2112 assertEquals(&quot;[]&quot;, (String) MH_duper.invokeExact(l)); // ArrayList method
2113 try { assertEquals(&quot;inaccessible&quot;, Listie.lookup().findSpecial(
2114         String.class, &quot;toString&quot;, methodType(String.class), Listie.class));
2115  } catch (IllegalAccessException ex) { } // OK
2116 Listie subl = new Listie() { public String toString() { return &quot;[subclass]&quot;; } };
2117 assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(subl)); // Listie method
2118          * }&lt;/pre&gt;&lt;/blockquote&gt;
2119          *
2120          * @param refc the class or interface from which the method is accessed
2121          * @param name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)
2122          * @param type the type of the method, with the receiver argument omitted
2123          * @param specialCaller the proposed calling class to perform the {@code invokespecial}
2124          * @return the desired method handle
2125          * @throws NoSuchMethodException if the method does not exist
2126          * @throws IllegalAccessException if access checking fails,
2127          *                                or if the method is {@code static},
2128          *                                or if the method&#39;s variable arity modifier bit
2129          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">2130          * @throws    SecurityException if a security manager is present and it</span>
2131          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2132          * @throws NullPointerException if any argument is null
2133          */
2134         public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,
2135                                         Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {
2136             checkSpecialCaller(specialCaller, refc);
2137             Lookup specialLookup = this.in(specialCaller);
2138             MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="line-modified">2139             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerLookup(method));</span>
2140         }
2141 
2142         /**
2143          * Produces a method handle giving read access to a non-static field.
2144          * The type of the method handle will have a return type of the field&#39;s
2145          * value type.
2146          * The method handle&#39;s single argument will be the instance containing
2147          * the field.
2148          * Access checking is performed immediately on behalf of the lookup class.
2149          * @param refc the class or interface from which the method is accessed
2150          * @param name the field&#39;s name
2151          * @param type the field&#39;s type
2152          * @return a method handle which can load values from the field
2153          * @throws NoSuchFieldException if the field does not exist
2154          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">2155          * @throws    SecurityException if a security manager is present and it</span>
2156          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2157          * @throws NullPointerException if any argument is null
2158          * @see #findVarHandle(Class, String, Class)
2159          */
2160         public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2161             MemberName field = resolveOrFail(REF_getField, refc, name, type);
2162             return getDirectField(REF_getField, refc, field);
2163         }
2164 
2165         /**
2166          * Produces a method handle giving write access to a non-static field.
2167          * The type of the method handle will have a void return type.
2168          * The method handle will take two arguments, the instance containing
2169          * the field, and the value to be stored.
2170          * The second argument will be of the field&#39;s value type.
2171          * Access checking is performed immediately on behalf of the lookup class.
2172          * @param refc the class or interface from which the method is accessed
2173          * @param name the field&#39;s name
2174          * @param type the field&#39;s type
2175          * @return a method handle which can store values into the field
2176          * @throws NoSuchFieldException if the field does not exist
2177          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">2178          *                                or {@code final}</span>
<span class="line-added">2179          * @throws    SecurityException if a security manager is present and it</span>
2180          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2181          * @throws NullPointerException if any argument is null
2182          * @see #findVarHandle(Class, String, Class)
2183          */
2184         public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2185             MemberName field = resolveOrFail(REF_putField, refc, name, type);
2186             return getDirectField(REF_putField, refc, field);
2187         }
2188 
2189         /**
2190          * Produces a VarHandle giving access to a non-static field {@code name}
2191          * of type {@code type} declared in a class of type {@code recv}.
2192          * The VarHandle&#39;s variable type is {@code type} and it has one
2193          * coordinate type, {@code recv}.
2194          * &lt;p&gt;
2195          * Access checking is performed immediately on behalf of the lookup
2196          * class.
2197          * &lt;p&gt;
2198          * Certain access modes of the returned VarHandle are unsupported under
2199          * the following conditions:
</pre>
<hr />
<pre>
2232          * There are many possible NaN values that are considered to be
2233          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2234          * provided by Java can distinguish between them.  Operation failure can
2235          * occur if the expected or witness value is a NaN value and it is
2236          * transformed (perhaps in a platform specific manner) into another NaN
2237          * value, and thus has a different bitwise representation (see
2238          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2239          * details).
2240          * The values {@code -0.0} and {@code +0.0} have different bitwise
2241          * representations but are considered equal when using the primitive
2242          * {@code ==} operator.  Operation failure can occur if, for example, a
2243          * numeric algorithm computes an expected value to be say {@code -0.0}
2244          * and previously computed the witness value to be say {@code +0.0}.
2245          * @param recv the receiver class, of type {@code R}, that declares the
2246          * non-static field
2247          * @param name the field&#39;s name
2248          * @param type the field&#39;s type, of type {@code T}
2249          * @return a VarHandle giving access to non-static fields.
2250          * @throws NoSuchFieldException if the field does not exist
2251          * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="line-modified">2252          * @throws    SecurityException if a security manager is present and it</span>
2253          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2254          * @throws NullPointerException if any argument is null
2255          * @since 9
2256          */
2257         public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2258             MemberName getField = resolveOrFail(REF_getField, recv, name, type);
2259             MemberName putField = resolveOrFail(REF_putField, recv, name, type);
2260             return getFieldVarHandle(REF_getField, REF_putField, recv, getField, putField);
2261         }
2262 
2263         /**
2264          * Produces a method handle giving read access to a static field.
2265          * The type of the method handle will have a return type of the field&#39;s
2266          * value type.
2267          * The method handle will take no arguments.
2268          * Access checking is performed immediately on behalf of the lookup class.
2269          * &lt;p&gt;
2270          * If the returned method handle is invoked, the field&#39;s class will
2271          * be initialized, if it has not already been initialized.
2272          * @param refc the class or interface from which the method is accessed
2273          * @param name the field&#39;s name
2274          * @param type the field&#39;s type
2275          * @return a method handle which can load values from the field
2276          * @throws NoSuchFieldException if the field does not exist
2277          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">2278          * @throws    SecurityException if a security manager is present and it</span>
2279          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2280          * @throws NullPointerException if any argument is null
2281          */
2282         public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2283             MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
2284             return getDirectField(REF_getStatic, refc, field);
2285         }
2286 
2287         /**
2288          * Produces a method handle giving write access to a static field.
2289          * The type of the method handle will have a void return type.
2290          * The method handle will take a single
2291          * argument, of the field&#39;s value type, the value to be stored.
2292          * Access checking is performed immediately on behalf of the lookup class.
2293          * &lt;p&gt;
2294          * If the returned method handle is invoked, the field&#39;s class will
2295          * be initialized, if it has not already been initialized.
2296          * @param refc the class or interface from which the method is accessed
2297          * @param name the field&#39;s name
2298          * @param type the field&#39;s type
2299          * @return a method handle which can store values into the field
2300          * @throws NoSuchFieldException if the field does not exist
2301          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">2302          *                                or is {@code final}</span>
<span class="line-added">2303          * @throws    SecurityException if a security manager is present and it</span>
2304          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2305          * @throws NullPointerException if any argument is null
2306          */
2307         public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2308             MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
2309             return getDirectField(REF_putStatic, refc, field);
2310         }
2311 
2312         /**
2313          * Produces a VarHandle giving access to a static field {@code name} of
2314          * type {@code type} declared in a class of type {@code decl}.
2315          * The VarHandle&#39;s variable type is {@code type} and it has no
2316          * coordinate types.
2317          * &lt;p&gt;
2318          * Access checking is performed immediately on behalf of the lookup
2319          * class.
2320          * &lt;p&gt;
2321          * If the returned VarHandle is operated on, the declaring class will be
2322          * initialized, if it has not already been initialized.
2323          * &lt;p&gt;
</pre>
<hr />
<pre>
2357          * unexpectedly fail.
2358          * There are many possible NaN values that are considered to be
2359          * {@code NaN} in Java, although no IEEE 754 floating-point operation
2360          * provided by Java can distinguish between them.  Operation failure can
2361          * occur if the expected or witness value is a NaN value and it is
2362          * transformed (perhaps in a platform specific manner) into another NaN
2363          * value, and thus has a different bitwise representation (see
2364          * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
2365          * details).
2366          * The values {@code -0.0} and {@code +0.0} have different bitwise
2367          * representations but are considered equal when using the primitive
2368          * {@code ==} operator.  Operation failure can occur if, for example, a
2369          * numeric algorithm computes an expected value to be say {@code -0.0}
2370          * and previously computed the witness value to be say {@code +0.0}.
2371          * @param decl the class that declares the static field
2372          * @param name the field&#39;s name
2373          * @param type the field&#39;s type, of type {@code T}
2374          * @return a VarHandle giving access to a static field
2375          * @throws NoSuchFieldException if the field does not exist
2376          * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="line-modified">2377          * @throws    SecurityException if a security manager is present and it</span>
2378          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2379          * @throws NullPointerException if any argument is null
2380          * @since 9
2381          */
2382         public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2383             MemberName getField = resolveOrFail(REF_getStatic, decl, name, type);
2384             MemberName putField = resolveOrFail(REF_putStatic, decl, name, type);
2385             return getFieldVarHandle(REF_getStatic, REF_putStatic, decl, getField, putField);
2386         }
2387 
2388         /**
2389          * Produces an early-bound method handle for a non-static method.
2390          * The receiver must have a supertype {@code defc} in which a method
2391          * of the given name and type is accessible to the lookup class.
2392          * The method and all its argument types must be accessible to the lookup object.
2393          * The type of the method handle will be that of the method,
2394          * without any insertion of an additional receiver parameter.
2395          * The given receiver will be bound into the method handle,
2396          * so that every call to the method handle will invoke the
2397          * requested method on the given receiver.
</pre>
<hr />
<pre>
2411 MethodHandle mh0 = lookup().findVirtual(defc, name, type);
2412 MethodHandle mh1 = mh0.bindTo(receiver);
2413 mh1 = mh1.withVarargs(mh0.isVarargsCollector());
2414 return mh1;
2415          * }&lt;/pre&gt;&lt;/blockquote&gt;
2416          * where {@code defc} is either {@code receiver.getClass()} or a super
2417          * type of that class, in which the requested method is accessible
2418          * to the lookup class.
2419          * (Unlike {@code bind}, {@code bindTo} does not preserve variable arity.
2420          * Also, {@code bindTo} may throw a {@code ClassCastException} in instances where {@code bind} would
2421          * throw an {@code IllegalAccessException}, as in the case where the member is {@code protected} and
2422          * the receiver is restricted by {@code findVirtual} to the lookup class.)
2423          * @param receiver the object from which the method is accessed
2424          * @param name the name of the method
2425          * @param type the type of the method, with the receiver argument omitted
2426          * @return the desired method handle
2427          * @throws NoSuchMethodException if the method does not exist
2428          * @throws IllegalAccessException if access checking fails
2429          *                                or if the method&#39;s variable arity modifier bit
2430          *                                is set and {@code asVarargsCollector} fails
<span class="line-modified">2431          * @throws    SecurityException if a security manager is present and it</span>
2432          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2433          * @throws NullPointerException if any argument is null
2434          * @see MethodHandle#bindTo
2435          * @see #findVirtual
2436          */
2437         public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2438             Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE
2439             MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="line-modified">2440             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerLookup(method));</span>
2441             if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
2442                 throw new IllegalAccessException(&quot;The restricted defining class &quot; +
2443                                                  mh.type().leadingReferenceParameter().getName() +
2444                                                  &quot; is not assignable from receiver class &quot; +
2445                                                  receiver.getClass().getName());
2446             }
2447             return mh.bindArgumentL(0, receiver).setVarargs(method);
2448         }
2449 
2450         /**
2451          * Makes a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
2452          * to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.
2453          * If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
2454          * If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
2455          * Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
2456          * The type of the method handle will be that of the method,
2457          * with the receiver type prepended (but only if it is non-static).
2458          * If the method&#39;s {@code accessible} flag is not set,
2459          * access checking is performed immediately on behalf of the lookup class.
2460          * If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
</pre>
<hr />
<pre>
2472          *                                or if the method&#39;s variable arity modifier bit
2473          *                                is set and {@code asVarargsCollector} fails
2474          * @throws NullPointerException if the argument is null
2475          */
2476         public MethodHandle unreflect(Method m) throws IllegalAccessException {
2477             if (m.getDeclaringClass() == MethodHandle.class) {
2478                 MethodHandle mh = unreflectForMH(m);
2479                 if (mh != null)  return mh;
2480             }
2481             if (m.getDeclaringClass() == VarHandle.class) {
2482                 MethodHandle mh = unreflectForVH(m);
2483                 if (mh != null)  return mh;
2484             }
2485             MemberName method = new MemberName(m);
2486             byte refKind = method.getReferenceKind();
2487             if (refKind == REF_invokeSpecial)
2488                 refKind = REF_invokeVirtual;
2489             assert(method.isMethod());
2490             @SuppressWarnings(&quot;deprecation&quot;)
2491             Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">2492             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));</span>
2493         }
2494         private MethodHandle unreflectForMH(Method m) {
2495             // these names require special lookups because they throw UnsupportedOperationException
2496             if (MemberName.isMethodHandleInvokeName(m.getName()))
2497                 return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));
2498             return null;
2499         }
2500         private MethodHandle unreflectForVH(Method m) {
2501             // these names require special lookups because they throw UnsupportedOperationException
2502             if (MemberName.isVarHandleMethodInvokeName(m.getName()))
2503                 return MethodHandleImpl.fakeVarHandleInvoke(new MemberName(m));
2504             return null;
2505         }
2506 
2507         /**
2508          * Produces a method handle for a reflected method.
2509          * It will bypass checks for overriding methods on the receiver,
2510          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
2511          * instruction from within the explicitly specified {@code specialCaller}.
2512          * The type of the method handle will be that of the method,
</pre>
<hr />
<pre>
2518          * &lt;p&gt;
2519          * Before method resolution,
2520          * if the explicitly specified caller class is not identical with the
2521          * lookup class, or if this lookup object does not have
2522          * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
2523          * privileges, the access fails.
2524          * &lt;p&gt;
2525          * The returned method handle will have
2526          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2527          * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2528          * @param m the reflected method
2529          * @param specialCaller the class nominally calling the method
2530          * @return a method handle which can invoke the reflected method
2531          * @throws IllegalAccessException if access checking fails,
2532          *                                or if the method is {@code static},
2533          *                                or if the method&#39;s variable arity modifier bit
2534          *                                is set and {@code asVarargsCollector} fails
2535          * @throws NullPointerException if any argument is null
2536          */
2537         public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {
<span class="line-modified">2538             checkSpecialCaller(specialCaller, m.getDeclaringClass());</span>
2539             Lookup specialLookup = this.in(specialCaller);
2540             MemberName method = new MemberName(m, true);
2541             assert(method.isMethod());
2542             // ignore m.isAccessible:  this is a new kind of access
<span class="line-modified">2543             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));</span>
2544         }
2545 
2546         /**
2547          * Produces a method handle for a reflected constructor.
2548          * The type of the method handle will be that of the constructor,
2549          * with the return type changed to the declaring class.
2550          * The method handle will perform a {@code newInstance} operation,
2551          * creating a new instance of the constructor&#39;s class on the
2552          * arguments passed to the method handle.
2553          * &lt;p&gt;
2554          * If the constructor&#39;s {@code accessible} flag is not set,
2555          * access checking is performed immediately on behalf of the lookup class.
2556          * &lt;p&gt;
2557          * The returned method handle will have
2558          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
2559          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
2560          * &lt;p&gt;
2561          * If the returned method handle is invoked, the constructor&#39;s class will
2562          * be initialized, if it has not already been initialized.
2563          * @param c the reflected constructor
2564          * @return a method handle which can invoke the reflected constructor
2565          * @throws IllegalAccessException if access checking fails
2566          *                                or if the method&#39;s variable arity modifier bit
2567          *                                is set and {@code asVarargsCollector} fails
2568          * @throws NullPointerException if the argument is null
2569          */
2570         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
2571             MemberName ctor = new MemberName(c);
2572             assert(ctor.isConstructor());
2573             @SuppressWarnings(&quot;deprecation&quot;)
2574             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
2575             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);
2576         }
2577 
2578         /**
2579          * Produces a method handle giving read access to a reflected field.
2580          * The type of the method handle will have a return type of the field&#39;s
2581          * value type.
<span class="line-modified">2582          * If the field is {@code static}, the method handle will take no arguments.</span>
2583          * Otherwise, its single argument will be the instance containing
2584          * the field.
<span class="line-modified">2585          * If the {@code Field} object&#39;s {@code accessible} flag is not set,</span>
2586          * access checking is performed immediately on behalf of the lookup class.
2587          * &lt;p&gt;
2588          * If the field is static, and
2589          * if the returned method handle is invoked, the field&#39;s class will
2590          * be initialized, if it has not already been initialized.
2591          * @param f the reflected field
2592          * @return a method handle which can load values from the reflected field
2593          * @throws IllegalAccessException if access checking fails
2594          * @throws NullPointerException if the argument is null
2595          */
2596         public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
2597             return unreflectField(f, false);
2598         }









2599 
2600         /**
2601          * Produces a method handle giving write access to a reflected field.
2602          * The type of the method handle will have a void return type.
<span class="line-modified">2603          * If the field is {@code static}, the method handle will take a single</span>
2604          * argument, of the field&#39;s value type, the value to be stored.
2605          * Otherwise, the two arguments will be the instance containing
2606          * the field, and the value to be stored.
<span class="line-modified">2607          * If the {@code Field} object&#39;s {@code accessible} flag is not set,</span>
2608          * access checking is performed immediately on behalf of the lookup class.
2609          * &lt;p&gt;
<span class="line-modified">2610          * If the field is {@code final}, write access will not be</span>
<span class="line-added">2611          * allowed and access checking will fail, except under certain</span>
<span class="line-added">2612          * narrow circumstances documented for {@link Field#set Field.set}.</span>
<span class="line-added">2613          * A method handle is returned only if a corresponding call to</span>
<span class="line-added">2614          * the {@code Field} object&#39;s {@code set} method could return</span>
<span class="line-added">2615          * normally.  In particular, fields which are both {@code static}</span>
<span class="line-added">2616          * and {@code final} may never be set.</span>
<span class="line-added">2617          * &lt;p&gt;</span>
<span class="line-added">2618          * If the field is {@code static}, and</span>
2619          * if the returned method handle is invoked, the field&#39;s class will
2620          * be initialized, if it has not already been initialized.
2621          * @param f the reflected field
2622          * @return a method handle which can store values into the reflected field
<span class="line-modified">2623          * @throws IllegalAccessException if access checking fails,</span>
<span class="line-added">2624          *         or if the field is {@code final} and write access</span>
<span class="line-added">2625          *         is not enabled on the {@code Field} object</span>
2626          * @throws NullPointerException if the argument is null
2627          */
2628         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
2629             return unreflectField(f, true);
2630         }
2631 
<span class="line-added">2632         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {</span>
<span class="line-added">2633             MemberName field = new MemberName(f, isSetter);</span>
<span class="line-added">2634             if (isSetter &amp;&amp; field.isStatic() &amp;&amp; field.isFinal())</span>
<span class="line-added">2635                 throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>
<span class="line-added">2636             assert(isSetter</span>
<span class="line-added">2637                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())</span>
<span class="line-added">2638                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));</span>
<span class="line-added">2639             @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-added">2640             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;</span>
<span class="line-added">2641             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);</span>
<span class="line-added">2642         }</span>
<span class="line-added">2643 </span>
2644         /**
2645          * Produces a VarHandle giving access to a reflected field {@code f}
2646          * of type {@code T} declared in a class of type {@code R}.
2647          * The VarHandle&#39;s variable type is {@code T}.
2648          * If the field is non-static the VarHandle has one coordinate type,
2649          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
2650          * coordinate types.
2651          * &lt;p&gt;
2652          * Access checking is performed immediately on behalf of the lookup
2653          * class, regardless of the value of the field&#39;s {@code accessible}
2654          * flag.
2655          * &lt;p&gt;
2656          * If the field is static, and if the returned VarHandle is operated
2657          * on, the field&#39;s declaring class will be initialized, if it has not
2658          * already been initialized.
2659          * &lt;p&gt;
2660          * Certain access modes of the returned VarHandle are unsupported under
2661          * the following conditions:
2662          * &lt;ul&gt;
2663          * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
</pre>
<hr />
<pre>
2713          * @since 9
2714          */
2715         public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
2716             MemberName getField = new MemberName(f, false);
2717             MemberName putField = new MemberName(f, true);
2718             return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),
2719                                                       f.getDeclaringClass(), getField, putField);
2720         }
2721 
2722         /**
2723          * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
2724          * created by this lookup object or a similar one.
2725          * Security and access checks are performed to ensure that this lookup object
2726          * is capable of reproducing the target method handle.
2727          * This means that the cracking may fail if target is a direct method handle
2728          * but was created by an unrelated lookup object.
2729          * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
2730          * and was created by a lookup object for a different class.
2731          * @param target a direct method handle to crack into symbolic reference components
2732          * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
<span class="line-modified">2733          * @throws    SecurityException if a security manager is present and it</span>
2734          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2735          * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
<span class="line-modified">2736          * @throws    NullPointerException if the target is {@code null}</span>
2737          * @see MethodHandleInfo
2738          * @since 1.8
2739          */
2740         public MethodHandleInfo revealDirect(MethodHandle target) {
2741             MemberName member = target.internalMemberName();
2742             if (member == null || (!member.isResolved() &amp;&amp;
2743                                    !member.isMethodHandleInvoke() &amp;&amp;
2744                                    !member.isVarHandleMethodInvoke()))
2745                 throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
2746             Class&lt;?&gt; defc = member.getDeclaringClass();
2747             byte refKind = member.getReferenceKind();
2748             assert(MethodHandleNatives.refKindIsValid(refKind));
2749             if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
2750                 // Devirtualized method invocation is usually formally virtual.
2751                 // To avoid creating extra MemberName objects for this common case,
2752                 // we encode this extra degree of freedom using MH.isInvokeSpecial.
2753                 refKind = REF_invokeVirtual;
2754             if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
2755                 // Symbolic reference is through interface but resolves to Object method (toString, etc.)
2756                 refKind = REF_invokeInterface;
2757             // Check SM permissions and member access before cracking.
2758             try {
2759                 checkAccess(refKind, defc, member);
2760                 checkSecurityManager(defc, member);
2761             } catch (IllegalAccessException ex) {
2762                 throw new IllegalArgumentException(ex);
2763             }
2764             if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
2765                 Class&lt;?&gt; callerClass = target.internalCallerClass();
<span class="line-modified">2766                 if (!hasFullPrivilegeAccess() || callerClass != lookupClass())</span>
2767                     throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
2768             }
2769             // Produce the handle to the results.
2770             return new InfoFromMemberName(this, member, refKind);
2771         }
2772 
2773         /// Helper methods, all package-private.
2774 
2775         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
2776             checkSymbolicClass(refc);  // do this before attempting to resolve
2777             Objects.requireNonNull(name);
2778             Objects.requireNonNull(type);
2779             return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
2780                                             NoSuchFieldException.class);
2781         }
2782 
2783         MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2784             checkSymbolicClass(refc);  // do this before attempting to resolve
2785             Objects.requireNonNull(name);
2786             Objects.requireNonNull(type);
</pre>
<hr />
<pre>
2799 
2800         MemberName resolveOrNull(byte refKind, MemberName member) {
2801             // do this before attempting to resolve
2802             if (!isClassAccessible(member.getDeclaringClass())) {
2803                 return null;
2804             }
2805             Objects.requireNonNull(member.getName());
2806             Objects.requireNonNull(member.getType());
2807             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
2808         }
2809 
2810         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
2811             if (!isClassAccessible(refc)) {
2812                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
2813             }
2814         }
2815 
2816         boolean isClassAccessible(Class&lt;?&gt; refc) {
2817             Objects.requireNonNull(refc);
2818             Class&lt;?&gt; caller = lookupClassOrNull();
<span class="line-modified">2819             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);</span>
2820         }
2821 
2822         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
2823         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
2824             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)
2825                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);
2826         }
2827 
2828 
2829         /**
2830          * Find my trustable caller class if m is a caller sensitive method.
<span class="line-modified">2831          * If this lookup object has full privilege access, then the caller class is the lookupClass.</span>
2832          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
2833          */
<span class="line-modified">2834         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {</span>
<span class="line-modified">2835             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {</span>
<span class="line-modified">2836                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods</span>
<span class="line-modified">2837                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>





2838             }
<span class="line-modified">2839             return this;</span>
2840         }
2841 
2842         /**
<span class="line-modified">2843          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.</span>
<span class="line-modified">2844          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.</span>
<span class="line-added">2845          *</span>
<span class="line-added">2846          * @deprecated This method was originally designed to test {@code PRIVATE} access</span>
<span class="line-added">2847          * that implies full privilege access but {@code MODULE} access has since become</span>
<span class="line-added">2848          * independent of {@code PRIVATE} access.  It is recommended to call</span>
<span class="line-added">2849          * {@link #hasFullPrivilegeAccess()} instead.</span>
2850          * @since 9
2851          */
<span class="line-added">2852         @Deprecated(since=&quot;14&quot;)</span>
2853         public boolean hasPrivateAccess() {
<span class="line-modified">2854             return hasFullPrivilegeAccess();</span>
<span class="line-added">2855         }</span>
<span class="line-added">2856 </span>
<span class="line-added">2857         /**</span>
<span class="line-added">2858          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,</span>
<span class="line-added">2859          * i.e. {@code PRIVATE} and {@code MODULE} access.</span>
<span class="line-added">2860          * A {@code Lookup} object must have full privilege access in order to</span>
<span class="line-added">2861          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.</span>
<span class="line-added">2862          *</span>
<span class="line-added">2863          * @return {@code true} if this lookup has full privilege access.</span>
<span class="line-added">2864          * @since 14</span>
<span class="line-added">2865          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;</span>
<span class="line-added">2866          */</span>
<span class="line-added">2867         public boolean hasFullPrivilegeAccess() {</span>
<span class="line-added">2868             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);</span>
2869         }
2870 
2871         /**
2872          * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
2873          * Determines a trustable caller class to compare with refc, the symbolic reference class.
<span class="line-modified">2874          * If this lookup object has full privilege access, then the caller class is the lookupClass.</span>
2875          */
2876         void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
<span class="line-added">2877             if (allowedModes == TRUSTED)  return;</span>
<span class="line-added">2878 </span>
2879             SecurityManager smgr = System.getSecurityManager();
2880             if (smgr == null)  return;

2881 
2882             // Step 1:
<span class="line-modified">2883             boolean fullPowerLookup = hasFullPrivilegeAccess();</span>
2884             if (!fullPowerLookup ||
2885                 !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
2886                 ReflectUtil.checkPackageAccess(refc);
2887             }
2888 
2889             if (m == null) {  // findClass or accessClass
2890                 // Step 2b:
2891                 if (!fullPowerLookup) {
2892                     smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
2893                 }
2894                 return;
2895             }
2896 
2897             // Step 2a:
2898             if (m.isPublic()) return;
2899             if (!fullPowerLookup) {
2900                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
2901             }
2902 
2903             // Step 3:
</pre>
<hr />
<pre>
2952                 // All arrays simply inherit Object.clone.
2953                 // But for access checking logic, we make Object.clone
2954                 // (normally protected) appear to be public.
2955                 // Later on, when the DirectMethodHandle is created,
2956                 // its leading argument will be restricted to the
2957                 // requested array type.
2958                 // N.B. The return type is not adjusted, because
2959                 // that is *not* the bytecode behavior.
2960                 mods ^= Modifier.PROTECTED | Modifier.PUBLIC;
2961             }
2962             if (Modifier.isProtected(mods) &amp;&amp; refKind == REF_newInvokeSpecial) {
2963                 // cannot &quot;new&quot; a protected ctor in a different package
2964                 mods ^= Modifier.PROTECTED;
2965             }
2966             if (Modifier.isFinal(mods) &amp;&amp;
2967                     MethodHandleNatives.refKindIsSetter(refKind))
2968                 throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);
2969             int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE
2970             if ((requestedModes &amp; allowedModes) != 0) {
2971                 if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
<span class="line-modified">2972                                                     mods, lookupClass(), previousLookupClass(), allowedModes))</span>
2973                     return;
2974             } else {
2975                 // Protected members can also be checked as if they were package-private.
2976                 if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0
2977                         &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))
2978                     return;
2979             }
2980             throw m.makeAccessException(accessFailedMessage(refc, m), this);
2981         }
2982 
2983         String accessFailedMessage(Class&lt;?&gt; refc, MemberName m) {
2984             Class&lt;?&gt; defc = m.getDeclaringClass();
2985             int mods = m.getModifiers();
2986             // check the class first:
2987             boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
2988                                (defc == refc ||
2989                                 Modifier.isPublic(refc.getModifiers())));
2990             if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
<span class="line-modified">2991                 // ignore previous lookup class to check if default package access</span>
<span class="line-added">2992                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), null, FULL_POWER_MODES) &amp;&amp;</span>
2993                            (defc == refc ||
<span class="line-modified">2994                             VerifyAccess.isClassAccessible(refc, lookupClass(), null, FULL_POWER_MODES)));</span>
2995             }
2996             if (!classOK)
2997                 return &quot;class is not public&quot;;
2998             if (Modifier.isPublic(mods))
2999                 return &quot;access to public member failed&quot;;  // (how?, module not readable?)
3000             if (Modifier.isPrivate(mods))
3001                 return &quot;member is private&quot;;
3002             if (Modifier.isProtected(mods))
3003                 return &quot;member is protected&quot;;
3004             return &quot;member is private to package&quot;;
3005         }
3006 
3007         private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {
3008             int allowedModes = this.allowedModes;
3009             if (allowedModes == TRUSTED)  return;
<span class="line-modified">3010             if ((lookupModes() &amp; PRIVATE) == 0</span>
3011                 || (specialCaller != lookupClass()
3012                        // ensure non-abstract methods in superinterfaces can be special-invoked
3013                     &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))
3014                 throw new MemberName(specialCaller).
3015                     makeAccessException(&quot;no private access for invokespecial&quot;, this);
3016         }
3017 
3018         private boolean restrictProtectedReceiver(MemberName method) {
3019             // The accessing class only has the right to use a protected member
3020             // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
3021             if (!method.isProtected() || method.isStatic()
3022                 || allowedModes == TRUSTED
3023                 || method.getDeclaringClass() == lookupClass()
3024                 || VerifyAccess.isSamePackage(method.getDeclaringClass(), lookupClass()))
3025                 return false;
3026             return true;
3027         }
3028         private MethodHandle restrictReceiver(MemberName method, DirectMethodHandle mh, Class&lt;?&gt; caller) throws IllegalAccessException {
3029             assert(!method.isStatic());
3030             // receiver type of mh is too wide; narrow to caller
3031             if (!method.getDeclaringClass().isAssignableFrom(caller)) {
3032                 throw method.makeAccessException(&quot;caller class must be a subclass below the method&quot;, caller);
3033             }
3034             MethodType rawType = mh.type();
3035             if (caller.isAssignableFrom(rawType.parameterType(0))) return mh; // no need to restrict; already narrow
3036             MethodType narrowType = rawType.changeParameterType(0, caller);
3037             assert(!mh.isVarargsCollector());  // viewAsType will lose varargs-ness
3038             assert(mh.viewAsTypeChecks(narrowType, true));
3039             return mh.copyWith(narrowType, mh.form);
3040         }
3041 
3042         /** Check access and get the requested method. */
<span class="line-modified">3043         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
3044             final boolean doRestrict    = true;
3045             final boolean checkSecurity = true;
<span class="line-modified">3046             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);</span>
3047         }
3048         /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */
<span class="line-modified">3049         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
3050             final boolean doRestrict    = false;
3051             final boolean checkSecurity = true;
<span class="line-modified">3052             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);</span>
3053         }
3054         /** Check access and get the requested method, eliding security manager checks. */
<span class="line-modified">3055         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
3056             final boolean doRestrict    = true;
3057             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<span class="line-modified">3058             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);</span>
3059         }
3060         /** Common code for all methods; do not call directly except from immediately above. */
3061         private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
3062                                                    boolean checkSecurity,
<span class="line-modified">3063                                                    boolean doRestrict,</span>
<span class="line-modified">3064                                                    Lookup boundCaller) throws IllegalAccessException {</span>
3065             checkMethod(refKind, refc, method);
3066             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3067             if (checkSecurity)
3068                 checkSecurityManager(refc, method);
3069             assert(!method.isMethodHandleInvoke());
3070 
3071             if (refKind == REF_invokeSpecial &amp;&amp;
3072                 refc != lookupClass() &amp;&amp;
3073                 !refc.isInterface() &amp;&amp;
3074                 refc != lookupClass().getSuperclass() &amp;&amp;
3075                 refc.isAssignableFrom(lookupClass())) {
3076                 assert(!method.getName().equals(&quot;&lt;init&gt;&quot;));  // not this code path
3077 
3078                 // Per JVMS 6.5, desc. of invokespecial instruction:
3079                 // If the method is in a superclass of the LC,
3080                 // and if our original search was above LC.super,
3081                 // repeat the search (symbolic lookup) from LC.super
3082                 // and continue with the direct superclass of that class,
3083                 // and so forth, until a match is found or no further superclasses exist.
3084                 // FIXME: MemberName.resolve should handle this instead.
3085                 Class&lt;?&gt; refcAsSuper = lookupClass();
3086                 MemberName m2;
3087                 do {
3088                     refcAsSuper = refcAsSuper.getSuperclass();
3089                     m2 = new MemberName(refcAsSuper,
3090                                         method.getName(),
3091                                         method.getMethodType(),
3092                                         REF_invokeSpecial);
3093                     m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());
3094                 } while (m2 == null &amp;&amp;         // no method is found yet
3095                          refc != refcAsSuper); // search up to refc
3096                 if (m2 == null)  throw new InternalError(method.toString());
3097                 method = m2;
3098                 refc = refcAsSuper;
3099                 // redo basic checks
3100                 checkMethod(refKind, refc, method);
3101             }

3102             DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
3103             MethodHandle mh = dmh;
3104             // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
3105             if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||
3106                     (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {
3107                 mh = restrictReceiver(method, dmh, lookupClass());
3108             }
<span class="line-modified">3109             mh = maybeBindCaller(method, mh, boundCaller);</span>
3110             mh = mh.setVarargs(method);
3111             return mh;
3112         }
<span class="line-modified">3113         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh, Lookup boundCaller)</span>

3114                                              throws IllegalAccessException {
<span class="line-modified">3115             if (boundCaller.allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))</span>
3116                 return mh;
<span class="line-modified">3117 </span>
<span class="line-modified">3118             // boundCaller must have full privilege access.</span>
<span class="line-modified">3119             // It should have been checked by findBoundCallerLookup. Safe to check this again.</span>
<span class="line-modified">3120             if (!boundCaller.hasFullPrivilegeAccess())</span>
<span class="line-added">3121                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>
<span class="line-added">3122 </span>
<span class="line-added">3123             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, boundCaller.lookupClass);</span>
3124             // Note: caller will apply varargs after this step happens.
3125             return cbmh;
3126         }
<span class="line-added">3127 </span>
3128         /** Check access and get the requested field. */
3129         private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3130             final boolean checkSecurity = true;
3131             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3132         }
3133         /** Check access and get the requested field, eliding security manager checks. */
3134         private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
3135             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3136             return getDirectFieldCommon(refKind, refc, field, checkSecurity);
3137         }
3138         /** Common code for all fields; do not call directly except from immediately above. */
3139         private MethodHandle getDirectFieldCommon(byte refKind, Class&lt;?&gt; refc, MemberName field,
3140                                                   boolean checkSecurity) throws IllegalAccessException {
3141             checkField(refKind, refc, field);
3142             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3143             if (checkSecurity)
3144                 checkSecurityManager(refc, field);
3145             DirectMethodHandle dmh = DirectMethodHandle.make(refc, field);
3146             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp;
3147                                     restrictProtectedReceiver(field));
</pre>
<hr />
<pre>
3203         /** Check access and get the requested constructor, eliding security manager checks. */
3204         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3205             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3206             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3207         }
3208         /** Common code for all constructors; do not call directly except from immediately above. */
3209         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3210                                                   boolean checkSecurity) throws IllegalAccessException {
3211             assert(ctor.isConstructor());
3212             checkAccess(REF_newInvokeSpecial, refc, ctor);
3213             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3214             if (checkSecurity)
3215                 checkSecurityManager(refc, ctor);
3216             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3217             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3218         }
3219 
3220         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3221          */
3222         /*non-public*/
<span class="line-modified">3223         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)</span>
<span class="line-added">3224                 throws ReflectiveOperationException {</span>
3225             if (!(type instanceof Class || type instanceof MethodType))
3226                 throw new InternalError(&quot;unresolved MemberName&quot;);
3227             MemberName member = new MemberName(refKind, defc, name, type);
3228             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3229             if (mh != null) {
3230                 checkSymbolicClass(defc);
3231                 return mh;
3232             }
3233             if (defc == MethodHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3234                 // Treat MethodHandle.invoke and invokeExact specially.
3235                 mh = findVirtualForMH(member.getName(), member.getMethodType());
3236                 if (mh != null) {
3237                     return mh;
3238                 }
3239             } else if (defc == VarHandle.class &amp;&amp; refKind == REF_invokeVirtual) {
3240                 // Treat signature-polymorphic methods on VarHandle specially.
3241                 mh = findVirtualForVH(member.getName(), member.getMethodType());
3242                 if (mh != null) {
3243                     return mh;
3244                 }
3245             }
3246             MemberName resolved = resolveOrFail(refKind, member);
3247             mh = getDirectMethodForConstant(refKind, defc, resolved);
3248             if (mh instanceof DirectMethodHandle
3249                     &amp;&amp; canBeCached(refKind, defc, resolved)) {
3250                 MemberName key = mh.internalMemberName();
3251                 if (key != null) {
3252                     key = key.asNormalOriginal();
3253                 }
3254                 if (member.equals(key)) {  // better safe than sorry
3255                     LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);
3256                 }
3257             }
3258             return mh;
3259         }
<span class="line-modified">3260         private boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {</span>

3261             if (refKind == REF_invokeSpecial) {
3262                 return false;
3263             }
3264             if (!Modifier.isPublic(defc.getModifiers()) ||
3265                     !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
3266                     !member.isPublic() ||
3267                     member.isCallerSensitive()) {
3268                 return false;
3269             }
3270             ClassLoader loader = defc.getClassLoader();
3271             if (loader != null) {
3272                 ClassLoader sysl = ClassLoader.getSystemClassLoader();
3273                 boolean found = false;
3274                 while (sysl != null) {
3275                     if (loader == sysl) { found = true; break; }
3276                     sysl = sysl.getParent();
3277                 }
3278                 if (!found) {
3279                     return false;
3280                 }
3281             }
3282             try {
3283                 MemberName resolved2 = publicLookup().resolveOrNull(refKind,
3284                     new MemberName(refKind, defc, member.getName(), member.getType()));
3285                 if (resolved2 == null) {
3286                     return false;
3287                 }
3288                 checkSecurityManager(defc, resolved2);
3289             } catch (SecurityException ex) {
3290                 return false;
3291             }
3292             return true;
3293         }
<span class="line-modified">3294         private MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)</span>

3295                 throws ReflectiveOperationException {
3296             if (MethodHandleNatives.refKindIsField(refKind)) {
3297                 return getDirectFieldNoSecurityManager(refKind, defc, member);
3298             } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
<span class="line-modified">3299                 return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));</span>
3300             } else if (refKind == REF_newInvokeSpecial) {
3301                 return getDirectConstructorNoSecurityManager(defc, member);
3302             }
3303             // oops
3304             throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
3305         }
3306 
3307         static ConcurrentHashMap&lt;MemberName, DirectMethodHandle&gt; LOOKASIDE_TABLE = new ConcurrentHashMap&lt;&gt;();
3308     }
3309 
3310     /**
3311      * Produces a method handle constructing arrays of a desired type,
3312      * as if by the {@code anewarray} bytecode.
3313      * The return type of the method handle will be the array type.
3314      * The type of its sole argument will be {@code int}, which specifies the size of the array.
3315      *
3316      * &lt;p&gt; If the returned method handle is invoked with a negative
3317      * array size, a {@code NegativeArraySizeException} will be thrown.
3318      *
3319      * @param arrayClass an array type
3320      * @return a method handle which can create arrays of the given type
3321      * @throws NullPointerException if the argument is {@code null}
3322      * @throws IllegalArgumentException if {@code arrayClass} is not an array type
3323      * @see java.lang.reflect.Array#newInstance(Class, int)
3324      * @jvms 6.5 {@code anewarray} Instruction
3325      * @since 9
3326      */
<span class="line-modified">3327     public static MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>

3328         if (!arrayClass.isArray()) {
3329             throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
3330         }
3331         MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
3332                 bindTo(arrayClass.getComponentType());
3333         return ani.asType(ani.type().changeReturnType(arrayClass));
3334     }
3335 
3336     /**
3337      * Produces a method handle returning the length of an array,
3338      * as if by the {@code arraylength} bytecode.
3339      * The type of the method handle will have {@code int} as return type,
3340      * and its sole argument will be the array type.
3341      *
3342      * &lt;p&gt; If the returned method handle is invoked with a {@code null}
3343      * array reference, a {@code NullPointerException} will be thrown.
3344      *
3345      * @param arrayClass an array type
3346      * @return a method handle which can retrieve the length of an array of the given array type
3347      * @throws NullPointerException if the argument is {@code null}
3348      * @throws IllegalArgumentException if arrayClass is not an array type
3349      * @jvms 6.5 {@code arraylength} Instruction
3350      * @since 9
3351      */
<span class="line-modified">3352     public static MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>

3353         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
3354     }
3355 
3356     /**
3357      * Produces a method handle giving read access to elements of an array,
3358      * as if by the {@code aaload} bytecode.
3359      * The type of the method handle will have a return type of the array&#39;s
3360      * element type.  Its first argument will be the array type,
3361      * and the second will be {@code int}.
3362      *
3363      * &lt;p&gt; When the returned method handle is invoked,
3364      * the array reference and array index are checked.
3365      * A {@code NullPointerException} will be thrown if the array reference
3366      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3367      * thrown if the index is negative or if it is greater than or equal to
3368      * the length of the array.
3369      *
3370      * @param arrayClass an array type
3371      * @return a method handle which can load values from the given array type
3372      * @throws NullPointerException if the argument is null
3373      * @throws  IllegalArgumentException if arrayClass is not an array type
3374      * @jvms 6.5 {@code aaload} Instruction
3375      */
<span class="line-modified">3376     public static MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>

3377         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
3378     }
3379 
3380     /**
3381      * Produces a method handle giving write access to elements of an array,
3382      * as if by the {@code astore} bytecode.
3383      * The type of the method handle will have a void return type.
3384      * Its last argument will be the array&#39;s element type.
3385      * The first and second arguments will be the array type and int.
3386      *
3387      * &lt;p&gt; When the returned method handle is invoked,
3388      * the array reference and array index are checked.
3389      * A {@code NullPointerException} will be thrown if the array reference
3390      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3391      * thrown if the index is negative or if it is greater than or equal to
3392      * the length of the array.
3393      *
3394      * @param arrayClass the class of an array
3395      * @return a method handle which can store values into the array type
3396      * @throws NullPointerException if the argument is null
3397      * @throws IllegalArgumentException if arrayClass is not an array type
3398      * @jvms 6.5 {@code aastore} Instruction
3399      */
<span class="line-modified">3400     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>

3401         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3402     }
3403 
3404     /**
3405      * Produces a VarHandle giving access to elements of an array of type
3406      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3407      * of {@code arrayClass} and the list of coordinate types is
3408      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3409      * corresponds to an argument that is an index into an array.
3410      * &lt;p&gt;
3411      * Certain access modes of the returned VarHandle are unsupported under
3412      * the following conditions:
3413      * &lt;ul&gt;
3414      * &lt;li&gt;if the component type is anything other than {@code byte},
3415      *     {@code short}, {@code char}, {@code int}, {@code long},
3416      *     {@code float}, or {@code double} then numeric atomic update access
3417      *     modes are unsupported.
3418      * &lt;li&gt;if the field type is anything other than {@code boolean},
3419      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3420      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
3444      * unexpectedly fail.
3445      * There are many possible NaN values that are considered to be
3446      * {@code NaN} in Java, although no IEEE 754 floating-point operation
3447      * provided by Java can distinguish between them.  Operation failure can
3448      * occur if the expected or witness value is a NaN value and it is
3449      * transformed (perhaps in a platform specific manner) into another NaN
3450      * value, and thus has a different bitwise representation (see
3451      * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
3452      * details).
3453      * The values {@code -0.0} and {@code +0.0} have different bitwise
3454      * representations but are considered equal when using the primitive
3455      * {@code ==} operator.  Operation failure can occur if, for example, a
3456      * numeric algorithm computes an expected value to be say {@code -0.0}
3457      * and previously computed the witness value to be say {@code +0.0}.
3458      * @param arrayClass the class of an array, of type {@code T[]}
3459      * @return a VarHandle giving access to elements of an array
3460      * @throws NullPointerException if the arrayClass is null
3461      * @throws IllegalArgumentException if arrayClass is not an array type
3462      * @since 9
3463      */
<span class="line-modified">3464     public static VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>

3465         return VarHandles.makeArrayElementHandle(arrayClass);
3466     }
3467 
3468     /**
3469      * Produces a VarHandle giving access to elements of a {@code byte[]} array
3470      * viewed as if it were a different primitive array type, such as
3471      * {@code int[]} or {@code long[]}.
3472      * The VarHandle&#39;s variable type is the component type of
3473      * {@code viewArrayClass} and the list of coordinate types is
3474      * {@code (byte[], int)}, where the {@code int} coordinate type
3475      * corresponds to an argument that is an index into a {@code byte[]} array.
3476      * The returned VarHandle accesses bytes at an index in a {@code byte[]}
3477      * array, composing bytes to or from a value of the component type of
3478      * {@code viewArrayClass} according to the given endianness.
3479      * &lt;p&gt;
3480      * The supported component types (variables types) are {@code short},
3481      * {@code char}, {@code int}, {@code long}, {@code float} and
3482      * {@code double}.
3483      * &lt;p&gt;
3484      * Access of bytes at a given index will result in an
</pre>
<hr />
<pre>
3524      * boolean isMisaligned = misalignedAtIndex != 0;
3525      * }&lt;/pre&gt;
3526      * &lt;p&gt;
3527      * If the variable type is {@code float} or {@code double} then atomic
3528      * update access modes compare values using their bitwise representation
3529      * (see {@link Float#floatToRawIntBits} and
3530      * {@link Double#doubleToRawLongBits}, respectively).
3531      * @param viewArrayClass the view array class, with a component type of
3532      * type {@code T}
3533      * @param byteOrder the endianness of the view array elements, as
3534      * stored in the underlying {@code byte} array
3535      * @return a VarHandle giving access to elements of a {@code byte[]} array
3536      * viewed as if elements corresponding to the components type of the view
3537      * array class
3538      * @throws NullPointerException if viewArrayClass or byteOrder is null
3539      * @throws IllegalArgumentException if viewArrayClass is not an array type
3540      * @throws UnsupportedOperationException if the component type of
3541      * viewArrayClass is not supported as a variable type
3542      * @since 9
3543      */
<span class="line-modified">3544     public static VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>

3545                                      ByteOrder byteOrder) throws IllegalArgumentException {
3546         Objects.requireNonNull(byteOrder);
3547         return VarHandles.byteArrayViewHandle(viewArrayClass,
3548                                               byteOrder == ByteOrder.BIG_ENDIAN);
3549     }
3550 
3551     /**
3552      * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
3553      * viewed as if it were an array of elements of a different primitive
3554      * component type to that of {@code byte}, such as {@code int[]} or
3555      * {@code long[]}.
3556      * The VarHandle&#39;s variable type is the component type of
3557      * {@code viewArrayClass} and the list of coordinate types is
3558      * {@code (ByteBuffer, int)}, where the {@code int} coordinate type
3559      * corresponds to an argument that is an index into a {@code byte[]} array.
3560      * The returned VarHandle accesses bytes at an index in a
3561      * {@code ByteBuffer}, composing bytes to or from a value of the component
3562      * type of {@code viewArrayClass} according to the given endianness.
3563      * &lt;p&gt;
3564      * The supported component types (variables types) are {@code short},
</pre>
<hr />
<pre>
3611      * }&lt;/pre&gt;
3612      * &lt;p&gt;
3613      * If the variable type is {@code float} or {@code double} then atomic
3614      * update access modes compare values using their bitwise representation
3615      * (see {@link Float#floatToRawIntBits} and
3616      * {@link Double#doubleToRawLongBits}, respectively).
3617      * @param viewArrayClass the view array class, with a component type of
3618      * type {@code T}
3619      * @param byteOrder the endianness of the view array elements, as
3620      * stored in the underlying {@code ByteBuffer} (Note this overrides the
3621      * endianness of a {@code ByteBuffer})
3622      * @return a VarHandle giving access to elements of a {@code ByteBuffer}
3623      * viewed as if elements corresponding to the components type of the view
3624      * array class
3625      * @throws NullPointerException if viewArrayClass or byteOrder is null
3626      * @throws IllegalArgumentException if viewArrayClass is not an array type
3627      * @throws UnsupportedOperationException if the component type of
3628      * viewArrayClass is not supported as a variable type
3629      * @since 9
3630      */
<span class="line-modified">3631     public static VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>

3632                                       ByteOrder byteOrder) throws IllegalArgumentException {
3633         Objects.requireNonNull(byteOrder);
3634         return VarHandles.makeByteBufferViewHandle(viewArrayClass,
3635                                                    byteOrder == ByteOrder.BIG_ENDIAN);
3636     }
3637 
3638 
3639     /// method handle invocation (reflective style)
3640 
3641     /**
3642      * Produces a method handle which will invoke any method handle of the
3643      * given {@code type}, with a given number of trailing arguments replaced by
3644      * a single trailing {@code Object[]} array.
3645      * The resulting invoker will be a method handle with the following
3646      * arguments:
3647      * &lt;ul&gt;
3648      * &lt;li&gt;a single {@code MethodHandle} target
3649      * &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
3650      * &lt;li&gt;an {@code Object[]} array containing trailing arguments
3651      * &lt;/ul&gt;
</pre>
<hr />
<pre>
3667      * not have the correct number of elements, the invoker will throw
3668      * an {@link IllegalArgumentException} instead of invoking the target.
3669      * &lt;p&gt;
3670      * This method is equivalent to the following code (though it may be more efficient):
3671      * &lt;blockquote&gt;&lt;pre&gt;{@code
3672 MethodHandle invoker = MethodHandles.invoker(type);
3673 int spreadArgCount = type.parameterCount() - leadingArgCount;
3674 invoker = invoker.asSpreader(Object[].class, spreadArgCount);
3675 return invoker;
3676      * }&lt;/pre&gt;&lt;/blockquote&gt;
3677      * This method throws no reflective or security exceptions.
3678      * @param type the desired target type
3679      * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target
3680      * @return a method handle suitable for invoking any method handle of the given type
3681      * @throws NullPointerException if {@code type} is null
3682      * @throws IllegalArgumentException if {@code leadingArgCount} is not in
3683      *                  the range from 0 to {@code type.parameterCount()} inclusive,
3684      *                  or if the resulting method handle&#39;s type would have
3685      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3686      */
<span class="line-modified">3687     public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {</span>

3688         if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
3689             throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
3690         type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
3691         return type.invokers().spreadInvoker(leadingArgCount);
3692     }
3693 
3694     /**
3695      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3696      * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
3697      * The resulting invoker will have a type which is
3698      * exactly equal to the desired type, except that it will accept
3699      * an additional leading argument of type {@code MethodHandle}.
3700      * &lt;p&gt;
3701      * This method is equivalent to the following code (though it may be more efficient):
3702      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}
3703      *
3704      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3705      * &lt;em&gt;Discussion:&lt;/em&gt;
3706      * Invoker method handles can be useful when working with variable method handles
3707      * of unknown types.
</pre>
<hr />
<pre>
3709      * handle {@code M}, extract its type {@code T},
3710      * look up the invoker method {@code X} for {@code T},
3711      * and call the invoker method, as {@code X.invoke(T, A...)}.
3712      * (It would not work to call {@code X.invokeExact}, since the type {@code T}
3713      * is unknown.)
3714      * If spreading, collecting, or other argument transformations are required,
3715      * they can be applied once to the invoker {@code X} and reused on many {@code M}
3716      * method handle values, as long as they are compatible with the type of {@code X}.
3717      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3718      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
3719      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
3720      * on the declared {@code invokeExact} or {@code invoke} method will raise an
3721      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
3722      * &lt;p&gt;
3723      * This method throws no reflective or security exceptions.
3724      * @param type the desired target type
3725      * @return a method handle suitable for invoking any method handle of the given type
3726      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
3727      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3728      */
<span class="line-modified">3729     public static MethodHandle exactInvoker(MethodType type) {</span>

3730         return type.invokers().exactInvoker();
3731     }
3732 
3733     /**
3734      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3735      * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
3736      * The resulting invoker will have a type which is
3737      * exactly equal to the desired type, except that it will accept
3738      * an additional leading argument of type {@code MethodHandle}.
3739      * &lt;p&gt;
3740      * Before invoking its target, if the target differs from the expected type,
3741      * the invoker will apply reference casts as
3742      * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
3743      * Similarly, the return value will be converted as necessary.
3744      * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
3745      * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
3746      * &lt;p&gt;
3747      * This method is equivalent to the following code (though it may be more efficient):
3748      * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
3749      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3750      * &lt;em&gt;Discussion:&lt;/em&gt;
3751      * A {@linkplain MethodType#genericMethodType general method type} is one which
3752      * mentions only {@code Object} arguments and return values.
3753      * An invoker for such a type is capable of calling any method handle
3754      * of the same arity as the general type.
3755      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
3756      * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
3757      * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
3758      * on the declared {@code invokeExact} or {@code invoke} method will raise an
3759      * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
3760      * &lt;p&gt;
3761      * This method throws no reflective or security exceptions.
3762      * @param type the desired target type
3763      * @return a method handle suitable for invoking any method handle convertible to the given type
3764      * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
3765      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
3766      */
<span class="line-modified">3767     public static MethodHandle invoker(MethodType type) {</span>

3768         return type.invokers().genericInvoker();
3769     }
3770 
3771     /**
3772      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3773      * invoke a signature-polymorphic access mode method on any VarHandle whose
3774      * associated access mode type is compatible with the given type.
3775      * The resulting invoker will have a type which is exactly equal to the
3776      * desired given type, except that it will accept an additional leading
3777      * argument of type {@code VarHandle}.
3778      *
3779      * @param accessMode the VarHandle access mode
3780      * @param type the desired target type
3781      * @return a method handle suitable for invoking an access mode method of
3782      *         any VarHandle whose access mode type is of the given type.
3783      * @since 9
3784      */
<span class="line-modified">3785     public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>

3786         return type.invokers().varHandleMethodExactInvoker(accessMode);
3787     }
3788 
3789     /**
3790      * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
3791      * invoke a signature-polymorphic access mode method on any VarHandle whose
3792      * associated access mode type is compatible with the given type.
3793      * The resulting invoker will have a type which is exactly equal to the
3794      * desired given type, except that it will accept an additional leading
3795      * argument of type {@code VarHandle}.
3796      * &lt;p&gt;
3797      * Before invoking its target, if the access mode type differs from the
3798      * desired given type, the invoker will apply reference casts as necessary
3799      * and box, unbox, or widen primitive values, as if by
3800      * {@link MethodHandle#asType asType}.  Similarly, the return value will be
3801      * converted as necessary.
3802      * &lt;p&gt;
3803      * This method is equivalent to the following code (though it may be more
3804      * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
3805      *
3806      * @param accessMode the VarHandle access mode
3807      * @param type the desired target type
3808      * @return a method handle suitable for invoking an access mode method of
3809      *         any VarHandle whose access mode type is convertible to the given
3810      *         type.
3811      * @since 9
3812      */
<span class="line-modified">3813     public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>

3814         return type.invokers().varHandleMethodInvoker(accessMode);
3815     }
3816 
<span class="line-modified">3817     /*non-public*/</span>
<span class="line-modified">3818     static MethodHandle basicInvoker(MethodType type) {</span>
3819         return type.invokers().basicInvoker();
3820     }
3821 
3822      /// method handle modification (creation from other method handles)
3823 
3824     /**
3825      * Produces a method handle which adapts the type of the
3826      * given method handle to a new type by pairwise argument and return type conversion.
3827      * The original type and new type must have the same number of arguments.
3828      * The resulting method handle is guaranteed to report a type
3829      * which is equal to the desired new type.
3830      * &lt;p&gt;
3831      * If the original type and new type are equal, returns target.
3832      * &lt;p&gt;
3833      * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
3834      * and some additional conversions are also applied if those conversions fail.
3835      * Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
3836      * if possible, before or instead of any conversions done by {@code asType}:
3837      * &lt;ul&gt;
3838      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
</pre>
<hr />
<pre>
3848      *     then a Java casting conversion (JLS 5.5) is applied.
3849      *     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
3850      *     widening and/or narrowing.)
3851      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
3852      *     conversion will be applied at runtime, possibly followed
3853      *     by a Java casting conversion (JLS 5.5) on the primitive value,
3854      *     possibly followed by a conversion from byte to boolean by testing
3855      *     the low-order bit.
3856      * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
3857      *     and if the reference is null at runtime, a zero value is introduced.
3858      * &lt;/ul&gt;
3859      * @param target the method handle to invoke after arguments are retyped
3860      * @param newType the expected type of the new method handle
3861      * @return a method handle which delegates to the target after performing
3862      *           any necessary argument conversions, and arranges for any
3863      *           necessary return value conversions
3864      * @throws NullPointerException if either argument is null
3865      * @throws WrongMethodTypeException if the conversion cannot be made
3866      * @see MethodHandle#asType
3867      */
<span class="line-modified">3868     public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {</span>

3869         explicitCastArgumentsChecks(target, newType);
3870         // use the asTypeCache when possible:
3871         MethodType oldType = target.type();
3872         if (oldType == newType)  return target;
3873         if (oldType.explicitCastEquivalentToAsType(newType)) {
3874             return target.asFixedArity().asType(newType);
3875         }
3876         return MethodHandleImpl.makePairwiseConvert(target, newType, false);
3877     }
3878 
3879     private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType) {
3880         if (target.type().parameterCount() != newType.parameterCount()) {
3881             throw new WrongMethodTypeException(&quot;cannot explicitly cast &quot; + target + &quot; to &quot; + newType);
3882         }
3883     }
3884 
3885     /**
3886      * Produces a method handle which adapts the calling sequence of the
3887      * given method handle to a new type, by reordering the arguments.
3888      * The resulting method handle is guaranteed to report a type
</pre>
<hr />
<pre>
3927 assert(add.type().equals(intfn2));
3928 MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
3929 assert(twice.type().equals(intfn1));
3930 assert((int)twice.invokeExact(21) == 42);
3931      * }&lt;/pre&gt;&lt;/blockquote&gt;
3932      * &lt;p&gt;
3933      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
3934      * variable-arity method handle}, even if the original target method handle was.
3935      * @param target the method handle to invoke after arguments are reordered
3936      * @param newType the expected type of the new method handle
3937      * @param reorder an index array which controls the reordering
3938      * @return a method handle which delegates to the target after it
3939      *           drops unused arguments and moves and/or duplicates the other arguments
3940      * @throws NullPointerException if any argument is null
3941      * @throws IllegalArgumentException if the index array length is not equal to
3942      *                  the arity of the target, or if any index array element
3943      *                  not a valid index for a parameter of {@code newType},
3944      *                  or if two corresponding parameter types in
3945      *                  {@code target.type()} and {@code newType} are not identical,
3946      */
<span class="line-modified">3947     public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {</span>

3948         reorder = reorder.clone();  // get a private copy
3949         MethodType oldType = target.type();
3950         permuteArgumentChecks(reorder, newType, oldType);
3951         // first detect dropped arguments and handle them separately
3952         int[] originalReorder = reorder;
3953         BoundMethodHandle result = target.rebind();
3954         LambdaForm form = result.form;
3955         int newArity = newType.parameterCount();
3956         // Normalize the reordering into a real permutation,
3957         // by removing duplicates and adding dropped elements.
3958         // This somewhat improves lambda form caching, as well
3959         // as simplifying the transform by breaking it up into steps.
3960         for (int ddIdx; (ddIdx = findFirstDupOrDrop(reorder, newArity)) != 0; ) {
3961             if (ddIdx &gt; 0) {
3962                 // We found a duplicated entry at reorder[ddIdx].
3963                 // Example:  (x,y,z)-&gt;asList(x,y,z)
3964                 // permuted by [1*,0,1] =&gt; (a0,a1)=&gt;asList(a1,a0,a1)
3965                 // permuted by [0,1,0*] =&gt; (a0,a1)=&gt;asList(a0,a1,a0)
3966                 // The starred element corresponds to the argument
3967                 // deleted by the dupArgumentForm transform.
</pre>
<hr />
<pre>
4086             if (!bad)  return true;
4087         }
4088         throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
4089     }
4090 
4091     /**
4092      * Produces a method handle of the requested return type which returns the given
4093      * constant value every time it is invoked.
4094      * &lt;p&gt;
4095      * Before the method handle is returned, the passed-in value is converted to the requested type.
4096      * If the requested type is primitive, widening primitive conversions are attempted,
4097      * else reference conversions are attempted.
4098      * &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
4099      * @param type the return type of the desired method handle
4100      * @param value the value to return
4101      * @return a method handle of the given return type and no arguments, which always returns the given value
4102      * @throws NullPointerException if the {@code type} argument is null
4103      * @throws ClassCastException if the value cannot be converted to the required return type
4104      * @throws IllegalArgumentException if the given type is {@code void.class}
4105      */
<span class="line-modified">4106     public static MethodHandle constant(Class&lt;?&gt; type, Object value) {</span>

4107         if (type.isPrimitive()) {
4108             if (type == void.class)
4109                 throw newIllegalArgumentException(&quot;void type&quot;);
4110             Wrapper w = Wrapper.forPrimitiveType(type);
4111             value = w.convert(value, type);
4112             if (w.zero().equals(value))
4113                 return zero(w, type);
4114             return insertArguments(identity(type), 0, value);
4115         } else {
4116             if (value == null)
4117                 return zero(Wrapper.OBJECT, type);
4118             return identity(type).bindTo(value);
4119         }
4120     }
4121 
4122     /**
4123      * Produces a method handle which returns its sole argument when invoked.
4124      * @param type the type of the sole parameter and return value of the desired method handle
4125      * @return a unary method handle which accepts and returns the given type
4126      * @throws NullPointerException if the argument is null
4127      * @throws IllegalArgumentException if the given type is {@code void.class}
4128      */
<span class="line-modified">4129     public static MethodHandle identity(Class&lt;?&gt; type) {</span>

4130         Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
4131         int pos = btw.ordinal();
4132         MethodHandle ident = IDENTITY_MHS[pos];
4133         if (ident == null) {
4134             ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
4135         }
4136         if (ident.type().returnType() == type)
4137             return ident;
4138         // something like identity(Foo.class); do not bother to intern these
4139         assert (btw == Wrapper.OBJECT);
4140         return makeIdentity(type);
4141     }
4142 
4143     /**
4144      * Produces a constant method handle of the requested return type which
4145      * returns the default value for that type every time it is invoked.
4146      * The resulting constant method handle will have no side effects.
4147      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4148      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4149      * since {@code explicitCastArguments} converts {@code null} to default values.
</pre>
<hr />
<pre>
4239      * The {@code pos} argument selects which parameters are to be bound.
4240      * It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
4241      * where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
4242      * and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
4243      * &lt;p&gt;
4244      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4245      * variable-arity method handle}, even if the original target method handle was.
4246      * @param target the method handle to invoke after the argument is inserted
4247      * @param pos where to insert the argument (zero for the first)
4248      * @param values the series of arguments to insert
4249      * @return a method handle which inserts an additional argument,
4250      *         before calling the original method handle
4251      * @throws NullPointerException if the target or the {@code values} array is null
4252      * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than
4253      *         {@code N - L} where {@code N} is the arity of the target method handle and {@code L}
4254      *         is the length of the values array.
4255      * @throws ClassCastException if an argument does not match the corresponding bound parameter
4256      *         type.
4257      * @see MethodHandle#bindTo
4258      */
<span class="line-modified">4259     public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {</span>

4260         int insCount = values.length;
4261         Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
4262         if (insCount == 0)  return target;
4263         BoundMethodHandle result = target.rebind();
4264         for (int i = 0; i &lt; insCount; i++) {
4265             Object value = values[i];
4266             Class&lt;?&gt; ptype = ptypes[pos+i];
4267             if (ptype.isPrimitive()) {
4268                 result = insertArgumentPrimitive(result, pos, ptype, value);
4269             } else {
4270                 value = ptype.cast(value);  // throw CCE if needed
4271                 result = result.bindArgumentL(pos, value);
4272             }
4273         }
4274         return result;
4275     }
4276 
4277     private static BoundMethodHandle insertArgumentPrimitive(BoundMethodHandle result, int pos,
4278                                                              Class&lt;?&gt; ptype, Object value) {
4279         Wrapper w = Wrapper.forPrimitiveType(ptype);
</pre>
<hr />
<pre>
4314      * &lt;p&gt;
4315      * &lt;b&gt;Example:&lt;/b&gt;
4316      * &lt;blockquote&gt;&lt;pre&gt;{@code
4317 import static java.lang.invoke.MethodHandles.*;
4318 import static java.lang.invoke.MethodType.*;
4319 ...
4320 MethodHandle cat = lookup().findVirtual(String.class,
4321   &quot;concat&quot;, methodType(String.class, String.class));
4322 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
4323 MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
4324 MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
4325 assertEquals(bigType, d0.type());
4326 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4327      * }&lt;/pre&gt;&lt;/blockquote&gt;
4328      * &lt;p&gt;
4329      * This method is also equivalent to the following code:
4330      * &lt;blockquote&gt;&lt;pre&gt;
4331      * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
4332      * &lt;/pre&gt;&lt;/blockquote&gt;
4333      * @param target the method handle to invoke after the arguments are dropped

4334      * @param pos position of first argument to drop (zero for the leftmost)
<span class="line-added">4335      * @param valueTypes the type(s) of the argument(s) to drop</span>
4336      * @return a method handle which drops arguments of the given types,
4337      *         before calling the original method handle
4338      * @throws NullPointerException if the target is null,
4339      *                              or if the {@code valueTypes} list or any of its elements is null
4340      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
4341      *                  or if {@code pos} is negative or greater than the arity of the target,
4342      *                  or if the new method handle&#39;s type would have too many parameters
4343      */
<span class="line-modified">4344     public static MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>

4345         return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
4346     }
4347 
4348     private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
4349         return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
4350     }
4351 
<span class="line-modified">4352     private static MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>

4353         MethodType oldType = target.type();  // get NPE
4354         int dropped = dropArgumentChecks(oldType, pos, valueTypes);
4355         MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
4356         if (dropped == 0)  return target;
4357         BoundMethodHandle result = target.rebind();
4358         LambdaForm lform = result.form;
4359         int insertFormArg = 1 + pos;
4360         for (Class&lt;?&gt; ptype : valueTypes) {
4361             lform = lform.editor().addArgumentForm(insertFormArg++, BasicType.basicType(ptype));
4362         }
4363         result = result.copyWith(newType, lform);
4364         return result;
4365     }
4366 
4367     private static int dropArgumentChecks(MethodType oldType, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
4368         int dropped = valueTypes.size();
4369         MethodType.checkSlotCount(dropped);
4370         int outargs = oldType.parameterCount();
4371         int inargs  = outargs + dropped;
4372         if (pos &lt; 0 || pos &gt; outargs)
</pre>
<hr />
<pre>
4394 import static java.lang.invoke.MethodType.*;
4395 ...
4396 MethodHandle cat = lookup().findVirtual(String.class,
4397   &quot;concat&quot;, methodType(String.class, String.class));
4398 assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
4399 MethodHandle d0 = dropArguments(cat, 0, String.class);
4400 assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4401 MethodHandle d1 = dropArguments(cat, 1, String.class);
4402 assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4403 MethodHandle d2 = dropArguments(cat, 2, String.class);
4404 assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
4405 MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
4406 assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
4407      * }&lt;/pre&gt;&lt;/blockquote&gt;
4408      * &lt;p&gt;
4409      * This method is also equivalent to the following code:
4410      * &lt;blockquote&gt;&lt;pre&gt;
4411      * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
4412      * &lt;/pre&gt;&lt;/blockquote&gt;
4413      * @param target the method handle to invoke after the arguments are dropped

4414      * @param pos position of first argument to drop (zero for the leftmost)
<span class="line-added">4415      * @param valueTypes the type(s) of the argument(s) to drop</span>
4416      * @return a method handle which drops arguments of the given types,
4417      *         before calling the original method handle
4418      * @throws NullPointerException if the target is null,
4419      *                              or if the {@code valueTypes} array or any of its elements is null
4420      * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
4421      *                  or if {@code pos} is negative or greater than the arity of the target,
4422      *                  or if the new method handle&#39;s type would have
4423      *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4424      */
<span class="line-modified">4425     public static MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>

4426         return dropArguments0(target, pos, copyTypes(valueTypes));
4427     }
4428 
4429     // private version which allows caller some freedom with error handling
4430     private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
4431                                       boolean nullOnFailure) {
4432         newTypes = copyTypes(newTypes.toArray());
4433         List&lt;Class&lt;?&gt;&gt; oldTypes = target.type().parameterList();
4434         int match = oldTypes.size();
4435         if (skip != 0) {
4436             if (skip &lt; 0 || skip &gt; match) {
4437                 throw newIllegalArgumentException(&quot;illegal skip&quot;, skip, target);
4438             }
4439             oldTypes = oldTypes.subList(skip, match);
4440             match -= skip;
4441         }
4442         List&lt;Class&lt;?&gt;&gt; addTypes = newTypes;
4443         int add = addTypes.size();
4444         if (pos != 0) {
4445             if (pos &lt; 0 || pos &gt; add) {
</pre>
<hr />
<pre>
4511 if (h1.type().parameterCount() &lt; h2.type().parameterCount())
4512     h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
4513 else
4514     h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
4515 MethodHandle h3 = guardWithTest(h0, h1, h2);
4516 assertEquals(&quot;xy&quot;, h3.invoke(&quot;x&quot;, &quot;y&quot;, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
4517      * }&lt;/pre&gt;&lt;/blockquote&gt;
4518      * @param target the method handle to adapt
4519      * @param skip number of targets parameters to disregard (they will be unchanged)
4520      * @param newTypes the list of types to match {@code target}&#39;s parameter type list to
4521      * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
4522      * @return a possibly adapted method handle
4523      * @throws NullPointerException if either argument is null
4524      * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
4525      *         or if {@code skip} is negative or greater than the arity of the target,
4526      *         or if {@code pos} is negative or greater than the newTypes list size,
4527      *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
4528      *         {@code pos}.
4529      * @since 9
4530      */
<span class="line-modified">4531     public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {</span>

4532         Objects.requireNonNull(target);
4533         Objects.requireNonNull(newTypes);
4534         return dropArgumentsToMatch(target, skip, newTypes, pos, false);
4535     }
4536 
4537     /**
4538      * Adapts a target method handle by pre-processing
4539      * one or more of its arguments, each with its own unary filter function,
4540      * and then calling the target with each pre-processed argument
4541      * replaced by the result of its corresponding filter function.
4542      * &lt;p&gt;
4543      * The pre-processing is performed by one or more method handles,
4544      * specified in the elements of the {@code filters} array.
4545      * The first element of the filter array corresponds to the {@code pos}
4546      * argument of the target, and so on in sequence.
4547      * The filter functions are invoked in left to right order.
4548      * &lt;p&gt;
4549      * Null arguments in the array are treated as identity functions,
4550      * and the corresponding arguments left unchanged.
4551      * (If there are no non-null elements in the array, the original target is returned.)
</pre>
<hr />
<pre>
4594      * T adapter(P... p, V[i]... v[i], B... b) {
4595      *   return target(p..., filter[i](v[i])..., b...);
4596      * }
4597      * }&lt;/pre&gt;&lt;/blockquote&gt;
4598      * &lt;p&gt;
4599      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4600      * variable-arity method handle}, even if the original target method handle was.
4601      *
4602      * @param target the method handle to invoke after arguments are filtered
4603      * @param pos the position of the first argument to filter
4604      * @param filters method handles to call initially on filtered arguments
4605      * @return method handle which incorporates the specified argument filtering logic
4606      * @throws NullPointerException if the target is null
4607      *                              or if the {@code filters} array is null
4608      * @throws IllegalArgumentException if a non-null element of {@code filters}
4609      *          does not match a corresponding argument type of target as described above,
4610      *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
4611      *          or if the resulting method handle&#39;s type would have
4612      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4613      */
<span class="line-modified">4614     public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {</span>

4615         // In method types arguments start at index 0, while the LF
4616         // editor have the MH receiver at position 0 - adjust appropriately.
4617         final int MH_RECEIVER_OFFSET = 1;
4618         filterArgumentsCheckArity(target, pos, filters);
4619         MethodHandle adapter = target;
4620 
4621         // keep track of currently matched filters, as to optimize repeated filters
4622         int index = 0;
4623         int[] positions = new int[filters.length];
4624         MethodHandle filter = null;
4625 
4626         // process filters in reverse order so that the invocation of
4627         // the resulting adapter will invoke the filters in left-to-right order
4628         for (int i = filters.length - 1; i &gt;= 0; --i) {
4629             MethodHandle newFilter = filters[i];
4630             if (newFilter == null) continue;  // ignore null elements of filters
4631 
4632             // flush changes on update
4633             if (filter != newFilter) {
4634                 if (filter != null) {
</pre>
<hr />
<pre>
4652         }
4653         return adapter;
4654     }
4655 
4656     private static MethodHandle filterRepeatedArgument(MethodHandle adapter, MethodHandle filter, int[] positions) {
4657         MethodType targetType = adapter.type();
4658         MethodType filterType = filter.type();
4659         BoundMethodHandle result = adapter.rebind();
4660         Class&lt;?&gt; newParamType = filterType.parameterType(0);
4661 
4662         Class&lt;?&gt;[] ptypes = targetType.ptypes().clone();
4663         for (int pos : positions) {
4664             ptypes[pos - 1] = newParamType;
4665         }
4666         MethodType newType = MethodType.makeImpl(targetType.rtype(), ptypes, true);
4667 
4668         LambdaForm lform = result.editor().filterRepeatedArgumentForm(BasicType.basicType(newParamType), positions);
4669         return result.copyWithExtendL(newType, lform, filter);
4670     }
4671 
<span class="line-modified">4672     /*non-public*/</span>
<span class="line-modified">4673     static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {</span>
4674         filterArgumentChecks(target, pos, filter);
4675         MethodType targetType = target.type();
4676         MethodType filterType = filter.type();
4677         BoundMethodHandle result = target.rebind();
4678         Class&lt;?&gt; newParamType = filterType.parameterType(0);
4679         LambdaForm lform = result.editor().filterArgumentForm(1 + pos, BasicType.basicType(newParamType));
4680         MethodType newType = targetType.changeParameterType(pos, newParamType);
4681         result = result.copyWithExtendL(newType, lform, filter);
4682         return result;
4683     }
4684 
4685     private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters) {
4686         MethodType targetType = target.type();
4687         int maxPos = targetType.parameterCount();
4688         if (pos + filters.length &gt; maxPos)
4689             throw newIllegalArgumentException(&quot;too many filters&quot;);
4690     }
4691 
4692     private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
4693         MethodType targetType = target.type();
</pre>
<hr />
<pre>
4799      * Other equivalences are possible but would require argument permutation.
4800      * &lt;p&gt;
4801      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4802      * variable-arity method handle}, even if the original target method handle was.
4803      *
4804      * @param target the method handle to invoke after filtering the subsequence of arguments
4805      * @param pos the position of the first adapter argument to pass to the filter,
4806      *            and/or the target argument which receives the result of the filter
4807      * @param filter method handle to call on the subsequence of arguments
4808      * @return method handle which incorporates the specified argument subsequence filtering logic
4809      * @throws NullPointerException if either argument is null
4810      * @throws IllegalArgumentException if the return type of {@code filter}
4811      *          is non-void and is not the same as the {@code pos} argument of the target,
4812      *          or if {@code pos} is not between 0 and the target&#39;s arity, inclusive,
4813      *          or if the resulting method handle&#39;s type would have
4814      *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
4815      * @see MethodHandles#foldArguments
4816      * @see MethodHandles#filterArguments
4817      * @see MethodHandles#filterReturnValue
4818      */
<span class="line-modified">4819     public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {</span>

4820         MethodType newType = collectArgumentsChecks(target, pos, filter);
4821         MethodType collectorType = filter.type();
4822         BoundMethodHandle result = target.rebind();
4823         LambdaForm lform;
4824         if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
4825             lform = result.editor().collectArgumentArrayForm(1 + pos, filter);
4826             if (lform != null) {
4827                 return result.copyWith(newType, lform);
4828             }
4829         }
4830         lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());
4831         return result.copyWithExtendL(newType, lform, filter);
4832     }
4833 
4834     private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
4835         MethodType targetType = target.type();
4836         MethodType filterType = filter.type();
4837         Class&lt;?&gt; rtype = filterType.returnType();
4838         List&lt;Class&lt;?&gt;&gt; filterArgs = filterType.parameterList();
4839         if (rtype == void.class) {
</pre>
<hr />
<pre>
4892      *   return filter2();
4893      * }
4894      * // and if the filter has a void return:
4895      * T target3(A...);
4896      * void filter3(V);
4897      * void adapter3(A... a) {
4898      *   T t = target3(a...);
4899      *   filter3(t);
4900      * }
4901      * }&lt;/pre&gt;&lt;/blockquote&gt;
4902      * &lt;p&gt;
4903      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
4904      * variable-arity method handle}, even if the original target method handle was.
4905      * @param target the method handle to invoke before filtering the return value
4906      * @param filter method handle to call on the return value
4907      * @return method handle which incorporates the specified return value filtering logic
4908      * @throws NullPointerException if either argument is null
4909      * @throws IllegalArgumentException if the argument list of {@code filter}
4910      *          does not match the return type of target as described above
4911      */
<span class="line-modified">4912     public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {</span>

4913         MethodType targetType = target.type();
4914         MethodType filterType = filter.type();
4915         filterReturnValueChecks(targetType, filterType);
4916         BoundMethodHandle result = target.rebind();
4917         BasicType rtype = BasicType.basicType(filterType.returnType());
4918         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
4919         MethodType newType = targetType.changeReturnType(filterType.returnType());
4920         result = result.copyWithExtendL(newType, lform, filter);
4921         return result;
4922     }
4923 
4924     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
4925         Class&lt;?&gt; rtype = targetType.returnType();
4926         int filterValues = filterType.parameterCount();
4927         if (filterValues == 0
4928                 ? (rtype != void.class)
4929                 : (rtype != filterType.parameterType(0) || filterValues != 1))
4930             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
4931     }
4932 
</pre>
<hr />
<pre>
5000      * void combiner2(A...);
5001      * T adapter2(A... a, B... b) {
5002      *   combiner2(a...);
5003      *   return target2(a..., b...);
5004      * }
5005      * }&lt;/pre&gt;&lt;/blockquote&gt;
5006      * &lt;p&gt;
5007      * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
5008      * variable-arity method handle}, even if the original target method handle was.
5009      * @param target the method handle to invoke after arguments are combined
5010      * @param combiner method handle to call initially on the incoming arguments
5011      * @return method handle which incorporates the specified argument folding logic
5012      * @throws NullPointerException if either argument is null
5013      * @throws IllegalArgumentException if {@code combiner}&#39;s return type
5014      *          is non-void and not the same as the first argument type of
5015      *          the target, or if the initial {@code N} argument types
5016      *          of the target
5017      *          (skipping one matching the {@code combiner}&#39;s return type)
5018      *          are not identical with the argument types of {@code combiner}
5019      */
<span class="line-modified">5020     public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {</span>

5021         return foldArguments(target, 0, combiner);
5022     }
5023 
5024     /**
5025      * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
5026      * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
5027      * before the folded arguments.
5028      * &lt;p&gt;
5029      * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
5030      * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
5031      * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
5032      * 0.
5033      *
5034      * @apiNote Example:
5035      * &lt;blockquote&gt;&lt;pre&gt;{@code
5036     import static java.lang.invoke.MethodHandles.*;
5037     import static java.lang.invoke.MethodType.*;
5038     ...
5039     MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
5040     &quot;println&quot;, methodType(void.class, String.class))
</pre>
<hr />
<pre>
5127         return rtype;
5128     }
5129 
5130     /**
5131      * Adapts a target method handle by pre-processing some of its arguments, then calling the target with the result
5132      * of the pre-processing replacing the argument at the given position.
5133      *
5134      * @param target the method handle to invoke after arguments are combined
5135      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5136      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5137      * @param combiner method handle to call initially on the incoming arguments
5138      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5139      * @return method handle which incorporates the specified argument folding logic
5140      * @throws NullPointerException if either argument is null
5141      * @throws IllegalArgumentException if either of the following two conditions holds:
5142      *          (1) {@code combiner}&#39;s return type is not the same as the argument type at position
5143      *              {@code pos} of the target signature;
5144      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are
5145      *              not identical with the argument types of {@code combiner}.
5146      */
<span class="line-modified">5147     /*non-public*/</span>
<span class="line-added">5148     static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
5149         return argumentsWithCombiner(true, target, position, combiner, argPositions);
5150     }
5151 
5152     /**
5153      * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of
5154      * the pre-processing inserted into the original sequence of arguments at the given position.
5155      *
5156      * @param target the method handle to invoke after arguments are combined
5157      * @param position the position at which to start folding and at which to insert the folding result; if this is {@code
5158      *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
5159      * @param combiner method handle to call initially on the incoming arguments
5160      * @param argPositions indexes of the target to pick arguments sent to the combiner from
5161      * @return method handle which incorporates the specified argument folding logic
5162      * @throws NullPointerException if either argument is null
5163      * @throws IllegalArgumentException if either of the following two conditions holds:
5164      *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
5165      *              {@code pos} of the target signature;
5166      *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature
5167      *              (skipping {@code position} where the {@code combiner}&#39;s return will be folded in) are not identical
5168      *              with the argument types of {@code combiner}.
5169      */
<span class="line-modified">5170     /*non-public*/</span>
<span class="line-added">5171     static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
5172         return argumentsWithCombiner(false, target, position, combiner, argPositions);
5173     }
5174 
5175     private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
5176         MethodType targetType = target.type();
5177         MethodType combinerType = combiner.type();
5178         Class&lt;?&gt; rtype = argumentsWithCombinerChecks(position, filter, targetType, combinerType, argPositions);
5179         BoundMethodHandle result = target.rebind();
5180 
5181         MethodType newType = targetType;
5182         LambdaForm lform;
5183         if (filter) {
5184             lform = result.editor().filterArgumentsForm(1 + position, combinerType.basicType(), argPositions);
5185         } else {
5186             boolean dropResult = rtype == void.class;
5187             lform = result.editor().foldArgumentsForm(1 + position, dropResult, combinerType.basicType(), argPositions);
5188             if (!dropResult) {
5189                 newType = newType.dropParameterTypes(position, position + 1);
5190             }
5191         }
</pre>
<hr />
<pre>
5238      * T fallback(A...,B...);
5239      * T adapter(A... a,B... b) {
5240      *   if (test(a...))
5241      *     return target(a..., b...);
5242      *   else
5243      *     return fallback(a..., b...);
5244      * }
5245      * }&lt;/pre&gt;&lt;/blockquote&gt;
5246      * Note that the test arguments ({@code a...} in the pseudocode) cannot
5247      * be modified by execution of the test, and so are passed unchanged
5248      * from the caller to the target or fallback as appropriate.
5249      * @param test method handle used for test, must return boolean
5250      * @param target method handle to call if test passes
5251      * @param fallback method handle to call if test fails
5252      * @return method handle which incorporates the specified if/then/else logic
5253      * @throws NullPointerException if any argument is null
5254      * @throws IllegalArgumentException if {@code test} does not return boolean,
5255      *          or if all three method types do not match (with the return
5256      *          type of {@code test} changed to match that of the target).
5257      */
<span class="line-modified">5258     public static MethodHandle guardWithTest(MethodHandle test,</span>

5259                                MethodHandle target,
5260                                MethodHandle fallback) {
5261         MethodType gtype = test.type();
5262         MethodType ttype = target.type();
5263         MethodType ftype = fallback.type();
5264         if (!ttype.equals(ftype))
5265             throw misMatchedTypes(&quot;target and fallback types&quot;, ttype, ftype);
5266         if (gtype.returnType() != boolean.class)
5267             throw newIllegalArgumentException(&quot;guard type is not a predicate &quot;+gtype);
5268         List&lt;Class&lt;?&gt;&gt; targs = ttype.parameterList();
5269         test = dropArgumentsToMatch(test, 0, targs, 0, true);
5270         if (test == null) {
5271             throw misMatchedTypes(&quot;target and test types&quot;, ttype, gtype);
5272         }
5273         return MethodHandleImpl.makeGuardWithTest(test, target, fallback);
5274     }
5275 
5276     static &lt;T&gt; RuntimeException misMatchedTypes(String what, T t1, T t2) {
5277         return newIllegalArgumentException(what + &quot; must match: &quot; + t1 + &quot; != &quot; + t2);
5278     }
</pre>
<hr />
<pre>
5310      * be modified by execution of the target, and so are passed unchanged
5311      * from the caller to the handler, if the handler is invoked.
5312      * &lt;p&gt;
5313      * The target and handler must return the same type, even if the handler
5314      * always throws.  (This might happen, for instance, because the handler
5315      * is simulating a {@code finally} clause).
5316      * To create such a throwing handler, compose the handler creation logic
5317      * with {@link #throwException throwException},
5318      * in order to create a method handle of the correct return type.
5319      * @param target method handle to call
5320      * @param exType the type of exception which the handler will catch
5321      * @param handler method handle to call if a matching exception is thrown
5322      * @return method handle which incorporates the specified try/catch logic
5323      * @throws NullPointerException if any argument is null
5324      * @throws IllegalArgumentException if {@code handler} does not accept
5325      *          the given exception type, or if the method handle types do
5326      *          not match in their return types and their
5327      *          corresponding parameters
5328      * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
5329      */
<span class="line-modified">5330     public static MethodHandle catchException(MethodHandle target,</span>

5331                                 Class&lt;? extends Throwable&gt; exType,
5332                                 MethodHandle handler) {
5333         MethodType ttype = target.type();
5334         MethodType htype = handler.type();
5335         if (!Throwable.class.isAssignableFrom(exType))
5336             throw new ClassCastException(exType.getName());
5337         if (htype.parameterCount() &lt; 1 ||
5338             !htype.parameterType(0).isAssignableFrom(exType))
5339             throw newIllegalArgumentException(&quot;handler does not accept exception type &quot;+exType);
5340         if (htype.returnType() != ttype.returnType())
5341             throw misMatchedTypes(&quot;target and handler return types&quot;, ttype, htype);
5342         handler = dropArgumentsToMatch(handler, 1, ttype.parameterList(), 0, true);
5343         if (handler == null) {
5344             throw misMatchedTypes(&quot;target and handler types&quot;, ttype, htype);
5345         }
5346         return MethodHandleImpl.makeGuardWithCatch(target, exType, handler);
5347     }
5348 
5349     /**
5350      * Produces a method handle which will throw exceptions of the given {@code exType}.
5351      * The method handle will accept a single argument of {@code exType},
5352      * and immediately throw it as an exception.
5353      * The method type will nominally specify a return of {@code returnType}.
5354      * The return type may be anything convenient:  It doesn&#39;t matter to the
5355      * method handle&#39;s behavior, since it will never return normally.
5356      * @param returnType the return type of the desired method handle
5357      * @param exType the parameter type of the desired method handle
5358      * @return method handle which can throw the given exceptions
5359      * @throws NullPointerException if either argument is null
5360      */
<span class="line-modified">5361     public static MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {</span>

5362         if (!Throwable.class.isAssignableFrom(exType))
5363             throw new ClassCastException(exType.getName());
5364         return MethodHandleImpl.throwException(methodType(returnType, exType));
5365     }
5366 
5367     /**
5368      * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
5369      * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
5370      * delivers the loop&#39;s result, which is the return value of the resulting handle.
5371      * &lt;p&gt;
5372      * Intuitively, every loop is formed by one or more &quot;clauses&quot;, each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
5373      * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
5374      * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
5375      * terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
5376      * &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.
5377      * &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable {@code v}.
5378      * &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
5379      * &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop&#39;s return value.
5380      * &lt;/ul&gt;
5381      * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.
</pre>
<hr />
<pre>
5688             MethodHandle in = init.get(i);
5689             MethodHandle st = step.get(i);
5690             if (in == null &amp;&amp; st == null) {
5691                 iterationVariableTypes.add(void.class);
5692             } else if (in != null &amp;&amp; st != null) {
5693                 loopChecks1a(i, in, st);
5694                 iterationVariableTypes.add(in.type().returnType());
5695             } else {
5696                 iterationVariableTypes.add(in == null ? st.type().returnType() : in.type().returnType());
5697             }
5698         }
5699         final List&lt;Class&lt;?&gt;&gt; commonPrefix = iterationVariableTypes.stream().filter(t -&gt; t != void.class).
5700                 collect(Collectors.toList());
5701 
5702         // Step 1B: determine loop parameters (A...).
5703         final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
5704         loopChecks1b(init, commonSuffix);
5705 
5706         // Step 1C: determine loop return type.
5707         // Step 1D: check other types.
<span class="line-modified">5708         // local variable required here; see JDK-8223553</span>
<span class="line-modified">5709         Stream&lt;Class&lt;?&gt;&gt; cstream = fini.stream().filter(Objects::nonNull).map(MethodHandle::type)</span>
<span class="line-added">5710                 .map(MethodType::returnType);</span>
<span class="line-added">5711         final Class&lt;?&gt; loopReturnType = cstream.findFirst().orElse(void.class);</span>
5712         loopChecks1cd(pred, fini, loopReturnType);
5713 
5714         // Step 2: determine parameter lists.
5715         final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
5716         commonParameterSequence.addAll(commonSuffix);
5717         loopChecks2(step, pred, fini, commonParameterSequence);
5718 
5719         // Step 3: fill in omitted functions.
5720         for (int i = 0; i &lt; nclauses; ++i) {
5721             Class&lt;?&gt; t = iterationVariableTypes.get(i);
5722             if (init.get(i) == null) {
5723                 init.set(i, empty(methodType(t, commonSuffix)));
5724             }
5725             if (step.get(i) == null) {
5726                 step.set(i, dropArgumentsToMatch(identityOrVoid(t), 0, commonParameterSequence, i));
5727             }
5728             if (pred.get(i) == null) {
5729                 pred.set(i, dropArguments0(constant(boolean.class, true), 0, commonParameterSequence));
5730             }
5731             if (fini.get(i) == null) {
</pre>
<hr />
<pre>
6649                 // special case; if the iterator handle is null and the external
6650                 // parameter list is not empty then the first parameter must be
6651                 // assignable to Iterable
6652                 iterableType = externalParamList.get(0);
6653                 if (!Iterable.class.isAssignableFrom(iterableType)) {
6654                     throw newIllegalArgumentException(
6655                             &quot;inferred first loop argument must inherit from Iterable: &quot; + iterableType);
6656                 }
6657             }
6658         }
6659         if (init != null) {
6660             MethodType initType = init.type();
6661             if (initType.returnType() != returnType ||
6662                     !initType.effectivelyIdenticalParameters(0, externalParamList)) {
6663                 throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, externalParamList));
6664             }
6665         }
6666         return iterableType;  // help the caller a bit
6667     }
6668 
<span class="line-modified">6669     /*non-public*/</span>
<span class="line-added">6670     static MethodHandle swapArguments(MethodHandle mh, int i, int j) {</span>
6671         // there should be a better way to uncross my wires
6672         int arity = mh.type().parameterCount();
6673         int[] order = new int[arity];
6674         for (int k = 0; k &lt; arity; k++)  order[k] = k;
6675         order[i] = j; order[j] = i;
6676         Class&lt;?&gt;[] types = mh.type().parameterArray();
6677         Class&lt;?&gt; ti = types[i]; types[i] = types[j]; types[j] = ti;
6678         MethodType swapType = methodType(mh.type().returnType(), types);
6679         return permuteArguments(mh, swapType, order);
6680     }
6681 
6682     /**
6683      * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
6684      * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
6685      * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
6686      * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
6687      * value returned from the {@code cleanup} handle&#39;s execution will be the result of the execution of the
6688      * {@code try-finally} handle.
6689      * &lt;p&gt;
6690      * The {@code cleanup} handle will be passed one or two additional leading arguments.
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleStatics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/CodeSource.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
 28 
 29 import java.net.URL;
 30 import java.net.SocketPermission;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.Hashtable;
 34 import java.io.ByteArrayInputStream;
 35 import java.io.IOException;
 36 import java.security.cert.*;
 37 import sun.net.util.URLUtil;
 38 import sun.security.util.IOUtils;
 39 
 40 /**
 41  *
 42  * &lt;p&gt;This class extends the concept of a codebase to
 43  * encapsulate not only the location (URL) but also the certificate chains
 44  * that were used to verify signed code originating from that location.
 45  *
 46  * @author Li Gong
 47  * @author Roland Schemers
 48  * @since 1.2
 49  */
 50 
 51 public class CodeSource implements java.io.Serializable {
 52 
<a name="2" id="anc2"></a><span class="line-added"> 53     @java.io.Serial</span>
 54     private static final long serialVersionUID = 4977541819976013951L;
 55 
 56     /**
 57      * The code location.
 58      *
 59      * @serial
 60      */
<a name="3" id="anc3"></a><span class="line-modified"> 61     private final URL location;</span>
 62 
 63     /*
 64      * The code signers.
 65      */
 66     private transient CodeSigner[] signers = null;
 67 
 68     /*
 69      * The code signers. Certificate chains are concatenated.
 70      */
 71     private transient java.security.cert.Certificate[] certs = null;
 72 
 73     // cached SocketPermission used for matchLocation
 74     private transient SocketPermission sp;
 75 
 76     // for generating cert paths
 77     private transient CertificateFactory factory = null;
 78 
 79     /**
 80      * A String form of the URL for use as a key in HashMaps/Sets. The String
 81      * form should be behave in the same manner as the URL when compared for
 82      * equality in a HashMap/Set, except that no nameservice lookup is done
 83      * on the hostname (only string comparison), and the fragment is not
 84      * considered.
 85      */
 86     private transient String locationNoFragString;
 87 
 88     /**
 89      * Constructs a CodeSource and associates it with the specified
 90      * location and set of certificates.
 91      *
 92      * @param url the location (URL).  It may be {@code null}.
 93      * @param certs the certificate(s). It may be {@code null}. The contents
 94      * of the array are copied to protect against subsequent modification.
 95      */
 96     public CodeSource(URL url, java.security.cert.Certificate[] certs) {
 97         this.location = url;
 98         if (url != null) {
 99             this.locationNoFragString = URLUtil.urlNoFragString(url);
100         }
101 
102         // Copy the supplied certs
103         if (certs != null) {
104             this.certs = certs.clone();
105         }
106     }
107 
108     /**
109      * Constructs a CodeSource and associates it with the specified
110      * location and set of code signers.
111      *
112      * @param url the location (URL).  It may be {@code null}.
113      * @param signers the code signers. It may be {@code null}. The contents
114      * of the array are copied to protect against subsequent modification.
115      *
116      * @since 1.5
117      */
118     public CodeSource(URL url, CodeSigner[] signers) {
119         this.location = url;
120         if (url != null) {
121             this.locationNoFragString = URLUtil.urlNoFragString(url);
122         }
123 
124         // Copy the supplied signers
125         if (signers != null) {
126             this.signers = signers.clone();
127         }
128     }
129 
130     /**
131      * Returns the hash code value for this object.
132      *
133      * @return a hash code value for this object.
134      */
135     @Override
136     public int hashCode() {
137         if (location != null)
138             return location.hashCode();
139         else
140             return 0;
141     }
142 
143     /**
144      * Tests for equality between the specified object and this
145      * object. Two CodeSource objects are considered equal if their
146      * locations are of identical value and if their signer certificate
147      * chains are of identical value. It is not required that
148      * the certificate chains be in the same order.
149      *
150      * @param obj the object to test for equality with this object.
151      *
152      * @return true if the objects are considered equal, false otherwise.
153      */
154     @Override
155     public boolean equals(Object obj) {
156         if (obj == this)
157             return true;
158 
159         // objects types must be equal
160         if (!(obj instanceof CodeSource))
161             return false;
162 
163         CodeSource cs = (CodeSource) obj;
164 
165         // URLs must match
166         if (location == null) {
167             // if location is null, then cs.location must be null as well
168             if (cs.location != null) return false;
169         } else {
170             // if location is not null, then it must equal cs.location
171             if (!location.equals(cs.location)) return false;
172         }
173 
174         // certs must match
175         return matchCerts(cs, true);
176     }
177 
178     /**
179      * Returns the location associated with this CodeSource.
180      *
181      * @return the location (URL), or {@code null} if no URL was supplied
182      * during construction.
183      */
184     public final URL getLocation() {
185         /* since URL is practically immutable, returning itself is not
186            a security problem */
187         return this.location;
188     }
189 
190     /**
191      * Returns a String form of the URL for use as a key in HashMaps/Sets.
192      */
193     String getLocationNoFragString() {
194         return locationNoFragString;
195     }
196 
197     /**
198      * Returns the certificates associated with this CodeSource.
199      * &lt;p&gt;
200      * If this CodeSource object was created using the
201      * {@link #CodeSource(URL url, CodeSigner[] signers)}
202      * constructor then its certificate chains are extracted and used to
203      * create an array of Certificate objects. Each signer certificate is
204      * followed by its supporting certificate chain (which may be empty).
205      * Each signer certificate and its supporting certificate chain is ordered
206      * bottom-to-top (i.e., with the signer certificate first and the (root)
207      * certificate authority last).
208      *
209      * @return a copy of the certificate array, or {@code null} if there
210      * is none.
211      */
212     public final java.security.cert.Certificate[] getCertificates() {
213         if (certs != null) {
214             return certs.clone();
215 
216         } else if (signers != null) {
217             // Convert the code signers to certs
218             ArrayList&lt;java.security.cert.Certificate&gt; certChains =
219                         new ArrayList&lt;&gt;();
220             for (int i = 0; i &lt; signers.length; i++) {
221                 certChains.addAll(
222                     signers[i].getSignerCertPath().getCertificates());
223             }
224             certs = certChains.toArray(
225                         new java.security.cert.Certificate[certChains.size()]);
226             return certs.clone();
227 
228         } else {
229             return null;
230         }
231     }
232 
233     /**
234      * Returns the code signers associated with this CodeSource.
235      * &lt;p&gt;
236      * If this CodeSource object was created using the
237      * {@link #CodeSource(URL url, java.security.cert.Certificate[] certs)}
238      * constructor then its certificate chains are extracted and used to
239      * create an array of CodeSigner objects. Note that only X.509 certificates
240      * are examined - all other certificate types are ignored.
241      *
242      * @return a copy of the code signer array, or {@code null} if there
243      * is none.
244      *
245      * @since 1.5
246      */
247     public final CodeSigner[] getCodeSigners() {
248         if (signers != null) {
249             return signers.clone();
250 
251         } else if (certs != null) {
252             // Convert the certs to code signers
253             signers = convertCertArrayToSignerArray(certs);
254             return signers.clone();
255 
256         } else {
257             return null;
258         }
259     }
260 
261     /**
262      * Returns true if this CodeSource object &quot;implies&quot; the specified CodeSource.
263      * &lt;p&gt;
264      * More specifically, this method makes the following checks.
265      * If any fail, it returns false. If they all succeed, it returns true.
266      * &lt;ul&gt;
267      * &lt;li&gt; &lt;i&gt;codesource&lt;/i&gt; must not be null.
268      * &lt;li&gt; If this object&#39;s certificates are not null, then all
269      * of this object&#39;s certificates must be present in &lt;i&gt;codesource&lt;/i&gt;&#39;s
270      * certificates.
271      * &lt;li&gt; If this object&#39;s location (getLocation()) is not null, then the
272      * following checks are made against this object&#39;s location and
273      * &lt;i&gt;codesource&lt;/i&gt;&#39;s:
274      *   &lt;ul&gt;
275      *     &lt;li&gt;  &lt;i&gt;codesource&lt;/i&gt;&#39;s location must not be null.
276      *
277      *     &lt;li&gt;  If this object&#39;s location
278      *           equals &lt;i&gt;codesource&lt;/i&gt;&#39;s location, then return true.
279      *
280      *     &lt;li&gt;  This object&#39;s protocol (getLocation().getProtocol()) must be
281      *           equal to &lt;i&gt;codesource&lt;/i&gt;&#39;s protocol, ignoring case.
282      *
283      *     &lt;li&gt;  If this object&#39;s host (getLocation().getHost()) is not null,
284      *           then the SocketPermission
285      *           constructed with this object&#39;s host must imply the
286      *           SocketPermission constructed with &lt;i&gt;codesource&lt;/i&gt;&#39;s host.
287      *
288      *     &lt;li&gt;  If this object&#39;s port (getLocation().getPort()) is not
289      *           equal to -1 (that is, if a port is specified), it must equal
290      *           &lt;i&gt;codesource&lt;/i&gt;&#39;s port or default port
291      *           (codesource.getLocation().getDefaultPort()).
292      *
293      *     &lt;li&gt;  If this object&#39;s file (getLocation().getFile()) doesn&#39;t equal
294      *           &lt;i&gt;codesource&lt;/i&gt;&#39;s file, then the following checks are made:
295      *           If this object&#39;s file ends with &quot;/-&quot;,
296      *           then &lt;i&gt;codesource&lt;/i&gt;&#39;s file must start with this object&#39;s
297      *           file (exclusive the trailing &quot;-&quot;).
298      *           If this object&#39;s file ends with a &quot;/*&quot;,
299      *           then &lt;i&gt;codesource&lt;/i&gt;&#39;s file must start with this object&#39;s
300      *           file and must not have any further &quot;/&quot; separators.
301      *           If this object&#39;s file doesn&#39;t end with a &quot;/&quot;,
302      *           then &lt;i&gt;codesource&lt;/i&gt;&#39;s file must match this object&#39;s
303      *           file with a &#39;/&#39; appended.
304      *
305      *     &lt;li&gt;  If this object&#39;s reference (getLocation().getRef()) is
306      *           not null, it must equal &lt;i&gt;codesource&lt;/i&gt;&#39;s reference.
307      *
308      *   &lt;/ul&gt;
309      * &lt;/ul&gt;
310      * &lt;p&gt;
311      * For example, the codesource objects with the following locations
312      * and null certificates all imply
313      * the codesource with the location &quot;http://www.example.com/classes/foo.jar&quot;
314      * and null certificates:
315      * &lt;pre&gt;
316      *     http:
317      *     http://*.example.com/classes/*
318      *     http://www.example.com/classes/-
319      *     http://www.example.com/classes/foo.jar
320      * &lt;/pre&gt;
321      *
322      * Note that if this CodeSource has a null location and a null
323      * certificate chain, then it implies every other CodeSource.
324      *
325      * @param codesource CodeSource to compare against.
326      *
327      * @return true if the specified codesource is implied by this codesource,
328      * false if not.
329      */
330     public boolean implies(CodeSource codesource)
331     {
332         if (codesource == null)
333             return false;
334 
335         return matchCerts(codesource, false) &amp;&amp; matchLocation(codesource);
336     }
337 
338     /**
339      * Returns true if all the certs in this
340      * CodeSource are also in &lt;i&gt;that&lt;/i&gt;.
341      *
342      * @param that the CodeSource to check against.
343      * @param strict if true then a strict equality match is performed.
344      *               Otherwise a subset match is performed.
345      */
346     boolean matchCerts(CodeSource that, boolean strict)
347     {
348         boolean match;
349 
350         // match any key
351         if (certs == null &amp;&amp; signers == null) {
352             if (strict) {
353                 return (that.certs == null &amp;&amp; that.signers == null);
354             } else {
355                 return true;
356             }
357         // both have signers
358         } else if (signers != null &amp;&amp; that.signers != null) {
359             if (strict &amp;&amp; signers.length != that.signers.length) {
360                 return false;
361             }
362             for (int i = 0; i &lt; signers.length; i++) {
363                 match = false;
364                 for (int j = 0; j &lt; that.signers.length; j++) {
365                     if (signers[i].equals(that.signers[j])) {
366                         match = true;
367                         break;
368                     }
369                 }
370                 if (!match) return false;
371             }
372             return true;
373 
374         // both have certs
375         } else if (certs != null &amp;&amp; that.certs != null) {
376             if (strict &amp;&amp; certs.length != that.certs.length) {
377                 return false;
378             }
379             for (int i = 0; i &lt; certs.length; i++) {
380                 match = false;
381                 for (int j = 0; j &lt; that.certs.length; j++) {
382                     if (certs[i].equals(that.certs[j])) {
383                         match = true;
384                         break;
385                     }
386                 }
387                 if (!match) return false;
388             }
389             return true;
390         }
391 
392         return false;
393     }
394 
395 
396     /**
397      * Returns true if two CodeSource&#39;s have the &quot;same&quot; location.
398      *
399      * @param that CodeSource to compare against
400      */
401     private boolean matchLocation(CodeSource that) {
402         if (location == null)
403             return true;
404 
405         if ((that == null) || (that.location == null))
406             return false;
407 
408         if (location.equals(that.location))
409             return true;
410 
411         if (!location.getProtocol().equalsIgnoreCase(that.location.getProtocol()))
412             return false;
413 
414         int thisPort = location.getPort();
415         if (thisPort != -1) {
416             int thatPort = that.location.getPort();
417             int port = thatPort != -1 ? thatPort
418                                       : that.location.getDefaultPort();
419             if (thisPort != port)
420                 return false;
421         }
422 
423         if (location.getFile().endsWith(&quot;/-&quot;)) {
424             // Matches the directory and (recursively) all files
425             // and subdirectories contained in that directory.
426             // For example, &quot;/a/b/-&quot; implies anything that starts with
427             // &quot;/a/b/&quot;
428             String thisPath = location.getFile().substring(0,
429                                             location.getFile().length()-1);
430             if (!that.location.getFile().startsWith(thisPath))
431                 return false;
432         } else if (location.getFile().endsWith(&quot;/*&quot;)) {
433             // Matches the directory and all the files contained in that
434             // directory.
435             // For example, &quot;/a/b/*&quot; implies anything that starts with
436             // &quot;/a/b/&quot; but has no further slashes
437             int last = that.location.getFile().lastIndexOf(&#39;/&#39;);
438             if (last == -1)
439                 return false;
440             String thisPath = location.getFile().substring(0,
441                                             location.getFile().length()-1);
442             String thatPath = that.location.getFile().substring(0, last+1);
443             if (!thatPath.equals(thisPath))
444                 return false;
445         } else {
446             // Exact matches only.
447             // For example, &quot;/a/b&quot; and &quot;/a/b/&quot; both imply &quot;/a/b/&quot;
448             if ((!that.location.getFile().equals(location.getFile()))
449                 &amp;&amp; (!that.location.getFile().equals(location.getFile()+&quot;/&quot;))) {
450                 return false;
451             }
452         }
453 
454         if (location.getRef() != null
455             &amp;&amp; !location.getRef().equals(that.location.getRef())) {
456             return false;
457         }
458 
459         String thisHost = location.getHost();
460         String thatHost = that.location.getHost();
461         if (thisHost != null) {
462             if ((&quot;&quot;.equals(thisHost) || &quot;localhost&quot;.equals(thisHost)) &amp;&amp;
463                 (&quot;&quot;.equals(thatHost) || &quot;localhost&quot;.equals(thatHost))) {
464                 // ok
465             } else if (!thisHost.equals(thatHost)) {
466                 if (thatHost == null) {
467                     return false;
468                 }
469                 if (this.sp == null) {
470                     this.sp = new SocketPermission(thisHost, &quot;resolve&quot;);
471                 }
472                 if (that.sp == null) {
473                     that.sp = new SocketPermission(thatHost, &quot;resolve&quot;);
474                 }
475                 if (!this.sp.implies(that.sp)) {
476                     return false;
477                 }
478             }
479         }
480         // everything matches
481         return true;
482     }
483 
484     /**
485      * Returns a string describing this CodeSource, telling its
486      * URL and certificates.
487      *
488      * @return information about this CodeSource.
489      */
490     @Override
491     public String toString() {
492         StringBuilder sb = new StringBuilder();
493         sb.append(&quot;(&quot;);
494         sb.append(this.location);
495 
496         if (this.certs != null &amp;&amp; this.certs.length &gt; 0) {
497             for (int i = 0; i &lt; this.certs.length; i++) {
498                 sb.append( &quot; &quot; + this.certs[i]);
499             }
500 
501         } else if (this.signers != null &amp;&amp; this.signers.length &gt; 0) {
502             for (int i = 0; i &lt; this.signers.length; i++) {
503                 sb.append( &quot; &quot; + this.signers[i]);
504             }
505         } else {
506             sb.append(&quot; &lt;no signer certificates&gt;&quot;);
507         }
508         sb.append(&quot;)&quot;);
509         return sb.toString();
510     }
511 
512     /**
513      * Writes this object out to a stream (i.e., serializes it).
514      *
515      * @serialData An initial {@code URL} is followed by an
516      * {@code int} indicating the number of certificates to follow
517      * (a value of &quot;zero&quot; denotes that there are no certificates associated
518      * with this object).
519      * Each certificate is written out starting with a {@code String}
520      * denoting the certificate type, followed by an
521      * {@code int} specifying the length of the certificate encoding,
522      * followed by the certificate encoding itself which is written out as an
523      * array of bytes. Finally, if any code signers are present then the array
524      * of code signers is serialized and written out too.
525      */
<a name="4" id="anc4"></a><span class="line-added">526     @java.io.Serial</span>
527     private void writeObject(java.io.ObjectOutputStream oos)
528         throws IOException
529     {
530         oos.defaultWriteObject(); // location
531 
532         // Serialize the array of certs
533         if (certs == null || certs.length == 0) {
534             oos.writeInt(0);
535         } else {
536             // write out the total number of certs
537             oos.writeInt(certs.length);
538             // write out each cert, including its type
539             for (int i = 0; i &lt; certs.length; i++) {
540                 java.security.cert.Certificate cert = certs[i];
541                 try {
542                     oos.writeUTF(cert.getType());
543                     byte[] encoded = cert.getEncoded();
544                     oos.writeInt(encoded.length);
545                     oos.write(encoded);
546                 } catch (CertificateEncodingException cee) {
547                     throw new IOException(cee.getMessage());
548                 }
549             }
550         }
551 
552         // Serialize the array of code signers (if any)
553         if (signers != null &amp;&amp; signers.length &gt; 0) {
554             oos.writeObject(signers);
555         }
556     }
557 
558     /**
559      * Restores this object from a stream (i.e., deserializes it).
560      */
<a name="5" id="anc5"></a><span class="line-added">561     @java.io.Serial</span>
562     private void readObject(java.io.ObjectInputStream ois)
563         throws IOException, ClassNotFoundException
564     {
565         CertificateFactory cf;
566         Hashtable&lt;String, CertificateFactory&gt; cfs = null;
567         List&lt;java.security.cert.Certificate&gt; certList = null;
568 
569         ois.defaultReadObject(); // location
570 
571         // process any new-style certs in the stream (if present)
572         int size = ois.readInt();
573         if (size &gt; 0) {
574             // we know of 3 different cert types: X.509, PGP, SDSI, which
575             // could all be present in the stream at the same time
576             cfs = new Hashtable&lt;&gt;(3);
577             certList = new ArrayList&lt;&gt;(size &gt; 20 ? 20 : size);
578         } else if (size &lt; 0) {
579             throw new IOException(&quot;size cannot be negative&quot;);
580         }
581 
582         for (int i = 0; i &lt; size; i++) {
583             // read the certificate type, and instantiate a certificate
584             // factory of that type (reuse existing factory if possible)
585             String certType = ois.readUTF();
586             if (cfs.containsKey(certType)) {
587                 // reuse certificate factory
588                 cf = cfs.get(certType);
589             } else {
590                 // create new certificate factory
591                 try {
592                     cf = CertificateFactory.getInstance(certType);
593                 } catch (CertificateException ce) {
594                     throw new ClassNotFoundException
595                         (&quot;Certificate factory for &quot; + certType + &quot; not found&quot;);
596                 }
597                 // store the certificate factory so we can reuse it later
598                 cfs.put(certType, cf);
599             }
600             // parse the certificate
<a name="6" id="anc6"></a><span class="line-modified">601             byte[] encoded = IOUtils.readExactlyNBytes(ois, ois.readInt());</span>
602             ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
603             try {
604                 certList.add(cf.generateCertificate(bais));
605             } catch (CertificateException ce) {
606                 throw new IOException(ce.getMessage());
607             }
608             bais.close();
609         }
610 
611         if (certList != null) {
612             this.certs = certList.toArray(
613                     new java.security.cert.Certificate[size]);
614         }
615         // Deserialize array of code signers (if any)
616         try {
617             this.signers = ((CodeSigner[])ois.readObject()).clone();
618         } catch (IOException ioe) {
619             // no signers present
620         }
621 
622         if (location != null) {
623             locationNoFragString = URLUtil.urlNoFragString(location);
624         }
625     }
626 
627     /*
628      * Convert an array of certificates to an array of code signers.
629      * The array of certificates is a concatenation of certificate chains
630      * where the initial certificate in each chain is the end-entity cert.
631      *
632      * @return an array of code signers or null if none are generated.
633      */
634     private CodeSigner[] convertCertArrayToSignerArray(
635         java.security.cert.Certificate[] certs) {
636 
637         if (certs == null) {
638             return null;
639         }
640 
641         try {
642             // Initialize certificate factory
643             if (factory == null) {
644                 factory = CertificateFactory.getInstance(&quot;X.509&quot;);
645             }
646 
647             // Iterate through all the certificates
648             int i = 0;
649             List&lt;CodeSigner&gt; signers = new ArrayList&lt;&gt;();
650             while (i &lt; certs.length) {
651                 List&lt;java.security.cert.Certificate&gt; certChain =
652                         new ArrayList&lt;&gt;();
653                 certChain.add(certs[i++]); // first cert is an end-entity cert
654                 int j = i;
655 
656                 // Extract chain of certificates
657                 // (loop while certs are not end-entity certs)
658                 while (j &lt; certs.length &amp;&amp;
659                     certs[j] instanceof X509Certificate &amp;&amp;
660                     ((X509Certificate)certs[j]).getBasicConstraints() != -1) {
661                     certChain.add(certs[j]);
662                     j++;
663                 }
664                 i = j;
665                 CertPath certPath = factory.generateCertPath(certChain);
666                 signers.add(new CodeSigner(certPath, null));
667             }
668 
669             if (signers.isEmpty()) {
670                 return null;
671             } else {
672                 return signers.toArray(new CodeSigner[signers.size()]);
673             }
674 
675         } catch (CertificateException e) {
676             return null; //TODO - may be better to throw an ex. here
677         }
678     }
679 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
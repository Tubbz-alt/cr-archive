<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/math/BigDecimal.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../lang/reflect/UndeclaredThrowableException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BigInteger.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/BigDecimal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 263     /**
 264      * Sentinel value for {@link #intCompact} indicating the
 265      * significand information is only available from {@code intVal}.
 266      */
 267     static final long INFLATED = Long.MIN_VALUE;
 268 
 269     private static final BigInteger INFLATED_BIGINT = BigInteger.valueOf(INFLATED);
 270 
 271     /**
 272      * If the absolute value of the significand of this BigDecimal is
 273      * less than or equal to {@code Long.MAX_VALUE}, the value can be
 274      * compactly stored in this field and used in computations.
 275      */
 276     private final transient long intCompact;
 277 
 278     // All 18-digit base ten strings fit into a long; not all 19-digit
 279     // strings will
 280     private static final int MAX_COMPACT_DIGITS = 18;
 281 
 282     /* Appease the serialization gods */

 283     private static final long serialVersionUID = 6108874887143696463L;
 284 
 285     private static final ThreadLocal&lt;StringBuilderHelper&gt;
 286         threadLocalStringBuilderHelper = new ThreadLocal&lt;StringBuilderHelper&gt;() {
 287         @Override
 288         protected StringBuilderHelper initialValue() {
 289             return new StringBuilderHelper();
 290         }
 291     };
 292 
 293     // Cache of common small BigDecimal values.
 294     private static final BigDecimal ZERO_THROUGH_TEN[] = {
 295         new BigDecimal(BigInteger.ZERO,       0,  0, 1),
 296         new BigDecimal(BigInteger.ONE,        1,  0, 1),
 297         new BigDecimal(BigInteger.TWO,        2,  0, 1),
 298         new BigDecimal(BigInteger.valueOf(3), 3,  0, 1),
 299         new BigDecimal(BigInteger.valueOf(4), 4,  0, 1),
 300         new BigDecimal(BigInteger.valueOf(5), 5,  0, 1),
 301         new BigDecimal(BigInteger.valueOf(6), 6,  0, 1),
 302         new BigDecimal(BigInteger.valueOf(7), 7,  0, 1),
</pre>
<hr />
<pre>
2101                 strippedScale % 2 == 0) {
2102                 BigDecimal result = valueOf(1L, strippedScale/2);
2103                 if (result.scale() != preferredScale) {
2104                     // Adjust to requested precision and preferred
2105                     // scale as appropriate.
2106                     result = result.add(zeroWithFinalPreferredScale, mc);
2107                 }
2108                 return result;
2109             }
2110 
2111             // After stripTrailingZeros, the representation is normalized as
2112             //
2113             // unscaledValue * 10^(-scale)
2114             //
2115             // where unscaledValue is an integer with the mimimum
2116             // precision for the cohort of the numerical value. To
2117             // allow binary floating-point hardware to be used to get
2118             // approximately a 15 digit approximation to the square
2119             // root, it is helpful to instead normalize this so that
2120             // the significand portion is to right of the decimal
<span class="line-modified">2121             // point by roughly (scale() - precision() +1).</span>
2122 
2123             // Now the precision / scale adjustment
2124             int scaleAdjust = 0;
2125             int scale = stripped.scale() - stripped.precision() + 1;
2126             if (scale % 2 == 0) {
2127                 scaleAdjust = scale;
2128             } else {
2129                 scaleAdjust = scale - 1;
2130             }
2131 
2132             BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);
2133 
2134             assert  // Verify 0.1 &lt;= working &lt; 10
2135                 ONE_TENTH.compareTo(working) &lt;= 0 &amp;&amp; working.compareTo(TEN) &lt; 0;
2136 
2137             // Use good ole&#39; Math.sqrt to get the initial guess for
2138             // the Newton iteration, good to at least 15 decimal
2139             // digits. This approach does incur the cost of a
2140             //
2141             // BigDecimal -&gt; double -&gt; BigDecimal
2142             //
2143             // conversion cycle, but it avoids the need for several
2144             // Newton iterations in BigDecimal arithmetic to get the
2145             // working answer to 15 digits of precision. If many fewer
2146             // than 15 digits were needed, it might be faster to do
2147             // the loop entirely in BigDecimal arithmetic.
2148             //
<span class="line-modified">2149             // (A double value might have as much many as 17 decimal</span>
2150             // digits of precision; it depends on the relative density
2151             // of binary and decimal numbers at different regions of
2152             // the number line.)
2153             //
2154             // (It would be possible to check for certain special
2155             // cases to avoid doing any Newton iterations. For
2156             // example, if the BigDecimal -&gt; double conversion was
2157             // known to be exact and the rounding mode had a
2158             // low-enough precision, the post-Newton rounding logic
2159             // could be applied directly.)
2160 
2161             BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));
2162             int guessPrecision = 15;
2163             int originalPrecision = mc.getPrecision();
2164             int targetPrecision;
2165 
2166             // If an exact value is requested, it must only need about
2167             // half of the input digits to represent since multiplying
2168             // an N digit number by itself yield a 2N-1 digit or 2N
2169             // digit result.
2170             if (originalPrecision == 0) {
2171                 targetPrecision = stripped.precision()/2 + 1;
2172             } else {
<span class="line-modified">2173                 targetPrecision = originalPrecision;</span>


















2174             }
2175 
2176             // When setting the precision to use inside the Newton
2177             // iteration loop, take care to avoid the case where the
2178             // precision of the input exceeds the requested precision
2179             // and rounding the input value too soon.
2180             BigDecimal approx = guess;
2181             int workingPrecision = working.precision();
2182             do {
2183                 int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),
2184                                            workingPrecision);
2185                 MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);
2186                 // approx = 0.5 * (approx + fraction / approx)
2187                 approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));
2188                 guessPrecision *= 2;
2189             } while (guessPrecision &lt; targetPrecision + 2);
2190 
2191             BigDecimal result;
2192             RoundingMode targetRm = mc.getRoundingMode();
2193             if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {
2194                 RoundingMode tmpRm =
2195                     (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;
2196                 MathContext mcTmp = new MathContext(targetPrecision, tmpRm);
2197                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);
2198 
2199                 // If result*result != this numerically, the square
2200                 // root isn&#39;t exact
<span class="line-modified">2201                 if (this.subtract(result.multiply(result)).compareTo(ZERO) != 0) {</span>
2202                     throw new ArithmeticException(&quot;Computed square root not exact.&quot;);
2203                 }
2204             } else {
2205                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);










































2206             }
2207 



2208             if (result.scale() != preferredScale) {
2209                 // The preferred scale of an add is
2210                 // max(addend.scale(), augend.scale()). Therefore, if
2211                 // the scale of the result is first minimized using
2212                 // stripTrailingZeros(), adding a zero of the
<span class="line-modified">2213                 // preferred scale rounding the correct precision will</span>
<span class="line-modified">2214                 // perform the proper scale vs precision tradeoffs.</span>

2215                 result = result.stripTrailingZeros().
2216                     add(zeroWithFinalPreferredScale,
2217                         new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
2218             }
<span class="line-removed">2219             assert squareRootResultAssertions(result, mc);</span>
2220             return result;
2221         } else {

2222             switch (signum) {
2223             case -1:
2224                 throw new ArithmeticException(&quot;Attempted square root &quot; +
2225                                               &quot;of negative BigDecimal&quot;);
2226             case 0:
<span class="line-modified">2227                 return valueOf(0L, scale()/2);</span>


2228 
2229             default:
2230                 throw new AssertionError(&quot;Bad value from signum&quot;);
2231             }
2232         }
2233     }
2234 




2235     private boolean isPowerOfTen() {
2236         return BigInteger.ONE.equals(this.unscaledValue());
2237     }
2238 
2239     /**
2240      * For nonzero values, check numerical correctness properties of
2241      * the computed result for the chosen rounding mode.
2242      *
<span class="line-modified">2243      * For the directed roundings, for DOWN and FLOOR, result^2 must</span>
<span class="line-modified">2244      * be {@code &lt;=} the input and (result+ulp)^2 must be {@code &gt;} the</span>
<span class="line-modified">2245      * input. Conversely, for UP and CEIL, result^2 must be {@code &gt;=} the</span>
<span class="line-modified">2246      * input and (result-ulp)^2 must be {@code &lt;} the input.</span>






2247      */
2248     private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {
2249         if (result.signum() == 0) {
2250             return squareRootZeroResultAssertions(result, mc);
2251         } else {
2252             RoundingMode rm = mc.getRoundingMode();
2253             BigDecimal ulp = result.ulp();
2254             BigDecimal neighborUp   = result.add(ulp);
2255             // Make neighbor down accurate even for powers of ten
<span class="line-modified">2256             if (this.isPowerOfTen()) {</span>
2257                 ulp = ulp.divide(TEN);
2258             }
2259             BigDecimal neighborDown = result.subtract(ulp);
2260 
2261             // Both the starting value and result should be nonzero and positive.
<span class="line-modified">2262             if (result.signum() != 1 ||</span>
<span class="line-modified">2263                 this.signum() != 1) {</span>
<span class="line-modified">2264                 return false;</span>
<span class="line-removed">2265             }</span>
2266 
2267             switch (rm) {
2268             case DOWN:
2269             case FLOOR:
<span class="line-modified">2270                 return</span>
<span class="line-modified">2271                     result.multiply(result).compareTo(this)         &lt;= 0 &amp;&amp;</span>
<span class="line-modified">2272                     neighborUp.multiply(neighborUp).compareTo(this) &gt; 0;</span>


2273 
2274             case UP:
2275             case CEILING:
<span class="line-modified">2276                 return</span>
<span class="line-modified">2277                     result.multiply(result).compareTo(this)             &gt;= 0 &amp;&amp;</span>
<span class="line-modified">2278                     neighborDown.multiply(neighborDown).compareTo(this) &lt; 0;</span>



2279 
2280             case HALF_DOWN:
2281             case HALF_EVEN:
2282             case HALF_UP:
<span class="line-modified">2283                 BigDecimal err = result.multiply(result).subtract(this).abs();</span>
<span class="line-modified">2284                 BigDecimal errUp = neighborUp.multiply(neighborUp).subtract(this);</span>
<span class="line-modified">2285                 BigDecimal errDown =  this.subtract(neighborDown.multiply(neighborDown));</span>
2286                 // All error values should be positive so don&#39;t need to
2287                 // compare absolute values.
2288 
2289                 int err_comp_errUp = err.compareTo(errUp);
2290                 int err_comp_errDown = err.compareTo(errDown);
2291 
<span class="line-modified">2292                 return</span>
2293                     errUp.signum()   == 1 &amp;&amp;
<span class="line-modified">2294                     errDown.signum() == 1 &amp;&amp;</span>
<span class="line-modified">2295 </span>
<span class="line-modified">2296                     err_comp_errUp   &lt;= 0 &amp;&amp;</span>
<span class="line-modified">2297                     err_comp_errDown &lt;= 0 &amp;&amp;</span>
<span class="line-modified">2298 </span>










2299                     ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;
<span class="line-modified">2300                     ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true);</span>

2301                 // &amp;&amp; could check for digit conditions for ties too

2302 
2303             default: // Definition of UNNECESSARY already verified.
2304                 return true;
2305             }
2306         }
2307     }
2308 
2309     private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {
2310         return this.compareTo(ZERO) == 0;
2311     }
2312 
2313     /**
2314      * Returns a {@code BigDecimal} whose value is
2315      * &lt;code&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;, The power is computed exactly, to
2316      * unlimited precision.
2317      *
2318      * &lt;p&gt;The parameter {@code n} must be in the range 0 through
2319      * 999999999, inclusive.  {@code ZERO.pow(0)} returns {@link
2320      * #ONE}.
2321      *
</pre>
<hr />
<pre>
3397 
3398     /**
3399      * Converts this {@code BigDecimal} to a {@code long}.
3400      * This conversion is analogous to the
3401      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3402      * {@code short} as defined in
3403      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3404      * any fractional part of this
3405      * {@code BigDecimal} will be discarded, and if the resulting
3406      * &quot;{@code BigInteger}&quot; is too big to fit in a
3407      * {@code long}, only the low-order 64 bits are returned.
3408      * Note that this conversion can lose information about the
3409      * overall magnitude and precision of this {@code BigDecimal} value as well
3410      * as return a result with the opposite sign.
3411      *
3412      * @return this {@code BigDecimal} converted to a {@code long}.
3413      * @jls 5.1.3 Narrowing Primitive Conversion
3414      */
3415     @Override
3416     public long longValue(){
<span class="line-modified">3417         return (intCompact != INFLATED &amp;&amp; scale == 0) ?</span>
<span class="line-modified">3418             intCompact:</span>
<span class="line-modified">3419             toBigInteger().longValue();</span>























3420     }
3421 
3422     /**
3423      * Converts this {@code BigDecimal} to a {@code long}, checking
3424      * for lost information.  If this {@code BigDecimal} has a
3425      * nonzero fractional part or is out of the possible range for a
3426      * {@code long} result then an {@code ArithmeticException} is
3427      * thrown.
3428      *
3429      * @return this {@code BigDecimal} converted to a {@code long}.
3430      * @throws ArithmeticException if {@code this} has a nonzero
3431      *         fractional part, or will not fit in a {@code long}.
3432      * @since  1.5
3433      */
3434     public long longValueExact() {
3435         if (intCompact != INFLATED &amp;&amp; scale == 0)
3436             return intCompact;
<span class="line-modified">3437         // If more than 19 digits in integer part it cannot possibly fit</span>
<span class="line-modified">3438         if ((precision() - scale) &gt; 19) // [OK for negative scale too]</span>
<span class="line-removed">3439             throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="line-removed">3440         // Fastpath zero and &lt; 1.0 numbers (the latter can be very slow</span>
<span class="line-removed">3441         // to round if very small)</span>
3442         if (this.signum() == 0)
3443             return 0;
<span class="line-modified">3444         if ((this.precision() - this.scale) &lt;= 0)</span>



3445             throw new ArithmeticException(&quot;Rounding necessary&quot;);





3446         // round to an integer, with Exception if decimal part non-0
3447         BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);
3448         if (num.precision() &gt;= 19) // need to check carefully
3449             LongOverflow.check(num);
3450         return num.inflated().longValue();
3451     }
3452 
3453     private static class LongOverflow {
3454         /** BigInteger equal to Long.MIN_VALUE. */
3455         private static final BigInteger LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
3456 
3457         /** BigInteger equal to Long.MAX_VALUE. */
3458         private static final BigInteger LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
3459 
3460         public static void check(BigDecimal num) {
3461             BigInteger intVal = num.inflated();
3462             if (intVal.compareTo(LONGMIN) &lt; 0 ||
3463                 intVal.compareTo(LONGMAX) &gt; 0)
3464                 throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3465         }
</pre>
<hr />
<pre>
3469      * Converts this {@code BigDecimal} to an {@code int}.
3470      * This conversion is analogous to the
3471      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3472      * {@code short} as defined in
3473      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3474      * any fractional part of this
3475      * {@code BigDecimal} will be discarded, and if the resulting
3476      * &quot;{@code BigInteger}&quot; is too big to fit in an
3477      * {@code int}, only the low-order 32 bits are returned.
3478      * Note that this conversion can lose information about the
3479      * overall magnitude and precision of this {@code BigDecimal}
3480      * value as well as return a result with the opposite sign.
3481      *
3482      * @return this {@code BigDecimal} converted to an {@code int}.
3483      * @jls 5.1.3 Narrowing Primitive Conversion
3484      */
3485     @Override
3486     public int intValue() {
3487         return  (intCompact != INFLATED &amp;&amp; scale == 0) ?
3488             (int)intCompact :
<span class="line-modified">3489             toBigInteger().intValue();</span>
3490     }
3491 
3492     /**
3493      * Converts this {@code BigDecimal} to an {@code int}, checking
3494      * for lost information.  If this {@code BigDecimal} has a
3495      * nonzero fractional part or is out of the possible range for an
3496      * {@code int} result then an {@code ArithmeticException} is
3497      * thrown.
3498      *
3499      * @return this {@code BigDecimal} converted to an {@code int}.
3500      * @throws ArithmeticException if {@code this} has a nonzero
3501      *         fractional part, or will not fit in an {@code int}.
3502      * @since  1.5
3503      */
3504     public int intValueExact() {
3505        long num;
3506        num = this.longValueExact();     // will check decimal part
3507        if ((int)num != num)
3508            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3509        return (int)num;
</pre>
<hr />
<pre>
4082         private static final long intCompactOffset
4083                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intCompact&quot;);
4084         private static final long intValOffset
4085                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intVal&quot;);
4086 
4087         static void setIntCompact(BigDecimal bd, long val) {
4088             unsafe.putLong(bd, intCompactOffset, val);
4089         }
4090 
4091         static void setIntValVolatile(BigDecimal bd, BigInteger val) {
4092             unsafe.putReferenceVolatile(bd, intValOffset, val);
4093         }
4094     }
4095 
4096     /**
4097      * Reconstitute the {@code BigDecimal} instance from a stream (that is,
4098      * deserialize it).
4099      *
4100      * @param s the stream being read.
4101      */

4102     private void readObject(java.io.ObjectInputStream s)
4103         throws java.io.IOException, ClassNotFoundException {
4104         // Read in all fields
4105         s.defaultReadObject();
4106         // validate possibly bad fields
4107         if (intVal == null) {
4108             String message = &quot;BigDecimal: null intVal in stream&quot;;
4109             throw new java.io.StreamCorruptedException(message);
4110         // [all values of scale are now allowed]
4111         }
4112         UnsafeHolder.setIntCompact(this, compactValFor(intVal));
4113     }
4114 
4115    /**
4116     * Serialize this {@code BigDecimal} to the stream in question
4117     *
4118     * @param s the stream to serialize to.
4119     */

4120    private void writeObject(java.io.ObjectOutputStream s)
4121        throws java.io.IOException {
4122        // Must inflate to maintain compatible serial form.
4123        if (this.intVal == null)
4124            UnsafeHolder.setIntValVolatile(this, BigInteger.valueOf(this.intCompact));
4125        // Could reset intVal back to null if it has to be set.
4126        s.defaultWriteObject();
4127    }
4128 
4129     /**
4130      * Returns the length of the absolute value of a {@code long}, in decimal
4131      * digits.
4132      *
4133      * @param x the {@code long}
4134      * @return the length of the unscaled value, in deciaml digits.
4135      */
4136     static int longDigitLength(long x) {
4137         /*
4138          * As described in &quot;Bit Twiddling Hacks&quot; by Sean Anderson,
4139          * (http://graphics.stanford.edu/~seander/bithacks.html)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 263     /**
 264      * Sentinel value for {@link #intCompact} indicating the
 265      * significand information is only available from {@code intVal}.
 266      */
 267     static final long INFLATED = Long.MIN_VALUE;
 268 
 269     private static final BigInteger INFLATED_BIGINT = BigInteger.valueOf(INFLATED);
 270 
 271     /**
 272      * If the absolute value of the significand of this BigDecimal is
 273      * less than or equal to {@code Long.MAX_VALUE}, the value can be
 274      * compactly stored in this field and used in computations.
 275      */
 276     private final transient long intCompact;
 277 
 278     // All 18-digit base ten strings fit into a long; not all 19-digit
 279     // strings will
 280     private static final int MAX_COMPACT_DIGITS = 18;
 281 
 282     /* Appease the serialization gods */
<span class="line-added"> 283     @java.io.Serial</span>
 284     private static final long serialVersionUID = 6108874887143696463L;
 285 
 286     private static final ThreadLocal&lt;StringBuilderHelper&gt;
 287         threadLocalStringBuilderHelper = new ThreadLocal&lt;StringBuilderHelper&gt;() {
 288         @Override
 289         protected StringBuilderHelper initialValue() {
 290             return new StringBuilderHelper();
 291         }
 292     };
 293 
 294     // Cache of common small BigDecimal values.
 295     private static final BigDecimal ZERO_THROUGH_TEN[] = {
 296         new BigDecimal(BigInteger.ZERO,       0,  0, 1),
 297         new BigDecimal(BigInteger.ONE,        1,  0, 1),
 298         new BigDecimal(BigInteger.TWO,        2,  0, 1),
 299         new BigDecimal(BigInteger.valueOf(3), 3,  0, 1),
 300         new BigDecimal(BigInteger.valueOf(4), 4,  0, 1),
 301         new BigDecimal(BigInteger.valueOf(5), 5,  0, 1),
 302         new BigDecimal(BigInteger.valueOf(6), 6,  0, 1),
 303         new BigDecimal(BigInteger.valueOf(7), 7,  0, 1),
</pre>
<hr />
<pre>
2102                 strippedScale % 2 == 0) {
2103                 BigDecimal result = valueOf(1L, strippedScale/2);
2104                 if (result.scale() != preferredScale) {
2105                     // Adjust to requested precision and preferred
2106                     // scale as appropriate.
2107                     result = result.add(zeroWithFinalPreferredScale, mc);
2108                 }
2109                 return result;
2110             }
2111 
2112             // After stripTrailingZeros, the representation is normalized as
2113             //
2114             // unscaledValue * 10^(-scale)
2115             //
2116             // where unscaledValue is an integer with the mimimum
2117             // precision for the cohort of the numerical value. To
2118             // allow binary floating-point hardware to be used to get
2119             // approximately a 15 digit approximation to the square
2120             // root, it is helpful to instead normalize this so that
2121             // the significand portion is to right of the decimal
<span class="line-modified">2122             // point by roughly (scale() - precision() + 1).</span>
2123 
2124             // Now the precision / scale adjustment
2125             int scaleAdjust = 0;
2126             int scale = stripped.scale() - stripped.precision() + 1;
2127             if (scale % 2 == 0) {
2128                 scaleAdjust = scale;
2129             } else {
2130                 scaleAdjust = scale - 1;
2131             }
2132 
2133             BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);
2134 
2135             assert  // Verify 0.1 &lt;= working &lt; 10
2136                 ONE_TENTH.compareTo(working) &lt;= 0 &amp;&amp; working.compareTo(TEN) &lt; 0;
2137 
2138             // Use good ole&#39; Math.sqrt to get the initial guess for
2139             // the Newton iteration, good to at least 15 decimal
2140             // digits. This approach does incur the cost of a
2141             //
2142             // BigDecimal -&gt; double -&gt; BigDecimal
2143             //
2144             // conversion cycle, but it avoids the need for several
2145             // Newton iterations in BigDecimal arithmetic to get the
2146             // working answer to 15 digits of precision. If many fewer
2147             // than 15 digits were needed, it might be faster to do
2148             // the loop entirely in BigDecimal arithmetic.
2149             //
<span class="line-modified">2150             // (A double value might have as many as 17 decimal</span>
2151             // digits of precision; it depends on the relative density
2152             // of binary and decimal numbers at different regions of
2153             // the number line.)
2154             //
2155             // (It would be possible to check for certain special
2156             // cases to avoid doing any Newton iterations. For
2157             // example, if the BigDecimal -&gt; double conversion was
2158             // known to be exact and the rounding mode had a
2159             // low-enough precision, the post-Newton rounding logic
2160             // could be applied directly.)
2161 
2162             BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));
2163             int guessPrecision = 15;
2164             int originalPrecision = mc.getPrecision();
2165             int targetPrecision;
2166 
2167             // If an exact value is requested, it must only need about
2168             // half of the input digits to represent since multiplying
2169             // an N digit number by itself yield a 2N-1 digit or 2N
2170             // digit result.
2171             if (originalPrecision == 0) {
2172                 targetPrecision = stripped.precision()/2 + 1;
2173             } else {
<span class="line-modified">2174                 /*</span>
<span class="line-added">2175                  * To avoid the need for post-Newton fix-up logic, in</span>
<span class="line-added">2176                  * the case of half-way rounding modes, double the</span>
<span class="line-added">2177                  * target precision so that the &quot;2p + 2&quot; property can</span>
<span class="line-added">2178                  * be relied on to accomplish the final rounding.</span>
<span class="line-added">2179                  */</span>
<span class="line-added">2180                 switch (mc.getRoundingMode()) {</span>
<span class="line-added">2181                 case HALF_UP:</span>
<span class="line-added">2182                 case HALF_DOWN:</span>
<span class="line-added">2183                 case HALF_EVEN:</span>
<span class="line-added">2184                     targetPrecision = 2 * originalPrecision;</span>
<span class="line-added">2185                     if (targetPrecision &lt; 0) // Overflow</span>
<span class="line-added">2186                         targetPrecision = Integer.MAX_VALUE - 2;</span>
<span class="line-added">2187                     break;</span>
<span class="line-added">2188 </span>
<span class="line-added">2189                 default:</span>
<span class="line-added">2190                     targetPrecision = originalPrecision;</span>
<span class="line-added">2191                     break;</span>
<span class="line-added">2192                 }</span>
2193             }
2194 
2195             // When setting the precision to use inside the Newton
2196             // iteration loop, take care to avoid the case where the
2197             // precision of the input exceeds the requested precision
2198             // and rounding the input value too soon.
2199             BigDecimal approx = guess;
2200             int workingPrecision = working.precision();
2201             do {
2202                 int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),
2203                                            workingPrecision);
2204                 MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);
2205                 // approx = 0.5 * (approx + fraction / approx)
2206                 approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));
2207                 guessPrecision *= 2;
2208             } while (guessPrecision &lt; targetPrecision + 2);
2209 
2210             BigDecimal result;
2211             RoundingMode targetRm = mc.getRoundingMode();
2212             if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {
2213                 RoundingMode tmpRm =
2214                     (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;
2215                 MathContext mcTmp = new MathContext(targetPrecision, tmpRm);
2216                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);
2217 
2218                 // If result*result != this numerically, the square
2219                 // root isn&#39;t exact
<span class="line-modified">2220                 if (this.subtract(result.square()).compareTo(ZERO) != 0) {</span>
2221                     throw new ArithmeticException(&quot;Computed square root not exact.&quot;);
2222                 }
2223             } else {
2224                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);
<span class="line-added">2225 </span>
<span class="line-added">2226                 switch (targetRm) {</span>
<span class="line-added">2227                 case DOWN:</span>
<span class="line-added">2228                 case FLOOR:</span>
<span class="line-added">2229                     // Check if too big</span>
<span class="line-added">2230                     if (result.square().compareTo(this) &gt; 0) {</span>
<span class="line-added">2231                         BigDecimal ulp = result.ulp();</span>
<span class="line-added">2232                         // Adjust increment down in case of 1.0 = 10^0</span>
<span class="line-added">2233                         // since the next smaller number is only 1/10</span>
<span class="line-added">2234                         // as far way as the next larger at exponent</span>
<span class="line-added">2235                         // boundaries. Test approx and *not* result to</span>
<span class="line-added">2236                         // avoid having to detect an arbitrary power</span>
<span class="line-added">2237                         // of ten.</span>
<span class="line-added">2238                         if (approx.compareTo(ONE) == 0) {</span>
<span class="line-added">2239                             ulp = ulp.multiply(ONE_TENTH);</span>
<span class="line-added">2240                         }</span>
<span class="line-added">2241                         result = result.subtract(ulp);</span>
<span class="line-added">2242                     }</span>
<span class="line-added">2243                     break;</span>
<span class="line-added">2244 </span>
<span class="line-added">2245                 case UP:</span>
<span class="line-added">2246                 case CEILING:</span>
<span class="line-added">2247                     // Check if too small</span>
<span class="line-added">2248                     if (result.square().compareTo(this) &lt; 0) {</span>
<span class="line-added">2249                         result = result.add(result.ulp());</span>
<span class="line-added">2250                     }</span>
<span class="line-added">2251                     break;</span>
<span class="line-added">2252 </span>
<span class="line-added">2253                 default:</span>
<span class="line-added">2254                     // No additional work, rely on &quot;2p + 2&quot; property</span>
<span class="line-added">2255                     // for correct rounding. Alternatively, could</span>
<span class="line-added">2256                     // instead run the Newton iteration to around p</span>
<span class="line-added">2257                     // digits and then do tests and fix-ups on the</span>
<span class="line-added">2258                     // rounded value. One possible set of tests and</span>
<span class="line-added">2259                     // fix-ups is given in the Hull and Abrham paper;</span>
<span class="line-added">2260                     // however, additional half-way cases can occur</span>
<span class="line-added">2261                     // for BigDecimal given the more varied</span>
<span class="line-added">2262                     // combinations of input and output precisions</span>
<span class="line-added">2263                     // supported.</span>
<span class="line-added">2264                     break;</span>
<span class="line-added">2265                 }</span>
<span class="line-added">2266 </span>
2267             }
2268 
<span class="line-added">2269             // Test numerical properties at full precision before any</span>
<span class="line-added">2270             // scale adjustments.</span>
<span class="line-added">2271             assert squareRootResultAssertions(result, mc);</span>
2272             if (result.scale() != preferredScale) {
2273                 // The preferred scale of an add is
2274                 // max(addend.scale(), augend.scale()). Therefore, if
2275                 // the scale of the result is first minimized using
2276                 // stripTrailingZeros(), adding a zero of the
<span class="line-modified">2277                 // preferred scale rounding to the correct precision</span>
<span class="line-modified">2278                 // will perform the proper scale vs precision</span>
<span class="line-added">2279                 // tradeoffs.</span>
2280                 result = result.stripTrailingZeros().
2281                     add(zeroWithFinalPreferredScale,
2282                         new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
2283             }

2284             return result;
2285         } else {
<span class="line-added">2286             BigDecimal result = null;</span>
2287             switch (signum) {
2288             case -1:
2289                 throw new ArithmeticException(&quot;Attempted square root &quot; +
2290                                               &quot;of negative BigDecimal&quot;);
2291             case 0:
<span class="line-modified">2292                 result = valueOf(0L, scale()/2);</span>
<span class="line-added">2293                 assert squareRootResultAssertions(result, mc);</span>
<span class="line-added">2294                 return result;</span>
2295 
2296             default:
2297                 throw new AssertionError(&quot;Bad value from signum&quot;);
2298             }
2299         }
2300     }
2301 
<span class="line-added">2302     private BigDecimal square() {</span>
<span class="line-added">2303         return this.multiply(this);</span>
<span class="line-added">2304     }</span>
<span class="line-added">2305 </span>
2306     private boolean isPowerOfTen() {
2307         return BigInteger.ONE.equals(this.unscaledValue());
2308     }
2309 
2310     /**
2311      * For nonzero values, check numerical correctness properties of
2312      * the computed result for the chosen rounding mode.
2313      *
<span class="line-modified">2314      * For the directed rounding modes:</span>
<span class="line-modified">2315      *</span>
<span class="line-modified">2316      * &lt;ul&gt;</span>
<span class="line-modified">2317      *</span>
<span class="line-added">2318      * &lt;li&gt; For DOWN and FLOOR, result^2 must be {@code &lt;=} the input</span>
<span class="line-added">2319      * and (result+ulp)^2 must be {@code &gt;} the input.</span>
<span class="line-added">2320      *</span>
<span class="line-added">2321      * &lt;li&gt;Conversely, for UP and CEIL, result^2 must be {@code &gt;=}</span>
<span class="line-added">2322      * the input and (result-ulp)^2 must be {@code &lt;} the input.</span>
<span class="line-added">2323      * &lt;/ul&gt;</span>
2324      */
2325     private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {
2326         if (result.signum() == 0) {
2327             return squareRootZeroResultAssertions(result, mc);
2328         } else {
2329             RoundingMode rm = mc.getRoundingMode();
2330             BigDecimal ulp = result.ulp();
2331             BigDecimal neighborUp   = result.add(ulp);
2332             // Make neighbor down accurate even for powers of ten
<span class="line-modified">2333             if (result.isPowerOfTen()) {</span>
2334                 ulp = ulp.divide(TEN);
2335             }
2336             BigDecimal neighborDown = result.subtract(ulp);
2337 
2338             // Both the starting value and result should be nonzero and positive.
<span class="line-modified">2339             assert (result.signum() == 1 &amp;&amp;</span>
<span class="line-modified">2340                     this.signum() == 1) :</span>
<span class="line-modified">2341                 &quot;Bad signum of this and/or its sqrt.&quot;;</span>

2342 
2343             switch (rm) {
2344             case DOWN:
2345             case FLOOR:
<span class="line-modified">2346                 assert</span>
<span class="line-modified">2347                     result.square().compareTo(this)     &lt;= 0 &amp;&amp;</span>
<span class="line-modified">2348                     neighborUp.square().compareTo(this) &gt; 0:</span>
<span class="line-added">2349                 &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">2350                 return true;</span>
2351 
2352             case UP:
2353             case CEILING:
<span class="line-modified">2354                 assert</span>
<span class="line-modified">2355                     result.square().compareTo(this)       &gt;= 0 &amp;&amp;</span>
<span class="line-modified">2356                     neighborDown.square().compareTo(this) &lt; 0:</span>
<span class="line-added">2357                 &quot;Square of result out for bounds rounding &quot; + rm;</span>
<span class="line-added">2358                 return true;</span>
<span class="line-added">2359 </span>
2360 
2361             case HALF_DOWN:
2362             case HALF_EVEN:
2363             case HALF_UP:
<span class="line-modified">2364                 BigDecimal err = result.square().subtract(this).abs();</span>
<span class="line-modified">2365                 BigDecimal errUp = neighborUp.square().subtract(this);</span>
<span class="line-modified">2366                 BigDecimal errDown =  this.subtract(neighborDown.square());</span>
2367                 // All error values should be positive so don&#39;t need to
2368                 // compare absolute values.
2369 
2370                 int err_comp_errUp = err.compareTo(errUp);
2371                 int err_comp_errDown = err.compareTo(errDown);
2372 
<span class="line-modified">2373                 assert</span>
2374                     errUp.signum()   == 1 &amp;&amp;
<span class="line-modified">2375                     errDown.signum() == 1 :</span>
<span class="line-modified">2376                 &quot;Errors of neighbors squared don&#39;t have correct signs&quot;;</span>
<span class="line-modified">2377 </span>
<span class="line-modified">2378                 // For breaking a half-way tie, the return value may</span>
<span class="line-modified">2379                 // have a larger error than one of the neighbors. For</span>
<span class="line-added">2380                 // example, the square root of 2.25 to a precision of</span>
<span class="line-added">2381                 // 1 digit is either 1 or 2 depending on how the exact</span>
<span class="line-added">2382                 // value of 1.5 is rounded. If 2 is returned, it will</span>
<span class="line-added">2383                 // have a larger rounding error than its neighbor 1.</span>
<span class="line-added">2384                 assert</span>
<span class="line-added">2385                     err_comp_errUp   &lt;= 0 ||</span>
<span class="line-added">2386                     err_comp_errDown &lt;= 0 :</span>
<span class="line-added">2387                 &quot;Computed square root has larger error than neighbors for &quot; + rm;</span>
<span class="line-added">2388 </span>
<span class="line-added">2389                 assert</span>
2390                     ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;
<span class="line-modified">2391                     ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true) :</span>
<span class="line-added">2392                         &quot;Incorrect error relationships&quot;;</span>
2393                 // &amp;&amp; could check for digit conditions for ties too
<span class="line-added">2394                 return true;</span>
2395 
2396             default: // Definition of UNNECESSARY already verified.
2397                 return true;
2398             }
2399         }
2400     }
2401 
2402     private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {
2403         return this.compareTo(ZERO) == 0;
2404     }
2405 
2406     /**
2407      * Returns a {@code BigDecimal} whose value is
2408      * &lt;code&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;, The power is computed exactly, to
2409      * unlimited precision.
2410      *
2411      * &lt;p&gt;The parameter {@code n} must be in the range 0 through
2412      * 999999999, inclusive.  {@code ZERO.pow(0)} returns {@link
2413      * #ONE}.
2414      *
</pre>
<hr />
<pre>
3490 
3491     /**
3492      * Converts this {@code BigDecimal} to a {@code long}.
3493      * This conversion is analogous to the
3494      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3495      * {@code short} as defined in
3496      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3497      * any fractional part of this
3498      * {@code BigDecimal} will be discarded, and if the resulting
3499      * &quot;{@code BigInteger}&quot; is too big to fit in a
3500      * {@code long}, only the low-order 64 bits are returned.
3501      * Note that this conversion can lose information about the
3502      * overall magnitude and precision of this {@code BigDecimal} value as well
3503      * as return a result with the opposite sign.
3504      *
3505      * @return this {@code BigDecimal} converted to a {@code long}.
3506      * @jls 5.1.3 Narrowing Primitive Conversion
3507      */
3508     @Override
3509     public long longValue(){
<span class="line-modified">3510         if (intCompact != INFLATED &amp;&amp; scale == 0) {</span>
<span class="line-modified">3511             return intCompact;</span>
<span class="line-modified">3512         } else {</span>
<span class="line-added">3513             // Fastpath zero and small values</span>
<span class="line-added">3514             if (this.signum() == 0 || fractionOnly() ||</span>
<span class="line-added">3515                 // Fastpath very large-scale values that will result</span>
<span class="line-added">3516                 // in a truncated value of zero. If the scale is -64</span>
<span class="line-added">3517                 // or less, there are at least 64 powers of 10 in the</span>
<span class="line-added">3518                 // value of the numerical result. Since 10 = 2*5, in</span>
<span class="line-added">3519                 // that case there would also be 64 powers of 2 in the</span>
<span class="line-added">3520                 // result, meaning all 64 bits of a long will be zero.</span>
<span class="line-added">3521                 scale &lt;= -64) {</span>
<span class="line-added">3522                 return 0;</span>
<span class="line-added">3523             } else {</span>
<span class="line-added">3524                 return toBigInteger().longValue();</span>
<span class="line-added">3525             }</span>
<span class="line-added">3526         }</span>
<span class="line-added">3527     }</span>
<span class="line-added">3528 </span>
<span class="line-added">3529     /**</span>
<span class="line-added">3530      * Return true if a nonzero BigDecimal has an absolute value less</span>
<span class="line-added">3531      * than one; i.e. only has fraction digits.</span>
<span class="line-added">3532      */</span>
<span class="line-added">3533     private boolean fractionOnly() {</span>
<span class="line-added">3534         assert this.signum() != 0;</span>
<span class="line-added">3535         return (this.precision() - this.scale) &lt;= 0;</span>
3536     }
3537 
3538     /**
3539      * Converts this {@code BigDecimal} to a {@code long}, checking
3540      * for lost information.  If this {@code BigDecimal} has a
3541      * nonzero fractional part or is out of the possible range for a
3542      * {@code long} result then an {@code ArithmeticException} is
3543      * thrown.
3544      *
3545      * @return this {@code BigDecimal} converted to a {@code long}.
3546      * @throws ArithmeticException if {@code this} has a nonzero
3547      *         fractional part, or will not fit in a {@code long}.
3548      * @since  1.5
3549      */
3550     public long longValueExact() {
3551         if (intCompact != INFLATED &amp;&amp; scale == 0)
3552             return intCompact;
<span class="line-modified">3553 </span>
<span class="line-modified">3554         // Fastpath zero</span>



3555         if (this.signum() == 0)
3556             return 0;
<span class="line-modified">3557 </span>
<span class="line-added">3558         // Fastpath numbers less than 1.0 (the latter can be very slow</span>
<span class="line-added">3559         // to round if very small)</span>
<span class="line-added">3560         if (fractionOnly())</span>
3561             throw new ArithmeticException(&quot;Rounding necessary&quot;);
<span class="line-added">3562 </span>
<span class="line-added">3563         // If more than 19 digits in integer part it cannot possibly fit</span>
<span class="line-added">3564         if ((precision() - scale) &gt; 19) // [OK for negative scale too]</span>
<span class="line-added">3565             throw new java.lang.ArithmeticException(&quot;Overflow&quot;);</span>
<span class="line-added">3566 </span>
3567         // round to an integer, with Exception if decimal part non-0
3568         BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);
3569         if (num.precision() &gt;= 19) // need to check carefully
3570             LongOverflow.check(num);
3571         return num.inflated().longValue();
3572     }
3573 
3574     private static class LongOverflow {
3575         /** BigInteger equal to Long.MIN_VALUE. */
3576         private static final BigInteger LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
3577 
3578         /** BigInteger equal to Long.MAX_VALUE. */
3579         private static final BigInteger LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
3580 
3581         public static void check(BigDecimal num) {
3582             BigInteger intVal = num.inflated();
3583             if (intVal.compareTo(LONGMIN) &lt; 0 ||
3584                 intVal.compareTo(LONGMAX) &gt; 0)
3585                 throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3586         }
</pre>
<hr />
<pre>
3590      * Converts this {@code BigDecimal} to an {@code int}.
3591      * This conversion is analogous to the
3592      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3593      * {@code short} as defined in
3594      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3595      * any fractional part of this
3596      * {@code BigDecimal} will be discarded, and if the resulting
3597      * &quot;{@code BigInteger}&quot; is too big to fit in an
3598      * {@code int}, only the low-order 32 bits are returned.
3599      * Note that this conversion can lose information about the
3600      * overall magnitude and precision of this {@code BigDecimal}
3601      * value as well as return a result with the opposite sign.
3602      *
3603      * @return this {@code BigDecimal} converted to an {@code int}.
3604      * @jls 5.1.3 Narrowing Primitive Conversion
3605      */
3606     @Override
3607     public int intValue() {
3608         return  (intCompact != INFLATED &amp;&amp; scale == 0) ?
3609             (int)intCompact :
<span class="line-modified">3610             (int)longValue();</span>
3611     }
3612 
3613     /**
3614      * Converts this {@code BigDecimal} to an {@code int}, checking
3615      * for lost information.  If this {@code BigDecimal} has a
3616      * nonzero fractional part or is out of the possible range for an
3617      * {@code int} result then an {@code ArithmeticException} is
3618      * thrown.
3619      *
3620      * @return this {@code BigDecimal} converted to an {@code int}.
3621      * @throws ArithmeticException if {@code this} has a nonzero
3622      *         fractional part, or will not fit in an {@code int}.
3623      * @since  1.5
3624      */
3625     public int intValueExact() {
3626        long num;
3627        num = this.longValueExact();     // will check decimal part
3628        if ((int)num != num)
3629            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3630        return (int)num;
</pre>
<hr />
<pre>
4203         private static final long intCompactOffset
4204                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intCompact&quot;);
4205         private static final long intValOffset
4206                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intVal&quot;);
4207 
4208         static void setIntCompact(BigDecimal bd, long val) {
4209             unsafe.putLong(bd, intCompactOffset, val);
4210         }
4211 
4212         static void setIntValVolatile(BigDecimal bd, BigInteger val) {
4213             unsafe.putReferenceVolatile(bd, intValOffset, val);
4214         }
4215     }
4216 
4217     /**
4218      * Reconstitute the {@code BigDecimal} instance from a stream (that is,
4219      * deserialize it).
4220      *
4221      * @param s the stream being read.
4222      */
<span class="line-added">4223     @java.io.Serial</span>
4224     private void readObject(java.io.ObjectInputStream s)
4225         throws java.io.IOException, ClassNotFoundException {
4226         // Read in all fields
4227         s.defaultReadObject();
4228         // validate possibly bad fields
4229         if (intVal == null) {
4230             String message = &quot;BigDecimal: null intVal in stream&quot;;
4231             throw new java.io.StreamCorruptedException(message);
4232         // [all values of scale are now allowed]
4233         }
4234         UnsafeHolder.setIntCompact(this, compactValFor(intVal));
4235     }
4236 
4237    /**
4238     * Serialize this {@code BigDecimal} to the stream in question
4239     *
4240     * @param s the stream to serialize to.
4241     */
<span class="line-added">4242     @java.io.Serial</span>
4243    private void writeObject(java.io.ObjectOutputStream s)
4244        throws java.io.IOException {
4245        // Must inflate to maintain compatible serial form.
4246        if (this.intVal == null)
4247            UnsafeHolder.setIntValVolatile(this, BigInteger.valueOf(this.intCompact));
4248        // Could reset intVal back to null if it has to be set.
4249        s.defaultWriteObject();
4250    }
4251 
4252     /**
4253      * Returns the length of the absolute value of a {@code long}, in decimal
4254      * digits.
4255      *
4256      * @param x the {@code long}
4257      * @return the length of the unscaled value, in deciaml digits.
4258      */
4259     static int longDigitLength(long x) {
4260         /*
4261          * As described in &quot;Bit Twiddling Hacks&quot; by Sean Anderson,
4262          * (http://graphics.stanford.edu/~seander/bithacks.html)
</pre>
</td>
</tr>
</table>
<center><a href="../lang/reflect/UndeclaredThrowableException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BigInteger.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
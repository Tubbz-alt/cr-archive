<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/StringConcatHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
<a name="2" id="anc2"></a><span class="line-added"> 28 import jdk.internal.misc.Unsafe;</span>
<span class="line-added"> 29 import jdk.internal.vm.annotation.ForceInline;</span>
<span class="line-added"> 30 </span>
 31 /**
 32  * Helper for string concatenation. These methods are mostly looked up with private lookups
 33  * from {@link java.lang.invoke.StringConcatFactory}, and used in {@link java.lang.invoke.MethodHandle}
 34  * combinators there.
 35  */
 36 final class StringConcatHelper {
 37 
 38     private StringConcatHelper() {
 39         // no instantiation
 40     }
 41 
 42     /**
 43      * Check for overflow, throw exception on overflow.
<a name="3" id="anc3"></a><span class="line-modified"> 44      *</span>
<span class="line-modified"> 45      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-added"> 46      *                    the upper word.</span>
<span class="line-added"> 47      * @return            the given parameter value, if valid</span>
 48      */
 49     private static long checkOverflow(long lengthCoder) {
 50         if ((int)lengthCoder &gt;= 0) {
 51             return lengthCoder;
 52         }
 53         throw new OutOfMemoryError(&quot;Overflow: String length out of range&quot;);
 54     }
 55 
 56     /**
 57      * Mix value length and coder into current length and coder.
<a name="4" id="anc4"></a><span class="line-modified"> 58      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 59      *                    the upper word.</span>
<span class="line-modified"> 60      * @param value       value to mix in</span>
<span class="line-added"> 61      * @return            new length and coder</span>
 62      */
<a name="5" id="anc5"></a><span class="line-modified"> 63     static long mix(long lengthCoder, boolean value) {</span>
<span class="line-modified"> 64         return checkOverflow(lengthCoder + (value ? 4 : 5));</span>
 65     }
 66 
 67     /**
 68      * Mix value length and coder into current length and coder.
<a name="6" id="anc6"></a><span class="line-modified"> 69      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 70      *                    the upper word.</span>
<span class="line-modified"> 71      * @param value       value to mix in</span>
<span class="line-added"> 72      * @return            new length and coder</span>
 73      */
<a name="7" id="anc7"></a><span class="line-modified"> 74     static long mix(long lengthCoder, byte value) {</span>
<span class="line-modified"> 75         return mix(lengthCoder, (int)value);</span>
 76     }
 77 
 78     /**
 79      * Mix value length and coder into current length and coder.
<a name="8" id="anc8"></a><span class="line-modified"> 80      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 81      *                    the upper word.</span>
<span class="line-modified"> 82      * @param value       value to mix in</span>
<span class="line-added"> 83      * @return            new length and coder</span>
 84      */
<a name="9" id="anc9"></a><span class="line-modified"> 85     static long mix(long lengthCoder, char value) {</span>
<span class="line-modified"> 86         return checkOverflow(lengthCoder + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);</span>
 87     }
 88 
 89     /**
 90      * Mix value length and coder into current length and coder.
<a name="10" id="anc10"></a><span class="line-modified"> 91      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified"> 92      *                    the upper word.</span>
<span class="line-modified"> 93      * @param value       value to mix in</span>
<span class="line-added"> 94      * @return            new length and coder</span>
 95      */
<a name="11" id="anc11"></a><span class="line-modified"> 96     static long mix(long lengthCoder, short value) {</span>
<span class="line-modified"> 97         return mix(lengthCoder, (int)value);</span>
 98     }
 99 
100     /**
101      * Mix value length and coder into current length and coder.
<a name="12" id="anc12"></a><span class="line-modified">102      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">103      *                    the upper word.</span>
<span class="line-modified">104      * @param value       value to mix in</span>
<span class="line-added">105      * @return            new length and coder</span>
106      */
<a name="13" id="anc13"></a><span class="line-modified">107     static long mix(long lengthCoder, int value) {</span>
<span class="line-modified">108         return checkOverflow(lengthCoder + Integer.stringSize(value));</span>
109     }
110 
111     /**
112      * Mix value length and coder into current length and coder.
<a name="14" id="anc14"></a><span class="line-modified">113      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">114      *                    the upper word.</span>
<span class="line-modified">115      * @param value       value to mix in</span>
<span class="line-added">116      * @return            new length and coder</span>
117      */
<a name="15" id="anc15"></a><span class="line-modified">118     static long mix(long lengthCoder, long value) {</span>
<span class="line-modified">119         return checkOverflow(lengthCoder + Long.stringSize(value));</span>
120     }
121 
122     /**
123      * Mix value length and coder into current length and coder.
<a name="16" id="anc16"></a><span class="line-modified">124      * @param lengthCoder String length with coder packed into higher bits</span>
<span class="line-modified">125      *                    the upper word.</span>
<span class="line-modified">126      * @param value       value to mix in</span>
<span class="line-added">127      * @return            new length and coder</span>
128      */
<a name="17" id="anc17"></a><span class="line-modified">129     static long mix(long lengthCoder, String value) {</span>
<span class="line-modified">130         lengthCoder += value.length();</span>
131         if (value.coder() == String.UTF16) {
<a name="18" id="anc18"></a><span class="line-modified">132             lengthCoder |= UTF16;</span>
133         }
<a name="19" id="anc19"></a><span class="line-modified">134         return checkOverflow(lengthCoder);</span>
135     }
136 
137     /**
138      * Prepends the stringly representation of boolean value into buffer,
139      * given the coder and final index. Index is measured in chars, not in bytes!
140      *
141      * @param indexCoder final char index in the buffer, along with coder packed
142      *                   into higher bits.
143      * @param buf        buffer to append to
144      * @param value      boolean value to encode
145      * @return           updated index (coder value retained)
146      */
<a name="20" id="anc20"></a><span class="line-modified">147     private static long prepend(long indexCoder, byte[] buf, boolean value) {</span>
148         int index = (int)indexCoder;
149         if (indexCoder &lt; UTF16) {
150             if (value) {
151                 buf[--index] = &#39;e&#39;;
152                 buf[--index] = &#39;u&#39;;
153                 buf[--index] = &#39;r&#39;;
154                 buf[--index] = &#39;t&#39;;
155             } else {
156                 buf[--index] = &#39;e&#39;;
157                 buf[--index] = &#39;s&#39;;
158                 buf[--index] = &#39;l&#39;;
159                 buf[--index] = &#39;a&#39;;
160                 buf[--index] = &#39;f&#39;;
161             }
162             return index;
163         } else {
164             if (value) {
165                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
166                 StringUTF16.putChar(buf, --index, &#39;u&#39;);
167                 StringUTF16.putChar(buf, --index, &#39;r&#39;);
168                 StringUTF16.putChar(buf, --index, &#39;t&#39;);
169             } else {
170                 StringUTF16.putChar(buf, --index, &#39;e&#39;);
171                 StringUTF16.putChar(buf, --index, &#39;s&#39;);
172                 StringUTF16.putChar(buf, --index, &#39;l&#39;);
173                 StringUTF16.putChar(buf, --index, &#39;a&#39;);
174                 StringUTF16.putChar(buf, --index, &#39;f&#39;);
175             }
176             return index | UTF16;
177         }
178     }
179 
180     /**
<a name="21" id="anc21"></a><span class="line-modified">181      * Prepends constant and the stringly representation of value into buffer,</span>
182      * given the coder and final index. Index is measured in chars, not in bytes!
183      *
184      * @param indexCoder final char index in the buffer, along with coder packed
185      *                   into higher bits.
186      * @param buf        buffer to append to
<a name="22" id="anc22"></a><span class="line-modified">187      * @param prefix     a constant to prepend before value</span>
<span class="line-added">188      * @param value      boolean value to encode</span>
<span class="line-added">189      * @param suffix     a constant to prepend after value</span>
190      * @return           updated index (coder value retained)
191      */
<a name="23" id="anc23"></a><span class="line-modified">192     static long prepend(long indexCoder, byte[] buf, String prefix, boolean value, String suffix) {</span>
<span class="line-modified">193         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">194         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">195         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">196         return indexCoder;</span>
<span class="line-added">197     }</span>
<span class="line-added">198 </span>
<span class="line-added">199     /**</span>
<span class="line-added">200      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">201      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">202      *</span>
<span class="line-added">203      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">204      *                   into higher bits.</span>
<span class="line-added">205      * @param buf        buffer to append to</span>
<span class="line-added">206      * @param prefix     a constant to prepend before value</span>
<span class="line-added">207      * @param value      boolean value to encode</span>
<span class="line-added">208      * @param suffix     a constant to prepend after value</span>
<span class="line-added">209      * @return           updated index (coder value retained)</span>
<span class="line-added">210      */</span>
<span class="line-added">211     static long prepend(long indexCoder, byte[] buf, String prefix, byte value, String suffix) {</span>
<span class="line-added">212         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">213         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">214         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">215         return indexCoder;</span>
216     }
217 
218     /**
219      * Prepends the stringly representation of char value into buffer,
220      * given the coder and final index. Index is measured in chars, not in bytes!
221      *
222      * @param indexCoder final char index in the buffer, along with coder packed
223      *                   into higher bits.
224      * @param buf        buffer to append to
225      * @param value      char value to encode
226      * @return           updated index (coder value retained)
227      */
<a name="24" id="anc24"></a><span class="line-modified">228     private static long prepend(long indexCoder, byte[] buf, char value) {</span>
229         if (indexCoder &lt; UTF16) {
230             buf[(int)(--indexCoder)] = (byte) (value &amp; 0xFF);
231         } else {
232             StringUTF16.putChar(buf, (int)(--indexCoder), value);
233         }
234         return indexCoder;
235     }
236 
237     /**
<a name="25" id="anc25"></a><span class="line-modified">238      * Prepends constant and the stringly representation of value into buffer,</span>
239      * given the coder and final index. Index is measured in chars, not in bytes!
240      *
241      * @param indexCoder final char index in the buffer, along with coder packed
242      *                   into higher bits.
243      * @param buf        buffer to append to
<a name="26" id="anc26"></a><span class="line-modified">244      * @param prefix     a constant to prepend before value</span>
<span class="line-added">245      * @param value      boolean value to encode</span>
<span class="line-added">246      * @param suffix     a constant to prepend after value</span>
247      * @return           updated index (coder value retained)
248      */
<a name="27" id="anc27"></a><span class="line-modified">249     static long prepend(long indexCoder, byte[] buf, String prefix, char value, String suffix) {</span>
<span class="line-modified">250         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">251         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">252         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">253         return indexCoder;</span>
<span class="line-added">254     }</span>
<span class="line-added">255 </span>
<span class="line-added">256     /**</span>
<span class="line-added">257      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">258      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">259      *</span>
<span class="line-added">260      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">261      *                   into higher bits.</span>
<span class="line-added">262      * @param buf        buffer to append to</span>
<span class="line-added">263      * @param prefix     a constant to prepend before value</span>
<span class="line-added">264      * @param value      boolean value to encode</span>
<span class="line-added">265      * @param suffix     a constant to prepend after value</span>
<span class="line-added">266      * @return           updated index (coder value retained)</span>
<span class="line-added">267      */</span>
<span class="line-added">268     static long prepend(long indexCoder, byte[] buf, String prefix, short value, String suffix) {</span>
<span class="line-added">269         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">270         indexCoder = prepend(indexCoder, buf, (int)value);</span>
<span class="line-added">271         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">272         return indexCoder;</span>
273     }
274 
275     /**
276      * Prepends the stringly representation of integer value into buffer,
277      * given the coder and final index. Index is measured in chars, not in bytes!
278      *
279      * @param indexCoder final char index in the buffer, along with coder packed
280      *                   into higher bits.
281      * @param buf        buffer to append to
282      * @param value      integer value to encode
283      * @return           updated index (coder value retained)
284      */
<a name="28" id="anc28"></a><span class="line-modified">285     private static long prepend(long indexCoder, byte[] buf, int value) {</span>
286         if (indexCoder &lt; UTF16) {
287             return Integer.getChars(value, (int)indexCoder, buf);
288         } else {
289             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
290         }
291     }
292 
<a name="29" id="anc29"></a><span class="line-added">293     /**</span>
<span class="line-added">294      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">295      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">296      *</span>
<span class="line-added">297      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">298      *                   into higher bits.</span>
<span class="line-added">299      * @param buf        buffer to append to</span>
<span class="line-added">300      * @param prefix     a constant to prepend before value</span>
<span class="line-added">301      * @param value      boolean value to encode</span>
<span class="line-added">302      * @param suffix     a constant to prepend after value</span>
<span class="line-added">303      * @return           updated index (coder value retained)</span>
<span class="line-added">304      */</span>
<span class="line-added">305     static long prepend(long indexCoder, byte[] buf, String prefix, int value, String suffix) {</span>
<span class="line-added">306         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">307         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">308         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">309         return indexCoder;</span>
<span class="line-added">310     }</span>
<span class="line-added">311 </span>
312     /**
313      * Prepends the stringly representation of long value into buffer,
314      * given the coder and final index. Index is measured in chars, not in bytes!
315      *
316      * @param indexCoder final char index in the buffer, along with coder packed
317      *                   into higher bits.
318      * @param buf        buffer to append to
319      * @param value      long value to encode
320      * @return           updated index (coder value retained)
321      */
<a name="30" id="anc30"></a><span class="line-modified">322     private static long prepend(long indexCoder, byte[] buf, long value) {</span>
323         if (indexCoder &lt; UTF16) {
324             return Long.getChars(value, (int)indexCoder, buf);
325         } else {
326             return StringUTF16.getChars(value, (int)indexCoder, buf) | UTF16;
327         }
328     }
329 
<a name="31" id="anc31"></a><span class="line-added">330     /**</span>
<span class="line-added">331      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">332      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">333      *</span>
<span class="line-added">334      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">335      *                   into higher bits.</span>
<span class="line-added">336      * @param buf        buffer to append to</span>
<span class="line-added">337      * @param prefix     a constant to prepend before value</span>
<span class="line-added">338      * @param value      boolean value to encode</span>
<span class="line-added">339      * @param suffix     a constant to prepend after value</span>
<span class="line-added">340      * @return           updated index (coder value retained)</span>
<span class="line-added">341      */</span>
<span class="line-added">342     static long prepend(long indexCoder, byte[] buf, String prefix, long value, String suffix) {</span>
<span class="line-added">343         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">344         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">345         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">346         return indexCoder;</span>
<span class="line-added">347     }</span>
<span class="line-added">348 </span>
349     /**
350      * Prepends the stringly representation of String value into buffer,
351      * given the coder and final index. Index is measured in chars, not in bytes!
352      *
353      * @param indexCoder final char index in the buffer, along with coder packed
354      *                   into higher bits.
355      * @param buf        buffer to append to
356      * @param value      String value to encode
357      * @return           updated index (coder value retained)
358      */
<a name="32" id="anc32"></a><span class="line-modified">359     private static long prepend(long indexCoder, byte[] buf, String value) {</span>
360         indexCoder -= value.length();
361         if (indexCoder &lt; UTF16) {
362             value.getBytes(buf, (int)indexCoder, String.LATIN1);
363         } else {
364             value.getBytes(buf, (int)indexCoder, String.UTF16);
365         }
366         return indexCoder;
367     }
368 
<a name="33" id="anc33"></a><span class="line-added">369     /**</span>
<span class="line-added">370      * Prepends constant and the stringly representation of value into buffer,</span>
<span class="line-added">371      * given the coder and final index. Index is measured in chars, not in bytes!</span>
<span class="line-added">372      *</span>
<span class="line-added">373      * @param indexCoder final char index in the buffer, along with coder packed</span>
<span class="line-added">374      *                   into higher bits.</span>
<span class="line-added">375      * @param buf        buffer to append to</span>
<span class="line-added">376      * @param prefix     a constant to prepend before value</span>
<span class="line-added">377      * @param value      boolean value to encode</span>
<span class="line-added">378      * @param suffix     a constant to prepend after value</span>
<span class="line-added">379      * @return           updated index (coder value retained)</span>
<span class="line-added">380      */</span>
<span class="line-added">381     static long prepend(long indexCoder, byte[] buf, String prefix, String value, String suffix) {</span>
<span class="line-added">382         if (suffix != null) indexCoder = prepend(indexCoder, buf, suffix);</span>
<span class="line-added">383         indexCoder = prepend(indexCoder, buf, value);</span>
<span class="line-added">384         if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);</span>
<span class="line-added">385         return indexCoder;</span>
<span class="line-added">386     }</span>
<span class="line-added">387 </span>
388     /**
389      * Instantiates the String with given buffer and coder
390      * @param buf           buffer to use
391      * @param indexCoder    remaining index (should be zero) and coder
392      * @return String       resulting string
393      */
394     static String newString(byte[] buf, long indexCoder) {
395         // Use the private, non-copying constructor (unsafe!)
396         if (indexCoder == LATIN1) {
397             return new String(buf, String.LATIN1);
398         } else if (indexCoder == UTF16) {
399             return new String(buf, String.UTF16);
400         } else {
401             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
402         }
403     }
404 
<a name="34" id="anc34"></a><span class="line-added">405     /**</span>
<span class="line-added">406      * Perform a simple concatenation between two objects. Added for startup</span>
<span class="line-added">407      * performance, but also demonstrates the code that would be emitted by</span>
<span class="line-added">408      * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}</span>
<span class="line-added">409      * for two Object arguments.</span>
<span class="line-added">410      *</span>
<span class="line-added">411      * @param first         first argument</span>
<span class="line-added">412      * @param second        second argument</span>
<span class="line-added">413      * @return String       resulting string</span>
<span class="line-added">414      */</span>
<span class="line-added">415     @ForceInline</span>
<span class="line-added">416     static String simpleConcat(Object first, Object second) {</span>
<span class="line-added">417         String s1 = stringOf(first);</span>
<span class="line-added">418         String s2 = stringOf(second);</span>
<span class="line-added">419         // start &quot;mixing&quot; in length and coder or arguments, order is not</span>
<span class="line-added">420         // important</span>
<span class="line-added">421         long indexCoder = mix(initialCoder(), s2);</span>
<span class="line-added">422         indexCoder = mix(indexCoder, s1);</span>
<span class="line-added">423         byte[] buf = newArray(indexCoder);</span>
<span class="line-added">424         // prepend each argument in reverse order, since we prepending</span>
<span class="line-added">425         // from the end of the byte array</span>
<span class="line-added">426         indexCoder = prepend(indexCoder, buf, s2);</span>
<span class="line-added">427         indexCoder = prepend(indexCoder, buf, s1);</span>
<span class="line-added">428         return newString(buf, indexCoder);</span>
<span class="line-added">429     }</span>
<span class="line-added">430 </span>
<span class="line-added">431     /**</span>
<span class="line-added">432      * We need some additional conversion for Objects in general, because</span>
<span class="line-added">433      * {@code String.valueOf(Object)} may return null. String conversion rules</span>
<span class="line-added">434      * in Java state we need to produce &quot;null&quot; String in this case, so we</span>
<span class="line-added">435      * provide a customized version that deals with this problematic corner case.</span>
<span class="line-added">436      */</span>
<span class="line-added">437     static String stringOf(Object value) {</span>
<span class="line-added">438         String s;</span>
<span class="line-added">439         return (value == null || (s = value.toString()) == null) ? &quot;null&quot; : s;</span>
<span class="line-added">440     }</span>
<span class="line-added">441 </span>
442     private static final long LATIN1 = (long)String.LATIN1 &lt;&lt; 32;
443 
444     private static final long UTF16 = (long)String.UTF16 &lt;&lt; 32;
445 
<a name="35" id="anc35"></a><span class="line-added">446     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-added">447 </span>
<span class="line-added">448     /**</span>
<span class="line-added">449      * Allocates an uninitialized byte array based on the length and coder information</span>
<span class="line-added">450      * in indexCoder</span>
<span class="line-added">451      * @param indexCoder</span>
<span class="line-added">452      * @return the newly allocated byte array</span>
<span class="line-added">453      */</span>
<span class="line-added">454     @ForceInline</span>
<span class="line-added">455     static byte[] newArray(long indexCoder) {</span>
<span class="line-added">456         byte coder = (byte)(indexCoder &gt;&gt; 32);</span>
<span class="line-added">457         int index = (int)indexCoder;</span>
<span class="line-added">458         return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index &lt;&lt; coder);</span>
<span class="line-added">459     }</span>
<span class="line-added">460 </span>
461     /**
462      * Provides the initial coder for the String.
463      * @return initial coder, adjusted into the upper half
464      */
465     static long initialCoder() {
466         return String.COMPACT_STRINGS ? LATIN1 : UTF16;
467     }
468 
469 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
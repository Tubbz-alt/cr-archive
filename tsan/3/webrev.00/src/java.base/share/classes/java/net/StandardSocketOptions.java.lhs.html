<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/StandardSocketOptions.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 /**
 29  * Defines the &lt;em&gt;standard&lt;/em&gt; socket options.
 30  *
 31  * &lt;p&gt; The {@link SocketOption#name name} of each socket option defined by this
 32  * class is its field name.
 33  *
 34  * &lt;p&gt; In this release, the socket options defined here are used by {@link
 35  * java.nio.channels.NetworkChannel network} channels in the {@link
 36  * java.nio.channels channels} package.
 37  *
 38  * @since 1.7
 39  */
 40 
 41 public final class StandardSocketOptions {
 42     private StandardSocketOptions() { }
 43 
 44     // -- SOL_SOCKET --
 45 
 46     /**
 47      * Allow transmission of broadcast datagrams.
 48      *
 49      * &lt;p&gt; The value of this socket option is a {@code Boolean} that represents
 50      * whether the option is enabled or disabled. The option is specific to
 51      * datagram-oriented sockets sending to {@link java.net.Inet4Address IPv4}
 52      * broadcast addresses. When the socket option is enabled then the socket
 53      * can be used to send &lt;em&gt;broadcast datagrams&lt;/em&gt;.
 54      *
 55      * &lt;p&gt; The initial value of this socket option is {@code FALSE}. The socket
 56      * option may be enabled or disabled at any time. Some operating systems may
 57      * require that the Java virtual machine be started with implementation
 58      * specific privileges to enable this option or send broadcast datagrams.
 59      *
 60      * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc919.txt&quot;&gt;RFC&amp;nbsp;929:
 61      * Broadcasting Internet Datagrams&lt;/a&gt;
 62      * @see DatagramSocket#setBroadcast
 63      */
 64     public static final SocketOption&lt;Boolean&gt; SO_BROADCAST =
 65         new StdSocketOption&lt;Boolean&gt;(&quot;SO_BROADCAST&quot;, Boolean.class);
 66 
 67     /**
 68      * Keep connection alive.
 69      *
 70      * &lt;p&gt; The value of this socket option is a {@code Boolean} that represents
 71      * whether the option is enabled or disabled. When the {@code SO_KEEPALIVE}
 72      * option is enabled the operating system may use a &lt;em&gt;keep-alive&lt;/em&gt;
 73      * mechanism to periodically probe the other end of a connection when the
 74      * connection is otherwise idle. The exact semantics of the keep alive
 75      * mechanism is system dependent and therefore unspecified.
 76      *
 77      * &lt;p&gt; The initial value of this socket option is {@code FALSE}. The socket
 78      * option may be enabled or disabled at any time.
 79      *
 80      * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC&amp;nbsp;1122
 81      * Requirements for Internet Hosts -- Communication Layers&lt;/a&gt;
 82      * @see Socket#setKeepAlive
 83      */
 84     public static final SocketOption&lt;Boolean&gt; SO_KEEPALIVE =
 85         new StdSocketOption&lt;Boolean&gt;(&quot;SO_KEEPALIVE&quot;, Boolean.class);
 86 
 87     /**
 88      * The size of the socket send buffer.
 89      *
 90      * &lt;p&gt; The value of this socket option is an {@code Integer} that is the
 91      * size of the socket send buffer in bytes. The socket send buffer is an
 92      * output buffer used by the networking implementation. It may need to be
 93      * increased for high-volume connections. The value of the socket option is
 94      * a &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual
 95      * size may differ. The socket option can be queried to retrieve the actual
 96      * size.
 97      *
 98      * &lt;p&gt; For datagram-oriented sockets, the size of the send buffer may limit
 99      * the size of the datagrams that may be sent by the socket. Whether
100      * datagrams larger than the buffer size are sent or discarded is system
101      * dependent.
102      *
103      * &lt;p&gt; The initial/default size of the socket send buffer and the range of
104      * allowable values is system dependent although a negative size is not
105      * allowed. An attempt to set the socket send buffer to larger than its
106      * maximum size causes it to be set to its maximum size.
107      *
108      * &lt;p&gt; An implementation allows this socket option to be set before the
109      * socket is bound or connected. Whether an implementation allows the
110      * socket send buffer to be changed after the socket is bound is system
111      * dependent.
112      *
113      * @see Socket#setSendBufferSize
114      */
115     public static final SocketOption&lt;Integer&gt; SO_SNDBUF =
116         new StdSocketOption&lt;Integer&gt;(&quot;SO_SNDBUF&quot;, Integer.class);
117 
118 
119     /**
120      * The size of the socket receive buffer.
121      *
122      * &lt;p&gt; The value of this socket option is an {@code Integer} that is the
123      * size of the socket receive buffer in bytes. The socket receive buffer is
124      * an input buffer used by the networking implementation. It may need to be
125      * increased for high-volume connections or decreased to limit the possible
126      * backlog of incoming data. The value of the socket option is a
127      * &lt;em&gt;hint&lt;/em&gt; to the implementation to size the buffer and the actual
128      * size may differ.
129      *
130      * &lt;p&gt; For datagram-oriented sockets, the size of the receive buffer may
131      * limit the size of the datagrams that can be received. Whether datagrams
132      * larger than the buffer size can be received is system dependent.
133      * Increasing the socket receive buffer may be important for cases where
134      * datagrams arrive in bursts faster than they can be processed.
135      *
136      * &lt;p&gt; In the case of stream-oriented sockets and the TCP/IP protocol, the
137      * size of the socket receive buffer may be used when advertising the size
138      * of the TCP receive window to the remote peer.
139      *
140      * &lt;p&gt; The initial/default size of the socket receive buffer and the range
141      * of allowable values is system dependent although a negative size is not
142      * allowed. An attempt to set the socket receive buffer to larger than its
143      * maximum size causes it to be set to its maximum size.
144      *
145      * &lt;p&gt; An implementation allows this socket option to be set before the
146      * socket is bound or connected. Whether an implementation allows the
147      * socket receive buffer to be changed after the socket is bound is system
148      * dependent.
149      *
150      * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc1323.txt&quot;&gt;RFC&amp;nbsp;1323: TCP
151      * Extensions for High Performance&lt;/a&gt;
152      * @see Socket#setReceiveBufferSize
153      * @see ServerSocket#setReceiveBufferSize
154      */
155     public static final SocketOption&lt;Integer&gt; SO_RCVBUF =
156         new StdSocketOption&lt;Integer&gt;(&quot;SO_RCVBUF&quot;, Integer.class);
157 
158     /**
159      * Re-use address.
160      *
161      * &lt;p&gt; The value of this socket option is a {@code Boolean} that represents
162      * whether the option is enabled or disabled. The exact semantics of this
163      * socket option are socket type and system dependent.
164      *
165      * &lt;p&gt; In the case of stream-oriented sockets, this socket option will
166      * usually determine whether the socket can be bound to a socket address
167      * when a previous connection involving that socket address is in the
168      * &lt;em&gt;TIME_WAIT&lt;/em&gt; state. On implementations where the semantics differ,
169      * and the socket option is not required to be enabled in order to bind the
170      * socket when a previous connection is in this state, then the
171      * implementation may choose to ignore this option.
172      *
173      * &lt;p&gt; For datagram-oriented sockets the socket option is used to allow
174      * multiple programs bind to the same address. This option should be enabled
175      * when the socket is to be used for Internet Protocol (IP) multicasting.
176      *
177      * &lt;p&gt; An implementation allows this socket option to be set before the
178      * socket is bound or connected. Changing the value of this socket option
179      * after the socket is bound has no effect. The default value of this
180      * socket option is system dependent.
181      *
182      * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc793.txt&quot;&gt;RFC&amp;nbsp;793: Transmission
183      * Control Protocol&lt;/a&gt;
184      * @see ServerSocket#setReuseAddress
185      */
186     public static final SocketOption&lt;Boolean&gt; SO_REUSEADDR =
187         new StdSocketOption&lt;Boolean&gt;(&quot;SO_REUSEADDR&quot;, Boolean.class);
188 
189     /**
190      * Re-use port.
191      *
192      * &lt;p&gt; The value of this socket option is a {@code Boolean} that represents
193      * whether the option is enabled or disabled. The exact semantics of this
194      * socket option are socket type and system dependent.
195      *
196      * &lt;p&gt; In the case of stream-oriented sockets, this socket option usually allows
197      * multiple listening sockets to be bound to both same address
198      * and same port.
199      *
200      * &lt;p&gt; For datagram-oriented sockets the socket option usually allows
201      * multiple UDP sockets to be bound to the same address and port.
202      *
203      * &lt;p&gt; An implementation allows this socket option to be set before the
204      * socket is bound or connected. Changing the value of this socket option
205      * after the socket is bound has no effect.
206      *
207      * @since 9
208      */
209     public static final SocketOption&lt;Boolean&gt; SO_REUSEPORT =
210         new StdSocketOption&lt;Boolean&gt;(&quot;SO_REUSEPORT&quot;, Boolean.class);
211 
212     /**
213      * Linger on close if data is present.
214      *
215      * &lt;p&gt; The value of this socket option is an {@code Integer} that controls
216      * the action taken when unsent data is queued on the socket and a method
217      * to close the socket is invoked. If the value of the socket option is zero
218      * or greater, then it represents a timeout value, in seconds, known as the
219      * &lt;em&gt;linger interval&lt;/em&gt;. The linger interval is the timeout for the
220      * {@code close} method to block while the operating system attempts to
221      * transmit the unsent data or it decides that it is unable to transmit the
222      * data. If the value of the socket option is less than zero then the option
223      * is disabled. In that case the {@code close} method does not wait until
224      * unsent data is transmitted; if possible the operating system will transmit
225      * any unsent data before the connection is closed.
226      *
227      * &lt;p&gt; This socket option is intended for use with sockets that are configured
228      * in {@link java.nio.channels.SelectableChannel#isBlocking() blocking} mode
229      * only. The behavior of the {@code close} method when this option is
230      * enabled on a non-blocking socket is not defined.
231      *
232      * &lt;p&gt; The initial value of this socket option is a negative value, meaning
233      * that the option is disabled. The option may be enabled, or the linger
234      * interval changed, at any time. The maximum value of the linger interval
235      * is system dependent. Setting the linger interval to a value that is
236      * greater than its maximum value causes the linger interval to be set to
237      * its maximum value.
238      *
239      * @see Socket#setSoLinger
240      */
241     public static final SocketOption&lt;Integer&gt; SO_LINGER =
242         new StdSocketOption&lt;Integer&gt;(&quot;SO_LINGER&quot;, Integer.class);
243 
244 
245     // -- IPPROTO_IP --
246 
247     /**
248      * The Type of Service (ToS) octet in the Internet Protocol (IP) header.
249      *
250      * &lt;p&gt; The value of this socket option is an {@code Integer} representing
251      * the value of the ToS octet in IP packets sent by sockets to an {@link
252      * StandardProtocolFamily#INET IPv4} socket. The interpretation of the ToS
253      * octet is network specific and is not defined by this class. Further
254      * information on the ToS octet can be found in &lt;a
255      * href=&quot;http://www.ietf.org/rfc/rfc1349.txt&quot;&gt;RFC&amp;nbsp;1349&lt;/a&gt; and &lt;a
256      * href=&quot;http://www.ietf.org/rfc/rfc2474.txt&quot;&gt;RFC&amp;nbsp;2474&lt;/a&gt;. The value
257      * of the socket option is a &lt;em&gt;hint&lt;/em&gt;. An implementation may ignore the
258      * value, or ignore specific values.
259      *
260      * &lt;p&gt; The initial/default value of the TOS field in the ToS octet is
261      * implementation specific but will typically be {@code 0}. For
262      * datagram-oriented sockets the option may be configured at any time after
263      * the socket has been bound. The new value of the octet is used when sending
264      * subsequent datagrams. It is system dependent whether this option can be
265      * queried or changed prior to binding the socket.
266      *
267      * &lt;p&gt; The behavior of this socket option on a stream-oriented socket, or an
268      * {@link StandardProtocolFamily#INET6 IPv6} socket, is not defined in this
269      * release.
270      *
271      * @see DatagramSocket#setTrafficClass
272      */
273     public static final SocketOption&lt;Integer&gt; IP_TOS =
274         new StdSocketOption&lt;Integer&gt;(&quot;IP_TOS&quot;, Integer.class);
275 
276     /**
277      * The network interface for Internet Protocol (IP) multicast datagrams.
278      *
279      * &lt;p&gt; The value of this socket option is a {@link NetworkInterface} that
280      * represents the outgoing interface for multicast datagrams sent by the
281      * datagram-oriented socket. For {@link StandardProtocolFamily#INET6 IPv6}
282      * sockets then it is system dependent whether setting this option also
283      * sets the outgoing interface for multicast datagrams sent to IPv4
284      * addresses.
285      *
286      * &lt;p&gt; The initial/default value of this socket option may be {@code null}
287      * to indicate that outgoing interface will be selected by the operating
288      * system, typically based on the network routing tables. An implementation
289      * allows this socket option to be set after the socket is bound. Whether
290      * the socket option can be queried or changed prior to binding the socket
291      * is system dependent.
292      *
293      * @see java.nio.channels.MulticastChannel
<a name="2" id="anc2"></a><span class="line-removed">294      * @see MulticastSocket#setInterface</span>
295      */
296     public static final SocketOption&lt;NetworkInterface&gt; IP_MULTICAST_IF =
297         new StdSocketOption&lt;NetworkInterface&gt;(&quot;IP_MULTICAST_IF&quot;, NetworkInterface.class);
298 
299     /**
300      * The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast datagrams.
301      *
302      * &lt;p&gt; The value of this socket option is an {@code Integer} in the range
303      * {@code 0 &lt;= value &lt;= 255}. It is used to control the scope of multicast
304      * datagrams sent by the datagram-oriented socket.
305      * In the case of an {@link StandardProtocolFamily#INET IPv4} socket
306      * the option is the time-to-live (TTL) on multicast datagrams sent by the
307      * socket. Datagrams with a TTL of zero are not transmitted on the network
308      * but may be delivered locally. In the case of an {@link
309      * StandardProtocolFamily#INET6 IPv6} socket the option is the
310      * &lt;em&gt;hop limit&lt;/em&gt; which is number of &lt;em&gt;hops&lt;/em&gt; that the datagram can
311      * pass through before expiring on the network. For IPv6 sockets it is
312      * system dependent whether the option also sets the &lt;em&gt;time-to-live&lt;/em&gt;
313      * on multicast datagrams sent to IPv4 addresses.
314      *
315      * &lt;p&gt; The initial/default value of the time-to-live setting is typically
316      * {@code 1}. An implementation allows this socket option to be set after
317      * the socket is bound. Whether the socket option can be queried or changed
318      * prior to binding the socket is system dependent.
319      *
320      * @see java.nio.channels.MulticastChannel
321      * @see MulticastSocket#setTimeToLive
322      */
323     public static final SocketOption&lt;Integer&gt; IP_MULTICAST_TTL =
324         new StdSocketOption&lt;Integer&gt;(&quot;IP_MULTICAST_TTL&quot;, Integer.class);
325 
326     /**
327      * Loopback for Internet Protocol (IP) multicast datagrams.
328      *
329      * &lt;p&gt; The value of this socket option is a {@code Boolean} that controls
330      * the &lt;em&gt;loopback&lt;/em&gt; of multicast datagrams. The value of the socket
331      * option represents if the option is enabled or disabled.
332      *
333      * &lt;p&gt; The exact semantics of this socket options are system dependent.
334      * In particular, it is system dependent whether the loopback applies to
335      * multicast datagrams sent from the socket or received by the socket.
336      * For {@link StandardProtocolFamily#INET6 IPv6} sockets then it is
337      * system dependent whether the option also applies to multicast datagrams
338      * sent to IPv4 addresses.
339      *
340      * &lt;p&gt; The initial/default value of this socket option is {@code TRUE}. An
341      * implementation allows this socket option to be set after the socket is
342      * bound. Whether the socket option can be queried or changed prior to
343      * binding the socket is system dependent.
344      *
345      * @see java.nio.channels.MulticastChannel
<a name="3" id="anc3"></a><span class="line-removed">346      *  @see MulticastSocket#setLoopbackMode</span>
347      */
348     public static final SocketOption&lt;Boolean&gt; IP_MULTICAST_LOOP =
349         new StdSocketOption&lt;Boolean&gt;(&quot;IP_MULTICAST_LOOP&quot;, Boolean.class);
350 
351 
352     // -- IPPROTO_TCP --
353 
354     /**
355      * Disable the Nagle algorithm.
356      *
357      * &lt;p&gt; The value of this socket option is a {@code Boolean} that represents
358      * whether the option is enabled or disabled. The socket option is specific to
359      * stream-oriented sockets using the TCP/IP protocol. TCP/IP uses an algorithm
360      * known as &lt;em&gt;The Nagle Algorithm&lt;/em&gt; to coalesce short segments and
361      * improve network efficiency.
362      *
363      * &lt;p&gt; The default value of this socket option is {@code FALSE}. The
364      * socket option should only be enabled in cases where it is known that the
365      * coalescing impacts performance. The socket option may be enabled at any
366      * time. In other words, the Nagle Algorithm can be disabled. Once the option
367      * is enabled, it is system dependent whether it can be subsequently
368      * disabled. If it cannot, then invoking the {@code setOption} method to
369      * disable the option has no effect.
370      *
371      * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC&amp;nbsp;1122:
372      * Requirements for Internet Hosts -- Communication Layers&lt;/a&gt;
373      * @see Socket#setTcpNoDelay
374      */
375     public static final SocketOption&lt;Boolean&gt; TCP_NODELAY =
376         new StdSocketOption&lt;Boolean&gt;(&quot;TCP_NODELAY&quot;, Boolean.class);
377 
378 
379     private static class StdSocketOption&lt;T&gt; implements SocketOption&lt;T&gt; {
380         private final String name;
381         private final Class&lt;T&gt; type;
382         StdSocketOption(String name, Class&lt;T&gt; type) {
383             this.name = name;
384             this.type = type;
385         }
386         @Override public String name() { return name; }
387         @Override public Class&lt;T&gt; type() { return type; }
388         @Override public String toString() { return name; }
389     }
390 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/CharArrayWriter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.util.Arrays;
 29 
 30 /**
 31  * This class implements a character buffer that can be used as an Writer.
 32  * The buffer automatically grows when data is written to the stream.  The data
 33  * can be retrieved using toCharArray() and toString().
 34  * &lt;P&gt;
 35  * Note: Invoking close() on this class has no effect, and methods
 36  * of this class can be called after the stream has closed
 37  * without generating an IOException.
 38  *
 39  * @author      Herb Jellinek
 40  * @since       1.1
 41  */
<a name="2" id="anc2"></a><span class="line-modified"> 42 public class CharArrayWriter extends Writer {</span>

 43     /**
 44      * The buffer where data is stored.
 45      */
 46     protected char buf[];
 47 
 48     /**
 49      * The number of chars in the buffer.
 50      */
 51     protected int count;
 52 
 53     /**
 54      * Creates a new CharArrayWriter.
 55      */
 56     public CharArrayWriter() {
 57         this(32);
 58     }
 59 
 60     /**
 61      * Creates a new CharArrayWriter with the specified initial size.
 62      *
<a name="3" id="anc3"></a><span class="line-modified"> 63      * @param  initialSize  an int specifying the initial buffer size.</span>
<span class="line-modified"> 64      * @throws IllegalArgumentException if initialSize is negative</span>
 65      */
 66     public CharArrayWriter(int initialSize) {
 67         if (initialSize &lt; 0) {
 68             throw new IllegalArgumentException(&quot;Negative initial size: &quot;
 69                                                + initialSize);
 70         }
 71         buf = new char[initialSize];
 72     }
 73 
 74     /**
 75      * Writes a character to the buffer.
 76      */
 77     public void write(int c) {
 78         synchronized (lock) {
 79             int newcount = count + 1;
 80             if (newcount &gt; buf.length) {
 81                 buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount));
 82             }
 83             buf[count] = (char)c;
 84             count = newcount;
 85         }
 86     }
 87 
 88     /**
 89      * Writes characters to the buffer.
 90      * @param c the data to be written
 91      * @param off       the start offset in the data
 92      * @param len       the number of chars that are written
 93      *
 94      * @throws  IndexOutOfBoundsException
 95      *          If {@code off} is negative, or {@code len} is negative,
 96      *          or {@code off + len} is negative or greater than the length
 97      *          of the given array
 98      */
 99     public void write(char c[], int off, int len) {
100         if ((off &lt; 0) || (off &gt; c.length) || (len &lt; 0) ||
101             ((off + len) &gt; c.length) || ((off + len) &lt; 0)) {
102             throw new IndexOutOfBoundsException();
103         } else if (len == 0) {
104             return;
105         }
106         synchronized (lock) {
107             int newcount = count + len;
108             if (newcount &gt; buf.length) {
109                 buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount));
110             }
111             System.arraycopy(c, off, buf, count, len);
112             count = newcount;
113         }
114     }
115 
116     /**
117      * Write a portion of a string to the buffer.
118      * @param  str  String to be written from
119      * @param  off  Offset from which to start reading characters
120      * @param  len  Number of characters to be written
121      *
122      * @throws  IndexOutOfBoundsException
123      *          If {@code off} is negative, or {@code len} is negative,
124      *          or {@code off + len} is negative or greater than the length
125      *          of the given string
126      */
127     public void write(String str, int off, int len) {
128         synchronized (lock) {
129             int newcount = count + len;
130             if (newcount &gt; buf.length) {
131                 buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount));
132             }
133             str.getChars(off, off + len, buf, count);
134             count = newcount;
135         }
136     }
137 
138     /**
139      * Writes the contents of the buffer to another character stream.
140      *
141      * @param out       the output stream to write to
142      * @throws IOException If an I/O error occurs.
143      */
144     public void writeTo(Writer out) throws IOException {
145         synchronized (lock) {
146             out.write(buf, 0, count);
147         }
148     }
149 
150     /**
151      * Appends the specified character sequence to this writer.
152      *
153      * &lt;p&gt; An invocation of this method of the form {@code out.append(csq)}
154      * behaves in exactly the same way as the invocation
155      *
156      * &lt;pre&gt;
157      *     out.write(csq.toString()) &lt;/pre&gt;
158      *
159      * &lt;p&gt; Depending on the specification of {@code toString} for the
160      * character sequence {@code csq}, the entire sequence may not be
161      * appended. For instance, invoking the {@code toString} method of a
162      * character buffer will return a subsequence whose content depends upon
163      * the buffer&#39;s position and limit.
164      *
165      * @param  csq
166      *         The character sequence to append.  If {@code csq} is
167      *         {@code null}, then the four characters {@code &quot;null&quot;} are
168      *         appended to this writer.
169      *
170      * @return  This writer
171      *
172      * @since  1.5
173      */
174     public CharArrayWriter append(CharSequence csq) {
175         String s = String.valueOf(csq);
176         write(s, 0, s.length());
177         return this;
178     }
179 
180     /**
181      * Appends a subsequence of the specified character sequence to this writer.
182      *
183      * &lt;p&gt; An invocation of this method of the form
184      * {@code out.append(csq, start, end)} when
185      * {@code csq} is not {@code null}, behaves in
186      * exactly the same way as the invocation
187      *
188      * &lt;pre&gt;
189      *     out.write(csq.subSequence(start, end).toString()) &lt;/pre&gt;
190      *
191      * @param  csq
192      *         The character sequence from which a subsequence will be
193      *         appended.  If {@code csq} is {@code null}, then characters
194      *         will be appended as if {@code csq} contained the four
195      *         characters {@code &quot;null&quot;}.
196      *
197      * @param  start
198      *         The index of the first character in the subsequence
199      *
200      * @param  end
201      *         The index of the character following the last character in the
202      *         subsequence
203      *
204      * @return  This writer
205      *
206      * @throws  IndexOutOfBoundsException
207      *          If {@code start} or {@code end} are negative, {@code start}
208      *          is greater than {@code end}, or {@code end} is greater than
209      *          {@code csq.length()}
210      *
211      * @since  1.5
212      */
213     public CharArrayWriter append(CharSequence csq, int start, int end) {
214         if (csq == null) csq = &quot;null&quot;;
215         return append(csq.subSequence(start, end));
216     }
217 
218     /**
219      * Appends the specified character to this writer.
220      *
221      * &lt;p&gt; An invocation of this method of the form {@code out.append(c)}
222      * behaves in exactly the same way as the invocation
223      *
224      * &lt;pre&gt;
225      *     out.write(c) &lt;/pre&gt;
226      *
227      * @param  c
228      *         The 16-bit character to append
229      *
230      * @return  This writer
231      *
232      * @since 1.5
233      */
234     public CharArrayWriter append(char c) {
235         write(c);
236         return this;
237     }
238 
239     /**
240      * Resets the buffer so that you can use it again without
241      * throwing away the already allocated buffer.
242      */
243     public void reset() {
244         count = 0;
245     }
246 
247     /**
248      * Returns a copy of the input data.
249      *
250      * @return an array of chars copied from the input data.
251      */
252     public char[] toCharArray() {
253         synchronized (lock) {
254             return Arrays.copyOf(buf, count);
255         }
256     }
257 
258     /**
259      * Returns the current size of the buffer.
260      *
261      * @return an int representing the current size of the buffer.
262      */
263     public int size() {
264         return count;
265     }
266 
267     /**
268      * Converts input data to a string.
269      * @return the string.
270      */
271     public String toString() {
272         synchronized (lock) {
273             return new String(buf, 0, count);
274         }
275     }
276 
277     /**
278      * Flush the stream.
279      */
280     public void flush() { }
281 
282     /**
283      * Close the stream.  This method does not release the buffer, since its
284      * contents might still be required. Note: Invoking this method in this class
285      * will have no effect.
286      */
287     public void close() { }
288 
289 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/reflect/Executable.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
 28 import java.lang.annotation.*;
 29 import java.util.Arrays;
 30 import java.util.Map;
 31 import java.util.Objects;
 32 import java.util.StringJoiner;
 33 import java.util.stream.Stream;
 34 import java.util.stream.Collectors;
 35 
 36 import jdk.internal.access.SharedSecrets;
 37 import sun.reflect.annotation.AnnotationParser;
 38 import sun.reflect.annotation.AnnotationSupport;
 39 import sun.reflect.annotation.TypeAnnotationParser;
 40 import sun.reflect.annotation.TypeAnnotation;
 41 import sun.reflect.generics.repository.ConstructorRepository;
 42 
 43 /**
 44  * A shared superclass for the common functionality of {@link Method}
 45  * and {@link Constructor}.
 46  *
 47  * @since 1.8
 48  */
 49 public abstract class Executable extends AccessibleObject
 50     implements Member, GenericDeclaration {
 51     /*
 52      * Only grant package-visibility to the constructor.
 53      */
 54     Executable() {}
 55 
 56     /**
 57      * Accessor method to allow code sharing
 58      */
 59     abstract byte[] getAnnotationBytes();
 60 
 61     /**
 62      * Does the Executable have generic information.
 63      */
 64     abstract boolean hasGenericInformation();
 65 
 66     abstract ConstructorRepository getGenericInfo();
 67 
 68     boolean equalParamTypes(Class&lt;?&gt;[] params1, Class&lt;?&gt;[] params2) {
 69         /* Avoid unnecessary cloning */
 70         if (params1.length == params2.length) {
 71             for (int i = 0; i &lt; params1.length; i++) {
 72                 if (params1[i] != params2[i])
 73                     return false;
 74             }
 75             return true;
 76         }
 77         return false;
 78     }
 79 
 80     Annotation[][] parseParameterAnnotations(byte[] parameterAnnotations) {
 81         return AnnotationParser.parseParameterAnnotations(
 82                parameterAnnotations,
 83                SharedSecrets.getJavaLangAccess().
 84                getConstantPool(getDeclaringClass()),
 85                getDeclaringClass());
 86     }
 87 
 88     void printModifiersIfNonzero(StringBuilder sb, int mask, boolean isDefault) {
 89         int mod = getModifiers() &amp; mask;
 90 
 91         if (mod != 0 &amp;&amp; !isDefault) {
 92             sb.append(Modifier.toString(mod)).append(&#39; &#39;);
 93         } else {
 94             int access_mod = mod &amp; Modifier.ACCESS_MODIFIERS;
 95             if (access_mod != 0)
 96                 sb.append(Modifier.toString(access_mod)).append(&#39; &#39;);
 97             if (isDefault)
 98                 sb.append(&quot;default &quot;);
 99             mod = (mod &amp; ~Modifier.ACCESS_MODIFIERS);
100             if (mod != 0)
101                 sb.append(Modifier.toString(mod)).append(&#39; &#39;);
102         }
103     }
104 
105     String sharedToString(int modifierMask,
106                           boolean isDefault,
107                           Class&lt;?&gt;[] parameterTypes,
108                           Class&lt;?&gt;[] exceptionTypes) {
109         try {
110             StringBuilder sb = new StringBuilder();
111 
112             printModifiersIfNonzero(sb, modifierMask, isDefault);
113             specificToStringHeader(sb);
114             sb.append(Arrays.stream(parameterTypes)
115                       .map(Type::getTypeName)
116                       .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
117             if (exceptionTypes.length &gt; 0) {
118                 sb.append(Arrays.stream(exceptionTypes)
119                           .map(Type::getTypeName)
120                           .collect(Collectors.joining(&quot;,&quot;, &quot; throws &quot;, &quot;&quot;)));
121             }
122             return sb.toString();
123         } catch (Exception e) {
124             return &quot;&lt;&quot; + e + &quot;&gt;&quot;;
125         }
126     }
127 
128     /**
129      * Generate toString header information specific to a method or
130      * constructor.
131      */
132     abstract void specificToStringHeader(StringBuilder sb);
133 
134     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
135         Type[] bounds = typeVar.getBounds();
136         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
137             return typeVar.getName();
138         } else {
139             return typeVar.getName() + &quot; extends &quot; +
140                 Arrays.stream(bounds)
141                 .map(Type::getTypeName)
142                 .collect(Collectors.joining(&quot; &amp; &quot;));
143         }
144     }
145 
146     String sharedToGenericString(int modifierMask, boolean isDefault) {
147         try {
148             StringBuilder sb = new StringBuilder();
149 
150             printModifiersIfNonzero(sb, modifierMask, isDefault);
151 
152             TypeVariable&lt;?&gt;[] typeparms = getTypeParameters();
153             if (typeparms.length &gt; 0) {
154                 sb.append(Arrays.stream(typeparms)
155                           .map(Executable::typeVarBounds)
156                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt; &quot;)));
157             }
158 
159             specificToGenericStringHeader(sb);
160 
161             sb.append(&#39;(&#39;);
162             StringJoiner sj = new StringJoiner(&quot;,&quot;);
163             Type[] params = getGenericParameterTypes();
164             for (int j = 0; j &lt; params.length; j++) {
165                 String param = params[j].getTypeName();
166                 if (isVarArgs() &amp;&amp; (j == params.length - 1)) // replace T[] with T...
167                     param = param.replaceFirst(&quot;\\[\\]$&quot;, &quot;...&quot;);
168                 sj.add(param);
169             }
170             sb.append(sj.toString());
171             sb.append(&#39;)&#39;);
172 
173             Type[] exceptionTypes = getGenericExceptionTypes();
174             if (exceptionTypes.length &gt; 0) {
175                 sb.append(Arrays.stream(exceptionTypes)
176                           .map(Type::getTypeName)
177                           .collect(Collectors.joining(&quot;,&quot;, &quot; throws &quot;, &quot;&quot;)));
178             }
179             return sb.toString();
180         } catch (Exception e) {
181             return &quot;&lt;&quot; + e + &quot;&gt;&quot;;
182         }
183     }
184 
185     /**
186      * Generate toGenericString header information specific to a
187      * method or constructor.
188      */
189     abstract void specificToGenericStringHeader(StringBuilder sb);
190 
191     /**
192      * Returns the {@code Class} object representing the class or interface
193      * that declares the executable represented by this object.
194      */
195     public abstract Class&lt;?&gt; getDeclaringClass();
196 
197     /**
198      * Returns the name of the executable represented by this object.
199      */
200     public abstract String getName();
201 
202     /**
203      * Returns the Java language {@linkplain Modifier modifiers} for
204      * the executable represented by this object.
205      */
206     public abstract int getModifiers();
207 
208     /**
209      * Returns an array of {@code TypeVariable} objects that represent the
210      * type variables declared by the generic declaration represented by this
211      * {@code GenericDeclaration} object, in declaration order.  Returns an
212      * array of length 0 if the underlying generic declaration declares no type
213      * variables.
214      *
215      * @return an array of {@code TypeVariable} objects that represent
216      *     the type variables declared by this generic declaration
217      * @throws GenericSignatureFormatError if the generic
218      *     signature of this generic declaration does not conform to
219      *     the format specified in
220      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
221      */
222     public abstract TypeVariable&lt;?&gt;[] getTypeParameters();
223 
224     // returns shared array of parameter types - must never give it out
225     // to the untrusted code...
226     abstract Class&lt;?&gt;[] getSharedParameterTypes();
227 
228     // returns shared array of exception types - must never give it out
229     // to the untrusted code...
230     abstract Class&lt;?&gt;[] getSharedExceptionTypes();
231 
232     /**
233      * Returns an array of {@code Class} objects that represent the formal
234      * parameter types, in declaration order, of the executable
235      * represented by this object.  Returns an array of length
236      * 0 if the underlying executable takes no parameters.
237      *
238      * @return the parameter types for the executable this object
239      * represents
240      */
241     public abstract Class&lt;?&gt;[] getParameterTypes();
242 
243     /**
244      * Returns the number of formal parameters (whether explicitly
245      * declared or implicitly declared or neither) for the executable
246      * represented by this object.
247      *
248      * @return The number of formal parameters for the executable this
249      * object represents
250      */
251     public int getParameterCount() {
252         throw new AbstractMethodError();
253     }
254 
255     /**
256      * Returns an array of {@code Type} objects that represent the formal
257      * parameter types, in declaration order, of the executable represented by
258      * this object. Returns an array of length 0 if the
259      * underlying executable takes no parameters.
260      *
261      * &lt;p&gt;If a formal parameter type is a parameterized type,
262      * the {@code Type} object returned for it must accurately reflect
263      * the actual type parameters used in the source code.
264      *
265      * &lt;p&gt;If a formal parameter type is a type variable or a parameterized
266      * type, it is created. Otherwise, it is resolved.
267      *
268      * @return an array of {@code Type}s that represent the formal
269      *     parameter types of the underlying executable, in declaration order
270      * @throws GenericSignatureFormatError
271      *     if the generic method signature does not conform to the format
272      *     specified in
273      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
274      * @throws TypeNotPresentException if any of the parameter
275      *     types of the underlying executable refers to a non-existent type
276      *     declaration
277      * @throws MalformedParameterizedTypeException if any of
278      *     the underlying executable&#39;s parameter types refer to a parameterized
279      *     type that cannot be instantiated for any reason
280      */
281     public Type[] getGenericParameterTypes() {
282         if (hasGenericInformation())
283             return getGenericInfo().getParameterTypes();
284         else
285             return getParameterTypes();
286     }
287 
288     /**
289      * Behaves like {@code getGenericParameterTypes}, but returns type
290      * information for all parameters, including synthetic parameters.
291      */
292     Type[] getAllGenericParameterTypes() {
293         final boolean genericInfo = hasGenericInformation();
294 
295         // Easy case: we don&#39;t have generic parameter information.  In
296         // this case, we just return the result of
297         // getParameterTypes().
298         if (!genericInfo) {
299             return getParameterTypes();
300         } else {
301             final boolean realParamData = hasRealParameterData();
302             final Type[] genericParamTypes = getGenericParameterTypes();
303             final Type[] nonGenericParamTypes = getParameterTypes();
304             final Type[] out = new Type[nonGenericParamTypes.length];
305             final Parameter[] params = getParameters();
306             int fromidx = 0;
307             // If we have real parameter data, then we use the
308             // synthetic and mandate flags to our advantage.
309             if (realParamData) {
310                 for (int i = 0; i &lt; out.length; i++) {
311                     final Parameter param = params[i];
312                     if (param.isSynthetic() || param.isImplicit()) {
313                         // If we hit a synthetic or mandated parameter,
314                         // use the non generic parameter info.
315                         out[i] = nonGenericParamTypes[i];
316                     } else {
317                         // Otherwise, use the generic parameter info.
318                         out[i] = genericParamTypes[fromidx];
319                         fromidx++;
320                     }
321                 }
322             } else {
323                 // Otherwise, use the non-generic parameter data.
324                 // Without method parameter reflection data, we have
325                 // no way to figure out which parameters are
326                 // synthetic/mandated, thus, no way to match up the
327                 // indexes.
328                 return genericParamTypes.length == nonGenericParamTypes.length ?
329                     genericParamTypes : nonGenericParamTypes;
330             }
331             return out;
332         }
333     }
334 
335     /**
336      * Returns an array of {@code Parameter} objects that represent
337      * all the parameters to the underlying executable represented by
338      * this object.  Returns an array of length 0 if the executable
339      * has no parameters.
340      *
341      * &lt;p&gt;The parameters of the underlying executable do not necessarily
342      * have unique names, or names that are legal identifiers in the
343      * Java programming language (JLS 3.8).
344      *
345      * @throws MalformedParametersException if the class file contains
346      * a MethodParameters attribute that is improperly formatted.
347      * @return an array of {@code Parameter} objects representing all
348      * the parameters to the executable this object represents.
349      */
350     public Parameter[] getParameters() {
351         // TODO: This may eventually need to be guarded by security
352         // mechanisms similar to those in Field, Method, etc.
353         //
354         // Need to copy the cached array to prevent users from messing
355         // with it.  Since parameters are immutable, we can
356         // shallow-copy.
357         return privateGetParameters().clone();
358     }
359 
360     private Parameter[] synthesizeAllParams() {
361         final int realparams = getParameterCount();
362         final Parameter[] out = new Parameter[realparams];
363         for (int i = 0; i &lt; realparams; i++)
364             // TODO: is there a way to synthetically derive the
365             // modifiers?  Probably not in the general case, since
366             // we&#39;d have no way of knowing about them, but there
367             // may be specific cases.
368             out[i] = new Parameter(&quot;arg&quot; + i, 0, this, i);
369         return out;
370     }
371 
372     private void verifyParameters(final Parameter[] parameters) {
373         final int mask = Modifier.FINAL | Modifier.SYNTHETIC | Modifier.MANDATED;
374 
375         if (getParameterTypes().length != parameters.length)
376             throw new MalformedParametersException(&quot;Wrong number of parameters in MethodParameters attribute&quot;);
377 
378         for (Parameter parameter : parameters) {
379             final String name = parameter.getRealName();
380             final int mods = parameter.getModifiers();
381 
382             if (name != null) {
383                 if (name.isEmpty() || name.indexOf(&#39;.&#39;) != -1 ||
384                     name.indexOf(&#39;;&#39;) != -1 || name.indexOf(&#39;[&#39;) != -1 ||
385                     name.indexOf(&#39;/&#39;) != -1) {
386                     throw new MalformedParametersException(&quot;Invalid parameter name \&quot;&quot; + name + &quot;\&quot;&quot;);
387                 }
388             }
389 
390             if (mods != (mods &amp; mask)) {
391                 throw new MalformedParametersException(&quot;Invalid parameter modifiers&quot;);
392             }
393         }
394     }
395 
396     private Parameter[] privateGetParameters() {
397         // Use tmp to avoid multiple writes to a volatile.
398         Parameter[] tmp = parameters;
399 
400         if (tmp == null) {
401 
402             // Otherwise, go to the JVM to get them
403             try {
404                 tmp = getParameters0();
405             } catch(IllegalArgumentException e) {
406                 // Rethrow ClassFormatErrors
407                 throw new MalformedParametersException(&quot;Invalid constant pool index&quot;);
408             }
409 
410             // If we get back nothing, then synthesize parameters
411             if (tmp == null) {
412                 hasRealParameterData = false;
413                 tmp = synthesizeAllParams();
414             } else {
415                 hasRealParameterData = true;
416                 verifyParameters(tmp);
417             }
418 
419             parameters = tmp;
420         }
421 
422         return tmp;
423     }
424 
425     boolean hasRealParameterData() {
426         // If this somehow gets called before parameters gets
427         // initialized, force it into existence.
428         if (parameters == null) {
429             privateGetParameters();
430         }
431         return hasRealParameterData;
432     }
433 
434     private transient volatile boolean hasRealParameterData;
435     private transient volatile Parameter[] parameters;
436 
437     private native Parameter[] getParameters0();
438     native byte[] getTypeAnnotationBytes0();
439 
440     // Needed by reflectaccess
441     byte[] getTypeAnnotationBytes() {
442         return getTypeAnnotationBytes0();
443     }
444 
445     /**
446      * Returns an array of {@code Class} objects that represent the
447      * types of exceptions declared to be thrown by the underlying
448      * executable represented by this object.  Returns an array of
449      * length 0 if the executable declares no exceptions in its {@code
450      * throws} clause.
451      *
452      * @return the exception types declared as being thrown by the
453      * executable this object represents
454      */
455     public abstract Class&lt;?&gt;[] getExceptionTypes();
456 
457     /**
458      * Returns an array of {@code Type} objects that represent the
459      * exceptions declared to be thrown by this executable object.
460      * Returns an array of length 0 if the underlying executable declares
461      * no exceptions in its {@code throws} clause.
462      *
463      * &lt;p&gt;If an exception type is a type variable or a parameterized
464      * type, it is created. Otherwise, it is resolved.
465      *
466      * @return an array of Types that represent the exception types
467      *     thrown by the underlying executable
468      * @throws GenericSignatureFormatError
469      *     if the generic method signature does not conform to the format
470      *     specified in
471      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
472      * @throws TypeNotPresentException if the underlying executable&#39;s
473      *     {@code throws} clause refers to a non-existent type declaration
474      * @throws MalformedParameterizedTypeException if
475      *     the underlying executable&#39;s {@code throws} clause refers to a
476      *     parameterized type that cannot be instantiated for any reason
477      */
478     public Type[] getGenericExceptionTypes() {
479         Type[] result;
480         if (hasGenericInformation() &amp;&amp;
481             ((result = getGenericInfo().getExceptionTypes()).length &gt; 0))
482             return result;
483         else
484             return getExceptionTypes();
485     }
486 
487     /**
488      * Returns a string describing this {@code Executable}, including
489      * any type parameters.
490      * @return a string describing this {@code Executable}, including
491      * any type parameters
492      */
493     public abstract String toGenericString();
494 
495     /**
496      * Returns {@code true} if this executable was declared to take a
497      * variable number of arguments; returns {@code false} otherwise.
498      *
499      * @return {@code true} if an only if this executable was declared
500      * to take a variable number of arguments.
501      */
502     public boolean isVarArgs()  {
503         return (getModifiers() &amp; Modifier.VARARGS) != 0;
504     }
505 
506     /**
507      * Returns {@code true} if this executable is a synthetic
508      * construct; returns {@code false} otherwise.
509      *
510      * @return true if and only if this executable is a synthetic
511      * construct as defined by
512      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
513      * @jls 13.1 The Form of a Binary
514      */
515     public boolean isSynthetic() {
516         return Modifier.isSynthetic(getModifiers());
517     }
518 
519     /**
520      * Returns an array of arrays of {@code Annotation}s that
521      * represent the annotations on the formal parameters, in
522      * declaration order, of the {@code Executable} represented by
523      * this object.  Synthetic and mandated parameters (see
524      * explanation below), such as the outer &quot;this&quot; parameter to an
525      * inner class constructor will be represented in the returned
526      * array.  If the executable has no parameters (meaning no formal,
527      * no synthetic, and no mandated parameters), a zero-length array
528      * will be returned.  If the {@code Executable} has one or more
529      * parameters, a nested array of length zero is returned for each
530      * parameter with no annotations. The annotation objects contained
531      * in the returned arrays are serializable.  The caller of this
532      * method is free to modify the returned arrays; it will have no
533      * effect on the arrays returned to other callers.
534      *
535      * A compiler may add extra parameters that are implicitly
536      * declared in source (&quot;mandated&quot;), as well as parameters that
537      * are neither implicitly nor explicitly declared in source
538      * (&quot;synthetic&quot;) to the parameter list for a method.  See {@link
539      * java.lang.reflect.Parameter} for more information.
540      *
541      * @see java.lang.reflect.Parameter
542      * @see java.lang.reflect.Parameter#getAnnotations
543      * @return an array of arrays that represent the annotations on
544      *    the formal and implicit parameters, in declaration order, of
545      *    the executable represented by this object
546      */
547     public abstract Annotation[][] getParameterAnnotations();
548 
549     Annotation[][] sharedGetParameterAnnotations(Class&lt;?&gt;[] parameterTypes,
550                                                  byte[] parameterAnnotations) {
551         int numParameters = parameterTypes.length;
552         if (parameterAnnotations == null)
553             return new Annotation[numParameters][0];
554 
555         Annotation[][] result = parseParameterAnnotations(parameterAnnotations);
556 
557         if (result.length != numParameters &amp;&amp;
558             handleParameterNumberMismatch(result.length, numParameters)) {
559             Annotation[][] tmp = new Annotation[result.length+1][];
560             // Shift annotations down one to account for an implicit leading parameter
561             System.arraycopy(result, 0, tmp, 1, result.length);
562             tmp[0] = new Annotation[0];
563             result = tmp;
564         }
565         return result;
566     }
567 
568     abstract boolean handleParameterNumberMismatch(int resultLength, int numParameters);
569 
570     /**
571      * {@inheritDoc}
572      * @throws NullPointerException  {@inheritDoc}
573      */
574     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
575         Objects.requireNonNull(annotationClass);
576         return annotationClass.cast(declaredAnnotations().get(annotationClass));
577     }
578 
579     /**
580      * {@inheritDoc}
581      * @throws NullPointerException {@inheritDoc}
582      */
583     @Override
584     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
585         Objects.requireNonNull(annotationClass);
586 
587         return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);
588     }
589 
590     /**
591      * {@inheritDoc}
592      */
593     public Annotation[] getDeclaredAnnotations()  {
594         return AnnotationParser.toArray(declaredAnnotations());
595     }
596 
597     private transient volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
598 
599     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
600         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declAnnos;
601         if ((declAnnos = declaredAnnotations) == null) {
602             synchronized (this) {
603                 if ((declAnnos = declaredAnnotations) == null) {
604                     Executable root = (Executable)getRoot();
605                     if (root != null) {
606                         declAnnos = root.declaredAnnotations();
607                     } else {
608                         declAnnos = AnnotationParser.parseAnnotations(
609                                 getAnnotationBytes(),
610                                 SharedSecrets.getJavaLangAccess().
611                                         getConstantPool(getDeclaringClass()),
612                                 getDeclaringClass()
613                         );
614                     }
615                     declaredAnnotations = declAnnos;
616                 }
617             }
618         }
619         return declAnnos;
620     }
621 
622     /**
623      * Returns an {@code AnnotatedType} object that represents the use of a type to
624      * specify the return type of the method/constructor represented by this
625      * Executable.
626      *
627      * If this {@code Executable} object represents a constructor, the {@code
628      * AnnotatedType} object represents the type of the constructed object.
629      *
630      * If this {@code Executable} object represents a method, the {@code
631      * AnnotatedType} object represents the use of a type to specify the return
632      * type of the method.
633      *
634      * @return an object representing the return type of the method
635      * or constructor represented by this {@code Executable}
636      */
637     public abstract AnnotatedType getAnnotatedReturnType();
638 
639     /* Helper for subclasses of Executable.
640      *
641      * Returns an AnnotatedType object that represents the use of a type to
642      * specify the return type of the method/constructor represented by this
643      * Executable.
644      */
645     AnnotatedType getAnnotatedReturnType0(Type returnType) {
646         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
647                 SharedSecrets.getJavaLangAccess().
648                         getConstantPool(getDeclaringClass()),
649                 this,
650                 getDeclaringClass(),
651                 returnType,
652                 TypeAnnotation.TypeAnnotationTarget.METHOD_RETURN);
653     }
654 
655     /**
656      * Returns an {@code AnnotatedType} object that represents the use of a
657      * type to specify the receiver type of the method/constructor represented
658      * by this {@code Executable} object.
659      *
660      * The receiver type of a method/constructor is available only if the
661      * method/constructor has a receiver parameter (JLS 8.4.1). If this {@code
662      * Executable} object &lt;em&gt;represents an instance method or represents a
663      * constructor of an inner member class&lt;/em&gt;, and the
664      * method/constructor &lt;em&gt;either&lt;/em&gt; has no receiver parameter or has a
665      * receiver parameter with no annotations on its type, then the return
666      * value is an {@code AnnotatedType} object representing an element with no
667      * annotations.
668      *
669      * If this {@code Executable} object represents a static method or
670      * represents a constructor of a top level, static member, local, or
671      * anonymous class, then the return value is null.
672      *
673      * @return an object representing the receiver type of the method or
674      * constructor represented by this {@code Executable} or {@code null} if
675      * this {@code Executable} can not have a receiver parameter
676      */
677     public AnnotatedType getAnnotatedReceiverType() {
678         if (Modifier.isStatic(this.getModifiers()))
679             return null;
680         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
681                 SharedSecrets.getJavaLangAccess().
682                         getConstantPool(getDeclaringClass()),
683                 this,
684                 getDeclaringClass(),
685                 getDeclaringClass(),
686                 TypeAnnotation.TypeAnnotationTarget.METHOD_RECEIVER);
687     }
688 
689     /**
690      * Returns an array of {@code AnnotatedType} objects that represent the use
691      * of types to specify formal parameter types of the method/constructor
692      * represented by this Executable. The order of the objects in the array
693      * corresponds to the order of the formal parameter types in the
694      * declaration of the method/constructor.
695      *
696      * Returns an array of length 0 if the method/constructor declares no
697      * parameters.
698      *
699      * @return an array of objects representing the types of the
700      * formal parameters of the method or constructor represented by this
701      * {@code Executable}
702      */
703     public AnnotatedType[] getAnnotatedParameterTypes() {
704         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
705                 SharedSecrets.getJavaLangAccess().
706                         getConstantPool(getDeclaringClass()),
707                 this,
708                 getDeclaringClass(),
709                 getAllGenericParameterTypes(),
710                 TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);
711     }
712 
713     /**
714      * Returns an array of {@code AnnotatedType} objects that represent the use
715      * of types to specify the declared exceptions of the method/constructor
716      * represented by this Executable. The order of the objects in the array
717      * corresponds to the order of the exception types in the declaration of
718      * the method/constructor.
719      *
720      * Returns an array of length 0 if the method/constructor declares no
721      * exceptions.
722      *
723      * @return an array of objects representing the declared
724      * exceptions of the method or constructor represented by this {@code
725      * Executable}
726      */
727     public AnnotatedType[] getAnnotatedExceptionTypes() {
728         return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),
729                 SharedSecrets.getJavaLangAccess().
730                         getConstantPool(getDeclaringClass()),
731                 this,
732                 getDeclaringClass(),
733                 getGenericExceptionTypes(),
734                 TypeAnnotation.TypeAnnotationTarget.THROWS);
735     }
736 
737 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/UnresolvedPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.security;
 27 
 28 import sun.security.util.IOUtils;
 29 
 30 import java.io.IOException;
 31 import java.io.ByteArrayInputStream;
 32 import java.security.cert.Certificate;
 33 import java.util.ArrayList;
 34 import java.util.Hashtable;
 35 import java.lang.reflect.*;
 36 import java.security.cert.*;
 37 import java.util.List;
 38 
 39 /**
 40  * The UnresolvedPermission class is used to hold Permissions that
 41  * were &quot;unresolved&quot; when the Policy was initialized.
 42  * An unresolved permission is one whose actual Permission class
 43  * does not yet exist at the time the Policy is initialized (see below).
 44  *
 45  * &lt;p&gt;The policy for a Java runtime (specifying
 46  * which permissions are available for code from various principals)
 47  * is represented by a Policy object.
 48  * Whenever a Policy is initialized or refreshed, Permission objects of
 49  * appropriate classes are created for all permissions
 50  * allowed by the Policy.
 51  *
 52  * &lt;p&gt;Many permission class types
 53  * referenced by the policy configuration are ones that exist
 54  * locally (i.e., ones that can be found on CLASSPATH).
 55  * Objects for such permissions can be instantiated during
 56  * Policy initialization. For example, it is always possible
 57  * to instantiate a java.io.FilePermission, since the
 58  * FilePermission class is found on the CLASSPATH.
 59  *
 60  * &lt;p&gt;Other permission classes may not yet exist during Policy
 61  * initialization. For example, a referenced permission class may
 62  * be in a JAR file that will later be loaded.
 63  * For each such class, an UnresolvedPermission is instantiated.
 64  * Thus, an UnresolvedPermission is essentially a &quot;placeholder&quot;
 65  * containing information about the permission.
 66  *
 67  * &lt;p&gt;Later, when code calls AccessController.checkPermission
 68  * on a permission of a type that was previously unresolved,
 69  * but whose class has since been loaded, previously-unresolved
 70  * permissions of that type are &quot;resolved&quot;. That is,
 71  * for each such UnresolvedPermission, a new object of
 72  * the appropriate class type is instantiated, based on the
 73  * information in the UnresolvedPermission.
 74  *
 75  * &lt;p&gt; To instantiate the new class, UnresolvedPermission assumes
 76  * the class provides a zero, one, and/or two-argument constructor.
 77  * The zero-argument constructor would be used to instantiate
 78  * a permission without a name and without actions.
 79  * A one-arg constructor is assumed to take a {@code String}
 80  * name as input, and a two-arg constructor is assumed to take a
 81  * {@code String} name and {@code String} actions
 82  * as input.  UnresolvedPermission may invoke a
 83  * constructor with a {@code null} name and/or actions.
 84  * If an appropriate permission constructor is not available,
 85  * the UnresolvedPermission is ignored and the relevant permission
 86  * will not be granted to executing code.
 87  *
 88  * &lt;p&gt; The newly created permission object replaces the
 89  * UnresolvedPermission, which is removed.
 90  *
 91  * &lt;p&gt; Note that the {@code getName} method for an
 92  * {@code UnresolvedPermission} returns the
 93  * {@code type} (class name) for the underlying permission
 94  * that has not been resolved.
 95  *
 96  * @see java.security.Permission
 97  * @see java.security.Permissions
 98  * @see java.security.PermissionCollection
 99  * @see java.security.Policy
100  *
101  *
102  * @author Roland Schemers
103  * @since 1.2
104  */
105 
106 public final class UnresolvedPermission extends Permission
107 implements java.io.Serializable
108 {
109 
<a name="2" id="anc2"></a>
110     private static final long serialVersionUID = -4821973115467008846L;
111 
112     private static final sun.security.util.Debug debug =
113         sun.security.util.Debug.getInstance
114         (&quot;policy,access&quot;, &quot;UnresolvedPermission&quot;);
115 
116     /**
117      * The class name of the Permission class that will be
118      * created when this unresolved permission is resolved.
119      *
120      * @serial
121      */
122     private String type;
123 
124     /**
125      * The permission name.
126      *
127      * @serial
128      */
129     private String name;
130 
131     /**
132      * The actions of the permission.
133      *
134      * @serial
135      */
136     private String actions;
137 
138     private transient java.security.cert.Certificate[] certs;
139 
140     /**
141      * Creates a new UnresolvedPermission containing the permission
142      * information needed later to actually create a Permission of the
143      * specified class, when the permission is resolved.
144      *
145      * @param type the class name of the Permission class that will be
146      * created when this unresolved permission is resolved.
147      * @param name the name of the permission.
148      * @param actions the actions of the permission.
149      * @param certs the certificates the permission&#39;s class was signed with.
150      * This is a list of certificate chains, where each chain is composed of a
151      * signer certificate and optionally its supporting certificate chain.
152      * Each chain is ordered bottom-to-top (i.e., with the signer certificate
153      * first and the (root) certificate authority last). The signer
154      * certificates are copied from the array. Subsequent changes to
155      * the array will not affect this UnsolvedPermission.
156      */
157     public UnresolvedPermission(String type,
158                                 String name,
159                                 String actions,
160                                 java.security.cert.Certificate[] certs)
161     {
162         super(type);
163 
164         if (type == null)
165                 throw new NullPointerException(&quot;type can&#39;t be null&quot;);
166 
167         this.type = type;
168         this.name = name;
169         this.actions = actions;
170         if (certs != null) {
171             // Extract the signer certs from the list of certificates.
172             for (int i=0; i&lt;certs.length; i++) {
173                 if (!(certs[i] instanceof X509Certificate)) {
174                     // there is no concept of signer certs, so we store the
175                     // entire cert array
176                     this.certs = certs.clone();
177                     break;
178                 }
179             }
180 
181             if (this.certs == null) {
182                 // Go through the list of certs and see if all the certs are
183                 // signer certs.
184                 int i = 0;
185                 int count = 0;
186                 while (i &lt; certs.length) {
187                     count++;
188                     while (((i+1) &lt; certs.length) &amp;&amp;
189                            ((X509Certificate)certs[i]).getIssuerDN().equals(
190                                ((X509Certificate)certs[i+1]).getSubjectDN())) {
191                         i++;
192                     }
193                     i++;
194                 }
195                 if (count == certs.length) {
196                     // All the certs are signer certs, so we store the entire
197                     // array
198                     this.certs = certs.clone();
199                 }
200 
201                 if (this.certs == null) {
202                     // extract the signer certs
203                     ArrayList&lt;java.security.cert.Certificate&gt; signerCerts =
204                         new ArrayList&lt;&gt;();
205                     i = 0;
206                     while (i &lt; certs.length) {
207                         signerCerts.add(certs[i]);
208                         while (((i+1) &lt; certs.length) &amp;&amp;
209                             ((X509Certificate)certs[i]).getIssuerDN().equals(
210                               ((X509Certificate)certs[i+1]).getSubjectDN())) {
211                             i++;
212                         }
213                         i++;
214                     }
215                     this.certs =
216                         new java.security.cert.Certificate[signerCerts.size()];
217                     signerCerts.toArray(this.certs);
218                 }
219             }
220         }
221     }
222 
223 
224     private static final Class&lt;?&gt;[] PARAMS0 = { };
225     private static final Class&lt;?&gt;[] PARAMS1 = { String.class };
226     private static final Class&lt;?&gt;[] PARAMS2 = { String.class, String.class };
227 
228     /**
229      * try and resolve this permission using the class loader of the permission
230      * that was passed in.
231      */
232     Permission resolve(Permission p, java.security.cert.Certificate[] certs) {
233         if (this.certs != null) {
234             // if p wasn&#39;t signed, we don&#39;t have a match
235             if (certs == null) {
236                 return null;
237             }
238 
239             // all certs in this.certs must be present in certs
240             boolean match;
241             for (int i = 0; i &lt; this.certs.length; i++) {
242                 match = false;
243                 for (int j = 0; j &lt; certs.length; j++) {
244                     if (this.certs[i].equals(certs[j])) {
245                         match = true;
246                         break;
247                     }
248                 }
249                 if (!match) return null;
250             }
251         }
252         try {
253             Class&lt;?&gt; pc = p.getClass();
254 
255             if (name == null &amp;&amp; actions == null) {
256                 try {
257                     Constructor&lt;?&gt; c = pc.getConstructor(PARAMS0);
258                     return (Permission)c.newInstance(new Object[] {});
259                 } catch (NoSuchMethodException ne) {
260                     try {
261                         Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);
262                         return (Permission) c.newInstance(
263                               new Object[] { name});
264                     } catch (NoSuchMethodException ne1) {
265                         Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
266                         return (Permission) c.newInstance(
267                               new Object[] { name, actions });
268                     }
269                 }
270             } else {
271                 if (name != null &amp;&amp; actions == null) {
272                     try {
273                         Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);
274                         return (Permission) c.newInstance(
275                               new Object[] { name});
276                     } catch (NoSuchMethodException ne) {
277                         Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
278                         return (Permission) c.newInstance(
279                               new Object[] { name, actions });
280                     }
281                 } else {
282                     Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);
283                     return (Permission) c.newInstance(
284                           new Object[] { name, actions });
285                 }
286             }
287         } catch (NoSuchMethodException nsme) {
288             if (debug != null ) {
289                 debug.println(&quot;NoSuchMethodException:\n  could not find &quot; +
290                         &quot;proper constructor for &quot; + type);
291                 nsme.printStackTrace();
292             }
293             return null;
294         } catch (Exception e) {
295             if (debug != null ) {
296                 debug.println(&quot;unable to instantiate &quot; + name);
297                 e.printStackTrace();
298             }
299             return null;
300         }
301     }
302 
303     /**
304      * This method always returns false for unresolved permissions.
305      * That is, an UnresolvedPermission is never considered to
306      * imply another permission.
307      *
308      * @param p the permission to check against.
309      *
310      * @return false.
311      */
312     public boolean implies(Permission p) {
313         return false;
314     }
315 
316     /**
317      * Checks two UnresolvedPermission objects for equality.
318      * Checks that {@code obj} is an UnresolvedPermission, and has
319      * the same type (class) name, permission name, actions, and
320      * certificates as this object.
321      *
322      * &lt;p&gt; To determine certificate equality, this method only compares
323      * actual signer certificates.  Supporting certificate chains
324      * are not taken into consideration by this method.
325      *
326      * @param obj the object we are testing for equality with this object.
327      *
328      * @return true if obj is an UnresolvedPermission, and has the same
329      * type (class) name, permission name, actions, and
330      * certificates as this object.
331      */
332     public boolean equals(Object obj) {
333         if (obj == this)
334             return true;
335 
336         if (! (obj instanceof UnresolvedPermission))
337             return false;
338         UnresolvedPermission that = (UnresolvedPermission) obj;
339 
340         // check type
341         if (!this.type.equals(that.type)) {
342             return false;
343         }
344 
345         // check name
346         if (this.name == null) {
347             if (that.name != null) {
348                 return false;
349             }
350         } else if (!this.name.equals(that.name)) {
351             return false;
352         }
353 
354         // check actions
355         if (this.actions == null) {
356             if (that.actions != null) {
357                 return false;
358             }
359         } else {
360             if (!this.actions.equals(that.actions)) {
361                 return false;
362             }
363         }
364 
365         // check certs
366         if ((this.certs == null &amp;&amp; that.certs != null) ||
367             (this.certs != null &amp;&amp; that.certs == null) ||
368             (this.certs != null &amp;&amp; that.certs != null &amp;&amp;
369                 this.certs.length != that.certs.length)) {
370             return false;
371         }
372 
373         int i,j;
374         boolean match;
375 
376         for (i = 0; this.certs != null &amp;&amp; i &lt; this.certs.length; i++) {
377             match = false;
378             for (j = 0; j &lt; that.certs.length; j++) {
379                 if (this.certs[i].equals(that.certs[j])) {
380                     match = true;
381                     break;
382                 }
383             }
384             if (!match) return false;
385         }
386 
387         for (i = 0; that.certs != null &amp;&amp; i &lt; that.certs.length; i++) {
388             match = false;
389             for (j = 0; j &lt; this.certs.length; j++) {
390                 if (that.certs[i].equals(this.certs[j])) {
391                     match = true;
392                     break;
393                 }
394             }
395             if (!match) return false;
396         }
397         return true;
398     }
399 
400     /**
401      * Returns the hash code value for this object.
402      *
403      * @return a hash code value for this object.
404      */
405 
406     public int hashCode() {
407         int hash = type.hashCode();
408         if (name != null)
409             hash ^= name.hashCode();
410         if (actions != null)
411             hash ^= actions.hashCode();
412         return hash;
413     }
414 
415     /**
416      * Returns the canonical string representation of the actions,
417      * which currently is the empty string &quot;&quot;, since there are no actions for
418      * an UnresolvedPermission. That is, the actions for the
419      * permission that will be created when this UnresolvedPermission
420      * is resolved may be non-null, but an UnresolvedPermission
421      * itself is never considered to have any actions.
422      *
423      * @return the empty string &quot;&quot;.
424      */
425     public String getActions()
426     {
427         return &quot;&quot;;
428     }
429 
430     /**
431      * Get the type (class name) of the underlying permission that
432      * has not been resolved.
433      *
434      * @return the type (class name) of the underlying permission that
435      *  has not been resolved
436      *
437      * @since 1.5
438      */
439     public String getUnresolvedType() {
440         return type;
441     }
442 
443     /**
444      * Get the target name of the underlying permission that
445      * has not been resolved.
446      *
447      * @return the target name of the underlying permission that
448      *          has not been resolved, or {@code null},
449      *          if there is no target name
450      *
451      * @since 1.5
452      */
453     public String getUnresolvedName() {
454         return name;
455     }
456 
457     /**
458      * Get the actions for the underlying permission that
459      * has not been resolved.
460      *
461      * @return the actions for the underlying permission that
462      *          has not been resolved, or {@code null}
463      *          if there are no actions
464      *
465      * @since 1.5
466      */
467     public String getUnresolvedActions() {
468         return actions;
469     }
470 
471     /**
472      * Get the signer certificates (without any supporting chain)
473      * for the underlying permission that has not been resolved.
474      *
475      * @return the signer certificates for the underlying permission that
476      * has not been resolved, or null, if there are no signer certificates.
477      * Returns a new array each time this method is called.
478      *
479      * @since 1.5
480      */
481     public java.security.cert.Certificate[] getUnresolvedCerts() {
482         return (certs == null) ? null : certs.clone();
483     }
484 
485     /**
486      * Returns a string describing this UnresolvedPermission.  The convention
487      * is to specify the class name, the permission name, and the actions, in
488      * the following format: &#39;(unresolved &quot;ClassName&quot; &quot;name&quot; &quot;actions&quot;)&#39;.
489      *
490      * @return information about this UnresolvedPermission.
491      */
492     public String toString() {
493         return &quot;(unresolved &quot; + type + &quot; &quot; + name + &quot; &quot; + actions + &quot;)&quot;;
494     }
495 
496     /**
497      * Returns a new PermissionCollection object for storing
498      * UnresolvedPermission  objects.
499      *
500      * @return a new PermissionCollection object suitable for
501      * storing UnresolvedPermissions.
502      */
503 
504     public PermissionCollection newPermissionCollection() {
505         return new UnresolvedPermissionCollection();
506     }
507 
508     /**
509      * Writes this object out to a stream (i.e., serializes it).
510      *
511      * @serialData An initial {@code String} denoting the
512      * {@code type} is followed by a {@code String} denoting the
513      * {@code name} is followed by a {@code String} denoting the
514      * {@code actions} is followed by an {@code int} indicating the
515      * number of certificates to follow
516      * (a value of &quot;zero&quot; denotes that there are no certificates associated
517      * with this object).
518      * Each certificate is written out starting with a {@code String}
519      * denoting the certificate type, followed by an
520      * {@code int} specifying the length of the certificate encoding,
521      * followed by the certificate encoding itself which is written out as an
522      * array of bytes.
523      */
<a name="3" id="anc3"></a>
524     private void writeObject(java.io.ObjectOutputStream oos)
525         throws IOException
526     {
527         oos.defaultWriteObject();
528 
529         if (certs==null || certs.length==0) {
530             oos.writeInt(0);
531         } else {
532             // write out the total number of certs
533             oos.writeInt(certs.length);
534             // write out each cert, including its type
535             for (int i=0; i &lt; certs.length; i++) {
536                 java.security.cert.Certificate cert = certs[i];
537                 try {
538                     oos.writeUTF(cert.getType());
539                     byte[] encoded = cert.getEncoded();
540                     oos.writeInt(encoded.length);
541                     oos.write(encoded);
542                 } catch (CertificateEncodingException cee) {
543                     throw new IOException(cee.getMessage());
544                 }
545             }
546         }
547     }
548 
549     /**
550      * Restores this object from a stream (i.e., deserializes it).
551      */
<a name="4" id="anc4"></a>
552     private void readObject(java.io.ObjectInputStream ois)
553         throws IOException, ClassNotFoundException
554     {
555         CertificateFactory cf;
556         Hashtable&lt;String, CertificateFactory&gt; cfs = null;
557         List&lt;Certificate&gt; certList = null;
558 
559         ois.defaultReadObject();
560 
561         if (type == null)
562                 throw new NullPointerException(&quot;type can&#39;t be null&quot;);
563 
564         // process any new-style certs in the stream (if present)
565         int size = ois.readInt();
566         if (size &gt; 0) {
567             // we know of 3 different cert types: X.509, PGP, SDSI, which
568             // could all be present in the stream at the same time
569             cfs = new Hashtable&lt;&gt;(3);
570             certList = new ArrayList&lt;&gt;(size &gt; 20 ? 20 : size);
571         } else if (size &lt; 0) {
572             throw new IOException(&quot;size cannot be negative&quot;);
573         }
574 
575         for (int i=0; i&lt;size; i++) {
576             // read the certificate type, and instantiate a certificate
577             // factory of that type (reuse existing factory if possible)
578             String certType = ois.readUTF();
579             if (cfs.containsKey(certType)) {
580                 // reuse certificate factory
581                 cf = cfs.get(certType);
582             } else {
583                 // create new certificate factory
584                 try {
585                     cf = CertificateFactory.getInstance(certType);
586                 } catch (CertificateException ce) {
587                     throw new ClassNotFoundException
588                         (&quot;Certificate factory for &quot;+certType+&quot; not found&quot;);
589                 }
590                 // store the certificate factory so we can reuse it later
591                 cfs.put(certType, cf);
592             }
593             // parse the certificate
<a name="5" id="anc5"></a><span class="line-modified">594             byte[] encoded = IOUtils.readNBytes(ois, ois.readInt());</span>
595             ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
596             try {
597                 certList.add(cf.generateCertificate(bais));
598             } catch (CertificateException ce) {
599                 throw new IOException(ce.getMessage());
600             }
601             bais.close();
602         }
603         if (certList != null) {
604             this.certs = certList.toArray(
605                     new java.security.cert.Certificate[size]);
606         }
607     }
608 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/FilePermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileReader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/FilePermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,11 ***</span>
   * This class represents access to a file or directory.  A FilePermission consists
   * of a pathname and a set of actions valid for that pathname.
   * &lt;P&gt;
   * Pathname is the pathname of the file or directory granted the specified
   * actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">!  * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;) indicates</span>
   * all the files and directories contained in that directory. A pathname
   * that ends with &quot;/-&quot; indicates (recursively) all files
   * and subdirectories contained in that directory. Such a pathname is called
   * a wildcard pathname. Otherwise, it&#39;s a simple pathname.
   * &lt;P&gt;
<span class="line-new-header">--- 44,11 ---</span>
   * This class represents access to a file or directory.  A FilePermission consists
   * of a pathname and a set of actions valid for that pathname.
   * &lt;P&gt;
   * Pathname is the pathname of the file or directory granted the specified
   * actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">!  * the file separator character, {@code File.separatorChar}) indicates</span>
   * all the files and directories contained in that directory. A pathname
   * that ends with &quot;/-&quot; indicates (recursively) all files
   * and subdirectories contained in that directory. Such a pathname is called
   * a wildcard pathname. Otherwise, it&#39;s a simple pathname.
   * &lt;P&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,15 ***</span>
   *
   * &lt;DL&gt;
   *    &lt;DT&gt; read &lt;DD&gt; read permission
   *    &lt;DT&gt; write &lt;DD&gt; write permission
   *    &lt;DT&gt; execute
<span class="line-modified">!  *    &lt;DD&gt; execute permission. Allows &lt;code&gt;Runtime.exec&lt;/code&gt; to</span>
<span class="line-modified">!  *         be called. Corresponds to &lt;code&gt;SecurityManager.checkExec&lt;/code&gt;.</span>
   *    &lt;DT&gt; delete
<span class="line-modified">!  *    &lt;DD&gt; delete permission. Allows &lt;code&gt;File.delete&lt;/code&gt; to</span>
<span class="line-modified">!  *         be called. Corresponds to &lt;code&gt;SecurityManager.checkDelete&lt;/code&gt;.</span>
   *    &lt;DT&gt; readlink
   *    &lt;DD&gt; read link permission. Allows the target of a
   *         &lt;a href=&quot;../nio/file/package-summary.html#links&quot;&gt;symbolic link&lt;/a&gt;
   *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
   *         readSymbolicLink } method.
<span class="line-new-header">--- 68,15 ---</span>
   *
   * &lt;DL&gt;
   *    &lt;DT&gt; read &lt;DD&gt; read permission
   *    &lt;DT&gt; write &lt;DD&gt; write permission
   *    &lt;DT&gt; execute
<span class="line-modified">!  *    &lt;DD&gt; execute permission. Allows {@code Runtime.exec} to</span>
<span class="line-modified">!  *         be called. Corresponds to {@code SecurityManager.checkExec}.</span>
   *    &lt;DT&gt; delete
<span class="line-modified">!  *    &lt;DD&gt; delete permission. Allows {@code File.delete} to</span>
<span class="line-modified">!  *         be called. Corresponds to {@code SecurityManager.checkDelete}.</span>
   *    &lt;DT&gt; readlink
   *    &lt;DD&gt; read link permission. Allows the target of a
   *         &lt;a href=&quot;../nio/file/package-summary.html#links&quot;&gt;symbolic link&lt;/a&gt;
   *         to be read by invoking the {@link java.nio.file.Files#readSymbolicLink
   *         readSymbolicLink } method.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 193,11 ---</span>
  //        }
  //        sb.append(&quot;***\n&quot;);
  //        return sb.toString();
  //    }
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 7930732926638008763L;
  
      /**
       * Use the platform&#39;s default file system to avoid recursive initialization
       * issues when the VM is configured to use a custom file system provider.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,16 ***</span>
<span class="line-new-header">--- 365,26 ---</span>
                  throw new NullPointerException(&quot;name can&#39;t be null&quot;);
  
              this.mask = mask;
  
              if (cpath.equals(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;)) {
<span class="line-added">+                 allFiles = true;</span>
                  directory = true;
                  recursive = true;
                  cpath = &quot;&quot;;
                  return;
              }
  
<span class="line-added">+             // Validate path by platform&#39;s default file system</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 String name = cpath.endsWith(&quot;*&quot;) ? cpath.substring(0, cpath.length() - 1) + &quot;-&quot; : cpath;</span>
<span class="line-added">+                 builtInFS.getPath(new File(name).getPath());</span>
<span class="line-added">+             } catch (InvalidPathException ipe) {</span>
<span class="line-added">+                 invalid = true;</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              // store only the canonical cpath if possible
              cpath = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
                  public String run() {
                      try {
                          String path = cpath;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,11 ***</span>
       * contains a comma-separated list of the desired actions granted on the
       * file or directory. Possible actions are
       * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;.
       *
       * &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">!      * the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;)</span>
       * indicates all the files and directories contained in that directory.
       * A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
       * subdirectories contained in that directory. The special pathname
       * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} matches any file.
       *
<span class="line-new-header">--- 434,11 ---</span>
       * contains a comma-separated list of the desired actions granted on the
       * file or directory. Possible actions are
       * &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;.
       *
       * &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
<span class="line-modified">!      * the file separator character, {@code File.separatorChar})</span>
       * indicates all the files and directories contained in that directory.
       * A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
       * subdirectories contained in that directory. The special pathname
       * {@literal &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;} matches any file.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,12 ***</span>
       * directory.
       *
       * &lt;p&gt;A pathname containing an empty string represents an empty path.
       *
       * @implNote In this implementation, the
<span class="line-modified">!      * {@code jdk.io.permissionsUseCanonicalPath} system property dictates how</span>
<span class="line-modified">!      * the {@code path} argument is processed and stored.</span>
       * &lt;P&gt;
       * If the value of the system property is set to {@code true}, {@code path}
       * is canonicalized and stored as a String object named {@code cpath}.
       * This means a relative path is converted to an absolute path, a Windows
       * DOS-style 8.3 path is expanded to a long path, and a symbolic link is
<span class="line-new-header">--- 449,12 ---</span>
       * directory.
       *
       * &lt;p&gt;A pathname containing an empty string represents an empty path.
       *
       * @implNote In this implementation, the
<span class="line-modified">!      * {@systemProperty jdk.io.permissionsUseCanonicalPath} system property</span>
<span class="line-modified">!      * dictates how the {@code path} argument is processed and stored.</span>
       * &lt;P&gt;
       * If the value of the system property is set to {@code true}, {@code path}
       * is canonicalized and stored as a String object named {@code cpath}.
       * This means a relative path is converted to an absolute path, a Windows
       * DOS-style 8.3 path is expanded to a long path, and a symbolic link is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,17 ***</span>
       * {@code path} is removed before canonicalization or normalization.
       * It is stored in a separate wildcard flag field.
       * &lt;P&gt;
       * The default value of the {@code jdk.io.permissionsUseCanonicalPath}
       * system property is {@code false} in this implementation.
       *
       * @param path the pathname of the file/directory.
       * @param actions the action string.
       *
<span class="line-modified">!      * @throws IllegalArgumentException</span>
<span class="line-modified">!      *          If actions is &lt;code&gt;null&lt;/code&gt;, empty or contains an action</span>
<span class="line-modified">!      *          other than the specified possible actions.</span>
       */
      public FilePermission(String path, String actions) {
          super(path);
          init(getMask(actions));
      }
<span class="line-new-header">--- 471,20 ---</span>
       * {@code path} is removed before canonicalization or normalization.
       * It is stored in a separate wildcard flag field.
       * &lt;P&gt;
       * The default value of the {@code jdk.io.permissionsUseCanonicalPath}
       * system property is {@code false} in this implementation.
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * The value can also be set with a security property using the same name,</span>
<span class="line-added">+      * but setting a system property will override the security property value.</span>
       *
       * @param path the pathname of the file/directory.
       * @param actions the action string.
       *
<span class="line-modified">!      * @throws IllegalArgumentException if actions is {@code null}, empty,</span>
<span class="line-modified">!      *         malformed or contains an action other than the specified</span>
<span class="line-modified">!      *         possible actions</span>
       */
      public FilePermission(String path, String actions) {
          super(path);
          init(getMask(actions));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,11 ***</span>
      /**
       * Creates a new FilePermission object using an action mask.
       * More efficient than the FilePermission(String, String) constructor.
       * Can be used from within
       * code that needs to create a FilePermission object to pass into the
<span class="line-modified">!      * &lt;code&gt;implies&lt;/code&gt; method.</span>
       *
       * @param path the pathname of the file/directory.
       * @param mask the action mask to use.
       */
      // package private for use by the FilePermissionCollection add method
<span class="line-new-header">--- 492,11 ---</span>
      /**
       * Creates a new FilePermission object using an action mask.
       * More efficient than the FilePermission(String, String) constructor.
       * Can be used from within
       * code that needs to create a FilePermission object to pass into the
<span class="line-modified">!      * {@code implies} method.</span>
       *
       * @param path the pathname of the file/directory.
       * @param mask the action mask to use.
       */
      // package private for use by the FilePermissionCollection add method
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,13 ***</span>
       * invalid {@code FilePermission}. Even if two {@code FilePermission}
       * are created with the same invalid path, one does not imply the other.
       *
       * @param p the permission to check against.
       *
<span class="line-modified">!      * @return &lt;code&gt;true&lt;/code&gt; if the specified permission is not</span>
<span class="line-modified">!      *                  &lt;code&gt;null&lt;/code&gt; and is implied by this object,</span>
<span class="line-modified">!      *                  &lt;code&gt;false&lt;/code&gt; otherwise.</span>
       */
      @Override
      public boolean implies(Permission p) {
          if (!(p instanceof FilePermission))
              return false;
<span class="line-new-header">--- 558,13 ---</span>
       * invalid {@code FilePermission}. Even if two {@code FilePermission}
       * are created with the same invalid path, one does not imply the other.
       *
       * @param p the permission to check against.
       *
<span class="line-modified">!      * @return {@code true} if the specified permission is not</span>
<span class="line-modified">!      *                  {@code null} and is implied by this object,</span>
<span class="line-modified">!      *                  {@code false} otherwise.</span>
       */
      @Override
      public boolean implies(Permission p) {
          if (!(p instanceof FilePermission))
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,23 ***</span>
       *
       * @param that the FilePermission to check against.
       * @return the effective mask
       */
      boolean impliesIgnoreMask(FilePermission that) {
          if (FilePermCompat.nb) {
<span class="line-removed">-             if (this == that) {</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (allFiles) {</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (this.invalid || that.invalid) {</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (that.allFiles) {</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
              // Left at least same level of wildness as right
              if ((this.recursive &amp;&amp; that.recursive) != that.recursive
                      || (this.directory &amp;&amp; that.directory) != that.directory) {
                  return false;
              }
<span class="line-new-header">--- 584,23 ---</span>
       *
       * @param that the FilePermission to check against.
       * @return the effective mask
       */
      boolean impliesIgnoreMask(FilePermission that) {
<span class="line-added">+         if (this == that) {</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (allFiles) {</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (this.invalid || that.invalid) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (that.allFiles) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
          if (FilePermCompat.nb) {
              // Left at least same level of wildness as right
              if ((this.recursive &amp;&amp; that.recursive) != that.recursive
                      || (this.directory &amp;&amp; that.directory) != that.directory) {
                  return false;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 766,13 ***</span>
       * When {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, an
       * invalid {@code FilePermission} does not equal to any object except
       * for itself, even if they are created using the same invalid path.
       *
       * @param obj the object we are testing for equality with this object.
<span class="line-modified">!      * @return &lt;code&gt;true&lt;/code&gt; if obj is a FilePermission, and has the same</span>
       *          pathname and actions as this FilePermission object,
<span class="line-modified">!      *          &lt;code&gt;false&lt;/code&gt; otherwise.</span>
       */
      @Override
      public boolean equals(Object obj) {
          if (obj == this)
              return true;
<span class="line-new-header">--- 780,13 ---</span>
       * When {@code jdk.io.permissionsUseCanonicalPath} is {@code false}, an
       * invalid {@code FilePermission} does not equal to any object except
       * for itself, even if they are created using the same invalid path.
       *
       * @param obj the object we are testing for equality with this object.
<span class="line-modified">!      * @return {@code true} if obj is a FilePermission, and has the same</span>
       *          pathname and actions as this FilePermission object,
<span class="line-modified">!      *          {@code false} otherwise.</span>
       */
      @Override
      public boolean equals(Object obj) {
          if (obj == this)
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,22 ***</span>
          if (! (obj instanceof FilePermission))
              return false;
  
          FilePermission that = (FilePermission) obj;
  
          if (FilePermCompat.nb) {
<span class="line-removed">-             if (this.invalid || that.invalid) {</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
              return (this.mask == that.mask) &amp;&amp;
                      (this.allFiles == that.allFiles) &amp;&amp;
                      this.npath.equals(that.npath) &amp;&amp;
                      Objects.equals(npath2, that.npath2) &amp;&amp;
                      (this.directory == that.directory) &amp;&amp;
                      (this.recursive == that.recursive);
          } else {
              return (this.mask == that.mask) &amp;&amp;
                      this.cpath.equals(that.cpath) &amp;&amp;
                      (this.directory == that.directory) &amp;&amp;
                      (this.recursive == that.recursive);
          }
      }
<span class="line-new-header">--- 794,23 ---</span>
          if (! (obj instanceof FilePermission))
              return false;
  
          FilePermission that = (FilePermission) obj;
  
<span class="line-added">+         if (this.invalid || that.invalid) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
          if (FilePermCompat.nb) {
              return (this.mask == that.mask) &amp;&amp;
                      (this.allFiles == that.allFiles) &amp;&amp;
                      this.npath.equals(that.npath) &amp;&amp;
                      Objects.equals(npath2, that.npath2) &amp;&amp;
                      (this.directory == that.directory) &amp;&amp;
                      (this.recursive == that.recursive);
          } else {
              return (this.mask == that.mask) &amp;&amp;
<span class="line-added">+                     (this.allFiles == that.allFiles) &amp;&amp;</span>
                      this.cpath.equals(that.cpath) &amp;&amp;
                      (this.directory == that.directory) &amp;&amp;
                      (this.recursive == that.recursive);
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,21 ***</span>
                  throw new IllegalArgumentException(
                          &quot;invalid permission: &quot; + actions);
              }
  
              // make sure we didn&#39;t just match the tail of a word
<span class="line-modified">!             // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.</span>
              boolean seencomma = false;
              while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified">!                 switch(a[i-matchlen]) {</span>
<span class="line-removed">-                 case &#39;,&#39;:</span>
<span class="line-removed">-                     seencomma = true;</span>
<span class="line-removed">-                     break;</span>
                  case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
                  case &#39;\f&#39;: case &#39;\t&#39;:
                      break;
                  default:
                      throw new IllegalArgumentException(
                              &quot;invalid permission: &quot; + actions);
                  }
                  i--;
              }
<span class="line-new-header">--- 933,22 ---</span>
                  throw new IllegalArgumentException(
                          &quot;invalid permission: &quot; + actions);
              }
  
              // make sure we didn&#39;t just match the tail of a word
<span class="line-modified">!             // like &quot;ackbarfdelete&quot;.  Also, skip to the comma.</span>
              boolean seencomma = false;
              while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified">!                 switch (c = a[i-matchlen]) {</span>
                  case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
                  case &#39;\f&#39;: case &#39;\t&#39;:
                      break;
                  default:
<span class="line-added">+                     if (c == &#39;,&#39; &amp;&amp; i &gt; matchlen) {</span>
<span class="line-added">+                         seencomma = true;</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
                      throw new IllegalArgumentException(
                              &quot;invalid permission: &quot; + actions);
                  }
                  i--;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,11 ***</span>
  
      /**
       * Returns the &quot;canonical string representation&quot; of the actions.
       * That is, this method always returns present actions in the following order:
       * read, write, execute, delete, readlink. For example, if this FilePermission
<span class="line-modified">!      * object allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;</span>
       * will return the string &quot;read,write&quot;.
       *
       * @return the canonical string representation of the actions.
       */
      @Override
<span class="line-new-header">--- 1000,11 ---</span>
  
      /**
       * Returns the &quot;canonical string representation&quot; of the actions.
       * That is, this method always returns present actions in the following order:
       * read, write, execute, delete, readlink. For example, if this FilePermission
<span class="line-modified">!      * object allows both write and read actions, a call to {@code getActions}</span>
       * will return the string &quot;read,write&quot;.
       *
       * @return the canonical string representation of the actions.
       */
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1003,31 ***</span>
       * Returns a new PermissionCollection object for storing FilePermission
       * objects.
       * &lt;p&gt;
       * FilePermission objects must be stored in a manner that allows them
       * to be inserted into the collection in any order, but that also enables the
<span class="line-modified">!      * PermissionCollection &lt;code&gt;implies&lt;/code&gt;</span>
       * method to be implemented in an efficient (and consistent) manner.
       *
       * &lt;p&gt;For example, if you have two FilePermissions:
       * &lt;OL&gt;
<span class="line-modified">!      * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/-&quot;, &quot;read&quot;&lt;/code&gt;</span>
<span class="line-modified">!      * &lt;LI&gt;  &lt;code&gt;&quot;/tmp/scratch/foo&quot;, &quot;write&quot;&lt;/code&gt;</span>
       * &lt;/OL&gt;
       *
<span class="line-modified">!      * &lt;p&gt;and you are calling the &lt;code&gt;implies&lt;/code&gt; method with the FilePermission:</span>
       *
       * &lt;pre&gt;
       *   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * then the &lt;code&gt;implies&lt;/code&gt; function must</span>
       * take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
       * permissions, so the effective permission is &quot;read,write&quot;,
<span class="line-modified">!      * and &lt;code&gt;implies&lt;/code&gt; returns true. The &quot;implies&quot; semantics for</span>
       * FilePermissions are handled properly by the PermissionCollection object
<span class="line-modified">!      * returned by this &lt;code&gt;newPermissionCollection&lt;/code&gt; method.</span>
       *
       * @return a new PermissionCollection object suitable for storing
       * FilePermissions.
       */
      @Override
<span class="line-new-header">--- 1019,31 ---</span>
       * Returns a new PermissionCollection object for storing FilePermission
       * objects.
       * &lt;p&gt;
       * FilePermission objects must be stored in a manner that allows them
       * to be inserted into the collection in any order, but that also enables the
<span class="line-modified">!      * PermissionCollection {@code implies}</span>
       * method to be implemented in an efficient (and consistent) manner.
       *
       * &lt;p&gt;For example, if you have two FilePermissions:
       * &lt;OL&gt;
<span class="line-modified">!      * &lt;LI&gt;  {@code &quot;/tmp/-&quot;, &quot;read&quot;}</span>
<span class="line-modified">!      * &lt;LI&gt;  {@code &quot;/tmp/scratch/foo&quot;, &quot;write&quot;}</span>
       * &lt;/OL&gt;
       *
<span class="line-modified">!      * &lt;p&gt;and you are calling the {@code implies} method with the FilePermission:</span>
       *
       * &lt;pre&gt;
       *   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * then the {@code implies} function must</span>
       * take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
       * permissions, so the effective permission is &quot;read,write&quot;,
<span class="line-modified">!      * and {@code implies} returns true. The &quot;implies&quot; semantics for</span>
       * FilePermissions are handled properly by the PermissionCollection object
<span class="line-modified">!      * returned by this {@code newPermissionCollection} method.</span>
       *
       * @return a new PermissionCollection object suitable for storing
       * FilePermissions.
       */
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,10 ***</span>
<span class="line-new-header">--- 1054,11 ---</span>
      /**
       * WriteObject is called to save the state of the FilePermission
       * to a stream. The actions are serialized, and the superclass
       * takes care of the name.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream s)
          throws IOException
      {
          // Write out the actions. The superclass takes care of the name
          // call getActions to make sure actions field is initialized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,10 ***</span>
<span class="line-new-header">--- 1069,11 ---</span>
  
      /**
       * readObject is called to restore the state of the FilePermission from
       * a stream.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream s)
           throws IOException, ClassNotFoundException
      {
          // Read in the actions, then restore everything else by calling init.
          s.defaultReadObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,14 ***</span>
       * Adds a permission to the FilePermissionCollection. The key for the hash is
       * permission.path.
       *
       * @param permission the Permission object to add.
       *
<span class="line-modified">!      * @exception IllegalArgumentException - if the permission is not a</span>
       *                                       FilePermission
       *
<span class="line-modified">!      * @exception SecurityException - if this FilePermissionCollection object</span>
       *                                has been marked readonly
       */
      @Override
      public void add(Permission permission) {
          if (! (permission instanceof FilePermission))
<span class="line-new-header">--- 1140,14 ---</span>
       * Adds a permission to the FilePermissionCollection. The key for the hash is
       * permission.path.
       *
       * @param permission the Permission object to add.
       *
<span class="line-modified">!      * @throws    IllegalArgumentException   if the permission is not a</span>
       *                                       FilePermission
       *
<span class="line-modified">!      * @throws    SecurityException   if this FilePermissionCollection object</span>
       *                                has been marked readonly
       */
      @Override
      public void add(Permission permission) {
          if (! (permission instanceof FilePermission))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,11 ***</span>
              if (((needed &amp; fp.getMask()) != 0) &amp;&amp; fp.impliesIgnoreMask(fperm)) {
                  effective |= fp.getMask();
                  if ((effective &amp; desired) == desired) {
                      return true;
                  }
<span class="line-modified">!                 needed = (desired ^ effective);</span>
              }
          }
          return false;
      }
  
<span class="line-new-header">--- 1209,11 ---</span>
              if (((needed &amp; fp.getMask()) != 0) &amp;&amp; fp.impliesIgnoreMask(fperm)) {
                  effective |= fp.getMask();
                  if ((effective &amp; desired) == desired) {
                      return true;
                  }
<span class="line-modified">!                 needed = (desired &amp; ~effective);</span>
              }
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1208,20 ***</span>
<span class="line-new-header">--- 1226,22 ---</span>
      @Override
      public Enumeration&lt;Permission&gt; elements() {
          return perms.elements();
      }
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 2202956749081564585L;
  
      // Need to maintain serialization interoperability with earlier releases,
      // which had the serializable field:
      //    private Vector permissions;
  
      /**
       * @serialField permissions java.util.Vector
       *     A list of FilePermission objects.
       */
<span class="line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields = {
          new ObjectStreamField(&quot;permissions&quot;, Vector.class),
      };
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,10 ***</span>
<span class="line-new-header">--- 1249,11 ---</span>
       */
      /*
       * Writes the contents of the perms field out as a Vector for
       * serialization compatibility with earlier releases.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream out) throws IOException {
          // Don&#39;t call out.defaultWriteObject()
  
          // Write out Vector
          Vector&lt;Permission&gt; permissions = new Vector&lt;&gt;(perms.values());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1243,10 ***</span>
<span class="line-new-header">--- 1264,11 ---</span>
      }
  
      /*
       * Reads in a Vector of FilePermissions and saves them in the perms field.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream in)
          throws IOException, ClassNotFoundException
      {
          // Don&#39;t call defaultReadObject()
  
</pre>
<center><a href="FileOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileReader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
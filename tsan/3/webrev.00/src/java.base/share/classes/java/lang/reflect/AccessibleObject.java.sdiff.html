<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/AccessibleObject.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ref/Reference.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Array.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/AccessibleObject.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.invoke.MethodHandle;
 30 import java.lang.ref.WeakReference;
 31 import java.security.AccessController;
 32 

 33 import jdk.internal.misc.VM;
 34 import jdk.internal.module.IllegalAccessLogger;
 35 import jdk.internal.reflect.CallerSensitive;
 36 import jdk.internal.reflect.Reflection;
 37 import jdk.internal.reflect.ReflectionFactory;
 38 import sun.security.action.GetPropertyAction;
 39 import sun.security.util.SecurityConstants;
 40 
 41 /**
 42  * The {@code AccessibleObject} class is the base class for {@code Field},
 43  * {@code Method}, and {@code Constructor} objects (known as &lt;em&gt;reflected
 44  * objects&lt;/em&gt;). It provides the ability to flag a reflected object as
 45  * suppressing checks for Java language access control when it is used. This
 46  * permits sophisticated applications with sufficient privilege, such as Java
 47  * Object Serialization or other persistence mechanisms, to manipulate objects
 48  * in a manner that would normally be prohibited.
 49  *
 50  * &lt;p&gt; Java language access control prevents use of private members outside
 51  * their top-level class; package access members outside their package; protected members
 52  * outside their package or subclasses; and public members outside their
 53  * module unless they are declared in an {@link Module#isExported(String,Module)
 54  * exported} package and the user {@link Module#canRead reads} their module. By
 55  * default, Java language access control is enforced (with one variation) when
 56  * {@code Field}s, {@code Method}s, or {@code Constructor}s are used to get or
 57  * set fields, to invoke methods, or to create and initialize new instances of
 58  * classes, respectively. Every reflected object checks that the code using it
<span class="line-modified"> 59  * is in an appropriate class, package, or module. &lt;/p&gt;</span>



 60  *
 61  * &lt;p&gt; The one variation from Java language access control is that the checks
 62  * by reflected objects assume readability. That is, the module containing
 63  * the use of a reflected object is assumed to read the module in which
 64  * the underlying field, method, or constructor is declared. &lt;/p&gt;
 65  *
 66  * &lt;p&gt; Whether the checks for Java language access control can be suppressed
 67  * (and thus, whether access can be enabled) depends on whether the reflected
 68  * object corresponds to a member in an exported or open package
 69  * (see {@link #setAccessible(boolean)}). &lt;/p&gt;
 70  *
 71  * @jls 6.6 Access Control
 72  * @since 1.2
 73  * @revised 9
 74  * @spec JPMS
 75  */
 76 public class AccessibleObject implements AnnotatedElement {




 77 
 78     static void checkPermission() {
 79         SecurityManager sm = System.getSecurityManager();
 80         if (sm != null) {
 81             // SecurityConstants.ACCESS_PERMISSION is used to check
 82             // whether a client has sufficient privilege to defeat Java
 83             // language access control checks.
 84             sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);
 85         }
 86     }
 87 
 88     /**
 89      * Convenience method to set the {@code accessible} flag for an
 90      * array of reflected objects with a single security check (for efficiency).
 91      *
 92      * &lt;p&gt; This method may be used to enable access to all reflected objects in
 93      * the array when access to each reflected object can be enabled as
 94      * specified by {@link #setAccessible(boolean) setAccessible(boolean)}. &lt;/p&gt;
 95      *
 96      * &lt;p&gt;If there is a security manager, its
</pre>
<hr />
<pre>
653         }
654         if (targetClass != null // instance member or constructor
655             &amp;&amp; Modifier.isProtected(modifiers)
656             &amp;&amp; targetClass != memberClass) {
657             if (isAccessChecked(caller, targetClass)) {
658                 return true;         // ACCESS IS OK
659             }
660         } else if (isAccessChecked(caller)) {
661             // Non-protected case (or targetClass == memberClass or static member).
662             return true;             // ACCESS IS OK
663         }
664 
665         // If no return, fall through to the slow path.
666         return slowVerifyAccess(caller, memberClass, targetClass, modifiers);
667     }
668 
669     // Keep all this slow stuff out of line:
670     private boolean slowVerifyAccess(Class&lt;?&gt; caller, Class&lt;?&gt; memberClass,
671                                      Class&lt;?&gt; targetClass, int modifiers)
672     {







673         if (!Reflection.verifyMemberAccess(caller, memberClass, targetClass, modifiers)) {
674             // access denied
675             return false;
676         }
677 
678         // access okay
679         logIfExportedForIllegalAccess(caller, memberClass);
680 
681         // Success: Update the cache.
682         Object cache = (targetClass != null
683                         &amp;&amp; Modifier.isProtected(modifiers)
684                         &amp;&amp; targetClass != memberClass)
685                         ? Cache.protectedMemberCallerCache(caller, targetClass)
686                         : new WeakReference&lt;&gt;(caller);
687         accessCheckCache = cache;         // write volatile
688         return true;
689     }
690 
691     // true to print a stack trace when access fails
692     private static volatile boolean printStackWhenAccessFails;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
 28 import java.lang.annotation.Annotation;
 29 import java.lang.invoke.MethodHandle;
 30 import java.lang.ref.WeakReference;
 31 import java.security.AccessController;
 32 
<span class="line-added"> 33 import jdk.internal.access.SharedSecrets;</span>
 34 import jdk.internal.misc.VM;
 35 import jdk.internal.module.IllegalAccessLogger;
 36 import jdk.internal.reflect.CallerSensitive;
 37 import jdk.internal.reflect.Reflection;
 38 import jdk.internal.reflect.ReflectionFactory;
 39 import sun.security.action.GetPropertyAction;
 40 import sun.security.util.SecurityConstants;
 41 
 42 /**
 43  * The {@code AccessibleObject} class is the base class for {@code Field},
 44  * {@code Method}, and {@code Constructor} objects (known as &lt;em&gt;reflected
 45  * objects&lt;/em&gt;). It provides the ability to flag a reflected object as
 46  * suppressing checks for Java language access control when it is used. This
 47  * permits sophisticated applications with sufficient privilege, such as Java
 48  * Object Serialization or other persistence mechanisms, to manipulate objects
 49  * in a manner that would normally be prohibited.
 50  *
 51  * &lt;p&gt; Java language access control prevents use of private members outside
 52  * their top-level class; package access members outside their package; protected members
 53  * outside their package or subclasses; and public members outside their
 54  * module unless they are declared in an {@link Module#isExported(String,Module)
 55  * exported} package and the user {@link Module#canRead reads} their module. By
 56  * default, Java language access control is enforced (with one variation) when
 57  * {@code Field}s, {@code Method}s, or {@code Constructor}s are used to get or
 58  * set fields, to invoke methods, or to create and initialize new instances of
 59  * classes, respectively. Every reflected object checks that the code using it
<span class="line-modified"> 60  * is in an appropriate class, package, or module. The check when invoked by</span>
<span class="line-added"> 61  * &lt;a href=&quot;{@docRoot}/../specs/jni/index.html&quot;&gt;JNI code&lt;/a&gt; with no Java</span>
<span class="line-added"> 62  * class on the stack only succeeds if the member and the declaring class are</span>
<span class="line-added"> 63  * public, and the class is in a package that is exported to all modules. &lt;/p&gt;</span>
 64  *
 65  * &lt;p&gt; The one variation from Java language access control is that the checks
 66  * by reflected objects assume readability. That is, the module containing
 67  * the use of a reflected object is assumed to read the module in which
 68  * the underlying field, method, or constructor is declared. &lt;/p&gt;
 69  *
 70  * &lt;p&gt; Whether the checks for Java language access control can be suppressed
 71  * (and thus, whether access can be enabled) depends on whether the reflected
 72  * object corresponds to a member in an exported or open package
 73  * (see {@link #setAccessible(boolean)}). &lt;/p&gt;
 74  *
 75  * @jls 6.6 Access Control
 76  * @since 1.2
 77  * @revised 9
 78  * @spec JPMS
 79  */
 80 public class AccessibleObject implements AnnotatedElement {
<span class="line-added"> 81     static {</span>
<span class="line-added"> 82         // AccessibleObject is initialized early in initPhase1</span>
<span class="line-added"> 83         SharedSecrets.setJavaLangReflectAccess(new ReflectAccess());</span>
<span class="line-added"> 84     }</span>
 85 
 86     static void checkPermission() {
 87         SecurityManager sm = System.getSecurityManager();
 88         if (sm != null) {
 89             // SecurityConstants.ACCESS_PERMISSION is used to check
 90             // whether a client has sufficient privilege to defeat Java
 91             // language access control checks.
 92             sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);
 93         }
 94     }
 95 
 96     /**
 97      * Convenience method to set the {@code accessible} flag for an
 98      * array of reflected objects with a single security check (for efficiency).
 99      *
100      * &lt;p&gt; This method may be used to enable access to all reflected objects in
101      * the array when access to each reflected object can be enabled as
102      * specified by {@link #setAccessible(boolean) setAccessible(boolean)}. &lt;/p&gt;
103      *
104      * &lt;p&gt;If there is a security manager, its
</pre>
<hr />
<pre>
661         }
662         if (targetClass != null // instance member or constructor
663             &amp;&amp; Modifier.isProtected(modifiers)
664             &amp;&amp; targetClass != memberClass) {
665             if (isAccessChecked(caller, targetClass)) {
666                 return true;         // ACCESS IS OK
667             }
668         } else if (isAccessChecked(caller)) {
669             // Non-protected case (or targetClass == memberClass or static member).
670             return true;             // ACCESS IS OK
671         }
672 
673         // If no return, fall through to the slow path.
674         return slowVerifyAccess(caller, memberClass, targetClass, modifiers);
675     }
676 
677     // Keep all this slow stuff out of line:
678     private boolean slowVerifyAccess(Class&lt;?&gt; caller, Class&lt;?&gt; memberClass,
679                                      Class&lt;?&gt; targetClass, int modifiers)
680     {
<span class="line-added">681 </span>
<span class="line-added">682         if (caller == null) {</span>
<span class="line-added">683             // No caller frame when a native thread attaches to the VM</span>
<span class="line-added">684             // only allow access to a public accessible member</span>
<span class="line-added">685             return Reflection.verifyPublicMemberAccess(memberClass, modifiers);</span>
<span class="line-added">686         }</span>
<span class="line-added">687 </span>
688         if (!Reflection.verifyMemberAccess(caller, memberClass, targetClass, modifiers)) {
689             // access denied
690             return false;
691         }
692 
693         // access okay
694         logIfExportedForIllegalAccess(caller, memberClass);
695 
696         // Success: Update the cache.
697         Object cache = (targetClass != null
698                         &amp;&amp; Modifier.isProtected(modifiers)
699                         &amp;&amp; targetClass != memberClass)
700                         ? Cache.protectedMemberCallerCache(caller, targetClass)
701                         : new WeakReference&lt;&gt;(caller);
702         accessCheckCache = cache;         // write volatile
703         return true;
704     }
705 
706     // true to print a stack trace when access fails
707     private static volatile boolean printStackWhenAccessFails;
</pre>
</td>
</tr>
</table>
<center><a href="../ref/Reference.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Array.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
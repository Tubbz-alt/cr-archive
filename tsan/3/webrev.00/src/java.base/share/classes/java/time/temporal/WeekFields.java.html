<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/time/temporal/WeekFields.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2011-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time.temporal;
  63 
  64 import static java.time.temporal.ChronoField.DAY_OF_MONTH;
  65 import static java.time.temporal.ChronoField.DAY_OF_WEEK;
  66 import static java.time.temporal.ChronoField.DAY_OF_YEAR;
  67 import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
  68 import static java.time.temporal.ChronoField.YEAR;
  69 import static java.time.temporal.ChronoUnit.DAYS;
  70 import static java.time.temporal.ChronoUnit.FOREVER;
  71 import static java.time.temporal.ChronoUnit.MONTHS;
  72 import static java.time.temporal.ChronoUnit.WEEKS;
  73 import static java.time.temporal.ChronoUnit.YEARS;
  74 
  75 import java.io.IOException;
  76 import java.io.InvalidObjectException;
  77 import java.io.ObjectInputStream;
  78 import java.io.Serializable;
  79 import java.time.DateTimeException;
  80 import java.time.DayOfWeek;
  81 import java.time.chrono.ChronoLocalDate;
  82 import java.time.chrono.Chronology;
  83 import java.time.format.ResolverStyle;
  84 import java.util.Locale;
  85 import java.util.Map;
  86 import java.util.Objects;
  87 import java.util.ResourceBundle;
  88 import java.util.concurrent.ConcurrentHashMap;
  89 import java.util.concurrent.ConcurrentMap;
  90 import sun.util.locale.provider.CalendarDataUtility;
  91 import sun.util.locale.provider.LocaleProviderAdapter;
  92 import sun.util.locale.provider.LocaleResources;
  93 
  94 /**
  95  * Localized definitions of the day-of-week, week-of-month and week-of-year fields.
  96  * &lt;p&gt;
  97  * A standard week is seven days long, but cultures have different definitions for some
  98  * other aspects of a week. This class represents the definition of the week, for the
  99  * purpose of providing {@link TemporalField} instances.
 100  * &lt;p&gt;
 101  * WeekFields provides five fields,
 102  * {@link #dayOfWeek()}, {@link #weekOfMonth()}, {@link #weekOfYear()},
 103  * {@link #weekOfWeekBasedYear()}, and {@link #weekBasedYear()}
 104  * that provide access to the values from any {@linkplain Temporal temporal object}.
 105  * &lt;p&gt;
 106  * The computations for day-of-week, week-of-month, and week-of-year are based
 107  * on the  {@linkplain ChronoField#YEAR proleptic-year},
 108  * {@linkplain ChronoField#MONTH_OF_YEAR month-of-year},
 109  * {@linkplain ChronoField#DAY_OF_MONTH day-of-month}, and
 110  * {@linkplain ChronoField#DAY_OF_WEEK ISO day-of-week} which are based on the
 111  * {@linkplain ChronoField#EPOCH_DAY epoch-day} and the chronology.
 112  * The values may not be aligned with the {@linkplain ChronoField#YEAR_OF_ERA year-of-Era}
 113  * depending on the Chronology.
 114  * &lt;p&gt;A week is defined by:
 115  * &lt;ul&gt;
 116  * &lt;li&gt;The first day-of-week.
 117  * For example, the ISO-8601 standard considers Monday to be the first day-of-week.
 118  * &lt;li&gt;The minimal number of days in the first week.
 119  * For example, the ISO-8601 standard counts the first week as needing at least 4 days.
 120  * &lt;/ul&gt;
 121  * Together these two values allow a year or month to be divided into weeks.
 122  *
 123  * &lt;h2&gt;Week of Month&lt;/h2&gt;
 124  * One field is used: week-of-month.
 125  * The calculation ensures that weeks never overlap a month boundary.
 126  * The month is divided into periods where each period starts on the defined first day-of-week.
 127  * The earliest period is referred to as week 0 if it has less than the minimal number of days
 128  * and week 1 if it has at least the minimal number of days.
 129  *
 130  * &lt;table class=striped style=&quot;text-align: left&quot;&gt;
 131  * &lt;caption&gt;Examples of WeekFields&lt;/caption&gt;
 132  * &lt;thead&gt;
 133  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Date&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Day-of-week&lt;/th&gt;
 134  *  &lt;th scope=&quot;col&quot;&gt;First day: Monday&lt;br&gt;Minimal days: 4&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;First day: Monday&lt;br&gt;Minimal days: 5&lt;/th&gt;&lt;/tr&gt;
 135  * &lt;/thead&gt;
 136  * &lt;tbody&gt;
 137  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2008-12-31&lt;/th&gt;&lt;td&gt;Wednesday&lt;/td&gt;
 138  *  &lt;td&gt;Week 5 of December 2008&lt;/td&gt;&lt;td&gt;Week 5 of December 2008&lt;/td&gt;&lt;/tr&gt;
 139  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-01&lt;/th&gt;&lt;td&gt;Thursday&lt;/td&gt;
 140  *  &lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;td&gt;Week 0 of January 2009&lt;/td&gt;&lt;/tr&gt;
 141  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-04&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;
 142  *  &lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;td&gt;Week 0 of January 2009&lt;/td&gt;&lt;/tr&gt;
 143  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-05&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;
 144  *  &lt;td&gt;Week 2 of January 2009&lt;/td&gt;&lt;td&gt;Week 1 of January 2009&lt;/td&gt;&lt;/tr&gt;
 145  * &lt;/tbody&gt;
 146  * &lt;/table&gt;
 147  *
 148  * &lt;h2&gt;Week of Year&lt;/h2&gt;
 149  * One field is used: week-of-year.
 150  * The calculation ensures that weeks never overlap a year boundary.
 151  * The year is divided into periods where each period starts on the defined first day-of-week.
 152  * The earliest period is referred to as week 0 if it has less than the minimal number of days
 153  * and week 1 if it has at least the minimal number of days.
 154  *
 155  * &lt;h2&gt;Week Based Year&lt;/h2&gt;
 156  * Two fields are used for week-based-year, one for the
 157  * {@link #weekOfWeekBasedYear() week-of-week-based-year} and one for
 158  * {@link #weekBasedYear() week-based-year}.  In a week-based-year, each week
 159  * belongs to only a single year.  Week 1 of a year is the first week that
 160  * starts on the first day-of-week and has at least the minimum number of days.
 161  * The first and last weeks of a year may contain days from the
 162  * previous calendar year or next calendar year respectively.
 163  *
 164  * &lt;table class=striped style=&quot;text-align: left;&quot;&gt;
 165  * &lt;caption&gt;Examples of WeekFields for week-based-year&lt;/caption&gt;
 166  * &lt;thead&gt;
 167  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Date&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Day-of-week&lt;/th&gt;
 168  *  &lt;th scope=&quot;col&quot;&gt;First day: Monday&lt;br&gt;Minimal days: 4&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;First day: Monday&lt;br&gt;Minimal days: 5&lt;/th&gt;&lt;/tr&gt;
 169  * &lt;/thead&gt;
 170  * &lt;tbody&gt;
 171  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2008-12-31&lt;/th&gt;&lt;td&gt;Wednesday&lt;/td&gt;
 172  *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 173  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-01&lt;/th&gt;&lt;td&gt;Thursday&lt;/td&gt;
 174  *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 175  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-04&lt;/th&gt;&lt;td&gt;Sunday&lt;/td&gt;
 176  *  &lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;td&gt;Week 53 of 2008&lt;/td&gt;&lt;/tr&gt;
 177  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;2009-01-05&lt;/th&gt;&lt;td&gt;Monday&lt;/td&gt;
 178  *  &lt;td&gt;Week 2 of 2009&lt;/td&gt;&lt;td&gt;Week 1 of 2009&lt;/td&gt;&lt;/tr&gt;
 179  * &lt;/tbody&gt;
 180  * &lt;/table&gt;
 181  *
 182  * @implSpec
 183  * This class is immutable and thread-safe.
 184  *
 185  * @since 1.8
 186  */
 187 public final class WeekFields implements Serializable {
 188     // implementation notes
 189     // querying week-of-month or week-of-year should return the week value bound within the month/year
 190     // however, setting the week value should be lenient (use plus/minus weeks)
 191     // allow week-of-month outer range [0 to 6]
 192     // allow week-of-year outer range [0 to 54]
 193     // this is because callers shouldn&#39;t be expected to know the details of validity
 194 
 195     /**
 196      * The cache of rules by firstDayOfWeek plus minimalDays.
 197      * Initialized first to be available for definition of ISO, etc.
 198      */
 199     private static final ConcurrentMap&lt;String, WeekFields&gt; CACHE = new ConcurrentHashMap&lt;&gt;(4, 0.75f, 2);
 200 
 201     /**
 202      * The ISO-8601 definition, where a week starts on Monday and the first week
 203      * has a minimum of 4 days.
 204      * &lt;p&gt;
 205      * The ISO-8601 standard defines a calendar system based on weeks.
 206      * It uses the week-based-year and week-of-week-based-year concepts to split
 207      * up the passage of days instead of the standard year/month/day.
 208      * &lt;p&gt;
 209      * Note that the first week may start in the previous calendar year.
 210      * Note also that the first few days of a calendar year may be in the
 211      * week-based-year corresponding to the previous calendar year.
 212      */
 213     public static final WeekFields ISO = new WeekFields(DayOfWeek.MONDAY, 4);
 214 
 215     /**
 216      * The common definition of a week that starts on Sunday and the first week
 217      * has a minimum of 1 day.
 218      * &lt;p&gt;
 219      * Defined as starting on Sunday and with a minimum of 1 day in the month.
 220      * This week definition is in use in the US and other European countries.
 221      */
 222     public static final WeekFields SUNDAY_START = WeekFields.of(DayOfWeek.SUNDAY, 1);
 223 
 224     /**
 225      * The unit that represents week-based-years for the purpose of addition and subtraction.
 226      * &lt;p&gt;
 227      * This allows a number of week-based-years to be added to, or subtracted from, a date.
 228      * The unit is equal to either 52 or 53 weeks.
 229      * The estimated duration of a week-based-year is the same as that of a standard ISO
 230      * year at {@code 365.2425 Days}.
 231      * &lt;p&gt;
 232      * The rules for addition add the number of week-based-years to the existing value
 233      * for the week-based-year field retaining the week-of-week-based-year
 234      * and day-of-week, unless the week number it too large for the target year.
 235      * In that case, the week is set to the last week of the year
 236      * with the same day-of-week.
 237      * &lt;p&gt;
 238      * This unit is an immutable and thread-safe singleton.
 239      */
 240     public static final TemporalUnit WEEK_BASED_YEARS = IsoFields.WEEK_BASED_YEARS;
 241 
 242     /**
 243      * Serialization version.
 244      */
 245     @java.io.Serial
 246     private static final long serialVersionUID = -1177360819670808121L;
 247 
 248     /**
 249      * The first day-of-week.
 250      */
 251     private final DayOfWeek firstDayOfWeek;
 252     /**
 253      * The minimal number of days in the first week.
 254      */
 255     private final int minimalDays;
 256     /**
 257      * The field used to access the computed DayOfWeek.
 258      */
 259     private final transient TemporalField dayOfWeek = ComputedDayOfField.ofDayOfWeekField(this);
 260     /**
 261      * The field used to access the computed WeekOfMonth.
 262      */
 263     private final transient TemporalField weekOfMonth = ComputedDayOfField.ofWeekOfMonthField(this);
 264     /**
 265      * The field used to access the computed WeekOfYear.
 266      */
 267     private final transient TemporalField weekOfYear = ComputedDayOfField.ofWeekOfYearField(this);
 268     /**
 269      * The field that represents the week-of-week-based-year.
 270      * &lt;p&gt;
 271      * This field allows the week of the week-based-year value to be queried and set.
 272      * &lt;p&gt;
 273      * This unit is an immutable and thread-safe singleton.
 274      */
 275     private final transient TemporalField weekOfWeekBasedYear = ComputedDayOfField.ofWeekOfWeekBasedYearField(this);
 276     /**
 277      * The field that represents the week-based-year.
 278      * &lt;p&gt;
 279      * This field allows the week-based-year value to be queried and set.
 280      * &lt;p&gt;
 281      * This unit is an immutable and thread-safe singleton.
 282      */
 283     private final transient TemporalField weekBasedYear = ComputedDayOfField.ofWeekBasedYearField(this);
 284 
 285     //-----------------------------------------------------------------------
 286     /**
 287      * Obtains an instance of {@code WeekFields} appropriate for a locale.
 288      * &lt;p&gt;
 289      * This will look up appropriate values from the provider of localization data.
 290      * If the locale contains &quot;fw&quot; (First day of week) and/or &quot;rg&quot;
 291      * (Region Override) &lt;a href=&quot;../../util/Locale.html#def_locale_extension&quot;&gt;
 292      * Unicode extensions&lt;/a&gt;, returned instance will reflect the values specified with
 293      * those extensions. If both &quot;fw&quot; and &quot;rg&quot; are specified, the value from
 294      * the &quot;fw&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.
 295      *
 296      * @param locale  the locale to use, not null
 297      * @return the week-definition, not null
 298      */
 299     public static WeekFields of(Locale locale) {
 300         Objects.requireNonNull(locale, &quot;locale&quot;);
 301 
 302         int calDow = CalendarDataUtility.retrieveFirstDayOfWeek(locale);
 303         DayOfWeek dow = DayOfWeek.SUNDAY.plus(calDow - 1);
 304         int minDays = CalendarDataUtility.retrieveMinimalDaysInFirstWeek(locale);
 305         return WeekFields.of(dow, minDays);
 306     }
 307 
 308     /**
 309      * Obtains an instance of {@code WeekFields} from the first day-of-week and minimal days.
 310      * &lt;p&gt;
 311      * The first day-of-week defines the ISO {@code DayOfWeek} that is day 1 of the week.
 312      * The minimal number of days in the first week defines how many days must be present
 313      * in a month or year, starting from the first day-of-week, before the week is counted
 314      * as the first week. A value of 1 will count the first day of the month or year as part
 315      * of the first week, whereas a value of 7 will require the whole seven days to be in
 316      * the new month or year.
 317      * &lt;p&gt;
 318      * WeekFields instances are singletons; for each unique combination
 319      * of {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek}
 320      * the same instance will be returned.
 321      *
 322      * @param firstDayOfWeek  the first day of the week, not null
 323      * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
 324      * @return the week-definition, not null
 325      * @throws IllegalArgumentException if the minimal days value is less than one
 326      *      or greater than 7
 327      */
 328     public static WeekFields of(DayOfWeek firstDayOfWeek, int minimalDaysInFirstWeek) {
 329         String key = firstDayOfWeek.toString() + minimalDaysInFirstWeek;
 330         WeekFields rules = CACHE.get(key);
 331         if (rules == null) {
 332             rules = new WeekFields(firstDayOfWeek, minimalDaysInFirstWeek);
 333             CACHE.putIfAbsent(key, rules);
 334             rules = CACHE.get(key);
 335         }
 336         return rules;
 337     }
 338 
 339     //-----------------------------------------------------------------------
 340     /**
 341      * Creates an instance of the definition.
 342      *
 343      * @param firstDayOfWeek  the first day of the week, not null
 344      * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
 345      * @throws IllegalArgumentException if the minimal days value is invalid
 346      */
 347     private WeekFields(DayOfWeek firstDayOfWeek, int minimalDaysInFirstWeek) {
 348         Objects.requireNonNull(firstDayOfWeek, &quot;firstDayOfWeek&quot;);
 349         if (minimalDaysInFirstWeek &lt; 1 || minimalDaysInFirstWeek &gt; 7) {
 350             throw new IllegalArgumentException(&quot;Minimal number of days is invalid&quot;);
 351         }
 352         this.firstDayOfWeek = firstDayOfWeek;
 353         this.minimalDays = minimalDaysInFirstWeek;
 354     }
 355 
 356     //-----------------------------------------------------------------------
 357     /**
 358      * Restore the state of a WeekFields from the stream.
 359      * Check that the values are valid.
 360      *
 361      * @param s the stream to read
 362      * @throws InvalidObjectException if the serialized object has an invalid
 363      *     value for firstDayOfWeek or minimalDays.
 364      * @throws ClassNotFoundException if a class cannot be resolved
 365      */
 366     @java.io.Serial
 367     private void readObject(ObjectInputStream s)
 368          throws IOException, ClassNotFoundException, InvalidObjectException
 369     {
 370         s.defaultReadObject();
 371         if (firstDayOfWeek == null) {
 372             throw new InvalidObjectException(&quot;firstDayOfWeek is null&quot;);
 373         }
 374 
 375         if (minimalDays &lt; 1 || minimalDays &gt; 7) {
 376             throw new InvalidObjectException(&quot;Minimal number of days is invalid&quot;);
 377         }
 378     }
 379 
 380     /**
 381      * Return the singleton WeekFields associated with the
 382      * {@code firstDayOfWeek} and {@code minimalDays}.
 383      * @return the singleton WeekFields for the firstDayOfWeek and minimalDays.
 384      * @throws InvalidObjectException if the serialized object has invalid
 385      *     values for firstDayOfWeek or minimalDays.
 386      */
 387     @java.io.Serial
 388     private Object readResolve() throws InvalidObjectException {
 389         try {
 390             return WeekFields.of(firstDayOfWeek, minimalDays);
 391         } catch (IllegalArgumentException iae) {
 392             throw new InvalidObjectException(&quot;Invalid serialized WeekFields: &quot; + iae.getMessage());
 393         }
 394     }
 395 
 396     //-----------------------------------------------------------------------
 397     /**
 398      * Gets the first day-of-week.
 399      * &lt;p&gt;
 400      * The first day-of-week varies by culture.
 401      * For example, the US uses Sunday, while France and the ISO-8601 standard use Monday.
 402      * This method returns the first day using the standard {@code DayOfWeek} enum.
 403      *
 404      * @return the first day-of-week, not null
 405      */
 406     public DayOfWeek getFirstDayOfWeek() {
 407         return firstDayOfWeek;
 408     }
 409 
 410     /**
 411      * Gets the minimal number of days in the first week.
 412      * &lt;p&gt;
 413      * The number of days considered to define the first week of a month or year
 414      * varies by culture.
 415      * For example, the ISO-8601 requires 4 days (more than half a week) to
 416      * be present before counting the first week.
 417      *
 418      * @return the minimal number of days in the first week of a month or year, from 1 to 7
 419      */
 420     public int getMinimalDaysInFirstWeek() {
 421         return minimalDays;
 422     }
 423 
 424     //-----------------------------------------------------------------------
 425     /**
 426      * Returns a field to access the day of week based on this {@code WeekFields}.
 427      * &lt;p&gt;
 428      * This is similar to {@link ChronoField#DAY_OF_WEEK} but uses values for
 429      * the day-of-week based on this {@code WeekFields}.
 430      * The days are numbered from 1 to 7 where the
 431      * {@link #getFirstDayOfWeek() first day-of-week} is assigned the value 1.
 432      * &lt;p&gt;
 433      * For example, if the first day-of-week is Sunday, then that will have the
 434      * value 1, with other days ranging from Monday as 2 to Saturday as 7.
 435      * &lt;p&gt;
 436      * In the resolving phase of parsing, a localized day-of-week will be converted
 437      * to a standardized {@code ChronoField} day-of-week.
 438      * The day-of-week must be in the valid range 1 to 7.
 439      * Other fields in this class build dates using the standardized day-of-week.
 440      *
 441      * @return a field providing access to the day-of-week with localized numbering, not null
 442      */
 443     public TemporalField dayOfWeek() {
 444         return dayOfWeek;
 445     }
 446 
 447     /**
 448      * Returns a field to access the week of month based on this {@code WeekFields}.
 449      * &lt;p&gt;
 450      * This represents the concept of the count of weeks within the month where weeks
 451      * start on a fixed day-of-week, such as Monday.
 452      * This field is typically used with {@link WeekFields#dayOfWeek()}.
 453      * &lt;p&gt;
 454      * Week one (1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
 455      * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the month.
 456      * Thus, week one may start up to {@code minDays} days before the start of the month.
 457      * If the first week starts after the start of the month then the period before is week zero (0).
 458      * &lt;p&gt;
 459      * For example:&lt;br&gt;
 460      * - if the 1st day of the month is a Monday, week one starts on the 1st and there is no week zero&lt;br&gt;
 461      * - if the 2nd day of the month is a Monday, week one starts on the 2nd and the 1st is in week zero&lt;br&gt;
 462      * - if the 4th day of the month is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero&lt;br&gt;
 463      * - if the 5th day of the month is a Monday, week two starts on the 5th and the 1st to 4th is in week one&lt;br&gt;
 464      * &lt;p&gt;
 465      * This field can be used with any calendar system.
 466      * &lt;p&gt;
 467      * In the resolving phase of parsing, a date can be created from a year,
 468      * week-of-month, month-of-year and day-of-week.
 469      * &lt;p&gt;
 470      * In {@linkplain ResolverStyle#STRICT strict mode}, all four fields are
 471      * validated against their range of valid values. The week-of-month field
 472      * is validated to ensure that the resulting month is the month requested.
 473      * &lt;p&gt;
 474      * In {@linkplain ResolverStyle#SMART smart mode}, all four fields are
 475      * validated against their range of valid values. The week-of-month field
 476      * is validated from 0 to 6, meaning that the resulting date can be in a
 477      * different month to that specified.
 478      * &lt;p&gt;
 479      * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
 480      * are validated against the range of valid values. The resulting date is calculated
 481      * equivalent to the following four stage approach.
 482      * First, create a date on the first day of the first week of January in the requested year.
 483      * Then take the month-of-year, subtract one, and add the amount in months to the date.
 484      * Then take the week-of-month, subtract one, and add the amount in weeks to the date.
 485      * Finally, adjust to the correct day-of-week within the localized week.
 486      *
 487      * @return a field providing access to the week-of-month, not null
 488      */
 489     public TemporalField weekOfMonth() {
 490         return weekOfMonth;
 491     }
 492 
 493     /**
 494      * Returns a field to access the week of year based on this {@code WeekFields}.
 495      * &lt;p&gt;
 496      * This represents the concept of the count of weeks within the year where weeks
 497      * start on a fixed day-of-week, such as Monday.
 498      * This field is typically used with {@link WeekFields#dayOfWeek()}.
 499      * &lt;p&gt;
 500      * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
 501      * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
 502      * Thus, week one may start up to {@code minDays} days before the start of the year.
 503      * If the first week starts after the start of the year then the period before is week zero (0).
 504      * &lt;p&gt;
 505      * For example:&lt;br&gt;
 506      * - if the 1st day of the year is a Monday, week one starts on the 1st and there is no week zero&lt;br&gt;
 507      * - if the 2nd day of the year is a Monday, week one starts on the 2nd and the 1st is in week zero&lt;br&gt;
 508      * - if the 4th day of the year is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero&lt;br&gt;
 509      * - if the 5th day of the year is a Monday, week two starts on the 5th and the 1st to 4th is in week one&lt;br&gt;
 510      * &lt;p&gt;
 511      * This field can be used with any calendar system.
 512      * &lt;p&gt;
 513      * In the resolving phase of parsing, a date can be created from a year,
 514      * week-of-year and day-of-week.
 515      * &lt;p&gt;
 516      * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
 517      * validated against their range of valid values. The week-of-year field
 518      * is validated to ensure that the resulting year is the year requested.
 519      * &lt;p&gt;
 520      * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
 521      * validated against their range of valid values. The week-of-year field
 522      * is validated from 0 to 54, meaning that the resulting date can be in a
 523      * different year to that specified.
 524      * &lt;p&gt;
 525      * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
 526      * are validated against the range of valid values. The resulting date is calculated
 527      * equivalent to the following three stage approach.
 528      * First, create a date on the first day of the first week in the requested year.
 529      * Then take the week-of-year, subtract one, and add the amount in weeks to the date.
 530      * Finally, adjust to the correct day-of-week within the localized week.
 531      *
 532      * @return a field providing access to the week-of-year, not null
 533      */
 534     public TemporalField weekOfYear() {
 535         return weekOfYear;
 536     }
 537 
 538     /**
 539      * Returns a field to access the week of a week-based-year based on this {@code WeekFields}.
 540      * &lt;p&gt;
 541      * This represents the concept of the count of weeks within the year where weeks
 542      * start on a fixed day-of-week, such as Monday and each week belongs to exactly one year.
 543      * This field is typically used with {@link WeekFields#dayOfWeek()} and
 544      * {@link WeekFields#weekBasedYear()}.
 545      * &lt;p&gt;
 546      * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
 547      * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
 548      * If the first week starts after the start of the year then the period before
 549      * is in the last week of the previous year.
 550      * &lt;p&gt;
 551      * For example:&lt;br&gt;
 552      * - if the 1st day of the year is a Monday, week one starts on the 1st&lt;br&gt;
 553      * - if the 2nd day of the year is a Monday, week one starts on the 2nd and
 554      *   the 1st is in the last week of the previous year&lt;br&gt;
 555      * - if the 4th day of the year is a Monday, week one starts on the 4th and
 556      *   the 1st to 3rd is in the last week of the previous year&lt;br&gt;
 557      * - if the 5th day of the year is a Monday, week two starts on the 5th and
 558      *   the 1st to 4th is in week one&lt;br&gt;
 559      * &lt;p&gt;
 560      * This field can be used with any calendar system.
 561      * &lt;p&gt;
 562      * In the resolving phase of parsing, a date can be created from a week-based-year,
 563      * week-of-year and day-of-week.
 564      * &lt;p&gt;
 565      * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
 566      * validated against their range of valid values. The week-of-year field
 567      * is validated to ensure that the resulting week-based-year is the
 568      * week-based-year requested.
 569      * &lt;p&gt;
 570      * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
 571      * validated against their range of valid values. The week-of-week-based-year field
 572      * is validated from 1 to 53, meaning that the resulting date can be in the
 573      * following week-based-year to that specified.
 574      * &lt;p&gt;
 575      * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
 576      * are validated against the range of valid values. The resulting date is calculated
 577      * equivalent to the following three stage approach.
 578      * First, create a date on the first day of the first week in the requested week-based-year.
 579      * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
 580      * Finally, adjust to the correct day-of-week within the localized week.
 581      *
 582      * @return a field providing access to the week-of-week-based-year, not null
 583      */
 584     public TemporalField weekOfWeekBasedYear() {
 585         return weekOfWeekBasedYear;
 586     }
 587 
 588     /**
 589      * Returns a field to access the year of a week-based-year based on this {@code WeekFields}.
 590      * &lt;p&gt;
 591      * This represents the concept of the year where weeks start on a fixed day-of-week,
 592      * such as Monday and each week belongs to exactly one year.
 593      * This field is typically used with {@link WeekFields#dayOfWeek()} and
 594      * {@link WeekFields#weekOfWeekBasedYear()}.
 595      * &lt;p&gt;
 596      * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
 597      * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
 598      * Thus, week one may start before the start of the year.
 599      * If the first week starts after the start of the year then the period before
 600      * is in the last week of the previous year.
 601      * &lt;p&gt;
 602      * This field can be used with any calendar system.
 603      * &lt;p&gt;
 604      * In the resolving phase of parsing, a date can be created from a week-based-year,
 605      * week-of-year and day-of-week.
 606      * &lt;p&gt;
 607      * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
 608      * validated against their range of valid values. The week-of-year field
 609      * is validated to ensure that the resulting week-based-year is the
 610      * week-based-year requested.
 611      * &lt;p&gt;
 612      * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
 613      * validated against their range of valid values. The week-of-week-based-year field
 614      * is validated from 1 to 53, meaning that the resulting date can be in the
 615      * following week-based-year to that specified.
 616      * &lt;p&gt;
 617      * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
 618      * are validated against the range of valid values. The resulting date is calculated
 619      * equivalent to the following three stage approach.
 620      * First, create a date on the first day of the first week in the requested week-based-year.
 621      * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
 622      * Finally, adjust to the correct day-of-week within the localized week.
 623      *
 624      * @return a field providing access to the week-based-year, not null
 625      */
 626     public TemporalField weekBasedYear() {
 627         return weekBasedYear;
 628     }
 629 
 630     //-----------------------------------------------------------------------
 631     /**
 632      * Checks if this {@code WeekFields} is equal to the specified object.
 633      * &lt;p&gt;
 634      * The comparison is based on the entire state of the rules, which is
 635      * the first day-of-week and minimal days.
 636      *
 637      * @param object  the other rules to compare to, null returns false
 638      * @return true if this is equal to the specified rules
 639      */
 640     @Override
 641     public boolean equals(Object object) {
 642         if (this == object) {
 643             return true;
 644         }
 645         if (object instanceof WeekFields) {
 646             return hashCode() == object.hashCode();
 647         }
 648         return false;
 649     }
 650 
 651     /**
 652      * A hash code for this {@code WeekFields}.
 653      *
 654      * @return a suitable hash code
 655      */
 656     @Override
 657     public int hashCode() {
 658         return firstDayOfWeek.ordinal() * 7 + minimalDays;
 659     }
 660 
 661     //-----------------------------------------------------------------------
 662     /**
 663      * A string representation of this {@code WeekFields} instance.
 664      *
 665      * @return the string representation, not null
 666      */
 667     @Override
 668     public String toString() {
 669         return &quot;WeekFields[&quot; + firstDayOfWeek + &#39;,&#39; + minimalDays + &#39;]&#39;;
 670     }
 671 
 672     //-----------------------------------------------------------------------
 673     /**
 674      * Field type that computes DayOfWeek, WeekOfMonth, and WeekOfYear
 675      * based on a WeekFields.
 676      * A separate Field instance is required for each different WeekFields;
 677      * combination of start of week and minimum number of days.
 678      * Constructors are provided to create fields for DayOfWeek, WeekOfMonth,
 679      * and WeekOfYear.
 680      */
 681     static class ComputedDayOfField implements TemporalField {
 682 
 683         /**
 684          * Returns a field to access the day of week,
 685          * computed based on a WeekFields.
 686          * &lt;p&gt;
 687          * The WeekDefintion of the first day of the week is used with
 688          * the ISO DAY_OF_WEEK field to compute week boundaries.
 689          */
 690         static ComputedDayOfField ofDayOfWeekField(WeekFields weekDef) {
 691             return new ComputedDayOfField(&quot;DayOfWeek&quot;, weekDef, DAYS, WEEKS, DAY_OF_WEEK_RANGE);
 692         }
 693 
 694         /**
 695          * Returns a field to access the week of month,
 696          * computed based on a WeekFields.
 697          * @see WeekFields#weekOfMonth()
 698          */
 699         static ComputedDayOfField ofWeekOfMonthField(WeekFields weekDef) {
 700             return new ComputedDayOfField(&quot;WeekOfMonth&quot;, weekDef, WEEKS, MONTHS, WEEK_OF_MONTH_RANGE);
 701         }
 702 
 703         /**
 704          * Returns a field to access the week of year,
 705          * computed based on a WeekFields.
 706          * @see WeekFields#weekOfYear()
 707          */
 708         static ComputedDayOfField ofWeekOfYearField(WeekFields weekDef) {
 709             return new ComputedDayOfField(&quot;WeekOfYear&quot;, weekDef, WEEKS, YEARS, WEEK_OF_YEAR_RANGE);
 710         }
 711 
 712         /**
 713          * Returns a field to access the week of week-based-year,
 714          * computed based on a WeekFields.
 715          * @see WeekFields#weekOfWeekBasedYear()
 716          */
 717         static ComputedDayOfField ofWeekOfWeekBasedYearField(WeekFields weekDef) {
 718             return new ComputedDayOfField(&quot;WeekOfWeekBasedYear&quot;, weekDef, WEEKS, IsoFields.WEEK_BASED_YEARS, WEEK_OF_WEEK_BASED_YEAR_RANGE);
 719         }
 720 
 721         /**
 722          * Returns a field to access the week of week-based-year,
 723          * computed based on a WeekFields.
 724          * @see WeekFields#weekBasedYear()
 725          */
 726         static ComputedDayOfField ofWeekBasedYearField(WeekFields weekDef) {
 727             return new ComputedDayOfField(&quot;WeekBasedYear&quot;, weekDef, IsoFields.WEEK_BASED_YEARS, FOREVER, ChronoField.YEAR.range());
 728         }
 729 
 730         /**
 731          * Return a new week-based-year date of the Chronology, year, week-of-year,
 732          * and dow of week.
 733          * @param chrono The chronology of the new date
 734          * @param yowby the year of the week-based-year
 735          * @param wowby the week of the week-based-year
 736          * @param dow the day of the week
 737          * @return a ChronoLocalDate for the requested year, week of year, and day of week
 738          */
 739         private ChronoLocalDate ofWeekBasedYear(Chronology chrono,
 740                 int yowby, int wowby, int dow) {
 741             ChronoLocalDate date = chrono.date(yowby, 1, 1);
 742             int ldow = localizedDayOfWeek(date);
 743             int offset = startOfWeekOffset(1, ldow);
 744 
 745             // Clamp the week of year to keep it in the same year
 746             int yearLen = date.lengthOfYear();
 747             int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());
 748             wowby = Math.min(wowby, newYearWeek - 1);
 749 
 750             int days = -offset + (dow - 1) + (wowby - 1) * 7;
 751             return date.plus(days, DAYS);
 752         }
 753 
 754         private final String name;
 755         private final WeekFields weekDef;
 756         private final TemporalUnit baseUnit;
 757         private final TemporalUnit rangeUnit;
 758         private final ValueRange range;
 759 
 760         private ComputedDayOfField(String name, WeekFields weekDef, TemporalUnit baseUnit, TemporalUnit rangeUnit, ValueRange range) {
 761             this.name = name;
 762             this.weekDef = weekDef;
 763             this.baseUnit = baseUnit;
 764             this.rangeUnit = rangeUnit;
 765             this.range = range;
 766         }
 767 
 768         private static final ValueRange DAY_OF_WEEK_RANGE = ValueRange.of(1, 7);
 769         private static final ValueRange WEEK_OF_MONTH_RANGE = ValueRange.of(0, 1, 4, 6);
 770         private static final ValueRange WEEK_OF_YEAR_RANGE = ValueRange.of(0, 1, 52, 54);
 771         private static final ValueRange WEEK_OF_WEEK_BASED_YEAR_RANGE = ValueRange.of(1, 52, 53);
 772 
 773         @Override
 774         public long getFrom(TemporalAccessor temporal) {
 775             if (rangeUnit == WEEKS) {  // day-of-week
 776                 return localizedDayOfWeek(temporal);
 777             } else if (rangeUnit == MONTHS) {  // week-of-month
 778                 return localizedWeekOfMonth(temporal);
 779             } else if (rangeUnit == YEARS) {  // week-of-year
 780                 return localizedWeekOfYear(temporal);
 781             } else if (rangeUnit == WEEK_BASED_YEARS) {
 782                 return localizedWeekOfWeekBasedYear(temporal);
 783             } else if (rangeUnit == FOREVER) {
 784                 return localizedWeekBasedYear(temporal);
 785             } else {
 786                 throw new IllegalStateException(&quot;unreachable, rangeUnit: &quot; + rangeUnit + &quot;, this: &quot; + this);
 787             }
 788         }
 789 
 790         private int localizedDayOfWeek(TemporalAccessor temporal) {
 791             int sow = weekDef.getFirstDayOfWeek().getValue();
 792             int isoDow = temporal.get(DAY_OF_WEEK);
 793             return Math.floorMod(isoDow - sow, 7) + 1;
 794         }
 795 
 796         private int localizedDayOfWeek(int isoDow) {
 797             int sow = weekDef.getFirstDayOfWeek().getValue();
 798             return Math.floorMod(isoDow - sow, 7) + 1;
 799         }
 800 
 801         private long localizedWeekOfMonth(TemporalAccessor temporal) {
 802             int dow = localizedDayOfWeek(temporal);
 803             int dom = temporal.get(DAY_OF_MONTH);
 804             int offset = startOfWeekOffset(dom, dow);
 805             return computeWeek(offset, dom);
 806         }
 807 
 808         private long localizedWeekOfYear(TemporalAccessor temporal) {
 809             int dow = localizedDayOfWeek(temporal);
 810             int doy = temporal.get(DAY_OF_YEAR);
 811             int offset = startOfWeekOffset(doy, dow);
 812             return computeWeek(offset, doy);
 813         }
 814 
 815         /**
 816          * Returns the year of week-based-year for the temporal.
 817          * The year can be the previous year, the current year, or the next year.
 818          * @param temporal a date of any chronology, not null
 819          * @return the year of week-based-year for the date
 820          */
 821         private int localizedWeekBasedYear(TemporalAccessor temporal) {
 822             int dow = localizedDayOfWeek(temporal);
 823             int year = temporal.get(YEAR);
 824             int doy = temporal.get(DAY_OF_YEAR);
 825             int offset = startOfWeekOffset(doy, dow);
 826             int week = computeWeek(offset, doy);
 827             if (week == 0) {
 828                 // Day is in end of week of previous year; return the previous year
 829                 return year - 1;
 830             } else {
 831                 // If getting close to end of year, use higher precision logic
 832                 // Check if date of year is in partial week associated with next year
 833                 ValueRange dayRange = temporal.range(DAY_OF_YEAR);
 834                 int yearLen = (int)dayRange.getMaximum();
 835                 int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());
 836                 if (week &gt;= newYearWeek) {
 837                     return year + 1;
 838                 }
 839             }
 840             return year;
 841         }
 842 
 843         /**
 844          * Returns the week of week-based-year for the temporal.
 845          * The week can be part of the previous year, the current year,
 846          * or the next year depending on the week start and minimum number
 847          * of days.
 848          * @param temporal  a date of any chronology
 849          * @return the week of the year
 850          * @see #localizedWeekBasedYear(java.time.temporal.TemporalAccessor)
 851          */
 852         private int localizedWeekOfWeekBasedYear(TemporalAccessor temporal) {
 853             int dow = localizedDayOfWeek(temporal);
 854             int doy = temporal.get(DAY_OF_YEAR);
 855             int offset = startOfWeekOffset(doy, dow);
 856             int week = computeWeek(offset, doy);
 857             if (week == 0) {
 858                 // Day is in end of week of previous year
 859                 // Recompute from the last day of the previous year
 860                 ChronoLocalDate date = Chronology.from(temporal).date(temporal);
 861                 date = date.minus(doy, DAYS);   // Back down into previous year
 862                 return localizedWeekOfWeekBasedYear(date);
 863             } else if (week &gt; 50) {
 864                 // If getting close to end of year, use higher precision logic
 865                 // Check if date of year is in partial week associated with next year
 866                 ValueRange dayRange = temporal.range(DAY_OF_YEAR);
 867                 int yearLen = (int)dayRange.getMaximum();
 868                 int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());
 869                 if (week &gt;= newYearWeek) {
 870                     // Overlaps with week of following year; reduce to week in following year
 871                     week = week - newYearWeek + 1;
 872                 }
 873             }
 874             return week;
 875         }
 876 
 877         /**
 878          * Returns an offset to align week start with a day of month or day of year.
 879          *
 880          * @param day  the day; 1 through infinity
 881          * @param dow  the day of the week of that day; 1 through 7
 882          * @return  an offset in days to align a day with the start of the first &#39;full&#39; week
 883          */
 884         private int startOfWeekOffset(int day, int dow) {
 885             // offset of first day corresponding to the day of week in first 7 days (zero origin)
 886             int weekStart = Math.floorMod(day - dow, 7);
 887             int offset = -weekStart;
 888             if (weekStart + 1 &gt; weekDef.getMinimalDaysInFirstWeek()) {
 889                 // The previous week has the minimum days in the current month to be a &#39;week&#39;
 890                 offset = 7 - weekStart;
 891             }
 892             return offset;
 893         }
 894 
 895         /**
 896          * Returns the week number computed from the reference day and reference dayOfWeek.
 897          *
 898          * @param offset the offset to align a date with the start of week
 899          *     from {@link #startOfWeekOffset}.
 900          * @param day  the day for which to compute the week number
 901          * @return the week number where zero is used for a partial week and 1 for the first full week
 902          */
 903         private int computeWeek(int offset, int day) {
 904             return ((7 + offset + (day - 1)) / 7);
 905         }
 906 
 907         @SuppressWarnings(&quot;unchecked&quot;)
 908         @Override
 909         public &lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue) {
 910             // Check the new value and get the old value of the field
 911             int newVal = range.checkValidIntValue(newValue, this);  // lenient check range
 912             int currentVal = temporal.get(this);
 913             if (newVal == currentVal) {
 914                 return temporal;
 915             }
 916 
 917             if (rangeUnit == FOREVER) {     // replace year of WeekBasedYear
 918                 // Create a new date object with the same chronology,
 919                 // the desired year and the same week and dow.
 920                 int idow = temporal.get(weekDef.dayOfWeek);
 921                 int wowby = temporal.get(weekDef.weekOfWeekBasedYear);
 922                 return (R) ofWeekBasedYear(Chronology.from(temporal), (int)newValue, wowby, idow);
 923             } else {
 924                 // Compute the difference and add that using the base unit of the field
 925                 return (R) temporal.plus(newVal - currentVal, baseUnit);
 926             }
 927         }
 928 
 929         @Override
 930         public ChronoLocalDate resolve(
 931                 Map&lt;TemporalField, Long&gt; fieldValues, TemporalAccessor partialTemporal, ResolverStyle resolverStyle) {
 932             final long value = fieldValues.get(this);
 933             final int newValue = Math.toIntExact(value);  // broad limit makes overflow checking lighter
 934             // first convert localized day-of-week to ISO day-of-week
 935             // doing this first handles case where both ISO and localized were parsed and might mismatch
 936             // day-of-week is always strict as two different day-of-week values makes lenient complex
 937             if (rangeUnit == WEEKS) {  // day-of-week
 938                 final int checkedValue = range.checkValidIntValue(value, this);  // no leniency as too complex
 939                 final int startDow = weekDef.getFirstDayOfWeek().getValue();
 940                 long isoDow = Math.floorMod((startDow - 1) + (checkedValue - 1), 7) + 1;
 941                 fieldValues.remove(this);
 942                 fieldValues.put(DAY_OF_WEEK, isoDow);
 943                 return null;
 944             }
 945 
 946             // can only build date if ISO day-of-week is present
 947             if (fieldValues.containsKey(DAY_OF_WEEK) == false) {
 948                 return null;
 949             }
 950             int isoDow = DAY_OF_WEEK.checkValidIntValue(fieldValues.get(DAY_OF_WEEK));
 951             int dow = localizedDayOfWeek(isoDow);
 952 
 953             // build date
 954             Chronology chrono = Chronology.from(partialTemporal);
 955             if (fieldValues.containsKey(YEAR)) {
 956                 int year = YEAR.checkValidIntValue(fieldValues.get(YEAR));  // validate
 957                 if (rangeUnit == MONTHS &amp;&amp; fieldValues.containsKey(MONTH_OF_YEAR)) {  // week-of-month
 958                     long month = fieldValues.get(MONTH_OF_YEAR);  // not validated yet
 959                     return resolveWoM(fieldValues, chrono, year, month, newValue, dow, resolverStyle);
 960                 }
 961                 if (rangeUnit == YEARS) {  // week-of-year
 962                     return resolveWoY(fieldValues, chrono, year, newValue, dow, resolverStyle);
 963                 }
 964             } else if ((rangeUnit == WEEK_BASED_YEARS || rangeUnit == FOREVER) &amp;&amp;
 965                     fieldValues.containsKey(weekDef.weekBasedYear) &amp;&amp;
 966                     fieldValues.containsKey(weekDef.weekOfWeekBasedYear)) { // week-of-week-based-year and year-of-week-based-year
 967                 return resolveWBY(fieldValues, chrono, dow, resolverStyle);
 968             }
 969             return null;
 970         }
 971 
 972         private ChronoLocalDate resolveWoM(
 973                 Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int year, long month, long wom, int localDow, ResolverStyle resolverStyle) {
 974             ChronoLocalDate date;
 975             if (resolverStyle == ResolverStyle.LENIENT) {
 976                 date = chrono.date(year, 1, 1).plus(Math.subtractExact(month, 1), MONTHS);
 977                 long weeks = Math.subtractExact(wom, localizedWeekOfMonth(date));
 978                 int days = localDow - localizedDayOfWeek(date);  // safe from overflow
 979                 date = date.plus(Math.addExact(Math.multiplyExact(weeks, 7), days), DAYS);
 980             } else {
 981                 int monthValid = MONTH_OF_YEAR.checkValidIntValue(month);  // validate
 982                 date = chrono.date(year, monthValid, 1);
 983                 int womInt = range.checkValidIntValue(wom, this);  // validate
 984                 int weeks = (int) (womInt - localizedWeekOfMonth(date));  // safe from overflow
 985                 int days = localDow - localizedDayOfWeek(date);  // safe from overflow
 986                 date = date.plus(weeks * 7 + days, DAYS);
 987                 if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.getLong(MONTH_OF_YEAR) != month) {
 988                     throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different month&quot;);
 989                 }
 990             }
 991             fieldValues.remove(this);
 992             fieldValues.remove(YEAR);
 993             fieldValues.remove(MONTH_OF_YEAR);
 994             fieldValues.remove(DAY_OF_WEEK);
 995             return date;
 996         }
 997 
 998         private ChronoLocalDate resolveWoY(
 999                 Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int year, long woy, int localDow, ResolverStyle resolverStyle) {
1000             ChronoLocalDate date = chrono.date(year, 1, 1);
1001             if (resolverStyle == ResolverStyle.LENIENT) {
1002                 long weeks = Math.subtractExact(woy, localizedWeekOfYear(date));
1003                 int days = localDow - localizedDayOfWeek(date);  // safe from overflow
1004                 date = date.plus(Math.addExact(Math.multiplyExact(weeks, 7), days), DAYS);
1005             } else {
1006                 int womInt = range.checkValidIntValue(woy, this);  // validate
1007                 int weeks = (int) (womInt - localizedWeekOfYear(date));  // safe from overflow
1008                 int days = localDow - localizedDayOfWeek(date);  // safe from overflow
1009                 date = date.plus(weeks * 7 + days, DAYS);
1010                 if (resolverStyle == ResolverStyle.STRICT &amp;&amp; date.getLong(YEAR) != year) {
1011                     throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different year&quot;);
1012                 }
1013             }
1014             fieldValues.remove(this);
1015             fieldValues.remove(YEAR);
1016             fieldValues.remove(DAY_OF_WEEK);
1017             return date;
1018         }
1019 
1020         private ChronoLocalDate resolveWBY(
1021                 Map&lt;TemporalField, Long&gt; fieldValues, Chronology chrono, int localDow, ResolverStyle resolverStyle) {
1022             int yowby = weekDef.weekBasedYear.range().checkValidIntValue(
1023                     fieldValues.get(weekDef.weekBasedYear), weekDef.weekBasedYear);
1024             ChronoLocalDate date;
1025             if (resolverStyle == ResolverStyle.LENIENT) {
1026                 date = ofWeekBasedYear(chrono, yowby, 1, localDow);
1027                 long wowby = fieldValues.get(weekDef.weekOfWeekBasedYear);
1028                 long weeks = Math.subtractExact(wowby, 1);
1029                 date = date.plus(weeks, WEEKS);
1030             } else {
1031                 int wowby = weekDef.weekOfWeekBasedYear.range().checkValidIntValue(
1032                         fieldValues.get(weekDef.weekOfWeekBasedYear), weekDef.weekOfWeekBasedYear);  // validate
1033                 date = ofWeekBasedYear(chrono, yowby, wowby, localDow);
1034                 if (resolverStyle == ResolverStyle.STRICT &amp;&amp; localizedWeekBasedYear(date) != yowby) {
1035                     throw new DateTimeException(&quot;Strict mode rejected resolved date as it is in a different week-based-year&quot;);
1036                 }
1037             }
1038             fieldValues.remove(this);
1039             fieldValues.remove(weekDef.weekBasedYear);
1040             fieldValues.remove(weekDef.weekOfWeekBasedYear);
1041             fieldValues.remove(DAY_OF_WEEK);
1042             return date;
1043         }
1044 
1045         //-----------------------------------------------------------------------
1046         @Override
1047         public String getDisplayName(Locale locale) {
1048             Objects.requireNonNull(locale, &quot;locale&quot;);
1049             if (rangeUnit == YEARS) {  // only have values for week-of-year
1050                 LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased()
1051                         .getLocaleResources(
1052                             CalendarDataUtility.findRegionOverride(locale));
1053                 ResourceBundle rb = lr.getJavaTimeFormatData();
1054                 return rb.containsKey(&quot;field.week&quot;) ? rb.getString(&quot;field.week&quot;) : name;
1055             }
1056             return name;
1057         }
1058 
1059         @Override
1060         public TemporalUnit getBaseUnit() {
1061             return baseUnit;
1062         }
1063 
1064         @Override
1065         public TemporalUnit getRangeUnit() {
1066             return rangeUnit;
1067         }
1068 
1069         @Override
1070         public boolean isDateBased() {
1071             return true;
1072         }
1073 
1074         @Override
1075         public boolean isTimeBased() {
1076             return false;
1077         }
1078 
1079         @Override
1080         public ValueRange range() {
1081             return range;
1082         }
1083 
1084         //-----------------------------------------------------------------------
1085         @Override
1086         public boolean isSupportedBy(TemporalAccessor temporal) {
1087             if (temporal.isSupported(DAY_OF_WEEK)) {
1088                 if (rangeUnit == WEEKS) {  // day-of-week
1089                     return true;
1090                 } else if (rangeUnit == MONTHS) {  // week-of-month
1091                     return temporal.isSupported(DAY_OF_MONTH);
1092                 } else if (rangeUnit == YEARS) {  // week-of-year
1093                     return temporal.isSupported(DAY_OF_YEAR);
1094                 } else if (rangeUnit == WEEK_BASED_YEARS) {
1095                     return temporal.isSupported(DAY_OF_YEAR);
1096                 } else if (rangeUnit == FOREVER) {
1097                     return temporal.isSupported(YEAR);
1098                 }
1099             }
1100             return false;
1101         }
1102 
1103         @Override
1104         public ValueRange rangeRefinedBy(TemporalAccessor temporal) {
1105             if (rangeUnit == ChronoUnit.WEEKS) {  // day-of-week
1106                 return range;
1107             } else if (rangeUnit == MONTHS) {  // week-of-month
1108                 return rangeByWeek(temporal, DAY_OF_MONTH);
1109             } else if (rangeUnit == YEARS) {  // week-of-year
1110                 return rangeByWeek(temporal, DAY_OF_YEAR);
1111             } else if (rangeUnit == WEEK_BASED_YEARS) {
1112                 return rangeWeekOfWeekBasedYear(temporal);
1113             } else if (rangeUnit == FOREVER) {
1114                 return YEAR.range();
1115             } else {
1116                 throw new IllegalStateException(&quot;unreachable, rangeUnit: &quot; + rangeUnit + &quot;, this: &quot; + this);
1117             }
1118         }
1119 
1120         /**
1121          * Map the field range to a week range
1122          * @param temporal the temporal
1123          * @param field the field to get the range of
1124          * @return the ValueRange with the range adjusted to weeks.
1125          */
1126         private ValueRange rangeByWeek(TemporalAccessor temporal, TemporalField field) {
1127             int dow = localizedDayOfWeek(temporal);
1128             int offset = startOfWeekOffset(temporal.get(field), dow);
1129             ValueRange fieldRange = temporal.range(field);
1130             return ValueRange.of(computeWeek(offset, (int) fieldRange.getMinimum()),
1131                     computeWeek(offset, (int) fieldRange.getMaximum()));
1132         }
1133 
1134         /**
1135          * Map the field range to a week range of a week year.
1136          * @param temporal  the temporal
1137          * @return the ValueRange with the range adjusted to weeks.
1138          */
1139         private ValueRange rangeWeekOfWeekBasedYear(TemporalAccessor temporal) {
1140             if (!temporal.isSupported(DAY_OF_YEAR)) {
1141                 return WEEK_OF_YEAR_RANGE;
1142             }
1143             int dow = localizedDayOfWeek(temporal);
1144             int doy = temporal.get(DAY_OF_YEAR);
1145             int offset = startOfWeekOffset(doy, dow);
1146             int week = computeWeek(offset, doy);
1147             if (week == 0) {
1148                 // Day is in end of week of previous year
1149                 // Recompute from the last day of the previous year
1150                 ChronoLocalDate date = Chronology.from(temporal).date(temporal);
1151                 date = date.minus(doy + 7, DAYS);   // Back down into previous year
1152                 return rangeWeekOfWeekBasedYear(date);
1153             }
1154             // Check if day of year is in partial week associated with next year
1155             ValueRange dayRange = temporal.range(DAY_OF_YEAR);
1156             int yearLen = (int)dayRange.getMaximum();
1157             int newYearWeek = computeWeek(offset, yearLen + weekDef.getMinimalDaysInFirstWeek());
1158 
1159             if (week &gt;= newYearWeek) {
1160                 // Overlaps with weeks of following year; recompute from a week in following year
1161                 ChronoLocalDate date = Chronology.from(temporal).date(temporal);
1162                 date = date.plus(yearLen - doy + 1 + 7, ChronoUnit.DAYS);
1163                 return rangeWeekOfWeekBasedYear(date);
1164             }
1165             return ValueRange.of(1, newYearWeek-1);
1166         }
1167 
1168         //-----------------------------------------------------------------------
1169         @Override
1170         public String toString() {
1171             return name + &quot;[&quot; + weekDef.toString() + &quot;]&quot;;
1172         }
1173     }
1174 }
    </pre>
  </body>
</html>
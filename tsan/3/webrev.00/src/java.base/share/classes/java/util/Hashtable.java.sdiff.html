<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Hashtable.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="HashSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="IdentityHashMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Hashtable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 154      */
 155     private int threshold;
 156 
 157     /**
 158      * The load factor for the hashtable.
 159      *
 160      * @serial
 161      */
 162     private float loadFactor;
 163 
 164     /**
 165      * The number of times this Hashtable has been structurally modified
 166      * Structural modifications are those that change the number of entries in
 167      * the Hashtable or otherwise modify its internal structure (e.g.,
 168      * rehash).  This field is used to make iterators on Collection-views of
 169      * the Hashtable fail-fast.  (See ConcurrentModificationException).
 170      */
 171     private transient int modCount = 0;
 172 
 173     /** use serialVersionUID from JDK 1.0.2 for interoperability */

 174     private static final long serialVersionUID = 1421746759512286392L;
 175 
 176     /**
 177      * Constructs a new, empty hashtable with the specified initial
 178      * capacity and the specified load factor.
 179      *
 180      * @param      initialCapacity   the initial capacity of the hashtable.
 181      * @param      loadFactor        the load factor of the hashtable.
<span class="line-modified"> 182      * @exception  IllegalArgumentException  if the initial capacity is less</span>
 183      *             than zero, or if the load factor is nonpositive.
 184      */
 185     public Hashtable(int initialCapacity, float loadFactor) {
 186         if (initialCapacity &lt; 0)
 187             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 188                                                initialCapacity);
 189         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
 190             throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);
 191 
 192         if (initialCapacity==0)
 193             initialCapacity = 1;
 194         this.loadFactor = loadFactor;
 195         table = new Entry&lt;?,?&gt;[initialCapacity];
 196         threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
 197     }
 198 
 199     /**
 200      * Constructs a new, empty hashtable with the specified initial capacity
 201      * and default load factor (0.75).
 202      *
 203      * @param     initialCapacity   the initial capacity of the hashtable.
<span class="line-modified"> 204      * @exception IllegalArgumentException if the initial capacity is less</span>
 205      *              than zero.
 206      */
 207     public Hashtable(int initialCapacity) {
 208         this(initialCapacity, 0.75f);
 209     }
 210 
 211     /**
 212      * Constructs a new, empty hashtable with a default initial capacity (11)
 213      * and load factor (0.75).
 214      */
 215     public Hashtable() {
 216         this(11, 0.75f);
 217     }
 218 
 219     /**
 220      * Constructs a new hashtable with the same mappings as the given
 221      * Map.  The hashtable is created with an initial capacity sufficient to
 222      * hold the mappings in the given Map and a default load factor (0.75).
 223      *
 224      * @param t the map whose mappings are to be placed in this map.
</pre>
<hr />
<pre>
 286      * @see     Map
 287      */
 288     public synchronized Enumeration&lt;V&gt; elements() {
 289         return this.&lt;V&gt;getEnumeration(VALUES);
 290     }
 291 
 292     /**
 293      * Tests if some key maps into the specified value in this hashtable.
 294      * This operation is more expensive than the {@link #containsKey
 295      * containsKey} method.
 296      *
 297      * &lt;p&gt;Note that this method is identical in functionality to
 298      * {@link #containsValue containsValue}, (which is part of the
 299      * {@link Map} interface in the collections framework).
 300      *
 301      * @param      value   a value to search for
 302      * @return     {@code true} if and only if some key maps to the
 303      *             {@code value} argument in this hashtable as
 304      *             determined by the {@code equals} method;
 305      *             {@code false} otherwise.
<span class="line-modified"> 306      * @exception  NullPointerException  if the value is {@code null}</span>
 307      */
 308     public synchronized boolean contains(Object value) {
 309         if (value == null) {
 310             throw new NullPointerException();
 311         }
 312 
 313         Entry&lt;?,?&gt; tab[] = table;
 314         for (int i = tab.length ; i-- &gt; 0 ;) {
 315             for (Entry&lt;?,?&gt; e = tab[i] ; e != null ; e = e.next) {
 316                 if (e.value.equals(value)) {
 317                     return true;
 318                 }
 319             }
 320         }
 321         return false;
 322     }
 323 
 324     /**
 325      * Returns true if this hashtable maps one or more keys to this value.
 326      *
</pre>
<hr />
<pre>
 447         // Creates the new entry.
 448         @SuppressWarnings(&quot;unchecked&quot;)
 449         Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];
 450         tab[index] = new Entry&lt;&gt;(hash, key, value, e);
 451         count++;
 452         modCount++;
 453     }
 454 
 455     /**
 456      * Maps the specified {@code key} to the specified
 457      * {@code value} in this hashtable. Neither the key nor the
 458      * value can be {@code null}. &lt;p&gt;
 459      *
 460      * The value can be retrieved by calling the {@code get} method
 461      * with a key that is equal to the original key.
 462      *
 463      * @param      key     the hashtable key
 464      * @param      value   the value
 465      * @return     the previous value of the specified key in this hashtable,
 466      *             or {@code null} if it did not have one
<span class="line-modified"> 467      * @exception  NullPointerException  if the key or value is</span>
 468      *               {@code null}
 469      * @see     Object#equals(Object)
 470      * @see     #get(Object)
 471      */
 472     public synchronized V put(K key, V value) {
 473         // Make sure the value is not null
 474         if (value == null) {
 475             throw new NullPointerException();
 476         }
 477 
 478         // Makes sure the key is not already in the hashtable.
 479         Entry&lt;?,?&gt; tab[] = table;
 480         int hash = key.hashCode();
 481         int index = (hash &amp; 0x7FFFFFFF) % tab.length;
 482         @SuppressWarnings(&quot;unchecked&quot;)
 483         Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
 484         for(; entry != null ; entry = entry.next) {
 485             if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
 486                 V old = entry.value;
 487                 entry.value = value;
</pre>
<hr />
<pre>
1184             }
1185         }
1186 
1187         if (value != null) {
1188             addEntry(hash, key, value, index);
1189         }
1190 
1191         return value;
1192     }
1193 
1194     /**
1195      * Save the state of the Hashtable to a stream (i.e., serialize it).
1196      *
1197      * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the Hashtable (the length of the
1198      *             bucket array) is emitted (int), followed by the
1199      *             &lt;i&gt;size&lt;/i&gt; of the Hashtable (the number of key-value
1200      *             mappings), followed by the key (Object) and value (Object)
1201      *             for each key-value mapping represented by the Hashtable
1202      *             The key-value mappings are emitted in no particular order.
1203      */

1204     private void writeObject(java.io.ObjectOutputStream s)
1205             throws IOException {
1206         writeHashtable(s);
1207     }
1208 
1209     /**
1210      * Perform serialization of the Hashtable to an ObjectOutputStream.
1211      * The Properties class overrides this method.
1212      */
1213     void writeHashtable(java.io.ObjectOutputStream s)
1214             throws IOException {
1215         Entry&lt;Object, Object&gt; entryStack = null;
1216 
1217         synchronized (this) {
1218             // Write out the threshold and loadFactor
1219             s.defaultWriteObject();
1220 
1221             // Write out the length and count of elements
1222             s.writeInt(table.length);
1223             s.writeInt(count);
</pre>
<hr />
<pre>
1237         while (entryStack != null) {
1238             s.writeObject(entryStack.key);
1239             s.writeObject(entryStack.value);
1240             entryStack = entryStack.next;
1241         }
1242     }
1243 
1244     /**
1245      * Called by Properties to write out a simulated threshold and loadfactor.
1246      */
1247     final void defaultWriteHashtable(java.io.ObjectOutputStream s, int length,
1248             float loadFactor) throws IOException {
1249         this.threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);
1250         this.loadFactor = loadFactor;
1251         s.defaultWriteObject();
1252     }
1253 
1254     /**
1255      * Reconstitute the Hashtable from a stream (i.e., deserialize it).
1256      */

1257     private void readObject(java.io.ObjectInputStream s)
1258             throws IOException, ClassNotFoundException {
1259         readHashtable(s);
1260     }
1261 
1262     /**
1263      * Perform deserialization of the Hashtable from an ObjectInputStream.
1264      * The Properties class overrides this method.
1265      */
1266     void readHashtable(java.io.ObjectInputStream s)
1267             throws IOException, ClassNotFoundException {
1268         // Read in the threshold and loadFactor
1269         s.defaultReadObject();
1270 
1271         // Validate loadFactor (ignore threshold - it will be re-computed)
1272         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
1273             throw new StreamCorruptedException(&quot;Illegal Load: &quot; + loadFactor);
1274 
1275         // Read the original length of the array and number of elements
1276         int origlength = s.readInt();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 154      */
 155     private int threshold;
 156 
 157     /**
 158      * The load factor for the hashtable.
 159      *
 160      * @serial
 161      */
 162     private float loadFactor;
 163 
 164     /**
 165      * The number of times this Hashtable has been structurally modified
 166      * Structural modifications are those that change the number of entries in
 167      * the Hashtable or otherwise modify its internal structure (e.g.,
 168      * rehash).  This field is used to make iterators on Collection-views of
 169      * the Hashtable fail-fast.  (See ConcurrentModificationException).
 170      */
 171     private transient int modCount = 0;
 172 
 173     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 174     @java.io.Serial</span>
 175     private static final long serialVersionUID = 1421746759512286392L;
 176 
 177     /**
 178      * Constructs a new, empty hashtable with the specified initial
 179      * capacity and the specified load factor.
 180      *
 181      * @param      initialCapacity   the initial capacity of the hashtable.
 182      * @param      loadFactor        the load factor of the hashtable.
<span class="line-modified"> 183      * @throws     IllegalArgumentException  if the initial capacity is less</span>
 184      *             than zero, or if the load factor is nonpositive.
 185      */
 186     public Hashtable(int initialCapacity, float loadFactor) {
 187         if (initialCapacity &lt; 0)
 188             throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
 189                                                initialCapacity);
 190         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
 191             throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);
 192 
 193         if (initialCapacity==0)
 194             initialCapacity = 1;
 195         this.loadFactor = loadFactor;
 196         table = new Entry&lt;?,?&gt;[initialCapacity];
 197         threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
 198     }
 199 
 200     /**
 201      * Constructs a new, empty hashtable with the specified initial capacity
 202      * and default load factor (0.75).
 203      *
 204      * @param     initialCapacity   the initial capacity of the hashtable.
<span class="line-modified"> 205      * @throws    IllegalArgumentException if the initial capacity is less</span>
 206      *              than zero.
 207      */
 208     public Hashtable(int initialCapacity) {
 209         this(initialCapacity, 0.75f);
 210     }
 211 
 212     /**
 213      * Constructs a new, empty hashtable with a default initial capacity (11)
 214      * and load factor (0.75).
 215      */
 216     public Hashtable() {
 217         this(11, 0.75f);
 218     }
 219 
 220     /**
 221      * Constructs a new hashtable with the same mappings as the given
 222      * Map.  The hashtable is created with an initial capacity sufficient to
 223      * hold the mappings in the given Map and a default load factor (0.75).
 224      *
 225      * @param t the map whose mappings are to be placed in this map.
</pre>
<hr />
<pre>
 287      * @see     Map
 288      */
 289     public synchronized Enumeration&lt;V&gt; elements() {
 290         return this.&lt;V&gt;getEnumeration(VALUES);
 291     }
 292 
 293     /**
 294      * Tests if some key maps into the specified value in this hashtable.
 295      * This operation is more expensive than the {@link #containsKey
 296      * containsKey} method.
 297      *
 298      * &lt;p&gt;Note that this method is identical in functionality to
 299      * {@link #containsValue containsValue}, (which is part of the
 300      * {@link Map} interface in the collections framework).
 301      *
 302      * @param      value   a value to search for
 303      * @return     {@code true} if and only if some key maps to the
 304      *             {@code value} argument in this hashtable as
 305      *             determined by the {@code equals} method;
 306      *             {@code false} otherwise.
<span class="line-modified"> 307      * @throws     NullPointerException  if the value is {@code null}</span>
 308      */
 309     public synchronized boolean contains(Object value) {
 310         if (value == null) {
 311             throw new NullPointerException();
 312         }
 313 
 314         Entry&lt;?,?&gt; tab[] = table;
 315         for (int i = tab.length ; i-- &gt; 0 ;) {
 316             for (Entry&lt;?,?&gt; e = tab[i] ; e != null ; e = e.next) {
 317                 if (e.value.equals(value)) {
 318                     return true;
 319                 }
 320             }
 321         }
 322         return false;
 323     }
 324 
 325     /**
 326      * Returns true if this hashtable maps one or more keys to this value.
 327      *
</pre>
<hr />
<pre>
 448         // Creates the new entry.
 449         @SuppressWarnings(&quot;unchecked&quot;)
 450         Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];
 451         tab[index] = new Entry&lt;&gt;(hash, key, value, e);
 452         count++;
 453         modCount++;
 454     }
 455 
 456     /**
 457      * Maps the specified {@code key} to the specified
 458      * {@code value} in this hashtable. Neither the key nor the
 459      * value can be {@code null}. &lt;p&gt;
 460      *
 461      * The value can be retrieved by calling the {@code get} method
 462      * with a key that is equal to the original key.
 463      *
 464      * @param      key     the hashtable key
 465      * @param      value   the value
 466      * @return     the previous value of the specified key in this hashtable,
 467      *             or {@code null} if it did not have one
<span class="line-modified"> 468      * @throws     NullPointerException  if the key or value is</span>
 469      *               {@code null}
 470      * @see     Object#equals(Object)
 471      * @see     #get(Object)
 472      */
 473     public synchronized V put(K key, V value) {
 474         // Make sure the value is not null
 475         if (value == null) {
 476             throw new NullPointerException();
 477         }
 478 
 479         // Makes sure the key is not already in the hashtable.
 480         Entry&lt;?,?&gt; tab[] = table;
 481         int hash = key.hashCode();
 482         int index = (hash &amp; 0x7FFFFFFF) % tab.length;
 483         @SuppressWarnings(&quot;unchecked&quot;)
 484         Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
 485         for(; entry != null ; entry = entry.next) {
 486             if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
 487                 V old = entry.value;
 488                 entry.value = value;
</pre>
<hr />
<pre>
1185             }
1186         }
1187 
1188         if (value != null) {
1189             addEntry(hash, key, value, index);
1190         }
1191 
1192         return value;
1193     }
1194 
1195     /**
1196      * Save the state of the Hashtable to a stream (i.e., serialize it).
1197      *
1198      * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the Hashtable (the length of the
1199      *             bucket array) is emitted (int), followed by the
1200      *             &lt;i&gt;size&lt;/i&gt; of the Hashtable (the number of key-value
1201      *             mappings), followed by the key (Object) and value (Object)
1202      *             for each key-value mapping represented by the Hashtable
1203      *             The key-value mappings are emitted in no particular order.
1204      */
<span class="line-added">1205     @java.io.Serial</span>
1206     private void writeObject(java.io.ObjectOutputStream s)
1207             throws IOException {
1208         writeHashtable(s);
1209     }
1210 
1211     /**
1212      * Perform serialization of the Hashtable to an ObjectOutputStream.
1213      * The Properties class overrides this method.
1214      */
1215     void writeHashtable(java.io.ObjectOutputStream s)
1216             throws IOException {
1217         Entry&lt;Object, Object&gt; entryStack = null;
1218 
1219         synchronized (this) {
1220             // Write out the threshold and loadFactor
1221             s.defaultWriteObject();
1222 
1223             // Write out the length and count of elements
1224             s.writeInt(table.length);
1225             s.writeInt(count);
</pre>
<hr />
<pre>
1239         while (entryStack != null) {
1240             s.writeObject(entryStack.key);
1241             s.writeObject(entryStack.value);
1242             entryStack = entryStack.next;
1243         }
1244     }
1245 
1246     /**
1247      * Called by Properties to write out a simulated threshold and loadfactor.
1248      */
1249     final void defaultWriteHashtable(java.io.ObjectOutputStream s, int length,
1250             float loadFactor) throws IOException {
1251         this.threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);
1252         this.loadFactor = loadFactor;
1253         s.defaultWriteObject();
1254     }
1255 
1256     /**
1257      * Reconstitute the Hashtable from a stream (i.e., deserialize it).
1258      */
<span class="line-added">1259     @java.io.Serial</span>
1260     private void readObject(java.io.ObjectInputStream s)
1261             throws IOException, ClassNotFoundException {
1262         readHashtable(s);
1263     }
1264 
1265     /**
1266      * Perform deserialization of the Hashtable from an ObjectInputStream.
1267      * The Properties class overrides this method.
1268      */
1269     void readHashtable(java.io.ObjectInputStream s)
1270             throws IOException, ClassNotFoundException {
1271         // Read in the threshold and loadFactor
1272         s.defaultReadObject();
1273 
1274         // Validate loadFactor (ignore threshold - it will be re-computed)
1275         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
1276             throw new StreamCorruptedException(&quot;Illegal Load: &quot; + loadFactor);
1277 
1278         // Read the original length of the array and number of elements
1279         int origlength = s.readInt();
</pre>
</td>
</tr>
</table>
<center><a href="HashSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="IdentityHashMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
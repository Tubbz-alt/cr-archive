<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/DataInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data input stream lets an application read primitive Java data
 30  * types from an underlying input stream in a machine-independent
 31  * way. An application uses a data output stream to write data that
 32  * can later be read by a data input stream.
 33  * &lt;p&gt;
 34  * DataInputStream is not necessarily safe for multithreaded access.
 35  * Thread safety is optional and is the responsibility of users of
 36  * methods in this class.
 37  *
 38  * @author  Arthur van Hoff
 39  * @see     java.io.DataOutputStream
 40  * @since   1.0
 41  */
<a name="2" id="anc2"></a><span class="line-modified"> 42 public class DataInputStream extends FilterInputStream implements DataInput {</span>

 43 
 44     /**
 45      * Creates a DataInputStream that uses the specified
 46      * underlying InputStream.
 47      *
 48      * @param  in   the specified input stream
 49      */
 50     public DataInputStream(InputStream in) {
 51         super(in);
 52     }
 53 
 54     /**
 55      * working arrays initialized on demand by readUTF
 56      */
 57     private byte bytearr[] = new byte[80];
 58     private char chararr[] = new char[80];
 59 
 60     /**
 61      * Reads some number of bytes from the contained input stream and
<a name="3" id="anc3"></a><span class="line-modified"> 62      * stores them into the buffer array {@code b}. The number of</span>
 63      * bytes actually read is returned as an integer. This method blocks
 64      * until input data is available, end of file is detected, or an
 65      * exception is thrown.
 66      *
<a name="4" id="anc4"></a><span class="line-modified"> 67      * &lt;p&gt;If {@code b} is null, a {@code NullPointerException} is</span>
<span class="line-modified"> 68      * thrown. If the length of {@code b} is zero, then no bytes are</span>
<span class="line-modified"> 69      * read and {@code 0} is returned; otherwise, there is an attempt</span>
 70      * to read at least one byte. If no byte is available because the
<a name="5" id="anc5"></a><span class="line-modified"> 71      * stream is at end of file, the value {@code -1} is returned;</span>
<span class="line-modified"> 72      * otherwise, at least one byte is read and stored into {@code b}.</span>
 73      *
<a name="6" id="anc6"></a><span class="line-modified"> 74      * &lt;p&gt;The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified"> 75      * next one into {@code b[1]}, and so on. The number of bytes read</span>
<span class="line-modified"> 76      * is, at most, equal to the length of {@code b}. Let {@code k}</span>
 77      * be the number of bytes actually read; these bytes will be stored in
<a name="7" id="anc7"></a><span class="line-modified"> 78      * elements {@code b[0]} through {@code b[k-1]}, leaving</span>
<span class="line-modified"> 79      * elements {@code b[k]} through {@code b[b.length-1]}</span>
 80      * unaffected.
 81      *
<a name="8" id="anc8"></a><span class="line-modified"> 82      * &lt;p&gt;The {@code read(b)} method has the same effect as:</span>
 83      * &lt;blockquote&gt;&lt;pre&gt;
 84      * read(b, 0, b.length)
 85      * &lt;/pre&gt;&lt;/blockquote&gt;
 86      *
 87      * @param      b   the buffer into which the data is read.
 88      * @return     the total number of bytes read into the buffer, or
<a name="9" id="anc9"></a><span class="line-modified"> 89      *             {@code -1} if there is no more data because the end</span>
 90      *             of the stream has been reached.
<a name="10" id="anc10"></a><span class="line-modified"> 91      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified"> 92      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified"> 93      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified"> 94      *             error occurs.</span>
 95      * @see        java.io.FilterInputStream#in
 96      * @see        java.io.InputStream#read(byte[], int, int)
 97      */
 98     public final int read(byte b[]) throws IOException {
 99         return in.read(b, 0, b.length);
100     }
101 
102     /**
<a name="11" id="anc11"></a><span class="line-modified">103      * Reads up to {@code len} bytes of data from the contained</span>
104      * input stream into an array of bytes.  An attempt is made to read
<a name="12" id="anc12"></a><span class="line-modified">105      * as many as {@code len} bytes, but a smaller number may be read,</span>
106      * possibly zero. The number of bytes actually read is returned as an
107      * integer.
108      *
109      * &lt;p&gt; This method blocks until input data is available, end of file is
110      * detected, or an exception is thrown.
111      *
<a name="13" id="anc13"></a><span class="line-modified">112      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">113      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
114      * least one byte. If no byte is available because the stream is at end of
<a name="14" id="anc14"></a><span class="line-modified">115      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">116      * byte is read and stored into {@code b}.</span>
117      *
<a name="15" id="anc15"></a><span class="line-modified">118      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">119      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">120      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
121      * bytes actually read; these bytes will be stored in elements
<a name="16" id="anc16"></a><span class="line-modified">122      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">123      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">124      * {@code b[off+len-1]} unaffected.</span>
125      *
<a name="17" id="anc17"></a><span class="line-modified">126      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">127      * {@code b[off]} and elements {@code b[off+len]} through</span>
<span class="line-modified">128      * {@code b[b.length-1]} are unaffected.</span>
129      *
130      * @param      b     the buffer into which the data is read.
<a name="18" id="anc18"></a><span class="line-modified">131      * @param      off the start offset in the destination array {@code b}</span>
132      * @param      len   the maximum number of bytes read.
133      * @return     the total number of bytes read into the buffer, or
<a name="19" id="anc19"></a><span class="line-modified">134      *             {@code -1} if there is no more data because the end</span>
135      *             of the stream has been reached.
<a name="20" id="anc20"></a><span class="line-modified">136      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">137      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">138      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">139      *             {@code b.length - off}</span>
<span class="line-modified">140      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">141      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">142      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified">143      *             error occurs.</span>
144      * @see        java.io.FilterInputStream#in
145      * @see        java.io.InputStream#read(byte[], int, int)
146      */
147     public final int read(byte b[], int off, int len) throws IOException {
148         return in.read(b, off, len);
149     }
150 
151     /**
152      * See the general contract of the {@code readFully}
153      * method of {@code DataInput}.
154      * &lt;p&gt;
155      * Bytes
156      * for this operation are read from the contained
157      * input stream.
158      *
159      * @param   b   the buffer into which the data is read.
160      * @throws  NullPointerException if {@code b} is {@code null}.
161      * @throws  EOFException  if this input stream reaches the end before
162      *          reading all the bytes.
163      * @throws  IOException   the stream has been closed and the contained
164      *          input stream does not support reading after close, or
165      *          another I/O error occurs.
166      * @see     java.io.FilterInputStream#in
167      */
168     public final void readFully(byte b[]) throws IOException {
169         readFully(b, 0, b.length);
170     }
171 
172     /**
173      * See the general contract of the {@code readFully}
174      * method of {@code DataInput}.
175      * &lt;p&gt;
176      * Bytes
177      * for this operation are read from the contained
178      * input stream.
179      *
180      * @param      b     the buffer into which the data is read.
181      * @param      off   the start offset in the data array {@code b}.
182      * @param      len   the number of bytes to read.
<a name="21" id="anc21"></a><span class="line-modified">183      * @throws     NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">184      * @throws     IndexOutOfBoundsException if {@code off} is negative,</span>
185      *             {@code len} is negative, or {@code len} is greater than
186      *             {@code b.length - off}.
<a name="22" id="anc22"></a><span class="line-modified">187      * @throws     EOFException  if this input stream reaches the end before</span>
188      *             reading all the bytes.
<a name="23" id="anc23"></a><span class="line-modified">189      * @throws     IOException   the stream has been closed and the contained</span>
190      *             input stream does not support reading after close, or
191      *             another I/O error occurs.
192      * @see        java.io.FilterInputStream#in
193      */
194     public final void readFully(byte b[], int off, int len) throws IOException {
195         if (len &lt; 0)
196             throw new IndexOutOfBoundsException();
197         int n = 0;
198         while (n &lt; len) {
199             int count = in.read(b, off + n, len - n);
200             if (count &lt; 0)
201                 throw new EOFException();
202             n += count;
203         }
204     }
205 
206     /**
<a name="24" id="anc24"></a><span class="line-modified">207      * See the general contract of the {@code skipBytes}</span>
<span class="line-modified">208      * method of {@code DataInput}.</span>
209      * &lt;p&gt;
210      * Bytes for this operation are read from the contained
211      * input stream.
212      *
213      * @param      n   the number of bytes to be skipped.
214      * @return     the actual number of bytes skipped.
<a name="25" id="anc25"></a><span class="line-modified">215      * @throws     IOException  if the contained input stream does not support</span>
216      *             seek, or the stream has been closed and
217      *             the contained input stream does not support
218      *             reading after close, or another I/O error occurs.
219      */
220     public final int skipBytes(int n) throws IOException {
221         int total = 0;
222         int cur = 0;
223 
224         while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) {
225             total += cur;
226         }
227 
228         return total;
229     }
230 
231     /**
<a name="26" id="anc26"></a><span class="line-modified">232      * See the general contract of the {@code readBoolean}</span>
<span class="line-modified">233      * method of {@code DataInput}.</span>
234      * &lt;p&gt;
235      * Bytes for this operation are read from the contained
236      * input stream.
237      *
<a name="27" id="anc27"></a><span class="line-modified">238      * @return     the {@code boolean} value read.</span>
<span class="line-modified">239      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">240      * @throws     IOException   the stream has been closed and the contained</span>
241      *             input stream does not support reading after close, or
242      *             another I/O error occurs.
243      * @see        java.io.FilterInputStream#in
244      */
245     public final boolean readBoolean() throws IOException {
246         int ch = in.read();
247         if (ch &lt; 0)
248             throw new EOFException();
249         return (ch != 0);
250     }
251 
252     /**
<a name="28" id="anc28"></a><span class="line-modified">253      * See the general contract of the {@code readByte}</span>
<span class="line-modified">254      * method of {@code DataInput}.</span>
255      * &lt;p&gt;
256      * Bytes
257      * for this operation are read from the contained
258      * input stream.
259      *
260      * @return     the next byte of this input stream as a signed 8-bit
<a name="29" id="anc29"></a><span class="line-modified">261      *             {@code byte}.</span>
<span class="line-modified">262      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">263      * @throws     IOException   the stream has been closed and the contained</span>
264      *             input stream does not support reading after close, or
265      *             another I/O error occurs.
266      * @see        java.io.FilterInputStream#in
267      */
268     public final byte readByte() throws IOException {
269         int ch = in.read();
270         if (ch &lt; 0)
271             throw new EOFException();
272         return (byte)(ch);
273     }
274 
275     /**
<a name="30" id="anc30"></a><span class="line-modified">276      * See the general contract of the {@code readUnsignedByte}</span>
<span class="line-modified">277      * method of {@code DataInput}.</span>
278      * &lt;p&gt;
279      * Bytes
280      * for this operation are read from the contained
281      * input stream.
282      *
283      * @return     the next byte of this input stream, interpreted as an
284      *             unsigned 8-bit number.
<a name="31" id="anc31"></a><span class="line-modified">285      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">286      * @throws     IOException   the stream has been closed and the contained</span>
287      *             input stream does not support reading after close, or
288      *             another I/O error occurs.
289      * @see         java.io.FilterInputStream#in
290      */
291     public final int readUnsignedByte() throws IOException {
292         int ch = in.read();
293         if (ch &lt; 0)
294             throw new EOFException();
295         return ch;
296     }
297 
298     /**
<a name="32" id="anc32"></a><span class="line-modified">299      * See the general contract of the {@code readShort}</span>
<span class="line-modified">300      * method of {@code DataInput}.</span>
301      * &lt;p&gt;
302      * Bytes
303      * for this operation are read from the contained
304      * input stream.
305      *
306      * @return     the next two bytes of this input stream, interpreted as a
307      *             signed 16-bit number.
<a name="33" id="anc33"></a><span class="line-modified">308      * @throws     EOFException  if this input stream reaches the end before</span>
309      *               reading two bytes.
<a name="34" id="anc34"></a><span class="line-modified">310      * @throws     IOException   the stream has been closed and the contained</span>
311      *             input stream does not support reading after close, or
312      *             another I/O error occurs.
313      * @see        java.io.FilterInputStream#in
314      */
315     public final short readShort() throws IOException {
316         int ch1 = in.read();
317         int ch2 = in.read();
318         if ((ch1 | ch2) &lt; 0)
319             throw new EOFException();
320         return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
321     }
322 
323     /**
<a name="35" id="anc35"></a><span class="line-modified">324      * See the general contract of the {@code readUnsignedShort}</span>
<span class="line-modified">325      * method of {@code DataInput}.</span>
326      * &lt;p&gt;
327      * Bytes
328      * for this operation are read from the contained
329      * input stream.
330      *
331      * @return     the next two bytes of this input stream, interpreted as an
332      *             unsigned 16-bit integer.
<a name="36" id="anc36"></a><span class="line-modified">333      * @throws     EOFException  if this input stream reaches the end before</span>
334      *             reading two bytes.
<a name="37" id="anc37"></a><span class="line-modified">335      * @throws     IOException   the stream has been closed and the contained</span>
336      *             input stream does not support reading after close, or
337      *             another I/O error occurs.
338      * @see        java.io.FilterInputStream#in
339      */
340     public final int readUnsignedShort() throws IOException {
341         int ch1 = in.read();
342         int ch2 = in.read();
343         if ((ch1 | ch2) &lt; 0)
344             throw new EOFException();
345         return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
346     }
347 
348     /**
<a name="38" id="anc38"></a><span class="line-modified">349      * See the general contract of the {@code readChar}</span>
<span class="line-modified">350      * method of {@code DataInput}.</span>
351      * &lt;p&gt;
352      * Bytes
353      * for this operation are read from the contained
354      * input stream.
355      *
356      * @return     the next two bytes of this input stream, interpreted as a
<a name="39" id="anc39"></a><span class="line-modified">357      *             {@code char}.</span>
<span class="line-modified">358      * @throws     EOFException  if this input stream reaches the end before</span>
359      *               reading two bytes.
<a name="40" id="anc40"></a><span class="line-modified">360      * @throws     IOException   the stream has been closed and the contained</span>
361      *             input stream does not support reading after close, or
362      *             another I/O error occurs.
363      * @see        java.io.FilterInputStream#in
364      */
365     public final char readChar() throws IOException {
366         int ch1 = in.read();
367         int ch2 = in.read();
368         if ((ch1 | ch2) &lt; 0)
369             throw new EOFException();
370         return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
371     }
372 
373     /**
<a name="41" id="anc41"></a><span class="line-modified">374      * See the general contract of the {@code readInt}</span>
<span class="line-modified">375      * method of {@code DataInput}.</span>
376      * &lt;p&gt;
377      * Bytes
378      * for this operation are read from the contained
379      * input stream.
380      *
381      * @return     the next four bytes of this input stream, interpreted as an
<a name="42" id="anc42"></a><span class="line-modified">382      *             {@code int}.</span>
<span class="line-modified">383      * @throws     EOFException  if this input stream reaches the end before</span>
384      *               reading four bytes.
<a name="43" id="anc43"></a><span class="line-modified">385      * @throws     IOException   the stream has been closed and the contained</span>
386      *             input stream does not support reading after close, or
387      *             another I/O error occurs.
388      * @see        java.io.FilterInputStream#in
389      */
390     public final int readInt() throws IOException {
391         int ch1 = in.read();
392         int ch2 = in.read();
393         int ch3 = in.read();
394         int ch4 = in.read();
395         if ((ch1 | ch2 | ch3 | ch4) &lt; 0)
396             throw new EOFException();
397         return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));
398     }
399 
400     private byte readBuffer[] = new byte[8];
401 
402     /**
<a name="44" id="anc44"></a><span class="line-modified">403      * See the general contract of the {@code readLong}</span>
<span class="line-modified">404      * method of {@code DataInput}.</span>
405      * &lt;p&gt;
406      * Bytes
407      * for this operation are read from the contained
408      * input stream.
409      *
410      * @return     the next eight bytes of this input stream, interpreted as a
<a name="45" id="anc45"></a><span class="line-modified">411      *             {@code long}.</span>
<span class="line-modified">412      * @throws     EOFException  if this input stream reaches the end before</span>
413      *               reading eight bytes.
<a name="46" id="anc46"></a><span class="line-modified">414      * @throws     IOException   the stream has been closed and the contained</span>
415      *             input stream does not support reading after close, or
416      *             another I/O error occurs.
417      * @see        java.io.FilterInputStream#in
418      */
419     public final long readLong() throws IOException {
420         readFully(readBuffer, 0, 8);
421         return (((long)readBuffer[0] &lt;&lt; 56) +
422                 ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) +
423                 ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) +
424                 ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) +
425                 ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) +
426                 ((readBuffer[5] &amp; 255) &lt;&lt; 16) +
427                 ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
428                 ((readBuffer[7] &amp; 255) &lt;&lt;  0));
429     }
430 
431     /**
<a name="47" id="anc47"></a><span class="line-modified">432      * See the general contract of the {@code readFloat}</span>
<span class="line-modified">433      * method of {@code DataInput}.</span>
434      * &lt;p&gt;
435      * Bytes
436      * for this operation are read from the contained
437      * input stream.
438      *
439      * @return     the next four bytes of this input stream, interpreted as a
<a name="48" id="anc48"></a><span class="line-modified">440      *             {@code float}.</span>
<span class="line-modified">441      * @throws     EOFException  if this input stream reaches the end before</span>
442      *               reading four bytes.
<a name="49" id="anc49"></a><span class="line-modified">443      * @throws     IOException   the stream has been closed and the contained</span>
444      *             input stream does not support reading after close, or
445      *             another I/O error occurs.
446      * @see        java.io.DataInputStream#readInt()
447      * @see        java.lang.Float#intBitsToFloat(int)
448      */
449     public final float readFloat() throws IOException {
450         return Float.intBitsToFloat(readInt());
451     }
452 
453     /**
<a name="50" id="anc50"></a><span class="line-modified">454      * See the general contract of the {@code readDouble}</span>
<span class="line-modified">455      * method of {@code DataInput}.</span>
456      * &lt;p&gt;
457      * Bytes
458      * for this operation are read from the contained
459      * input stream.
460      *
461      * @return     the next eight bytes of this input stream, interpreted as a
<a name="51" id="anc51"></a><span class="line-modified">462      *             {@code double}.</span>
<span class="line-modified">463      * @throws     EOFException  if this input stream reaches the end before</span>
464      *               reading eight bytes.
<a name="52" id="anc52"></a><span class="line-modified">465      * @throws     IOException   the stream has been closed and the contained</span>
466      *             input stream does not support reading after close, or
467      *             another I/O error occurs.
468      * @see        java.io.DataInputStream#readLong()
469      * @see        java.lang.Double#longBitsToDouble(long)
470      */
471     public final double readDouble() throws IOException {
472         return Double.longBitsToDouble(readLong());
473     }
474 
475     private char lineBuffer[];
476 
477     /**
<a name="53" id="anc53"></a><span class="line-modified">478      * See the general contract of the {@code readLine}</span>
<span class="line-modified">479      * method of {@code DataInput}.</span>
480      * &lt;p&gt;
481      * Bytes
482      * for this operation are read from the contained
483      * input stream.
484      *
485      * @deprecated This method does not properly convert bytes to characters.
486      * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<a name="54" id="anc54"></a><span class="line-modified">487      * {@code BufferedReader.readLine()} method.  Programs that use the</span>
<span class="line-modified">488      * {@code DataInputStream} class to read lines can be converted to use</span>
<span class="line-modified">489      * the {@code BufferedReader} class by replacing code of the form:</span>
490      * &lt;blockquote&gt;&lt;pre&gt;
491      *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
492      * &lt;/pre&gt;&lt;/blockquote&gt;
493      * with:
494      * &lt;blockquote&gt;&lt;pre&gt;
495      *     BufferedReader d
496      *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
497      * &lt;/pre&gt;&lt;/blockquote&gt;
498      *
499      * @return     the next line of text from this input stream.
<a name="55" id="anc55"></a><span class="line-modified">500      * @throws     IOException  if an I/O error occurs.</span>
501      * @see        java.io.BufferedReader#readLine()
502      * @see        java.io.FilterInputStream#in
503      */
504     @Deprecated
505     public final String readLine() throws IOException {
506         char buf[] = lineBuffer;
507 
508         if (buf == null) {
509             buf = lineBuffer = new char[128];
510         }
511 
512         int room = buf.length;
513         int offset = 0;
514         int c;
515 
516 loop:   while (true) {
517             switch (c = in.read()) {
518               case -1:
519               case &#39;\n&#39;:
520                 break loop;
521 
522               case &#39;\r&#39;:
523                 int c2 = in.read();
524                 if ((c2 != &#39;\n&#39;) &amp;&amp; (c2 != -1)) {
525                     if (!(in instanceof PushbackInputStream)) {
526                         this.in = new PushbackInputStream(in);
527                     }
528                     ((PushbackInputStream)in).unread(c2);
529                 }
530                 break loop;
531 
532               default:
533                 if (--room &lt; 0) {
534                     buf = new char[offset + 128];
535                     room = buf.length - offset - 1;
536                     System.arraycopy(lineBuffer, 0, buf, 0, offset);
537                     lineBuffer = buf;
538                 }
539                 buf[offset++] = (char) c;
540                 break;
541             }
542         }
543         if ((c == -1) &amp;&amp; (offset == 0)) {
544             return null;
545         }
546         return String.copyValueOf(buf, 0, offset);
547     }
548 
549     /**
<a name="56" id="anc56"></a><span class="line-modified">550      * See the general contract of the {@code readUTF}</span>
<span class="line-modified">551      * method of {@code DataInput}.</span>
552      * &lt;p&gt;
553      * Bytes
554      * for this operation are read from the contained
555      * input stream.
556      *
557      * @return     a Unicode string.
<a name="57" id="anc57"></a><span class="line-modified">558      * @throws     EOFException  if this input stream reaches the end before</span>
559      *               reading all the bytes.
<a name="58" id="anc58"></a><span class="line-modified">560      * @throws     IOException   the stream has been closed and the contained</span>
561      *             input stream does not support reading after close, or
562      *             another I/O error occurs.
<a name="59" id="anc59"></a><span class="line-modified">563      * @throws     UTFDataFormatException if the bytes do not represent a valid</span>
564      *             modified UTF-8 encoding of a string.
565      * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
566      */
567     public final String readUTF() throws IOException {
568         return readUTF(this);
569     }
570 
571     /**
572      * Reads from the
<a name="60" id="anc60"></a><span class="line-modified">573      * stream {@code in} a representation</span>
574      * of a Unicode  character string encoded in
575      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<a name="61" id="anc61"></a><span class="line-modified">576      * this string of characters is then returned as a {@code String}.</span>
577      * The details of the modified UTF-8 representation
<a name="62" id="anc62"></a><span class="line-modified">578      * are  exactly the same as for the {@code readUTF}</span>
<span class="line-modified">579      * method of {@code DataInput}.</span>
580      *
581      * @param      in   a data input stream.
582      * @return     a Unicode string.
<a name="63" id="anc63"></a><span class="line-modified">583      * @throws     EOFException            if the input stream reaches the end</span>
584      *               before all the bytes.
<a name="64" id="anc64"></a><span class="line-modified">585      * @throws     IOException   the stream has been closed and the contained</span>
586      *             input stream does not support reading after close, or
587      *             another I/O error occurs.
<a name="65" id="anc65"></a><span class="line-modified">588      * @throws     UTFDataFormatException  if the bytes do not represent a</span>
589      *               valid modified UTF-8 encoding of a Unicode string.
590      * @see        java.io.DataInputStream#readUnsignedShort()
591      */
592     public static final String readUTF(DataInput in) throws IOException {
593         int utflen = in.readUnsignedShort();
594         byte[] bytearr = null;
595         char[] chararr = null;
596         if (in instanceof DataInputStream) {
597             DataInputStream dis = (DataInputStream)in;
598             if (dis.bytearr.length &lt; utflen){
599                 dis.bytearr = new byte[utflen*2];
600                 dis.chararr = new char[utflen*2];
601             }
602             chararr = dis.chararr;
603             bytearr = dis.bytearr;
604         } else {
605             bytearr = new byte[utflen];
606             chararr = new char[utflen];
607         }
608 
609         int c, char2, char3;
610         int count = 0;
611         int chararr_count=0;
612 
613         in.readFully(bytearr, 0, utflen);
614 
615         while (count &lt; utflen) {
616             c = (int) bytearr[count] &amp; 0xff;
617             if (c &gt; 127) break;
618             count++;
619             chararr[chararr_count++]=(char)c;
620         }
621 
622         while (count &lt; utflen) {
623             c = (int) bytearr[count] &amp; 0xff;
624             switch (c &gt;&gt; 4) {
625                 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
626                     /* 0xxxxxxx*/
627                     count++;
628                     chararr[chararr_count++]=(char)c;
629                     break;
630                 case 12: case 13:
631                     /* 110x xxxx   10xx xxxx*/
632                     count += 2;
633                     if (count &gt; utflen)
634                         throw new UTFDataFormatException(
635                             &quot;malformed input: partial character at end&quot;);
636                     char2 = (int) bytearr[count-1];
637                     if ((char2 &amp; 0xC0) != 0x80)
638                         throw new UTFDataFormatException(
639                             &quot;malformed input around byte &quot; + count);
640                     chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) |
641                                                     (char2 &amp; 0x3F));
642                     break;
643                 case 14:
644                     /* 1110 xxxx  10xx xxxx  10xx xxxx */
645                     count += 3;
646                     if (count &gt; utflen)
647                         throw new UTFDataFormatException(
648                             &quot;malformed input: partial character at end&quot;);
649                     char2 = (int) bytearr[count-2];
650                     char3 = (int) bytearr[count-1];
651                     if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80))
652                         throw new UTFDataFormatException(
653                             &quot;malformed input around byte &quot; + (count-1));
654                     chararr[chararr_count++]=(char)(((c     &amp; 0x0F) &lt;&lt; 12) |
655                                                     ((char2 &amp; 0x3F) &lt;&lt; 6)  |
656                                                     ((char3 &amp; 0x3F) &lt;&lt; 0));
657                     break;
658                 default:
659                     /* 10xx xxxx,  1111 xxxx */
660                     throw new UTFDataFormatException(
661                         &quot;malformed input around byte &quot; + count);
662             }
663         }
664         // The number of chars produced may be less than utflen
665         return new String(chararr, 0, chararr_count);
666     }
667 }
<a name="66" id="anc66"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="66" type="hidden" />
</body>
</html>
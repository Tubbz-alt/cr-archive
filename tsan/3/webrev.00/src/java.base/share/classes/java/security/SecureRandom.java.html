<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/security/SecureRandom.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.util.*;
  29 import java.util.regex.*;
  30 
  31 import java.security.Provider.Service;
  32 
  33 import sun.security.jca.*;
  34 import sun.security.jca.GetInstance.Instance;
  35 import sun.security.provider.SunEntries;
  36 import sun.security.util.Debug;
  37 
  38 /**
  39  * This class provides a cryptographically strong random number
  40  * generator (RNG).
  41  *
  42  * &lt;p&gt;A cryptographically strong random number minimally complies with the
  43  * statistical random number generator tests specified in
  44  * &lt;a href=&quot;http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf&quot;&gt;
  45  * &lt;i&gt;FIPS 140-2, Security Requirements for Cryptographic Modules&lt;/i&gt;&lt;/a&gt;,
  46  * section 4.9.1.
  47  * Additionally, {@code SecureRandom} must produce non-deterministic output.
  48  * Therefore any seed material passed to a {@code SecureRandom} object must be
  49  * unpredictable, and all {@code SecureRandom} output sequences must be
  50  * cryptographically strong, as described in
  51  * &lt;a href=&quot;http://tools.ietf.org/html/rfc4086&quot;&gt;
  52  * &lt;i&gt;RFC 4086: Randomness Requirements for Security&lt;/i&gt;&lt;/a&gt;.
  53  *
  54  * &lt;p&gt; Many {@code SecureRandom} implementations are in the form of a
  55  * pseudo-random number generator (PRNG, also known as deterministic random
  56  * bits generator or DRBG), which means they use a deterministic algorithm
  57  * to produce a pseudo-random sequence from a random seed.
  58  * Other implementations may produce true random numbers,
  59  * and yet others may use a combination of both techniques.
  60  *
  61  * &lt;p&gt;A caller obtains a {@code SecureRandom} instance via the
  62  * no-argument constructor or one of the {@code getInstance} methods.
  63  * For example:
  64  *
  65  * &lt;blockquote&gt;&lt;pre&gt;
  66  * SecureRandom r1 = new SecureRandom();
  67  * SecureRandom r2 = SecureRandom.getInstance(&quot;NativePRNG&quot;);
  68  * SecureRandom r3 = SecureRandom.getInstance(&quot;DRBG&quot;,
  69  *         DrbgParameters.instantiation(128, RESEED_ONLY, null));&lt;/pre&gt;
  70  * &lt;/blockquote&gt;
  71  *
  72  * &lt;p&gt; The third statement above returns a {@code SecureRandom} object of the
  73  * specific algorithm supporting the specific instantiate parameters. The
  74  * implementation&#39;s effective instantiated parameters must match this minimum
  75  * request but is not necessarily the same. For example, even if the request
  76  * does not require a certain feature, the actual instantiation can provide
  77  * the feature. An implementation may lazily instantiate a {@code SecureRandom}
  78  * until it&#39;s actually used, but the effective instantiate parameters must be
  79  * determined right after it&#39;s created and {@link #getParameters()} should
  80  * always return the same result unchanged.
  81  *
  82  * &lt;p&gt; Typical callers of {@code SecureRandom} invoke the following methods
  83  * to retrieve random bytes:
  84  *
  85  * &lt;blockquote&gt;&lt;pre&gt;
  86  * SecureRandom random = new SecureRandom();
  87  * byte[] bytes = new byte[20];
  88  * random.nextBytes(bytes);&lt;/pre&gt;
  89  * &lt;/blockquote&gt;
  90  *
  91  * &lt;p&gt; Callers may also invoke the {@link #generateSeed} method
  92  * to generate a given number of seed bytes (to seed other random number
  93  * generators, for example):
  94  *
  95  * &lt;blockquote&gt;&lt;pre&gt;
  96  * byte[] seed = random.generateSeed(20);&lt;/pre&gt;
  97  * &lt;/blockquote&gt;
  98  *
  99  * &lt;p&gt; A newly created PRNG {@code SecureRandom} object is not seeded (except
 100  * if it is created by {@link #SecureRandom(byte[])}). The first call to
 101  * {@code nextBytes} will force it to seed itself from an implementation-
 102  * specific entropy source. This self-seeding will not occur if {@code setSeed}
 103  * was previously called.
 104  *
 105  * &lt;p&gt; A {@code SecureRandom} can be reseeded at any time by calling the
 106  * {@code reseed} or {@code setSeed} method. The {@code reseed} method
 107  * reads entropy input from its entropy source to reseed itself.
 108  * The {@code setSeed} method requires the caller to provide the seed.
 109  *
 110  * &lt;p&gt; Please note that {@code reseed} may not be supported by all
 111  * {@code SecureRandom} implementations.
 112  *
 113  * &lt;p&gt; Some {@code SecureRandom} implementations may accept a
 114  * {@link SecureRandomParameters} parameter in its
 115  * {@link #nextBytes(byte[], SecureRandomParameters)} and
 116  * {@link #reseed(SecureRandomParameters)} methods to further
 117  * control the behavior of the methods.
 118  *
 119  * &lt;p&gt; Note: Depending on the implementation, the {@code generateSeed},
 120  * {@code reseed} and {@code nextBytes} methods may block as entropy is being
 121  * gathered, for example, if the entropy source is /dev/random on various
 122  * Unix-like operating systems.
 123  *
 124  * &lt;h2&gt; Thread safety &lt;/h2&gt;
 125  * {@code SecureRandom} objects are safe for use by multiple concurrent threads.
 126  *
 127  * @implSpec
 128  * A {@code SecureRandom} service provider can advertise that it is thread-safe
 129  * by setting the &lt;a href=
 130  * &quot;{@docRoot}/../specs/security/standard-names.html#service-attributes&quot;&gt;service
 131  * provider attribute&lt;/a&gt; &quot;ThreadSafe&quot; to &quot;true&quot; when registering the provider.
 132  * Otherwise, this class will instead synchronize access to the following
 133  * methods of the {@code SecureRandomSpi} implementation:
 134  * &lt;ul&gt;
 135  * &lt;li&gt;{@link SecureRandomSpi#engineSetSeed(byte[])}
 136  * &lt;li&gt;{@link SecureRandomSpi#engineNextBytes(byte[])}
 137  * &lt;li&gt;{@link SecureRandomSpi#engineNextBytes(byte[], SecureRandomParameters)}
 138  * &lt;li&gt;{@link SecureRandomSpi#engineGenerateSeed(int)}
 139  * &lt;li&gt;{@link SecureRandomSpi#engineReseed(SecureRandomParameters)}
 140  * &lt;/ul&gt;
 141  *
 142  * @see java.security.SecureRandomSpi
 143  * @see java.util.Random
 144  *
 145  * @author Benjamin Renaud
 146  * @author Josh Bloch
 147  * @since 1.1
 148  */
 149 
 150 public class SecureRandom extends java.util.Random {
 151 
 152     private static final Debug pdebug =
 153                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 154     private static final boolean skipDebug =
 155         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;securerandom&quot;);
 156 
 157     /**
 158      * The provider.
 159      *
 160      * @serial
 161      * @since 1.2
 162      */
 163     private Provider provider = null;
 164 
 165     /**
 166      * The provider implementation.
 167      *
 168      * @serial
 169      * @since 1.2
 170      */
 171     private SecureRandomSpi secureRandomSpi = null;
 172 
 173     /**
 174      * Thread safety.
 175      *
 176      * @serial
 177      * @since 9
 178      */
 179     private final boolean threadSafe;
 180 
 181     /*
 182      * The algorithm name of null if unknown.
 183      *
 184      * @serial
 185      * @since 1.5
 186      */
 187     private String algorithm;
 188 
 189     // Seed Generator
 190     private static volatile SecureRandom seedGenerator;
 191 
 192     /**
 193      * Constructs a secure random number generator (RNG) implementing the
 194      * default random number algorithm.
 195      *
 196      * &lt;p&gt; This constructor traverses the list of registered security Providers,
 197      * starting with the most preferred Provider.
 198      * A new {@code SecureRandom} object encapsulating the
 199      * {@code SecureRandomSpi} implementation from the first
 200      * Provider that supports a {@code SecureRandom} (RNG) algorithm is returned.
 201      * If none of the Providers support a RNG algorithm,
 202      * then an implementation-specific default is returned.
 203      *
 204      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 205      * the {@link Security#getProviders() Security.getProviders()} method.
 206      *
 207      * &lt;p&gt; See the {@code SecureRandom} section in the &lt;a href=
 208      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 209      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 210      * for information about standard RNG algorithm names.
 211      */
 212     public SecureRandom() {
 213         /*
 214          * This call to our superclass constructor will result in a call
 215          * to our own {@code setSeed} method, which will return
 216          * immediately when it is passed zero.
 217          */
 218         super(0);
 219         getDefaultPRNG(false, null);
 220         this.threadSafe = getThreadSafe();
 221     }
 222 
 223     private boolean getThreadSafe() {
 224         if (provider == null || algorithm == null) {
 225             return false;
 226         } else {
 227             return Boolean.parseBoolean(provider.getProperty(
 228                     &quot;SecureRandom.&quot; + algorithm + &quot; ThreadSafe&quot;, &quot;false&quot;));
 229         }
 230     }
 231 
 232     /**
 233      * Constructs a secure random number generator (RNG) implementing the
 234      * default random number algorithm.
 235      * The {@code SecureRandom} instance is seeded with the specified seed bytes.
 236      *
 237      * &lt;p&gt; This constructor traverses the list of registered security Providers,
 238      * starting with the most preferred Provider.
 239      * A new {@code SecureRandom} object encapsulating the
 240      * {@code SecureRandomSpi} implementation from the first
 241      * Provider that supports a {@code SecureRandom} (RNG) algorithm is returned.
 242      * If none of the Providers support a RNG algorithm,
 243      * then an implementation-specific default is returned.
 244      *
 245      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 246      * the {@link Security#getProviders() Security.getProviders()} method.
 247      *
 248      * &lt;p&gt; See the {@code SecureRandom} section in the &lt;a href=
 249      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 250      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 251      * for information about standard RNG algorithm names.
 252      *
 253      * @param seed the seed.
 254      */
 255     public SecureRandom(byte[] seed) {
 256         super(0);
 257         getDefaultPRNG(true, seed);
 258         this.threadSafe = getThreadSafe();
 259     }
 260 
 261     private void getDefaultPRNG(boolean setSeed, byte[] seed) {
 262         String prng = getPrngAlgorithm();
 263         if (prng == null) {
 264             // bummer, get the SUN implementation
 265             prng = &quot;SHA1PRNG&quot;;
 266             this.secureRandomSpi = new sun.security.provider.SecureRandom();
 267             this.provider = Providers.getSunProvider();
 268             if (setSeed) {
 269                 this.secureRandomSpi.engineSetSeed(seed);
 270             }
 271         } else {
 272             try {
 273                 SecureRandom random = SecureRandom.getInstance(prng);
 274                 this.secureRandomSpi = random.getSecureRandomSpi();
 275                 this.provider = random.getProvider();
 276                 if (setSeed) {
 277                     this.secureRandomSpi.engineSetSeed(seed);
 278                 }
 279             } catch (NoSuchAlgorithmException nsae) {
 280                 // never happens, because we made sure the algorithm exists
 281                 throw new RuntimeException(nsae);
 282             }
 283         }
 284         // JDK 1.1 based implementations subclass SecureRandom instead of
 285         // SecureRandomSpi. They will also go through this code path because
 286         // they must call a SecureRandom constructor as it is their superclass.
 287         // If we are dealing with such an implementation, do not set the
 288         // algorithm value as it would be inaccurate.
 289         if (getClass() == SecureRandom.class) {
 290             this.algorithm = prng;
 291         }
 292     }
 293 
 294     /**
 295      * Creates a {@code SecureRandom} object.
 296      *
 297      * @param secureRandomSpi the {@code SecureRandom} implementation.
 298      * @param provider the provider.
 299      */
 300     protected SecureRandom(SecureRandomSpi secureRandomSpi,
 301                            Provider provider) {
 302         this(secureRandomSpi, provider, null);
 303     }
 304 
 305     private SecureRandom(SecureRandomSpi secureRandomSpi, Provider provider,
 306             String algorithm) {
 307         super(0);
 308         this.secureRandomSpi = secureRandomSpi;
 309         this.provider = provider;
 310         this.algorithm = algorithm;
 311         this.threadSafe = getThreadSafe();
 312 
 313         if (!skipDebug &amp;&amp; pdebug != null) {
 314             pdebug.println(&quot;SecureRandom.&quot; + algorithm +
 315                 &quot; algorithm from: &quot; + getProviderName());
 316         }
 317     }
 318 
 319     private String getProviderName() {
 320         return (provider == null) ? &quot;(no provider)&quot; : provider.getName();
 321     }
 322 
 323     /**
 324      * Returns a {@code SecureRandom} object that implements the specified
 325      * Random Number Generator (RNG) algorithm.
 326      *
 327      * &lt;p&gt; This method traverses the list of registered security Providers,
 328      * starting with the most preferred Provider.
 329      * A new {@code SecureRandom} object encapsulating the
 330      * {@code SecureRandomSpi} implementation from the first
 331      * Provider that supports the specified algorithm is returned.
 332      *
 333      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 334      * the {@link Security#getProviders() Security.getProviders()} method.
 335      *
 336      * @implNote
 337      * The JDK Reference Implementation additionally uses the
 338      * {@code jdk.security.provider.preferred}
 339      * {@link Security#getProperty(String) Security} property to determine
 340      * the preferred provider order for the specified algorithm. This
 341      * may be different than the order of providers returned by
 342      * {@link Security#getProviders() Security.getProviders()}.
 343      *
 344      * @param algorithm the name of the RNG algorithm.
 345      * See the {@code SecureRandom} section in the &lt;a href=
 346      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 347      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 348      * for information about standard RNG algorithm names.
 349      *
 350      * @return the new {@code SecureRandom} object
 351      *
 352      * @throws NoSuchAlgorithmException if no {@code Provider} supports a
 353      *         {@code SecureRandomSpi} implementation for the
 354      *         specified algorithm
 355      *
 356      * @throws NullPointerException if {@code algorithm} is {@code null}
 357      *
 358      * @see Provider
 359      *
 360      * @since 1.2
 361      */
 362     public static SecureRandom getInstance(String algorithm)
 363             throws NoSuchAlgorithmException {
 364         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 365         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 366                 SecureRandomSpi.class, algorithm);
 367         return new SecureRandom((SecureRandomSpi)instance.impl,
 368                 instance.provider, algorithm);
 369     }
 370 
 371     /**
 372      * Returns a {@code SecureRandom} object that implements the specified
 373      * Random Number Generator (RNG) algorithm.
 374      *
 375      * &lt;p&gt; A new {@code SecureRandom} object encapsulating the
 376      * {@code SecureRandomSpi} implementation from the specified provider
 377      * is returned.  The specified provider must be registered
 378      * in the security provider list.
 379      *
 380      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 381      * the {@link Security#getProviders() Security.getProviders()} method.
 382      *
 383      * @param algorithm the name of the RNG algorithm.
 384      * See the {@code SecureRandom} section in the &lt;a href=
 385      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 386      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 387      * for information about standard RNG algorithm names.
 388      *
 389      * @param provider the name of the provider.
 390      *
 391      * @return the new {@code SecureRandom} object
 392      *
 393      * @throws IllegalArgumentException if the provider name is {@code null}
 394      *         or empty
 395      *
 396      * @throws NoSuchAlgorithmException if a {@code SecureRandomSpi}
 397      *         implementation for the specified algorithm is not
 398      *         available from the specified provider
 399      *
 400      * @throws NoSuchProviderException if the specified provider is not
 401      *         registered in the security provider list
 402      *
 403      * @throws NullPointerException if {@code algorithm} is {@code null}
 404      *
 405      * @see Provider
 406      *
 407      * @since 1.2
 408      */
 409     public static SecureRandom getInstance(String algorithm, String provider)
 410             throws NoSuchAlgorithmException, NoSuchProviderException {
 411         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 412         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 413             SecureRandomSpi.class, algorithm, provider);
 414         return new SecureRandom((SecureRandomSpi)instance.impl,
 415             instance.provider, algorithm);
 416     }
 417 
 418     /**
 419      * Returns a {@code SecureRandom} object that implements the specified
 420      * Random Number Generator (RNG) algorithm.
 421      *
 422      * &lt;p&gt; A new {@code SecureRandom} object encapsulating the
 423      * {@code SecureRandomSpi} implementation from the specified {@code Provider}
 424      * object is returned.  Note that the specified {@code Provider} object
 425      * does not have to be registered in the provider list.
 426      *
 427      * @param algorithm the name of the RNG algorithm.
 428      * See the {@code SecureRandom} section in the &lt;a href=
 429      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 430      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 431      * for information about standard RNG algorithm names.
 432      *
 433      * @param provider the provider.
 434      *
 435      * @return the new {@code SecureRandom} object
 436      *
 437      * @throws IllegalArgumentException if the specified provider is
 438      *         {@code null}
 439      *
 440      * @throws NoSuchAlgorithmException if a {@code SecureRandomSpi}
 441      *         implementation for the specified algorithm is not available
 442      *         from the specified {@code Provider} object
 443      *
 444      * @throws NullPointerException if {@code algorithm} is {@code null}
 445      *
 446      * @see Provider
 447      *
 448      * @since 1.4
 449      */
 450     public static SecureRandom getInstance(String algorithm,
 451             Provider provider) throws NoSuchAlgorithmException {
 452         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 453         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 454             SecureRandomSpi.class, algorithm, provider);
 455         return new SecureRandom((SecureRandomSpi)instance.impl,
 456             instance.provider, algorithm);
 457     }
 458 
 459     /**
 460      * Returns a {@code SecureRandom} object that implements the specified
 461      * Random Number Generator (RNG) algorithm and supports the specified
 462      * {@code SecureRandomParameters} request.
 463      *
 464      * &lt;p&gt; This method traverses the list of registered security Providers,
 465      * starting with the most preferred Provider.
 466      * A new {@code SecureRandom} object encapsulating the
 467      * {@code SecureRandomSpi} implementation from the first
 468      * Provider that supports the specified algorithm and the specified
 469      * {@code SecureRandomParameters} is returned.
 470      *
 471      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 472      * the {@link Security#getProviders() Security.getProviders()} method.
 473      *
 474      * @implNote
 475      * The JDK Reference Implementation additionally uses the
 476      * {@code jdk.security.provider.preferred} property to determine
 477      * the preferred provider order for the specified algorithm. This
 478      * may be different than the order of providers returned by
 479      * {@link Security#getProviders() Security.getProviders()}.
 480      *
 481      * @param algorithm the name of the RNG algorithm.
 482      * See the {@code SecureRandom} section in the &lt;a href=
 483      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 484      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 485      * for information about standard RNG algorithm names.
 486      *
 487      * @param params the {@code SecureRandomParameters}
 488      *               the newly created {@code SecureRandom} object must support.
 489      *
 490      * @return the new {@code SecureRandom} object
 491      *
 492      * @throws IllegalArgumentException if the specified params is
 493      *         {@code null}
 494      *
 495      * @throws NoSuchAlgorithmException if no Provider supports a
 496      *         {@code SecureRandomSpi} implementation for the specified
 497      *         algorithm and parameters
 498      *
 499      * @throws NullPointerException if {@code algorithm} is {@code null}
 500      *
 501      * @see Provider
 502      *
 503      * @since 9
 504      */
 505     public static SecureRandom getInstance(
 506             String algorithm, SecureRandomParameters params)
 507             throws NoSuchAlgorithmException {
 508         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 509         if (params == null) {
 510             throw new IllegalArgumentException(&quot;params cannot be null&quot;);
 511         }
 512         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 513                 SecureRandomSpi.class, algorithm, params);
 514         return new SecureRandom((SecureRandomSpi)instance.impl,
 515                 instance.provider, algorithm);
 516     }
 517 
 518     /**
 519      * Returns a {@code SecureRandom} object that implements the specified
 520      * Random Number Generator (RNG) algorithm and supports the specified
 521      * {@code SecureRandomParameters} request.
 522      *
 523      * &lt;p&gt; A new {@code SecureRandom} object encapsulating the
 524      * {@code SecureRandomSpi} implementation from the specified provider
 525      * is returned.  The specified provider must be registered
 526      * in the security provider list.
 527      *
 528      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 529      * the {@link Security#getProviders() Security.getProviders()} method.
 530      *
 531      * @param algorithm the name of the RNG algorithm.
 532      * See the {@code SecureRandom} section in the &lt;a href=
 533      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 534      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 535      * for information about standard RNG algorithm names.
 536      *
 537      * @param params the {@code SecureRandomParameters}
 538      *               the newly created {@code SecureRandom} object must support.
 539      *
 540      * @param provider the name of the provider.
 541      *
 542      * @return the new {@code SecureRandom} object
 543      *
 544      * @throws IllegalArgumentException if the provider name is {@code null}
 545      *         or empty, or params is {@code null}
 546      *
 547      * @throws NoSuchAlgorithmException if the specified provider does not
 548      *         support a {@code SecureRandomSpi} implementation for the
 549      *         specified algorithm and parameters
 550      *
 551      * @throws NoSuchProviderException if the specified provider is not
 552      *         registered in the security provider list
 553      *
 554      * @throws NullPointerException if {@code algorithm} is {@code null}
 555      *
 556      * @see Provider
 557      *
 558      * @since 9
 559      */
 560     public static SecureRandom getInstance(String algorithm,
 561             SecureRandomParameters params, String provider)
 562             throws NoSuchAlgorithmException, NoSuchProviderException {
 563         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 564         if (params == null) {
 565             throw new IllegalArgumentException(&quot;params cannot be null&quot;);
 566         }
 567         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 568                 SecureRandomSpi.class, algorithm, params, provider);
 569         return new SecureRandom((SecureRandomSpi)instance.impl,
 570                 instance.provider, algorithm);
 571     }
 572 
 573     /**
 574      * Returns a {@code SecureRandom} object that implements the specified
 575      * Random Number Generator (RNG) algorithm and supports the specified
 576      * {@code SecureRandomParameters} request.
 577      *
 578      * &lt;p&gt; A new {@code SecureRandom} object encapsulating the
 579      * {@code SecureRandomSpi} implementation from the specified
 580      * {@code Provider} object is returned.  Note that the specified
 581      * {@code Provider} object does not have to be registered in the
 582      * provider list.
 583      *
 584      * @param algorithm the name of the RNG algorithm.
 585      * See the {@code SecureRandom} section in the &lt;a href=
 586      * &quot;{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms&quot;&gt;
 587      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 588      * for information about standard RNG algorithm names.
 589      *
 590      * @param params the {@code SecureRandomParameters}
 591      *               the newly created {@code SecureRandom} object must support.
 592      *
 593      * @param provider the provider.
 594      *
 595      * @return the new {@code SecureRandom} object
 596      *
 597      * @throws IllegalArgumentException if the specified provider or params
 598      *         is {@code null}
 599      *
 600      * @throws NoSuchAlgorithmException if the specified provider does not
 601      *         support a {@code SecureRandomSpi} implementation for the
 602      *         specified algorithm and parameters
 603      *
 604      * @throws NullPointerException if {@code algorithm} is {@code null}
 605      *
 606      * @see Provider
 607      *
 608      * @since 9
 609      */
 610     public static SecureRandom getInstance(String algorithm,
 611             SecureRandomParameters params, Provider provider)
 612             throws NoSuchAlgorithmException {
 613         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 614         if (params == null) {
 615             throw new IllegalArgumentException(&quot;params cannot be null&quot;);
 616         }
 617         Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,
 618                 SecureRandomSpi.class, algorithm, params, provider);
 619         return new SecureRandom((SecureRandomSpi)instance.impl,
 620                 instance.provider, algorithm);
 621     }
 622 
 623     /**
 624      * Returns the {@code SecureRandomSpi} of this {@code SecureRandom} object.
 625      */
 626     SecureRandomSpi getSecureRandomSpi() {
 627         return secureRandomSpi;
 628     }
 629 
 630     /**
 631      * Returns the provider of this {@code SecureRandom} object.
 632      *
 633      * @return the provider of this {@code SecureRandom} object.
 634      */
 635     public final Provider getProvider() {
 636         return provider;
 637     }
 638 
 639     /**
 640      * Returns the name of the algorithm implemented by this
 641      * {@code SecureRandom} object.
 642      *
 643      * @return the name of the algorithm or {@code unknown}
 644      *          if the algorithm name cannot be determined.
 645      * @since 1.5
 646      */
 647     public String getAlgorithm() {
 648         return Objects.toString(algorithm, &quot;unknown&quot;);
 649     }
 650 
 651     /**
 652      * Returns a Human-readable string representation of this
 653      * {@code SecureRandom}.
 654      *
 655      * @return the string representation
 656      */
 657     @Override
 658     public String toString() {
 659         return secureRandomSpi.toString();
 660     }
 661 
 662     /**
 663      * Returns the effective {@link SecureRandomParameters} for this
 664      * {@code SecureRandom} instance.
 665      * &lt;p&gt;
 666      * The returned value can be different from the
 667      * {@code SecureRandomParameters} object passed into a {@code getInstance}
 668      * method, but it cannot change during the lifetime of this
 669      * {@code SecureRandom} object.
 670      * &lt;p&gt;
 671      * A caller can use the returned value to find out what features this
 672      * {@code SecureRandom} supports.
 673      *
 674      * @return the effective {@link SecureRandomParameters} parameters,
 675      * or {@code null} if no parameters were used.
 676      *
 677      * @since 9
 678      * @see SecureRandomSpi
 679      */
 680     public SecureRandomParameters getParameters() {
 681         return secureRandomSpi.engineGetParameters();
 682     }
 683 
 684     /**
 685      * Reseeds this random object with the given seed. The seed supplements,
 686      * rather than replaces, the existing seed. Thus, repeated calls are
 687      * guaranteed never to reduce randomness.
 688      * &lt;p&gt;
 689      * A PRNG {@code SecureRandom} will not seed itself automatically if
 690      * {@code setSeed} is called before any {@code nextBytes} or {@code reseed}
 691      * calls. The caller should make sure that the {@code seed} argument
 692      * contains enough entropy for the security of this {@code SecureRandom}.
 693      *
 694      * @param seed the seed.
 695      *
 696      * @see #getSeed
 697      */
 698     public void setSeed(byte[] seed) {
 699         if (threadSafe) {
 700             secureRandomSpi.engineSetSeed(seed);
 701         } else {
 702             synchronized (this) {
 703                 secureRandomSpi.engineSetSeed(seed);
 704             }
 705         }
 706     }
 707 
 708     /**
 709      * Reseeds this random object, using the eight bytes contained
 710      * in the given {@code long seed}. The given seed supplements,
 711      * rather than replaces, the existing seed. Thus, repeated calls
 712      * are guaranteed never to reduce randomness.
 713      *
 714      * &lt;p&gt;This method is defined for compatibility with
 715      * {@code java.util.Random}.
 716      *
 717      * @param seed the seed.
 718      *
 719      * @see #getSeed
 720      */
 721     @Override
 722     public void setSeed(long seed) {
 723         /*
 724          * Ignore call from super constructor (as well as any other calls
 725          * unfortunate enough to be passing 0).  It&#39;s critical that we
 726          * ignore call from superclass constructor, as digest has not
 727          * yet been initialized at that point.
 728          */
 729         if (seed != 0) {
 730             setSeed(longToByteArray(seed));
 731         }
 732     }
 733 
 734     /**
 735      * Generates a user-specified number of random bytes.
 736      *
 737      * @param bytes the array to be filled in with random bytes.
 738      */
 739     @Override
 740     public void nextBytes(byte[] bytes) {
 741         if (threadSafe) {
 742             secureRandomSpi.engineNextBytes(bytes);
 743         } else {
 744             synchronized (this) {
 745                 secureRandomSpi.engineNextBytes(bytes);
 746             }
 747         }
 748     }
 749 
 750     /**
 751      * Generates a user-specified number of random bytes with
 752      * additional parameters.
 753      *
 754      * @param bytes the array to be filled in with random bytes
 755      * @param params additional parameters
 756      * @throws NullPointerException if {@code bytes} is null
 757      * @throws UnsupportedOperationException if the underlying provider
 758      *         implementation has not overridden this method
 759      * @throws IllegalArgumentException if {@code params} is {@code null},
 760      *         illegal or unsupported by this {@code SecureRandom}
 761      *
 762      * @since 9
 763      */
 764     public void nextBytes(byte[] bytes, SecureRandomParameters params) {
 765         if (params == null) {
 766             throw new IllegalArgumentException(&quot;params cannot be null&quot;);
 767         }
 768         if (threadSafe) {
 769             secureRandomSpi.engineNextBytes(
 770                     Objects.requireNonNull(bytes), params);
 771         } else {
 772             synchronized (this) {
 773                 secureRandomSpi.engineNextBytes(
 774                         Objects.requireNonNull(bytes), params);
 775             }
 776         }
 777     }
 778 
 779     /**
 780      * Generates an integer containing the user-specified number of
 781      * pseudo-random bits (right justified, with leading zeros).  This
 782      * method overrides a {@code java.util.Random} method, and serves
 783      * to provide a source of random bits to all of the methods inherited
 784      * from that class (for example, {@code nextInt},
 785      * {@code nextLong}, and {@code nextFloat}).
 786      *
 787      * @param numBits number of pseudo-random bits to be generated, where
 788      * {@code 0 &lt;= numBits &lt;= 32}.
 789      *
 790      * @return an {@code int} containing the user-specified number
 791      * of pseudo-random bits (right justified, with leading zeros).
 792      */
 793     @Override
 794     protected final int next(int numBits) {
 795         int numBytes = (numBits+7)/8;
 796         byte[] b = new byte[numBytes];
 797         int next = 0;
 798 
 799         nextBytes(b);
 800         for (int i = 0; i &lt; numBytes; i++) {
 801             next = (next &lt;&lt; 8) + (b[i] &amp; 0xFF);
 802         }
 803 
 804         return next &gt;&gt;&gt; (numBytes*8 - numBits);
 805     }
 806 
 807     /**
 808      * Returns the given number of seed bytes, computed using the seed
 809      * generation algorithm that this class uses to seed itself.  This
 810      * call may be used to seed other random number generators.
 811      *
 812      * &lt;p&gt;This method is only included for backwards compatibility.
 813      * The caller is encouraged to use one of the alternative
 814      * {@code getInstance} methods to obtain a {@code SecureRandom} object, and
 815      * then call the {@code generateSeed} method to obtain seed bytes
 816      * from that object.
 817      *
 818      * @param numBytes the number of seed bytes to generate.
 819      *
 820      * @throws IllegalArgumentException if {@code numBytes} is negative
 821      * @return the seed bytes.
 822      *
 823      * @see #setSeed
 824      */
 825     public static byte[] getSeed(int numBytes) {
 826         SecureRandom seedGen = seedGenerator;
 827         if (seedGen == null) {
 828             seedGen = new SecureRandom();
 829             seedGenerator = seedGen;
 830         }
 831         return seedGen.generateSeed(numBytes);
 832     }
 833 
 834     /**
 835      * Returns the given number of seed bytes, computed using the seed
 836      * generation algorithm that this class uses to seed itself.  This
 837      * call may be used to seed other random number generators.
 838      *
 839      * @param numBytes the number of seed bytes to generate.
 840      * @throws IllegalArgumentException if {@code numBytes} is negative
 841      * @return the seed bytes.
 842      */
 843     public byte[] generateSeed(int numBytes) {
 844         if (numBytes &lt; 0) {
 845             throw new IllegalArgumentException(&quot;numBytes cannot be negative&quot;);
 846         }
 847         if (threadSafe) {
 848             return secureRandomSpi.engineGenerateSeed(numBytes);
 849         } else {
 850             synchronized (this) {
 851                 return secureRandomSpi.engineGenerateSeed(numBytes);
 852             }
 853         }
 854     }
 855 
 856     /**
 857      * Helper function to convert a long into a byte array (least significant
 858      * byte first).
 859      */
 860     private static byte[] longToByteArray(long l) {
 861         byte[] retVal = new byte[8];
 862 
 863         for (int i = 0; i &lt; 8; i++) {
 864             retVal[i] = (byte) l;
 865             l &gt;&gt;= 8;
 866         }
 867 
 868         return retVal;
 869     }
 870 
 871     /**
 872      * Gets a default PRNG algorithm by looking through all registered
 873      * providers. Returns the first PRNG algorithm of the first provider that
 874      * has registered a {@code SecureRandom} implementation, or null if none of
 875      * the registered providers supplies a {@code SecureRandom} implementation.
 876      */
 877     private static String getPrngAlgorithm() {
 878         for (Provider p : Providers.getProviderList().providers()) {
 879             // For SUN provider, we use SunEntries.DEFF_SECURE_RANDOM_ALGO
 880             // as the default SecureRandom algorithm; for other providers,
 881             // we continue to iterate through to the 1st SecureRandom
 882             // service
 883             if (p.getName().equals(&quot;SUN&quot;)) {
 884                 return SunEntries.DEF_SECURE_RANDOM_ALGO;
 885             }
 886             for (Service s : p.getServices()) {
 887                 if (s.getType().equals(&quot;SecureRandom&quot;)) {
 888                     return s.getAlgorithm();
 889                 }
 890             }
 891         }
 892         return null;
 893     }
 894 
 895     /*
 896      * Lazily initialize since Pattern.compile() is heavy.
 897      * Effective Java (2nd Edition), Item 71.
 898      */
 899     private static final class StrongPatternHolder {
 900         /*
 901          * Entries are alg:prov separated by ,
 902          * Allow for prepended/appended whitespace between entries.
 903          *
 904          * Capture groups:
 905          *     1 - alg
 906          *     2 - :prov (optional)
 907          *     3 - prov (optional)
 908          *     4 - ,nextEntry (optional)
 909          *     5 - nextEntry (optional)
 910          */
 911         private static Pattern pattern =
 912             Pattern.compile(
 913                 &quot;\\s*([\\S&amp;&amp;[^:,]]*)(\\:([\\S&amp;&amp;[^,]]*))?\\s*(\\,(.*))?&quot;);
 914     }
 915 
 916     /**
 917      * Returns a {@code SecureRandom} object that was selected by using
 918      * the algorithms/providers specified in the {@code
 919      * securerandom.strongAlgorithms} {@link Security} property.
 920      * &lt;p&gt;
 921      * Some situations require strong random values, such as when
 922      * creating high-value/long-lived secrets like RSA public/private
 923      * keys.  To help guide applications in selecting a suitable strong
 924      * {@code SecureRandom} implementation, Java distributions
 925      * include a list of known strong {@code SecureRandom}
 926      * implementations in the {@code securerandom.strongAlgorithms}
 927      * Security property.
 928      * &lt;p&gt;
 929      * Every implementation of the Java platform is required to
 930      * support at least one strong {@code SecureRandom} implementation.
 931      *
 932      * @return a strong {@code SecureRandom} implementation as indicated
 933      * by the {@code securerandom.strongAlgorithms} Security property
 934      *
 935      * @throws NoSuchAlgorithmException if no algorithm is available
 936      *
 937      * @see Security#getProperty(String)
 938      *
 939      * @since 1.8
 940      */
 941     public static SecureRandom getInstanceStrong()
 942             throws NoSuchAlgorithmException {
 943 
 944         String property = AccessController.doPrivileged(
 945             new PrivilegedAction&lt;&gt;() {
 946                 @Override
 947                 public String run() {
 948                     return Security.getProperty(
 949                         &quot;securerandom.strongAlgorithms&quot;);
 950                 }
 951             });
 952 
 953         if (property == null || property.isEmpty()) {
 954             throw new NoSuchAlgorithmException(
 955                 &quot;Null/empty securerandom.strongAlgorithms Security Property&quot;);
 956         }
 957 
 958         String remainder = property;
 959         while (remainder != null) {
 960             Matcher m;
 961             if ((m = StrongPatternHolder.pattern.matcher(
 962                     remainder)).matches()) {
 963 
 964                 String alg = m.group(1);
 965                 String prov = m.group(3);
 966 
 967                 try {
 968                     if (prov == null) {
 969                         return SecureRandom.getInstance(alg);
 970                     } else {
 971                         return SecureRandom.getInstance(alg, prov);
 972                     }
 973                 } catch (NoSuchAlgorithmException |
 974                         NoSuchProviderException e) {
 975                 }
 976                 remainder = m.group(5);
 977             } else {
 978                 remainder = null;
 979             }
 980         }
 981 
 982         throw new NoSuchAlgorithmException(
 983             &quot;No strong SecureRandom impls available: &quot; + property);
 984     }
 985 
 986     /**
 987      * Reseeds this {@code SecureRandom} with entropy input read from its
 988      * entropy source.
 989      *
 990      * @throws UnsupportedOperationException if the underlying provider
 991      *         implementation has not overridden this method.
 992      *
 993      * @since 9
 994      */
 995     public void reseed() {
 996         if (threadSafe) {
 997             secureRandomSpi.engineReseed(null);
 998         } else {
 999             synchronized (this) {
1000                 secureRandomSpi.engineReseed(null);
1001             }
1002         }
1003     }
1004 
1005     /**
1006      * Reseeds this {@code SecureRandom} with entropy input read from its
1007      * entropy source with additional parameters.
1008      * &lt;p&gt;
1009      * Note that entropy is obtained from an entropy source. While
1010      * some data in {@code params} may contain entropy, its main usage is to
1011      * provide diversity.
1012      *
1013      * @param params extra parameters
1014      * @throws UnsupportedOperationException if the underlying provider
1015      *         implementation has not overridden this method.
1016      * @throws IllegalArgumentException if {@code params} is {@code null},
1017      *         illegal or unsupported by this {@code SecureRandom}
1018      *
1019      * @since 9
1020      */
1021     public void reseed(SecureRandomParameters params) {
1022         if (params == null) {
1023             throw new IllegalArgumentException(&quot;params cannot be null&quot;);
1024         }
1025         if (threadSafe) {
1026             secureRandomSpi.engineReseed(params);
1027         } else {
1028             synchronized (this) {
1029                 secureRandomSpi.engineReseed(params);
1030             }
1031         }
1032     }
1033 
1034     // Declare serialVersionUID to be compatible with JDK1.1
1035     @java.io.Serial
1036     static final long serialVersionUID = 4940670005562187L;
1037 
1038     // Retain unused values serialized from JDK1.1
1039     /**
1040      * @serial
1041      */
1042     private byte[] state;
1043     /**
1044      * @serial
1045      */
1046     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
1047     private MessageDigest digest = null;
1048     /**
1049      * @serial
1050      *
1051      * We know that the MessageDigest class does not implement
1052      * java.io.Serializable.  However, since this field is no longer
1053      * used, it will always be NULL and won&#39;t affect the serialization
1054      * of the {@code SecureRandom} class itself.
1055      */
1056     private byte[] randomBytes;
1057     /**
1058      * @serial
1059      */
1060     private int randomBytesUsed;
1061     /**
1062      * @serial
1063      */
1064     private long counter;
1065 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/HttpConnectSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramSocketImplFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HttpRetryException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/HttpConnectSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.lang.reflect.Field;
 30 import java.lang.reflect.Method;
 31 import java.util.HashMap;
 32 import java.util.Map;
 33 import java.util.Set;
 34 
 35 /**
 36  * Basic SocketImpl that relies on the internal HTTP protocol handler
<span class="line-modified"> 37  * implementation to perform the HTTP tunneling and authentication. The</span>
<span class="line-modified"> 38  * sockets impl is swapped out and replaced with the socket from the HTTP</span>
<span class="line-removed"> 39  * handler after the tunnel is successfully setup.</span>
 40  *
 41  * @since 1.8
 42  */
 43 
<span class="line-modified"> 44 /*package*/ class HttpConnectSocketImpl extends PlainSocketImpl {</span>
 45 
 46     private static final String httpURLClazzStr =
 47                                   &quot;sun.net.www.protocol.http.HttpURLConnection&quot;;
 48     private static final String netClientClazzStr = &quot;sun.net.NetworkClient&quot;;
 49     private static final String doTunnelingStr = &quot;doTunneling&quot;;
 50     private static final Field httpField;
 51     private static final Field serverSocketField;
 52     private static final Method doTunneling;
 53 
 54     private final String server;

 55     private InetSocketAddress external_address;
 56     private HashMap&lt;Integer, Object&gt; optionsMap = new HashMap&lt;&gt;();
 57 
 58     static  {
 59         try {
 60             Class&lt;?&gt; httpClazz = Class.forName(httpURLClazzStr, true, null);
 61             httpField = httpClazz.getDeclaredField(&quot;http&quot;);
 62             doTunneling = httpClazz.getDeclaredMethod(doTunnelingStr);
 63             Class&lt;?&gt; netClientClazz = Class.forName(netClientClazzStr, true, null);
 64             serverSocketField = netClientClazz.getDeclaredField(&quot;serverSocket&quot;);
 65 
 66             java.security.AccessController.doPrivileged(
 67                 new java.security.PrivilegedAction&lt;&gt;() {
 68                     public Void run() {
 69                         httpField.setAccessible(true);
 70                         serverSocketField.setAccessible(true);
 71                         return null;
 72                 }
 73             });
 74         } catch (ReflectiveOperationException x) {
 75             throw new InternalError(&quot;Should not reach here&quot;, x);
 76         }
 77     }
 78 
<span class="line-modified"> 79     HttpConnectSocketImpl(String server, int port) {</span>
<span class="line-modified"> 80         this.server = server;</span>
<span class="line-modified"> 81         this.port = port;</span>
<span class="line-removed"> 82     }</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84     HttpConnectSocketImpl(Proxy proxy) {</span>
 85         SocketAddress a = proxy.address();
 86         if ( !(a instanceof InetSocketAddress) )
 87             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 88 
 89         InetSocketAddress ad = (InetSocketAddress) a;
 90         server = ad.getHostString();
 91         port = ad.getPort();
 92     }
 93 










 94     @Override
 95     protected void connect(SocketAddress endpoint, int timeout)
 96         throws IOException
 97     {
 98         if (endpoint == null || !(endpoint instanceof InetSocketAddress))
 99             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
100         final InetSocketAddress epoint = (InetSocketAddress)endpoint;
<span class="line-modified">101         final String destHost = epoint.isUnresolved() ? epoint.getHostName()</span>
<span class="line-modified">102                                                       : epoint.getAddress().getHostAddress();</span>
103         final int destPort = epoint.getPort();
104 
105         SecurityManager security = System.getSecurityManager();
106         if (security != null)
107             security.checkConnect(destHost, destPort);
108 



109         // Connect to the HTTP proxy server
110         String urlString = &quot;http://&quot; + destHost + &quot;:&quot; + destPort;
111         Socket httpSocket = privilegedDoTunnel(urlString, timeout);
112 
113         // Success!
114         external_address = epoint;
115 
116         // close the original socket impl and release its descriptor
117         close();
118 
119         // update the Sockets impl to the impl from the http Socket
<span class="line-modified">120         AbstractPlainSocketImpl psi = (AbstractPlainSocketImpl) httpSocket.impl;</span>
<span class="line-modified">121         this.getSocket().impl = psi;</span>
122 
123         // best effort is made to try and reset options previously set
124         Set&lt;Map.Entry&lt;Integer,Object&gt;&gt; options = optionsMap.entrySet();
125         try {
126             for(Map.Entry&lt;Integer,Object&gt; entry : options) {
<span class="line-modified">127                 psi.setOption(entry.getKey(), entry.getValue());</span>
128             }
129         } catch (IOException x) {  /* gulp! */  }
130     }
131 
















132     @Override
133     public void setOption(int opt, Object val) throws SocketException {
<span class="line-modified">134         super.setOption(opt, val);</span>
135 
136         if (external_address != null)
137             return;  // we&#39;re connected, just return
138 
139         // store options so that they can be re-applied to the impl after connect
140         optionsMap.put(opt, val);
141     }
142 
143     private Socket privilegedDoTunnel(final String urlString,
144                                       final int timeout)
145         throws IOException
146     {
147         try {
148             return java.security.AccessController.doPrivileged(
149                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
150                     public Socket run() throws IOException {
151                         return doTunnel(urlString, timeout);
152                 }
153             });
154         } catch (java.security.PrivilegedActionException pae) {
155             throw (IOException) pae.getException();
156         }
157     }
158 
159     private Socket doTunnel(String urlString, int connectTimeout)
160         throws IOException
161     {
162         Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(server, port));
163         URL destURL = new URL(urlString);
164         HttpURLConnection conn = (HttpURLConnection) destURL.openConnection(proxy);
165         conn.setConnectTimeout(connectTimeout);
<span class="line-modified">166         conn.setReadTimeout(this.timeout);</span>



167         conn.connect();
168         doTunneling(conn);
169         try {
170             Object httpClient = httpField.get(conn);
171             return (Socket) serverSocketField.get(httpClient);
172         } catch (IllegalAccessException x) {
173             throw new InternalError(&quot;Should not reach here&quot;, x);
174         }
175     }
176 
<span class="line-modified">177     private void doTunneling(HttpURLConnection conn) {</span>
178         try {
179             doTunneling.invoke(conn);
180         } catch (ReflectiveOperationException x) {




181             throw new InternalError(&quot;Should not reach here&quot;, x);
182         }
183     }
184 
185     @Override
186     protected InetAddress getInetAddress() {
187         if (external_address != null)
188             return external_address.getAddress();
189         else
<span class="line-modified">190             return super.getInetAddress();</span>
191     }
192 
193     @Override
194     protected int getPort() {
195         if (external_address != null)
196             return external_address.getPort();
197         else
<span class="line-modified">198             return super.getPort();</span>
199     }
200 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.lang.reflect.Field;
 30 import java.lang.reflect.Method;
 31 import java.util.HashMap;
 32 import java.util.Map;
 33 import java.util.Set;
 34 
 35 /**
 36  * Basic SocketImpl that relies on the internal HTTP protocol handler
<span class="line-modified"> 37  * implementation to perform the HTTP tunneling and authentication. Once</span>
<span class="line-modified"> 38  * connected, all socket operations delegate to a platform SocketImpl.</span>

 39  *
 40  * @since 1.8
 41  */
 42 
<span class="line-modified"> 43 /*package*/ class HttpConnectSocketImpl extends DelegatingSocketImpl {</span>
 44 
 45     private static final String httpURLClazzStr =
 46                                   &quot;sun.net.www.protocol.http.HttpURLConnection&quot;;
 47     private static final String netClientClazzStr = &quot;sun.net.NetworkClient&quot;;
 48     private static final String doTunnelingStr = &quot;doTunneling&quot;;
 49     private static final Field httpField;
 50     private static final Field serverSocketField;
 51     private static final Method doTunneling;
 52 
 53     private final String server;
<span class="line-added"> 54     private final Socket socket;</span>
 55     private InetSocketAddress external_address;
 56     private HashMap&lt;Integer, Object&gt; optionsMap = new HashMap&lt;&gt;();
 57 
 58     static  {
 59         try {
 60             Class&lt;?&gt; httpClazz = Class.forName(httpURLClazzStr, true, null);
 61             httpField = httpClazz.getDeclaredField(&quot;http&quot;);
 62             doTunneling = httpClazz.getDeclaredMethod(doTunnelingStr);
 63             Class&lt;?&gt; netClientClazz = Class.forName(netClientClazzStr, true, null);
 64             serverSocketField = netClientClazz.getDeclaredField(&quot;serverSocket&quot;);
 65 
 66             java.security.AccessController.doPrivileged(
 67                 new java.security.PrivilegedAction&lt;&gt;() {
 68                     public Void run() {
 69                         httpField.setAccessible(true);
 70                         serverSocketField.setAccessible(true);
 71                         return null;
 72                 }
 73             });
 74         } catch (ReflectiveOperationException x) {
 75             throw new InternalError(&quot;Should not reach here&quot;, x);
 76         }
 77     }
 78 
<span class="line-modified"> 79     HttpConnectSocketImpl(Proxy proxy, SocketImpl delegate, Socket socket) {</span>
<span class="line-modified"> 80         super(delegate);</span>
<span class="line-modified"> 81         this.socket = socket;</span>



 82         SocketAddress a = proxy.address();
 83         if ( !(a instanceof InetSocketAddress) )
 84             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 85 
 86         InetSocketAddress ad = (InetSocketAddress) a;
 87         server = ad.getHostString();
 88         port = ad.getPort();
 89     }
 90 
<span class="line-added"> 91     @Override</span>
<span class="line-added"> 92     protected void connect(String host, int port) throws IOException {</span>
<span class="line-added"> 93         connect(new InetSocketAddress(host, port), 0);</span>
<span class="line-added"> 94     }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     @Override</span>
<span class="line-added"> 97     protected void connect(InetAddress address, int port) throws IOException {</span>
<span class="line-added"> 98         connect(new InetSocketAddress(address, port), 0);</span>
<span class="line-added"> 99     }</span>
<span class="line-added">100 </span>
101     @Override
102     protected void connect(SocketAddress endpoint, int timeout)
103         throws IOException
104     {
105         if (endpoint == null || !(endpoint instanceof InetSocketAddress))
106             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
107         final InetSocketAddress epoint = (InetSocketAddress)endpoint;
<span class="line-modified">108         String destHost = epoint.isUnresolved() ? epoint.getHostName()</span>
<span class="line-modified">109                                                 : epoint.getAddress().getHostAddress();</span>
110         final int destPort = epoint.getPort();
111 
112         SecurityManager security = System.getSecurityManager();
113         if (security != null)
114             security.checkConnect(destHost, destPort);
115 
<span class="line-added">116         if (destHost.contains(&quot;:&quot;))</span>
<span class="line-added">117             destHost = &quot;[&quot; + destHost + &quot;]&quot;;</span>
<span class="line-added">118 </span>
119         // Connect to the HTTP proxy server
120         String urlString = &quot;http://&quot; + destHost + &quot;:&quot; + destPort;
121         Socket httpSocket = privilegedDoTunnel(urlString, timeout);
122 
123         // Success!
124         external_address = epoint;
125 
126         // close the original socket impl and release its descriptor
127         close();
128 
129         // update the Sockets impl to the impl from the http Socket
<span class="line-modified">130         SocketImpl si = httpSocket.impl;</span>
<span class="line-modified">131         socket.setImpl(si);</span>
132 
133         // best effort is made to try and reset options previously set
134         Set&lt;Map.Entry&lt;Integer,Object&gt;&gt; options = optionsMap.entrySet();
135         try {
136             for(Map.Entry&lt;Integer,Object&gt; entry : options) {
<span class="line-modified">137                 si.setOption(entry.getKey(), entry.getValue());</span>
138             }
139         } catch (IOException x) {  /* gulp! */  }
140     }
141 
<span class="line-added">142 </span>
<span class="line-added">143     @Override</span>
<span class="line-added">144     protected void listen(int backlog) {</span>
<span class="line-added">145         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">146     }</span>
<span class="line-added">147 </span>
<span class="line-added">148     @Override</span>
<span class="line-added">149     protected void accept(SocketImpl s) {</span>
<span class="line-added">150         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">151     }</span>
<span class="line-added">152 </span>
<span class="line-added">153     @Override</span>
<span class="line-added">154     void reset() {</span>
<span class="line-added">155         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">156     }</span>
<span class="line-added">157 </span>
158     @Override
159     public void setOption(int opt, Object val) throws SocketException {
<span class="line-modified">160         delegate.setOption(opt, val);</span>
161 
162         if (external_address != null)
163             return;  // we&#39;re connected, just return
164 
165         // store options so that they can be re-applied to the impl after connect
166         optionsMap.put(opt, val);
167     }
168 
169     private Socket privilegedDoTunnel(final String urlString,
170                                       final int timeout)
171         throws IOException
172     {
173         try {
174             return java.security.AccessController.doPrivileged(
175                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
176                     public Socket run() throws IOException {
177                         return doTunnel(urlString, timeout);
178                 }
179             });
180         } catch (java.security.PrivilegedActionException pae) {
181             throw (IOException) pae.getException();
182         }
183     }
184 
185     private Socket doTunnel(String urlString, int connectTimeout)
186         throws IOException
187     {
188         Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(server, port));
189         URL destURL = new URL(urlString);
190         HttpURLConnection conn = (HttpURLConnection) destURL.openConnection(proxy);
191         conn.setConnectTimeout(connectTimeout);
<span class="line-modified">192         int timeout = (int) getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-added">193         if (timeout &gt; 0) {</span>
<span class="line-added">194             conn.setReadTimeout(timeout);</span>
<span class="line-added">195         }</span>
196         conn.connect();
197         doTunneling(conn);
198         try {
199             Object httpClient = httpField.get(conn);
200             return (Socket) serverSocketField.get(httpClient);
201         } catch (IllegalAccessException x) {
202             throw new InternalError(&quot;Should not reach here&quot;, x);
203         }
204     }
205 
<span class="line-modified">206     private void doTunneling(HttpURLConnection conn) throws IOException {</span>
207         try {
208             doTunneling.invoke(conn);
209         } catch (ReflectiveOperationException x) {
<span class="line-added">210             Throwable cause = x.getCause();</span>
<span class="line-added">211             if (cause instanceof IOException) {</span>
<span class="line-added">212                 throw (IOException) cause;</span>
<span class="line-added">213             }</span>
214             throw new InternalError(&quot;Should not reach here&quot;, x);
215         }
216     }
217 
218     @Override
219     protected InetAddress getInetAddress() {
220         if (external_address != null)
221             return external_address.getAddress();
222         else
<span class="line-modified">223             return delegate.getInetAddress();</span>
224     }
225 
226     @Override
227     protected int getPort() {
228         if (external_address != null)
229             return external_address.getPort();
230         else
<span class="line-modified">231             return delegate.getPort();</span>
232     }
233 }
</pre>
</td>
</tr>
</table>
<center><a href="DatagramSocketImplFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="HttpRetryException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
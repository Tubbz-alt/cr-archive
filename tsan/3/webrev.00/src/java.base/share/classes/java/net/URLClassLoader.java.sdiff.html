<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/URLClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="URL.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLConnection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/URLClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import java.security.CodeSigner;
 36 import java.security.CodeSource;
 37 import java.security.Permission;
 38 import java.security.PermissionCollection;
 39 import java.security.PrivilegedAction;
 40 import java.security.PrivilegedExceptionAction;
 41 import java.security.SecureClassLoader;
 42 import java.util.Enumeration;
 43 import java.util.List;
 44 import java.util.NoSuchElementException;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.WeakHashMap;
 48 import java.util.jar.Attributes;
 49 import java.util.jar.Attributes.Name;
 50 import java.util.jar.JarFile;
 51 import java.util.jar.Manifest;
 52 
 53 import jdk.internal.loader.Resource;
 54 import jdk.internal.loader.URLClassPath;
<span class="line-removed"> 55 import jdk.internal.access.JavaNetURLClassLoaderAccess;</span>
 56 import jdk.internal.access.SharedSecrets;
 57 import jdk.internal.perf.PerfCounter;
 58 import sun.net.www.ParseUtil;
 59 import sun.security.util.SecurityConstants;
 60 
 61 /**
 62  * This class loader is used to load classes and resources from a search
 63  * path of URLs referring to both JAR files and directories. Any {@code jar:}
 64  * scheme URL (see {@link java.net.JarURLConnection}) is assumed to refer to a
 65  * JAR file.  Any {@code file:} scheme URL that ends with a &#39;/&#39; is assumed to
 66  * refer to a directory. Otherwise, the URL is assumed to refer to a JAR file
 67  * which will be opened as needed.
 68  * &lt;p&gt;
 69  * This class loader supports the loading of classes and resources from the
 70  * contents of a &lt;a href=&quot;../util/jar/JarFile.html#multirelease&quot;&gt;multi-release&lt;/a&gt;
 71  * JAR file that is referred to by a given URL.
 72  * &lt;p&gt;
 73  * The AccessControlContext of the thread that created the instance of
 74  * URLClassLoader will be used when subsequently loading classes and
 75  * resources.
</pre>
<hr />
<pre>
 83 public class URLClassLoader extends SecureClassLoader implements Closeable {
 84     /* The search path for classes and resources */
 85     private final URLClassPath ucp;
 86 
 87     /* The context to be used when loading classes and resources */
 88     private final AccessControlContext acc;
 89 
 90     /**
 91      * Constructs a new URLClassLoader for the given URLs. The URLs will be
 92      * searched in the order specified for classes and resources after first
 93      * searching in the specified parent class loader.  Any {@code jar:}
 94      * scheme URL is assumed to refer to a JAR file.  Any {@code file:} scheme
 95      * URL that ends with a &#39;/&#39; is assumed to refer to a directory.  Otherwise,
 96      * the URL is assumed to refer to a JAR file which will be downloaded and
 97      * opened as needed.
 98      *
 99      * &lt;p&gt;If there is a security manager, this method first
100      * calls the security manager&#39;s {@code checkCreateClassLoader} method
101      * to ensure creation of a class loader is allowed.
102      *
<span class="line-modified">103      * @param urls the URLs from which to load classes and resources</span>
<span class="line-modified">104      * @param parent the parent class loader for delegation</span>
<span class="line-modified">105      * @exception  SecurityException  if a security manager exists and its</span>
106      *             {@code checkCreateClassLoader} method doesn&#39;t allow
107      *             creation of a class loader.
<span class="line-modified">108      * @exception  NullPointerException if {@code urls} or any of its</span>
109      *             elements is {@code null}.
110      * @see SecurityManager#checkCreateClassLoader
111      */
112     public URLClassLoader(URL[] urls, ClassLoader parent) {
113         super(parent);
114         this.acc = AccessController.getContext();
115         this.ucp = new URLClassPath(urls, acc);
116     }
117 
118     URLClassLoader(String name, URL[] urls, ClassLoader parent,
119                    AccessControlContext acc) {
120         super(name, parent);
121         this.acc = acc;
122         this.ucp = new URLClassPath(urls, acc);
123     }
124 
125     /**
126      * Constructs a new URLClassLoader for the specified URLs using the
127      * default delegation parent {@code ClassLoader}. The URLs will
128      * be searched in the order specified for classes and resources after
129      * first searching in the parent class loader. Any URL that ends with
130      * a &#39;/&#39; is assumed to refer to a directory. Otherwise, the URL is
131      * assumed to refer to a JAR file which will be downloaded and opened
132      * as needed.
133      *
134      * &lt;p&gt;If there is a security manager, this method first
135      * calls the security manager&#39;s {@code checkCreateClassLoader} method
136      * to ensure creation of a class loader is allowed.
137      *
<span class="line-modified">138      * @param urls the URLs from which to load classes and resources</span>
139      *
<span class="line-modified">140      * @exception  SecurityException  if a security manager exists and its</span>
141      *             {@code checkCreateClassLoader} method doesn&#39;t allow
142      *             creation of a class loader.
<span class="line-modified">143      * @exception  NullPointerException if {@code urls} or any of its</span>
144      *             elements is {@code null}.
145      * @see SecurityManager#checkCreateClassLoader
146      */
147     public URLClassLoader(URL[] urls) {
148         super();
149         this.acc = AccessController.getContext();
150         this.ucp = new URLClassPath(urls, acc);
151     }
152 
153     URLClassLoader(URL[] urls, AccessControlContext acc) {
154         super();
155         this.acc = acc;
156         this.ucp = new URLClassPath(urls, acc);
157     }
158 
159     /**
160      * Constructs a new URLClassLoader for the specified URLs, parent
161      * class loader, and URLStreamHandlerFactory. The parent argument
162      * will be used as the parent class loader for delegation. The
163      * factory argument will be used as the stream handler factory to
164      * obtain protocol handlers when creating new jar URLs.
165      *
166      * &lt;p&gt;If there is a security manager, this method first
167      * calls the security manager&#39;s {@code checkCreateClassLoader} method
168      * to ensure creation of a class loader is allowed.
169      *
<span class="line-modified">170      * @param urls the URLs from which to load classes and resources</span>
<span class="line-modified">171      * @param parent the parent class loader for delegation</span>
<span class="line-modified">172      * @param factory the URLStreamHandlerFactory to use when creating URLs</span>
173      *
<span class="line-modified">174      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">175      *             {@code checkCreateClassLoader} method doesn&#39;t allow</span>
<span class="line-modified">176      *             creation of a class loader.</span>
<span class="line-modified">177      * @exception  NullPointerException if {@code urls} or any of its</span>
<span class="line-modified">178      *             elements is {@code null}.</span>
179      * @see SecurityManager#checkCreateClassLoader
180      */
181     public URLClassLoader(URL[] urls, ClassLoader parent,
182                           URLStreamHandlerFactory factory) {
183         super(parent);
184         this.acc = AccessController.getContext();
185         this.ucp = new URLClassPath(urls, factory, acc);
186     }
187 
188 
189     /**
190      * Constructs a new named {@code URLClassLoader} for the specified URLs.
191      * The URLs will be searched in the order specified for classes
192      * and resources after first searching in the specified parent class loader.
193      * Any URL that ends with a &#39;/&#39; is assumed to refer to a directory.
194      * Otherwise, the URL is assumed to refer to a JAR file which will be
195      * downloaded and opened as needed.
196      *
197      * @param  name class loader name; or {@code null} if not named
198      * @param  urls the URLs from which to load classes and resources
</pre>
<hr />
<pre>
310         }
311     }
312 
313    /**
314     * Closes this URLClassLoader, so that it can no longer be used to load
315     * new classes or resources that are defined by this loader.
316     * Classes and resources defined by any of this loader&#39;s parents in the
317     * delegation hierarchy are still accessible. Also, any classes or resources
318     * that are already loaded, are still accessible.
319     * &lt;p&gt;
320     * In the case of jar: and file: URLs, it also closes any files
321     * that were opened by it. If another thread is loading a
322     * class when the {@code close} method is invoked, then the result of
323     * that load is undefined.
324     * &lt;p&gt;
325     * The method makes a best effort attempt to close all opened files,
326     * by catching {@link IOException}s internally. Unchecked exceptions
327     * and errors are not caught. Calling close on an already closed
328     * loader has no effect.
329     *
<span class="line-modified">330     * @exception IOException if closing any file opened by this class loader</span>
331     * resulted in an IOException. Any such exceptions are caught internally.
332     * If only one is caught, then it is re-thrown. If more than one exception
333     * is caught, then the second and following exceptions are added
334     * as suppressed exceptions of the first one caught, which is then re-thrown.
335     *
<span class="line-modified">336     * @exception SecurityException if a security manager is set, and it denies</span>
337     *   {@link RuntimePermission}{@code (&quot;closeClassLoader&quot;)}
338     *
339     * @since 1.7
340     */
341     public void close() throws IOException {
342         SecurityManager security = System.getSecurityManager();
343         if (security != null) {
344             security.checkPermission(new RuntimePermission(&quot;closeClassLoader&quot;));
345         }
346         List&lt;IOException&gt; errors = ucp.closeLoaders();
347 
348         // now close any remaining streams.
349 
350         synchronized (closeables) {
351             Set&lt;Closeable&gt; keys = closeables.keySet();
352             for (Closeable c : keys) {
353                 try {
354                     c.close();
355                 } catch (IOException ioex) {
356                     errors.add(ioex);
</pre>
<hr />
<pre>
385      */
386     protected void addURL(URL url) {
387         ucp.addURL(url);
388     }
389 
390     /**
391      * Returns the search path of URLs for loading classes and resources.
392      * This includes the original list of URLs specified to the constructor,
393      * along with any URLs subsequently appended by the addURL() method.
394      * @return the search path of URLs for loading classes and resources.
395      */
396     public URL[] getURLs() {
397         return ucp.getURLs();
398     }
399 
400     /**
401      * Finds and loads the class with the specified name from the URL search
402      * path. Any URLs referring to JAR files are loaded and opened as needed
403      * until the class is found.
404      *
<span class="line-modified">405      * @param name the name of the class</span>
<span class="line-modified">406      * @return the resulting class</span>
<span class="line-modified">407      * @exception ClassNotFoundException if the class could not be found,</span>
408      *            or if the loader is closed.
<span class="line-modified">409      * @exception NullPointerException if {@code name} is {@code null}.</span>
410      */
411     protected Class&lt;?&gt; findClass(final String name)
412         throws ClassNotFoundException
413     {
414         final Class&lt;?&gt; result;
415         try {
416             result = AccessController.doPrivileged(
417                 new PrivilegedExceptionAction&lt;&gt;() {
418                     public Class&lt;?&gt; run() throws ClassNotFoundException {
419                         String path = name.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;.class&quot;);
420                         Resource res = ucp.getResource(path, false);
421                         if (res != null) {
422                             try {
423                                 return defineClass(name, res);
424                             } catch (IOException e) {
425                                 throw new ClassNotFoundException(name, e);
426                             }
427                         } else {
428                             return null;
429                         }
</pre>
<hr />
<pre>
612      */
613     public URL findResource(final String name) {
614         /*
615          * The same restriction to finding classes applies to resources
616          */
617         URL url = AccessController.doPrivileged(
618             new PrivilegedAction&lt;&gt;() {
619                 public URL run() {
620                     return ucp.findResource(name, true);
621                 }
622             }, acc);
623 
624         return url != null ? URLClassPath.checkURL(url) : null;
625     }
626 
627     /**
628      * Returns an Enumeration of URLs representing all of the resources
629      * on the URL search path having the specified name.
630      *
631      * @param name the resource name
<span class="line-modified">632      * @exception IOException if an I/O exception occurs</span>
633      * @return An {@code Enumeration} of {@code URL}s.
634      *         If the loader is closed, the Enumeration contains no elements.
635      */
636     public Enumeration&lt;URL&gt; findResources(final String name)
637         throws IOException
638     {
639         final Enumeration&lt;URL&gt; e = ucp.findResources(name, true);
640 
641         return new Enumeration&lt;&gt;() {
642             private URL url = null;
643 
644             private boolean next() {
645                 if (url != null) {
646                     return true;
647                 }
648                 do {
649                     URL u = AccessController.doPrivileged(
650                         new PrivilegedAction&lt;&gt;() {
651                             public URL run() {
652                                 if (!e.hasMoreElements())
</pre>
<hr />
<pre>
680      * Returns the permissions for the given codesource object.
681      * The implementation of this method first calls super.getPermissions
682      * and then adds permissions based on the URL of the codesource.
683      * &lt;p&gt;
684      * If the protocol of this URL is &quot;jar&quot;, then the permission granted
685      * is based on the permission that is required by the URL of the Jar
686      * file.
687      * &lt;p&gt;
688      * If the protocol is &quot;file&quot; and there is an authority component, then
689      * permission to connect to and accept connections from that authority
690      * may be granted. If the protocol is &quot;file&quot;
691      * and the path specifies a file, then permission to read that
692      * file is granted. If protocol is &quot;file&quot; and the path is
693      * a directory, permission is granted to read all files
694      * and (recursively) all files and subdirectories contained in
695      * that directory.
696      * &lt;p&gt;
697      * If the protocol is not &quot;file&quot;, then permission
698      * to connect to and accept connections from the URL&#39;s host is granted.
699      * @param codesource the codesource
<span class="line-modified">700      * @exception NullPointerException if {@code codesource} is {@code null}.</span>
701      * @return the permissions granted to the codesource
702      */
703     protected PermissionCollection getPermissions(CodeSource codesource)
704     {
705         PermissionCollection perms = super.getPermissions(codesource);
706 
707         URL url = codesource.getLocation();
708 
709         Permission p;
710         URLConnection urlConnection;
711 
712         try {
713             urlConnection = url.openConnection();
714             p = urlConnection.getPermission();
715         } catch (java.io.IOException ioe) {
716             p = null;
717             urlConnection = null;
718         }
719 
720         if (p instanceof FilePermission) {
</pre>
<hr />
<pre>
760                         sm.checkPermission(fp);
761                         return null;
762                     }
763                 }, acc);
764             }
765             perms.add(p);
766         }
767         return perms;
768     }
769 
770     /**
771      * Creates a new instance of URLClassLoader for the specified
772      * URLs and parent class loader. If a security manager is
773      * installed, the {@code loadClass} method of the URLClassLoader
774      * returned by this method will invoke the
775      * {@code SecurityManager.checkPackageAccess} method before
776      * loading the class.
777      *
778      * @param urls the URLs to search for classes and resources
779      * @param parent the parent class loader for delegation
<span class="line-modified">780      * @exception  NullPointerException if {@code urls} or any of its</span>
781      *             elements is {@code null}.
782      * @return the resulting class loader
783      */
784     public static URLClassLoader newInstance(final URL[] urls,
785                                              final ClassLoader parent) {
786         // Save the caller&#39;s context
787         final AccessControlContext acc = AccessController.getContext();
788         // Need a privileged block to create the class loader
789         URLClassLoader ucl = AccessController.doPrivileged(
790             new PrivilegedAction&lt;&gt;() {
791                 public URLClassLoader run() {
792                     return new FactoryURLClassLoader(null, urls, parent, acc);
793                 }
794             });
795         return ucl;
796     }
797 
798     /**
799      * Creates a new instance of URLClassLoader for the specified
800      * URLs and default parent class loader. If a security manager is
801      * installed, the {@code loadClass} method of the URLClassLoader
802      * returned by this method will invoke the
803      * {@code SecurityManager.checkPackageAccess} before
804      * loading the class.
805      *
806      * @param urls the URLs to search for classes and resources
<span class="line-modified">807      * @exception  NullPointerException if {@code urls} or any of its</span>
808      *             elements is {@code null}.
809      * @return the resulting class loader
810      */
811     public static URLClassLoader newInstance(final URL[] urls) {
812         // Save the caller&#39;s context
813         final AccessControlContext acc = AccessController.getContext();
814         // Need a privileged block to create the class loader
815         URLClassLoader ucl = AccessController.doPrivileged(
816             new PrivilegedAction&lt;&gt;() {
817                 public URLClassLoader run() {
818                     return new FactoryURLClassLoader(urls, acc);
819                 }
820             });
821         return ucl;
822     }
823 
824     static {
<span class="line-removed">825         SharedSecrets.setJavaNetURLClassLoaderAccess(</span>
<span class="line-removed">826             new JavaNetURLClassLoaderAccess() {</span>
<span class="line-removed">827                 @Override</span>
<span class="line-removed">828                 public AccessControlContext getAccessControlContext(URLClassLoader u) {</span>
<span class="line-removed">829                     return u.acc;</span>
<span class="line-removed">830                 }</span>
<span class="line-removed">831             }</span>
<span class="line-removed">832         );</span>
833         ClassLoader.registerAsParallelCapable();
834     }
835 }
836 
837 final class FactoryURLClassLoader extends URLClassLoader {
838 
839     static {
840         ClassLoader.registerAsParallelCapable();
841     }
842 
843     FactoryURLClassLoader(String name, URL[] urls, ClassLoader parent,
844                           AccessControlContext acc) {
845         super(name, urls, parent, acc);
846     }
847 
848     FactoryURLClassLoader(URL[] urls, AccessControlContext acc) {
849         super(urls, acc);
850     }
851 
852     public final Class&lt;?&gt; loadClass(String name, boolean resolve)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import java.security.CodeSigner;
 36 import java.security.CodeSource;
 37 import java.security.Permission;
 38 import java.security.PermissionCollection;
 39 import java.security.PrivilegedAction;
 40 import java.security.PrivilegedExceptionAction;
 41 import java.security.SecureClassLoader;
 42 import java.util.Enumeration;
 43 import java.util.List;
 44 import java.util.NoSuchElementException;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.WeakHashMap;
 48 import java.util.jar.Attributes;
 49 import java.util.jar.Attributes.Name;
 50 import java.util.jar.JarFile;
 51 import java.util.jar.Manifest;
 52 
 53 import jdk.internal.loader.Resource;
 54 import jdk.internal.loader.URLClassPath;

 55 import jdk.internal.access.SharedSecrets;
 56 import jdk.internal.perf.PerfCounter;
 57 import sun.net.www.ParseUtil;
 58 import sun.security.util.SecurityConstants;
 59 
 60 /**
 61  * This class loader is used to load classes and resources from a search
 62  * path of URLs referring to both JAR files and directories. Any {@code jar:}
 63  * scheme URL (see {@link java.net.JarURLConnection}) is assumed to refer to a
 64  * JAR file.  Any {@code file:} scheme URL that ends with a &#39;/&#39; is assumed to
 65  * refer to a directory. Otherwise, the URL is assumed to refer to a JAR file
 66  * which will be opened as needed.
 67  * &lt;p&gt;
 68  * This class loader supports the loading of classes and resources from the
 69  * contents of a &lt;a href=&quot;../util/jar/JarFile.html#multirelease&quot;&gt;multi-release&lt;/a&gt;
 70  * JAR file that is referred to by a given URL.
 71  * &lt;p&gt;
 72  * The AccessControlContext of the thread that created the instance of
 73  * URLClassLoader will be used when subsequently loading classes and
 74  * resources.
</pre>
<hr />
<pre>
 82 public class URLClassLoader extends SecureClassLoader implements Closeable {
 83     /* The search path for classes and resources */
 84     private final URLClassPath ucp;
 85 
 86     /* The context to be used when loading classes and resources */
 87     private final AccessControlContext acc;
 88 
 89     /**
 90      * Constructs a new URLClassLoader for the given URLs. The URLs will be
 91      * searched in the order specified for classes and resources after first
 92      * searching in the specified parent class loader.  Any {@code jar:}
 93      * scheme URL is assumed to refer to a JAR file.  Any {@code file:} scheme
 94      * URL that ends with a &#39;/&#39; is assumed to refer to a directory.  Otherwise,
 95      * the URL is assumed to refer to a JAR file which will be downloaded and
 96      * opened as needed.
 97      *
 98      * &lt;p&gt;If there is a security manager, this method first
 99      * calls the security manager&#39;s {@code checkCreateClassLoader} method
100      * to ensure creation of a class loader is allowed.
101      *
<span class="line-modified">102      * @param      urls the URLs from which to load classes and resources</span>
<span class="line-modified">103      * @param      parent the parent class loader for delegation</span>
<span class="line-modified">104      * @throws     SecurityException  if a security manager exists and its</span>
105      *             {@code checkCreateClassLoader} method doesn&#39;t allow
106      *             creation of a class loader.
<span class="line-modified">107      * @throws     NullPointerException if {@code urls} or any of its</span>
108      *             elements is {@code null}.
109      * @see SecurityManager#checkCreateClassLoader
110      */
111     public URLClassLoader(URL[] urls, ClassLoader parent) {
112         super(parent);
113         this.acc = AccessController.getContext();
114         this.ucp = new URLClassPath(urls, acc);
115     }
116 
117     URLClassLoader(String name, URL[] urls, ClassLoader parent,
118                    AccessControlContext acc) {
119         super(name, parent);
120         this.acc = acc;
121         this.ucp = new URLClassPath(urls, acc);
122     }
123 
124     /**
125      * Constructs a new URLClassLoader for the specified URLs using the
126      * default delegation parent {@code ClassLoader}. The URLs will
127      * be searched in the order specified for classes and resources after
128      * first searching in the parent class loader. Any URL that ends with
129      * a &#39;/&#39; is assumed to refer to a directory. Otherwise, the URL is
130      * assumed to refer to a JAR file which will be downloaded and opened
131      * as needed.
132      *
133      * &lt;p&gt;If there is a security manager, this method first
134      * calls the security manager&#39;s {@code checkCreateClassLoader} method
135      * to ensure creation of a class loader is allowed.
136      *
<span class="line-modified">137      * @param      urls the URLs from which to load classes and resources</span>
138      *
<span class="line-modified">139      * @throws     SecurityException  if a security manager exists and its</span>
140      *             {@code checkCreateClassLoader} method doesn&#39;t allow
141      *             creation of a class loader.
<span class="line-modified">142      * @throws     NullPointerException if {@code urls} or any of its</span>
143      *             elements is {@code null}.
144      * @see SecurityManager#checkCreateClassLoader
145      */
146     public URLClassLoader(URL[] urls) {
147         super();
148         this.acc = AccessController.getContext();
149         this.ucp = new URLClassPath(urls, acc);
150     }
151 
152     URLClassLoader(URL[] urls, AccessControlContext acc) {
153         super();
154         this.acc = acc;
155         this.ucp = new URLClassPath(urls, acc);
156     }
157 
158     /**
159      * Constructs a new URLClassLoader for the specified URLs, parent
160      * class loader, and URLStreamHandlerFactory. The parent argument
161      * will be used as the parent class loader for delegation. The
162      * factory argument will be used as the stream handler factory to
163      * obtain protocol handlers when creating new jar URLs.
164      *
165      * &lt;p&gt;If there is a security manager, this method first
166      * calls the security manager&#39;s {@code checkCreateClassLoader} method
167      * to ensure creation of a class loader is allowed.
168      *
<span class="line-modified">169      * @param  urls the URLs from which to load classes and resources</span>
<span class="line-modified">170      * @param  parent the parent class loader for delegation</span>
<span class="line-modified">171      * @param  factory the URLStreamHandlerFactory to use when creating URLs</span>
172      *
<span class="line-modified">173      * @throws SecurityException  if a security manager exists and its</span>
<span class="line-modified">174      *         {@code checkCreateClassLoader} method doesn&#39;t allow</span>
<span class="line-modified">175      *         creation of a class loader.</span>
<span class="line-modified">176      * @throws NullPointerException if {@code urls} or any of its</span>
<span class="line-modified">177      *         elements is {@code null}.</span>
178      * @see SecurityManager#checkCreateClassLoader
179      */
180     public URLClassLoader(URL[] urls, ClassLoader parent,
181                           URLStreamHandlerFactory factory) {
182         super(parent);
183         this.acc = AccessController.getContext();
184         this.ucp = new URLClassPath(urls, factory, acc);
185     }
186 
187 
188     /**
189      * Constructs a new named {@code URLClassLoader} for the specified URLs.
190      * The URLs will be searched in the order specified for classes
191      * and resources after first searching in the specified parent class loader.
192      * Any URL that ends with a &#39;/&#39; is assumed to refer to a directory.
193      * Otherwise, the URL is assumed to refer to a JAR file which will be
194      * downloaded and opened as needed.
195      *
196      * @param  name class loader name; or {@code null} if not named
197      * @param  urls the URLs from which to load classes and resources
</pre>
<hr />
<pre>
309         }
310     }
311 
312    /**
313     * Closes this URLClassLoader, so that it can no longer be used to load
314     * new classes or resources that are defined by this loader.
315     * Classes and resources defined by any of this loader&#39;s parents in the
316     * delegation hierarchy are still accessible. Also, any classes or resources
317     * that are already loaded, are still accessible.
318     * &lt;p&gt;
319     * In the case of jar: and file: URLs, it also closes any files
320     * that were opened by it. If another thread is loading a
321     * class when the {@code close} method is invoked, then the result of
322     * that load is undefined.
323     * &lt;p&gt;
324     * The method makes a best effort attempt to close all opened files,
325     * by catching {@link IOException}s internally. Unchecked exceptions
326     * and errors are not caught. Calling close on an already closed
327     * loader has no effect.
328     *
<span class="line-modified">329     * @throws    IOException if closing any file opened by this class loader</span>
330     * resulted in an IOException. Any such exceptions are caught internally.
331     * If only one is caught, then it is re-thrown. If more than one exception
332     * is caught, then the second and following exceptions are added
333     * as suppressed exceptions of the first one caught, which is then re-thrown.
334     *
<span class="line-modified">335     * @throws    SecurityException if a security manager is set, and it denies</span>
336     *   {@link RuntimePermission}{@code (&quot;closeClassLoader&quot;)}
337     *
338     * @since 1.7
339     */
340     public void close() throws IOException {
341         SecurityManager security = System.getSecurityManager();
342         if (security != null) {
343             security.checkPermission(new RuntimePermission(&quot;closeClassLoader&quot;));
344         }
345         List&lt;IOException&gt; errors = ucp.closeLoaders();
346 
347         // now close any remaining streams.
348 
349         synchronized (closeables) {
350             Set&lt;Closeable&gt; keys = closeables.keySet();
351             for (Closeable c : keys) {
352                 try {
353                     c.close();
354                 } catch (IOException ioex) {
355                     errors.add(ioex);
</pre>
<hr />
<pre>
384      */
385     protected void addURL(URL url) {
386         ucp.addURL(url);
387     }
388 
389     /**
390      * Returns the search path of URLs for loading classes and resources.
391      * This includes the original list of URLs specified to the constructor,
392      * along with any URLs subsequently appended by the addURL() method.
393      * @return the search path of URLs for loading classes and resources.
394      */
395     public URL[] getURLs() {
396         return ucp.getURLs();
397     }
398 
399     /**
400      * Finds and loads the class with the specified name from the URL search
401      * path. Any URLs referring to JAR files are loaded and opened as needed
402      * until the class is found.
403      *
<span class="line-modified">404      * @param     name the name of the class</span>
<span class="line-modified">405      * @return    the resulting class</span>
<span class="line-modified">406      * @throws    ClassNotFoundException if the class could not be found,</span>
407      *            or if the loader is closed.
<span class="line-modified">408      * @throws    NullPointerException if {@code name} is {@code null}.</span>
409      */
410     protected Class&lt;?&gt; findClass(final String name)
411         throws ClassNotFoundException
412     {
413         final Class&lt;?&gt; result;
414         try {
415             result = AccessController.doPrivileged(
416                 new PrivilegedExceptionAction&lt;&gt;() {
417                     public Class&lt;?&gt; run() throws ClassNotFoundException {
418                         String path = name.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;.class&quot;);
419                         Resource res = ucp.getResource(path, false);
420                         if (res != null) {
421                             try {
422                                 return defineClass(name, res);
423                             } catch (IOException e) {
424                                 throw new ClassNotFoundException(name, e);
425                             }
426                         } else {
427                             return null;
428                         }
</pre>
<hr />
<pre>
611      */
612     public URL findResource(final String name) {
613         /*
614          * The same restriction to finding classes applies to resources
615          */
616         URL url = AccessController.doPrivileged(
617             new PrivilegedAction&lt;&gt;() {
618                 public URL run() {
619                     return ucp.findResource(name, true);
620                 }
621             }, acc);
622 
623         return url != null ? URLClassPath.checkURL(url) : null;
624     }
625 
626     /**
627      * Returns an Enumeration of URLs representing all of the resources
628      * on the URL search path having the specified name.
629      *
630      * @param name the resource name
<span class="line-modified">631      * @throws    IOException if an I/O exception occurs</span>
632      * @return An {@code Enumeration} of {@code URL}s.
633      *         If the loader is closed, the Enumeration contains no elements.
634      */
635     public Enumeration&lt;URL&gt; findResources(final String name)
636         throws IOException
637     {
638         final Enumeration&lt;URL&gt; e = ucp.findResources(name, true);
639 
640         return new Enumeration&lt;&gt;() {
641             private URL url = null;
642 
643             private boolean next() {
644                 if (url != null) {
645                     return true;
646                 }
647                 do {
648                     URL u = AccessController.doPrivileged(
649                         new PrivilegedAction&lt;&gt;() {
650                             public URL run() {
651                                 if (!e.hasMoreElements())
</pre>
<hr />
<pre>
679      * Returns the permissions for the given codesource object.
680      * The implementation of this method first calls super.getPermissions
681      * and then adds permissions based on the URL of the codesource.
682      * &lt;p&gt;
683      * If the protocol of this URL is &quot;jar&quot;, then the permission granted
684      * is based on the permission that is required by the URL of the Jar
685      * file.
686      * &lt;p&gt;
687      * If the protocol is &quot;file&quot; and there is an authority component, then
688      * permission to connect to and accept connections from that authority
689      * may be granted. If the protocol is &quot;file&quot;
690      * and the path specifies a file, then permission to read that
691      * file is granted. If protocol is &quot;file&quot; and the path is
692      * a directory, permission is granted to read all files
693      * and (recursively) all files and subdirectories contained in
694      * that directory.
695      * &lt;p&gt;
696      * If the protocol is not &quot;file&quot;, then permission
697      * to connect to and accept connections from the URL&#39;s host is granted.
698      * @param codesource the codesource
<span class="line-modified">699      * @throws    NullPointerException if {@code codesource} is {@code null}.</span>
700      * @return the permissions granted to the codesource
701      */
702     protected PermissionCollection getPermissions(CodeSource codesource)
703     {
704         PermissionCollection perms = super.getPermissions(codesource);
705 
706         URL url = codesource.getLocation();
707 
708         Permission p;
709         URLConnection urlConnection;
710 
711         try {
712             urlConnection = url.openConnection();
713             p = urlConnection.getPermission();
714         } catch (java.io.IOException ioe) {
715             p = null;
716             urlConnection = null;
717         }
718 
719         if (p instanceof FilePermission) {
</pre>
<hr />
<pre>
759                         sm.checkPermission(fp);
760                         return null;
761                     }
762                 }, acc);
763             }
764             perms.add(p);
765         }
766         return perms;
767     }
768 
769     /**
770      * Creates a new instance of URLClassLoader for the specified
771      * URLs and parent class loader. If a security manager is
772      * installed, the {@code loadClass} method of the URLClassLoader
773      * returned by this method will invoke the
774      * {@code SecurityManager.checkPackageAccess} method before
775      * loading the class.
776      *
777      * @param urls the URLs to search for classes and resources
778      * @param parent the parent class loader for delegation
<span class="line-modified">779      * @throws     NullPointerException if {@code urls} or any of its</span>
780      *             elements is {@code null}.
781      * @return the resulting class loader
782      */
783     public static URLClassLoader newInstance(final URL[] urls,
784                                              final ClassLoader parent) {
785         // Save the caller&#39;s context
786         final AccessControlContext acc = AccessController.getContext();
787         // Need a privileged block to create the class loader
788         URLClassLoader ucl = AccessController.doPrivileged(
789             new PrivilegedAction&lt;&gt;() {
790                 public URLClassLoader run() {
791                     return new FactoryURLClassLoader(null, urls, parent, acc);
792                 }
793             });
794         return ucl;
795     }
796 
797     /**
798      * Creates a new instance of URLClassLoader for the specified
799      * URLs and default parent class loader. If a security manager is
800      * installed, the {@code loadClass} method of the URLClassLoader
801      * returned by this method will invoke the
802      * {@code SecurityManager.checkPackageAccess} before
803      * loading the class.
804      *
805      * @param urls the URLs to search for classes and resources
<span class="line-modified">806      * @throws     NullPointerException if {@code urls} or any of its</span>
807      *             elements is {@code null}.
808      * @return the resulting class loader
809      */
810     public static URLClassLoader newInstance(final URL[] urls) {
811         // Save the caller&#39;s context
812         final AccessControlContext acc = AccessController.getContext();
813         // Need a privileged block to create the class loader
814         URLClassLoader ucl = AccessController.doPrivileged(
815             new PrivilegedAction&lt;&gt;() {
816                 public URLClassLoader run() {
817                     return new FactoryURLClassLoader(urls, acc);
818                 }
819             });
820         return ucl;
821     }
822 
823     static {








824         ClassLoader.registerAsParallelCapable();
825     }
826 }
827 
828 final class FactoryURLClassLoader extends URLClassLoader {
829 
830     static {
831         ClassLoader.registerAsParallelCapable();
832     }
833 
834     FactoryURLClassLoader(String name, URL[] urls, ClassLoader parent,
835                           AccessControlContext acc) {
836         super(name, urls, parent, acc);
837     }
838 
839     FactoryURLClassLoader(URL[] urls, AccessControlContext acc) {
840         super(urls, acc);
841     }
842 
843     public final Class&lt;?&gt; loadClass(String name, boolean resolve)
</pre>
</td>
</tr>
</table>
<center><a href="URL.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLConnection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
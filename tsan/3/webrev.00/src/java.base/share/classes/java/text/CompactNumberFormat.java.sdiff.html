<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/CompactNumberFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Collator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormat.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/CompactNumberFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.text;
  26 
  27 import java.io.IOException;
  28 import java.io.InvalidObjectException;
  29 import java.io.ObjectInputStream;
  30 import java.math.BigDecimal;
  31 import java.math.BigInteger;
  32 import java.math.RoundingMode;
  33 import java.util.ArrayList;
  34 import java.util.Arrays;

  35 import java.util.List;
  36 import java.util.Locale;

  37 import java.util.Objects;
  38 import java.util.concurrent.atomic.AtomicInteger;
  39 import java.util.concurrent.atomic.AtomicLong;




  40 
  41 
  42 /**
  43  * &lt;p&gt;
  44  * {@code CompactNumberFormat} is a concrete subclass of {@code NumberFormat}
  45  * that formats a decimal number in its compact form.
  46  *
  47  * The compact number formatting is designed for the environment where the space
  48  * is limited, and the formatted string can be displayed in that limited space.
  49  * It is defined by LDML&#39;s specification for
  50  * &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats&quot;&gt;
  51  * Compact Number Formats&lt;/a&gt;. A compact number formatting refers
  52  * to the representation of a number in a shorter form, based on the patterns
  53  * provided for a given locale.
  54  *
  55  * &lt;p&gt;
  56  * For example:
  57  * &lt;br&gt;In the {@link java.util.Locale#US US locale}, {@code 1000} can be formatted
  58  * as {@code &quot;1K&quot;}, and {@code 1000000} as {@code &quot;1M&quot;}, depending upon the
  59  * &lt;a href = &quot;#compact_number_style&quot; &gt;style&lt;/a&gt; used.
  60  * &lt;br&gt;In the {@code &quot;hi_IN&quot;} locale, {@code 1000} can be formatted as
  61  * &quot;1 \u0939\u091C\u093C\u093E\u0930&quot;, and {@code 50000000} as &quot;5 \u0915.&quot;,
  62  * depending upon the &lt;a href = &quot;#compact_number_style&quot; &gt;style&lt;/a&gt; used.
  63  *
  64  * &lt;p&gt;
  65  * To obtain a {@code CompactNumberFormat} for a locale, use one
  66  * of the factory methods given by {@code NumberFormat} for compact number
  67  * formatting. For example,
  68  * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.
  69  *
  70  * &lt;blockquote&gt;&lt;pre&gt;
  71  * NumberFormat fmt = NumberFormat.getCompactNumberInstance(
  72  *                             new Locale(&quot;hi&quot;, &quot;IN&quot;), NumberFormat.Style.SHORT);
  73  * String result = fmt.format(1000);
  74  * &lt;/pre&gt;&lt;/blockquote&gt;
  75  *
<span class="line-modified">  76  * &lt;h3&gt;&lt;a id=&quot;compact_number_style&quot;&gt;Style&lt;/a&gt;&lt;/h3&gt;</span>
  77  * &lt;p&gt;
  78  * A number can be formatted in the compact forms with two different
  79  * styles, {@link NumberFormat.Style#SHORT SHORT}
  80  * and {@link NumberFormat.Style#LONG LONG}. Use
  81  * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and
  82  * parsing a number in {@link NumberFormat.Style#SHORT SHORT} or
  83  * {@link NumberFormat.Style#LONG LONG} compact form,
  84  * where the given {@code Style} parameter requests the desired
  85  * format. A {@link NumberFormat.Style#SHORT SHORT} style
  86  * compact number instance in the {@link java.util.Locale#US US locale} formats
  87  * {@code 10000} as {@code &quot;10K&quot;}. However, a
  88  * {@link NumberFormat.Style#LONG LONG} style instance in same locale
  89  * formats {@code 10000} as {@code &quot;10 thousand&quot;}.
  90  *
<span class="line-modified">  91  * &lt;h3&gt;&lt;a id=&quot;compact_number_patterns&quot;&gt;Compact Number Patterns&lt;/a&gt;&lt;/h3&gt;</span>
  92  * &lt;p&gt;
  93  * The compact number patterns are represented in a series of patterns where each
  94  * pattern is used to format a range of numbers. An example of
  95  * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns
  96  * for the {@link java.util.Locale#US US locale} is {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;,
  97  * &quot;00K&quot;, &quot;000K&quot;, &quot;0M&quot;, &quot;00M&quot;, &quot;000M&quot;, &quot;0B&quot;, &quot;00B&quot;, &quot;000B&quot;, &quot;0T&quot;, &quot;00T&quot;, &quot;000T&quot;}},
  98  * ranging from {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt; to {@code 10}&lt;sup&gt;{@code 14}&lt;/sup&gt;.
  99  * There can be any number of patterns and they are
 100  * strictly index based starting from the range {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;.
 101  * For example, in the above patterns, pattern at index 3
 102  * ({@code &quot;0K&quot;}) is used for formatting {@code number &gt;= 1000 and number &lt; 10000},
 103  * pattern at index 4 ({@code &quot;00K&quot;}) is used for formatting
 104  * {@code number &gt;= 10000 and number &lt; 100000} and so on. In most of the locales,
 105  * patterns with the range
 106  * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 2}&lt;/sup&gt; are empty
 107  * strings, which implicitly means a special pattern {@code &quot;0&quot;}.
 108  * A special pattern {@code &quot;0&quot;} is used for any range which does not contain
 109  * a compact pattern. This special pattern can appear explicitly for any specific
 110  * range, or considered as a default pattern for an empty string.
<span class="line-removed"> 111  * &lt;p&gt;</span>
<span class="line-removed"> 112  * A compact pattern has the following syntax:</span>
<span class="line-removed"> 113  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-removed"> 114  * &lt;i&gt;Pattern:&lt;/i&gt;</span>
<span class="line-removed"> 115  *         &lt;i&gt;PositivePattern&lt;/i&gt;</span>
<span class="line-removed"> 116  *         &lt;i&gt;PositivePattern&lt;/i&gt; &lt;i&gt;[; NegativePattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed"> 117  * &lt;i&gt;PositivePattern:&lt;/i&gt;</span>
<span class="line-removed"> 118  *         &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed"> 119  * &lt;i&gt;NegativePattern:&lt;/i&gt;</span>
<span class="line-removed"> 120  *        &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed"> 121  * &lt;i&gt;Prefix:&lt;/i&gt;</span>
<span class="line-removed"> 122  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-removed"> 123  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;</span>
<span class="line-removed"> 124  * &lt;i&gt;Suffix:&lt;/i&gt;</span>
<span class="line-removed"> 125  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-removed"> 126  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;</span>
<span class="line-removed"> 127  * &lt;i&gt;MinimumInteger:&lt;/i&gt;</span>
<span class="line-removed"> 128  *      0</span>
<span class="line-removed"> 129  *      0 &lt;i&gt;MinimumInteger&lt;/i&gt;</span>
<span class="line-removed"> 130  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
 131  *

 132  * A compact pattern contains a positive and negative subpattern
 133  * separated by a subpattern boundary character {@code &#39;;&#39; (U+003B)},
 134  * for example, {@code &quot;0K;-0K&quot;}. Each subpattern has a prefix,
 135  * minimum integer digits, and suffix. The negative subpattern
 136  * is optional, if absent, then the positive subpattern prefixed with the
 137  * minus sign ({@code &#39;-&#39; U+002D HYPHEN-MINUS}) is used as the negative
 138  * subpattern. That is, {@code &quot;0K&quot;} alone is equivalent to {@code &quot;0K;-0K&quot;}.
 139  * If there is an explicit negative subpattern, it serves only to specify
 140  * the negative prefix and suffix. The number of minimum integer digits,
 141  * and other characteristics are all the same as the positive pattern.
 142  * That means that {@code &quot;0K;-00K&quot;} produces precisely the same behavior
 143  * as {@code &quot;0K;-0K&quot;}.
 144  *
 145  * &lt;p&gt;
 146  * Many characters in a compact pattern are taken literally, they are matched
 147  * during parsing and output unchanged during formatting.
 148  * &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;Special characters&lt;/a&gt;,
 149  * on the other hand, stand for other characters, strings, or classes of
 150  * characters. They must be quoted, using single quote {@code &#39; (U+0027)}
 151  * unless noted otherwise, if they are to appear in the prefix or suffix
 152  * as literals. For example, 0\u0915&#39;.&#39;.
 153  *
<span class="line-modified"> 154  * &lt;h3&gt;Formatting&lt;/h3&gt;</span>










































 155  * The default formatting behavior returns a formatted string with no fractional
 156  * digits, however users can use the {@link #setMinimumFractionDigits(int)}
 157  * method to include the fractional part.
 158  * The number {@code 1000.0} or {@code 1000} is formatted as {@code &quot;1K&quot;}
 159  * not {@code &quot;1.00K&quot;} (in the {@link java.util.Locale#US US locale}). For this
 160  * reason, the patterns provided for formatting contain only the minimum
 161  * integer digits, prefix and/or suffix, but no fractional part.
 162  * For example, patterns used are {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, 0K, 00K, ...}}. If the pattern
 163  * selected for formatting a number is {@code &quot;0&quot;} (special pattern),
 164  * either explicit or defaulted, then the general number formatting provided by
 165  * {@link java.text.DecimalFormat DecimalFormat}
 166  * for the specified locale is used.
 167  *
<span class="line-modified"> 168  * &lt;h3&gt;Parsing&lt;/h3&gt;</span>
 169  * The default parsing behavior does not allow a grouping separator until
 170  * grouping used is set to {@code true} by using
 171  * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part
 172  * depends on the {@link #isParseIntegerOnly()}. For example, if the
 173  * parse integer only is set to true, then the fractional part is skipped.
 174  *
<span class="line-modified"> 175  * &lt;h3&gt;Rounding&lt;/h3&gt;</span>
 176  * {@code CompactNumberFormat} provides rounding modes defined in
 177  * {@link java.math.RoundingMode} for formatting.  By default, it uses
 178  * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
 179  *
 180  * @see CompactNumberFormat.Style
 181  * @see NumberFormat
 182  * @see DecimalFormat
 183  * @since 12
 184  */
 185 public final class CompactNumberFormat extends NumberFormat {
 186 

 187     private static final long serialVersionUID = 7128367218649234678L;
 188 
 189     /**
 190      * The patterns for compact form of numbers for this
 191      * {@code CompactNumberFormat}. A possible example is
 192      * {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;, &quot;00K&quot;, &quot;000K&quot;, &quot;0M&quot;, &quot;00M&quot;, &quot;000M&quot;, &quot;0B&quot;,
 193      * &quot;00B&quot;, &quot;000B&quot;, &quot;0T&quot;, &quot;00T&quot;, &quot;000T&quot;}} ranging from
 194      * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 14}&lt;/sup&gt;,
 195      * where each pattern is used to format a range of numbers.
 196      * For example, {@code &quot;0K&quot;} is used for formatting
 197      * {@code number &gt;= 1000 and number &lt; 10000}, {@code &quot;00K&quot;} is used for
 198      * formatting {@code number &gt;= 10000 and number &lt; 100000} and so on.
 199      * This field must not be {@code null}.
 200      *
 201      * @serial
 202      */
 203     private String[] compactPatterns;
 204 
 205     /**
 206      * List of positive prefix patterns of this formatter&#39;s
 207      * compact number patterns.
 208      */
<span class="line-modified"> 209     private transient List&lt;String&gt; positivePrefixPatterns;</span>
 210 
 211     /**
 212      * List of negative prefix patterns of this formatter&#39;s
 213      * compact number patterns.
 214      */
<span class="line-modified"> 215     private transient List&lt;String&gt; negativePrefixPatterns;</span>
 216 
 217     /**
 218      * List of positive suffix patterns of this formatter&#39;s
 219      * compact number patterns.
 220      */
<span class="line-modified"> 221     private transient List&lt;String&gt; positiveSuffixPatterns;</span>
 222 
 223     /**
 224      * List of negative suffix patterns of this formatter&#39;s
 225      * compact number patterns.
 226      */
<span class="line-modified"> 227     private transient List&lt;String&gt; negativeSuffixPatterns;</span>
 228 
 229     /**
 230      * List of divisors of this formatter&#39;s compact number patterns.
 231      * Divisor can be either Long or BigInteger (if the divisor value goes
 232      * beyond long boundary)
 233      */
 234     private transient List&lt;Number&gt; divisors;
 235 
 236     /**
 237      * The {@code DecimalFormatSymbols} object used by this format.
 238      * It contains the symbols used to format numbers. For example,
 239      * the grouping separator, decimal separator, and so on.
 240      * This field must not be {@code null}.
 241      *
 242      * @serial
 243      * @see DecimalFormatSymbols
 244      */
 245     private DecimalFormatSymbols symbols;
 246 
 247     /**
</pre>
<hr />
<pre>
 280      * @serial
 281      */
 282     private byte groupingSize = 0;
 283 
 284     /**
 285      * Returns whether the {@link #parse(String, ParsePosition)}
 286      * method returns {@code BigDecimal}.
 287      *
 288      * @serial
 289      */
 290     private boolean parseBigDecimal = false;
 291 
 292     /**
 293      * The {@code RoundingMode} used in this compact number format.
 294      * This field must not be {@code null}.
 295      *
 296      * @serial
 297      */
 298     private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
 299 




















 300     /**
 301      * Special pattern used for compact numbers
 302      */
 303     private static final String SPECIAL_PATTERN = &quot;0&quot;;
 304 
 305     /**
 306      * Multiplier for compact pattern range. In
 307      * the list compact patterns each compact pattern
 308      * specify the range with the multiplication factor of 10
 309      * of its previous compact pattern range.
 310      * For example, 10^0, 10^1, 10^2, 10^3, 10^4...
 311      *
 312      */
 313     private static final int RANGE_MULTIPLIER = 10;
 314 
 315     /**
 316      * Creates a {@code CompactNumberFormat} using the given decimal pattern,
 317      * decimal format symbols and compact patterns.
 318      * To obtain the instance of {@code CompactNumberFormat} with the standard
 319      * compact patterns for a {@code Locale} and {@code Style},
 320      * it is recommended to use the factory methods given by
 321      * {@code NumberFormat} for compact number formatting. For example,
 322      * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.
 323      *
 324      * @param decimalPattern a decimal pattern for general number formatting
 325      * @param symbols the set of symbols to be used
 326      * @param compactPatterns an array of
 327      *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;
 328      *        compact number patterns&lt;/a&gt;
 329      * @throws NullPointerException if any of the given arguments is
<span class="line-modified"> 330      *                                 {@code null}</span>
 331      * @throws IllegalArgumentException if the given {@code decimalPattern} or the
<span class="line-modified"> 332      *                     {@code compactPatterns} array contains an invalid pattern</span>
<span class="line-modified"> 333      *                     or if a {@code null} appears in the array of compact</span>
<span class="line-modified"> 334      *                     patterns</span>

































 335      * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)
 336      * @see DecimalFormatSymbols

 337      */
 338     public CompactNumberFormat(String decimalPattern,
<span class="line-modified"> 339             DecimalFormatSymbols symbols, String[] compactPatterns) {</span>

 340 
 341         Objects.requireNonNull(decimalPattern, &quot;decimalPattern&quot;);
 342         Objects.requireNonNull(symbols, &quot;symbols&quot;);
 343         Objects.requireNonNull(compactPatterns, &quot;compactPatterns&quot;);

 344 
 345         this.symbols = symbols;
 346         // Instantiating the DecimalFormat with &quot;0&quot; pattern; this acts just as a
 347         // basic pattern; the properties (For example, prefix/suffix)
 348         // are later computed based on the compact number formatting process.
 349         decimalFormat = new DecimalFormat(SPECIAL_PATTERN, this.symbols);
 350 
 351         // Initializing the super class state with the decimalFormat values
 352         // to represent this CompactNumberFormat.
 353         // For setting the digits counts, use overridden setXXX methods of this
 354         // CompactNumberFormat, as it performs check with the max range allowed
 355         // for compact number formatting
 356         setMaximumIntegerDigits(decimalFormat.getMaximumIntegerDigits());
 357         setMinimumIntegerDigits(decimalFormat.getMinimumIntegerDigits());
 358         setMaximumFractionDigits(decimalFormat.getMaximumFractionDigits());
 359         setMinimumFractionDigits(decimalFormat.getMinimumFractionDigits());
 360 
 361         super.setGroupingUsed(decimalFormat.isGroupingUsed());
 362         super.setParseIntegerOnly(decimalFormat.isParseIntegerOnly());
 363 
 364         this.compactPatterns = compactPatterns;
 365 
 366         // DecimalFormat used for formatting numbers with special pattern &quot;0&quot;.
 367         // Formatting is delegated to the DecimalFormat&#39;s number formatting
 368         // with no fraction digits
 369         this.decimalPattern = decimalPattern;
 370         defaultDecimalFormat = new DecimalFormat(this.decimalPattern,
 371                 this.symbols);
 372         defaultDecimalFormat.setMaximumFractionDigits(0);



 373         // Process compact patterns to extract the prefixes, suffixes and
 374         // divisors
 375         processCompactPatterns();
 376     }
 377 
 378     /**
 379      * Formats a number to produce a string representing its compact form.
 380      * The number can be of any subclass of {@link java.lang.Number}.
 381      * @param number     the number to format
 382      * @param toAppendTo the {@code StringBuffer} to which the formatted
 383      *                   text is to be appended
 384      * @param fieldPosition    keeps track on the position of the field within
 385      *                         the returned string. For example, for formatting
 386      *                         a number {@code 123456789} in the
 387      *                         {@link java.util.Locale#US US locale},
 388      *                         if the given {@code fieldPosition} is
 389      *                         {@link NumberFormat#INTEGER_FIELD}, the begin
 390      *                         index and end index of {@code fieldPosition}
 391      *                         will be set to 0 and 3, respectively for the
 392      *                         output string {@code 123M}. Similarly, positions
</pre>
<hr />
<pre>
 476 
 477         nanOrInfinity = decimalFormat.handleInfinity(number, result, delegate, isNegative);
 478         if (nanOrInfinity) {
 479             return result;
 480         }
 481 
 482         // Round the double value with min fraction digits, the integer
 483         // part of the rounded value is used for matching the compact
 484         // number pattern
 485         // For example, if roundingMode is HALF_UP with min fraction
 486         // digits = 0, the number 999.6 should round up
 487         // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
 488         DigitList dList = new DigitList();
 489         dList.setRoundingMode(getRoundingMode());
 490         number = isNegative ? -number : number;
 491         dList.set(isNegative, number, getMinimumFractionDigits());
 492 
 493         double roundedNumber = dList.getDouble();
 494         int compactDataIndex = selectCompactPattern((long) roundedNumber);
 495         if (compactDataIndex != -1) {
<span class="line-modified"> 496             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 497                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified"> 498             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 499                     : positiveSuffixPatterns.get(compactDataIndex);</span>
 500 
 501             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 502                 appendPrefix(result, prefix, delegate);
<span class="line-removed"> 503                 long divisor = (Long) divisors.get(compactDataIndex);</span>
 504                 roundedNumber = roundedNumber / divisor;
 505                 decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());
 506                 decimalFormat.subformatNumber(result, delegate, isNegative,
 507                         false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
 508                         getMaximumFractionDigits(), getMinimumFractionDigits());
 509                 appendSuffix(result, suffix, delegate);
 510             } else {
 511                 defaultDecimalFormat.doubleSubformat(number, result, delegate, isNegative);
 512             }
 513         } else {
 514             defaultDecimalFormat.doubleSubformat(number, result, delegate, isNegative);
 515         }
 516         return result;
 517     }
 518 
 519     /**
 520      * Formats a long to produce a string representing its compact form.
 521      * @param number    the long number to format
 522      * @param result    where the text is to be appended
 523      * @param fieldPosition    keeps track on the position of the field within
</pre>
<hr />
<pre>
 544             FieldPosition fieldPosition) {
 545 
 546         fieldPosition.setBeginIndex(0);
 547         fieldPosition.setEndIndex(0);
 548         return format(number, result, fieldPosition.getFieldDelegate());
 549     }
 550 
 551     private StringBuffer format(long number, StringBuffer result, FieldDelegate delegate) {
 552         boolean isNegative = (number &lt; 0);
 553         if (isNegative) {
 554             number = -number;
 555         }
 556 
 557         if (number &lt; 0) { // LONG_MIN
 558             BigInteger bigIntegerValue = BigInteger.valueOf(number);
 559             return format(bigIntegerValue, result, delegate, true);
 560         }
 561 
 562         int compactDataIndex = selectCompactPattern(number);
 563         if (compactDataIndex != -1) {
<span class="line-modified"> 564             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 565                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified"> 566             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 567                     : positiveSuffixPatterns.get(compactDataIndex);</span>
 568             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 569                 appendPrefix(result, prefix, delegate);
<span class="line-removed"> 570                 long divisor = (Long) divisors.get(compactDataIndex);</span>
 571                 if ((number % divisor == 0)) {
 572                     number = number / divisor;
 573                     decimalFormat.setDigitList(number, isNegative, 0);
 574                     decimalFormat.subformatNumber(result, delegate,
 575                             isNegative, true, getMaximumIntegerDigits(),
 576                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 577                             getMinimumFractionDigits());
 578                 } else {
 579                     // To avoid truncation of fractional part store
 580                     // the value in double and follow double path instead of
 581                     // long path
 582                     double dNumber = (double) number / divisor;
 583                     decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());
 584                     decimalFormat.subformatNumber(result, delegate,
 585                             isNegative, false, getMaximumIntegerDigits(),
 586                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 587                             getMinimumFractionDigits());
 588                 }
 589                 appendSuffix(result, suffix, delegate);
 590             } else {
</pre>
<hr />
<pre>
 631     }
 632 
 633     private StringBuffer format(BigDecimal number, StringBuffer result,
 634             FieldDelegate delegate) {
 635 
 636         boolean isNegative = number.signum() == -1;
 637         if (isNegative) {
 638             number = number.negate();
 639         }
 640 
 641         // Round the value with min fraction digits, the integer
 642         // part of the rounded value is used for matching the compact
 643         // number pattern
 644         // For example, If roundingMode is HALF_UP with min fraction digits = 0,
 645         // the number 999.6 should round up
 646         // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
 647         number = number.setScale(getMinimumFractionDigits(), getRoundingMode());
 648 
 649         int compactDataIndex;
 650         if (number.toBigInteger().bitLength() &lt; 64) {
<span class="line-modified"> 651             compactDataIndex = selectCompactPattern(number.toBigInteger().longValue());</span>

 652         } else {
 653             compactDataIndex = selectCompactPattern(number.toBigInteger());
 654         }
 655 
 656         if (compactDataIndex != -1) {
<span class="line-modified"> 657             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 658                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified"> 659             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 660                     : positiveSuffixPatterns.get(compactDataIndex);</span>
 661             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 662                 appendPrefix(result, prefix, delegate);
<span class="line-removed"> 663                 Number divisor = divisors.get(compactDataIndex);</span>
 664                 number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());
 665                 decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());
 666                 decimalFormat.subformatNumber(result, delegate, isNegative,
 667                         false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
 668                         getMaximumFractionDigits(), getMinimumFractionDigits());
 669                 appendSuffix(result, suffix, delegate);
 670             } else {
 671                 number = isNegative ? number.negate() : number;
 672                 defaultDecimalFormat.format(number, result, delegate);
 673             }
 674         } else {
 675             number = isNegative ? number.negate() : number;
 676             defaultDecimalFormat.format(number, result, delegate);
 677         }
 678         return result;
 679     }
 680 
 681     /**
 682      * Formats a BigInteger to produce a string representing its compact form.
 683      * @param number    the BigInteger number to format
</pre>
<hr />
<pre>
 703      */
 704     private StringBuffer format(BigInteger number, StringBuffer result,
 705             FieldPosition fieldPosition) {
 706 
 707         Objects.requireNonNull(number);
 708         fieldPosition.setBeginIndex(0);
 709         fieldPosition.setEndIndex(0);
 710         return format(number, result, fieldPosition.getFieldDelegate(), false);
 711     }
 712 
 713     private StringBuffer format(BigInteger number, StringBuffer result,
 714             FieldDelegate delegate, boolean formatLong) {
 715 
 716         boolean isNegative = number.signum() == -1;
 717         if (isNegative) {
 718             number = number.negate();
 719         }
 720 
 721         int compactDataIndex = selectCompactPattern(number);
 722         if (compactDataIndex != -1) {
<span class="line-modified"> 723             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 724                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified"> 725             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified"> 726                     : positiveSuffixPatterns.get(compactDataIndex);</span>
 727             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 728                 appendPrefix(result, prefix, delegate);
<span class="line-removed"> 729                 Number divisor = divisors.get(compactDataIndex);</span>
 730                 if (number.mod(new BigInteger(divisor.toString()))
 731                         .compareTo(BigInteger.ZERO) == 0) {
 732                     number = number.divide(new BigInteger(divisor.toString()));
 733 
 734                     decimalFormat.setDigitList(number, isNegative, 0);
 735                     decimalFormat.subformatNumber(result, delegate,
 736                             isNegative, true, getMaximumIntegerDigits(),
 737                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 738                             getMinimumFractionDigits());
 739                 } else {
 740                     // To avoid truncation of fractional part store the value in
 741                     // BigDecimal and follow BigDecimal path instead of
 742                     // BigInteger path
 743                     BigDecimal nDecimal = new BigDecimal(number)
 744                             .divide(new BigDecimal(divisor.toString()), getRoundingMode());
 745                     decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());
 746                     decimalFormat.subformatNumber(result, delegate,
 747                             isNegative, false, getMaximumIntegerDigits(),
 748                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 749                             getMinimumFractionDigits());
 750                 }
 751                 appendSuffix(result, suffix, delegate);
 752             } else {
 753                 number = isNegative ? number.negate() : number;
 754                 defaultDecimalFormat.format(number, result, delegate, formatLong);
 755             }
 756         } else {
 757             number = isNegative ? number.negate() : number;
 758             defaultDecimalFormat.format(number, result, delegate, formatLong);
 759         }
 760         return result;
 761     }
 762 












 763     /**
 764      * Appends the {@code prefix} to the {@code result} and also set the
 765      * {@code NumberFormat.Field.SIGN} and {@code NumberFormat.Field.PREFIX}
 766      * field positions.
 767      * @param result the resulting string, where the pefix is to be appended
 768      * @param prefix prefix to append
 769      * @param delegate notified of the locations of
 770      *                 {@code NumberFormat.Field.SIGN} and
 771      *                 {@code NumberFormat.Field.PREFIX} fields
 772      */
 773     private void appendPrefix(StringBuffer result, String prefix,
 774             FieldDelegate delegate) {
 775         append(result, expandAffix(prefix), delegate,
 776                 getFieldPositions(prefix, NumberFormat.Field.PREFIX));
 777     }
 778 
 779     /**
 780      * Appends {@code suffix} to the {@code result} and also set the
 781      * {@code NumberFormat.Field.SIGN} and {@code NumberFormat.Field.SUFFIX}
 782      * field positions.
</pre>
<hr />
<pre>
 819 
 820     /**
 821      * Expands an affix {@code pattern} into a string of literals.
 822      * All characters in the pattern are literals unless prefixed by QUOTE.
 823      * The character prefixed by QUOTE is replaced with its respective
 824      * localized literal.
 825      * @param pattern a compact number pattern affix
 826      * @return an expanded affix
 827      */
 828     private String expandAffix(String pattern) {
 829         // Return if no quoted character exists
 830         if (pattern.indexOf(QUOTE) &lt; 0) {
 831             return pattern;
 832         }
 833         StringBuilder sb = new StringBuilder();
 834         for (int index = 0; index &lt; pattern.length();) {
 835             char ch = pattern.charAt(index++);
 836             if (ch == QUOTE) {
 837                 ch = pattern.charAt(index++);
 838                 if (ch == MINUS_SIGN) {
<span class="line-modified"> 839                     ch = symbols.getMinusSign();</span>

 840                 }
 841             }
 842             sb.append(ch);
 843         }
 844         return sb.toString();
 845     }
 846 
 847     /**
 848      * Returns a list of {@code FieldPostion} in the given {@code pattern}.
 849      * @param pattern the pattern to be parsed for {@code FieldPosition}
 850      * @param field whether a PREFIX or SUFFIX field
 851      * @return a list of {@code FieldPostion}
 852      */
 853     private List&lt;FieldPosition&gt; getFieldPositions(String pattern, Field field) {
 854         List&lt;FieldPosition&gt; positions = new ArrayList&lt;&gt;();
 855         StringBuilder affix = new StringBuilder();
 856         int stringIndex = 0;
 857         for (int index = 0; index &lt; pattern.length();) {
 858             char ch = pattern.charAt(index++);
 859             if (ch == QUOTE) {
 860                 ch = pattern.charAt(index++);
 861                 if (ch == MINUS_SIGN) {
<span class="line-modified"> 862                     ch = symbols.getMinusSign();</span>
 863                     FieldPosition fp = new FieldPosition(NumberFormat.Field.SIGN);
 864                     fp.setBeginIndex(stringIndex);
<span class="line-modified"> 865                     fp.setEndIndex(stringIndex + 1);</span>
 866                     positions.add(fp);



 867                 }
 868             }
 869             stringIndex++;
 870             affix.append(ch);
 871         }
 872         if (affix.length() != 0) {
 873             FieldPosition fp = new FieldPosition(field);
 874             fp.setBeginIndex(0);
 875             fp.setEndIndex(affix.length());
 876             positions.add(fp);
 877         }
 878         return positions;
 879     }
 880 
 881     /**
 882      * Select the index of the matched compact number pattern for
 883      * the given {@code long} {@code number}.
 884      *
 885      * @param number number to be formatted
 886      * @return index of matched compact pattern;
</pre>
<hr />
<pre>
1020             } else {
1021                 long longValue = (long) matchedValue;
1022                 if (longValue &lt; (long) Math.pow(RANGE_MULTIPLIER, count)) {
1023                     throw new IllegalArgumentException(&quot;Invalid Pattern&quot;
1024                             + &quot; [&quot; + compactPatterns[patternIndex]
1025                             + &quot;]: min integer digits specified exceeds the limit&quot;
1026                             + &quot; for the index &quot; + patternIndex);
1027                 }
1028                 divisor = longValue / (long) Math.pow(RANGE_MULTIPLIER, count);
1029             }
1030         }
1031         return divisor;
1032     }
1033 
1034     /**
1035      * Process the series of compact patterns to compute the
1036      * series of prefixes, suffixes and their respective divisor
1037      * value.
1038      *
1039      */




1040     private void processCompactPatterns() {
1041         int size = compactPatterns.length;
1042         positivePrefixPatterns = new ArrayList&lt;&gt;(size);
1043         negativePrefixPatterns = new ArrayList&lt;&gt;(size);
1044         positiveSuffixPatterns = new ArrayList&lt;&gt;(size);
1045         negativeSuffixPatterns = new ArrayList&lt;&gt;(size);
1046         divisors = new ArrayList&lt;&gt;(size);
1047 
1048         for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1049             applyPattern(compactPatterns[index], index);</span>









































1050         }
1051     }
1052 































1053     /**
1054      * Process a compact pattern at a specific {@code index}
1055      * @param pattern the compact pattern to be processed
1056      * @param index index in the array of compact patterns
1057      *
1058      */
<span class="line-modified">1059     private void applyPattern(String pattern, int index) {</span>
1060 
1061         if (pattern == null) {
1062             throw new IllegalArgumentException(&quot;A null compact pattern&quot; +
1063                     &quot; encountered at index: &quot; + index);
1064         }
1065 
1066         int start = 0;
1067         boolean gotNegative = false;
1068 
1069         String positivePrefix = &quot;&quot;;
1070         String positiveSuffix = &quot;&quot;;
1071         String negativePrefix = &quot;&quot;;
1072         String negativeSuffix = &quot;&quot;;
1073         String zeros = &quot;&quot;;
1074         for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {
1075 
1076             StringBuffer prefix = new StringBuffer();
1077             StringBuffer suffix = new StringBuffer();
1078             boolean inQuote = false;
1079             // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
</pre>
<hr />
<pre>
1214             // If there is no negative pattern, or if the negative pattern is
1215             // identical to the positive pattern, then prepend the minus sign to
1216             // the positive pattern to form the negative pattern.
1217             if (!gotNegative
1218                     || (negativePrefix.equals(positivePrefix)
1219                     &amp;&amp; negativeSuffix.equals(positiveSuffix))) {
1220                 negativeSuffix = positiveSuffix;
1221                 negativePrefix = &quot;&#39;-&quot; + positivePrefix;
1222             }
1223         }
1224 
1225         // If no 0s are specified in a non empty pattern, it is invalid
1226         if (!pattern.isEmpty() &amp;&amp; zeros.isEmpty()) {
1227             throw new IllegalArgumentException(&quot;Invalid pattern&quot;
1228                     + &quot; [&quot; + pattern + &quot;]: all patterns must include digit&quot;
1229                     + &quot; placement 0s&quot;);
1230         }
1231 
1232         // Only if positive affix exists; else put empty strings
1233         if (!positivePrefix.isEmpty() || !positiveSuffix.isEmpty()) {
<span class="line-modified">1234             positivePrefixPatterns.add(positivePrefix);</span>
<span class="line-modified">1235             negativePrefixPatterns.add(negativePrefix);</span>
<span class="line-modified">1236             positiveSuffixPatterns.add(positiveSuffix);</span>
<span class="line-modified">1237             negativeSuffixPatterns.add(negativeSuffix);</span>
<span class="line-modified">1238             divisors.add(computeDivisor(zeros, index));</span>


1239         } else {
<span class="line-modified">1240             positivePrefixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">1241             negativePrefixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">1242             positiveSuffixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">1243             negativeSuffixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">1244             divisors.add(1L);</span>


1245         }
1246     }
1247 
1248     private final transient DigitList digitList = new DigitList();
1249     private static final int STATUS_INFINITE = 0;
1250     private static final int STATUS_POSITIVE = 1;
1251     private static final int STATUS_LENGTH   = 2;
1252 
1253     private static final char ZERO_DIGIT = &#39;0&#39;;
1254     private static final char DIGIT = &#39;#&#39;;
1255     private static final char DECIMAL_SEPARATOR = &#39;.&#39;;
1256     private static final char GROUPING_SEPARATOR = &#39;,&#39;;
1257     private static final char MINUS_SIGN = &#39;-&#39;;
1258     private static final char PERCENT = &#39;%&#39;;
1259     private static final char PER_MILLE = &#39;\u2030&#39;;
1260     private static final char SEPARATOR = &#39;;&#39;;
1261     private static final char CURRENCY_SIGN = &#39;\u00A4&#39;;
1262     private static final char QUOTE = &#39;\&#39;&#39;;
1263 
1264     // Expanded form of positive/negative prefix/suffix,
1265     // the expanded form contains special characters in
1266     // its localized form, which are used for matching
1267     // while parsing a string to number
<span class="line-modified">1268     private transient List&lt;String&gt; positivePrefixes;</span>
<span class="line-modified">1269     private transient List&lt;String&gt; negativePrefixes;</span>
<span class="line-modified">1270     private transient List&lt;String&gt; positiveSuffixes;</span>
<span class="line-modified">1271     private transient List&lt;String&gt; negativeSuffixes;</span>
1272 
1273     private void expandAffixPatterns() {
1274         positivePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
1275         negativePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
1276         positiveSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
1277         negativeSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
1278         for (int index = 0; index &lt; compactPatterns.length; index++) {
<span class="line-modified">1279             positivePrefixes.add(expandAffix(positivePrefixPatterns.get(index)));</span>
<span class="line-modified">1280             negativePrefixes.add(expandAffix(negativePrefixPatterns.get(index)));</span>
<span class="line-modified">1281             positiveSuffixes.add(expandAffix(positiveSuffixPatterns.get(index)));</span>
<span class="line-modified">1282             negativeSuffixes.add(expandAffix(negativeSuffixPatterns.get(index)));</span>
1283         }
1284     }
1285 
1286     /**
1287      * Parses a compact number from a string to produce a {@code Number}.
1288      * &lt;p&gt;
1289      * The method attempts to parse text starting at the index given by
1290      * {@code pos}.
1291      * If parsing succeeds, then the index of {@code pos} is updated
1292      * to the index after the last character used (parsing does not necessarily
1293      * use all characters up to the end of the string), and the parsed
1294      * number is returned. The updated {@code pos} can be used to
1295      * indicate the starting point for the next call to this method.
1296      * If an error occurs, then the index of {@code pos} is not
1297      * changed, the error index of {@code pos} is set to the index of
1298      * the character where the error occurred, and {@code null} is returned.
1299      * &lt;p&gt;
1300      * The value is the numeric part in the given text multiplied
1301      * by the numeric equivalent of the affix attached
1302      * (For example, &quot;K&quot; = 1000 in {@link java.util.Locale#US US locale}).
</pre>
<hr />
<pre>
1320      *     and positive infinity and NaN are returned as {@code Double}
1321      *     instances holding the values of the corresponding
1322      *     {@code Double} constants.
1323      * &lt;/ul&gt;
1324      * &lt;p&gt;
1325      * {@code CompactNumberFormat} parses all Unicode characters that represent
1326      * decimal digits, as defined by {@code Character.digit()}. In
1327      * addition, {@code CompactNumberFormat} also recognizes as digits the ten
1328      * consecutive characters starting with the localized zero digit defined in
1329      * the {@code DecimalFormatSymbols} object.
1330      * &lt;p&gt;
1331      * {@code CompactNumberFormat} parse does not allow parsing scientific
1332      * notations. For example, parsing a string {@code &quot;1.05E4K&quot;} in
1333      * {@link java.util.Locale#US US locale} breaks at character &#39;E&#39;
1334      * and returns 1.05.
1335      *
1336      * @param text the string to be parsed
1337      * @param pos  a {@code ParsePosition} object with index and error
1338      *             index information as described above
1339      * @return the parsed value, or {@code null} if the parse fails
<span class="line-modified">1340      * @exception  NullPointerException if {@code text} or</span>
1341      *             {@code pos} is null
1342      *
1343      */
1344     @Override
1345     public Number parse(String text, ParsePosition pos) {
1346 
1347         Objects.requireNonNull(text);
1348         Objects.requireNonNull(pos);
1349 
1350         // Lazily expanding the affix patterns, on the first parse
1351         // call on this instance
1352         // If not initialized, expand and load all affixes
1353         if (positivePrefixes == null) {
1354             expandAffixPatterns();
1355         }
1356 
1357         // The compact number multiplier for parsed string.
1358         // Its value is set on parsing prefix and suffix. For example,
1359         // in the {@link java.util.Locale#US US locale} parsing {@code &quot;1K&quot;}
1360         // sets its value to 1000, as K (thousand) is abbreviated form of 1000.
1361         Number cnfMultiplier = 1L;
1362 
1363         // Special case NaN
1364         if (text.regionMatches(pos.index, symbols.getNaN(),
1365                 0, symbols.getNaN().length())) {
1366             pos.index = pos.index + symbols.getNaN().length();
1367             return Double.NaN;
1368         }
1369 
1370         int position = pos.index;
1371         int oldStart = pos.index;
1372         boolean gotPositive = false;
1373         boolean gotNegative = false;
1374         int matchedPosIndex = -1;
1375         int matchedNegIndex = -1;
1376         String matchedPosPrefix = &quot;&quot;;
1377         String matchedNegPrefix = &quot;&quot;;
1378         String defaultPosPrefix = defaultDecimalFormat.getPositivePrefix();
1379         String defaultNegPrefix = defaultDecimalFormat.getNegativePrefix();


1380         // Prefix matching
1381         for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">1382             String positivePrefix = positivePrefixes.get(compactIndex);</span>
<span class="line-modified">1383             String negativePrefix = negativePrefixes.get(compactIndex);</span>
1384 
1385             // Do not break if a match occur; there is a possibility that the
1386             // subsequent affixes may match the longer subsequence in the given
1387             // string.
1388             // For example, matching &quot;Mdx 3&quot; with &quot;M&quot;, &quot;Md&quot; as prefix should
1389             // match with &quot;Md&quot;
1390             boolean match = matchAffix(text, position, positivePrefix,
1391                     defaultPosPrefix, matchedPosPrefix);
1392             if (match) {
1393                 matchedPosIndex = compactIndex;
1394                 matchedPosPrefix = positivePrefix;
1395                 gotPositive = true;
1396             }
1397 
1398             match = matchAffix(text, position, negativePrefix,
1399                     defaultNegPrefix, matchedNegPrefix);
1400             if (match) {
1401                 matchedNegIndex = compactIndex;
1402                 matchedNegPrefix = negativePrefix;
1403                 gotNegative = true;
</pre>
<hr />
<pre>
1465                 &amp;&amp; text.charAt(position) == symbols.getDecimalSeparator()) {
1466             position++; // Pass decimal character
1467             for (; position &lt; text.length(); ++position) {
1468                 char ch = text.charAt(position);
1469                 int digit = ch - symbols.getZeroDigit();
1470                 if (digit &lt; 0 || digit &gt; 9) {
1471                     digit = Character.digit(ch, 10);
1472                     // Parse all digit characters
1473                     if (!(digit &gt;= 0 &amp;&amp; digit &lt;= 9)) {
1474                         break;
1475                     }
1476                 }
1477             }
1478         }
1479 
1480         // Number parsed successfully; match prefix and
1481         // suffix to obtain multiplier
1482         pos.index = position;
1483         Number multiplier = computeParseMultiplier(text, pos,
1484                 gotPositive ? matchedPosPrefix : matchedNegPrefix,
<span class="line-modified">1485                 status, gotPositive, gotNegative);</span>
1486 
1487         if (multiplier.longValue() == -1L) {
1488             return null;
1489         } else if (multiplier.longValue() != 1L) {
1490             cnfMultiplier = multiplier;
1491         }
1492 
1493         // Special case INFINITY
1494         if (status[STATUS_INFINITE]) {
1495             if (status[STATUS_POSITIVE]) {
1496                 return Double.POSITIVE_INFINITY;
1497             } else {
1498                 return Double.NEGATIVE_INFINITY;
1499             }
1500         }
1501 
1502         if (isParseBigDecimal()) {
1503             BigDecimal bigDecimalResult = digitList.getBigDecimal();
1504 
1505             if (cnfMultiplier.longValue() != 1) {
</pre>
<hr />
<pre>
1507                         .multiply(new BigDecimal(cnfMultiplier.toString()));
1508             }
1509             if (!status[STATUS_POSITIVE]) {
1510                 bigDecimalResult = bigDecimalResult.negate();
1511             }
1512             return bigDecimalResult;
1513         } else {
1514             Number cnfResult;
1515             if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {
1516                 long longResult = digitList.getLong();
1517                 cnfResult = generateParseResult(longResult, false,
1518                         longResult &lt; 0, status, cnfMultiplier);
1519             } else {
1520                 cnfResult = generateParseResult(digitList.getDouble(),
1521                         true, false, status, cnfMultiplier);
1522             }
1523             return cnfResult;
1524         }
1525     }
1526 



























1527     /**
1528      * Returns the parsed result by multiplying the parsed number
1529      * with the multiplier representing the prefix and suffix.
1530      *
1531      * @param number parsed number component
1532      * @param gotDouble whether the parsed number contains decimal
1533      * @param gotLongMin whether the parsed number is Long.MIN
1534      * @param status boolean status flags indicating whether the
1535      *               value is infinite and whether it is positive
1536      * @param cnfMultiplier compact number multiplier
1537      * @return parsed result
1538      */
1539     private Number generateParseResult(Number number, boolean gotDouble,
1540             boolean gotLongMin, boolean[] status, Number cnfMultiplier) {
1541 
1542         if (gotDouble) {
1543             if (cnfMultiplier.longValue() != 1L) {
1544                 double doubleResult = number.doubleValue() * cnfMultiplier.doubleValue();
1545                 doubleResult = (double) convertIfNegative(doubleResult, status, gotLongMin);
1546                 // Check if a double can be represeneted as a long
</pre>
<hr />
<pre>
1642     }
1643 
1644     /**
1645      * Computes multiplier by matching the given {@code matchedPrefix}
1646      * and suffix in the specified {@code text} from the lists of
1647      * prefixes and suffixes extracted from compact patterns.
1648      *
1649      * @param text the string to parse
1650      * @param parsePosition the {@code ParsePosition} object representing the
1651      *                      index and error index of the parse string
1652      * @param matchedPrefix prefix extracted which needs to be matched to
1653      *                      obtain the multiplier
1654      * @param status upon return contains boolean status flags indicating
1655      *               whether the value is positive
1656      * @param gotPositive based on the prefix parsed; whether the number is positive
1657      * @param gotNegative based on the prefix parsed; whether the number is negative
1658      * @return the multiplier matching the prefix and suffix; -1 otherwise
1659      */
1660     private Number computeParseMultiplier(String text, ParsePosition parsePosition,
1661             String matchedPrefix, boolean[] status, boolean gotPositive,
<span class="line-modified">1662             boolean gotNegative) {</span>
1663 
1664         int position = parsePosition.index;
1665         boolean gotPos = false;
1666         boolean gotNeg = false;
1667         int matchedPosIndex = -1;
1668         int matchedNegIndex = -1;
1669         String matchedPosSuffix = &quot;&quot;;
1670         String matchedNegSuffix = &quot;&quot;;
1671         for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">1672             String positivePrefix = positivePrefixes.get(compactIndex);</span>
<span class="line-modified">1673             String negativePrefix = negativePrefixes.get(compactIndex);</span>
<span class="line-modified">1674             String positiveSuffix = positiveSuffixes.get(compactIndex);</span>
<span class="line-modified">1675             String negativeSuffix = negativeSuffixes.get(compactIndex);</span>
1676 
1677             // Do not break if a match occur; there is a possibility that the
1678             // subsequent affixes may match the longer subsequence in the given
1679             // string.
1680             // For example, matching &quot;3Mdx&quot; with &quot;M&quot;, &quot;Md&quot; should match with &quot;Md&quot;
1681             boolean match = matchPrefixAndSuffix(text, position, positivePrefix, matchedPrefix,
1682                     defaultDecimalFormat.getPositivePrefix(), positiveSuffix,
1683                     matchedPosSuffix, defaultDecimalFormat.getPositiveSuffix());
1684             if (match) {
1685                 matchedPosIndex = compactIndex;
1686                 matchedPosSuffix = positiveSuffix;
1687                 gotPos = true;
1688             }
1689 
1690             match = matchPrefixAndSuffix(text, position, negativePrefix, matchedPrefix,
1691                     defaultDecimalFormat.getNegativePrefix(), negativeSuffix,
1692                     matchedNegSuffix, defaultDecimalFormat.getNegativeSuffix());
1693             if (match) {
1694                 matchedNegIndex = compactIndex;
1695                 matchedNegSuffix = negativeSuffix;
</pre>
<hr />
<pre>
1757      * Reconstitutes this {@code CompactNumberFormat} from a stream
1758      * (that is, deserializes it) after performing some validations.
1759      * This method throws InvalidObjectException, if the stream data is invalid
1760      * because of the following reasons,
1761      * &lt;ul&gt;
1762      * &lt;li&gt; If any of the {@code decimalPattern}, {@code compactPatterns},
1763      * {@code symbols} or {@code roundingMode} is {@code null}.
1764      * &lt;li&gt; If the {@code decimalPattern} or the {@code compactPatterns} array
1765      * contains an invalid pattern or if a {@code null} appears in the array of
1766      * compact patterns.
1767      * &lt;li&gt; If the {@code minimumIntegerDigits} is greater than the
1768      * {@code maximumIntegerDigits} or the {@code minimumFractionDigits} is
1769      * greater than the {@code maximumFractionDigits}. This check is performed
1770      * by superclass&#39;s Object.
1771      * &lt;li&gt; If any of the minimum/maximum integer/fraction digit count is
1772      * negative. This check is performed by superclass&#39;s readObject.
1773      * &lt;li&gt; If the minimum or maximum integer digit count is larger than 309 or
1774      * if the minimum or maximum fraction digit count is larger than 340.
1775      * &lt;li&gt; If the grouping size is negative or larger than 127.
1776      * &lt;/ul&gt;


1777      *
1778      * @param inStream the stream
1779      * @throws IOException if an I/O error occurs
1780      * @throws ClassNotFoundException if the class of a serialized object
1781      *         could not be found
1782      */

1783     private void readObject(ObjectInputStream inStream) throws IOException,
1784             ClassNotFoundException {
1785 
1786         inStream.defaultReadObject();
1787         if (decimalPattern == null || compactPatterns == null
1788                 || symbols == null || roundingMode == null) {
1789             throw new InvalidObjectException(&quot;One of the &#39;decimalPattern&#39;,&quot;
1790                     + &quot; &#39;compactPatterns&#39;, &#39;symbols&#39; or &#39;roundingMode&#39;&quot;
1791                     + &quot; is null&quot;);
1792         }
1793 
1794         // Check only the maximum counts because NumberFormat.readObject has
1795         // already ensured that the maximum is greater than the minimum count.
1796         if (getMaximumIntegerDigits() &gt; DecimalFormat.DOUBLE_INTEGER_DIGITS
1797                 || getMaximumFractionDigits() &gt; DecimalFormat.DOUBLE_FRACTION_DIGITS) {
1798             throw new InvalidObjectException(&quot;Digit count out of range&quot;);
1799         }
1800 
1801         // Check if the grouping size is negative, on an attempt to
1802         // put value &gt; 127, it wraps around, so check just negative value
1803         if (groupingSize &lt; 0) {
1804             throw new InvalidObjectException(&quot;Grouping size is negative&quot;);
1805         }
1806 





1807         try {
1808             processCompactPatterns();
1809         } catch (IllegalArgumentException ex) {
1810             throw new InvalidObjectException(ex.getMessage());
1811         }
1812 
1813         decimalFormat = new DecimalFormat(SPECIAL_PATTERN, symbols);
1814         decimalFormat.setMaximumFractionDigits(getMaximumFractionDigits());
1815         decimalFormat.setMinimumFractionDigits(getMinimumFractionDigits());
1816         decimalFormat.setMaximumIntegerDigits(getMaximumIntegerDigits());
1817         decimalFormat.setMinimumIntegerDigits(getMinimumIntegerDigits());
1818         decimalFormat.setRoundingMode(getRoundingMode());
1819         decimalFormat.setGroupingSize(getGroupingSize());
1820         decimalFormat.setGroupingUsed(isGroupingUsed());
1821         decimalFormat.setParseIntegerOnly(isParseIntegerOnly());
1822 
1823         try {
1824             defaultDecimalFormat = new DecimalFormat(decimalPattern, symbols);
1825             defaultDecimalFormat.setMaximumFractionDigits(0);
1826         } catch (IllegalArgumentException ex) {
</pre>
<hr />
<pre>
2088      * Checks if this {@code CompactNumberFormat} is equal to the
2089      * specified {@code obj}. The objects of type {@code CompactNumberFormat}
2090      * are compared, other types return false; obeys the general contract of
2091      * {@link java.lang.Object#equals(java.lang.Object) Object.equals}.
2092      *
2093      * @param obj the object to compare with
2094      * @return true if this is equal to the other {@code CompactNumberFormat}
2095      */
2096     @Override
2097     public boolean equals(Object obj) {
2098 
2099         if (!super.equals(obj)) {
2100             return false;
2101         }
2102 
2103         CompactNumberFormat other = (CompactNumberFormat) obj;
2104         return decimalPattern.equals(other.decimalPattern)
2105                 &amp;&amp; symbols.equals(other.symbols)
2106                 &amp;&amp; Arrays.equals(compactPatterns, other.compactPatterns)
2107                 &amp;&amp; roundingMode.equals(other.roundingMode)

2108                 &amp;&amp; groupingSize == other.groupingSize
2109                 &amp;&amp; parseBigDecimal == other.parseBigDecimal;
2110     }
2111 
2112     /**
2113      * Returns the hash code for this {@code CompactNumberFormat} instance.
2114      *
2115      * @return hash code for this {@code CompactNumberFormat}
2116      */
2117     @Override
2118     public int hashCode() {
2119         return 31 * super.hashCode() +
<span class="line-modified">2120                 Objects.hash(decimalPattern, symbols, roundingMode)</span>
2121                 + Arrays.hashCode(compactPatterns) + groupingSize
2122                 + Boolean.hashCode(parseBigDecimal);
2123     }
2124 
2125     /**
2126      * Creates and returns a copy of this {@code CompactNumberFormat}
2127      * instance.
2128      *
2129      * @return a clone of this instance
2130      */
2131     @Override
2132     public CompactNumberFormat clone() {
2133         CompactNumberFormat other = (CompactNumberFormat) super.clone();
2134         other.compactPatterns = compactPatterns.clone();
2135         other.symbols = (DecimalFormatSymbols) symbols.clone();
2136         return other;
2137     }
2138 
<span class="line-modified">2139 }</span>



















































































































2140 



































</pre>
</td>
<td>
<hr />
<pre>
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.text;
  26 
  27 import java.io.IOException;
  28 import java.io.InvalidObjectException;
  29 import java.io.ObjectInputStream;
  30 import java.math.BigDecimal;
  31 import java.math.BigInteger;
  32 import java.math.RoundingMode;
  33 import java.util.ArrayList;
  34 import java.util.Arrays;
<span class="line-added">  35 import java.util.HashMap;</span>
  36 import java.util.List;
  37 import java.util.Locale;
<span class="line-added">  38 import java.util.Map;</span>
  39 import java.util.Objects;
  40 import java.util.concurrent.atomic.AtomicInteger;
  41 import java.util.concurrent.atomic.AtomicLong;
<span class="line-added">  42 import java.util.regex.Matcher;</span>
<span class="line-added">  43 import java.util.regex.Pattern;</span>
<span class="line-added">  44 import java.util.stream.Collectors;</span>
<span class="line-added">  45 import java.util.stream.Stream;</span>
  46 
  47 
  48 /**
  49  * &lt;p&gt;
  50  * {@code CompactNumberFormat} is a concrete subclass of {@code NumberFormat}
  51  * that formats a decimal number in its compact form.
  52  *
  53  * The compact number formatting is designed for the environment where the space
  54  * is limited, and the formatted string can be displayed in that limited space.
  55  * It is defined by LDML&#39;s specification for
  56  * &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats&quot;&gt;
  57  * Compact Number Formats&lt;/a&gt;. A compact number formatting refers
  58  * to the representation of a number in a shorter form, based on the patterns
  59  * provided for a given locale.
  60  *
  61  * &lt;p&gt;
  62  * For example:
  63  * &lt;br&gt;In the {@link java.util.Locale#US US locale}, {@code 1000} can be formatted
  64  * as {@code &quot;1K&quot;}, and {@code 1000000} as {@code &quot;1M&quot;}, depending upon the
  65  * &lt;a href = &quot;#compact_number_style&quot; &gt;style&lt;/a&gt; used.
  66  * &lt;br&gt;In the {@code &quot;hi_IN&quot;} locale, {@code 1000} can be formatted as
  67  * &quot;1 \u0939\u091C\u093C\u093E\u0930&quot;, and {@code 50000000} as &quot;5 \u0915.&quot;,
  68  * depending upon the &lt;a href = &quot;#compact_number_style&quot; &gt;style&lt;/a&gt; used.
  69  *
  70  * &lt;p&gt;
  71  * To obtain a {@code CompactNumberFormat} for a locale, use one
  72  * of the factory methods given by {@code NumberFormat} for compact number
  73  * formatting. For example,
  74  * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.
  75  *
  76  * &lt;blockquote&gt;&lt;pre&gt;
  77  * NumberFormat fmt = NumberFormat.getCompactNumberInstance(
  78  *                             new Locale(&quot;hi&quot;, &quot;IN&quot;), NumberFormat.Style.SHORT);
  79  * String result = fmt.format(1000);
  80  * &lt;/pre&gt;&lt;/blockquote&gt;
  81  *
<span class="line-modified">  82  * &lt;h2&gt;&lt;a id=&quot;compact_number_style&quot;&gt;Style&lt;/a&gt;&lt;/h2&gt;</span>
  83  * &lt;p&gt;
  84  * A number can be formatted in the compact forms with two different
  85  * styles, {@link NumberFormat.Style#SHORT SHORT}
  86  * and {@link NumberFormat.Style#LONG LONG}. Use
  87  * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and
  88  * parsing a number in {@link NumberFormat.Style#SHORT SHORT} or
  89  * {@link NumberFormat.Style#LONG LONG} compact form,
  90  * where the given {@code Style} parameter requests the desired
  91  * format. A {@link NumberFormat.Style#SHORT SHORT} style
  92  * compact number instance in the {@link java.util.Locale#US US locale} formats
  93  * {@code 10000} as {@code &quot;10K&quot;}. However, a
  94  * {@link NumberFormat.Style#LONG LONG} style instance in same locale
  95  * formats {@code 10000} as {@code &quot;10 thousand&quot;}.
  96  *
<span class="line-modified">  97  * &lt;h2&gt;&lt;a id=&quot;compact_number_patterns&quot;&gt;Compact Number Patterns&lt;/a&gt;&lt;/h2&gt;</span>
  98  * &lt;p&gt;
  99  * The compact number patterns are represented in a series of patterns where each
 100  * pattern is used to format a range of numbers. An example of
 101  * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns
 102  * for the {@link java.util.Locale#US US locale} is {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;,
 103  * &quot;00K&quot;, &quot;000K&quot;, &quot;0M&quot;, &quot;00M&quot;, &quot;000M&quot;, &quot;0B&quot;, &quot;00B&quot;, &quot;000B&quot;, &quot;0T&quot;, &quot;00T&quot;, &quot;000T&quot;}},
 104  * ranging from {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt; to {@code 10}&lt;sup&gt;{@code 14}&lt;/sup&gt;.
 105  * There can be any number of patterns and they are
 106  * strictly index based starting from the range {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;.
 107  * For example, in the above patterns, pattern at index 3
 108  * ({@code &quot;0K&quot;}) is used for formatting {@code number &gt;= 1000 and number &lt; 10000},
 109  * pattern at index 4 ({@code &quot;00K&quot;}) is used for formatting
 110  * {@code number &gt;= 10000 and number &lt; 100000} and so on. In most of the locales,
 111  * patterns with the range
 112  * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 2}&lt;/sup&gt; are empty
 113  * strings, which implicitly means a special pattern {@code &quot;0&quot;}.
 114  * A special pattern {@code &quot;0&quot;} is used for any range which does not contain
 115  * a compact pattern. This special pattern can appear explicitly for any specific
 116  * range, or considered as a default pattern for an empty string.




















 117  *
<span class="line-added"> 118  * &lt;p&gt;</span>
 119  * A compact pattern contains a positive and negative subpattern
 120  * separated by a subpattern boundary character {@code &#39;;&#39; (U+003B)},
 121  * for example, {@code &quot;0K;-0K&quot;}. Each subpattern has a prefix,
 122  * minimum integer digits, and suffix. The negative subpattern
 123  * is optional, if absent, then the positive subpattern prefixed with the
 124  * minus sign ({@code &#39;-&#39; U+002D HYPHEN-MINUS}) is used as the negative
 125  * subpattern. That is, {@code &quot;0K&quot;} alone is equivalent to {@code &quot;0K;-0K&quot;}.
 126  * If there is an explicit negative subpattern, it serves only to specify
 127  * the negative prefix and suffix. The number of minimum integer digits,
 128  * and other characteristics are all the same as the positive pattern.
 129  * That means that {@code &quot;0K;-00K&quot;} produces precisely the same behavior
 130  * as {@code &quot;0K;-0K&quot;}.
 131  *
 132  * &lt;p&gt;
 133  * Many characters in a compact pattern are taken literally, they are matched
 134  * during parsing and output unchanged during formatting.
 135  * &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;Special characters&lt;/a&gt;,
 136  * on the other hand, stand for other characters, strings, or classes of
 137  * characters. They must be quoted, using single quote {@code &#39; (U+0027)}
 138  * unless noted otherwise, if they are to appear in the prefix or suffix
 139  * as literals. For example, 0\u0915&#39;.&#39;.
 140  *
<span class="line-modified"> 141  * &lt;h3&gt;Plurals&lt;/h3&gt;</span>
<span class="line-added"> 142  * &lt;p&gt;</span>
<span class="line-added"> 143  * In case some localization requires compact number patterns to be different for</span>
<span class="line-added"> 144  * plurals, each singular and plural pattern can be enumerated within a pair of</span>
<span class="line-added"> 145  * curly brackets &lt;code&gt;&#39;{&#39; (U+007B)&lt;/code&gt; and &lt;code&gt;&#39;}&#39; (U+007D)&lt;/code&gt;, separated</span>
<span class="line-added"> 146  * by a space {@code &#39; &#39; (U+0020)}. If this format is used, each pattern needs to be</span>
<span class="line-added"> 147  * prepended by its {@code count}, followed by a single colon {@code &#39;:&#39; (U+003A)}.</span>
<span class="line-added"> 148  * If the pattern includes spaces literally, they must be quoted.</span>
<span class="line-added"> 149  * &lt;p&gt;</span>
<span class="line-added"> 150  * For example, the compact number pattern representing millions in German locale can be</span>
<span class="line-added"> 151  * specified as {@code &quot;{one:0&#39; &#39;Million other:0&#39; &#39;Millionen}&quot;}. The {@code count}</span>
<span class="line-added"> 152  * follows LDML&#39;s</span>
<span class="line-added"> 153  * &lt;a href=&quot;https://unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules&quot;&gt;</span>
<span class="line-added"> 154  * Language Plural Rules&lt;/a&gt;.</span>
<span class="line-added"> 155  * &lt;p&gt;</span>
<span class="line-added"> 156  * A compact pattern has the following syntax:</span>
<span class="line-added"> 157  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added"> 158  * &lt;i&gt;Pattern:&lt;/i&gt;</span>
<span class="line-added"> 159  *         &lt;i&gt;SimplePattern&lt;/i&gt;</span>
<span class="line-added"> 160  *         &#39;{&#39; &lt;i&gt;PluralPattern&lt;/i&gt; &lt;i&gt;[&#39; &#39; PluralPattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &#39;}&#39;</span>
<span class="line-added"> 161  * &lt;i&gt;SimplePattern:&lt;/i&gt;</span>
<span class="line-added"> 162  *         &lt;i&gt;PositivePattern&lt;/i&gt;</span>
<span class="line-added"> 163  *         &lt;i&gt;PositivePattern&lt;/i&gt; &lt;i&gt;[; NegativePattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added"> 164  * &lt;i&gt;PluralPattern:&lt;/i&gt;</span>
<span class="line-added"> 165  *         &lt;i&gt;Count&lt;/i&gt;:&lt;i&gt;SimplePattern&lt;/i&gt;</span>
<span class="line-added"> 166  * &lt;i&gt;Count:&lt;/i&gt;</span>
<span class="line-added"> 167  *         &quot;zero&quot; / &quot;one&quot; / &quot;two&quot; / &quot;few&quot; / &quot;many&quot; / &quot;other&quot;</span>
<span class="line-added"> 168  * &lt;i&gt;PositivePattern:&lt;/i&gt;</span>
<span class="line-added"> 169  *         &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added"> 170  * &lt;i&gt;NegativePattern:&lt;/i&gt;</span>
<span class="line-added"> 171  *        &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added"> 172  * &lt;i&gt;Prefix:&lt;/i&gt;</span>
<span class="line-added"> 173  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-added"> 174  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;.</span>
<span class="line-added"> 175  * &lt;i&gt;Suffix:&lt;/i&gt;</span>
<span class="line-added"> 176  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-added"> 177  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;.</span>
<span class="line-added"> 178  * &lt;i&gt;MinimumInteger:&lt;/i&gt;</span>
<span class="line-added"> 179  *      0</span>
<span class="line-added"> 180  *      0 &lt;i&gt;MinimumInteger&lt;/i&gt;</span>
<span class="line-added"> 181  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 182  *</span>
<span class="line-added"> 183  * &lt;h2&gt;Formatting&lt;/h2&gt;</span>
 184  * The default formatting behavior returns a formatted string with no fractional
 185  * digits, however users can use the {@link #setMinimumFractionDigits(int)}
 186  * method to include the fractional part.
 187  * The number {@code 1000.0} or {@code 1000} is formatted as {@code &quot;1K&quot;}
 188  * not {@code &quot;1.00K&quot;} (in the {@link java.util.Locale#US US locale}). For this
 189  * reason, the patterns provided for formatting contain only the minimum
 190  * integer digits, prefix and/or suffix, but no fractional part.
 191  * For example, patterns used are {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, 0K, 00K, ...}}. If the pattern
 192  * selected for formatting a number is {@code &quot;0&quot;} (special pattern),
 193  * either explicit or defaulted, then the general number formatting provided by
 194  * {@link java.text.DecimalFormat DecimalFormat}
 195  * for the specified locale is used.
 196  *
<span class="line-modified"> 197  * &lt;h2&gt;Parsing&lt;/h2&gt;</span>
 198  * The default parsing behavior does not allow a grouping separator until
 199  * grouping used is set to {@code true} by using
 200  * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part
 201  * depends on the {@link #isParseIntegerOnly()}. For example, if the
 202  * parse integer only is set to true, then the fractional part is skipped.
 203  *
<span class="line-modified"> 204  * &lt;h2&gt;Rounding&lt;/h2&gt;</span>
 205  * {@code CompactNumberFormat} provides rounding modes defined in
 206  * {@link java.math.RoundingMode} for formatting.  By default, it uses
 207  * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
 208  *
 209  * @see CompactNumberFormat.Style
 210  * @see NumberFormat
 211  * @see DecimalFormat
 212  * @since 12
 213  */
 214 public final class CompactNumberFormat extends NumberFormat {
 215 
<span class="line-added"> 216     @java.io.Serial</span>
 217     private static final long serialVersionUID = 7128367218649234678L;
 218 
 219     /**
 220      * The patterns for compact form of numbers for this
 221      * {@code CompactNumberFormat}. A possible example is
 222      * {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;, &quot;00K&quot;, &quot;000K&quot;, &quot;0M&quot;, &quot;00M&quot;, &quot;000M&quot;, &quot;0B&quot;,
 223      * &quot;00B&quot;, &quot;000B&quot;, &quot;0T&quot;, &quot;00T&quot;, &quot;000T&quot;}} ranging from
 224      * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 14}&lt;/sup&gt;,
 225      * where each pattern is used to format a range of numbers.
 226      * For example, {@code &quot;0K&quot;} is used for formatting
 227      * {@code number &gt;= 1000 and number &lt; 10000}, {@code &quot;00K&quot;} is used for
 228      * formatting {@code number &gt;= 10000 and number &lt; 100000} and so on.
 229      * This field must not be {@code null}.
 230      *
 231      * @serial
 232      */
 233     private String[] compactPatterns;
 234 
 235     /**
 236      * List of positive prefix patterns of this formatter&#39;s
 237      * compact number patterns.
 238      */
<span class="line-modified"> 239     private transient List&lt;Patterns&gt; positivePrefixPatterns;</span>
 240 
 241     /**
 242      * List of negative prefix patterns of this formatter&#39;s
 243      * compact number patterns.
 244      */
<span class="line-modified"> 245     private transient List&lt;Patterns&gt; negativePrefixPatterns;</span>
 246 
 247     /**
 248      * List of positive suffix patterns of this formatter&#39;s
 249      * compact number patterns.
 250      */
<span class="line-modified"> 251     private transient List&lt;Patterns&gt; positiveSuffixPatterns;</span>
 252 
 253     /**
 254      * List of negative suffix patterns of this formatter&#39;s
 255      * compact number patterns.
 256      */
<span class="line-modified"> 257     private transient List&lt;Patterns&gt; negativeSuffixPatterns;</span>
 258 
 259     /**
 260      * List of divisors of this formatter&#39;s compact number patterns.
 261      * Divisor can be either Long or BigInteger (if the divisor value goes
 262      * beyond long boundary)
 263      */
 264     private transient List&lt;Number&gt; divisors;
 265 
 266     /**
 267      * The {@code DecimalFormatSymbols} object used by this format.
 268      * It contains the symbols used to format numbers. For example,
 269      * the grouping separator, decimal separator, and so on.
 270      * This field must not be {@code null}.
 271      *
 272      * @serial
 273      * @see DecimalFormatSymbols
 274      */
 275     private DecimalFormatSymbols symbols;
 276 
 277     /**
</pre>
<hr />
<pre>
 310      * @serial
 311      */
 312     private byte groupingSize = 0;
 313 
 314     /**
 315      * Returns whether the {@link #parse(String, ParsePosition)}
 316      * method returns {@code BigDecimal}.
 317      *
 318      * @serial
 319      */
 320     private boolean parseBigDecimal = false;
 321 
 322     /**
 323      * The {@code RoundingMode} used in this compact number format.
 324      * This field must not be {@code null}.
 325      *
 326      * @serial
 327      */
 328     private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
 329 
<span class="line-added"> 330     /**</span>
<span class="line-added"> 331      * The {@code pluralRules} used in this compact number format.</span>
<span class="line-added"> 332      * {@code pluralRules} is a String designating plural rules which associate</span>
<span class="line-added"> 333      * the {@code Count} keyword, such as &quot;{@code one}&quot;, and the</span>
<span class="line-added"> 334      * actual integer number. Its syntax is defined in Unicode Consortium&#39;s</span>
<span class="line-added"> 335      * &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;</span>
<span class="line-added"> 336      * Plural rules syntax&lt;/a&gt;.</span>
<span class="line-added"> 337      * The default value is an empty string, meaning there is no plural rules.</span>
<span class="line-added"> 338      *</span>
<span class="line-added"> 339      * @serial</span>
<span class="line-added"> 340      * @since 14</span>
<span class="line-added"> 341      */</span>
<span class="line-added"> 342     private String pluralRules = &quot;&quot;;</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344     /**</span>
<span class="line-added"> 345      * The map for plural rules that maps LDML defined tags (e.g. &quot;one&quot;) to</span>
<span class="line-added"> 346      * its rule.</span>
<span class="line-added"> 347      */</span>
<span class="line-added"> 348     private transient Map&lt;String, String&gt; rulesMap;</span>
<span class="line-added"> 349 </span>
 350     /**
 351      * Special pattern used for compact numbers
 352      */
 353     private static final String SPECIAL_PATTERN = &quot;0&quot;;
 354 
 355     /**
 356      * Multiplier for compact pattern range. In
 357      * the list compact patterns each compact pattern
 358      * specify the range with the multiplication factor of 10
 359      * of its previous compact pattern range.
 360      * For example, 10^0, 10^1, 10^2, 10^3, 10^4...
 361      *
 362      */
 363     private static final int RANGE_MULTIPLIER = 10;
 364 
 365     /**
 366      * Creates a {@code CompactNumberFormat} using the given decimal pattern,
 367      * decimal format symbols and compact patterns.
 368      * To obtain the instance of {@code CompactNumberFormat} with the standard
 369      * compact patterns for a {@code Locale} and {@code Style},
 370      * it is recommended to use the factory methods given by
 371      * {@code NumberFormat} for compact number formatting. For example,
 372      * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.
 373      *
 374      * @param decimalPattern a decimal pattern for general number formatting
 375      * @param symbols the set of symbols to be used
 376      * @param compactPatterns an array of
 377      *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;
 378      *        compact number patterns&lt;/a&gt;
 379      * @throws NullPointerException if any of the given arguments is
<span class="line-modified"> 380      *       {@code null}</span>
 381      * @throws IllegalArgumentException if the given {@code decimalPattern} or the
<span class="line-modified"> 382      *       {@code compactPatterns} array contains an invalid pattern</span>
<span class="line-modified"> 383      *       or if a {@code null} appears in the array of compact</span>
<span class="line-modified"> 384      *       patterns</span>
<span class="line-added"> 385      * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)</span>
<span class="line-added"> 386      * @see DecimalFormatSymbols</span>
<span class="line-added"> 387      */</span>
<span class="line-added"> 388     public CompactNumberFormat(String decimalPattern,</span>
<span class="line-added"> 389                                DecimalFormatSymbols symbols, String[] compactPatterns) {</span>
<span class="line-added"> 390         this(decimalPattern, symbols, compactPatterns, &quot;&quot;);</span>
<span class="line-added"> 391     }</span>
<span class="line-added"> 392 </span>
<span class="line-added"> 393     /**</span>
<span class="line-added"> 394      * Creates a {@code CompactNumberFormat} using the given decimal pattern,</span>
<span class="line-added"> 395      * decimal format symbols, compact patterns, and plural rules.</span>
<span class="line-added"> 396      * To obtain the instance of {@code CompactNumberFormat} with the standard</span>
<span class="line-added"> 397      * compact patterns for a {@code Locale}, {@code Style}, and {@code pluralRules},</span>
<span class="line-added"> 398      * it is recommended to use the factory methods given by</span>
<span class="line-added"> 399      * {@code NumberFormat} for compact number formatting. For example,</span>
<span class="line-added"> 400      * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.</span>
<span class="line-added"> 401      *</span>
<span class="line-added"> 402      * @param decimalPattern a decimal pattern for general number formatting</span>
<span class="line-added"> 403      * @param symbols the set of symbols to be used</span>
<span class="line-added"> 404      * @param compactPatterns an array of</span>
<span class="line-added"> 405      *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;</span>
<span class="line-added"> 406      *        compact number patterns&lt;/a&gt;</span>
<span class="line-added"> 407      * @param pluralRules a String designating plural rules which associate</span>
<span class="line-added"> 408      *        the {@code Count} keyword, such as &quot;{@code one}&quot;, and the</span>
<span class="line-added"> 409      *        actual integer number. Its syntax is defined in Unicode Consortium&#39;s</span>
<span class="line-added"> 410      *        &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;</span>
<span class="line-added"> 411      *        Plural rules syntax&lt;/a&gt;</span>
<span class="line-added"> 412      * @throws NullPointerException if any of the given arguments is</span>
<span class="line-added"> 413      *        {@code null}</span>
<span class="line-added"> 414      * @throws IllegalArgumentException if the given {@code decimalPattern},</span>
<span class="line-added"> 415      *        the {@code compactPatterns} array contains an invalid pattern,</span>
<span class="line-added"> 416      *        a {@code null} appears in the array of compact patterns,</span>
<span class="line-added"> 417      *        or if the given {@code pluralRules} contains an invalid syntax</span>
 418      * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)
 419      * @see DecimalFormatSymbols
<span class="line-added"> 420      * @since 14</span>
 421      */
 422     public CompactNumberFormat(String decimalPattern,
<span class="line-modified"> 423             DecimalFormatSymbols symbols, String[] compactPatterns,</span>
<span class="line-added"> 424             String pluralRules) {</span>
 425 
 426         Objects.requireNonNull(decimalPattern, &quot;decimalPattern&quot;);
 427         Objects.requireNonNull(symbols, &quot;symbols&quot;);
 428         Objects.requireNonNull(compactPatterns, &quot;compactPatterns&quot;);
<span class="line-added"> 429         Objects.requireNonNull(pluralRules, &quot;pluralRules&quot;);</span>
 430 
 431         this.symbols = symbols;
 432         // Instantiating the DecimalFormat with &quot;0&quot; pattern; this acts just as a
 433         // basic pattern; the properties (For example, prefix/suffix)
 434         // are later computed based on the compact number formatting process.
 435         decimalFormat = new DecimalFormat(SPECIAL_PATTERN, this.symbols);
 436 
 437         // Initializing the super class state with the decimalFormat values
 438         // to represent this CompactNumberFormat.
 439         // For setting the digits counts, use overridden setXXX methods of this
 440         // CompactNumberFormat, as it performs check with the max range allowed
 441         // for compact number formatting
 442         setMaximumIntegerDigits(decimalFormat.getMaximumIntegerDigits());
 443         setMinimumIntegerDigits(decimalFormat.getMinimumIntegerDigits());
 444         setMaximumFractionDigits(decimalFormat.getMaximumFractionDigits());
 445         setMinimumFractionDigits(decimalFormat.getMinimumFractionDigits());
 446 
 447         super.setGroupingUsed(decimalFormat.isGroupingUsed());
 448         super.setParseIntegerOnly(decimalFormat.isParseIntegerOnly());
 449 
 450         this.compactPatterns = compactPatterns;
 451 
 452         // DecimalFormat used for formatting numbers with special pattern &quot;0&quot;.
 453         // Formatting is delegated to the DecimalFormat&#39;s number formatting
 454         // with no fraction digits
 455         this.decimalPattern = decimalPattern;
 456         defaultDecimalFormat = new DecimalFormat(this.decimalPattern,
 457                 this.symbols);
 458         defaultDecimalFormat.setMaximumFractionDigits(0);
<span class="line-added"> 459 </span>
<span class="line-added"> 460         this.pluralRules = pluralRules;</span>
<span class="line-added"> 461 </span>
 462         // Process compact patterns to extract the prefixes, suffixes and
 463         // divisors
 464         processCompactPatterns();
 465     }
 466 
 467     /**
 468      * Formats a number to produce a string representing its compact form.
 469      * The number can be of any subclass of {@link java.lang.Number}.
 470      * @param number     the number to format
 471      * @param toAppendTo the {@code StringBuffer} to which the formatted
 472      *                   text is to be appended
 473      * @param fieldPosition    keeps track on the position of the field within
 474      *                         the returned string. For example, for formatting
 475      *                         a number {@code 123456789} in the
 476      *                         {@link java.util.Locale#US US locale},
 477      *                         if the given {@code fieldPosition} is
 478      *                         {@link NumberFormat#INTEGER_FIELD}, the begin
 479      *                         index and end index of {@code fieldPosition}
 480      *                         will be set to 0 and 3, respectively for the
 481      *                         output string {@code 123M}. Similarly, positions
</pre>
<hr />
<pre>
 565 
 566         nanOrInfinity = decimalFormat.handleInfinity(number, result, delegate, isNegative);
 567         if (nanOrInfinity) {
 568             return result;
 569         }
 570 
 571         // Round the double value with min fraction digits, the integer
 572         // part of the rounded value is used for matching the compact
 573         // number pattern
 574         // For example, if roundingMode is HALF_UP with min fraction
 575         // digits = 0, the number 999.6 should round up
 576         // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
 577         DigitList dList = new DigitList();
 578         dList.setRoundingMode(getRoundingMode());
 579         number = isNegative ? -number : number;
 580         dList.set(isNegative, number, getMinimumFractionDigits());
 581 
 582         double roundedNumber = dList.getDouble();
 583         int compactDataIndex = selectCompactPattern((long) roundedNumber);
 584         if (compactDataIndex != -1) {
<span class="line-modified"> 585             long divisor = (Long) divisors.get(compactDataIndex);</span>
<span class="line-modified"> 586             int iPart = getIntegerPart(number, divisor);</span>
<span class="line-modified"> 587             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified"> 588             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
 589 
 590             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 591                 appendPrefix(result, prefix, delegate);

 592                 roundedNumber = roundedNumber / divisor;
 593                 decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());
 594                 decimalFormat.subformatNumber(result, delegate, isNegative,
 595                         false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
 596                         getMaximumFractionDigits(), getMinimumFractionDigits());
 597                 appendSuffix(result, suffix, delegate);
 598             } else {
 599                 defaultDecimalFormat.doubleSubformat(number, result, delegate, isNegative);
 600             }
 601         } else {
 602             defaultDecimalFormat.doubleSubformat(number, result, delegate, isNegative);
 603         }
 604         return result;
 605     }
 606 
 607     /**
 608      * Formats a long to produce a string representing its compact form.
 609      * @param number    the long number to format
 610      * @param result    where the text is to be appended
 611      * @param fieldPosition    keeps track on the position of the field within
</pre>
<hr />
<pre>
 632             FieldPosition fieldPosition) {
 633 
 634         fieldPosition.setBeginIndex(0);
 635         fieldPosition.setEndIndex(0);
 636         return format(number, result, fieldPosition.getFieldDelegate());
 637     }
 638 
 639     private StringBuffer format(long number, StringBuffer result, FieldDelegate delegate) {
 640         boolean isNegative = (number &lt; 0);
 641         if (isNegative) {
 642             number = -number;
 643         }
 644 
 645         if (number &lt; 0) { // LONG_MIN
 646             BigInteger bigIntegerValue = BigInteger.valueOf(number);
 647             return format(bigIntegerValue, result, delegate, true);
 648         }
 649 
 650         int compactDataIndex = selectCompactPattern(number);
 651         if (compactDataIndex != -1) {
<span class="line-modified"> 652             long divisor = (Long) divisors.get(compactDataIndex);</span>
<span class="line-modified"> 653             int iPart = getIntegerPart(number, divisor);</span>
<span class="line-modified"> 654             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified"> 655             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
 656             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 657                 appendPrefix(result, prefix, delegate);

 658                 if ((number % divisor == 0)) {
 659                     number = number / divisor;
 660                     decimalFormat.setDigitList(number, isNegative, 0);
 661                     decimalFormat.subformatNumber(result, delegate,
 662                             isNegative, true, getMaximumIntegerDigits(),
 663                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 664                             getMinimumFractionDigits());
 665                 } else {
 666                     // To avoid truncation of fractional part store
 667                     // the value in double and follow double path instead of
 668                     // long path
 669                     double dNumber = (double) number / divisor;
 670                     decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());
 671                     decimalFormat.subformatNumber(result, delegate,
 672                             isNegative, false, getMaximumIntegerDigits(),
 673                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 674                             getMinimumFractionDigits());
 675                 }
 676                 appendSuffix(result, suffix, delegate);
 677             } else {
</pre>
<hr />
<pre>
 718     }
 719 
 720     private StringBuffer format(BigDecimal number, StringBuffer result,
 721             FieldDelegate delegate) {
 722 
 723         boolean isNegative = number.signum() == -1;
 724         if (isNegative) {
 725             number = number.negate();
 726         }
 727 
 728         // Round the value with min fraction digits, the integer
 729         // part of the rounded value is used for matching the compact
 730         // number pattern
 731         // For example, If roundingMode is HALF_UP with min fraction digits = 0,
 732         // the number 999.6 should round up
 733         // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
 734         number = number.setScale(getMinimumFractionDigits(), getRoundingMode());
 735 
 736         int compactDataIndex;
 737         if (number.toBigInteger().bitLength() &lt; 64) {
<span class="line-modified"> 738             long longNumber = number.toBigInteger().longValue();</span>
<span class="line-added"> 739             compactDataIndex = selectCompactPattern(longNumber);</span>
 740         } else {
 741             compactDataIndex = selectCompactPattern(number.toBigInteger());
 742         }
 743 
 744         if (compactDataIndex != -1) {
<span class="line-modified"> 745             Number divisor = divisors.get(compactDataIndex);</span>
<span class="line-modified"> 746             int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());</span>
<span class="line-modified"> 747             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified"> 748             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
 749             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 750                 appendPrefix(result, prefix, delegate);

 751                 number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());
 752                 decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());
 753                 decimalFormat.subformatNumber(result, delegate, isNegative,
 754                         false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
 755                         getMaximumFractionDigits(), getMinimumFractionDigits());
 756                 appendSuffix(result, suffix, delegate);
 757             } else {
 758                 number = isNegative ? number.negate() : number;
 759                 defaultDecimalFormat.format(number, result, delegate);
 760             }
 761         } else {
 762             number = isNegative ? number.negate() : number;
 763             defaultDecimalFormat.format(number, result, delegate);
 764         }
 765         return result;
 766     }
 767 
 768     /**
 769      * Formats a BigInteger to produce a string representing its compact form.
 770      * @param number    the BigInteger number to format
</pre>
<hr />
<pre>
 790      */
 791     private StringBuffer format(BigInteger number, StringBuffer result,
 792             FieldPosition fieldPosition) {
 793 
 794         Objects.requireNonNull(number);
 795         fieldPosition.setBeginIndex(0);
 796         fieldPosition.setEndIndex(0);
 797         return format(number, result, fieldPosition.getFieldDelegate(), false);
 798     }
 799 
 800     private StringBuffer format(BigInteger number, StringBuffer result,
 801             FieldDelegate delegate, boolean formatLong) {
 802 
 803         boolean isNegative = number.signum() == -1;
 804         if (isNegative) {
 805             number = number.negate();
 806         }
 807 
 808         int compactDataIndex = selectCompactPattern(number);
 809         if (compactDataIndex != -1) {
<span class="line-modified"> 810             Number divisor = divisors.get(compactDataIndex);</span>
<span class="line-modified"> 811             int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());</span>
<span class="line-modified"> 812             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified"> 813             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
 814             if (!prefix.isEmpty() || !suffix.isEmpty()) {
 815                 appendPrefix(result, prefix, delegate);

 816                 if (number.mod(new BigInteger(divisor.toString()))
 817                         .compareTo(BigInteger.ZERO) == 0) {
 818                     number = number.divide(new BigInteger(divisor.toString()));
 819 
 820                     decimalFormat.setDigitList(number, isNegative, 0);
 821                     decimalFormat.subformatNumber(result, delegate,
 822                             isNegative, true, getMaximumIntegerDigits(),
 823                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 824                             getMinimumFractionDigits());
 825                 } else {
 826                     // To avoid truncation of fractional part store the value in
 827                     // BigDecimal and follow BigDecimal path instead of
 828                     // BigInteger path
 829                     BigDecimal nDecimal = new BigDecimal(number)
 830                             .divide(new BigDecimal(divisor.toString()), getRoundingMode());
 831                     decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());
 832                     decimalFormat.subformatNumber(result, delegate,
 833                             isNegative, false, getMaximumIntegerDigits(),
 834                             getMinimumIntegerDigits(), getMaximumFractionDigits(),
 835                             getMinimumFractionDigits());
 836                 }
 837                 appendSuffix(result, suffix, delegate);
 838             } else {
 839                 number = isNegative ? number.negate() : number;
 840                 defaultDecimalFormat.format(number, result, delegate, formatLong);
 841             }
 842         } else {
 843             number = isNegative ? number.negate() : number;
 844             defaultDecimalFormat.format(number, result, delegate, formatLong);
 845         }
 846         return result;
 847     }
 848 
<span class="line-added"> 849     /**</span>
<span class="line-added"> 850      * Obtain the designated affix from the appropriate list of affixes,</span>
<span class="line-added"> 851      * based on the given arguments.</span>
<span class="line-added"> 852      */</span>
<span class="line-added"> 853     private String getAffix(boolean isExpanded, boolean isPrefix, boolean isNegative, int compactDataIndex, int iPart) {</span>
<span class="line-added"> 854         return (isExpanded ? (isPrefix ? (isNegative ? negativePrefixes : positivePrefixes) :</span>
<span class="line-added"> 855                                          (isNegative ? negativeSuffixes : positiveSuffixes)) :</span>
<span class="line-added"> 856                              (isPrefix ? (isNegative ? negativePrefixPatterns : positivePrefixPatterns) :</span>
<span class="line-added"> 857                                          (isNegative ? negativeSuffixPatterns : positiveSuffixPatterns)))</span>
<span class="line-added"> 858                 .get(compactDataIndex).get(iPart);</span>
<span class="line-added"> 859     }</span>
<span class="line-added"> 860 </span>
 861     /**
 862      * Appends the {@code prefix} to the {@code result} and also set the
 863      * {@code NumberFormat.Field.SIGN} and {@code NumberFormat.Field.PREFIX}
 864      * field positions.
 865      * @param result the resulting string, where the pefix is to be appended
 866      * @param prefix prefix to append
 867      * @param delegate notified of the locations of
 868      *                 {@code NumberFormat.Field.SIGN} and
 869      *                 {@code NumberFormat.Field.PREFIX} fields
 870      */
 871     private void appendPrefix(StringBuffer result, String prefix,
 872             FieldDelegate delegate) {
 873         append(result, expandAffix(prefix), delegate,
 874                 getFieldPositions(prefix, NumberFormat.Field.PREFIX));
 875     }
 876 
 877     /**
 878      * Appends {@code suffix} to the {@code result} and also set the
 879      * {@code NumberFormat.Field.SIGN} and {@code NumberFormat.Field.SUFFIX}
 880      * field positions.
</pre>
<hr />
<pre>
 917 
 918     /**
 919      * Expands an affix {@code pattern} into a string of literals.
 920      * All characters in the pattern are literals unless prefixed by QUOTE.
 921      * The character prefixed by QUOTE is replaced with its respective
 922      * localized literal.
 923      * @param pattern a compact number pattern affix
 924      * @return an expanded affix
 925      */
 926     private String expandAffix(String pattern) {
 927         // Return if no quoted character exists
 928         if (pattern.indexOf(QUOTE) &lt; 0) {
 929             return pattern;
 930         }
 931         StringBuilder sb = new StringBuilder();
 932         for (int index = 0; index &lt; pattern.length();) {
 933             char ch = pattern.charAt(index++);
 934             if (ch == QUOTE) {
 935                 ch = pattern.charAt(index++);
 936                 if (ch == MINUS_SIGN) {
<span class="line-modified"> 937                     sb.append(symbols.getMinusSignText());</span>
<span class="line-added"> 938                     continue;</span>
 939                 }
 940             }
 941             sb.append(ch);
 942         }
 943         return sb.toString();
 944     }
 945 
 946     /**
 947      * Returns a list of {@code FieldPostion} in the given {@code pattern}.
 948      * @param pattern the pattern to be parsed for {@code FieldPosition}
 949      * @param field whether a PREFIX or SUFFIX field
 950      * @return a list of {@code FieldPostion}
 951      */
 952     private List&lt;FieldPosition&gt; getFieldPositions(String pattern, Field field) {
 953         List&lt;FieldPosition&gt; positions = new ArrayList&lt;&gt;();
 954         StringBuilder affix = new StringBuilder();
 955         int stringIndex = 0;
 956         for (int index = 0; index &lt; pattern.length();) {
 957             char ch = pattern.charAt(index++);
 958             if (ch == QUOTE) {
 959                 ch = pattern.charAt(index++);
 960                 if (ch == MINUS_SIGN) {
<span class="line-modified"> 961                     String minusText = symbols.getMinusSignText();</span>
 962                     FieldPosition fp = new FieldPosition(NumberFormat.Field.SIGN);
 963                     fp.setBeginIndex(stringIndex);
<span class="line-modified"> 964                     fp.setEndIndex(stringIndex + minusText.length());</span>
 965                     positions.add(fp);
<span class="line-added"> 966                     stringIndex += minusText.length();</span>
<span class="line-added"> 967                     affix.append(minusText);</span>
<span class="line-added"> 968                     continue;</span>
 969                 }
 970             }
 971             stringIndex++;
 972             affix.append(ch);
 973         }
 974         if (affix.length() != 0) {
 975             FieldPosition fp = new FieldPosition(field);
 976             fp.setBeginIndex(0);
 977             fp.setEndIndex(affix.length());
 978             positions.add(fp);
 979         }
 980         return positions;
 981     }
 982 
 983     /**
 984      * Select the index of the matched compact number pattern for
 985      * the given {@code long} {@code number}.
 986      *
 987      * @param number number to be formatted
 988      * @return index of matched compact pattern;
</pre>
<hr />
<pre>
1122             } else {
1123                 long longValue = (long) matchedValue;
1124                 if (longValue &lt; (long) Math.pow(RANGE_MULTIPLIER, count)) {
1125                     throw new IllegalArgumentException(&quot;Invalid Pattern&quot;
1126                             + &quot; [&quot; + compactPatterns[patternIndex]
1127                             + &quot;]: min integer digits specified exceeds the limit&quot;
1128                             + &quot; for the index &quot; + patternIndex);
1129                 }
1130                 divisor = longValue / (long) Math.pow(RANGE_MULTIPLIER, count);
1131             }
1132         }
1133         return divisor;
1134     }
1135 
1136     /**
1137      * Process the series of compact patterns to compute the
1138      * series of prefixes, suffixes and their respective divisor
1139      * value.
1140      *
1141      */
<span class="line-added">1142     private static final Pattern PLURALS =</span>
<span class="line-added">1143             Pattern.compile(&quot;^\\{(?&lt;plurals&gt;.*)\\}$&quot;);</span>
<span class="line-added">1144     private static final Pattern COUNT_PATTERN =</span>
<span class="line-added">1145             Pattern.compile(&quot;(zero|one|two|few|many|other):((&#39; &#39;|[^ ])+)[ ]*&quot;);</span>
1146     private void processCompactPatterns() {
1147         int size = compactPatterns.length;
1148         positivePrefixPatterns = new ArrayList&lt;&gt;(size);
1149         negativePrefixPatterns = new ArrayList&lt;&gt;(size);
1150         positiveSuffixPatterns = new ArrayList&lt;&gt;(size);
1151         negativeSuffixPatterns = new ArrayList&lt;&gt;(size);
1152         divisors = new ArrayList&lt;&gt;(size);
1153 
1154         for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1155             String text = compactPatterns[index];</span>
<span class="line-added">1156             positivePrefixPatterns.add(new Patterns());</span>
<span class="line-added">1157             negativePrefixPatterns.add(new Patterns());</span>
<span class="line-added">1158             positiveSuffixPatterns.add(new Patterns());</span>
<span class="line-added">1159             negativeSuffixPatterns.add(new Patterns());</span>
<span class="line-added">1160 </span>
<span class="line-added">1161             // check if it is the old style</span>
<span class="line-added">1162             Matcher m = text != null ? PLURALS.matcher(text) : null;</span>
<span class="line-added">1163             if (m != null &amp;&amp; m.matches()) {</span>
<span class="line-added">1164                 final int idx = index;</span>
<span class="line-added">1165                 String plurals = m.group(&quot;plurals&quot;);</span>
<span class="line-added">1166                 COUNT_PATTERN.matcher(plurals).results()</span>
<span class="line-added">1167                         .forEach(mr -&gt; applyPattern(mr.group(1), mr.group(2), idx));</span>
<span class="line-added">1168             } else {</span>
<span class="line-added">1169                 applyPattern(&quot;other&quot;, text, index);</span>
<span class="line-added">1170             }</span>
<span class="line-added">1171         }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173         rulesMap = buildPluralRulesMap();</span>
<span class="line-added">1174     }</span>
<span class="line-added">1175 </span>
<span class="line-added">1176     /**</span>
<span class="line-added">1177      * Build the plural rules map.</span>
<span class="line-added">1178      *</span>
<span class="line-added">1179      * @throws IllegalArgumentException if the {@code pluralRules} has invalid syntax,</span>
<span class="line-added">1180      *      or its length exceeds 2,048 chars</span>
<span class="line-added">1181      */</span>
<span class="line-added">1182     private Map&lt;String, String&gt; buildPluralRulesMap() {</span>
<span class="line-added">1183         // length limitation check. 2K for now.</span>
<span class="line-added">1184         if (pluralRules.length() &gt; 2_048) {</span>
<span class="line-added">1185             throw new IllegalArgumentException(&quot;plural rules is too long (&gt; 2,048)&quot;);</span>
<span class="line-added">1186         }</span>
<span class="line-added">1187 </span>
<span class="line-added">1188         try {</span>
<span class="line-added">1189             return Arrays.stream(pluralRules.split(&quot;;&quot;))</span>
<span class="line-added">1190                 .map(this::validateRule)</span>
<span class="line-added">1191                 .collect(Collectors.toMap(</span>
<span class="line-added">1192                         r -&gt; r.replaceFirst(&quot;:.*&quot;, &quot;&quot;),</span>
<span class="line-added">1193                         r -&gt; r.replaceFirst(&quot;[^:]+:&quot;, &quot;&quot;)</span>
<span class="line-added">1194                 ));</span>
<span class="line-added">1195         } catch (IllegalStateException ise) {</span>
<span class="line-added">1196             throw new IllegalArgumentException(ise);</span>
1197         }
1198     }
1199 
<span class="line-added">1200     // Patterns for plurals syntax validation</span>
<span class="line-added">1201     private final static String EXPR = &quot;([niftvw]{1})\\s*(([/\\%])\\s*(\\d+))*&quot;;</span>
<span class="line-added">1202     private final static String RELATION = &quot;(!{0,1}=)&quot;;</span>
<span class="line-added">1203     private final static String VALUE_RANGE = &quot;((\\d+)\\.\\.(\\d+)|\\d+)&quot;;</span>
<span class="line-added">1204     private final static String CONDITION = EXPR + &quot;\\s*&quot; +</span>
<span class="line-added">1205                                              RELATION + &quot;\\s*&quot; +</span>
<span class="line-added">1206                                              VALUE_RANGE + &quot;\\s*&quot; +</span>
<span class="line-added">1207                                              &quot;(\\,\\s*&quot; + VALUE_RANGE + &quot;)*&quot;;</span>
<span class="line-added">1208     private final static Pattern PLURALRULES_PATTERN =</span>
<span class="line-added">1209             Pattern.compile(&quot;(zero|one|two|few|many):\\s*&quot; +</span>
<span class="line-added">1210                             CONDITION +</span>
<span class="line-added">1211                             &quot;(\\s*(and|or)\\s*&quot; + CONDITION + &quot;)*&quot;);</span>
<span class="line-added">1212 </span>
<span class="line-added">1213     /**</span>
<span class="line-added">1214      * Validates a plural rule.</span>
<span class="line-added">1215      * @param rule rule to validate</span>
<span class="line-added">1216      * @throws IllegalArgumentException if the {@code rule} has invalid syntax</span>
<span class="line-added">1217      * @return the input rule (trimmed)</span>
<span class="line-added">1218      */</span>
<span class="line-added">1219     private String validateRule(String rule) {</span>
<span class="line-added">1220         rule = rule.trim();</span>
<span class="line-added">1221         if (!rule.isEmpty() &amp;&amp; !rule.equals(&quot;other:&quot;)) {</span>
<span class="line-added">1222             Matcher validator = PLURALRULES_PATTERN.matcher(rule);</span>
<span class="line-added">1223             if (!validator.matches()) {</span>
<span class="line-added">1224                 throw new IllegalArgumentException(&quot;Invalid plural rules syntax: &quot; + rule);</span>
<span class="line-added">1225             }</span>
<span class="line-added">1226         }</span>
<span class="line-added">1227 </span>
<span class="line-added">1228         return rule;</span>
<span class="line-added">1229     }</span>
<span class="line-added">1230 </span>
1231     /**
1232      * Process a compact pattern at a specific {@code index}
1233      * @param pattern the compact pattern to be processed
1234      * @param index index in the array of compact patterns
1235      *
1236      */
<span class="line-modified">1237     private void applyPattern(String count, String pattern, int index) {</span>
1238 
1239         if (pattern == null) {
1240             throw new IllegalArgumentException(&quot;A null compact pattern&quot; +
1241                     &quot; encountered at index: &quot; + index);
1242         }
1243 
1244         int start = 0;
1245         boolean gotNegative = false;
1246 
1247         String positivePrefix = &quot;&quot;;
1248         String positiveSuffix = &quot;&quot;;
1249         String negativePrefix = &quot;&quot;;
1250         String negativeSuffix = &quot;&quot;;
1251         String zeros = &quot;&quot;;
1252         for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {
1253 
1254             StringBuffer prefix = new StringBuffer();
1255             StringBuffer suffix = new StringBuffer();
1256             boolean inQuote = false;
1257             // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
</pre>
<hr />
<pre>
1392             // If there is no negative pattern, or if the negative pattern is
1393             // identical to the positive pattern, then prepend the minus sign to
1394             // the positive pattern to form the negative pattern.
1395             if (!gotNegative
1396                     || (negativePrefix.equals(positivePrefix)
1397                     &amp;&amp; negativeSuffix.equals(positiveSuffix))) {
1398                 negativeSuffix = positiveSuffix;
1399                 negativePrefix = &quot;&#39;-&quot; + positivePrefix;
1400             }
1401         }
1402 
1403         // If no 0s are specified in a non empty pattern, it is invalid
1404         if (!pattern.isEmpty() &amp;&amp; zeros.isEmpty()) {
1405             throw new IllegalArgumentException(&quot;Invalid pattern&quot;
1406                     + &quot; [&quot; + pattern + &quot;]: all patterns must include digit&quot;
1407                     + &quot; placement 0s&quot;);
1408         }
1409 
1410         // Only if positive affix exists; else put empty strings
1411         if (!positivePrefix.isEmpty() || !positiveSuffix.isEmpty()) {
<span class="line-modified">1412             positivePrefixPatterns.get(index).put(count, positivePrefix);</span>
<span class="line-modified">1413             negativePrefixPatterns.get(index).put(count, negativePrefix);</span>
<span class="line-modified">1414             positiveSuffixPatterns.get(index).put(count, positiveSuffix);</span>
<span class="line-modified">1415             negativeSuffixPatterns.get(index).put(count, negativeSuffix);</span>
<span class="line-modified">1416             if (divisors.size() &lt;= index) {</span>
<span class="line-added">1417                 divisors.add(computeDivisor(zeros, index));</span>
<span class="line-added">1418             }</span>
1419         } else {
<span class="line-modified">1420             positivePrefixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">1421             negativePrefixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">1422             positiveSuffixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">1423             negativeSuffixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">1424             if (divisors.size() &lt;= index) {</span>
<span class="line-added">1425                 divisors.add(1L);</span>
<span class="line-added">1426             }</span>
1427         }
1428     }
1429 
1430     private final transient DigitList digitList = new DigitList();
1431     private static final int STATUS_INFINITE = 0;
1432     private static final int STATUS_POSITIVE = 1;
1433     private static final int STATUS_LENGTH   = 2;
1434 
1435     private static final char ZERO_DIGIT = &#39;0&#39;;
1436     private static final char DIGIT = &#39;#&#39;;
1437     private static final char DECIMAL_SEPARATOR = &#39;.&#39;;
1438     private static final char GROUPING_SEPARATOR = &#39;,&#39;;
1439     private static final char MINUS_SIGN = &#39;-&#39;;
1440     private static final char PERCENT = &#39;%&#39;;
1441     private static final char PER_MILLE = &#39;\u2030&#39;;
1442     private static final char SEPARATOR = &#39;;&#39;;
1443     private static final char CURRENCY_SIGN = &#39;\u00A4&#39;;
1444     private static final char QUOTE = &#39;\&#39;&#39;;
1445 
1446     // Expanded form of positive/negative prefix/suffix,
1447     // the expanded form contains special characters in
1448     // its localized form, which are used for matching
1449     // while parsing a string to number
<span class="line-modified">1450     private transient List&lt;Patterns&gt; positivePrefixes;</span>
<span class="line-modified">1451     private transient List&lt;Patterns&gt; negativePrefixes;</span>
<span class="line-modified">1452     private transient List&lt;Patterns&gt; positiveSuffixes;</span>
<span class="line-modified">1453     private transient List&lt;Patterns&gt; negativeSuffixes;</span>
1454 
1455     private void expandAffixPatterns() {
1456         positivePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
1457         negativePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
1458         positiveSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
1459         negativeSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
1460         for (int index = 0; index &lt; compactPatterns.length; index++) {
<span class="line-modified">1461             positivePrefixes.add(positivePrefixPatterns.get(index).expandAffix());</span>
<span class="line-modified">1462             negativePrefixes.add(negativePrefixPatterns.get(index).expandAffix());</span>
<span class="line-modified">1463             positiveSuffixes.add(positiveSuffixPatterns.get(index).expandAffix());</span>
<span class="line-modified">1464             negativeSuffixes.add(negativeSuffixPatterns.get(index).expandAffix());</span>
1465         }
1466     }
1467 
1468     /**
1469      * Parses a compact number from a string to produce a {@code Number}.
1470      * &lt;p&gt;
1471      * The method attempts to parse text starting at the index given by
1472      * {@code pos}.
1473      * If parsing succeeds, then the index of {@code pos} is updated
1474      * to the index after the last character used (parsing does not necessarily
1475      * use all characters up to the end of the string), and the parsed
1476      * number is returned. The updated {@code pos} can be used to
1477      * indicate the starting point for the next call to this method.
1478      * If an error occurs, then the index of {@code pos} is not
1479      * changed, the error index of {@code pos} is set to the index of
1480      * the character where the error occurred, and {@code null} is returned.
1481      * &lt;p&gt;
1482      * The value is the numeric part in the given text multiplied
1483      * by the numeric equivalent of the affix attached
1484      * (For example, &quot;K&quot; = 1000 in {@link java.util.Locale#US US locale}).
</pre>
<hr />
<pre>
1502      *     and positive infinity and NaN are returned as {@code Double}
1503      *     instances holding the values of the corresponding
1504      *     {@code Double} constants.
1505      * &lt;/ul&gt;
1506      * &lt;p&gt;
1507      * {@code CompactNumberFormat} parses all Unicode characters that represent
1508      * decimal digits, as defined by {@code Character.digit()}. In
1509      * addition, {@code CompactNumberFormat} also recognizes as digits the ten
1510      * consecutive characters starting with the localized zero digit defined in
1511      * the {@code DecimalFormatSymbols} object.
1512      * &lt;p&gt;
1513      * {@code CompactNumberFormat} parse does not allow parsing scientific
1514      * notations. For example, parsing a string {@code &quot;1.05E4K&quot;} in
1515      * {@link java.util.Locale#US US locale} breaks at character &#39;E&#39;
1516      * and returns 1.05.
1517      *
1518      * @param text the string to be parsed
1519      * @param pos  a {@code ParsePosition} object with index and error
1520      *             index information as described above
1521      * @return the parsed value, or {@code null} if the parse fails
<span class="line-modified">1522      * @throws     NullPointerException if {@code text} or</span>
1523      *             {@code pos} is null
1524      *
1525      */
1526     @Override
1527     public Number parse(String text, ParsePosition pos) {
1528 
1529         Objects.requireNonNull(text);
1530         Objects.requireNonNull(pos);
1531 
1532         // Lazily expanding the affix patterns, on the first parse
1533         // call on this instance
1534         // If not initialized, expand and load all affixes
1535         if (positivePrefixes == null) {
1536             expandAffixPatterns();
1537         }
1538 
1539         // The compact number multiplier for parsed string.
1540         // Its value is set on parsing prefix and suffix. For example,
1541         // in the {@link java.util.Locale#US US locale} parsing {@code &quot;1K&quot;}
1542         // sets its value to 1000, as K (thousand) is abbreviated form of 1000.
1543         Number cnfMultiplier = 1L;
1544 
1545         // Special case NaN
1546         if (text.regionMatches(pos.index, symbols.getNaN(),
1547                 0, symbols.getNaN().length())) {
1548             pos.index = pos.index + symbols.getNaN().length();
1549             return Double.NaN;
1550         }
1551 
1552         int position = pos.index;
1553         int oldStart = pos.index;
1554         boolean gotPositive = false;
1555         boolean gotNegative = false;
1556         int matchedPosIndex = -1;
1557         int matchedNegIndex = -1;
1558         String matchedPosPrefix = &quot;&quot;;
1559         String matchedNegPrefix = &quot;&quot;;
1560         String defaultPosPrefix = defaultDecimalFormat.getPositivePrefix();
1561         String defaultNegPrefix = defaultDecimalFormat.getNegativePrefix();
<span class="line-added">1562         double num = parseNumberPart(text, position);</span>
<span class="line-added">1563 </span>
1564         // Prefix matching
1565         for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">1566             String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);</span>
<span class="line-modified">1567             String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);</span>
1568 
1569             // Do not break if a match occur; there is a possibility that the
1570             // subsequent affixes may match the longer subsequence in the given
1571             // string.
1572             // For example, matching &quot;Mdx 3&quot; with &quot;M&quot;, &quot;Md&quot; as prefix should
1573             // match with &quot;Md&quot;
1574             boolean match = matchAffix(text, position, positivePrefix,
1575                     defaultPosPrefix, matchedPosPrefix);
1576             if (match) {
1577                 matchedPosIndex = compactIndex;
1578                 matchedPosPrefix = positivePrefix;
1579                 gotPositive = true;
1580             }
1581 
1582             match = matchAffix(text, position, negativePrefix,
1583                     defaultNegPrefix, matchedNegPrefix);
1584             if (match) {
1585                 matchedNegIndex = compactIndex;
1586                 matchedNegPrefix = negativePrefix;
1587                 gotNegative = true;
</pre>
<hr />
<pre>
1649                 &amp;&amp; text.charAt(position) == symbols.getDecimalSeparator()) {
1650             position++; // Pass decimal character
1651             for (; position &lt; text.length(); ++position) {
1652                 char ch = text.charAt(position);
1653                 int digit = ch - symbols.getZeroDigit();
1654                 if (digit &lt; 0 || digit &gt; 9) {
1655                     digit = Character.digit(ch, 10);
1656                     // Parse all digit characters
1657                     if (!(digit &gt;= 0 &amp;&amp; digit &lt;= 9)) {
1658                         break;
1659                     }
1660                 }
1661             }
1662         }
1663 
1664         // Number parsed successfully; match prefix and
1665         // suffix to obtain multiplier
1666         pos.index = position;
1667         Number multiplier = computeParseMultiplier(text, pos,
1668                 gotPositive ? matchedPosPrefix : matchedNegPrefix,
<span class="line-modified">1669                 status, gotPositive, gotNegative, num);</span>
1670 
1671         if (multiplier.longValue() == -1L) {
1672             return null;
1673         } else if (multiplier.longValue() != 1L) {
1674             cnfMultiplier = multiplier;
1675         }
1676 
1677         // Special case INFINITY
1678         if (status[STATUS_INFINITE]) {
1679             if (status[STATUS_POSITIVE]) {
1680                 return Double.POSITIVE_INFINITY;
1681             } else {
1682                 return Double.NEGATIVE_INFINITY;
1683             }
1684         }
1685 
1686         if (isParseBigDecimal()) {
1687             BigDecimal bigDecimalResult = digitList.getBigDecimal();
1688 
1689             if (cnfMultiplier.longValue() != 1) {
</pre>
<hr />
<pre>
1691                         .multiply(new BigDecimal(cnfMultiplier.toString()));
1692             }
1693             if (!status[STATUS_POSITIVE]) {
1694                 bigDecimalResult = bigDecimalResult.negate();
1695             }
1696             return bigDecimalResult;
1697         } else {
1698             Number cnfResult;
1699             if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {
1700                 long longResult = digitList.getLong();
1701                 cnfResult = generateParseResult(longResult, false,
1702                         longResult &lt; 0, status, cnfMultiplier);
1703             } else {
1704                 cnfResult = generateParseResult(digitList.getDouble(),
1705                         true, false, status, cnfMultiplier);
1706             }
1707             return cnfResult;
1708         }
1709     }
1710 
<span class="line-added">1711     /**</span>
<span class="line-added">1712      * Parse the number part in the input text into a number</span>
<span class="line-added">1713      *</span>
<span class="line-added">1714      * @param text input text to be parsed</span>
<span class="line-added">1715      * @param position starting position</span>
<span class="line-added">1716      * @return the number</span>
<span class="line-added">1717      */</span>
<span class="line-added">1718     private static Pattern DIGITS = Pattern.compile(&quot;\\p{Nd}+&quot;);</span>
<span class="line-added">1719     private double parseNumberPart(String text, int position) {</span>
<span class="line-added">1720         if (text.startsWith(symbols.getInfinity(), position)) {</span>
<span class="line-added">1721             return Double.POSITIVE_INFINITY;</span>
<span class="line-added">1722         } else if (!text.startsWith(symbols.getNaN(), position)) {</span>
<span class="line-added">1723             Matcher m = DIGITS.matcher(text);</span>
<span class="line-added">1724             if (m.find(position)) {</span>
<span class="line-added">1725                 String digits = m.group();</span>
<span class="line-added">1726                 int cp = digits.codePointAt(0);</span>
<span class="line-added">1727                 if (Character.isDigit(cp)) {</span>
<span class="line-added">1728                     return Double.parseDouble(digits.codePoints()</span>
<span class="line-added">1729                         .map(Character::getNumericValue)</span>
<span class="line-added">1730                         .mapToObj(Integer::toString)</span>
<span class="line-added">1731                         .collect(Collectors.joining()));</span>
<span class="line-added">1732                 }</span>
<span class="line-added">1733             }</span>
<span class="line-added">1734         }</span>
<span class="line-added">1735         return Double.NaN;</span>
<span class="line-added">1736     }</span>
<span class="line-added">1737 </span>
1738     /**
1739      * Returns the parsed result by multiplying the parsed number
1740      * with the multiplier representing the prefix and suffix.
1741      *
1742      * @param number parsed number component
1743      * @param gotDouble whether the parsed number contains decimal
1744      * @param gotLongMin whether the parsed number is Long.MIN
1745      * @param status boolean status flags indicating whether the
1746      *               value is infinite and whether it is positive
1747      * @param cnfMultiplier compact number multiplier
1748      * @return parsed result
1749      */
1750     private Number generateParseResult(Number number, boolean gotDouble,
1751             boolean gotLongMin, boolean[] status, Number cnfMultiplier) {
1752 
1753         if (gotDouble) {
1754             if (cnfMultiplier.longValue() != 1L) {
1755                 double doubleResult = number.doubleValue() * cnfMultiplier.doubleValue();
1756                 doubleResult = (double) convertIfNegative(doubleResult, status, gotLongMin);
1757                 // Check if a double can be represeneted as a long
</pre>
<hr />
<pre>
1853     }
1854 
1855     /**
1856      * Computes multiplier by matching the given {@code matchedPrefix}
1857      * and suffix in the specified {@code text} from the lists of
1858      * prefixes and suffixes extracted from compact patterns.
1859      *
1860      * @param text the string to parse
1861      * @param parsePosition the {@code ParsePosition} object representing the
1862      *                      index and error index of the parse string
1863      * @param matchedPrefix prefix extracted which needs to be matched to
1864      *                      obtain the multiplier
1865      * @param status upon return contains boolean status flags indicating
1866      *               whether the value is positive
1867      * @param gotPositive based on the prefix parsed; whether the number is positive
1868      * @param gotNegative based on the prefix parsed; whether the number is negative
1869      * @return the multiplier matching the prefix and suffix; -1 otherwise
1870      */
1871     private Number computeParseMultiplier(String text, ParsePosition parsePosition,
1872             String matchedPrefix, boolean[] status, boolean gotPositive,
<span class="line-modified">1873             boolean gotNegative, double num) {</span>
1874 
1875         int position = parsePosition.index;
1876         boolean gotPos = false;
1877         boolean gotNeg = false;
1878         int matchedPosIndex = -1;
1879         int matchedNegIndex = -1;
1880         String matchedPosSuffix = &quot;&quot;;
1881         String matchedNegSuffix = &quot;&quot;;
1882         for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">1883             String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);</span>
<span class="line-modified">1884             String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);</span>
<span class="line-modified">1885             String positiveSuffix = getAffix(true, false, false, compactIndex, (int)num);</span>
<span class="line-modified">1886             String negativeSuffix = getAffix(true, false, true, compactIndex, (int)num);</span>
1887 
1888             // Do not break if a match occur; there is a possibility that the
1889             // subsequent affixes may match the longer subsequence in the given
1890             // string.
1891             // For example, matching &quot;3Mdx&quot; with &quot;M&quot;, &quot;Md&quot; should match with &quot;Md&quot;
1892             boolean match = matchPrefixAndSuffix(text, position, positivePrefix, matchedPrefix,
1893                     defaultDecimalFormat.getPositivePrefix(), positiveSuffix,
1894                     matchedPosSuffix, defaultDecimalFormat.getPositiveSuffix());
1895             if (match) {
1896                 matchedPosIndex = compactIndex;
1897                 matchedPosSuffix = positiveSuffix;
1898                 gotPos = true;
1899             }
1900 
1901             match = matchPrefixAndSuffix(text, position, negativePrefix, matchedPrefix,
1902                     defaultDecimalFormat.getNegativePrefix(), negativeSuffix,
1903                     matchedNegSuffix, defaultDecimalFormat.getNegativeSuffix());
1904             if (match) {
1905                 matchedNegIndex = compactIndex;
1906                 matchedNegSuffix = negativeSuffix;
</pre>
<hr />
<pre>
1968      * Reconstitutes this {@code CompactNumberFormat} from a stream
1969      * (that is, deserializes it) after performing some validations.
1970      * This method throws InvalidObjectException, if the stream data is invalid
1971      * because of the following reasons,
1972      * &lt;ul&gt;
1973      * &lt;li&gt; If any of the {@code decimalPattern}, {@code compactPatterns},
1974      * {@code symbols} or {@code roundingMode} is {@code null}.
1975      * &lt;li&gt; If the {@code decimalPattern} or the {@code compactPatterns} array
1976      * contains an invalid pattern or if a {@code null} appears in the array of
1977      * compact patterns.
1978      * &lt;li&gt; If the {@code minimumIntegerDigits} is greater than the
1979      * {@code maximumIntegerDigits} or the {@code minimumFractionDigits} is
1980      * greater than the {@code maximumFractionDigits}. This check is performed
1981      * by superclass&#39;s Object.
1982      * &lt;li&gt; If any of the minimum/maximum integer/fraction digit count is
1983      * negative. This check is performed by superclass&#39;s readObject.
1984      * &lt;li&gt; If the minimum or maximum integer digit count is larger than 309 or
1985      * if the minimum or maximum fraction digit count is larger than 340.
1986      * &lt;li&gt; If the grouping size is negative or larger than 127.
1987      * &lt;/ul&gt;
<span class="line-added">1988      * If the {@code pluralRules} field is not deserialized from the stream, it</span>
<span class="line-added">1989      * will be set to an empty string.</span>
1990      *
1991      * @param inStream the stream
1992      * @throws IOException if an I/O error occurs
1993      * @throws ClassNotFoundException if the class of a serialized object
1994      *         could not be found
1995      */
<span class="line-added">1996     @java.io.Serial</span>
1997     private void readObject(ObjectInputStream inStream) throws IOException,
1998             ClassNotFoundException {
1999 
2000         inStream.defaultReadObject();
2001         if (decimalPattern == null || compactPatterns == null
2002                 || symbols == null || roundingMode == null) {
2003             throw new InvalidObjectException(&quot;One of the &#39;decimalPattern&#39;,&quot;
2004                     + &quot; &#39;compactPatterns&#39;, &#39;symbols&#39; or &#39;roundingMode&#39;&quot;
2005                     + &quot; is null&quot;);
2006         }
2007 
2008         // Check only the maximum counts because NumberFormat.readObject has
2009         // already ensured that the maximum is greater than the minimum count.
2010         if (getMaximumIntegerDigits() &gt; DecimalFormat.DOUBLE_INTEGER_DIGITS
2011                 || getMaximumFractionDigits() &gt; DecimalFormat.DOUBLE_FRACTION_DIGITS) {
2012             throw new InvalidObjectException(&quot;Digit count out of range&quot;);
2013         }
2014 
2015         // Check if the grouping size is negative, on an attempt to
2016         // put value &gt; 127, it wraps around, so check just negative value
2017         if (groupingSize &lt; 0) {
2018             throw new InvalidObjectException(&quot;Grouping size is negative&quot;);
2019         }
2020 
<span class="line-added">2021         // pluralRules is since 14. Fill in empty string if it is null</span>
<span class="line-added">2022         if (pluralRules == null) {</span>
<span class="line-added">2023             pluralRules = &quot;&quot;;</span>
<span class="line-added">2024         }</span>
<span class="line-added">2025 </span>
2026         try {
2027             processCompactPatterns();
2028         } catch (IllegalArgumentException ex) {
2029             throw new InvalidObjectException(ex.getMessage());
2030         }
2031 
2032         decimalFormat = new DecimalFormat(SPECIAL_PATTERN, symbols);
2033         decimalFormat.setMaximumFractionDigits(getMaximumFractionDigits());
2034         decimalFormat.setMinimumFractionDigits(getMinimumFractionDigits());
2035         decimalFormat.setMaximumIntegerDigits(getMaximumIntegerDigits());
2036         decimalFormat.setMinimumIntegerDigits(getMinimumIntegerDigits());
2037         decimalFormat.setRoundingMode(getRoundingMode());
2038         decimalFormat.setGroupingSize(getGroupingSize());
2039         decimalFormat.setGroupingUsed(isGroupingUsed());
2040         decimalFormat.setParseIntegerOnly(isParseIntegerOnly());
2041 
2042         try {
2043             defaultDecimalFormat = new DecimalFormat(decimalPattern, symbols);
2044             defaultDecimalFormat.setMaximumFractionDigits(0);
2045         } catch (IllegalArgumentException ex) {
</pre>
<hr />
<pre>
2307      * Checks if this {@code CompactNumberFormat} is equal to the
2308      * specified {@code obj}. The objects of type {@code CompactNumberFormat}
2309      * are compared, other types return false; obeys the general contract of
2310      * {@link java.lang.Object#equals(java.lang.Object) Object.equals}.
2311      *
2312      * @param obj the object to compare with
2313      * @return true if this is equal to the other {@code CompactNumberFormat}
2314      */
2315     @Override
2316     public boolean equals(Object obj) {
2317 
2318         if (!super.equals(obj)) {
2319             return false;
2320         }
2321 
2322         CompactNumberFormat other = (CompactNumberFormat) obj;
2323         return decimalPattern.equals(other.decimalPattern)
2324                 &amp;&amp; symbols.equals(other.symbols)
2325                 &amp;&amp; Arrays.equals(compactPatterns, other.compactPatterns)
2326                 &amp;&amp; roundingMode.equals(other.roundingMode)
<span class="line-added">2327                 &amp;&amp; pluralRules.equals(other.pluralRules)</span>
2328                 &amp;&amp; groupingSize == other.groupingSize
2329                 &amp;&amp; parseBigDecimal == other.parseBigDecimal;
2330     }
2331 
2332     /**
2333      * Returns the hash code for this {@code CompactNumberFormat} instance.
2334      *
2335      * @return hash code for this {@code CompactNumberFormat}
2336      */
2337     @Override
2338     public int hashCode() {
2339         return 31 * super.hashCode() +
<span class="line-modified">2340                 Objects.hash(decimalPattern, symbols, roundingMode, pluralRules)</span>
2341                 + Arrays.hashCode(compactPatterns) + groupingSize
2342                 + Boolean.hashCode(parseBigDecimal);
2343     }
2344 
2345     /**
2346      * Creates and returns a copy of this {@code CompactNumberFormat}
2347      * instance.
2348      *
2349      * @return a clone of this instance
2350      */
2351     @Override
2352     public CompactNumberFormat clone() {
2353         CompactNumberFormat other = (CompactNumberFormat) super.clone();
2354         other.compactPatterns = compactPatterns.clone();
2355         other.symbols = (DecimalFormatSymbols) symbols.clone();
2356         return other;
2357     }
2358 
<span class="line-modified">2359     /**</span>
<span class="line-added">2360      * Abstraction of affix patterns for each &quot;count&quot; tag.</span>
<span class="line-added">2361      */</span>
<span class="line-added">2362     private final class Patterns {</span>
<span class="line-added">2363         private Map&lt;String, String&gt; patternsMap = new HashMap&lt;&gt;();</span>
<span class="line-added">2364 </span>
<span class="line-added">2365         void put(String count, String pattern) {</span>
<span class="line-added">2366             patternsMap.put(count, pattern);</span>
<span class="line-added">2367         }</span>
<span class="line-added">2368 </span>
<span class="line-added">2369         String get(double num) {</span>
<span class="line-added">2370             return patternsMap.getOrDefault(getPluralCategory(num),</span>
<span class="line-added">2371                     patternsMap.getOrDefault(&quot;other&quot;, &quot;&quot;));</span>
<span class="line-added">2372         }</span>
<span class="line-added">2373 </span>
<span class="line-added">2374         Patterns expandAffix() {</span>
<span class="line-added">2375             Patterns ret = new Patterns();</span>
<span class="line-added">2376             patternsMap.entrySet().stream()</span>
<span class="line-added">2377                     .forEach(e -&gt; ret.put(e.getKey(), CompactNumberFormat.this.expandAffix(e.getValue())));</span>
<span class="line-added">2378             return ret;</span>
<span class="line-added">2379         }</span>
<span class="line-added">2380     }</span>
<span class="line-added">2381 </span>
<span class="line-added">2382     private final int getIntegerPart(double number, double divisor) {</span>
<span class="line-added">2383         return BigDecimal.valueOf(number)</span>
<span class="line-added">2384                 .divide(BigDecimal.valueOf(divisor), roundingMode).intValue();</span>
<span class="line-added">2385     }</span>
<span class="line-added">2386 </span>
<span class="line-added">2387     /**</span>
<span class="line-added">2388      * Returns LDML&#39;s tag from the plurals rules</span>
<span class="line-added">2389      *</span>
<span class="line-added">2390      * @param input input number in double type</span>
<span class="line-added">2391      * @return LDML &quot;count&quot; tag</span>
<span class="line-added">2392      */</span>
<span class="line-added">2393     private String getPluralCategory(double input) {</span>
<span class="line-added">2394         if (rulesMap != null) {</span>
<span class="line-added">2395             return rulesMap.entrySet().stream()</span>
<span class="line-added">2396                     .filter(e -&gt; matchPluralRule(e.getValue(), input))</span>
<span class="line-added">2397                     .map(e -&gt; e.getKey())</span>
<span class="line-added">2398                     .findFirst()</span>
<span class="line-added">2399                     .orElse(&quot;other&quot;);</span>
<span class="line-added">2400         }</span>
<span class="line-added">2401 </span>
<span class="line-added">2402         // defaults to &quot;other&quot;</span>
<span class="line-added">2403         return &quot;other&quot;;</span>
<span class="line-added">2404     }</span>
<span class="line-added">2405 </span>
<span class="line-added">2406     private static boolean matchPluralRule(String condition, double input) {</span>
<span class="line-added">2407         return Arrays.stream(condition.split(&quot;or&quot;))</span>
<span class="line-added">2408             .anyMatch(and_condition -&gt; {</span>
<span class="line-added">2409                 return Arrays.stream(and_condition.split(&quot;and&quot;))</span>
<span class="line-added">2410                     .allMatch(r -&gt; relationCheck(r, input));</span>
<span class="line-added">2411             });</span>
<span class="line-added">2412     }</span>
<span class="line-added">2413 </span>
<span class="line-added">2414     private final static String NAMED_EXPR = &quot;(?&lt;op&gt;[niftvw]{1})\\s*((?&lt;div&gt;[/\\%])\\s*(?&lt;val&gt;\\d+))*&quot;;</span>
<span class="line-added">2415     private final static String NAMED_RELATION = &quot;(?&lt;rel&gt;!{0,1}=)&quot;;</span>
<span class="line-added">2416     private final static String NAMED_VALUE_RANGE = &quot;(?&lt;start&gt;\\d+)\\.\\.(?&lt;end&gt;\\d+)|(?&lt;value&gt;\\d+)&quot;;</span>
<span class="line-added">2417     private final static Pattern EXPR_PATTERN = Pattern.compile(NAMED_EXPR);</span>
<span class="line-added">2418     private final static Pattern RELATION_PATTERN = Pattern.compile(NAMED_RELATION);</span>
<span class="line-added">2419     private final static Pattern VALUE_RANGE_PATTERN = Pattern.compile(NAMED_VALUE_RANGE);</span>
<span class="line-added">2420 </span>
<span class="line-added">2421     /**</span>
<span class="line-added">2422      * Checks if the &#39;input&#39; equals the value, or within the range.</span>
<span class="line-added">2423      *</span>
<span class="line-added">2424      * @param valueOrRange A string representing either a single value or a range</span>
<span class="line-added">2425      * @param input to examine in double</span>
<span class="line-added">2426      * @return match indicator</span>
<span class="line-added">2427      */</span>
<span class="line-added">2428     private static boolean valOrRangeMatches(String valueOrRange, double input) {</span>
<span class="line-added">2429         Matcher m = VALUE_RANGE_PATTERN.matcher(valueOrRange);</span>
<span class="line-added">2430 </span>
<span class="line-added">2431         if (m.find()) {</span>
<span class="line-added">2432             String value = m.group(&quot;value&quot;);</span>
<span class="line-added">2433             if (value != null) {</span>
<span class="line-added">2434                 return input == Double.parseDouble(value);</span>
<span class="line-added">2435             } else {</span>
<span class="line-added">2436                 return input &gt;= Double.parseDouble(m.group(&quot;start&quot;)) &amp;&amp;</span>
<span class="line-added">2437                        input &lt;= Double.parseDouble(m.group(&quot;end&quot;));</span>
<span class="line-added">2438             }</span>
<span class="line-added">2439         }</span>
<span class="line-added">2440 </span>
<span class="line-added">2441         return false;</span>
<span class="line-added">2442     }</span>
<span class="line-added">2443 </span>
<span class="line-added">2444     /**</span>
<span class="line-added">2445      * Checks if the input value satisfies the relation. Each possible value or range is</span>
<span class="line-added">2446      * separated by a comma &#39;,&#39;</span>
<span class="line-added">2447      *</span>
<span class="line-added">2448      * @param relation relation string, e.g, &quot;n = 1, 3..5&quot;, or &quot;n != 1, 3..5&quot;</span>
<span class="line-added">2449      * @param input value to examine in double</span>
<span class="line-added">2450      * @return boolean to indicate whether the relation satisfies or not. If the relation</span>
<span class="line-added">2451      *  is &#39;=&#39;, true if any of the possible value/range satisfies. If the relation is &#39;!=&#39;,</span>
<span class="line-added">2452      *  none of the possible value/range should satisfy to return true.</span>
<span class="line-added">2453      */</span>
<span class="line-added">2454     private static boolean relationCheck(String relation, double input) {</span>
<span class="line-added">2455         Matcher expr = EXPR_PATTERN.matcher(relation);</span>
<span class="line-added">2456 </span>
<span class="line-added">2457         if (expr.find()) {</span>
<span class="line-added">2458             double lop = evalLOperand(expr, input);</span>
<span class="line-added">2459             Matcher rel = RELATION_PATTERN.matcher(relation);</span>
<span class="line-added">2460 </span>
<span class="line-added">2461             if (rel.find(expr.end())) {</span>
<span class="line-added">2462                 var conditions =</span>
<span class="line-added">2463                     Arrays.stream(relation.substring(rel.end()).split(&quot;,&quot;));</span>
<span class="line-added">2464 </span>
<span class="line-added">2465                 if (rel.group(&quot;rel&quot;).equals(&quot;!=&quot;)) {</span>
<span class="line-added">2466                     return conditions.noneMatch(c -&gt; valOrRangeMatches(c, lop));</span>
<span class="line-added">2467                 } else {</span>
<span class="line-added">2468                     return conditions.anyMatch(c -&gt; valOrRangeMatches(c, lop));</span>
<span class="line-added">2469                 }</span>
<span class="line-added">2470             }</span>
<span class="line-added">2471         }</span>
<span class="line-added">2472 </span>
<span class="line-added">2473         return false;</span>
<span class="line-added">2474     }</span>
2475 
<span class="line-added">2476     /**</span>
<span class="line-added">2477      * Evaluates the left operand value.</span>
<span class="line-added">2478      *</span>
<span class="line-added">2479      * @param expr Match result</span>
<span class="line-added">2480      * @param input value to examine in double</span>
<span class="line-added">2481      * @return resulting double value</span>
<span class="line-added">2482      */</span>
<span class="line-added">2483     private static double evalLOperand(Matcher expr, double input) {</span>
<span class="line-added">2484         double ret = 0;</span>
<span class="line-added">2485 </span>
<span class="line-added">2486         if (input == Double.POSITIVE_INFINITY) {</span>
<span class="line-added">2487             ret =input;</span>
<span class="line-added">2488         } else {</span>
<span class="line-added">2489             String op = expr.group(&quot;op&quot;);</span>
<span class="line-added">2490             if (op.equals(&quot;n&quot;) || op.equals(&quot;i&quot;)) {</span>
<span class="line-added">2491                 ret = input;</span>
<span class="line-added">2492             }</span>
<span class="line-added">2493 </span>
<span class="line-added">2494             String divop = expr.group(&quot;div&quot;);</span>
<span class="line-added">2495             if (divop != null) {</span>
<span class="line-added">2496                 String divisor = expr.group(&quot;val&quot;);</span>
<span class="line-added">2497                 switch (divop) {</span>
<span class="line-added">2498                     case &quot;%&quot;:</span>
<span class="line-added">2499                         ret %= Double.parseDouble(divisor);</span>
<span class="line-added">2500                         break;</span>
<span class="line-added">2501                     case &quot;/&quot;:</span>
<span class="line-added">2502                         ret /= Double.parseDouble(divisor);</span>
<span class="line-added">2503                         break;</span>
<span class="line-added">2504                 }</span>
<span class="line-added">2505             }</span>
<span class="line-added">2506         }</span>
<span class="line-added">2507 </span>
<span class="line-added">2508         return ret;</span>
<span class="line-added">2509     }</span>
<span class="line-added">2510 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="Collator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormat.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/lang/constant/ClassDesc.java b/src/java.base/share/classes/java/lang/constant/ClassDesc.java
--- a/src/java.base/share/classes/java/lang/constant/ClassDesc.java
+++ b/src/java.base/share/classes/java/lang/constant/ClassDesc.java
@@ -70,11 +70,11 @@
      * {@link #ofDescriptor(String)} or use the predefined constants in
      * {@link ConstantDescs}).
      *
      * @param name the fully qualified (dot-separated) binary class name
      * @return a {@linkplain ClassDesc} describing the desired class
-     * @throws NullPointerException if any argument is {@code null}
+     * @throws NullPointerException if the argument is {@code null}
      * @throws IllegalArgumentException if the name string is not in the
      * correct format
      */
     static ClassDesc of(String name) {
         ConstantUtils.validateBinaryClassName(requireNonNull(name));
@@ -121,11 +121,11 @@
      * {@code "[I"}, {@code "V"}, {@code "[Ljava/lang/String;"}, etc.
      * See JVMS 4.3.2 ("Field Descriptors") for more detail.
      *
      * @param descriptor a field descriptor string
      * @return a {@linkplain ClassDesc} describing the desired class
-     * @throws NullPointerException if any argument is {@code null}
+     * @throws NullPointerException if the argument is {@code null}
      * @throws IllegalArgumentException if the name string is not in the
      * correct format
      * @jvms 4.3.2 Field Descriptors
      * @jvms 4.4.1 The CONSTANT_Class_info Structure
      */
@@ -191,11 +191,11 @@
      * descriptor for the class {@code java.util.Map.Entry} could be obtained
      * by {@code d.nested("Entry")}.
      *
      * @param nestedName the unqualified name of the nested class
      * @return a {@linkplain ClassDesc} describing the nested class
-     * @throws NullPointerException if any argument is {@code null}
+     * @throws NullPointerException if the argument is {@code null}
      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
      * describe a class or interface type
      * @throws IllegalArgumentException if the nested class name is invalid
      */
     default ClassDesc nested(String nestedName) {
@@ -211,18 +211,23 @@
      *
      * @param firstNestedName the unqualified name of the first level of nested class
      * @param moreNestedNames the unqualified name(s) of the remaining levels of
      *                       nested class
      * @return a {@linkplain ClassDesc} describing the nested class
-     * @throws NullPointerException if any argument is {@code null}
+     * @throws NullPointerException if any argument or its contents is {@code null}
      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
      * describe a class or interface type
      * @throws IllegalArgumentException if the nested class name is invalid
      */
     default ClassDesc nested(String firstNestedName, String... moreNestedNames) {
         if (!isClassOrInterface())
             throw new IllegalStateException("Outer class is not a class or interface type");
+        validateMemberName(firstNestedName, false);
+        requireNonNull(moreNestedNames);
+        for (String addNestedNames : moreNestedNames) {
+            validateMemberName(addNestedNames, false);
+        }
         return moreNestedNames.length == 0
                ? nested(firstNestedName)
                : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining("$", "$", "")));
     }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/PriorityQueue.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Optional.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Properties.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/PriorityQueue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.util.function.Consumer;
 29 import java.util.function.Predicate;
 30 import jdk.internal.access.SharedSecrets;

 31 
 32 /**
 33  * An unbounded priority {@linkplain Queue queue} based on a priority heap.
 34  * The elements of the priority queue are ordered according to their
 35  * {@linkplain Comparable natural ordering}, or by a {@link Comparator}
 36  * provided at queue construction time, depending on which constructor is
 37  * used.  A priority queue does not permit {@code null} elements.
 38  * A priority queue relying on natural ordering also does not permit
 39  * insertion of non-comparable objects (doing so may result in
 40  * {@code ClassCastException}).
 41  *
 42  * &lt;p&gt;The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element
 43  * with respect to the specified ordering.  If multiple elements are
 44  * tied for least value, the head is one of those elements -- ties are
 45  * broken arbitrarily.  The queue retrieval operations {@code poll},
 46  * {@code remove}, {@code peek}, and {@code element} access the
 47  * element at the head of the queue.
 48  *
 49  * &lt;p&gt;A priority queue is unbounded, but has an internal
 50  * &lt;i&gt;capacity&lt;/i&gt; governing the size of an array used to store the
</pre>
<hr />
<pre>
 69  *
 70  * &lt;p&gt;Implementation note: this implementation provides
 71  * O(log(n)) time for the enqueuing and dequeuing methods
 72  * ({@code offer}, {@code poll}, {@code remove()} and {@code add});
 73  * linear time for the {@code remove(Object)} and {@code contains(Object)}
 74  * methods; and constant time for the retrieval methods
 75  * ({@code peek}, {@code element}, and {@code size}).
 76  *
 77  * &lt;p&gt;This class is a member of the
 78  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 79  * Java Collections Framework&lt;/a&gt;.
 80  *
 81  * @since 1.5
 82  * @author Josh Bloch, Doug Lea
 83  * @param &lt;E&gt; the type of elements held in this queue
 84  */
 85 @SuppressWarnings(&quot;unchecked&quot;)
 86 public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
 87     implements java.io.Serializable {
 88 

 89     private static final long serialVersionUID = -7720805057305804111L;
 90 
 91     private static final int DEFAULT_INITIAL_CAPACITY = 11;
 92 
 93     /**
 94      * Priority queue represented as a balanced binary heap: the two
 95      * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
 96      * priority queue is ordered by comparator, or by the elements&#39;
 97      * natural ordering, if comparator is null: For each node n in the
 98      * heap and each descendant d of n, n &lt;= d.  The element with the
 99      * lowest value is in queue[0], assuming the queue is nonempty.
100      */
101     transient Object[] queue; // non-private to simplify nested class access
102 
103     /**
104      * The number of elements in the priority queue.
105      */
106     int size;
107 
108     /**
109      * The comparator, or null if priority queue uses elements&#39;
110      * natural ordering.
111      */

112     private final Comparator&lt;? super E&gt; comparator;
113 
114     /**
115      * The number of times this priority queue has been
116      * &lt;i&gt;structurally modified&lt;/i&gt;.  See AbstractList for gory details.
117      */
118     transient int modCount;     // non-private to simplify nested class access
119 
120     /**
121      * Creates a {@code PriorityQueue} with the default initial
122      * capacity (11) that orders its elements according to their
123      * {@linkplain Comparable natural ordering}.
124      */
125     public PriorityQueue() {
126         this(DEFAULT_INITIAL_CAPACITY, null);
127     }
128 
129     /**
130      * Creates a {@code PriorityQueue} with the specified initial
131      * capacity that orders its elements according to their
</pre>
<hr />
<pre>
264         if (es.getClass() != Object[].class)
265             es = Arrays.copyOf(es, len, Object[].class);
266         if (len == 1 || this.comparator != null)
267             for (Object e : es)
268                 if (e == null)
269                     throw new NullPointerException();
270         this.queue = ensureNonEmpty(es);
271         this.size = len;
272     }
273 
274     /**
275      * Initializes queue array with elements from the given Collection.
276      *
277      * @param c the collection
278      */
279     private void initFromCollection(Collection&lt;? extends E&gt; c) {
280         initElementsFromCollection(c);
281         heapify();
282     }
283 
<span class="line-removed">284     /**</span>
<span class="line-removed">285      * The maximum size of array to allocate.</span>
<span class="line-removed">286      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">287      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">288      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">289      */</span>
<span class="line-removed">290     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">291 </span>
292     /**
293      * Increases the capacity of the array.
294      *
295      * @param minCapacity the desired minimum capacity
296      */
297     private void grow(int minCapacity) {
298         int oldCapacity = queue.length;
299         // Double size if small; else grow by 50%
<span class="line-modified">300         int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span>
<span class="line-modified">301                                          (oldCapacity + 2) :</span>
<span class="line-modified">302                                          (oldCapacity &gt;&gt; 1));</span>
<span class="line-modified">303         // overflow-conscious code</span>
<span class="line-removed">304         if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span>
<span class="line-removed">305             newCapacity = hugeCapacity(minCapacity);</span>
306         queue = Arrays.copyOf(queue, newCapacity);
307     }
308 
<span class="line-removed">309     private static int hugeCapacity(int minCapacity) {</span>
<span class="line-removed">310         if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed">311             throw new OutOfMemoryError();</span>
<span class="line-removed">312         return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span>
<span class="line-removed">313             Integer.MAX_VALUE :</span>
<span class="line-removed">314             MAX_ARRAY_SIZE;</span>
<span class="line-removed">315     }</span>
<span class="line-removed">316 </span>
317     /**
318      * Inserts the specified element into this priority queue.
319      *
320      * @return {@code true} (as specified by {@link Collection#add})
321      * @throws ClassCastException if the specified element cannot be
322      *         compared with elements currently in this priority queue
323      *         according to the priority queue&#39;s ordering
324      * @throws NullPointerException if the specified element is null
325      */
326     public boolean add(E e) {
327         return offer(e);
328     }
329 
330     /**
331      * Inserts the specified element into this priority queue.
332      *
333      * @return {@code true} (as specified by {@link Queue#offer})
334      * @throws ClassCastException if the specified element cannot be
335      *         compared with elements currently in this priority queue
336      *         according to the priority queue&#39;s ordering
</pre>
<hr />
<pre>
755      * queue, or {@code null} if this queue is sorted according to
756      * the {@linkplain Comparable natural ordering} of its elements.
757      *
758      * @return the comparator used to order this queue, or
759      *         {@code null} if this queue is sorted according to the
760      *         natural ordering of its elements
761      */
762     public Comparator&lt;? super E&gt; comparator() {
763         return comparator;
764     }
765 
766     /**
767      * Saves this queue to a stream (that is, serializes it).
768      *
769      * @param s the stream
770      * @throws java.io.IOException if an I/O error occurs
771      * @serialData The length of the array backing the instance is
772      *             emitted (int), followed by all of its elements
773      *             (each an {@code Object}) in the proper order.
774      */

775     private void writeObject(java.io.ObjectOutputStream s)
776         throws java.io.IOException {
777         // Write out element count, and any hidden stuff
778         s.defaultWriteObject();
779 
780         // Write out array length, for compatibility with 1.5 version
781         s.writeInt(Math.max(2, size + 1));
782 
783         // Write out all elements in the &quot;proper order&quot;.
784         final Object[] es = queue;
785         for (int i = 0, n = size; i &lt; n; i++)
786             s.writeObject(es[i]);
787     }
788 
789     /**
790      * Reconstitutes the {@code PriorityQueue} instance from a stream
791      * (that is, deserializes it).
792      *
793      * @param s the stream
794      * @throws ClassNotFoundException if the class of a serialized object
795      *         could not be found
796      * @throws java.io.IOException if an I/O error occurs
797      */

798     private void readObject(java.io.ObjectInputStream s)
799         throws java.io.IOException, ClassNotFoundException {
800         // Read in size, and any hidden stuff
801         s.defaultReadObject();
802 
803         // Read in (and discard) array length
804         s.readInt();
805 
806         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
807         final Object[] es = queue = new Object[Math.max(size, 1)];
808 
809         // Read in all elements.
810         for (int i = 0, n = size; i &lt; n; i++)
811             es[i] = s.readObject();
812 
813         // Elements are guaranteed to be in &quot;proper order&quot;, but the
814         // spec has never explained what that might be.
815         heapify();
816     }
817 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.util.function.Consumer;
 29 import java.util.function.Predicate;
 30 import jdk.internal.access.SharedSecrets;
<span class="line-added"> 31 import jdk.internal.util.ArraysSupport;</span>
 32 
 33 /**
 34  * An unbounded priority {@linkplain Queue queue} based on a priority heap.
 35  * The elements of the priority queue are ordered according to their
 36  * {@linkplain Comparable natural ordering}, or by a {@link Comparator}
 37  * provided at queue construction time, depending on which constructor is
 38  * used.  A priority queue does not permit {@code null} elements.
 39  * A priority queue relying on natural ordering also does not permit
 40  * insertion of non-comparable objects (doing so may result in
 41  * {@code ClassCastException}).
 42  *
 43  * &lt;p&gt;The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element
 44  * with respect to the specified ordering.  If multiple elements are
 45  * tied for least value, the head is one of those elements -- ties are
 46  * broken arbitrarily.  The queue retrieval operations {@code poll},
 47  * {@code remove}, {@code peek}, and {@code element} access the
 48  * element at the head of the queue.
 49  *
 50  * &lt;p&gt;A priority queue is unbounded, but has an internal
 51  * &lt;i&gt;capacity&lt;/i&gt; governing the size of an array used to store the
</pre>
<hr />
<pre>
 70  *
 71  * &lt;p&gt;Implementation note: this implementation provides
 72  * O(log(n)) time for the enqueuing and dequeuing methods
 73  * ({@code offer}, {@code poll}, {@code remove()} and {@code add});
 74  * linear time for the {@code remove(Object)} and {@code contains(Object)}
 75  * methods; and constant time for the retrieval methods
 76  * ({@code peek}, {@code element}, and {@code size}).
 77  *
 78  * &lt;p&gt;This class is a member of the
 79  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 80  * Java Collections Framework&lt;/a&gt;.
 81  *
 82  * @since 1.5
 83  * @author Josh Bloch, Doug Lea
 84  * @param &lt;E&gt; the type of elements held in this queue
 85  */
 86 @SuppressWarnings(&quot;unchecked&quot;)
 87 public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
 88     implements java.io.Serializable {
 89 
<span class="line-added"> 90     @java.io.Serial</span>
 91     private static final long serialVersionUID = -7720805057305804111L;
 92 
 93     private static final int DEFAULT_INITIAL_CAPACITY = 11;
 94 
 95     /**
 96      * Priority queue represented as a balanced binary heap: the two
 97      * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
 98      * priority queue is ordered by comparator, or by the elements&#39;
 99      * natural ordering, if comparator is null: For each node n in the
100      * heap and each descendant d of n, n &lt;= d.  The element with the
101      * lowest value is in queue[0], assuming the queue is nonempty.
102      */
103     transient Object[] queue; // non-private to simplify nested class access
104 
105     /**
106      * The number of elements in the priority queue.
107      */
108     int size;
109 
110     /**
111      * The comparator, or null if priority queue uses elements&#39;
112      * natural ordering.
113      */
<span class="line-added">114     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
115     private final Comparator&lt;? super E&gt; comparator;
116 
117     /**
118      * The number of times this priority queue has been
119      * &lt;i&gt;structurally modified&lt;/i&gt;.  See AbstractList for gory details.
120      */
121     transient int modCount;     // non-private to simplify nested class access
122 
123     /**
124      * Creates a {@code PriorityQueue} with the default initial
125      * capacity (11) that orders its elements according to their
126      * {@linkplain Comparable natural ordering}.
127      */
128     public PriorityQueue() {
129         this(DEFAULT_INITIAL_CAPACITY, null);
130     }
131 
132     /**
133      * Creates a {@code PriorityQueue} with the specified initial
134      * capacity that orders its elements according to their
</pre>
<hr />
<pre>
267         if (es.getClass() != Object[].class)
268             es = Arrays.copyOf(es, len, Object[].class);
269         if (len == 1 || this.comparator != null)
270             for (Object e : es)
271                 if (e == null)
272                     throw new NullPointerException();
273         this.queue = ensureNonEmpty(es);
274         this.size = len;
275     }
276 
277     /**
278      * Initializes queue array with elements from the given Collection.
279      *
280      * @param c the collection
281      */
282     private void initFromCollection(Collection&lt;? extends E&gt; c) {
283         initElementsFromCollection(c);
284         heapify();
285     }
286 








287     /**
288      * Increases the capacity of the array.
289      *
290      * @param minCapacity the desired minimum capacity
291      */
292     private void grow(int minCapacity) {
293         int oldCapacity = queue.length;
294         // Double size if small; else grow by 50%
<span class="line-modified">295         int newCapacity = ArraysSupport.newLength(oldCapacity,</span>
<span class="line-modified">296                 minCapacity - oldCapacity, /* minimum growth */</span>
<span class="line-modified">297                 oldCapacity &lt; 64 ? oldCapacity + 2 : oldCapacity &gt;&gt; 1</span>
<span class="line-modified">298                                            /* preferred growth */);</span>


299         queue = Arrays.copyOf(queue, newCapacity);
300     }
301 








302     /**
303      * Inserts the specified element into this priority queue.
304      *
305      * @return {@code true} (as specified by {@link Collection#add})
306      * @throws ClassCastException if the specified element cannot be
307      *         compared with elements currently in this priority queue
308      *         according to the priority queue&#39;s ordering
309      * @throws NullPointerException if the specified element is null
310      */
311     public boolean add(E e) {
312         return offer(e);
313     }
314 
315     /**
316      * Inserts the specified element into this priority queue.
317      *
318      * @return {@code true} (as specified by {@link Queue#offer})
319      * @throws ClassCastException if the specified element cannot be
320      *         compared with elements currently in this priority queue
321      *         according to the priority queue&#39;s ordering
</pre>
<hr />
<pre>
740      * queue, or {@code null} if this queue is sorted according to
741      * the {@linkplain Comparable natural ordering} of its elements.
742      *
743      * @return the comparator used to order this queue, or
744      *         {@code null} if this queue is sorted according to the
745      *         natural ordering of its elements
746      */
747     public Comparator&lt;? super E&gt; comparator() {
748         return comparator;
749     }
750 
751     /**
752      * Saves this queue to a stream (that is, serializes it).
753      *
754      * @param s the stream
755      * @throws java.io.IOException if an I/O error occurs
756      * @serialData The length of the array backing the instance is
757      *             emitted (int), followed by all of its elements
758      *             (each an {@code Object}) in the proper order.
759      */
<span class="line-added">760     @java.io.Serial</span>
761     private void writeObject(java.io.ObjectOutputStream s)
762         throws java.io.IOException {
763         // Write out element count, and any hidden stuff
764         s.defaultWriteObject();
765 
766         // Write out array length, for compatibility with 1.5 version
767         s.writeInt(Math.max(2, size + 1));
768 
769         // Write out all elements in the &quot;proper order&quot;.
770         final Object[] es = queue;
771         for (int i = 0, n = size; i &lt; n; i++)
772             s.writeObject(es[i]);
773     }
774 
775     /**
776      * Reconstitutes the {@code PriorityQueue} instance from a stream
777      * (that is, deserializes it).
778      *
779      * @param s the stream
780      * @throws ClassNotFoundException if the class of a serialized object
781      *         could not be found
782      * @throws java.io.IOException if an I/O error occurs
783      */
<span class="line-added">784     @java.io.Serial</span>
785     private void readObject(java.io.ObjectInputStream s)
786         throws java.io.IOException, ClassNotFoundException {
787         // Read in size, and any hidden stuff
788         s.defaultReadObject();
789 
790         // Read in (and discard) array length
791         s.readInt();
792 
793         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
794         final Object[] es = queue = new Object[Math.max(size, 1)];
795 
796         // Read in all elements.
797         for (int i = 0, n = size; i &lt; n; i++)
798             es[i] = s.readObject();
799 
800         // Elements are guaranteed to be in &quot;proper order&quot;, but the
801         // spec has never explained what that might be.
802         heapify();
803     }
804 
</pre>
</td>
</tr>
</table>
<center><a href="Optional.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Properties.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
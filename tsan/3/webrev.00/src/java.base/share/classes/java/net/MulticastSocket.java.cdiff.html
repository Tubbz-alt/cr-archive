<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/MulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MalformedURLException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/MulticastSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,68 ***</span>
   */
  
  package java.net;
  
  import java.io.IOException;
  import java.util.Collections;
  import java.util.Enumeration;
  import java.util.Set;
  
  /**
   * The multicast datagram socket class is useful for sending
<span class="line-modified">!  * and receiving IP multicast packets.  A MulticastSocket is</span>
   * a (UDP) DatagramSocket, with additional capabilities for
   * joining &quot;groups&quot; of other multicast hosts on the internet.
   * &lt;P&gt;
   * A multicast group is specified by a class D IP address
   * and by a standard UDP port number. Class D IP addresses
<span class="line-modified">!  * are in the range &lt;CODE&gt;224.0.0.0&lt;/CODE&gt; to &lt;CODE&gt;239.255.255.255&lt;/CODE&gt;,</span>
   * inclusive. The address 224.0.0.0 is reserved and should not be used.
   * &lt;P&gt;
   * One would join a multicast group by first creating a MulticastSocket
   * with the desired port, then invoking the
   * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
   * method:
   * &lt;PRE&gt;
   * // join a Multicast group and send the group salutations
   * ...
   * String msg = &quot;Hello&quot;;
<span class="line-modified">!  * InetAddress group = InetAddress.getByName(&quot;228.5.6.7&quot;);</span>
   * MulticastSocket s = new MulticastSocket(6789);
<span class="line-modified">!  * s.joinGroup(group);</span>
   * byte[] msgBytes = msg.getBytes(StandardCharsets.UTF_8);
   * DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length,
   *                                        group, 6789);
   * s.send(hi);
   * // get their responses!
   * byte[] buf = new byte[1000];
   * DatagramPacket recv = new DatagramPacket(buf, buf.length);
   * s.receive(recv);
   * ...
   * // OK, I&#39;m done talking - leave the group...
<span class="line-modified">!  * s.leaveGroup(group);</span>
   * &lt;/PRE&gt;
   *
   * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
   * recipients to that host and port receive the message (within the
<span class="line-modified">!  * time-to-live range of the packet, see below).  The socket needn&#39;t</span>
   * be a member of the multicast group to send messages to it.
   * &lt;P&gt;
   * When a socket subscribes to a multicast group/port, it receives
   * datagrams sent by other hosts to the group/port, as do all other
   * members of the group and port.  A socket relinquishes membership
<span class="line-modified">!  * in a group by the leaveGroup(InetAddress addr) method.  &lt;B&gt;</span>
<span class="line-modified">!  * Multiple MulticastSocket&#39;s&lt;/B&gt; may subscribe to a multicast group</span>
   * and port concurrently, and they will all receive group datagrams.
<span class="line-modified">!  * &lt;P&gt;</span>
<span class="line-modified">!  * Currently applets are not allowed to use multicast sockets.</span>
   *
   * @author Pavani Diwanji
<span class="line-modified">!  * @since  1.1</span>
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class MulticastSocket extends DatagramSocket {</span>
  
      /**
       * Used on some platforms to record if an outgoing interface
       * has been set for this socket.
       */
<span class="line-new-header">--- 24,118 ---</span>
   */
  
  package java.net;
  
  import java.io.IOException;
<span class="line-added">+ import java.nio.channels.DatagramChannel;</span>
<span class="line-added">+ import java.nio.channels.MulticastChannel;</span>
  import java.util.Collections;
  import java.util.Enumeration;
  import java.util.Set;
  
  /**
   * The multicast datagram socket class is useful for sending
<span class="line-modified">!  * and receiving IP multicast packets. A MulticastSocket is</span>
   * a (UDP) DatagramSocket, with additional capabilities for
   * joining &quot;groups&quot; of other multicast hosts on the internet.
   * &lt;P&gt;
   * A multicast group is specified by a class D IP address
   * and by a standard UDP port number. Class D IP addresses
<span class="line-modified">!  * are in the range {@code 224.0.0.0} to {@code 239.255.255.255},</span>
   * inclusive. The address 224.0.0.0 is reserved and should not be used.
   * &lt;P&gt;
   * One would join a multicast group by first creating a MulticastSocket
   * with the desired port, then invoking the
   * &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
   * method:
   * &lt;PRE&gt;
   * // join a Multicast group and send the group salutations
   * ...
   * String msg = &quot;Hello&quot;;
<span class="line-modified">!  * InetAddress mcastaddr = InetAddress.getByName(&quot;228.5.6.7&quot;);</span>
<span class="line-added">+  * InetSocketAddress group = new InetSocketAddress(mcastaddr, port);</span>
<span class="line-added">+  * NetworkInterface netIf = NetworkInterface.getByName(&quot;bge0&quot;);</span>
   * MulticastSocket s = new MulticastSocket(6789);
<span class="line-modified">!  *</span>
<span class="line-added">+  * s.joinGroup(group, netIf);</span>
   * byte[] msgBytes = msg.getBytes(StandardCharsets.UTF_8);
   * DatagramPacket hi = new DatagramPacket(msgBytes, msgBytes.length,
   *                                        group, 6789);
   * s.send(hi);
   * // get their responses!
   * byte[] buf = new byte[1000];
   * DatagramPacket recv = new DatagramPacket(buf, buf.length);
   * s.receive(recv);
   * ...
   * // OK, I&#39;m done talking - leave the group...
<span class="line-modified">!  * s.leaveGroup(group, netIf);</span>
   * &lt;/PRE&gt;
   *
   * When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
   * recipients to that host and port receive the message (within the
<span class="line-modified">!  * time-to-live range of the packet, see below). The socket needn&#39;t</span>
   * be a member of the multicast group to send messages to it.
   * &lt;P&gt;
   * When a socket subscribes to a multicast group/port, it receives
   * datagrams sent by other hosts to the group/port, as do all other
   * members of the group and port.  A socket relinquishes membership
<span class="line-modified">!  * in a group by the leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)</span>
<span class="line-modified">!  * method.</span>
<span class="line-added">+  * &lt;B&gt;Multiple MulticastSockets&lt;/B&gt; may subscribe to a multicast group</span>
   * and port concurrently, and they will all receive group datagrams.
<span class="line-modified">!  *</span>
<span class="line-modified">!  * &lt;p&gt; The {@code DatagramSocket} and {@code MulticastSocket}</span>
<span class="line-added">+  * classes define convenience methods to set and get several</span>
<span class="line-added">+  * socket options. Like {@code DatagramSocket} this class also</span>
<span class="line-added">+  * supports the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="line-added">+  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">+  * and query socket options.</span>
<span class="line-added">+  * In addition to the socket options supported by</span>
<span class="line-added">+  * &lt;a href=&quot;DatagramSocket.html#SocketOptions&quot;&gt;{@code DatagramSocket}&lt;/a&gt;, a</span>
<span class="line-added">+  * {@code MulticastSocket} supports the following socket options:</span>
<span class="line-added">+  * &lt;blockquote&gt;</span>
<span class="line-added">+  * &lt;a id=&quot;MulticastOptions&quot;&gt;&lt;/a&gt;</span>
<span class="line-added">+  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">+  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">+  * &lt;thead&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/thead&gt;</span>
<span class="line-added">+  * &lt;tbody&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The network interface for Internet Protocol (IP) multicast datagrams &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL</span>
<span class="line-added">+  *       IP_MULTICAST_TTL} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast</span>
<span class="line-added">+  *       datagrams &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP</span>
<span class="line-added">+  *       IP_MULTICAST_LOOP} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/tbody&gt;</span>
<span class="line-added">+  * &lt;/table&gt;</span>
<span class="line-added">+  * &lt;/blockquote&gt;</span>
<span class="line-added">+  * Additional (implementation specific) options may also be supported.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @apiNote {@link DatagramChannel} implements the {@link MulticastChannel} interface</span>
<span class="line-added">+  *          and provides an alternative API for sending and receiving multicast datagrams.</span>
<span class="line-added">+  *          The {@link MulticastChannel} API supports both {@linkplain</span>
<span class="line-added">+  *          MulticastChannel#join(InetAddress, NetworkInterface) any-source} and</span>
<span class="line-added">+  *          {@linkplain MulticastChannel#join(InetAddress, NetworkInterface, InetAddress)</span>
<span class="line-added">+  *          source-specific} multicast.</span>
   *
   * @author Pavani Diwanji
<span class="line-modified">!  * @since 1.1</span>
   */
<span class="line-modified">! public class MulticastSocket extends DatagramSocket {</span>
  
      /**
       * Used on some platforms to record if an outgoing interface
       * has been set for this socket.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,13 ***</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
       * enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @exception IOException if an I/O exception occurs while creating the</span>
       * MulticastSocket
<span class="line-modified">!      * @exception SecurityException if a security manager exists and its</span>
       * {@code checkListen} method doesn&#39;t allow the operation.
       * @see SecurityManager#checkListen
       * @see java.net.DatagramSocket#setReuseAddress(boolean)
       * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
       */
<span class="line-new-header">--- 151,13 ---</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is called to
       * enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @throws    IOException if an I/O exception occurs while creating the</span>
       * MulticastSocket
<span class="line-modified">!      * @throws    SecurityException if a security manager exists and its</span>
       * {@code checkListen} method doesn&#39;t allow the operation.
       * @see SecurityManager#checkListen
       * @see java.net.DatagramSocket#setReuseAddress(boolean)
       * @see java.net.DatagramSocketImpl#setOption(SocketOption, Object)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,17 ***</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is
       * called to enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @param port port to use</span>
<span class="line-modified">!      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">!      * while creating the MulticastSocket</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @see SecurityManager#checkListen</span>
<span class="line-modified">!      * @see java.net.DatagramSocket#setReuseAddress(boolean)</span>
       */
      public MulticastSocket(int port) throws IOException {
          this(new InetSocketAddress(port));
      }
  
<span class="line-new-header">--- 176,17 ---</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is
       * called to enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @param     port port to use</span>
<span class="line-modified">!      * @throws    IOException if an I/O exception occurs</span>
<span class="line-modified">!      *            while creating the MulticastSocket</span>
<span class="line-modified">!      * @throws    SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      *            {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @see       SecurityManager#checkListen</span>
<span class="line-modified">!      * @see       java.net.DatagramSocket#setReuseAddress(boolean)</span>
       */
      public MulticastSocket(int port) throws IOException {
          this(new InetSocketAddress(port));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,24 ***</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is
       * called to enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @param bindaddr Socket address to bind to, or {@code null} for</span>
<span class="line-modified">!      *                 an unbound socket.</span>
<span class="line-modified">!      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">!      * while creating the MulticastSocket</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @see SecurityManager#checkListen</span>
<span class="line-modified">!      * @see java.net.DatagramSocket#setReuseAddress(boolean)</span>
       *
       * @since 1.4
       */
      public MulticastSocket(SocketAddress bindaddr) throws IOException {
          super((SocketAddress) null);
  
          // Enable SO_REUSEADDR before binding
          setReuseAddress(true);
  
          if (bindaddr != null) {
              try {
<span class="line-new-header">--- 202,28 ---</span>
       * &lt;p&gt;
       * When the socket is created the
       * {@link DatagramSocket#setReuseAddress(boolean)} method is
       * called to enable the SO_REUSEADDR socket option.
       *
<span class="line-modified">!      * @param    bindaddr Socket address to bind to, or {@code null} for</span>
<span class="line-modified">!      *           an unbound socket.</span>
<span class="line-modified">!      * @throws   IOException if an I/O exception occurs</span>
<span class="line-modified">!      *           while creating the MulticastSocket</span>
<span class="line-modified">!      * @throws   SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      *           {@code checkListen} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @see      SecurityManager#checkListen</span>
<span class="line-modified">!      * @see      java.net.DatagramSocket#setReuseAddress(boolean)</span>
       *
       * @since 1.4
       */
      public MulticastSocket(SocketAddress bindaddr) throws IOException {
          super((SocketAddress) null);
  
<span class="line-added">+         // No further initialization when this is a DatagramChannel socket adaptor</span>
<span class="line-added">+         if (this instanceof sun.nio.ch.DatagramSocketAdaptor)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
          // Enable SO_REUSEADDR before binding
          setReuseAddress(true);
  
          if (bindaddr != null) {
              try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,15 ***</span>
       * scope of the multicasts.
       *
       * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
       * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
       *
<span class="line-modified">!      * @param ttl the time-to-live</span>
<span class="line-modified">!      * @exception IOException if an I/O exception occurs</span>
<span class="line-modified">!      * while setting the default time-to-live value</span>
       * @deprecated use the setTimeToLive method instead, which uses
<span class="line-modified">!      * &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.</span>
       * @see #getTTL()
       */
      @Deprecated
      public void setTTL(byte ttl) throws IOException {
          if (isClosed())
<span class="line-new-header">--- 260,15 ---</span>
       * scope of the multicasts.
       *
       * &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
       * in the range {@code 0 &lt;= ttl &lt;= 0xFF }.
       *
<span class="line-modified">!      * @param      ttl the time-to-live</span>
<span class="line-modified">!      * @throws     IOException if an I/O exception occurs</span>
<span class="line-modified">!      *             while setting the default time-to-live value</span>
       * @deprecated use the setTimeToLive method instead, which uses
<span class="line-modified">!      *             &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.</span>
       * @see #getTTL()
       */
      @Deprecated
      public void setTTL(byte ttl) throws IOException {
          if (isClosed())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,10 ***</span>
<span class="line-new-header">--- 292,11 ---</span>
       * @throws  IOException
       *          if an I/O exception occurs while setting the
       *          default time-to-live value
       *
       * @see #getTimeToLive()
<span class="line-added">+      * @since 1.2</span>
       */
      public void setTimeToLive(int ttl) throws IOException {
          if (ttl &lt; 0 || ttl &gt; 255) {
              throw new IllegalArgumentException(&quot;ttl out of range&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,11 ***</span>
  
      /**
       * Get the default time-to-live for multicast packets sent out on
       * the socket.
       *
<span class="line-modified">!      * @exception IOException if an I/O exception occurs</span>
       * while getting the default time-to-live value
       * @return the default time-to-live value
       * @deprecated use the getTimeToLive method instead, which returns
       * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
       * @see #setTTL(byte)
<span class="line-new-header">--- 307,11 ---</span>
  
      /**
       * Get the default time-to-live for multicast packets sent out on
       * the socket.
       *
<span class="line-modified">!      * @throws    IOException if an I/O exception occurs</span>
       * while getting the default time-to-live value
       * @return the default time-to-live value
       * @deprecated use the getTimeToLive method instead, which returns
       * an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.
       * @see #setTTL(byte)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,14 ***</span>
      }
  
      /**
       * Get the default time-to-live for multicast packets sent out on
       * the socket.
<span class="line-modified">!      * @exception IOException if an I/O exception occurs while</span>
       * getting the default time-to-live value
       * @return the default time-to-live value
       * @see #setTimeToLive(int)
       */
      public int getTimeToLive() throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          return getImpl().getTimeToLive();
<span class="line-new-header">--- 324,15 ---</span>
      }
  
      /**
       * Get the default time-to-live for multicast packets sent out on
       * the socket.
<span class="line-modified">!      * @throws    IOException if an I/O exception occurs while</span>
       * getting the default time-to-live value
       * @return the default time-to-live value
       * @see #setTimeToLive(int)
<span class="line-added">+      * @since 1.2</span>
       */
      public int getTimeToLive() throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          return getImpl().getTimeToLive();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,24 ***</span>
      /**
       * Joins a multicast group. Its behavior may be affected by
       * {@code setInterface} or {@code setNetworkInterface}.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method</span>
<span class="line-modified">!      * with the {@code mcastaddr} argument</span>
<span class="line-modified">!      * as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param mcastaddr is the multicast address to join</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @exception IOException if there is an error joining, or when the address</span>
<span class="line-modified">!      *            is not a multicast address, or the platform does not support</span>
<span class="line-modified">!      *            multicasting</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      * {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @see SecurityManager#checkMulticast(InetAddress)</span>
       */
      public void joinGroup(InetAddress mcastaddr) throws IOException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
  
<span class="line-new-header">--- 341,25 ---</span>
      /**
       * Joins a multicast group. Its behavior may be affected by
       * {@code setInterface} or {@code setNetworkInterface}.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">!      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param      mcastaddr is the multicast address to join</span>
<span class="line-modified">!      * @throws     IOException if there is an error joining,</span>
<span class="line-modified">!      *             or when the address is not a multicast address,</span>
<span class="line-modified">!      *             or the platform does not support multicasting</span>
<span class="line-modified">!      * @throws     SecurityException if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">!      * @deprecated This method does not accept the network interface on</span>
<span class="line-modified">!      *             which to join the multicast group. Use</span>
<span class="line-modified">!      *             {@link #joinGroup(SocketAddress, NetworkInterface)} instead.</span>
<span class="line-modified">!      * @see        SecurityManager#checkMulticast(InetAddress)</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public void joinGroup(InetAddress mcastaddr) throws IOException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,22 ***</span>
      /**
       * Leave a multicast group. Its behavior may be affected by
       * {@code setInterface} or {@code setNetworkInterface}.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method</span>
<span class="line-modified">!      * with the {@code mcastaddr} argument</span>
<span class="line-modified">!      * as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param mcastaddr is the multicast address to leave</span>
<span class="line-modified">!      * @exception IOException if there is an error leaving</span>
<span class="line-modified">!      * or when the address is not a multicast address.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      * {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @see SecurityManager#checkMulticast(InetAddress)</span>
       */
      public void leaveGroup(InetAddress mcastaddr) throws IOException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
  
<span class="line-new-header">--- 389,24 ---</span>
      /**
       * Leave a multicast group. Its behavior may be affected by
       * {@code setInterface} or {@code setNetworkInterface}.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">!      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param      mcastaddr is the multicast address to leave</span>
<span class="line-modified">!      * @throws     IOException if there is an error leaving</span>
<span class="line-modified">!      *             or when the address is not a multicast address.</span>
<span class="line-modified">!      * @throws     SecurityException if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @deprecated This method does not accept the network interface on which</span>
<span class="line-modified">!      *             to leave the multicast group. Use</span>
<span class="line-modified">!      *             {@link #leaveGroup(SocketAddress, NetworkInterface)} instead.</span>
<span class="line-added">+      * @see        SecurityManager#checkMulticast(InetAddress)</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public void leaveGroup(InetAddress mcastaddr) throws IOException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,26 ***</span>
       * &lt;p&gt;If there is a security manager, this method first
       * calls its {@code checkMulticast} method
       * with the {@code mcastaddr} argument
       * as its argument.
       *
<span class="line-modified">!      * @param mcastaddr is the multicast address to join</span>
<span class="line-modified">!      * @param netIf specifies the local interface to receive multicast</span>
<span class="line-modified">!      *        datagram packets, or &lt;i&gt;null&lt;/i&gt; to defer to the interface set by</span>
<span class="line-modified">!      *       {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">!      *       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @exception IOException if there is an error joining, or when the address</span>
<span class="line-modified">!      *            is not a multicast address, or the platform does not support</span>
<span class="line-modified">!      *            multicasting</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      * {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">!      * @throws  IllegalArgumentException if mcastaddr is null or is a</span>
<span class="line-modified">!      *          SocketAddress subclass not supported by this socket</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @see SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-modified">!      * @since 1.4</span>
       */
      public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
          throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-new-header">--- 429,28 ---</span>
       * &lt;p&gt;If there is a security manager, this method first
       * calls its {@code checkMulticast} method
       * with the {@code mcastaddr} argument
       * as its argument.
       *
<span class="line-modified">!      * @param  mcastaddr is the multicast address to join</span>
<span class="line-modified">!      * @param  netIf specifies the local interface to receive multicast</span>
<span class="line-modified">!      *         datagram packets, or {@code null} to defer to the interface set by</span>
<span class="line-modified">!      *         {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">!      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.</span>
<span class="line-modified">!      *         If {@code null}, and no interface has been set, the behaviour is</span>
<span class="line-modified">!      *         unspecified: any interface may be selected or the operation may fail</span>
<span class="line-modified">!      *         with a {@code SocketException}.</span>
<span class="line-modified">!      * @throws IOException if there is an error joining, or when the address</span>
<span class="line-modified">!      *         is not a multicast address, or the platform does not support</span>
<span class="line-modified">!      *         multicasting</span>
<span class="line-modified">!      * @throws SecurityException if a security manager exists and its</span>
<span class="line-modified">!      *         {@code checkMulticast} method doesn&#39;t allow the join.</span>
<span class="line-modified">!      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a</span>
<span class="line-modified">!      *         SocketAddress subclass not supported by this socket</span>
<span class="line-modified">!      * @see    SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-added">+      * @see    DatagramChannel#join(InetAddress, NetworkInterface)</span>
<span class="line-added">+      * @since  1.4</span>
       */
      public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)
          throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,28 ***</span>
  
      /**
       * Leave a multicast group on a specified local interface.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method</span>
<span class="line-modified">!      * with the {@code mcastaddr} argument</span>
<span class="line-modified">!      * as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param mcastaddr is the multicast address to leave</span>
<span class="line-modified">!      * @param netIf specifies the local interface or &lt;i&gt;null&lt;/i&gt; to defer</span>
<span class="line-modified">!      *             to the interface set by</span>
<span class="line-modified">!      *             {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">!      *             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</span>
<span class="line-modified">!      * @exception IOException if there is an error leaving</span>
<span class="line-modified">!      * or when the address is not a multicast address.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">!      * {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @throws  IllegalArgumentException if mcastaddr is null or is a</span>
<span class="line-modified">!      *          SocketAddress subclass not supported by this socket</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @see SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-modified">!      * @since 1.4</span>
       */
      public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
          throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-new-header">--- 476,29 ---</span>
  
      /**
       * Leave a multicast group on a specified local interface.
       *
       * &lt;p&gt;If there is a security manager, this method first
<span class="line-modified">!      * calls its {@code checkMulticast} method with the</span>
<span class="line-modified">!      * {@code mcastaddr} argument as its argument.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param  mcastaddr is the multicast address to leave</span>
<span class="line-modified">!      * @param  netIf specifies the local interface or {@code null} to defer</span>
<span class="line-modified">!      *         to the interface set by</span>
<span class="line-modified">!      *         {@link MulticastSocket#setInterface(InetAddress)} or</span>
<span class="line-modified">!      *         {@link MulticastSocket#setNetworkInterface(NetworkInterface)}.</span>
<span class="line-modified">!      *         If {@code null}, and no interface has been set, the behaviour</span>
<span class="line-modified">!      *         is unspecified: any interface may be selected or the operation</span>
<span class="line-modified">!      *         may fail with a {@code SocketException}.</span>
<span class="line-modified">!      * @throws IOException if there is an error leaving or when the address</span>
<span class="line-modified">!      *         is not a multicast address.</span>
<span class="line-modified">!      * @throws SecurityException if a security manager exists and its</span>
<span class="line-modified">!      *         {@code checkMulticast} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @throws IllegalArgumentException if mcastaddr is {@code null} or is a</span>
<span class="line-modified">!      *         SocketAddress subclass not supported by this socket.</span>
<span class="line-modified">!      * @see    SecurityManager#checkMulticast(InetAddress)</span>
<span class="line-added">+      * @since  1.4</span>
       */
      public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)
          throws IOException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,15 ***</span>
  
      /**
       * Set the multicast network interface used by methods
       * whose behavior would be affected by the value of the
       * network interface. Useful for multihomed hosts.
<span class="line-modified">!      * @param inf the InetAddress</span>
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
<span class="line-modified">!      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">!      * @see #getInterface()</span>
       */
      public void setInterface(InetAddress inf) throws SocketException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
          checkAddress(inf, &quot;setInterface&quot;);
<span class="line-new-header">--- 524,20 ---</span>
  
      /**
       * Set the multicast network interface used by methods
       * whose behavior would be affected by the value of the
       * network interface. Useful for multihomed hosts.
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param      inf the InetAddress</span>
<span class="line-modified">!      * @throws     SocketException if there is an error in</span>
<span class="line-modified">!      *             the underlying protocol, such as a TCP error.</span>
<span class="line-added">+      * @deprecated The InetAddress may not uniquely identify</span>
<span class="line-added">+      *             the network interface. Use</span>
<span class="line-added">+      *             {@link #setNetworkInterface(NetworkInterface)} instead.</span>
<span class="line-added">+      * @see        #getInterface()</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public void setInterface(InetAddress inf) throws SocketException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
          checkAddress(inf, &quot;setInterface&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 483,19 ***</span>
  
      /**
       * Retrieve the address of the network interface used for
       * multicast packets.
       *
<span class="line-modified">!      * @return An {@code InetAddress} representing</span>
<span class="line-modified">!      *  the address of the network interface used for</span>
<span class="line-modified">!      *  multicast packets.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
<span class="line-modified">!      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @see #setInterface(java.net.InetAddress)</span>
       */
      public InetAddress getInterface() throws SocketException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
          synchronized (infLock) {
<span class="line-new-header">--- 550,22 ---</span>
  
      /**
       * Retrieve the address of the network interface used for
       * multicast packets.
       *
<span class="line-modified">!      * @return     An {@code InetAddress} representing the address</span>
<span class="line-modified">!      *             of the network interface used for multicast packets,</span>
<span class="line-modified">!      *             or if no interface has been set, an {@code InetAddress}</span>
<span class="line-modified">!      *             representing any local address.</span>
<span class="line-modified">!      * @throws     SocketException if there is an error in the</span>
<span class="line-modified">!      *             underlying protocol, such as a TCP error.</span>
<span class="line-modified">!      * @deprecated The network interface may not be uniquely identified by</span>
<span class="line-modified">!      *             the InetAddress returned.</span>
<span class="line-added">+      *             Use {@link #getNetworkInterface()} instead.</span>
<span class="line-added">+      * @see        #setInterface(java.net.InetAddress)</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public InetAddress getInterface() throws SocketException {
          if (isClosed()) {
              throw new SocketException(&quot;Socket is closed&quot;);
          }
          synchronized (infLock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,11 ***</span>
      /**
       * Specify the network interface for outgoing multicast datagrams
       * sent on this socket.
       *
       * @param netIf the interface
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
       * the underlying protocol, such as a TCP error.
       * @see #getNetworkInterface()
       * @since 1.4
       */
      public void setNetworkInterface(NetworkInterface netIf)
<span class="line-new-header">--- 617,11 ---</span>
      /**
       * Specify the network interface for outgoing multicast datagrams
       * sent on this socket.
       *
       * @param netIf the interface
<span class="line-modified">!      * @throws    SocketException if there is an error in</span>
       * the underlying protocol, such as a TCP error.
       * @see #getNetworkInterface()
       * @since 1.4
       */
      public void setNetworkInterface(NetworkInterface netIf)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,20 ***</span>
      }
  
      /**
       * Get the multicast network interface set.
       *
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
<span class="line-modified">!      * the underlying protocol, such as a TCP error.</span>
<span class="line-modified">!      * @return the multicast {@code NetworkInterface} currently set</span>
<span class="line-modified">!      * @see #setNetworkInterface(NetworkInterface)</span>
<span class="line-modified">!      * @since 1.4</span>
       */
      public NetworkInterface getNetworkInterface() throws SocketException {
          NetworkInterface ni
              = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
<span class="line-modified">!         if ((ni.getIndex() == 0) || (ni.getIndex() == -1)) {</span>
              InetAddress[] addrs = new InetAddress[1];
              addrs[0] = InetAddress.anyLocalAddress();
              return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
          } else {
              return ni;
<span class="line-new-header">--- 635,22 ---</span>
      }
  
      /**
       * Get the multicast network interface set.
       *
<span class="line-modified">!      * @throws SocketException if there is an error in</span>
<span class="line-modified">!      *         the underlying protocol, such as a TCP error.</span>
<span class="line-modified">!      * @return The multicast {@code NetworkInterface} currently set. A placeholder</span>
<span class="line-modified">!      *         NetworkInterface is returned when there is no interface set; it has</span>
<span class="line-modified">!      *         a single InetAddress to represent any local address.</span>
<span class="line-added">+      * @see    #setNetworkInterface(NetworkInterface)</span>
<span class="line-added">+      * @since  1.4</span>
       */
      public NetworkInterface getNetworkInterface() throws SocketException {
          NetworkInterface ni
              = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
<span class="line-modified">!         if (ni == null) {</span>
              InetAddress[] addrs = new InetAddress[1];
              addrs[0] = InetAddress.anyLocalAddress();
              return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
          } else {
              return ni;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 592,27 ***</span>
       * the local socket.
       *
       * &lt;p&gt;Because this option is a hint, applications that want to
       * verify what loopback mode is set to should call
       * {@link #getLoopbackMode()}
<span class="line-modified">!      * @param disable {@code true} to disable the LoopbackMode</span>
<span class="line-modified">!      * @throws SocketException if an error occurs while setting the value</span>
<span class="line-modified">!      * @since 1.4</span>
<span class="line-modified">!      * @see #getLoopbackMode</span>
       */
      public void setLoopbackMode(boolean disable) throws SocketException {
          getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
      }
  
      /**
       * Get the setting for local loopback of multicast datagrams.
       *
<span class="line-modified">!      * @throws SocketException  if an error occurs while getting the value</span>
<span class="line-modified">!      * @return true if the LoopbackMode has been disabled</span>
<span class="line-modified">!      * @since 1.4</span>
<span class="line-modified">!      * @see #setLoopbackMode</span>
       */
      public boolean getLoopbackMode() throws SocketException {
          return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
      }
  
      /**
<span class="line-new-header">--- 664,37 ---</span>
       * the local socket.
       *
       * &lt;p&gt;Because this option is a hint, applications that want to
       * verify what loopback mode is set to should call
       * {@link #getLoopbackMode()}
<span class="line-modified">!      * @param      disable {@code true} to disable the LoopbackMode</span>
<span class="line-modified">!      * @throws     SocketException if an error occurs while setting the value</span>
<span class="line-modified">!      * @since      1.4</span>
<span class="line-modified">!      * @deprecated Use {@link #setOption(SocketOption, Object)} with</span>
<span class="line-added">+      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}</span>
<span class="line-added">+      *             instead. The loopback mode is enabled by default,</span>
<span class="line-added">+      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}</span>
<span class="line-added">+      *             disables it.</span>
<span class="line-added">+      * @see        #getLoopbackMode</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public void setLoopbackMode(boolean disable) throws SocketException {
          getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
      }
  
      /**
       * Get the setting for local loopback of multicast datagrams.
       *
<span class="line-modified">!      * @throws     SocketException if an error occurs while getting the value</span>
<span class="line-modified">!      * @return     true if the LoopbackMode has been disabled</span>
<span class="line-modified">!      * @since      1.4</span>
<span class="line-modified">!      * @deprecated Use {@link #getOption(SocketOption)} with</span>
<span class="line-added">+      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}</span>
<span class="line-added">+      *             instead.</span>
<span class="line-added">+      * @see        #setLoopbackMode</span>
       */
<span class="line-added">+     @Deprecated(since=&quot;14&quot;)</span>
      public boolean getLoopbackMode() throws SocketException {
          return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,15 ***</span>
       * One does not need to be the member of the group to send
       * packets to a destination multicast address.
       * @param ttl optional time to live for multicast packet.
       * default ttl is 1.
       *
<span class="line-modified">!      * @exception IOException is raised if an error occurs i.e</span>
<span class="line-modified">!      * error while setting ttl.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkMulticast} or {@code checkConnect}
       *             method doesn&#39;t allow the send.
       *
       * @deprecated Use the following code or its equivalent instead:
       *  ......
       *  int ttl = mcastSocket.getTimeToLive();
       *  mcastSocket.setTimeToLive(newttl);
<span class="line-new-header">--- 723,23 ---</span>
       * One does not need to be the member of the group to send
       * packets to a destination multicast address.
       * @param ttl optional time to live for multicast packet.
       * default ttl is 1.
       *
<span class="line-modified">!      * @throws     IOException is raised if an error occurs i.e</span>
<span class="line-modified">!      *             error while setting ttl.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkMulticast} or {@code checkConnect}
       *             method doesn&#39;t allow the send.
<span class="line-added">+      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
<span class="line-added">+      *             to a currently unreachable destination. Note, there is no</span>
<span class="line-added">+      *             guarantee that the exception will be thrown.</span>
<span class="line-added">+      * @throws     IllegalArgumentException if the socket is connected,</span>
<span class="line-added">+      *             and connected address and packet address differ, or</span>
<span class="line-added">+      *             if the socket is not connected and the packet address</span>
<span class="line-added">+      *             is not set or if its port is out of range.</span>
<span class="line-added">+      *</span>
       *
       * @deprecated Use the following code or its equivalent instead:
       *  ......
       *  int ttl = mcastSocket.getTimeToLive();
       *  mcastSocket.setTimeToLive(newttl);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,36 ***</span>
      @Deprecated
      public void send(DatagramPacket p, byte ttl)
          throws IOException {
              if (isClosed())
                  throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-removed">-             checkAddress(p.getAddress(), &quot;send&quot;);</span>
              synchronized(ttlLock) {
                  synchronized(p) {
                      if (connectState == ST_NOT_CONNECTED) {
                          // Security manager makes sure that the multicast address
                          // is allowed one and that the ttl used is less
                          // than the allowed maxttl.
                          SecurityManager security = System.getSecurityManager();
                          if (security != null) {
<span class="line-modified">!                             if (p.getAddress().isMulticastAddress()) {</span>
<span class="line-modified">!                                 security.checkMulticast(p.getAddress(), ttl);</span>
                              } else {
<span class="line-modified">!                                 security.checkConnect(p.getAddress().getHostAddress(),</span>
<span class="line-modified">!                                                       p.getPort());</span>
                              }
                          }
                      } else {
                          // we&#39;re connected
<span class="line-removed">-                         InetAddress packetAddress = null;</span>
<span class="line-removed">-                         packetAddress = p.getAddress();</span>
                          if (packetAddress == null) {
                              p.setAddress(connectedAddress);
                              p.setPort(connectedPort);
                          } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">!                                    p.getPort() != connectedPort) {</span>
<span class="line-modified">!                             throw new SecurityException(&quot;connected address and packet address&quot; +</span>
                                                          &quot; differ&quot;);
                          }
                      }
                      byte dttl = getTTL();
                      try {
<span class="line-new-header">--- 755,41 ---</span>
      @Deprecated
      public void send(DatagramPacket p, byte ttl)
          throws IOException {
              if (isClosed())
                  throw new SocketException(&quot;Socket is closed&quot;);
              synchronized(ttlLock) {
                  synchronized(p) {
<span class="line-added">+                     InetAddress packetAddress = p.getAddress();</span>
<span class="line-added">+                     int packetPort = p.getPort();</span>
<span class="line-added">+                     checkAddress(packetAddress, &quot;send&quot;);</span>
                      if (connectState == ST_NOT_CONNECTED) {
<span class="line-added">+                         if (packetAddress == null) {</span>
<span class="line-added">+                             throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-added">+                             throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
                          // Security manager makes sure that the multicast address
                          // is allowed one and that the ttl used is less
                          // than the allowed maxttl.
                          SecurityManager security = System.getSecurityManager();
                          if (security != null) {
<span class="line-modified">!                             if (packetAddress.isMulticastAddress()) {</span>
<span class="line-modified">!                                 security.checkMulticast(packetAddress, ttl);</span>
                              } else {
<span class="line-modified">!                                 security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-modified">!                                         packetPort);</span>
                              }
                          }
                      } else {
                          // we&#39;re connected
                          if (packetAddress == null) {
                              p.setAddress(connectedAddress);
                              p.setPort(connectedPort);
                          } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">!                                 packetPort != connectedPort) {</span>
<span class="line-modified">!                             throw new IllegalArgumentException(&quot;connected address and packet address&quot; +</span>
                                                          &quot; differ&quot;);
                          }
                      }
                      byte dttl = getTTL();
                      try {
</pre>
<center><a href="MalformedURLException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
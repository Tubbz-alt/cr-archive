<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
<a name="1" id="anc1"></a><span class="line-added">  28 import java.lang.invoke.MethodHandle;</span>
<span class="line-added">  29 import java.lang.invoke.MethodHandles;</span>
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InvocationTargetException;
<a name="2" id="anc2"></a><span class="line-added">  37 import java.lang.reflect.RecordComponent;</span>
  38 import java.lang.reflect.UndeclaredThrowableException;
  39 import java.lang.reflect.Member;
  40 import java.lang.reflect.Method;
  41 import java.lang.reflect.Modifier;
  42 import java.lang.reflect.Proxy;
  43 import java.security.AccessControlContext;
  44 import java.security.AccessController;
  45 import java.security.MessageDigest;
  46 import java.security.NoSuchAlgorithmException;
  47 import java.security.PermissionCollection;
  48 import java.security.Permissions;
  49 import java.security.PrivilegedAction;
<a name="3" id="anc3"></a><span class="line-added">  50 import java.security.PrivilegedActionException;</span>
<span class="line-added">  51 import java.security.PrivilegedExceptionAction;</span>
  52 import java.security.ProtectionDomain;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.HashSet;
  58 import java.util.Set;
  59 import java.util.concurrent.ConcurrentHashMap;
  60 import java.util.concurrent.ConcurrentMap;
  61 import jdk.internal.misc.Unsafe;
  62 import jdk.internal.reflect.CallerSensitive;
  63 import jdk.internal.reflect.Reflection;
  64 import jdk.internal.reflect.ReflectionFactory;
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.access.JavaSecurityAccess;
  67 import sun.reflect.misc.ReflectUtil;
  68 import static java.io.ObjectStreamField.*;
  69 
  70 /**
  71  * Serialization&#39;s descriptor for classes.  It contains the name and
  72  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  73  * loaded in this Java VM can be found/created using the lookup method.
  74  *
  75  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  76  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  77  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  78  *
  79  * @author      Mike Warres
  80  * @author      Roger Riggs
  81  * @see ObjectStreamField
  82  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  83  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  84  * @since   1.1
  85  */
  86 public class ObjectStreamClass implements Serializable {
  87 
  88     /** serialPersistentFields value indicating no serializable fields */
  89     public static final ObjectStreamField[] NO_FIELDS =
  90         new ObjectStreamField[0];
  91 
<a name="4" id="anc4"></a><span class="line-added">  92     @java.io.Serial</span>
  93     private static final long serialVersionUID = -6120832682080437368L;
<a name="5" id="anc5"></a><span class="line-added">  94     @java.io.Serial</span>
  95     private static final ObjectStreamField[] serialPersistentFields =
  96         NO_FIELDS;
  97 
  98     /** reflection factory for obtaining serialization constructors */
  99     private static final ReflectionFactory reflFactory =
 100         AccessController.doPrivileged(
 101             new ReflectionFactory.GetReflectionFactoryAction());
 102 
 103     private static class Caches {
 104         /** cache mapping local classes -&gt; descriptors */
 105         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
 106             new ConcurrentHashMap&lt;&gt;();
 107 
 108         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 109         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 110             new ConcurrentHashMap&lt;&gt;();
 111 
 112         /** queue for WeakReferences to local classes */
 113         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 114             new ReferenceQueue&lt;&gt;();
 115         /** queue for WeakReferences to field reflectors keys */
 116         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 117             new ReferenceQueue&lt;&gt;();
 118     }
 119 
 120     /** class associated with this descriptor (if any) */
 121     private Class&lt;?&gt; cl;
 122     /** name of class represented by this descriptor */
 123     private String name;
 124     /** serialVersionUID of represented class (null if not computed yet) */
 125     private volatile Long suid;
 126 
 127     /** true if represents dynamic proxy class */
 128     private boolean isProxy;
 129     /** true if represents enum type */
 130     private boolean isEnum;
<a name="6" id="anc6"></a><span class="line-added"> 131     /** true if represents record type */</span>
<span class="line-added"> 132     private boolean isRecord;</span>
 133     /** true if represented class implements Serializable */
 134     private boolean serializable;
 135     /** true if represented class implements Externalizable */
 136     private boolean externalizable;
 137     /** true if desc has data written by class-defined writeObject method */
 138     private boolean hasWriteObjectData;
 139     /**
 140      * true if desc has externalizable data written in block data format; this
 141      * must be true by default to accommodate ObjectInputStream subclasses which
 142      * override readClassDescriptor() to return class descriptors obtained from
 143      * ObjectStreamClass.lookup() (see 4461737)
 144      */
 145     private boolean hasBlockExternalData = true;
 146 
 147     /**
 148      * Contains information about InvalidClassException instances to be thrown
 149      * when attempting operations on an invalid class. Note that instances of
 150      * this class are immutable and are potentially shared among
 151      * ObjectStreamClass instances.
 152      */
 153     private static class ExceptionInfo {
 154         private final String className;
 155         private final String message;
 156 
 157         ExceptionInfo(String cn, String msg) {
 158             className = cn;
 159             message = msg;
 160         }
 161 
 162         /**
 163          * Returns (does not throw) an InvalidClassException instance created
 164          * from the information in this object, suitable for being thrown by
 165          * the caller.
 166          */
 167         InvalidClassException newInvalidClassException() {
 168             return new InvalidClassException(className, message);
 169         }
 170     }
 171 
 172     /** exception (if any) thrown while attempting to resolve class */
 173     private ClassNotFoundException resolveEx;
 174     /** exception (if any) to throw if non-enum deserialization attempted */
 175     private ExceptionInfo deserializeEx;
 176     /** exception (if any) to throw if non-enum serialization attempted */
 177     private ExceptionInfo serializeEx;
 178     /** exception (if any) to throw if default serialization attempted */
 179     private ExceptionInfo defaultSerializeEx;
 180 
 181     /** serializable fields */
 182     private ObjectStreamField[] fields;
 183     /** aggregate marshalled size of primitive fields */
 184     private int primDataSize;
 185     /** number of non-primitive fields */
 186     private int numObjFields;
 187     /** reflector for setting/getting serializable field values */
 188     private FieldReflector fieldRefl;
 189     /** data layout of serialized objects described by this class desc */
 190     private volatile ClassDataSlot[] dataLayout;
 191 
 192     /** serialization-appropriate constructor, or null if none */
 193     private Constructor&lt;?&gt; cons;
<a name="7" id="anc7"></a><span class="line-added"> 194     /** record canonical constructor, or null */</span>
<span class="line-added"> 195     private MethodHandle canonicalCtr;</span>
 196     /** protection domains that need to be checked when calling the constructor */
 197     private ProtectionDomain[] domains;
 198 
 199     /** class-defined writeObject method, or null if none */
 200     private Method writeObjectMethod;
 201     /** class-defined readObject method, or null if none */
 202     private Method readObjectMethod;
 203     /** class-defined readObjectNoData method, or null if none */
 204     private Method readObjectNoDataMethod;
 205     /** class-defined writeReplace method, or null if none */
 206     private Method writeReplaceMethod;
 207     /** class-defined readResolve method, or null if none */
 208     private Method readResolveMethod;
 209 
 210     /** local class descriptor for represented class (may point to self) */
 211     private ObjectStreamClass localDesc;
 212     /** superclass descriptor appearing in stream */
 213     private ObjectStreamClass superDesc;
 214 
 215     /** true if, and only if, the object has been correctly initialized */
 216     private boolean initialized;
 217 
 218     /**
 219      * Initializes native code.
 220      */
 221     private static native void initNative();
 222     static {
 223         initNative();
 224     }
 225 
 226     /**
 227      * Find the descriptor for a class that can be serialized.  Creates an
 228      * ObjectStreamClass instance if one does not exist yet for class. Null is
 229      * returned if the specified class does not implement java.io.Serializable
 230      * or java.io.Externalizable.
 231      *
 232      * @param   cl class for which to get the descriptor
 233      * @return  the class descriptor for the specified class
 234      */
 235     public static ObjectStreamClass lookup(Class&lt;?&gt; cl) {
 236         return lookup(cl, false);
 237     }
 238 
 239     /**
 240      * Returns the descriptor for any class, regardless of whether it
 241      * implements {@link Serializable}.
 242      *
 243      * @param        cl class for which to get the descriptor
 244      * @return       the class descriptor for the specified class
 245      * @since 1.6
 246      */
 247     public static ObjectStreamClass lookupAny(Class&lt;?&gt; cl) {
 248         return lookup(cl, true);
 249     }
 250 
 251     /**
 252      * Returns the name of the class described by this descriptor.
 253      * This method returns the name of the class in the format that
 254      * is used by the {@link Class#getName} method.
 255      *
 256      * @return a string representing the name of the class
 257      */
 258     public String getName() {
 259         return name;
 260     }
 261 
 262     /**
 263      * Return the serialVersionUID for this class.  The serialVersionUID
 264      * defines a set of classes all with the same name that have evolved from a
 265      * common root class and agree to be serialized and deserialized using a
 266      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 267      *
 268      * @return  the SUID of the class described by this descriptor
 269      */
 270     public long getSerialVersionUID() {
 271         // REMIND: synchronize instead of relying on volatile?
 272         if (suid == null) {
<a name="8" id="anc8"></a><span class="line-added"> 273             if (isRecord)</span>
<span class="line-added"> 274                 return 0L;</span>
<span class="line-added"> 275 </span>
 276             suid = AccessController.doPrivileged(
 277                 new PrivilegedAction&lt;Long&gt;() {
 278                     public Long run() {
 279                         return computeDefaultSUID(cl);
 280                     }
 281                 }
 282             );
 283         }
 284         return suid.longValue();
 285     }
 286 
 287     /**
 288      * Return the class in the local VM that this version is mapped to.  Null
 289      * is returned if there is no corresponding local class.
 290      *
<a name="9" id="anc9"></a><span class="line-modified"> 291      * @return  the {@code Class} instance that this descriptor represents</span>
 292      */
 293     @CallerSensitive
 294     public Class&lt;?&gt; forClass() {
 295         if (cl == null) {
 296             return null;
 297         }
 298         requireInitialized();
 299         if (System.getSecurityManager() != null) {
 300             Class&lt;?&gt; caller = Reflection.getCallerClass();
 301             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 302                 ReflectUtil.checkPackageAccess(cl);
 303             }
 304         }
 305         return cl;
 306     }
 307 
 308     /**
 309      * Return an array of the fields of this serializable class.
 310      *
 311      * @return  an array containing an element for each persistent field of
 312      *          this class. Returns an array of length zero if there are no
 313      *          fields.
 314      * @since 1.2
 315      */
 316     public ObjectStreamField[] getFields() {
 317         return getFields(true);
 318     }
 319 
 320     /**
 321      * Get the field of this class by name.
 322      *
 323      * @param   name the name of the data field to look for
 324      * @return  The ObjectStreamField object of the named field or null if
 325      *          there is no such named field.
 326      */
 327     public ObjectStreamField getField(String name) {
 328         return getField(name, null);
 329     }
 330 
 331     /**
 332      * Return a string describing this ObjectStreamClass.
 333      */
 334     public String toString() {
 335         return name + &quot;: static final long serialVersionUID = &quot; +
 336             getSerialVersionUID() + &quot;L;&quot;;
 337     }
 338 
 339     /**
 340      * Looks up and returns class descriptor for given class, or null if class
 341      * is non-serializable and &quot;all&quot; is set to false.
 342      *
 343      * @param   cl class to look up
 344      * @param   all if true, return descriptors for all classes; if false, only
 345      *          return descriptors for serializable classes
 346      */
 347     static ObjectStreamClass lookup(Class&lt;?&gt; cl, boolean all) {
 348         if (!(all || Serializable.class.isAssignableFrom(cl))) {
 349             return null;
 350         }
 351         processQueue(Caches.localDescsQueue, Caches.localDescs);
 352         WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);
 353         Reference&lt;?&gt; ref = Caches.localDescs.get(key);
 354         Object entry = null;
 355         if (ref != null) {
 356             entry = ref.get();
 357         }
 358         EntryFuture future = null;
 359         if (entry == null) {
 360             EntryFuture newEntry = new EntryFuture();
 361             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
 362             do {
 363                 if (ref != null) {
 364                     Caches.localDescs.remove(key, ref);
 365                 }
 366                 ref = Caches.localDescs.putIfAbsent(key, newRef);
 367                 if (ref != null) {
 368                     entry = ref.get();
 369                 }
 370             } while (ref != null &amp;&amp; entry == null);
 371             if (entry == null) {
 372                 future = newEntry;
 373             }
 374         }
 375 
 376         if (entry instanceof ObjectStreamClass) {  // check common case first
 377             return (ObjectStreamClass) entry;
 378         }
 379         if (entry instanceof EntryFuture) {
 380             future = (EntryFuture) entry;
 381             if (future.getOwner() == Thread.currentThread()) {
 382                 /*
 383                  * Handle nested call situation described by 4803747: waiting
 384                  * for future value to be set by a lookup() call further up the
 385                  * stack will result in deadlock, so calculate and set the
 386                  * future value here instead.
 387                  */
 388                 entry = null;
 389             } else {
 390                 entry = future.get();
 391             }
 392         }
 393         if (entry == null) {
 394             try {
 395                 entry = new ObjectStreamClass(cl);
 396             } catch (Throwable th) {
 397                 entry = th;
 398             }
 399             if (future.set(entry)) {
 400                 Caches.localDescs.put(key, new SoftReference&lt;&gt;(entry));
 401             } else {
 402                 // nested lookup call already set future
 403                 entry = future.get();
 404             }
 405         }
 406 
 407         if (entry instanceof ObjectStreamClass) {
 408             return (ObjectStreamClass) entry;
 409         } else if (entry instanceof RuntimeException) {
 410             throw (RuntimeException) entry;
 411         } else if (entry instanceof Error) {
 412             throw (Error) entry;
 413         } else {
 414             throw new InternalError(&quot;unexpected entry: &quot; + entry);
 415         }
 416     }
 417 
 418     /**
 419      * Placeholder used in class descriptor and field reflector lookup tables
 420      * for an entry in the process of being initialized.  (Internal) callers
 421      * which receive an EntryFuture belonging to another thread as the result
 422      * of a lookup should call the get() method of the EntryFuture; this will
 423      * return the actual entry once it is ready for use and has been set().  To
 424      * conserve objects, EntryFutures synchronize on themselves.
 425      */
 426     private static class EntryFuture {
 427 
 428         private static final Object unset = new Object();
 429         private final Thread owner = Thread.currentThread();
 430         private Object entry = unset;
 431 
 432         /**
 433          * Attempts to set the value contained by this EntryFuture.  If the
 434          * EntryFuture&#39;s value has not been set already, then the value is
 435          * saved, any callers blocked in the get() method are notified, and
 436          * true is returned.  If the value has already been set, then no saving
 437          * or notification occurs, and false is returned.
 438          */
 439         synchronized boolean set(Object entry) {
 440             if (this.entry != unset) {
 441                 return false;
 442             }
 443             this.entry = entry;
 444             notifyAll();
 445             return true;
 446         }
 447 
 448         /**
 449          * Returns the value contained by this EntryFuture, blocking if
 450          * necessary until a value is set.
 451          */
 452         synchronized Object get() {
 453             boolean interrupted = false;
 454             while (entry == unset) {
 455                 try {
 456                     wait();
 457                 } catch (InterruptedException ex) {
 458                     interrupted = true;
 459                 }
 460             }
 461             if (interrupted) {
 462                 AccessController.doPrivileged(
 463                     new PrivilegedAction&lt;&gt;() {
 464                         public Void run() {
 465                             Thread.currentThread().interrupt();
 466                             return null;
 467                         }
 468                     }
 469                 );
 470             }
 471             return entry;
 472         }
 473 
 474         /**
 475          * Returns the thread that created this EntryFuture.
 476          */
 477         Thread getOwner() {
 478             return owner;
 479         }
 480     }
 481 
<a name="10" id="anc10"></a><span class="line-added"> 482     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 483     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-added"> 484         return cls.isRecord();</span>
<span class="line-added"> 485     }</span>
<span class="line-added"> 486 </span>
 487     /**
 488      * Creates local class descriptor representing given class.
 489      */
 490     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 491         this.cl = cl;
 492         name = cl.getName();
 493         isProxy = Proxy.isProxyClass(cl);
 494         isEnum = Enum.class.isAssignableFrom(cl);
<a name="11" id="anc11"></a><span class="line-added"> 495         isRecord = isRecord(cl);</span>
 496         serializable = Serializable.class.isAssignableFrom(cl);
 497         externalizable = Externalizable.class.isAssignableFrom(cl);
 498 
 499         Class&lt;?&gt; superCl = cl.getSuperclass();
 500         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 501         localDesc = this;
 502 
 503         if (serializable) {
 504             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 505                 public Void run() {
 506                     if (isEnum) {
 507                         suid = Long.valueOf(0);
 508                         fields = NO_FIELDS;
 509                         return null;
 510                     }
 511                     if (cl.isArray()) {
 512                         fields = NO_FIELDS;
 513                         return null;
 514                     }
 515 
 516                     suid = getDeclaredSUID(cl);
 517                     try {
 518                         fields = getSerialFields(cl);
 519                         computeFieldOffsets();
 520                     } catch (InvalidClassException e) {
 521                         serializeEx = deserializeEx =
 522                             new ExceptionInfo(e.classname, e.getMessage());
 523                         fields = NO_FIELDS;
 524                     }
 525 
<a name="12" id="anc12"></a><span class="line-modified"> 526                     if (isRecord) {</span>
<span class="line-added"> 527                         canonicalCtr = canonicalRecordCtr(cl);</span>
<span class="line-added"> 528                     } else if (externalizable) {</span>
 529                         cons = getExternalizableConstructor(cl);
 530                     } else {
 531                         cons = getSerializableConstructor(cl);
 532                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 533                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 534                             Void.TYPE);
 535                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 536                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 537                             Void.TYPE);
 538                         readObjectNoDataMethod = getPrivateMethod(
 539                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 540                         hasWriteObjectData = (writeObjectMethod != null);
 541                     }
 542                     domains = getProtectionDomains(cons, cl);
 543                     writeReplaceMethod = getInheritableMethod(
 544                         cl, &quot;writeReplace&quot;, null, Object.class);
 545                     readResolveMethod = getInheritableMethod(
 546                         cl, &quot;readResolve&quot;, null, Object.class);
 547                     return null;
 548                 }
 549             });
 550         } else {
 551             suid = Long.valueOf(0);
 552             fields = NO_FIELDS;
 553         }
 554 
 555         try {
 556             fieldRefl = getReflector(fields, this);
 557         } catch (InvalidClassException ex) {
 558             // field mismatches impossible when matching local fields vs. self
 559             throw new InternalError(ex);
 560         }
 561 
 562         if (deserializeEx == null) {
 563             if (isEnum) {
 564                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<a name="13" id="anc13"></a><span class="line-modified"> 565             } else if (cons == null &amp;&amp; !isRecord) {</span>
 566                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 567             }
 568         }
<a name="14" id="anc14"></a><span class="line-modified"> 569         if (isRecord &amp;&amp; canonicalCtr == null) {</span>
<span class="line-modified"> 570             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);</span>
<span class="line-modified"> 571         } else {</span>
<span class="line-modified"> 572             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added"> 573                 if (fields[i].getField() == null) {</span>
<span class="line-added"> 574                     defaultSerializeEx = new ExceptionInfo(</span>
<span class="line-added"> 575                         name, &quot;unmatched serializable field(s) declared&quot;);</span>
<span class="line-added"> 576                 }</span>
 577             }
 578         }
 579         initialized = true;
 580     }
 581 
 582     /**
 583      * Creates blank class descriptor which should be initialized via a
 584      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 585      */
 586     ObjectStreamClass() {
 587     }
 588 
 589     /**
 590      * Creates a PermissionDomain that grants no permission.
 591      */
 592     private ProtectionDomain noPermissionsDomain() {
 593         PermissionCollection perms = new Permissions();
 594         perms.setReadOnly();
 595         return new ProtectionDomain(null, perms);
 596     }
 597 
 598     /**
 599      * Aggregate the ProtectionDomains of all the classes that separate
 600      * a concrete class {@code cl} from its ancestor&#39;s class declaring
 601      * a constructor {@code cons}.
 602      *
 603      * If {@code cl} is defined by the boot loader, or the constructor
 604      * {@code cons} is declared by {@code cl}, or if there is no security
 605      * manager, then this method does nothing and {@code null} is returned.
 606      *
 607      * @param cons A constructor declared by {@code cl} or one of its
 608      *             ancestors.
 609      * @param cl A concrete class, which is either the class declaring
 610      *           the constructor {@code cons}, or a serializable subclass
 611      *           of that class.
 612      * @return An array of ProtectionDomain representing the set of
 613      *         ProtectionDomain that separate the concrete class {@code cl}
 614      *         from its ancestor&#39;s declaring {@code cons}, or {@code null}.
 615      */
 616     private ProtectionDomain[] getProtectionDomains(Constructor&lt;?&gt; cons,
 617                                                     Class&lt;?&gt; cl) {
 618         ProtectionDomain[] domains = null;
 619         if (cons != null &amp;&amp; cl.getClassLoader() != null
 620                 &amp;&amp; System.getSecurityManager() != null) {
 621             Class&lt;?&gt; cls = cl;
 622             Class&lt;?&gt; fnscl = cons.getDeclaringClass();
 623             Set&lt;ProtectionDomain&gt; pds = null;
 624             while (cls != fnscl) {
 625                 ProtectionDomain pd = cls.getProtectionDomain();
 626                 if (pd != null) {
 627                     if (pds == null) pds = new HashSet&lt;&gt;();
 628                     pds.add(pd);
 629                 }
 630                 cls = cls.getSuperclass();
 631                 if (cls == null) {
 632                     // that&#39;s not supposed to happen
 633                     // make a ProtectionDomain with no permission.
 634                     // should we throw instead?
 635                     if (pds == null) pds = new HashSet&lt;&gt;();
 636                     else pds.clear();
 637                     pds.add(noPermissionsDomain());
 638                     break;
 639                 }
 640             }
 641             if (pds != null) {
 642                 domains = pds.toArray(new ProtectionDomain[0]);
 643             }
 644         }
 645         return domains;
 646     }
 647 
 648     /**
 649      * Initializes class descriptor representing a proxy class.
 650      */
 651     void initProxy(Class&lt;?&gt; cl,
 652                    ClassNotFoundException resolveEx,
 653                    ObjectStreamClass superDesc)
 654         throws InvalidClassException
 655     {
 656         ObjectStreamClass osc = null;
 657         if (cl != null) {
 658             osc = lookup(cl, true);
 659             if (!osc.isProxy) {
 660                 throw new InvalidClassException(
 661                     &quot;cannot bind proxy descriptor to a non-proxy class&quot;);
 662             }
 663         }
 664         this.cl = cl;
 665         this.resolveEx = resolveEx;
 666         this.superDesc = superDesc;
 667         isProxy = true;
 668         serializable = true;
 669         suid = Long.valueOf(0);
 670         fields = NO_FIELDS;
 671         if (osc != null) {
 672             localDesc = osc;
 673             name = localDesc.name;
 674             externalizable = localDesc.externalizable;
 675             writeReplaceMethod = localDesc.writeReplaceMethod;
 676             readResolveMethod = localDesc.readResolveMethod;
 677             deserializeEx = localDesc.deserializeEx;
 678             domains = localDesc.domains;
 679             cons = localDesc.cons;
 680         }
 681         fieldRefl = getReflector(fields, localDesc);
 682         initialized = true;
 683     }
 684 
 685     /**
 686      * Initializes class descriptor representing a non-proxy class.
 687      */
 688     void initNonProxy(ObjectStreamClass model,
 689                       Class&lt;?&gt; cl,
 690                       ClassNotFoundException resolveEx,
 691                       ObjectStreamClass superDesc)
 692         throws InvalidClassException
 693     {
 694         long suid = Long.valueOf(model.getSerialVersionUID());
 695         ObjectStreamClass osc = null;
 696         if (cl != null) {
 697             osc = lookup(cl, true);
 698             if (osc.isProxy) {
 699                 throw new InvalidClassException(
 700                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 701             }
 702             if (model.isEnum != osc.isEnum) {
 703                 throw new InvalidClassException(model.isEnum ?
 704                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 705                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 706             }
 707 
 708             if (model.serializable == osc.serializable &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified"> 709                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;</span>
 710                     suid != osc.getSerialVersionUID()) {
 711                 throw new InvalidClassException(osc.name,
 712                         &quot;local class incompatible: &quot; +
 713                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 714                                 &quot;, local class serialVersionUID = &quot; +
 715                                 osc.getSerialVersionUID());
 716             }
 717 
 718             if (!classNamesEqual(model.name, osc.name)) {
 719                 throw new InvalidClassException(osc.name,
 720                         &quot;local class name incompatible with stream class &quot; +
 721                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 722             }
 723 
 724             if (!model.isEnum) {
 725                 if ((model.serializable == osc.serializable) &amp;&amp;
 726                         (model.externalizable != osc.externalizable)) {
 727                     throw new InvalidClassException(osc.name,
 728                             &quot;Serializable incompatible with Externalizable&quot;);
 729                 }
 730 
 731                 if ((model.serializable != osc.serializable) ||
 732                         (model.externalizable != osc.externalizable) ||
 733                         !(model.serializable || model.externalizable)) {
 734                     deserializeEx = new ExceptionInfo(
 735                             osc.name, &quot;class invalid for deserialization&quot;);
 736                 }
 737             }
 738         }
 739 
 740         this.cl = cl;
<a name="16" id="anc16"></a><span class="line-added"> 741         if (cl != null) {</span>
<span class="line-added"> 742             this.isRecord = isRecord(cl);</span>
<span class="line-added"> 743             this.canonicalCtr = osc.canonicalCtr;</span>
<span class="line-added"> 744         }</span>
 745         this.resolveEx = resolveEx;
 746         this.superDesc = superDesc;
 747         name = model.name;
 748         this.suid = suid;
 749         isProxy = false;
 750         isEnum = model.isEnum;
 751         serializable = model.serializable;
 752         externalizable = model.externalizable;
 753         hasBlockExternalData = model.hasBlockExternalData;
 754         hasWriteObjectData = model.hasWriteObjectData;
 755         fields = model.fields;
 756         primDataSize = model.primDataSize;
 757         numObjFields = model.numObjFields;
 758 
 759         if (osc != null) {
 760             localDesc = osc;
 761             writeObjectMethod = localDesc.writeObjectMethod;
 762             readObjectMethod = localDesc.readObjectMethod;
 763             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 764             writeReplaceMethod = localDesc.writeReplaceMethod;
 765             readResolveMethod = localDesc.readResolveMethod;
 766             if (deserializeEx == null) {
 767                 deserializeEx = localDesc.deserializeEx;
 768             }
 769             domains = localDesc.domains;
<a name="17" id="anc17"></a><span class="line-added"> 770             assert isRecord(cl) ? localDesc.cons == null : true;</span>
 771             cons = localDesc.cons;
 772         }
 773 
 774         fieldRefl = getReflector(fields, localDesc);
 775         // reassign to matched fields so as to reflect local unshared settings
 776         fields = fieldRefl.getFields();
<a name="18" id="anc18"></a><span class="line-added"> 777 </span>
 778         initialized = true;
 779     }
 780 
 781     /**
 782      * Reads non-proxy class descriptor information from given input stream.
 783      * The resulting class descriptor is not fully functional; it can only be
 784      * used as input to the ObjectInputStream.resolveClass() and
 785      * ObjectStreamClass.initNonProxy() methods.
 786      */
 787     void readNonProxy(ObjectInputStream in)
 788         throws IOException, ClassNotFoundException
 789     {
 790         name = in.readUTF();
 791         suid = Long.valueOf(in.readLong());
 792         isProxy = false;
 793 
 794         byte flags = in.readByte();
 795         hasWriteObjectData =
 796             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 797         hasBlockExternalData =
 798             ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
 799         externalizable =
 800             ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
 801         boolean sflag =
 802             ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
 803         if (externalizable &amp;&amp; sflag) {
 804             throw new InvalidClassException(
 805                 name, &quot;serializable and externalizable flags conflict&quot;);
 806         }
 807         serializable = externalizable || sflag;
 808         isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != 0);
 809         if (isEnum &amp;&amp; suid.longValue() != 0L) {
 810             throw new InvalidClassException(name,
 811                 &quot;enum descriptor has non-zero serialVersionUID: &quot; + suid);
 812         }
 813 
 814         int numFields = in.readShort();
 815         if (isEnum &amp;&amp; numFields != 0) {
 816             throw new InvalidClassException(name,
 817                 &quot;enum descriptor has non-zero field count: &quot; + numFields);
 818         }
 819         fields = (numFields &gt; 0) ?
 820             new ObjectStreamField[numFields] : NO_FIELDS;
 821         for (int i = 0; i &lt; numFields; i++) {
 822             char tcode = (char) in.readByte();
 823             String fname = in.readUTF();
 824             String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
 825                 in.readTypeString() : new String(new char[] { tcode });
 826             try {
 827                 fields[i] = new ObjectStreamField(fname, signature, false);
 828             } catch (RuntimeException e) {
 829                 throw (IOException) new InvalidClassException(name,
 830                     &quot;invalid descriptor for field &quot; + fname).initCause(e);
 831             }
 832         }
 833         computeFieldOffsets();
 834     }
 835 
 836     /**
 837      * Writes non-proxy class descriptor information to given output stream.
 838      */
 839     void writeNonProxy(ObjectOutputStream out) throws IOException {
 840         out.writeUTF(name);
 841         out.writeLong(getSerialVersionUID());
 842 
 843         byte flags = 0;
 844         if (externalizable) {
 845             flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
 846             int protocol = out.getProtocolVersion();
 847             if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
 848                 flags |= ObjectStreamConstants.SC_BLOCK_DATA;
 849             }
 850         } else if (serializable) {
 851             flags |= ObjectStreamConstants.SC_SERIALIZABLE;
 852         }
 853         if (hasWriteObjectData) {
 854             flags |= ObjectStreamConstants.SC_WRITE_METHOD;
 855         }
 856         if (isEnum) {
 857             flags |= ObjectStreamConstants.SC_ENUM;
 858         }
 859         out.writeByte(flags);
 860 
 861         out.writeShort(fields.length);
 862         for (int i = 0; i &lt; fields.length; i++) {
 863             ObjectStreamField f = fields[i];
 864             out.writeByte(f.getTypeCode());
 865             out.writeUTF(f.getName());
 866             if (!f.isPrimitive()) {
 867                 out.writeTypeString(f.getTypeString());
 868             }
 869         }
 870     }
 871 
 872     /**
 873      * Returns ClassNotFoundException (if any) thrown while attempting to
 874      * resolve local class corresponding to this class descriptor.
 875      */
 876     ClassNotFoundException getResolveException() {
 877         return resolveEx;
 878     }
 879 
 880     /**
 881      * Throws InternalError if not initialized.
 882      */
 883     private final void requireInitialized() {
 884         if (!initialized)
 885             throw new InternalError(&quot;Unexpected call when not initialized&quot;);
 886     }
 887 
 888     /**
 889      * Throws an InvalidClassException if object instances referencing this
 890      * class descriptor should not be allowed to deserialize.  This method does
 891      * not apply to deserialization of enum constants.
 892      */
 893     void checkDeserialize() throws InvalidClassException {
 894         requireInitialized();
 895         if (deserializeEx != null) {
 896             throw deserializeEx.newInvalidClassException();
 897         }
 898     }
 899 
 900     /**
 901      * Throws an InvalidClassException if objects whose class is represented by
 902      * this descriptor should not be allowed to serialize.  This method does
 903      * not apply to serialization of enum constants.
 904      */
 905     void checkSerialize() throws InvalidClassException {
 906         requireInitialized();
 907         if (serializeEx != null) {
 908             throw serializeEx.newInvalidClassException();
 909         }
 910     }
 911 
 912     /**
 913      * Throws an InvalidClassException if objects whose class is represented by
 914      * this descriptor should not be permitted to use default serialization
 915      * (e.g., if the class declares serializable fields that do not correspond
 916      * to actual fields, and hence must use the GetField API).  This method
 917      * does not apply to deserialization of enum constants.
 918      */
 919     void checkDefaultSerialize() throws InvalidClassException {
 920         requireInitialized();
 921         if (defaultSerializeEx != null) {
 922             throw defaultSerializeEx.newInvalidClassException();
 923         }
 924     }
 925 
 926     /**
 927      * Returns superclass descriptor.  Note that on the receiving side, the
 928      * superclass descriptor may be bound to a class that is not a superclass
 929      * of the subclass descriptor&#39;s bound class.
 930      */
 931     ObjectStreamClass getSuperDesc() {
 932         requireInitialized();
 933         return superDesc;
 934     }
 935 
 936     /**
 937      * Returns the &quot;local&quot; class descriptor for the class associated with this
 938      * class descriptor (i.e., the result of
 939      * ObjectStreamClass.lookup(this.forClass())) or null if there is no class
 940      * associated with this descriptor.
 941      */
 942     ObjectStreamClass getLocalDesc() {
 943         requireInitialized();
 944         return localDesc;
 945     }
 946 
 947     /**
 948      * Returns arrays of ObjectStreamFields representing the serializable
 949      * fields of the represented class.  If copy is true, a clone of this class
 950      * descriptor&#39;s field array is returned, otherwise the array itself is
 951      * returned.
 952      */
 953     ObjectStreamField[] getFields(boolean copy) {
 954         return copy ? fields.clone() : fields;
 955     }
 956 
 957     /**
 958      * Looks up a serializable field of the represented class by name and type.
 959      * A specified type of null matches all types, Object.class matches all
 960      * non-primitive types, and any other non-null type matches assignable
 961      * types only.  Returns matching field, or null if no match found.
 962      */
 963     ObjectStreamField getField(String name, Class&lt;?&gt; type) {
 964         for (int i = 0; i &lt; fields.length; i++) {
 965             ObjectStreamField f = fields[i];
 966             if (f.getName().equals(name)) {
 967                 if (type == null ||
 968                     (type == Object.class &amp;&amp; !f.isPrimitive()))
 969                 {
 970                     return f;
 971                 }
 972                 Class&lt;?&gt; ftype = f.getType();
 973                 if (ftype != null &amp;&amp; type.isAssignableFrom(ftype)) {
 974                     return f;
 975                 }
 976             }
 977         }
 978         return null;
 979     }
 980 
 981     /**
 982      * Returns true if class descriptor represents a dynamic proxy class, false
 983      * otherwise.
 984      */
 985     boolean isProxy() {
 986         requireInitialized();
 987         return isProxy;
 988     }
 989 
 990     /**
 991      * Returns true if class descriptor represents an enum type, false
 992      * otherwise.
 993      */
 994     boolean isEnum() {
 995         requireInitialized();
 996         return isEnum;
 997     }
 998 
<a name="19" id="anc19"></a><span class="line-added"> 999     /**</span>
<span class="line-added">1000      * Returns true if class descriptor represents a record type, false</span>
<span class="line-added">1001      * otherwise.</span>
<span class="line-added">1002      */</span>
<span class="line-added">1003     boolean isRecord() {</span>
<span class="line-added">1004         requireInitialized();</span>
<span class="line-added">1005         return isRecord;</span>
<span class="line-added">1006     }</span>
<span class="line-added">1007 </span>
1008     /**
1009      * Returns true if represented class implements Externalizable, false
1010      * otherwise.
1011      */
1012     boolean isExternalizable() {
1013         requireInitialized();
1014         return externalizable;
1015     }
1016 
1017     /**
1018      * Returns true if represented class implements Serializable, false
1019      * otherwise.
1020      */
1021     boolean isSerializable() {
1022         requireInitialized();
1023         return serializable;
1024     }
1025 
1026     /**
1027      * Returns true if class descriptor represents externalizable class that
1028      * has written its data in 1.2 (block data) format, false otherwise.
1029      */
1030     boolean hasBlockExternalData() {
1031         requireInitialized();
1032         return hasBlockExternalData;
1033     }
1034 
1035     /**
1036      * Returns true if class descriptor represents serializable (but not
1037      * externalizable) class which has written its data via a custom
1038      * writeObject() method, false otherwise.
1039      */
1040     boolean hasWriteObjectData() {
1041         requireInitialized();
1042         return hasWriteObjectData;
1043     }
1044 
1045     /**
1046      * Returns true if represented class is serializable/externalizable and can
1047      * be instantiated by the serialization runtime--i.e., if it is
1048      * externalizable and defines a public no-arg constructor, or if it is
1049      * non-externalizable and its first non-serializable superclass defines an
1050      * accessible no-arg constructor.  Otherwise, returns false.
1051      */
1052     boolean isInstantiable() {
1053         requireInitialized();
1054         return (cons != null);
1055     }
1056 
1057     /**
1058      * Returns true if represented class is serializable (but not
1059      * externalizable) and defines a conformant writeObject method.  Otherwise,
1060      * returns false.
1061      */
1062     boolean hasWriteObjectMethod() {
1063         requireInitialized();
1064         return (writeObjectMethod != null);
1065     }
1066 
1067     /**
1068      * Returns true if represented class is serializable (but not
1069      * externalizable) and defines a conformant readObject method.  Otherwise,
1070      * returns false.
1071      */
1072     boolean hasReadObjectMethod() {
1073         requireInitialized();
1074         return (readObjectMethod != null);
1075     }
1076 
1077     /**
1078      * Returns true if represented class is serializable (but not
1079      * externalizable) and defines a conformant readObjectNoData method.
1080      * Otherwise, returns false.
1081      */
1082     boolean hasReadObjectNoDataMethod() {
1083         requireInitialized();
1084         return (readObjectNoDataMethod != null);
1085     }
1086 
1087     /**
1088      * Returns true if represented class is serializable or externalizable and
1089      * defines a conformant writeReplace method.  Otherwise, returns false.
1090      */
1091     boolean hasWriteReplaceMethod() {
1092         requireInitialized();
1093         return (writeReplaceMethod != null);
1094     }
1095 
1096     /**
1097      * Returns true if represented class is serializable or externalizable and
1098      * defines a conformant readResolve method.  Otherwise, returns false.
1099      */
1100     boolean hasReadResolveMethod() {
1101         requireInitialized();
1102         return (readResolveMethod != null);
1103     }
1104 
1105     /**
1106      * Creates a new instance of the represented class.  If the class is
1107      * externalizable, invokes its public no-arg constructor; otherwise, if the
1108      * class is serializable, invokes the no-arg constructor of the first
1109      * non-serializable superclass.  Throws UnsupportedOperationException if
1110      * this class descriptor is not associated with a class, if the associated
1111      * class is non-serializable or if the appropriate no-arg constructor is
1112      * inaccessible/unavailable.
1113      */
1114     Object newInstance()
1115         throws InstantiationException, InvocationTargetException,
1116                UnsupportedOperationException
1117     {
1118         requireInitialized();
1119         if (cons != null) {
1120             try {
1121                 if (domains == null || domains.length == 0) {
1122                     return cons.newInstance();
1123                 } else {
1124                     JavaSecurityAccess jsa = SharedSecrets.getJavaSecurityAccess();
1125                     PrivilegedAction&lt;?&gt; pea = () -&gt; {
1126                         try {
1127                             return cons.newInstance();
1128                         } catch (InstantiationException
1129                                  | InvocationTargetException
1130                                  | IllegalAccessException x) {
1131                             throw new UndeclaredThrowableException(x);
1132                         }
1133                     }; // Can&#39;t use PrivilegedExceptionAction with jsa
1134                     try {
1135                         return jsa.doIntersectionPrivilege(pea,
1136                                    AccessController.getContext(),
1137                                    new AccessControlContext(domains));
1138                     } catch (UndeclaredThrowableException x) {
1139                         Throwable cause = x.getCause();
1140                         if (cause instanceof InstantiationException)
1141                             throw (InstantiationException) cause;
1142                         if (cause instanceof InvocationTargetException)
1143                             throw (InvocationTargetException) cause;
1144                         if (cause instanceof IllegalAccessException)
1145                             throw (IllegalAccessException) cause;
1146                         // not supposed to happen
1147                         throw x;
1148                     }
1149                 }
1150             } catch (IllegalAccessException ex) {
1151                 // should not occur, as access checks have been suppressed
1152                 throw new InternalError(ex);
1153             }
1154         } else {
1155             throw new UnsupportedOperationException();
1156         }
1157     }
1158 
1159     /**
1160      * Invokes the writeObject method of the represented serializable class.
1161      * Throws UnsupportedOperationException if this class descriptor is not
1162      * associated with a class, or if the class is externalizable,
1163      * non-serializable or does not define writeObject.
1164      */
1165     void invokeWriteObject(Object obj, ObjectOutputStream out)
1166         throws IOException, UnsupportedOperationException
1167     {
1168         requireInitialized();
1169         if (writeObjectMethod != null) {
1170             try {
1171                 writeObjectMethod.invoke(obj, new Object[]{ out });
1172             } catch (InvocationTargetException ex) {
1173                 Throwable th = ex.getTargetException();
1174                 if (th instanceof IOException) {
1175                     throw (IOException) th;
1176                 } else {
1177                     throwMiscException(th);
1178                 }
1179             } catch (IllegalAccessException ex) {
1180                 // should not occur, as access checks have been suppressed
1181                 throw new InternalError(ex);
1182             }
1183         } else {
1184             throw new UnsupportedOperationException();
1185         }
1186     }
1187 
1188     /**
1189      * Invokes the readObject method of the represented serializable class.
1190      * Throws UnsupportedOperationException if this class descriptor is not
1191      * associated with a class, or if the class is externalizable,
1192      * non-serializable or does not define readObject.
1193      */
1194     void invokeReadObject(Object obj, ObjectInputStream in)
1195         throws ClassNotFoundException, IOException,
1196                UnsupportedOperationException
1197     {
1198         requireInitialized();
1199         if (readObjectMethod != null) {
1200             try {
1201                 readObjectMethod.invoke(obj, new Object[]{ in });
1202             } catch (InvocationTargetException ex) {
1203                 Throwable th = ex.getTargetException();
1204                 if (th instanceof ClassNotFoundException) {
1205                     throw (ClassNotFoundException) th;
1206                 } else if (th instanceof IOException) {
1207                     throw (IOException) th;
1208                 } else {
1209                     throwMiscException(th);
1210                 }
1211             } catch (IllegalAccessException ex) {
1212                 // should not occur, as access checks have been suppressed
1213                 throw new InternalError(ex);
1214             }
1215         } else {
1216             throw new UnsupportedOperationException();
1217         }
1218     }
1219 
1220     /**
1221      * Invokes the readObjectNoData method of the represented serializable
1222      * class.  Throws UnsupportedOperationException if this class descriptor is
1223      * not associated with a class, or if the class is externalizable,
1224      * non-serializable or does not define readObjectNoData.
1225      */
1226     void invokeReadObjectNoData(Object obj)
1227         throws IOException, UnsupportedOperationException
1228     {
1229         requireInitialized();
1230         if (readObjectNoDataMethod != null) {
1231             try {
1232                 readObjectNoDataMethod.invoke(obj, (Object[]) null);
1233             } catch (InvocationTargetException ex) {
1234                 Throwable th = ex.getTargetException();
1235                 if (th instanceof ObjectStreamException) {
1236                     throw (ObjectStreamException) th;
1237                 } else {
1238                     throwMiscException(th);
1239                 }
1240             } catch (IllegalAccessException ex) {
1241                 // should not occur, as access checks have been suppressed
1242                 throw new InternalError(ex);
1243             }
1244         } else {
1245             throw new UnsupportedOperationException();
1246         }
1247     }
1248 
1249     /**
1250      * Invokes the writeReplace method of the represented serializable class and
1251      * returns the result.  Throws UnsupportedOperationException if this class
1252      * descriptor is not associated with a class, or if the class is
1253      * non-serializable or does not define writeReplace.
1254      */
1255     Object invokeWriteReplace(Object obj)
1256         throws IOException, UnsupportedOperationException
1257     {
1258         requireInitialized();
1259         if (writeReplaceMethod != null) {
1260             try {
1261                 return writeReplaceMethod.invoke(obj, (Object[]) null);
1262             } catch (InvocationTargetException ex) {
1263                 Throwable th = ex.getTargetException();
1264                 if (th instanceof ObjectStreamException) {
1265                     throw (ObjectStreamException) th;
1266                 } else {
1267                     throwMiscException(th);
1268                     throw new InternalError(th);  // never reached
1269                 }
1270             } catch (IllegalAccessException ex) {
1271                 // should not occur, as access checks have been suppressed
1272                 throw new InternalError(ex);
1273             }
1274         } else {
1275             throw new UnsupportedOperationException();
1276         }
1277     }
1278 
1279     /**
1280      * Invokes the readResolve method of the represented serializable class and
1281      * returns the result.  Throws UnsupportedOperationException if this class
1282      * descriptor is not associated with a class, or if the class is
1283      * non-serializable or does not define readResolve.
1284      */
1285     Object invokeReadResolve(Object obj)
1286         throws IOException, UnsupportedOperationException
1287     {
1288         requireInitialized();
1289         if (readResolveMethod != null) {
1290             try {
1291                 return readResolveMethod.invoke(obj, (Object[]) null);
1292             } catch (InvocationTargetException ex) {
1293                 Throwable th = ex.getTargetException();
1294                 if (th instanceof ObjectStreamException) {
1295                     throw (ObjectStreamException) th;
1296                 } else {
1297                     throwMiscException(th);
1298                     throw new InternalError(th);  // never reached
1299                 }
1300             } catch (IllegalAccessException ex) {
1301                 // should not occur, as access checks have been suppressed
1302                 throw new InternalError(ex);
1303             }
1304         } else {
1305             throw new UnsupportedOperationException();
1306         }
1307     }
1308 
1309     /**
1310      * Class representing the portion of an object&#39;s serialized form allotted
1311      * to data described by a given class descriptor.  If &quot;hasData&quot; is false,
1312      * the object&#39;s serialized form does not contain data associated with the
1313      * class descriptor.
1314      */
1315     static class ClassDataSlot {
1316 
1317         /** class descriptor &quot;occupying&quot; this slot */
1318         final ObjectStreamClass desc;
1319         /** true if serialized form includes data for this slot&#39;s descriptor */
1320         final boolean hasData;
1321 
1322         ClassDataSlot(ObjectStreamClass desc, boolean hasData) {
1323             this.desc = desc;
1324             this.hasData = hasData;
1325         }
1326     }
1327 
1328     /**
1329      * Returns array of ClassDataSlot instances representing the data layout
1330      * (including superclass data) for serialized objects described by this
1331      * class descriptor.  ClassDataSlots are ordered by inheritance with those
1332      * containing &quot;higher&quot; superclasses appearing first.  The final
1333      * ClassDataSlot contains a reference to this descriptor.
1334      */
1335     ClassDataSlot[] getClassDataLayout() throws InvalidClassException {
1336         // REMIND: synchronize instead of relying on volatile?
1337         if (dataLayout == null) {
1338             dataLayout = getClassDataLayout0();
1339         }
1340         return dataLayout;
1341     }
1342 
1343     private ClassDataSlot[] getClassDataLayout0()
1344         throws InvalidClassException
1345     {
1346         ArrayList&lt;ClassDataSlot&gt; slots = new ArrayList&lt;&gt;();
1347         Class&lt;?&gt; start = cl, end = cl;
1348 
1349         // locate closest non-serializable superclass
1350         while (end != null &amp;&amp; Serializable.class.isAssignableFrom(end)) {
1351             end = end.getSuperclass();
1352         }
1353 
1354         HashSet&lt;String&gt; oscNames = new HashSet&lt;&gt;(3);
1355 
1356         for (ObjectStreamClass d = this; d != null; d = d.superDesc) {
1357             if (oscNames.contains(d.name)) {
1358                 throw new InvalidClassException(&quot;Circular reference.&quot;);
1359             } else {
1360                 oscNames.add(d.name);
1361             }
1362 
1363             // search up inheritance hierarchy for class with matching name
1364             String searchName = (d.cl != null) ? d.cl.getName() : d.name;
1365             Class&lt;?&gt; match = null;
1366             for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1367                 if (searchName.equals(c.getName())) {
1368                     match = c;
1369                     break;
1370                 }
1371             }
1372 
1373             // add &quot;no data&quot; slot for each unmatched class below match
1374             if (match != null) {
1375                 for (Class&lt;?&gt; c = start; c != match; c = c.getSuperclass()) {
1376                     slots.add(new ClassDataSlot(
1377                         ObjectStreamClass.lookup(c, true), false));
1378                 }
1379                 start = match.getSuperclass();
1380             }
1381 
1382             // record descriptor/class pairing
1383             slots.add(new ClassDataSlot(d.getVariantFor(match), true));
1384         }
1385 
1386         // add &quot;no data&quot; slot for any leftover unmatched classes
1387         for (Class&lt;?&gt; c = start; c != end; c = c.getSuperclass()) {
1388             slots.add(new ClassDataSlot(
1389                 ObjectStreamClass.lookup(c, true), false));
1390         }
1391 
1392         // order slots from superclass -&gt; subclass
1393         Collections.reverse(slots);
1394         return slots.toArray(new ClassDataSlot[slots.size()]);
1395     }
1396 
1397     /**
1398      * Returns aggregate size (in bytes) of marshalled primitive field values
1399      * for represented class.
1400      */
1401     int getPrimDataSize() {
1402         return primDataSize;
1403     }
1404 
1405     /**
1406      * Returns number of non-primitive serializable fields of represented
1407      * class.
1408      */
1409     int getNumObjFields() {
1410         return numObjFields;
1411     }
1412 
1413     /**
1414      * Fetches the serializable primitive field values of object obj and
1415      * marshals them into byte array buf starting at offset 0.  It is the
1416      * responsibility of the caller to ensure that obj is of the proper type if
1417      * non-null.
1418      */
1419     void getPrimFieldValues(Object obj, byte[] buf) {
1420         fieldRefl.getPrimFieldValues(obj, buf);
1421     }
1422 
1423     /**
1424      * Sets the serializable primitive fields of object obj using values
1425      * unmarshalled from byte array buf starting at offset 0.  It is the
1426      * responsibility of the caller to ensure that obj is of the proper type if
1427      * non-null.
1428      */
1429     void setPrimFieldValues(Object obj, byte[] buf) {
1430         fieldRefl.setPrimFieldValues(obj, buf);
1431     }
1432 
1433     /**
1434      * Fetches the serializable object field values of object obj and stores
1435      * them in array vals starting at offset 0.  It is the responsibility of
1436      * the caller to ensure that obj is of the proper type if non-null.
1437      */
1438     void getObjFieldValues(Object obj, Object[] vals) {
1439         fieldRefl.getObjFieldValues(obj, vals);
1440     }
1441 
1442     /**
1443      * Checks that the given values, from array vals starting at offset 0,
1444      * are assignable to the given serializable object fields.
1445      * @throws ClassCastException if any value is not assignable
1446      */
1447     void checkObjFieldValueTypes(Object obj, Object[] vals) {
1448         fieldRefl.checkObjectFieldValueTypes(obj, vals);
1449     }
1450 
1451     /**
1452      * Sets the serializable object fields of object obj using values from
1453      * array vals starting at offset 0.  It is the responsibility of the caller
1454      * to ensure that obj is of the proper type if non-null.
1455      */
1456     void setObjFieldValues(Object obj, Object[] vals) {
1457         fieldRefl.setObjFieldValues(obj, vals);
1458     }
1459 
1460     /**
1461      * Calculates and sets serializable field offsets, as well as primitive
1462      * data size and object field count totals.  Throws InvalidClassException
1463      * if fields are illegally ordered.
1464      */
1465     private void computeFieldOffsets() throws InvalidClassException {
1466         primDataSize = 0;
1467         numObjFields = 0;
1468         int firstObjIndex = -1;
1469 
1470         for (int i = 0; i &lt; fields.length; i++) {
1471             ObjectStreamField f = fields[i];
1472             switch (f.getTypeCode()) {
1473                 case &#39;Z&#39;:
1474                 case &#39;B&#39;:
1475                     f.setOffset(primDataSize++);
1476                     break;
1477 
1478                 case &#39;C&#39;:
1479                 case &#39;S&#39;:
1480                     f.setOffset(primDataSize);
1481                     primDataSize += 2;
1482                     break;
1483 
1484                 case &#39;I&#39;:
1485                 case &#39;F&#39;:
1486                     f.setOffset(primDataSize);
1487                     primDataSize += 4;
1488                     break;
1489 
1490                 case &#39;J&#39;:
1491                 case &#39;D&#39;:
1492                     f.setOffset(primDataSize);
1493                     primDataSize += 8;
1494                     break;
1495 
1496                 case &#39;[&#39;:
1497                 case &#39;L&#39;:
1498                     f.setOffset(numObjFields++);
1499                     if (firstObjIndex == -1) {
1500                         firstObjIndex = i;
1501                     }
1502                     break;
1503 
1504                 default:
1505                     throw new InternalError();
1506             }
1507         }
1508         if (firstObjIndex != -1 &amp;&amp;
1509             firstObjIndex + numObjFields != fields.length)
1510         {
1511             throw new InvalidClassException(name, &quot;illegal field order&quot;);
1512         }
1513     }
1514 
1515     /**
1516      * If given class is the same as the class associated with this class
1517      * descriptor, returns reference to this class descriptor.  Otherwise,
1518      * returns variant of this class descriptor bound to given class.
1519      */
1520     private ObjectStreamClass getVariantFor(Class&lt;?&gt; cl)
1521         throws InvalidClassException
1522     {
1523         if (this.cl == cl) {
1524             return this;
1525         }
1526         ObjectStreamClass desc = new ObjectStreamClass();
1527         if (isProxy) {
1528             desc.initProxy(cl, null, superDesc);
1529         } else {
1530             desc.initNonProxy(this, cl, null, superDesc);
1531         }
1532         return desc;
1533     }
1534 
1535     /**
1536      * Returns public no-arg constructor of given class, or null if none found.
1537      * Access checks are disabled on the returned constructor (if any), since
1538      * the defining class may still be non-public.
1539      */
1540     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1541         try {
1542             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1543             cons.setAccessible(true);
1544             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1545                 cons : null;
1546         } catch (NoSuchMethodException ex) {
1547             return null;
1548         }
1549     }
1550 
1551     /**
1552      * Returns subclass-accessible no-arg constructor of first non-serializable
1553      * superclass, or null if none found.  Access checks are disabled on the
1554      * returned constructor (if any).
1555      */
1556     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1557         return reflFactory.newConstructorForSerialization(cl);
1558     }
1559 
<a name="20" id="anc20"></a><span class="line-added">1560     /**</span>
<span class="line-added">1561      * Returns the canonical constructor for the given record class, or null if</span>
<span class="line-added">1562      * the not found ( which should never happen for correctly generated record</span>
<span class="line-added">1563      * classes ).</span>
<span class="line-added">1564      */</span>
<span class="line-added">1565     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1566     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {</span>
<span class="line-added">1567         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;</span>
<span class="line-added">1568         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {</span>
<span class="line-added">1569             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())</span>
<span class="line-added">1570                                           .map(RecordComponent::getType)</span>
<span class="line-added">1571                                           .toArray(Class&lt;?&gt;[]::new);</span>
<span class="line-added">1572             try {</span>
<span class="line-added">1573                 Constructor&lt;?&gt; ctr = cls.getConstructor(paramTypes);</span>
<span class="line-added">1574                 ctr.setAccessible(true);</span>
<span class="line-added">1575                 return MethodHandles.lookup().unreflectConstructor(ctr);</span>
<span class="line-added">1576             } catch (IllegalAccessException | NoSuchMethodException e) {</span>
<span class="line-added">1577                 return null;</span>
<span class="line-added">1578             }</span>
<span class="line-added">1579         };</span>
<span class="line-added">1580         return AccessController.doPrivileged(pa);</span>
<span class="line-added">1581     }</span>
<span class="line-added">1582 </span>
<span class="line-added">1583     /**</span>
<span class="line-added">1584      * Returns the canonical constructor, if the local class equivalent of this</span>
<span class="line-added">1585      * stream class descriptor is a record class, otherwise null.</span>
<span class="line-added">1586      */</span>
<span class="line-added">1587     MethodHandle getRecordConstructor() {</span>
<span class="line-added">1588         return canonicalCtr;</span>
<span class="line-added">1589     }</span>
<span class="line-added">1590 </span>
1591     /**
1592      * Returns non-static, non-abstract method with given signature provided it
1593      * is defined by or accessible (via inheritance) by the given class, or
1594      * null if no match found.  Access checks are disabled on the returned
1595      * method (if any).
1596      */
1597     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1598                                                Class&lt;?&gt;[] argTypes,
1599                                                Class&lt;?&gt; returnType)
1600     {
1601         Method meth = null;
1602         Class&lt;?&gt; defCl = cl;
1603         while (defCl != null) {
1604             try {
1605                 meth = defCl.getDeclaredMethod(name, argTypes);
1606                 break;
1607             } catch (NoSuchMethodException ex) {
1608                 defCl = defCl.getSuperclass();
1609             }
1610         }
1611 
1612         if ((meth == null) || (meth.getReturnType() != returnType)) {
1613             return null;
1614         }
1615         meth.setAccessible(true);
1616         int mods = meth.getModifiers();
1617         if ((mods &amp; (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
1618             return null;
1619         } else if ((mods &amp; (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
1620             return meth;
1621         } else if ((mods &amp; Modifier.PRIVATE) != 0) {
1622             return (cl == defCl) ? meth : null;
1623         } else {
1624             return packageEquals(cl, defCl) ? meth : null;
1625         }
1626     }
1627 
1628     /**
1629      * Returns non-static private method with given signature defined by given
1630      * class, or null if none found.  Access checks are disabled on the
1631      * returned method (if any).
1632      */
1633     private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,
1634                                            Class&lt;?&gt;[] argTypes,
1635                                            Class&lt;?&gt; returnType)
1636     {
1637         try {
1638             Method meth = cl.getDeclaredMethod(name, argTypes);
1639             meth.setAccessible(true);
1640             int mods = meth.getModifiers();
1641             return ((meth.getReturnType() == returnType) &amp;&amp;
1642                     ((mods &amp; Modifier.STATIC) == 0) &amp;&amp;
1643                     ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;
1644         } catch (NoSuchMethodException ex) {
1645             return null;
1646         }
1647     }
1648 
1649     /**
1650      * Returns true if classes are defined in the same runtime package, false
1651      * otherwise.
1652      */
1653     private static boolean packageEquals(Class&lt;?&gt; cl1, Class&lt;?&gt; cl2) {
1654         return (cl1.getClassLoader() == cl2.getClassLoader() &amp;&amp;
1655                 cl1.getPackageName().equals(cl2.getPackageName()));
1656     }
1657 
1658     /**
1659      * Compares class names for equality, ignoring package names.  Returns true
1660      * if class names equal, false otherwise.
1661      */
1662     private static boolean classNamesEqual(String name1, String name2) {
1663         int idx1 = name1.lastIndexOf(&#39;.&#39;) + 1;
1664         int idx2 = name2.lastIndexOf(&#39;.&#39;) + 1;
1665         int len1 = name1.length() - idx1;
1666         int len2 = name2.length() - idx2;
1667         return len1 == len2 &amp;&amp;
1668                 name1.regionMatches(idx1, name2, idx2, len1);
1669     }
1670 
1671     /**
1672      * Returns JVM type signature for given list of parameters and return type.
1673      */
1674     private static String getMethodSignature(Class&lt;?&gt;[] paramTypes,
1675                                              Class&lt;?&gt; retType)
1676     {
1677         StringBuilder sb = new StringBuilder();
1678         sb.append(&#39;(&#39;);
1679         for (int i = 0; i &lt; paramTypes.length; i++) {
1680             appendClassSignature(sb, paramTypes[i]);
1681         }
1682         sb.append(&#39;)&#39;);
1683         appendClassSignature(sb, retType);
1684         return sb.toString();
1685     }
1686 
1687     /**
1688      * Convenience method for throwing an exception that is either a
1689      * RuntimeException, Error, or of some unexpected type (in which case it is
1690      * wrapped inside an IOException).
1691      */
1692     private static void throwMiscException(Throwable th) throws IOException {
1693         if (th instanceof RuntimeException) {
1694             throw (RuntimeException) th;
1695         } else if (th instanceof Error) {
1696             throw (Error) th;
1697         } else {
1698             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1699             ex.initCause(th);
1700             throw ex;
1701         }
1702     }
1703 
1704     /**
1705      * Returns ObjectStreamField array describing the serializable fields of
1706      * the given class.  Serializable fields backed by an actual field of the
1707      * class are represented by ObjectStreamFields with corresponding non-null
1708      * Field objects.  Throws InvalidClassException if the (explicitly
1709      * declared) serializable fields are invalid.
1710      */
1711     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1712         throws InvalidClassException
1713     {
<a name="21" id="anc21"></a><span class="line-added">1714         if (!Serializable.class.isAssignableFrom(cl))</span>
<span class="line-added">1715             return NO_FIELDS;</span>
<span class="line-added">1716 </span>
1717         ObjectStreamField[] fields;
<a name="22" id="anc22"></a><span class="line-modified">1718         if (isRecord(cl)) {</span>
<span class="line-modified">1719             fields = getDefaultSerialFields(cl);</span>
<span class="line-added">1720             Arrays.sort(fields);</span>
<span class="line-added">1721         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;</span>
1722             !Proxy.isProxyClass(cl) &amp;&amp;
<a name="23" id="anc23"></a><span class="line-modified">1723                    !cl.isInterface()) {</span>

1724             if ((fields = getDeclaredSerialFields(cl)) == null) {
1725                 fields = getDefaultSerialFields(cl);
1726             }
1727             Arrays.sort(fields);
1728         } else {
1729             fields = NO_FIELDS;
1730         }
1731         return fields;
1732     }
1733 
1734     /**
1735      * Returns serializable fields of given class as defined explicitly by a
1736      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1737      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1738      * by an actual field of the class are represented by ObjectStreamFields
1739      * with corresponding non-null Field objects.  For compatibility with past
1740      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1741      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1742      * InvalidClassException if the declared serializable fields are
1743      * invalid--e.g., if multiple fields share the same name.
1744      */
1745     private static ObjectStreamField[] getDeclaredSerialFields(Class&lt;?&gt; cl)
1746         throws InvalidClassException
1747     {
1748         ObjectStreamField[] serialPersistentFields = null;
1749         try {
1750             Field f = cl.getDeclaredField(&quot;serialPersistentFields&quot;);
1751             int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;
1752             if ((f.getModifiers() &amp; mask) == mask) {
1753                 f.setAccessible(true);
1754                 serialPersistentFields = (ObjectStreamField[]) f.get(null);
1755             }
1756         } catch (Exception ex) {
1757         }
1758         if (serialPersistentFields == null) {
1759             return null;
1760         } else if (serialPersistentFields.length == 0) {
1761             return NO_FIELDS;
1762         }
1763 
1764         ObjectStreamField[] boundFields =
1765             new ObjectStreamField[serialPersistentFields.length];
1766         Set&lt;String&gt; fieldNames = new HashSet&lt;&gt;(serialPersistentFields.length);
1767 
1768         for (int i = 0; i &lt; serialPersistentFields.length; i++) {
1769             ObjectStreamField spf = serialPersistentFields[i];
1770 
1771             String fname = spf.getName();
1772             if (fieldNames.contains(fname)) {
1773                 throw new InvalidClassException(
1774                     &quot;multiple serializable fields named &quot; + fname);
1775             }
1776             fieldNames.add(fname);
1777 
1778             try {
1779                 Field f = cl.getDeclaredField(fname);
1780                 if ((f.getType() == spf.getType()) &amp;&amp;
1781                     ((f.getModifiers() &amp; Modifier.STATIC) == 0))
1782                 {
1783                     boundFields[i] =
1784                         new ObjectStreamField(f, spf.isUnshared(), true);
1785                 }
1786             } catch (NoSuchFieldException ex) {
1787             }
1788             if (boundFields[i] == null) {
1789                 boundFields[i] = new ObjectStreamField(
1790                     fname, spf.getType(), spf.isUnshared());
1791             }
1792         }
1793         return boundFields;
1794     }
1795 
1796     /**
1797      * Returns array of ObjectStreamFields corresponding to all non-static
1798      * non-transient fields declared by given class.  Each ObjectStreamField
1799      * contains a Field object for the field it represents.  If no default
1800      * serializable fields exist, NO_FIELDS is returned.
1801      */
1802     private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {
1803         Field[] clFields = cl.getDeclaredFields();
1804         ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();
1805         int mask = Modifier.STATIC | Modifier.TRANSIENT;
1806 
1807         for (int i = 0; i &lt; clFields.length; i++) {
1808             if ((clFields[i].getModifiers() &amp; mask) == 0) {
1809                 list.add(new ObjectStreamField(clFields[i], false, true));
1810             }
1811         }
1812         int size = list.size();
1813         return (size == 0) ? NO_FIELDS :
1814             list.toArray(new ObjectStreamField[size]);
1815     }
1816 
1817     /**
1818      * Returns explicit serial version UID value declared by given class, or
1819      * null if none.
1820      */
1821     private static Long getDeclaredSUID(Class&lt;?&gt; cl) {
1822         try {
1823             Field f = cl.getDeclaredField(&quot;serialVersionUID&quot;);
1824             int mask = Modifier.STATIC | Modifier.FINAL;
1825             if ((f.getModifiers() &amp; mask) == mask) {
1826                 f.setAccessible(true);
1827                 return Long.valueOf(f.getLong(null));
1828             }
1829         } catch (Exception ex) {
1830         }
1831         return null;
1832     }
1833 
1834     /**
1835      * Computes the default serial version UID value for the given class.
1836      */
1837     private static long computeDefaultSUID(Class&lt;?&gt; cl) {
1838         if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl))
1839         {
1840             return 0L;
1841         }
1842 
1843         try {
1844             ByteArrayOutputStream bout = new ByteArrayOutputStream();
1845             DataOutputStream dout = new DataOutputStream(bout);
1846 
1847             dout.writeUTF(cl.getName());
1848 
1849             int classMods = cl.getModifiers() &amp;
1850                 (Modifier.PUBLIC | Modifier.FINAL |
1851                  Modifier.INTERFACE | Modifier.ABSTRACT);
1852 
1853             /*
1854              * compensate for javac bug in which ABSTRACT bit was set for an
1855              * interface only if the interface declared methods
1856              */
1857             Method[] methods = cl.getDeclaredMethods();
1858             if ((classMods &amp; Modifier.INTERFACE) != 0) {
1859                 classMods = (methods.length &gt; 0) ?
1860                     (classMods | Modifier.ABSTRACT) :
1861                     (classMods &amp; ~Modifier.ABSTRACT);
1862             }
1863             dout.writeInt(classMods);
1864 
1865             if (!cl.isArray()) {
1866                 /*
1867                  * compensate for change in 1.2FCS in which
1868                  * Class.getInterfaces() was modified to return Cloneable and
1869                  * Serializable for array classes.
1870                  */
1871                 Class&lt;?&gt;[] interfaces = cl.getInterfaces();
1872                 String[] ifaceNames = new String[interfaces.length];
1873                 for (int i = 0; i &lt; interfaces.length; i++) {
1874                     ifaceNames[i] = interfaces[i].getName();
1875                 }
1876                 Arrays.sort(ifaceNames);
1877                 for (int i = 0; i &lt; ifaceNames.length; i++) {
1878                     dout.writeUTF(ifaceNames[i]);
1879                 }
1880             }
1881 
1882             Field[] fields = cl.getDeclaredFields();
1883             MemberSignature[] fieldSigs = new MemberSignature[fields.length];
1884             for (int i = 0; i &lt; fields.length; i++) {
1885                 fieldSigs[i] = new MemberSignature(fields[i]);
1886             }
1887             Arrays.sort(fieldSigs, new Comparator&lt;&gt;() {
1888                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1889                     return ms1.name.compareTo(ms2.name);
1890                 }
1891             });
1892             for (int i = 0; i &lt; fieldSigs.length; i++) {
1893                 MemberSignature sig = fieldSigs[i];
1894                 int mods = sig.member.getModifiers() &amp;
1895                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1896                      Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |
1897                      Modifier.TRANSIENT);
1898                 if (((mods &amp; Modifier.PRIVATE) == 0) ||
1899                     ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == 0))
1900                 {
1901                     dout.writeUTF(sig.name);
1902                     dout.writeInt(mods);
1903                     dout.writeUTF(sig.signature);
1904                 }
1905             }
1906 
1907             if (hasStaticInitializer(cl)) {
1908                 dout.writeUTF(&quot;&lt;clinit&gt;&quot;);
1909                 dout.writeInt(Modifier.STATIC);
1910                 dout.writeUTF(&quot;()V&quot;);
1911             }
1912 
1913             Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();
1914             MemberSignature[] consSigs = new MemberSignature[cons.length];
1915             for (int i = 0; i &lt; cons.length; i++) {
1916                 consSigs[i] = new MemberSignature(cons[i]);
1917             }
1918             Arrays.sort(consSigs, new Comparator&lt;&gt;() {
1919                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1920                     return ms1.signature.compareTo(ms2.signature);
1921                 }
1922             });
1923             for (int i = 0; i &lt; consSigs.length; i++) {
1924                 MemberSignature sig = consSigs[i];
1925                 int mods = sig.member.getModifiers() &amp;
1926                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1927                      Modifier.STATIC | Modifier.FINAL |
1928                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1929                      Modifier.ABSTRACT | Modifier.STRICT);
1930                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1931                     dout.writeUTF(&quot;&lt;init&gt;&quot;);
1932                     dout.writeInt(mods);
1933                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1934                 }
1935             }
1936 
1937             MemberSignature[] methSigs = new MemberSignature[methods.length];
1938             for (int i = 0; i &lt; methods.length; i++) {
1939                 methSigs[i] = new MemberSignature(methods[i]);
1940             }
1941             Arrays.sort(methSigs, new Comparator&lt;&gt;() {
1942                 public int compare(MemberSignature ms1, MemberSignature ms2) {
1943                     int comp = ms1.name.compareTo(ms2.name);
1944                     if (comp == 0) {
1945                         comp = ms1.signature.compareTo(ms2.signature);
1946                     }
1947                     return comp;
1948                 }
1949             });
1950             for (int i = 0; i &lt; methSigs.length; i++) {
1951                 MemberSignature sig = methSigs[i];
1952                 int mods = sig.member.getModifiers() &amp;
1953                     (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |
1954                      Modifier.STATIC | Modifier.FINAL |
1955                      Modifier.SYNCHRONIZED | Modifier.NATIVE |
1956                      Modifier.ABSTRACT | Modifier.STRICT);
1957                 if ((mods &amp; Modifier.PRIVATE) == 0) {
1958                     dout.writeUTF(sig.name);
1959                     dout.writeInt(mods);
1960                     dout.writeUTF(sig.signature.replace(&#39;/&#39;, &#39;.&#39;));
1961                 }
1962             }
1963 
1964             dout.flush();
1965 
1966             MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
1967             byte[] hashBytes = md.digest(bout.toByteArray());
1968             long hash = 0;
1969             for (int i = Math.min(hashBytes.length, 8) - 1; i &gt;= 0; i--) {
1970                 hash = (hash &lt;&lt; 8) | (hashBytes[i] &amp; 0xFF);
1971             }
1972             return hash;
1973         } catch (IOException ex) {
1974             throw new InternalError(ex);
1975         } catch (NoSuchAlgorithmException ex) {
1976             throw new SecurityException(ex.getMessage());
1977         }
1978     }
1979 
1980     /**
1981      * Returns true if the given class defines a static initializer method,
1982      * false otherwise.
1983      */
1984     private static native boolean hasStaticInitializer(Class&lt;?&gt; cl);
1985 
1986     /**
1987      * Class for computing and caching field/constructor/method signatures
1988      * during serialVersionUID calculation.
1989      */
1990     private static class MemberSignature {
1991 
1992         public final Member member;
1993         public final String name;
1994         public final String signature;
1995 
1996         public MemberSignature(Field field) {
1997             member = field;
1998             name = field.getName();
1999             signature = getClassSignature(field.getType());
2000         }
2001 
2002         public MemberSignature(Constructor&lt;?&gt; cons) {
2003             member = cons;
2004             name = cons.getName();
2005             signature = getMethodSignature(
2006                 cons.getParameterTypes(), Void.TYPE);
2007         }
2008 
2009         public MemberSignature(Method meth) {
2010             member = meth;
2011             name = meth.getName();
2012             signature = getMethodSignature(
2013                 meth.getParameterTypes(), meth.getReturnType());
2014         }
2015     }
2016 
2017     /**
2018      * Class for setting and retrieving serializable field values in batch.
2019      */
2020     // REMIND: dynamically generate these?
2021     private static class FieldReflector {
2022 
2023         /** handle for performing unsafe operations */
2024         private static final Unsafe unsafe = Unsafe.getUnsafe();
2025 
2026         /** fields to operate on */
2027         private final ObjectStreamField[] fields;
2028         /** number of primitive fields */
2029         private final int numPrimFields;
2030         /** unsafe field keys for reading fields - may contain dupes */
2031         private final long[] readKeys;
2032         /** unsafe fields keys for writing fields - no dupes */
2033         private final long[] writeKeys;
2034         /** field data offsets */
2035         private final int[] offsets;
2036         /** field type codes */
2037         private final char[] typeCodes;
2038         /** field types */
2039         private final Class&lt;?&gt;[] types;
2040 
2041         /**
2042          * Constructs FieldReflector capable of setting/getting values from the
2043          * subset of fields whose ObjectStreamFields contain non-null
2044          * reflective Field objects.  ObjectStreamFields with null Fields are
2045          * treated as filler, for which get operations return default values
2046          * and set operations discard given values.
2047          */
2048         FieldReflector(ObjectStreamField[] fields) {
2049             this.fields = fields;
2050             int nfields = fields.length;
2051             readKeys = new long[nfields];
2052             writeKeys = new long[nfields];
2053             offsets = new int[nfields];
2054             typeCodes = new char[nfields];
2055             ArrayList&lt;Class&lt;?&gt;&gt; typeList = new ArrayList&lt;&gt;();
2056             Set&lt;Long&gt; usedKeys = new HashSet&lt;&gt;();
2057 
2058 
2059             for (int i = 0; i &lt; nfields; i++) {
2060                 ObjectStreamField f = fields[i];
2061                 Field rf = f.getField();
2062                 long key = (rf != null) ?
2063                     unsafe.objectFieldOffset(rf) : Unsafe.INVALID_FIELD_OFFSET;
2064                 readKeys[i] = key;
2065                 writeKeys[i] = usedKeys.add(key) ?
2066                     key : Unsafe.INVALID_FIELD_OFFSET;
2067                 offsets[i] = f.getOffset();
2068                 typeCodes[i] = f.getTypeCode();
2069                 if (!f.isPrimitive()) {
2070                     typeList.add((rf != null) ? rf.getType() : null);
2071                 }
2072             }
2073 
2074             types = typeList.toArray(new Class&lt;?&gt;[typeList.size()]);
2075             numPrimFields = nfields - types.length;
2076         }
2077 
2078         /**
2079          * Returns list of ObjectStreamFields representing fields operated on
2080          * by this reflector.  The shared/unshared values and Field objects
2081          * contained by ObjectStreamFields in the list reflect their bindings
2082          * to locally defined serializable fields.
2083          */
2084         ObjectStreamField[] getFields() {
2085             return fields;
2086         }
2087 
2088         /**
2089          * Fetches the serializable primitive field values of object obj and
2090          * marshals them into byte array buf starting at offset 0.  The caller
2091          * is responsible for ensuring that obj is of the proper type.
2092          */
2093         void getPrimFieldValues(Object obj, byte[] buf) {
2094             if (obj == null) {
2095                 throw new NullPointerException();
2096             }
2097             /* assuming checkDefaultSerialize() has been called on the class
2098              * descriptor this FieldReflector was obtained from, no field keys
2099              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2100              */
2101             for (int i = 0; i &lt; numPrimFields; i++) {
2102                 long key = readKeys[i];
2103                 int off = offsets[i];
2104                 switch (typeCodes[i]) {
2105                     case &#39;Z&#39;:
2106                         Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));
2107                         break;
2108 
2109                     case &#39;B&#39;:
2110                         buf[off] = unsafe.getByte(obj, key);
2111                         break;
2112 
2113                     case &#39;C&#39;:
2114                         Bits.putChar(buf, off, unsafe.getChar(obj, key));
2115                         break;
2116 
2117                     case &#39;S&#39;:
2118                         Bits.putShort(buf, off, unsafe.getShort(obj, key));
2119                         break;
2120 
2121                     case &#39;I&#39;:
2122                         Bits.putInt(buf, off, unsafe.getInt(obj, key));
2123                         break;
2124 
2125                     case &#39;F&#39;:
2126                         Bits.putFloat(buf, off, unsafe.getFloat(obj, key));
2127                         break;
2128 
2129                     case &#39;J&#39;:
2130                         Bits.putLong(buf, off, unsafe.getLong(obj, key));
2131                         break;
2132 
2133                     case &#39;D&#39;:
2134                         Bits.putDouble(buf, off, unsafe.getDouble(obj, key));
2135                         break;
2136 
2137                     default:
2138                         throw new InternalError();
2139                 }
2140             }
2141         }
2142 
2143         /**
2144          * Sets the serializable primitive fields of object obj using values
2145          * unmarshalled from byte array buf starting at offset 0.  The caller
2146          * is responsible for ensuring that obj is of the proper type.
2147          */
2148         void setPrimFieldValues(Object obj, byte[] buf) {
2149             if (obj == null) {
2150                 throw new NullPointerException();
2151             }
2152             for (int i = 0; i &lt; numPrimFields; i++) {
2153                 long key = writeKeys[i];
2154                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2155                     continue;           // discard value
2156                 }
2157                 int off = offsets[i];
2158                 switch (typeCodes[i]) {
2159                     case &#39;Z&#39;:
2160                         unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));
2161                         break;
2162 
2163                     case &#39;B&#39;:
2164                         unsafe.putByte(obj, key, buf[off]);
2165                         break;
2166 
2167                     case &#39;C&#39;:
2168                         unsafe.putChar(obj, key, Bits.getChar(buf, off));
2169                         break;
2170 
2171                     case &#39;S&#39;:
2172                         unsafe.putShort(obj, key, Bits.getShort(buf, off));
2173                         break;
2174 
2175                     case &#39;I&#39;:
2176                         unsafe.putInt(obj, key, Bits.getInt(buf, off));
2177                         break;
2178 
2179                     case &#39;F&#39;:
2180                         unsafe.putFloat(obj, key, Bits.getFloat(buf, off));
2181                         break;
2182 
2183                     case &#39;J&#39;:
2184                         unsafe.putLong(obj, key, Bits.getLong(buf, off));
2185                         break;
2186 
2187                     case &#39;D&#39;:
2188                         unsafe.putDouble(obj, key, Bits.getDouble(buf, off));
2189                         break;
2190 
2191                     default:
2192                         throw new InternalError();
2193                 }
2194             }
2195         }
2196 
2197         /**
2198          * Fetches the serializable object field values of object obj and
2199          * stores them in array vals starting at offset 0.  The caller is
2200          * responsible for ensuring that obj is of the proper type.
2201          */
2202         void getObjFieldValues(Object obj, Object[] vals) {
2203             if (obj == null) {
2204                 throw new NullPointerException();
2205             }
2206             /* assuming checkDefaultSerialize() has been called on the class
2207              * descriptor this FieldReflector was obtained from, no field keys
2208              * in array should be equal to Unsafe.INVALID_FIELD_OFFSET.
2209              */
2210             for (int i = numPrimFields; i &lt; fields.length; i++) {
2211                 switch (typeCodes[i]) {
2212                     case &#39;L&#39;:
2213                     case &#39;[&#39;:
2214                         vals[offsets[i]] = unsafe.getReference(obj, readKeys[i]);
2215                         break;
2216 
2217                     default:
2218                         throw new InternalError();
2219                 }
2220             }
2221         }
2222 
2223         /**
2224          * Checks that the given values, from array vals starting at offset 0,
2225          * are assignable to the given serializable object fields.
2226          * @throws ClassCastException if any value is not assignable
2227          */
2228         void checkObjectFieldValueTypes(Object obj, Object[] vals) {
2229             setObjFieldValues(obj, vals, true);
2230         }
2231 
2232         /**
2233          * Sets the serializable object fields of object obj using values from
2234          * array vals starting at offset 0.  The caller is responsible for
2235          * ensuring that obj is of the proper type; however, attempts to set a
2236          * field with a value of the wrong type will trigger an appropriate
2237          * ClassCastException.
2238          */
2239         void setObjFieldValues(Object obj, Object[] vals) {
2240             setObjFieldValues(obj, vals, false);
2241         }
2242 
2243         private void setObjFieldValues(Object obj, Object[] vals, boolean dryRun) {
2244             if (obj == null) {
2245                 throw new NullPointerException();
2246             }
2247             for (int i = numPrimFields; i &lt; fields.length; i++) {
2248                 long key = writeKeys[i];
2249                 if (key == Unsafe.INVALID_FIELD_OFFSET) {
2250                     continue;           // discard value
2251                 }
2252                 switch (typeCodes[i]) {
2253                     case &#39;L&#39;:
2254                     case &#39;[&#39;:
2255                         Object val = vals[offsets[i]];
2256                         if (val != null &amp;&amp;
2257                             !types[i - numPrimFields].isInstance(val))
2258                         {
2259                             Field f = fields[i].getField();
2260                             throw new ClassCastException(
2261                                 &quot;cannot assign instance of &quot; +
2262                                 val.getClass().getName() + &quot; to field &quot; +
2263                                 f.getDeclaringClass().getName() + &quot;.&quot; +
2264                                 f.getName() + &quot; of type &quot; +
2265                                 f.getType().getName() + &quot; in instance of &quot; +
2266                                 obj.getClass().getName());
2267                         }
2268                         if (!dryRun)
2269                             unsafe.putReference(obj, key, val);
2270                         break;
2271 
2272                     default:
2273                         throw new InternalError();
2274                 }
2275             }
2276         }
2277     }
2278 
2279     /**
2280      * Matches given set of serializable fields with serializable fields
2281      * described by the given local class descriptor, and returns a
2282      * FieldReflector instance capable of setting/getting values from the
2283      * subset of fields that match (non-matching fields are treated as filler,
2284      * for which get operations return default values and set operations
2285      * discard given values).  Throws InvalidClassException if unresolvable
2286      * type conflicts exist between the two sets of fields.
2287      */
2288     private static FieldReflector getReflector(ObjectStreamField[] fields,
2289                                                ObjectStreamClass localDesc)
2290         throws InvalidClassException
2291     {
2292         // class irrelevant if no fields
2293         Class&lt;?&gt; cl = (localDesc != null &amp;&amp; fields.length &gt; 0) ?
2294             localDesc.cl : null;
2295         processQueue(Caches.reflectorsQueue, Caches.reflectors);
2296         FieldReflectorKey key = new FieldReflectorKey(cl, fields,
2297                                                       Caches.reflectorsQueue);
2298         Reference&lt;?&gt; ref = Caches.reflectors.get(key);
2299         Object entry = null;
2300         if (ref != null) {
2301             entry = ref.get();
2302         }
2303         EntryFuture future = null;
2304         if (entry == null) {
2305             EntryFuture newEntry = new EntryFuture();
2306             Reference&lt;?&gt; newRef = new SoftReference&lt;&gt;(newEntry);
2307             do {
2308                 if (ref != null) {
2309                     Caches.reflectors.remove(key, ref);
2310                 }
2311                 ref = Caches.reflectors.putIfAbsent(key, newRef);
2312                 if (ref != null) {
2313                     entry = ref.get();
2314                 }
2315             } while (ref != null &amp;&amp; entry == null);
2316             if (entry == null) {
2317                 future = newEntry;
2318             }
2319         }
2320 
2321         if (entry instanceof FieldReflector) {  // check common case first
2322             return (FieldReflector) entry;
2323         } else if (entry instanceof EntryFuture) {
2324             entry = ((EntryFuture) entry).get();
2325         } else if (entry == null) {
2326             try {
2327                 entry = new FieldReflector(matchFields(fields, localDesc));
2328             } catch (Throwable th) {
2329                 entry = th;
2330             }
2331             future.set(entry);
2332             Caches.reflectors.put(key, new SoftReference&lt;&gt;(entry));
2333         }
2334 
2335         if (entry instanceof FieldReflector) {
2336             return (FieldReflector) entry;
2337         } else if (entry instanceof InvalidClassException) {
2338             throw (InvalidClassException) entry;
2339         } else if (entry instanceof RuntimeException) {
2340             throw (RuntimeException) entry;
2341         } else if (entry instanceof Error) {
2342             throw (Error) entry;
2343         } else {
2344             throw new InternalError(&quot;unexpected entry: &quot; + entry);
2345         }
2346     }
2347 
2348     /**
2349      * FieldReflector cache lookup key.  Keys are considered equal if they
2350      * refer to the same class and equivalent field formats.
2351      */
2352     private static class FieldReflectorKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2353 
2354         private final String[] sigs;
2355         private final int hash;
2356         private final boolean nullClass;
2357 
2358         FieldReflectorKey(Class&lt;?&gt; cl, ObjectStreamField[] fields,
2359                           ReferenceQueue&lt;Class&lt;?&gt;&gt; queue)
2360         {
2361             super(cl, queue);
2362             nullClass = (cl == null);
2363             sigs = new String[2 * fields.length];
2364             for (int i = 0, j = 0; i &lt; fields.length; i++) {
2365                 ObjectStreamField f = fields[i];
2366                 sigs[j++] = f.getName();
2367                 sigs[j++] = f.getSignature();
2368             }
2369             hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);
2370         }
2371 
2372         public int hashCode() {
2373             return hash;
2374         }
2375 
2376         public boolean equals(Object obj) {
2377             if (obj == this) {
2378                 return true;
2379             }
2380 
2381             if (obj instanceof FieldReflectorKey) {
2382                 FieldReflectorKey other = (FieldReflectorKey) obj;
2383                 Class&lt;?&gt; referent;
2384                 return (nullClass ? other.nullClass
2385                                   : ((referent = get()) != null) &amp;&amp;
2386                                     (referent == other.get())) &amp;&amp;
2387                         Arrays.equals(sigs, other.sigs);
2388             } else {
2389                 return false;
2390             }
2391         }
2392     }
2393 
2394     /**
2395      * Matches given set of serializable fields with serializable fields
2396      * obtained from the given local class descriptor (which contain bindings
2397      * to reflective Field objects).  Returns list of ObjectStreamFields in
2398      * which each ObjectStreamField whose signature matches that of a local
2399      * field contains a Field object for that field; unmatched
2400      * ObjectStreamFields contain null Field objects.  Shared/unshared settings
2401      * of the returned ObjectStreamFields also reflect those of matched local
2402      * ObjectStreamFields.  Throws InvalidClassException if unresolvable type
2403      * conflicts exist between the two sets of fields.
2404      */
2405     private static ObjectStreamField[] matchFields(ObjectStreamField[] fields,
2406                                                    ObjectStreamClass localDesc)
2407         throws InvalidClassException
2408     {
2409         ObjectStreamField[] localFields = (localDesc != null) ?
2410             localDesc.fields : NO_FIELDS;
2411 
2412         /*
2413          * Even if fields == localFields, we cannot simply return localFields
2414          * here.  In previous implementations of serialization,
2415          * ObjectStreamField.getType() returned Object.class if the
2416          * ObjectStreamField represented a non-primitive field and belonged to
2417          * a non-local class descriptor.  To preserve this (questionable)
2418          * behavior, the ObjectStreamField instances returned by matchFields
2419          * cannot report non-primitive types other than Object.class; hence
2420          * localFields cannot be returned directly.
2421          */
2422 
2423         ObjectStreamField[] matches = new ObjectStreamField[fields.length];
2424         for (int i = 0; i &lt; fields.length; i++) {
2425             ObjectStreamField f = fields[i], m = null;
2426             for (int j = 0; j &lt; localFields.length; j++) {
2427                 ObjectStreamField lf = localFields[j];
2428                 if (f.getName().equals(lf.getName())) {
2429                     if ((f.isPrimitive() || lf.isPrimitive()) &amp;&amp;
2430                         f.getTypeCode() != lf.getTypeCode())
2431                     {
2432                         throw new InvalidClassException(localDesc.name,
2433                             &quot;incompatible types for field &quot; + f.getName());
2434                     }
2435                     if (lf.getField() != null) {
2436                         m = new ObjectStreamField(
2437                             lf.getField(), lf.isUnshared(), false);
2438                     } else {
2439                         m = new ObjectStreamField(
2440                             lf.getName(), lf.getSignature(), lf.isUnshared());
2441                     }
2442                 }
2443             }
2444             if (m == null) {
2445                 m = new ObjectStreamField(
2446                     f.getName(), f.getSignature(), false);
2447             }
2448             m.setOffset(f.getOffset());
2449             matches[i] = m;
2450         }
2451         return matches;
2452     }
2453 
2454     /**
2455      * Removes from the specified map any keys that have been enqueued
2456      * on the specified reference queue.
2457      */
2458     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2459                              ConcurrentMap&lt;? extends
2460                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2461     {
2462         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2463         while((ref = queue.poll()) != null) {
2464             map.remove(ref);
2465         }
2466     }
2467 
2468     /**
2469      *  Weak key for Class objects.
2470      *
2471      **/
2472     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2473         /**
2474          * saved value of the referent&#39;s identity hash code, to maintain
2475          * a consistent hash code after the referent has been cleared
2476          */
2477         private final int hash;
2478 
2479         /**
2480          * Create a new WeakClassKey to the given object, registered
2481          * with a queue.
2482          */
2483         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2484             super(cl, refQueue);
2485             hash = System.identityHashCode(cl);
2486         }
2487 
2488         /**
2489          * Returns the identity hash code of the original referent.
2490          */
2491         public int hashCode() {
2492             return hash;
2493         }
2494 
2495         /**
2496          * Returns true if the given object is this identical
2497          * WeakClassKey instance, or, if this object&#39;s referent has not
2498          * been cleared, if the given object is another WeakClassKey
2499          * instance with the identical non-null referent as this one.
2500          */
2501         public boolean equals(Object obj) {
2502             if (obj == this) {
2503                 return true;
2504             }
2505 
2506             if (obj instanceof WeakClassKey) {
2507                 Object referent = get();
2508                 return (referent != null) &amp;&amp;
2509                        (referent == ((WeakClassKey) obj).get());
2510             } else {
2511                 return false;
2512             }
2513         }
2514     }
<a name="24" id="anc24"></a><span class="line-added">2515 </span>
<span class="line-added">2516     /** Record specific support for retrieving and binding stream field values. */</span>
<span class="line-added">2517     static final class RecordSupport {</span>
<span class="line-added">2518 </span>
<span class="line-added">2519         /** Binds the given stream field values to the given method handle. */</span>
<span class="line-added">2520         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2521         static MethodHandle bindCtrValues(MethodHandle ctrMH,</span>
<span class="line-added">2522                                           ObjectStreamClass desc,</span>
<span class="line-added">2523                                           ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">2524             RecordComponent[] recordComponents;</span>
<span class="line-added">2525             try {</span>
<span class="line-added">2526                 Class&lt;?&gt; cls = desc.forClass();</span>
<span class="line-added">2527                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;</span>
<span class="line-added">2528                 recordComponents = AccessController.doPrivileged(pa);</span>
<span class="line-added">2529             } catch (PrivilegedActionException e) {</span>
<span class="line-added">2530                 throw new InternalError(e.getCause());</span>
<span class="line-added">2531             }</span>
<span class="line-added">2532 </span>
<span class="line-added">2533             Object[] args = new Object[recordComponents.length];</span>
<span class="line-added">2534             for (int i = 0; i &lt; recordComponents.length; i++) {</span>
<span class="line-added">2535                 String name = recordComponents[i].getName();</span>
<span class="line-added">2536                 Class&lt;?&gt; type= recordComponents[i].getType();</span>
<span class="line-added">2537                 Object o = streamFieldValue(name, type, desc, fieldValues);</span>
<span class="line-added">2538                 args[i] = o;</span>
<span class="line-added">2539             }</span>
<span class="line-added">2540 </span>
<span class="line-added">2541             return MethodHandles.insertArguments(ctrMH, 0, args);</span>
<span class="line-added">2542         }</span>
<span class="line-added">2543 </span>
<span class="line-added">2544         /** Returns the number of primitive fields for the given descriptor. */</span>
<span class="line-added">2545         private static int numberPrimValues(ObjectStreamClass desc) {</span>
<span class="line-added">2546             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">2547             int primValueCount = 0;</span>
<span class="line-added">2548             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2549                 if (fields[i].isPrimitive())</span>
<span class="line-added">2550                     primValueCount++;</span>
<span class="line-added">2551                 else</span>
<span class="line-added">2552                     break;  // can be no more</span>
<span class="line-added">2553             }</span>
<span class="line-added">2554             return primValueCount;</span>
<span class="line-added">2555         }</span>
<span class="line-added">2556 </span>
<span class="line-added">2557         /** Returns the default value for the given type. */</span>
<span class="line-added">2558         private static Object defaultValueFor(Class&lt;?&gt; pType) {</span>
<span class="line-added">2559             if (pType == Integer.TYPE)</span>
<span class="line-added">2560                 return 0;</span>
<span class="line-added">2561             else if (pType == Byte.TYPE)</span>
<span class="line-added">2562                 return (byte)0;</span>
<span class="line-added">2563             else if (pType == Long.TYPE)</span>
<span class="line-added">2564                 return 0L;</span>
<span class="line-added">2565             else if (pType == Float.TYPE)</span>
<span class="line-added">2566                 return 0.0f;</span>
<span class="line-added">2567             else if (pType == Double.TYPE)</span>
<span class="line-added">2568                 return 0.0d;</span>
<span class="line-added">2569             else if (pType == Short.TYPE)</span>
<span class="line-added">2570                 return (short)0;</span>
<span class="line-added">2571             else if (pType == Character.TYPE)</span>
<span class="line-added">2572                 return &#39;\u0000&#39;;</span>
<span class="line-added">2573             else if (pType == Boolean.TYPE)</span>
<span class="line-added">2574                 return false;</span>
<span class="line-added">2575             else</span>
<span class="line-added">2576                 return null;</span>
<span class="line-added">2577         }</span>
<span class="line-added">2578 </span>
<span class="line-added">2579         /**</span>
<span class="line-added">2580          * Returns the stream field value for the given name. The default value</span>
<span class="line-added">2581          * for the given type is returned if the field value is absent.</span>
<span class="line-added">2582          */</span>
<span class="line-added">2583         private static Object streamFieldValue(String pName,</span>
<span class="line-added">2584                                                Class&lt;?&gt; pType,</span>
<span class="line-added">2585                                                ObjectStreamClass desc,</span>
<span class="line-added">2586                                                ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">2587             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">2588 </span>
<span class="line-added">2589             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2590                 ObjectStreamField f = fields[i];</span>
<span class="line-added">2591                 String fName = f.getName();</span>
<span class="line-added">2592                 if (!fName.equals(pName))</span>
<span class="line-added">2593                     continue;</span>
<span class="line-added">2594 </span>
<span class="line-added">2595                 Class&lt;?&gt; fType = f.getField().getType();</span>
<span class="line-added">2596                 if (!pType.isAssignableFrom(fType))</span>
<span class="line-added">2597                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);</span>
<span class="line-added">2598 </span>
<span class="line-added">2599                 if (f.isPrimitive()) {</span>
<span class="line-added">2600                     if (pType == Integer.TYPE)</span>
<span class="line-added">2601                         return Bits.getInt(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2602                     else if (fType == Byte.TYPE)</span>
<span class="line-added">2603                         return fieldValues.primValues[f.getOffset()];</span>
<span class="line-added">2604                     else if (fType == Long.TYPE)</span>
<span class="line-added">2605                         return Bits.getLong(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2606                     else if (fType == Float.TYPE)</span>
<span class="line-added">2607                         return Bits.getFloat(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2608                     else if (fType == Double.TYPE)</span>
<span class="line-added">2609                         return Bits.getDouble(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2610                     else if (fType == Short.TYPE)</span>
<span class="line-added">2611                         return Bits.getShort(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2612                     else if (fType == Character.TYPE)</span>
<span class="line-added">2613                         return Bits.getChar(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2614                     else if (fType == Boolean.TYPE)</span>
<span class="line-added">2615                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2616                     else</span>
<span class="line-added">2617                         throw new InternalError(&quot;Unexpected type: &quot; + fType);</span>
<span class="line-added">2618                 } else { // reference</span>
<span class="line-added">2619                     return fieldValues.objValues[i - numberPrimValues(desc)];</span>
<span class="line-added">2620                 }</span>
<span class="line-added">2621             }</span>
<span class="line-added">2622 </span>
<span class="line-added">2623             return defaultValueFor(pType);</span>
<span class="line-added">2624         }</span>
<span class="line-added">2625     }</span>
2626 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
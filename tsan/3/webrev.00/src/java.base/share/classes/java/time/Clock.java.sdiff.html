<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/Clock.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../text/spi/NumberFormatProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateTimeException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/Clock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
462     /**
463      * A hash code for this clock.
464      * &lt;p&gt;
465      * Clocks should override this method based on
466      * their state and to meet the contract of {@link Object#hashCode}.
467      * If not overridden, the behavior is defined by {@link Object#hashCode}
468      *
469      * @return a suitable hash code
470      */
471     @Override
472     public  int hashCode() {
473         return super.hashCode();
474     }
475 
476     //-----------------------------------------------------------------------
477     /**
478      * Implementation of a clock that always returns the latest time from
479      * {@link System#currentTimeMillis()}.
480      */
481     static final class SystemClock extends Clock implements Serializable {

482         private static final long serialVersionUID = 6740630888130243051L;
483         private static final long OFFSET_SEED =
484                 System.currentTimeMillis()/1000 - 1024; // initial offest
485         static final SystemClock UTC = new SystemClock(ZoneOffset.UTC);
486 
487         private final ZoneId zone;
488         // We don&#39;t actually need a volatile here.
489         // We don&#39;t care if offset is set or read concurrently by multiple
490         // threads - we just need a value which is &#39;recent enough&#39; - in other
491         // words something that has been updated at least once in the last
492         // 2^32 secs (~136 years). And even if we by chance see an invalid
493         // offset, the worst that can happen is that we will get a -1 value
494         // from getNanoTimeAdjustment, forcing us to update the offset
495         // once again.
496         private transient long offset;
497 
498         SystemClock(ZoneId zone) {
499             this.zone = zone;
500             this.offset = OFFSET_SEED;
501         }
</pre>
<hr />
<pre>
555                     offset = localOffset;
556                 }
557             }
558             return Instant.ofEpochSecond(localOffset, adjustment);
559         }
560         @Override
561         public boolean equals(Object obj) {
562             if (obj instanceof SystemClock) {
563                 return zone.equals(((SystemClock) obj).zone);
564             }
565             return false;
566         }
567         @Override
568         public int hashCode() {
569             return zone.hashCode() + 1;
570         }
571         @Override
572         public String toString() {
573             return &quot;SystemClock[&quot; + zone + &quot;]&quot;;
574         }

575         private void readObject(ObjectInputStream is)
576                 throws IOException, ClassNotFoundException {
577             // ensure that offset is initialized
578             is.defaultReadObject();
579             offset = OFFSET_SEED;
580         }
581     }
582 
583     //-----------------------------------------------------------------------
584     /**
585      * Implementation of a clock that always returns the same instant.
586      * This is typically used for testing.
587      */
588     static final class FixedClock extends Clock implements Serializable {

589         private static final long serialVersionUID = 7430389292664866958L;
590         private final Instant instant;
591         private final ZoneId zone;
592 
593         FixedClock(Instant fixedInstant, ZoneId zone) {
594             this.instant = fixedInstant;
595             this.zone = zone;
596         }
597         @Override
598         public ZoneId getZone() {
599             return zone;
600         }
601         @Override
602         public Clock withZone(ZoneId zone) {
603             if (zone.equals(this.zone)) {  // intentional NPE
604                 return this;
605             }
606             return new FixedClock(instant, zone);
607         }
608         @Override
</pre>
<hr />
<pre>
619                 FixedClock other = (FixedClock) obj;
620                 return instant.equals(other.instant) &amp;&amp; zone.equals(other.zone);
621             }
622             return false;
623         }
624         @Override
625         public int hashCode() {
626             return instant.hashCode() ^ zone.hashCode();
627         }
628         @Override
629         public String toString() {
630             return &quot;FixedClock[&quot; + instant + &quot;,&quot; + zone + &quot;]&quot;;
631         }
632     }
633 
634     //-----------------------------------------------------------------------
635     /**
636      * Implementation of a clock that adds an offset to an underlying clock.
637      */
638     static final class OffsetClock extends Clock implements Serializable {

639         private static final long serialVersionUID = 2007484719125426256L;

640         private final Clock baseClock;
641         private final Duration offset;
642 
643         OffsetClock(Clock baseClock, Duration offset) {
644             this.baseClock = baseClock;
645             this.offset = offset;
646         }
647         @Override
648         public ZoneId getZone() {
649             return baseClock.getZone();
650         }
651         @Override
652         public Clock withZone(ZoneId zone) {
653             if (zone.equals(baseClock.getZone())) {  // intentional NPE
654                 return this;
655             }
656             return new OffsetClock(baseClock.withZone(zone), offset);
657         }
658         @Override
659         public long millis() {
</pre>
<hr />
<pre>
669                 OffsetClock other = (OffsetClock) obj;
670                 return baseClock.equals(other.baseClock) &amp;&amp; offset.equals(other.offset);
671             }
672             return false;
673         }
674         @Override
675         public int hashCode() {
676             return baseClock.hashCode() ^ offset.hashCode();
677         }
678         @Override
679         public String toString() {
680             return &quot;OffsetClock[&quot; + baseClock + &quot;,&quot; + offset + &quot;]&quot;;
681         }
682     }
683 
684     //-----------------------------------------------------------------------
685     /**
686      * Implementation of a clock that adds an offset to an underlying clock.
687      */
688     static final class TickClock extends Clock implements Serializable {

689         private static final long serialVersionUID = 6504659149906368850L;

690         private final Clock baseClock;
691         private final long tickNanos;
692 
693         TickClock(Clock baseClock, long tickNanos) {
694             this.baseClock = baseClock;
695             this.tickNanos = tickNanos;
696         }
697         @Override
698         public ZoneId getZone() {
699             return baseClock.getZone();
700         }
701         @Override
702         public Clock withZone(ZoneId zone) {
703             if (zone.equals(baseClock.getZone())) {  // intentional NPE
704                 return this;
705             }
706             return new TickClock(baseClock.withZone(zone), tickNanos);
707         }
708         @Override
709         public long millis() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
462     /**
463      * A hash code for this clock.
464      * &lt;p&gt;
465      * Clocks should override this method based on
466      * their state and to meet the contract of {@link Object#hashCode}.
467      * If not overridden, the behavior is defined by {@link Object#hashCode}
468      *
469      * @return a suitable hash code
470      */
471     @Override
472     public  int hashCode() {
473         return super.hashCode();
474     }
475 
476     //-----------------------------------------------------------------------
477     /**
478      * Implementation of a clock that always returns the latest time from
479      * {@link System#currentTimeMillis()}.
480      */
481     static final class SystemClock extends Clock implements Serializable {
<span class="line-added">482         @java.io.Serial</span>
483         private static final long serialVersionUID = 6740630888130243051L;
484         private static final long OFFSET_SEED =
485                 System.currentTimeMillis()/1000 - 1024; // initial offest
486         static final SystemClock UTC = new SystemClock(ZoneOffset.UTC);
487 
488         private final ZoneId zone;
489         // We don&#39;t actually need a volatile here.
490         // We don&#39;t care if offset is set or read concurrently by multiple
491         // threads - we just need a value which is &#39;recent enough&#39; - in other
492         // words something that has been updated at least once in the last
493         // 2^32 secs (~136 years). And even if we by chance see an invalid
494         // offset, the worst that can happen is that we will get a -1 value
495         // from getNanoTimeAdjustment, forcing us to update the offset
496         // once again.
497         private transient long offset;
498 
499         SystemClock(ZoneId zone) {
500             this.zone = zone;
501             this.offset = OFFSET_SEED;
502         }
</pre>
<hr />
<pre>
556                     offset = localOffset;
557                 }
558             }
559             return Instant.ofEpochSecond(localOffset, adjustment);
560         }
561         @Override
562         public boolean equals(Object obj) {
563             if (obj instanceof SystemClock) {
564                 return zone.equals(((SystemClock) obj).zone);
565             }
566             return false;
567         }
568         @Override
569         public int hashCode() {
570             return zone.hashCode() + 1;
571         }
572         @Override
573         public String toString() {
574             return &quot;SystemClock[&quot; + zone + &quot;]&quot;;
575         }
<span class="line-added">576         @java.io.Serial</span>
577         private void readObject(ObjectInputStream is)
578                 throws IOException, ClassNotFoundException {
579             // ensure that offset is initialized
580             is.defaultReadObject();
581             offset = OFFSET_SEED;
582         }
583     }
584 
585     //-----------------------------------------------------------------------
586     /**
587      * Implementation of a clock that always returns the same instant.
588      * This is typically used for testing.
589      */
590     static final class FixedClock extends Clock implements Serializable {
<span class="line-added">591         @java.io.Serial</span>
592         private static final long serialVersionUID = 7430389292664866958L;
593         private final Instant instant;
594         private final ZoneId zone;
595 
596         FixedClock(Instant fixedInstant, ZoneId zone) {
597             this.instant = fixedInstant;
598             this.zone = zone;
599         }
600         @Override
601         public ZoneId getZone() {
602             return zone;
603         }
604         @Override
605         public Clock withZone(ZoneId zone) {
606             if (zone.equals(this.zone)) {  // intentional NPE
607                 return this;
608             }
609             return new FixedClock(instant, zone);
610         }
611         @Override
</pre>
<hr />
<pre>
622                 FixedClock other = (FixedClock) obj;
623                 return instant.equals(other.instant) &amp;&amp; zone.equals(other.zone);
624             }
625             return false;
626         }
627         @Override
628         public int hashCode() {
629             return instant.hashCode() ^ zone.hashCode();
630         }
631         @Override
632         public String toString() {
633             return &quot;FixedClock[&quot; + instant + &quot;,&quot; + zone + &quot;]&quot;;
634         }
635     }
636 
637     //-----------------------------------------------------------------------
638     /**
639      * Implementation of a clock that adds an offset to an underlying clock.
640      */
641     static final class OffsetClock extends Clock implements Serializable {
<span class="line-added">642         @java.io.Serial</span>
643         private static final long serialVersionUID = 2007484719125426256L;
<span class="line-added">644         @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
645         private final Clock baseClock;
646         private final Duration offset;
647 
648         OffsetClock(Clock baseClock, Duration offset) {
649             this.baseClock = baseClock;
650             this.offset = offset;
651         }
652         @Override
653         public ZoneId getZone() {
654             return baseClock.getZone();
655         }
656         @Override
657         public Clock withZone(ZoneId zone) {
658             if (zone.equals(baseClock.getZone())) {  // intentional NPE
659                 return this;
660             }
661             return new OffsetClock(baseClock.withZone(zone), offset);
662         }
663         @Override
664         public long millis() {
</pre>
<hr />
<pre>
674                 OffsetClock other = (OffsetClock) obj;
675                 return baseClock.equals(other.baseClock) &amp;&amp; offset.equals(other.offset);
676             }
677             return false;
678         }
679         @Override
680         public int hashCode() {
681             return baseClock.hashCode() ^ offset.hashCode();
682         }
683         @Override
684         public String toString() {
685             return &quot;OffsetClock[&quot; + baseClock + &quot;,&quot; + offset + &quot;]&quot;;
686         }
687     }
688 
689     //-----------------------------------------------------------------------
690     /**
691      * Implementation of a clock that adds an offset to an underlying clock.
692      */
693     static final class TickClock extends Clock implements Serializable {
<span class="line-added">694         @java.io.Serial</span>
695         private static final long serialVersionUID = 6504659149906368850L;
<span class="line-added">696         @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
697         private final Clock baseClock;
698         private final long tickNanos;
699 
700         TickClock(Clock baseClock, long tickNanos) {
701             this.baseClock = baseClock;
702             this.tickNanos = tickNanos;
703         }
704         @Override
705         public ZoneId getZone() {
706             return baseClock.getZone();
707         }
708         @Override
709         public Clock withZone(ZoneId zone) {
710             if (zone.equals(baseClock.getZone())) {  // intentional NPE
711                 return this;
712             }
713             return new TickClock(baseClock.withZone(zone), tickNanos);
714         }
715         @Override
716         public long millis() {
</pre>
</td>
</tr>
</table>
<center><a href="../text/spi/NumberFormatProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateTimeException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
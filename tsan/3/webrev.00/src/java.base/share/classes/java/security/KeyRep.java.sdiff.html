<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/KeyRep.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyPairGeneratorSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/KeyRep.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 40  *
 41  * &lt;p&gt;
 42  *
 43  * Note that a serialized Key may contain sensitive information
 44  * which should not be exposed in untrusted environments.  See the
 45  * &lt;a href=&quot;{@docRoot}/../specs/serialization/security.html&quot;&gt;
 46  * Security Appendix&lt;/a&gt;
 47  * of the Serialization Specification for more information.
 48  *
 49  * @see Key
 50  * @see KeyFactory
 51  * @see javax.crypto.spec.SecretKeySpec
 52  * @see java.security.spec.X509EncodedKeySpec
 53  * @see java.security.spec.PKCS8EncodedKeySpec
 54  *
 55  * @since 1.5
 56  */
 57 
 58 public class KeyRep implements Serializable {
 59 

 60     private static final long serialVersionUID = -4757683898830641853L;
 61 
 62     /**
 63      * Key type.
 64      *
 65      * @since 1.5
 66      */
 67     public static enum Type {
 68 
 69         /** Type for secret keys. */
 70         SECRET,
 71 
 72         /** Type for public keys. */
 73         PUBLIC,
 74 
 75         /** Type for private keys. */
 76         PRIVATE,
 77 
 78     }
 79 
</pre>
<hr />
<pre>
103     private String format;
104 
105     /**
106      * The encoded Key bytes
107      *
108      * @serial
109      */
110     private byte[] encoded;
111 
112     /**
113      * Construct the alternate Key class.
114      *
115      * @param type either one of Type.SECRET, Type.PUBLIC, or Type.PRIVATE
116      * @param algorithm the algorithm returned from
117      *          {@code Key.getAlgorithm()}
118      * @param format the encoding format returned from
119      *          {@code Key.getFormat()}
120      * @param encoded the encoded bytes returned from
121      *          {@code Key.getEncoded()}
122      *
<span class="line-modified">123      * @exception NullPointerException</span>
124      *          if type is {@code null},
125      *          if algorithm is {@code null},
126      *          if format is {@code null},
127      *          or if encoded is {@code null}
128      */
129     public KeyRep(Type type, String algorithm,
130                 String format, byte[] encoded) {
131 
132         if (type == null || algorithm == null ||
133             format == null || encoded == null) {
134             throw new NullPointerException(&quot;invalid null input(s)&quot;);
135         }
136 
137         this.type = type;
138         this.algorithm = algorithm;
139         this.format = format.toUpperCase(Locale.ENGLISH);
140         this.encoded = encoded.clone();
141     }
142 
143     /**
144      * Resolve the Key object.
145      *
146      * &lt;p&gt; This method supports three Type/format combinations:
147      * &lt;ul&gt;
148      * &lt;li&gt; Type.SECRET/&quot;RAW&quot; - returns a SecretKeySpec object
149      * constructed using encoded key bytes and algorithm
150      * &lt;li&gt; Type.PUBLIC/&quot;X.509&quot; - gets a KeyFactory instance for
151      * the key algorithm, constructs an X509EncodedKeySpec with the
152      * encoded key bytes, and generates a public key from the spec
153      * &lt;li&gt; Type.PRIVATE/&quot;PKCS#8&quot; - gets a KeyFactory instance for
154      * the key algorithm, constructs a PKCS8EncodedKeySpec with the
155      * encoded key bytes, and generates a private key from the spec
156      * &lt;/ul&gt;
157      *
158      * @return the resolved Key object
159      *
<span class="line-modified">160      * @exception ObjectStreamException if the Type/format</span>
161      *  combination is unrecognized, if the algorithm, key format, or
162      *  encoded key bytes are unrecognized/invalid, of if the
163      *  resolution of the key fails for any reason
164      */

165     protected Object readResolve() throws ObjectStreamException {
166         try {
167             if (type == Type.SECRET &amp;&amp; RAW.equals(format)) {
168                 return new SecretKeySpec(encoded, algorithm);
169             } else if (type == Type.PUBLIC &amp;&amp; X509.equals(format)) {
170                 KeyFactory f = KeyFactory.getInstance(algorithm);
171                 return f.generatePublic(new X509EncodedKeySpec(encoded));
172             } else if (type == Type.PRIVATE &amp;&amp; PKCS8.equals(format)) {
173                 KeyFactory f = KeyFactory.getInstance(algorithm);
174                 return f.generatePrivate(new PKCS8EncodedKeySpec(encoded));
175             } else {
176                 throw new NotSerializableException
177                         (&quot;unrecognized type/format combination: &quot; +
178                         type + &quot;/&quot; + format);
179             }
180         } catch (NotSerializableException nse) {
181             throw nse;
182         } catch (Exception e) {
183             NotSerializableException nse = new NotSerializableException
184                                         (&quot;java.security.Key: &quot; +
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 40  *
 41  * &lt;p&gt;
 42  *
 43  * Note that a serialized Key may contain sensitive information
 44  * which should not be exposed in untrusted environments.  See the
 45  * &lt;a href=&quot;{@docRoot}/../specs/serialization/security.html&quot;&gt;
 46  * Security Appendix&lt;/a&gt;
 47  * of the Serialization Specification for more information.
 48  *
 49  * @see Key
 50  * @see KeyFactory
 51  * @see javax.crypto.spec.SecretKeySpec
 52  * @see java.security.spec.X509EncodedKeySpec
 53  * @see java.security.spec.PKCS8EncodedKeySpec
 54  *
 55  * @since 1.5
 56  */
 57 
 58 public class KeyRep implements Serializable {
 59 
<span class="line-added"> 60     @java.io.Serial</span>
 61     private static final long serialVersionUID = -4757683898830641853L;
 62 
 63     /**
 64      * Key type.
 65      *
 66      * @since 1.5
 67      */
 68     public static enum Type {
 69 
 70         /** Type for secret keys. */
 71         SECRET,
 72 
 73         /** Type for public keys. */
 74         PUBLIC,
 75 
 76         /** Type for private keys. */
 77         PRIVATE,
 78 
 79     }
 80 
</pre>
<hr />
<pre>
104     private String format;
105 
106     /**
107      * The encoded Key bytes
108      *
109      * @serial
110      */
111     private byte[] encoded;
112 
113     /**
114      * Construct the alternate Key class.
115      *
116      * @param type either one of Type.SECRET, Type.PUBLIC, or Type.PRIVATE
117      * @param algorithm the algorithm returned from
118      *          {@code Key.getAlgorithm()}
119      * @param format the encoding format returned from
120      *          {@code Key.getFormat()}
121      * @param encoded the encoded bytes returned from
122      *          {@code Key.getEncoded()}
123      *
<span class="line-modified">124      * @throws    NullPointerException</span>
125      *          if type is {@code null},
126      *          if algorithm is {@code null},
127      *          if format is {@code null},
128      *          or if encoded is {@code null}
129      */
130     public KeyRep(Type type, String algorithm,
131                 String format, byte[] encoded) {
132 
133         if (type == null || algorithm == null ||
134             format == null || encoded == null) {
135             throw new NullPointerException(&quot;invalid null input(s)&quot;);
136         }
137 
138         this.type = type;
139         this.algorithm = algorithm;
140         this.format = format.toUpperCase(Locale.ENGLISH);
141         this.encoded = encoded.clone();
142     }
143 
144     /**
145      * Resolve the Key object.
146      *
147      * &lt;p&gt; This method supports three Type/format combinations:
148      * &lt;ul&gt;
149      * &lt;li&gt; Type.SECRET/&quot;RAW&quot; - returns a SecretKeySpec object
150      * constructed using encoded key bytes and algorithm
151      * &lt;li&gt; Type.PUBLIC/&quot;X.509&quot; - gets a KeyFactory instance for
152      * the key algorithm, constructs an X509EncodedKeySpec with the
153      * encoded key bytes, and generates a public key from the spec
154      * &lt;li&gt; Type.PRIVATE/&quot;PKCS#8&quot; - gets a KeyFactory instance for
155      * the key algorithm, constructs a PKCS8EncodedKeySpec with the
156      * encoded key bytes, and generates a private key from the spec
157      * &lt;/ul&gt;
158      *
159      * @return the resolved Key object
160      *
<span class="line-modified">161      * @throws    ObjectStreamException if the Type/format</span>
162      *  combination is unrecognized, if the algorithm, key format, or
163      *  encoded key bytes are unrecognized/invalid, of if the
164      *  resolution of the key fails for any reason
165      */
<span class="line-added">166     @java.io.Serial</span>
167     protected Object readResolve() throws ObjectStreamException {
168         try {
169             if (type == Type.SECRET &amp;&amp; RAW.equals(format)) {
170                 return new SecretKeySpec(encoded, algorithm);
171             } else if (type == Type.PUBLIC &amp;&amp; X509.equals(format)) {
172                 KeyFactory f = KeyFactory.getInstance(algorithm);
173                 return f.generatePublic(new X509EncodedKeySpec(encoded));
174             } else if (type == Type.PRIVATE &amp;&amp; PKCS8.equals(format)) {
175                 KeyFactory f = KeyFactory.getInstance(algorithm);
176                 return f.generatePrivate(new PKCS8EncodedKeySpec(encoded));
177             } else {
178                 throw new NotSerializableException
179                         (&quot;unrecognized type/format combination: &quot; +
180                         type + &quot;/&quot; + format);
181             }
182         } catch (NotSerializableException nse) {
183             throw nse;
184         } catch (Exception e) {
185             NotSerializableException nse = new NotSerializableException
186                                         (&quot;java.security.Key: &quot; +
</pre>
</td>
</tr>
</table>
<center><a href="KeyPairGeneratorSpi.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
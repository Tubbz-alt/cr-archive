<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/Inet4Address.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.ObjectStreamException;
 29 
 30 /**
 31  * This class represents an Internet Protocol version 4 (IPv4) address.
 32  * Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;
 33  * &lt;i&gt;RFC&amp;nbsp;790: Assigned Numbers&lt;/i&gt;&lt;/a&gt;,
 34  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt;
 35  * &lt;i&gt;RFC&amp;nbsp;1918: Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;,
 36  * and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
 37  * Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;
 38  *
<a name="2" id="anc2"></a><span class="line-modified"> 39  * &lt;h3&gt; &lt;a id=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h3&gt;</span>
 40  *
 41  * Textual representation of IPv4 address used as input to methods
 42  * takes one of the following forms:
 43  *
 44  * &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 45  * &lt;li&gt;{@code d.d.d.d}&lt;/li&gt;
 46  * &lt;li&gt;{@code d.d.d}&lt;/li&gt;
 47  * &lt;li&gt;{@code d.d}&lt;/li&gt;
 48  * &lt;li&gt;{@code d}&lt;/li&gt;
 49  * &lt;/ul&gt;&lt;/blockquote&gt;
 50  *
 51  * &lt;p&gt; When four parts are specified, each is interpreted as a byte of
 52  * data and assigned, from left to right, to the four bytes of an IPv4
 53  * address.
 54 
 55  * &lt;p&gt; When a three part address is specified, the last part is
 56  * interpreted as a 16-bit quantity and placed in the right most two
 57  * bytes of the network address. This makes the three part address
 58  * format convenient for specifying Class B net- work addresses as
 59  * 128.net.host.
 60  *
 61  * &lt;p&gt; When a two part address is supplied, the last part is
 62  * interpreted as a 24-bit quantity and placed in the right most three
 63  * bytes of the network address. This makes the two part address
 64  * format convenient for specifying Class A network addresses as
 65  * net.host.
 66  *
 67  * &lt;p&gt; When only one part is given, the value is stored directly in
 68  * the network address without any byte rearrangement.
 69  *
 70  * &lt;p&gt; For methods that return a textual representation as output
 71  * value, the first form, i.e. a dotted-quad string, is used.
 72  *
<a name="3" id="anc3"></a><span class="line-modified"> 73  * &lt;h4&gt; The Scope of a Multicast Address &lt;/h4&gt;</span>
 74  *
 75  * Historically the IPv4 TTL field in the IP header has doubled as a
 76  * multicast scope field: a TTL of 0 means node-local, 1 means
 77  * link-local, up through 32 means site-local, up through 64 means
 78  * region-local, up through 128 means continent-local, and up through
 79  * 255 are global. However, the administrative scoping is preferred.
 80  * Please refer to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;
 81  * &lt;i&gt;RFC&amp;nbsp;2365: Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;
 82  * @since 1.4
 83  */
 84 
 85 public final
 86 class Inet4Address extends InetAddress {
 87     static final int INADDRSZ = 4;
 88 
 89     /** use serialVersionUID from InetAddress, but Inet4Address instance
 90      *  is always replaced by an InetAddress instance before being
 91      *  serialized */
<a name="4" id="anc4"></a>
 92     private static final long serialVersionUID = 3286316764910316507L;
 93 
 94     /*
 95      * Perform initializations.
 96      */
 97     static {
 98         init();
 99     }
100 
101     Inet4Address() {
102         super();
103         holder().hostName = null;
104         holder().address = 0;
105         holder().family = IPv4;
106     }
107 
108     Inet4Address(String hostName, byte addr[]) {
109         holder().hostName = hostName;
110         holder().family = IPv4;
111         if (addr != null) {
112             if (addr.length == INADDRSZ) {
113                 int address  = addr[3] &amp; 0xFF;
114                 address |= ((addr[2] &lt;&lt; 8) &amp; 0xFF00);
115                 address |= ((addr[1] &lt;&lt; 16) &amp; 0xFF0000);
116                 address |= ((addr[0] &lt;&lt; 24) &amp; 0xFF000000);
117                 holder().address = address;
118             }
119         }
120         holder().originalHostName = hostName;
121     }
122     Inet4Address(String hostName, int address) {
123         holder().hostName = hostName;
124         holder().family = IPv4;
125         holder().address = address;
126         holder().originalHostName = hostName;
127     }
128 
129     /**
130      * Replaces the object to be serialized with an InetAddress object.
131      *
132      * @return the alternate object to be serialized.
133      *
134      * @throws ObjectStreamException if a new object replacing this
135      * object could not be created
136      */
<a name="5" id="anc5"></a>
137     private Object writeReplace() throws ObjectStreamException {
138         // will replace the to be serialized &#39;this&#39; object
139         InetAddress inet = new InetAddress();
140         inet.holder().hostName = holder().getHostName();
141         inet.holder().address = holder().getAddress();
142 
143         /**
144          * Prior to 1.4 an InetAddress was created with a family
145          * based on the platform AF_INET value (usually 2).
146          * For compatibility reasons we must therefore write
147          * the InetAddress with this family.
148          */
149         inet.holder().family = 2;
150 
151         return inet;
152     }
153 
154     /**
155      * Utility routine to check if the InetAddress is an
156      * IP multicast address. IP multicast address is a Class D
157      * address i.e first four bits of the address are 1110.
158      * @return a {@code boolean} indicating if the InetAddress is
159      * an IP multicast address
160      */
161     public boolean isMulticastAddress() {
162         return ((holder().getAddress() &amp; 0xf0000000) == 0xe0000000);
163     }
164 
165     /**
166      * Utility routine to check if the InetAddress is a wildcard address.
167      * @return a {@code boolean} indicating if the InetAddress is
168      *         a wildcard address.
169      */
170     public boolean isAnyLocalAddress() {
171         return holder().getAddress() == 0;
172     }
173 
174     /**
175      * Utility routine to check if the InetAddress is a loopback address.
176      *
177      * @return a {@code boolean} indicating if the InetAddress is
178      * a loopback address; or false otherwise.
179      */
180     public boolean isLoopbackAddress() {
181         /* 127.x.x.x */
182         byte[] byteAddr = getAddress();
183         return byteAddr[0] == 127;
184     }
185 
186     /**
187      * Utility routine to check if the InetAddress is an link local address.
188      *
189      * @return a {@code boolean} indicating if the InetAddress is
190      * a link local address; or false if address is not a link local unicast address.
191      */
192     public boolean isLinkLocalAddress() {
193         // link-local unicast in IPv4 (169.254.0.0/16)
194         // defined in &quot;Documenting Special Use IPv4 Address Blocks
195         // that have been Registered with IANA&quot; by Bill Manning
196         // draft-manning-dsua-06.txt
197         int address = holder().getAddress();
198         return (((address &gt;&gt;&gt; 24) &amp; 0xFF) == 169)
199             &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) == 254);
200     }
201 
202     /**
203      * Utility routine to check if the InetAddress is a site local address.
204      *
205      * @return a {@code boolean} indicating if the InetAddress is
206      * a site local address; or false if address is not a site local unicast address.
207      */
208     public boolean isSiteLocalAddress() {
209         // refer to RFC 1918
210         // 10/8 prefix
211         // 172.16/12 prefix
212         // 192.168/16 prefix
213         int address = holder().getAddress();
214         return (((address &gt;&gt;&gt; 24) &amp; 0xFF) == 10)
215             || ((((address &gt;&gt;&gt; 24) &amp; 0xFF) == 172)
216                 &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xF0) == 16))
217             || ((((address &gt;&gt;&gt; 24) &amp; 0xFF) == 192)
218                 &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) == 168));
219     }
220 
221     /**
222      * Utility routine to check if the multicast address has global scope.
223      *
224      * @return a {@code boolean} indicating if the address has
225      *         is a multicast address of global scope, false if it is not
226      *         of global scope or it is not a multicast address
227      */
228     public boolean isMCGlobal() {
229         // 224.0.1.0 to 238.255.255.255
230         byte[] byteAddr = getAddress();
231         return ((byteAddr[0] &amp; 0xff) &gt;= 224 &amp;&amp; (byteAddr[0] &amp; 0xff) &lt;= 238 ) &amp;&amp;
232             !((byteAddr[0] &amp; 0xff) == 224 &amp;&amp; byteAddr[1] == 0 &amp;&amp;
233               byteAddr[2] == 0);
234     }
235 
236     /**
237      * Utility routine to check if the multicast address has node scope.
238      *
239      * @return a {@code boolean} indicating if the address has
240      *         is a multicast address of node-local scope, false if it is not
241      *         of node-local scope or it is not a multicast address
242      */
243     public boolean isMCNodeLocal() {
244         // unless ttl == 0
245         return false;
246     }
247 
248     /**
249      * Utility routine to check if the multicast address has link scope.
250      *
251      * @return a {@code boolean} indicating if the address has
252      *         is a multicast address of link-local scope, false if it is not
253      *         of link-local scope or it is not a multicast address
254      */
255     public boolean isMCLinkLocal() {
256         // 224.0.0/24 prefix and ttl == 1
257         int address = holder().getAddress();
258         return (((address &gt;&gt;&gt; 24) &amp; 0xFF) == 224)
259             &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) == 0)
260             &amp;&amp; (((address &gt;&gt;&gt; 8) &amp; 0xFF) == 0);
261     }
262 
263     /**
264      * Utility routine to check if the multicast address has site scope.
265      *
266      * @return a {@code boolean} indicating if the address has
267      *         is a multicast address of site-local scope, false if it is not
268      *         of site-local scope or it is not a multicast address
269      */
270     public boolean isMCSiteLocal() {
271         // 239.255/16 prefix or ttl &lt; 32
272         int address = holder().getAddress();
273         return (((address &gt;&gt;&gt; 24) &amp; 0xFF) == 239)
274             &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) == 255);
275     }
276 
277     /**
278      * Utility routine to check if the multicast address has organization scope.
279      *
280      * @return a {@code boolean} indicating if the address has
281      *         is a multicast address of organization-local scope,
282      *         false if it is not of organization-local scope
283      *         or it is not a multicast address
284      */
285     public boolean isMCOrgLocal() {
286         // 239.192 - 239.195
287         int address = holder().getAddress();
288         return (((address &gt;&gt;&gt; 24) &amp; 0xFF) == 239)
289             &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) &gt;= 192)
290             &amp;&amp; (((address &gt;&gt;&gt; 16) &amp; 0xFF) &lt;= 195);
291     }
292 
293     /**
294      * Returns the raw IP address of this {@code InetAddress}
295      * object. The result is in network byte order: the highest order
296      * byte of the address is in {@code getAddress()[0]}.
297      *
298      * @return  the raw IP address of this object.
299      */
300     public byte[] getAddress() {
301         int address = holder().getAddress();
302         byte[] addr = new byte[INADDRSZ];
303 
304         addr[0] = (byte) ((address &gt;&gt;&gt; 24) &amp; 0xFF);
305         addr[1] = (byte) ((address &gt;&gt;&gt; 16) &amp; 0xFF);
306         addr[2] = (byte) ((address &gt;&gt;&gt; 8) &amp; 0xFF);
307         addr[3] = (byte) (address &amp; 0xFF);
308         return addr;
309     }
310 
<a name="6" id="anc6"></a>






311     /**
312      * Returns the IP address string in textual presentation form.
313      *
314      * @return  the raw IP address in a string format.
315      */
316     public String getHostAddress() {
317         return numericToTextFormat(getAddress());
318     }
319 
320     /**
321      * Returns a hashcode for this IP address.
322      *
323      * @return  a hash code value for this IP address.
324      */
325     public int hashCode() {
326         return holder().getAddress();
327     }
328 
329     /**
330      * Compares this object against the specified object.
331      * The result is {@code true} if and only if the argument is
332      * not {@code null} and it represents the same IP address as
333      * this object.
334      * &lt;p&gt;
335      * Two instances of {@code InetAddress} represent the same IP
336      * address if the length of the byte arrays returned by
337      * {@code getAddress} is the same for both, and each of the
338      * array components is the same for the byte arrays.
339      *
340      * @param   obj   the object to compare against.
341      * @return  {@code true} if the objects are the same;
342      *          {@code false} otherwise.
343      * @see     java.net.InetAddress#getAddress()
344      */
345     public boolean equals(Object obj) {
346         return (obj != null) &amp;&amp; (obj instanceof Inet4Address) &amp;&amp;
347             (((InetAddress)obj).holder().getAddress() == holder().getAddress());
348     }
349 
350     // Utilities
351 
352     /**
353      * Converts IPv4 binary address into a string suitable for presentation.
354      *
355      * @param src a byte array representing an IPv4 numeric address
356      * @return a String representing the IPv4 address in
357      *         textual representation format
358      */
359     static String numericToTextFormat(byte[] src)
360     {
361         return (src[0] &amp; 0xff) + &quot;.&quot; + (src[1] &amp; 0xff) + &quot;.&quot; + (src[2] &amp; 0xff) + &quot;.&quot; + (src[3] &amp; 0xff);
362     }
363 
364     /**
365      * Perform class load-time initializations.
366      */
367     private static native void init();
368 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
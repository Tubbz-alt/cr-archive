<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassFormatError.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassNotFoundException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-added">+  * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,24 ***</span>
  import java.security.CodeSource;
  import java.security.PrivilegedAction;
  import java.security.ProtectionDomain;
  import java.security.cert.Certificate;
  import java.util.ArrayDeque;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.Deque;
  import java.util.Enumeration;
  import java.util.HashMap;
  import java.util.HashSet;
<span class="line-removed">- import java.util.Hashtable;</span>
  import java.util.Map;
  import java.util.NoSuchElementException;
  import java.util.Objects;
  import java.util.Set;
  import java.util.Spliterator;
  import java.util.Spliterators;
<span class="line-removed">- import java.util.Vector;</span>
  import java.util.WeakHashMap;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.Supplier;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
<span class="line-new-header">--- 38,23 ---</span>
  import java.security.CodeSource;
  import java.security.PrivilegedAction;
  import java.security.ProtectionDomain;
  import java.security.cert.Certificate;
  import java.util.ArrayDeque;
<span class="line-added">+ import java.util.ArrayList;</span>
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.Deque;
  import java.util.Enumeration;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Map;
  import java.util.NoSuchElementException;
  import java.util.Objects;
  import java.util.Set;
  import java.util.Spliterator;
  import java.util.Spliterators;
  import java.util.WeakHashMap;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.Supplier;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,10 ***</span>
<span class="line-new-header">--- 66,11 ---</span>
  import jdk.internal.misc.Unsafe;
  import jdk.internal.misc.VM;
  import jdk.internal.ref.CleanerFactory;
  import jdk.internal.reflect.CallerSensitive;
  import jdk.internal.reflect.Reflection;
<span class="line-added">+ import jdk.internal.util.StaticProperty;</span>
  import sun.reflect.misc.ReflectUtil;
  import sun.security.util.SecurityConstants;
  
  /**
   * A class loader is an object that is responsible for loading classes. The
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,11 ***</span>
   * hierarchical, class loaders need to be parallel capable, otherwise class
   * loading can lead to deadlocks because the loader lock is held for the
   * duration of the class loading process (see {@link #loadClass
   * loadClass} methods).
   *
<span class="line-modified">!  * &lt;h3&gt; &lt;a id=&quot;builtinLoaders&quot;&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * The Java run-time has the following built-in class loaders:
   *
   * &lt;ul&gt;
   * &lt;li&gt;&lt;p&gt;Bootstrap class loader.
<span class="line-new-header">--- 125,11 ---</span>
   * hierarchical, class loaders need to be parallel capable, otherwise class
   * loading can lead to deadlocks because the loader lock is held for the
   * duration of the class loading process (see {@link #loadClass
   * loadClass} methods).
   *
<span class="line-modified">!  * &lt;h2&gt; &lt;a id=&quot;builtinLoaders&quot;&gt;Run-time Built-in Class Loaders&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * The Java run-time has the following built-in class loaders:
   *
   * &lt;ul&gt;
   * &lt;li&gt;&lt;p&gt;Bootstrap class loader.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,11 ***</span>
   * &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
   * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
   * or a fully qualified name as defined by
   * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
   *
<span class="line-modified">!  * @jls 6.7  Fully Qualified Names</span>
   * @jls 13.1 The Form of a Binary
   * @see      #resolveClass(Class)
   * @since 1.0
   * @revised 9
   * @spec JPMS
<span class="line-new-header">--- 221,11 ---</span>
   * &lt;p&gt; Any package name provided as a {@code String} parameter to methods in
   * {@code ClassLoader} must be either the empty string (denoting an unnamed package)
   * or a fully qualified name as defined by
   * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
   *
<span class="line-modified">!  * @jls 6.7 Fully Qualified Names</span>
   * @jls 13.1 The Form of a Binary
   * @see      #resolveClass(Class)
   * @since 1.0
   * @revised 9
   * @spec JPMS
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,28 ***</span>
      // Note: VM also uses this field to decide if the current class loader
      // is parallel capable and the appropriate lock object for class loading.
      private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
  
      // Maps packages to certs
<span class="line-modified">!     private final Map &lt;String, Certificate[]&gt; package2certs;</span>
  
      // Shared among all packages with unsigned classes
      private static final Certificate[] nocerts = new Certificate[0];
  
      // The classes loaded by this class loader. The only purpose of this table
      // is to keep the classes from being GC&#39;ed until the loader is GC&#39;ed.
<span class="line-modified">!     private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();</span>
  
      // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
      // created classes.
      private final ProtectionDomain defaultDomain =
          new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
                               null, this, null);
  
      // Invoked by the VM to record every loaded class with this loader.
      void addClass(Class&lt;?&gt; c) {
<span class="line-modified">!         classes.addElement(c);</span>
      }
  
      // The packages defined in this class loader.  Each package name is
      // mapped to its corresponding NamedPackage object.
      //
<span class="line-new-header">--- 301,30 ---</span>
      // Note: VM also uses this field to decide if the current class loader
      // is parallel capable and the appropriate lock object for class loading.
      private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;
  
      // Maps packages to certs
<span class="line-modified">!     private final ConcurrentHashMap&lt;String, Certificate[]&gt; package2certs;</span>
  
      // Shared among all packages with unsigned classes
      private static final Certificate[] nocerts = new Certificate[0];
  
      // The classes loaded by this class loader. The only purpose of this table
      // is to keep the classes from being GC&#39;ed until the loader is GC&#39;ed.
<span class="line-modified">!     private final ArrayList&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();</span>
  
      // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
      // created classes.
      private final ProtectionDomain defaultDomain =
          new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
                               null, this, null);
  
      // Invoked by the VM to record every loaded class with this loader.
      void addClass(Class&lt;?&gt; c) {
<span class="line-modified">!         synchronized (classes) {</span>
<span class="line-added">+             classes.add(c);</span>
<span class="line-added">+         }</span>
      }
  
      // The packages defined in this class loader.  Each package name is
      // mapped to its corresponding NamedPackage object.
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,18 ***</span>
          this.name = name;
          this.parent = parent;
          this.unnamedModule = new Module(this);
          if (ParallelLoaders.isRegistered(this.getClass())) {
              parallelLockMap = new ConcurrentHashMap&lt;&gt;();
<span class="line-removed">-             package2certs = new ConcurrentHashMap&lt;&gt;();</span>
              assertionLock = new Object();
          } else {
              // no finer-grained lock; lock on the classloader instance
              parallelLockMap = null;
<span class="line-removed">-             package2certs = new Hashtable&lt;&gt;();</span>
              assertionLock = this;
          }
          this.nameAndId = nameAndId(this);
      }
  
      /**
       * If the defining loader has a name explicitly set then
<span class="line-new-header">--- 378,17 ---</span>
          this.name = name;
          this.parent = parent;
          this.unnamedModule = new Module(this);
          if (ParallelLoaders.isRegistered(this.getClass())) {
              parallelLockMap = new ConcurrentHashMap&lt;&gt;();
              assertionLock = new Object();
          } else {
              // no finer-grained lock; lock on the classloader instance
              parallelLockMap = null;
              assertionLock = this;
          }
<span class="line-added">+         this.package2certs = new ConcurrentHashMap&lt;&gt;();</span>
          this.nameAndId = nameAndId(this);
      }
  
      /**
       * If the defining loader has a name explicitly set then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,14 ***</span>
       * classes are visible.
       *
       * @param  parent
       *         The parent class loader
       *
<span class="line-modified">!      * @throws  SecurityException</span>
<span class="line-modified">!      *          If a security manager exists and its</span>
<span class="line-modified">!      *          {@code checkCreateClassLoader} method doesn&#39;t allow creation</span>
<span class="line-modified">!      *          of a new class loader.</span>
       *
       * @since  1.2
       */
      protected ClassLoader(ClassLoader parent) {
          this(checkCreateClassLoader(), null, parent);
<span class="line-new-header">--- 445,14 ---</span>
       * classes are visible.
       *
       * @param  parent
       *         The parent class loader
       *
<span class="line-modified">!      * @throws SecurityException</span>
<span class="line-modified">!      *         If a security manager exists and its</span>
<span class="line-modified">!      *         {@code checkCreateClassLoader} method doesn&#39;t allow creation</span>
<span class="line-modified">!      *         of a new class loader.</span>
       *
       * @since  1.2
       */
      protected ClassLoader(ClassLoader parent) {
          this(checkCreateClassLoader(), null, parent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,12 ***</span>
       * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
       * machine to resolve class references.  Invoking this method is equivalent
       * to invoking {@link #loadClass(String, boolean) loadClass(name,
       * false)}.
       *
<span class="line-modified">!      * @param  name</span>
<span class="line-modified">!      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class was not found
<span class="line-new-header">--- 509,12 ---</span>
       * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
       * machine to resolve class references.  Invoking this method is equivalent
       * to invoking {@link #loadClass(String, boolean) loadClass(name,
       * false)}.
       *
<span class="line-modified">!      * @param   name</span>
<span class="line-modified">!      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class was not found
</pre>
<hr />
<pre>
<span class="line-old-header">*** 549,15 ***</span>
       *
       * &lt;p&gt; Unless overridden, this method synchronizes on the result of
       * {@link #getClassLoadingLock getClassLoadingLock} method
       * during the entire class loading process.
       *
<span class="line-modified">!      * @param  name</span>
<span class="line-modified">!      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
<span class="line-modified">!      * @param  resolve</span>
<span class="line-modified">!      *         If {@code true} then resolve the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class could not be found
<span class="line-new-header">--- 551,15 ---</span>
       *
       * &lt;p&gt; Unless overridden, this method synchronizes on the result of
       * {@link #getClassLoadingLock getClassLoadingLock} method
       * during the entire class loading process.
       *
<span class="line-modified">!      * @param   name</span>
<span class="line-modified">!      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
<span class="line-modified">!      * @param   resolve</span>
<span class="line-modified">!      *          If {@code true} then resolve the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class could not be found
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,12 ***</span>
       * the {@link #loadClass loadClass} method after checking the
       * parent class loader for the requested class.
       *
       * @implSpec The default implementation throws {@code ClassNotFoundException}.
       *
<span class="line-modified">!      * @param  name</span>
<span class="line-modified">!      *         The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class could not be found
<span class="line-new-header">--- 704,12 ---</span>
       * the {@link #loadClass loadClass} method after checking the
       * parent class loader for the requested class.
       *
       * @implSpec The default implementation throws {@code ClassNotFoundException}.
       *
<span class="line-modified">!      * @param   name</span>
<span class="line-modified">!      *          The &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class</span>
       *
       * @return  The resulting {@code Class} object
       *
       * @throws  ClassNotFoundException
       *          If the class could not be found
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1132,22 ***</span>
  
          Certificate[] certs = null;
          if (cs != null) {
              certs = cs.getCertificates();
          }
<span class="line-modified">!         Certificate[] pcerts = null;</span>
<span class="line-modified">!         if (parallelLockMap == null) {</span>
<span class="line-removed">-             synchronized (this) {</span>
<span class="line-removed">-                 pcerts = package2certs.get(pname);</span>
<span class="line-removed">-                 if (pcerts == null) {</span>
<span class="line-removed">-                     package2certs.put(pname, (certs == null? nocerts:certs));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             pcerts = ((ConcurrentHashMap&lt;String, Certificate[]&gt;)package2certs).</span>
<span class="line-removed">-                 putIfAbsent(pname, (certs == null? nocerts:certs));</span>
<span class="line-removed">-         }</span>
          if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {
              throw new SecurityException(&quot;class \&quot;&quot; + name
                  + &quot;\&quot;&#39;s signer information does not match signer information&quot;
                  + &quot; of other classes in the same package&quot;);
          }
<span class="line-new-header">--- 1134,12 ---</span>
  
          Certificate[] certs = null;
          if (cs != null) {
              certs = cs.getCertificates();
          }
<span class="line-modified">!         certs = certs == null ? nocerts : certs;</span>
<span class="line-modified">!         Certificate[] pcerts = package2certs.putIfAbsent(pname, certs);</span>
          if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {
              throw new SecurityException(&quot;class \&quot;&quot; + name
                  + &quot;\&quot;&#39;s signer information does not match signer information&quot;
                  + &quot; of other classes in the same package&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1155,17 ***</span>
  
      /**
       * check to make sure the certs for the new class (certs) are the same as
       * the certs for the first class inserted in the package (pcerts)
       */
<span class="line-modified">!     private boolean compareCerts(Certificate[] pcerts,</span>
<span class="line-modified">!                                  Certificate[] certs)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         // certs can be null, indicating no certs.</span>
<span class="line-removed">-         if ((certs == null) || (certs.length == 0)) {</span>
              return pcerts.length == 0;
<span class="line-removed">-         }</span>
  
          // the length must be the same at this point
          if (certs.length != pcerts.length)
              return false;
  
<span class="line-new-header">--- 1147,14 ---</span>
  
      /**
       * check to make sure the certs for the new class (certs) are the same as
       * the certs for the first class inserted in the package (pcerts)
       */
<span class="line-modified">!     private boolean compareCerts(Certificate[] pcerts, Certificate[] certs) {</span>
<span class="line-modified">!         // empty array fast-path</span>
<span class="line-modified">!         if (certs.length == 0)</span>
              return pcerts.length == 0;
  
          // the length must be the same at this point
          if (certs.length != pcerts.length)
              return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1891,10 ***</span>
<span class="line-new-header">--- 1880,20 ---</span>
       * If named, the built-in system class loader will have no class path and
       * will search for classes and resources using the application module path;
       * otherwise, if unnamed, it will set the class path to the current
       * working directory.
       *
<span class="line-added">+      * &lt;p&gt; JAR files on the class path may contain a {@code Class-Path} manifest</span>
<span class="line-added">+      * attribute to specify dependent JAR files to be included in the class path.</span>
<span class="line-added">+      * {@code Class-Path} entries must meet certain conditions for validity (see</span>
<span class="line-added">+      * the &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;</span>
<span class="line-added">+      * JAR File Specification&lt;/a&gt; for details).  Invalid {@code Class-Path}</span>
<span class="line-added">+      * entries are ignored.  For debugging purposes, ignored entries can be</span>
<span class="line-added">+      * printed to the console if the</span>
<span class="line-added">+      * {@systemProperty jdk.net.URLClassPath.showIgnoredClassPathEntries} system</span>
<span class="line-added">+      * property is set to {@code true}.</span>
<span class="line-added">+      *</span>
       * @return  The system {@code ClassLoader}
       *
       * @throws  SecurityException
       *          If a security manager is present, and the caller&#39;s class loader
       *          is not {@code null} and is not the same as or an ancestor of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2182,11 ***</span>
       *
       * @since  1.2
       * @revised 9
       * @spec JPMS
       *
<span class="line-modified">!      * @jvms 5.3 Run-time package</span>
       * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
       *      The JAR File Specification: Package Sealing&lt;/a&gt;
       */
      protected Package definePackage(String name, String specTitle,
                                      String specVersion, String specVendor,
<span class="line-new-header">--- 2181,11 ---</span>
       *
       * @since  1.2
       * @revised 9
       * @spec JPMS
       *
<span class="line-modified">!      * @jvms 5.3 Creation and Loading</span>
       * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
       *      The JAR File Specification: Package Sealing&lt;/a&gt;
       */
      protected Package definePackage(String name, String specTitle,
                                      String specVersion, String specVendor,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2216,11 ***</span>
       *         by this class loader, or {@code null} if not found
       *
       * @throws  NullPointerException
       *          if {@code name} is {@code null}.
       *
<span class="line-modified">!      * @jvms 5.3 Run-time package</span>
       *
       * @since  9
       * @spec JPMS
       */
      public final Package getDefinedPackage(String name) {
<span class="line-new-header">--- 2215,11 ---</span>
       *         by this class loader, or {@code null} if not found
       *
       * @throws  NullPointerException
       *          if {@code name} is {@code null}.
       *
<span class="line-modified">!      * @jvms 5.3 Creation and Loading</span>
       *
       * @since  9
       * @spec JPMS
       */
      public final Package getDefinedPackage(String name) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2243,11 ***</span>
       *
       * @return The array of {@code Package} objects that have been defined by
       *         this class loader; or an zero length array if no package has been
       *         defined by this class loader.
       *
<span class="line-modified">!      * @jvms 5.3 Run-time package</span>
       *
       * @since  9
       * @spec JPMS
       */
      public final Package[] getDefinedPackages() {
<span class="line-new-header">--- 2242,11 ---</span>
       *
       * @return The array of {@code Package} objects that have been defined by
       *         this class loader; or an zero length array if no package has been
       *         defined by this class loader.
       *
<span class="line-modified">!      * @jvms 5.3 Creation and Loading</span>
       *
       * @since  9
       * @spec JPMS
       */
      public final Package[] getDefinedPackages() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2461,12 ***</span>
                   * When a library is being loaded, JNI_OnLoad function can cause
                   * another loadLibrary invocation that should succeed.
                   *
                   * We use a static stack to hold the list of libraries we are
                   * loading because this can happen only when called by the
<span class="line-modified">!                  * same thread because Runtime.load and Runtime.loadLibrary</span>
<span class="line-removed">-                  * are synchronous.</span>
                   *
                   * If there is a pending load operation for the library, we
                   * immediately return success; otherwise, we raise
                   * UnsatisfiedLinkError.
                   */
<span class="line-new-header">--- 2460,11 ---</span>
                   * When a library is being loaded, JNI_OnLoad function can cause
                   * another loadLibrary invocation that should succeed.
                   *
                   * We use a static stack to hold the list of libraries we are
                   * loading because this can happen only when called by the
<span class="line-modified">!                  * same thread because this block is synchronous.</span>
                   *
                   * If there is a pending load operation for the library, we
                   * immediately return success; otherwise, we raise
                   * UnsatisfiedLinkError.
                   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2547,74 ***</span>
          // JNI FindClass expects the caller class if invoked from JNI_OnLoad
          // and JNI_OnUnload is NativeLibrary class
          static native void unload(String name, boolean isBuiltin, long handle);
      }
  
<span class="line-modified">!     // The paths searched for libraries</span>
<span class="line-modified">!     private static String usr_paths[];</span>
<span class="line-modified">!     private static String sys_paths[];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static String[] initializePath(String propName) {</span>
<span class="line-modified">!         String ldPath = System.getProperty(propName, &quot;&quot;);</span>
<span class="line-modified">!         int ldLen = ldPath.length();</span>
<span class="line-modified">!         char ps = File.pathSeparatorChar;</span>
<span class="line-modified">!         int psCount = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (ClassLoaderHelper.allowsQuotedPathElements &amp;&amp;</span>
<span class="line-removed">-             ldPath.indexOf(&#39;\&quot;&#39;) &gt;= 0) {</span>
<span class="line-removed">-             // First, remove quotes put around quoted parts of paths.</span>
<span class="line-removed">-             // Second, use a quotation mark as a new path separator.</span>
<span class="line-removed">-             // This will preserve any quoted old path separators.</span>
<span class="line-removed">-             char[] buf = new char[ldLen];</span>
<span class="line-removed">-             int bufLen = 0;</span>
<span class="line-removed">-             for (int i = 0; i &lt; ldLen; ++i) {</span>
<span class="line-removed">-                 char ch = ldPath.charAt(i);</span>
<span class="line-removed">-                 if (ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed">-                     while (++i &lt; ldLen &amp;&amp;</span>
<span class="line-removed">-                         (ch = ldPath.charAt(i)) != &#39;\&quot;&#39;) {</span>
<span class="line-removed">-                         buf[bufLen++] = ch;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     if (ch == ps) {</span>
<span class="line-removed">-                         psCount++;</span>
<span class="line-removed">-                         ch = &#39;\&quot;&#39;;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     buf[bufLen++] = ch;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             ldPath = new String(buf, 0, bufLen);</span>
<span class="line-removed">-             ldLen = bufLen;</span>
<span class="line-removed">-             ps = &#39;\&quot;&#39;;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             for (int i = ldPath.indexOf(ps); i &gt;= 0;</span>
<span class="line-removed">-                  i = ldPath.indexOf(ps, i + 1)) {</span>
<span class="line-removed">-                 psCount++;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         String[] paths = new String[psCount + 1];</span>
<span class="line-removed">-         int pathStart = 0;</span>
<span class="line-removed">-         for (int j = 0; j &lt; psCount; ++j) {</span>
<span class="line-removed">-             int pathEnd = ldPath.indexOf(ps, pathStart);</span>
<span class="line-removed">-             paths[j] = (pathStart &lt; pathEnd) ?</span>
<span class="line-removed">-                 ldPath.substring(pathStart, pathEnd) : &quot;.&quot;;</span>
<span class="line-removed">-             pathStart = pathEnd + 1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         paths[psCount] = (pathStart &lt; ldLen) ?</span>
<span class="line-removed">-             ldPath.substring(pathStart, ldLen) : &quot;.&quot;;</span>
<span class="line-removed">-         return paths;</span>
      }
  
      // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
      static void loadLibrary(Class&lt;?&gt; fromClass, String name,
                              boolean isAbsolute) {
          ClassLoader loader =
              (fromClass == null) ? null : fromClass.getClassLoader();
<span class="line-modified">!         if (sys_paths == null) {</span>
<span class="line-removed">-             usr_paths = initializePath(&quot;java.library.path&quot;);</span>
<span class="line-removed">-             sys_paths = initializePath(&quot;sun.boot.library.path&quot;);</span>
<span class="line-removed">-         }</span>
          if (isAbsolute) {
              if (loadLibrary0(fromClass, new File(name))) {
                  return;
              }
              throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);
<span class="line-new-header">--- 2545,29 ---</span>
          // JNI FindClass expects the caller class if invoked from JNI_OnLoad
          // and JNI_OnUnload is NativeLibrary class
          static native void unload(String name, boolean isBuiltin, long handle);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Holds system and user library paths derived from the</span>
<span class="line-modified">!      * {@code java.library.path} and {@code sun.boot.library.path} system</span>
<span class="line-modified">!      * properties. The system properties are eagerly read at bootstrap, then</span>
<span class="line-modified">!      * lazily parsed on first use to avoid initialization ordering issues.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static class LibraryPaths {</span>
<span class="line-modified">!         static final String[] USER =</span>
<span class="line-modified">!                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());</span>
<span class="line-modified">!         static final String[] SYS =</span>
<span class="line-modified">!                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());</span>
      }
  
      // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
      static void loadLibrary(Class&lt;?&gt; fromClass, String name,
                              boolean isAbsolute) {
          ClassLoader loader =
              (fromClass == null) ? null : fromClass.getClassLoader();
<span class="line-modified">! </span>
          if (isAbsolute) {
              if (loadLibrary0(fromClass, new File(name))) {
                  return;
              }
              throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2631,23 ***</span>
                      return;
                  }
                  throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);
              }
          }
<span class="line-modified">!         for (String sys_path : sys_paths) {</span>
<span class="line-modified">!             File libfile = new File(sys_path, System.mapLibraryName(name));</span>
              if (loadLibrary0(fromClass, libfile)) {
                  return;
              }
              libfile = ClassLoaderHelper.mapAlternativeName(libfile);
              if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
                  return;
              }
          }
          if (loader != null) {
<span class="line-modified">!             for (String usr_path : usr_paths) {</span>
<span class="line-modified">!                 File libfile = new File(usr_path, System.mapLibraryName(name));</span>
                  if (loadLibrary0(fromClass, libfile)) {
                      return;
                  }
                  libfile = ClassLoaderHelper.mapAlternativeName(libfile);
                  if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
<span class="line-new-header">--- 2584,23 ---</span>
                      return;
                  }
                  throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);
              }
          }
<span class="line-modified">!         for (String sysPath : LibraryPaths.SYS) {</span>
<span class="line-modified">!             File libfile = new File(sysPath, System.mapLibraryName(name));</span>
              if (loadLibrary0(fromClass, libfile)) {
                  return;
              }
              libfile = ClassLoaderHelper.mapAlternativeName(libfile);
              if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
                  return;
              }
          }
          if (loader != null) {
<span class="line-modified">!             for (String userPath : LibraryPaths.USER) {</span>
<span class="line-modified">!                 File libfile = new File(userPath, System.mapLibraryName(name));</span>
                  if (loadLibrary0(fromClass, libfile)) {
                      return;
                  }
                  libfile = ClassLoaderHelper.mapAlternativeName(libfile);
                  if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2655,11 ***</span>
                  }
              }
          }
          // Oops, it failed
          throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">!             &quot; in java.library.path: &quot; + Arrays.toString(usr_paths));</span>
      }
  
      private static native String findBuiltinLib(String name);
  
      private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
<span class="line-new-header">--- 2608,11 ---</span>
                  }
              }
          }
          // Oops, it failed
          throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">!             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));</span>
      }
  
      private static native String findBuiltinLib(String name);
  
      private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
</pre>
<center><a href="ClassFormatError.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassNotFoundException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
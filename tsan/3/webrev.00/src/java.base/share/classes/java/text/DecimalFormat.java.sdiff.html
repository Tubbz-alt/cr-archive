<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/DecimalFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DateFormatSymbols.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DecimalFormatSymbols.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/DecimalFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.IOException;
  42 import java.io.InvalidObjectException;
  43 import java.io.ObjectInputStream;
  44 import java.math.BigDecimal;
  45 import java.math.BigInteger;
  46 import java.math.RoundingMode;
  47 import java.text.spi.NumberFormatProvider;
  48 import java.util.ArrayList;
  49 import java.util.Currency;
  50 import java.util.Locale;
  51 import java.util.concurrent.atomic.AtomicInteger;
  52 import java.util.concurrent.atomic.AtomicLong;
  53 import sun.util.locale.provider.LocaleProviderAdapter;
  54 import sun.util.locale.provider.ResourceBundleBasedAdapter;
  55 
  56 /**
<span class="line-modified">  57  * &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of</span>
<span class="line-modified">  58  * &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of</span>
  59  * features designed to make it possible to parse and format numbers in any
  60  * locale, including support for Western, Arabic, and Indic digits.  It also
  61  * supports different kinds of numbers, including integers (123), fixed-point
  62  * numbers (123.4), scientific notation (1.23E4), percentages (12%), and
  63  * currency amounts ($123).  All of these can be localized.
  64  *
<span class="line-modified">  65  * &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the</span>
<span class="line-modified">  66  * default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;&#39;s factory methods, such</span>
<span class="line-modified">  67  * as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the</span>
<span class="line-modified">  68  * &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the</span>
<span class="line-modified">  69  * &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than</span>
<span class="line-modified">  70  * &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do</span>
  71  * something like this:
  72  *
  73  * &lt;blockquote&gt;&lt;pre&gt;
  74  * NumberFormat f = NumberFormat.getInstance(loc);
  75  * if (f instanceof DecimalFormat) {
  76  *     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
  77  * }
  78  * &lt;/pre&gt;&lt;/blockquote&gt;
  79  *
<span class="line-modified">  80  * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of</span>
  81  * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
<span class="line-modified">  82  * &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The</span>
<span class="line-modified">  83  * symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using</span>
<span class="line-modified">  84  * the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are</span>
<span class="line-modified">  85  * read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.</span>
  86  *
<span class="line-modified">  87  * &lt;h3&gt;Patterns&lt;/h3&gt;</span>
  88  *
<span class="line-modified">  89  * &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:</span>
  90  * &lt;blockquote&gt;&lt;pre&gt;
  91  * &lt;i&gt;Pattern:&lt;/i&gt;
  92  *         &lt;i&gt;PositivePattern&lt;/i&gt;
  93  *         &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
  94  * &lt;i&gt;PositivePattern:&lt;/i&gt;
  95  *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
  96  * &lt;i&gt;NegativePattern:&lt;/i&gt;
  97  *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
  98  * &lt;i&gt;Prefix:&lt;/i&gt;
  99  *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 100  * &lt;i&gt;Suffix:&lt;/i&gt;
 101  *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 102  * &lt;i&gt;Number:&lt;/i&gt;
 103  *         &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 104  *         &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 105  * &lt;i&gt;Integer:&lt;/i&gt;
 106  *         &lt;i&gt;MinimumInteger&lt;/i&gt;
 107  *         #
 108  *         # &lt;i&gt;Integer&lt;/i&gt;
 109  *         # , &lt;i&gt;Integer&lt;/i&gt;
 110  * &lt;i&gt;MinimumInteger:&lt;/i&gt;
 111  *         0
 112  *         0 &lt;i&gt;MinimumInteger&lt;/i&gt;
 113  *         0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
 114  * &lt;i&gt;Fraction:&lt;/i&gt;
 115  *         &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 116  * &lt;i&gt;MinimumFraction:&lt;/i&gt;
 117  *         0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 118  * &lt;i&gt;OptionalFraction:&lt;/i&gt;
 119  *         # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 120  * &lt;i&gt;Exponent:&lt;/i&gt;
 121  *         E &lt;i&gt;MinimumExponent&lt;/i&gt;
 122  * &lt;i&gt;MinimumExponent:&lt;/i&gt;
 123  *         0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 124  * &lt;/pre&gt;&lt;/blockquote&gt;
 125  *
<span class="line-modified"> 126  * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative</span>
<span class="line-modified"> 127  * subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each</span>
 128  * subpattern has a prefix, numeric part, and suffix. The negative subpattern
 129  * is optional; if absent, then the positive subpattern prefixed with the
<span class="line-modified"> 130  * localized minus sign (&lt;code&gt;&#39;-&#39;&lt;/code&gt; in most locales) is used as the</span>
<span class="line-modified"> 131  * negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to</span>
<span class="line-modified"> 132  * &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it</span>
 133  * serves only to specify the negative prefix and suffix; the number of digits,
 134  * minimal digits, and other characteristics are all the same as the positive
<span class="line-modified"> 135  * pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely</span>
<span class="line-modified"> 136  * the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.</span>
 137  *
 138  * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
<span class="line-modified"> 139  * thousands separators, decimal separators, etc. may be set to arbitrary</span>
 140  * values, and they will appear properly during formatting.  However, care must
 141  * be taken that the symbols and strings do not conflict, or parsing will be
 142  * unreliable.  For example, either the positive and negative prefixes or the
<span class="line-modified"> 143  * suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able</span>
 144  * to distinguish positive from negative values.  (If they are identical, then
<span class="line-modified"> 145  * &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was</span>
<span class="line-modified"> 146  * specified.)  Another example is that the decimal separator and thousands</span>
 147  * separator should be distinct characters, or parsing will be impossible.
 148  *
 149  * &lt;p&gt;The grouping separator is commonly used for thousands, but in some
 150  * countries it separates ten-thousands. The grouping size is a constant number
 151  * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
 152  * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the
 153  * interval between the last one and the end of the integer is the one that is
<span class="line-modified"> 154  * used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==</span>
<span class="line-modified"> 155  * &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.</span>
 156  *
<span class="line-modified"> 157  * &lt;h4&gt;&lt;a id=&quot;special_pattern_character&quot;&gt;Special Pattern Characters&lt;/a&gt;&lt;/h4&gt;</span>
 158  *
 159  * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 160  * parsing and output unchanged during formatting.  Special characters, on the
 161  * other hand, stand for other characters, strings, or classes of characters.
 162  * They must be quoted, unless noted otherwise, if they are to appear in the
 163  * prefix or suffix as literals.
 164  *
 165  * &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
 166  * patterns use the corresponding characters taken from this formatter&#39;s
<span class="line-modified"> 167  * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose</span>
 168  * their special status.  Two exceptions are the currency sign and quote, which
 169  * are not localized.
 170  *
 171  * &lt;blockquote&gt;
 172  * &lt;table class=&quot;striped&quot;&gt;
 173  * &lt;caption style=&quot;display:none&quot;&gt;Chart showing symbol, location, localized, and meaning.&lt;/caption&gt;
 174  * &lt;thead&gt;
 175  *     &lt;tr&gt;
 176  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Symbol
 177  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Location
 178  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Localized?
 179  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Meaning
 180  * &lt;/thead&gt;
 181  * &lt;tbody&gt;
 182  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 183  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;0&lt;/code&gt;</span>
 184  *          &lt;td&gt;Number
 185  *          &lt;td&gt;Yes
 186  *          &lt;td&gt;Digit
 187  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 188  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;#&lt;/code&gt;</span>
 189  *          &lt;td&gt;Number
 190  *          &lt;td&gt;Yes
 191  *          &lt;td&gt;Digit, zero shows as absent
 192  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 193  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;.&lt;/code&gt;</span>
 194  *          &lt;td&gt;Number
 195  *          &lt;td&gt;Yes
 196  *          &lt;td&gt;Decimal separator or monetary decimal separator
 197  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 198  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;-&lt;/code&gt;</span>
 199  *          &lt;td&gt;Number
 200  *          &lt;td&gt;Yes
 201  *          &lt;td&gt;Minus sign
 202  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 203  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;,&lt;/code&gt;</span>
 204  *          &lt;td&gt;Number
 205  *          &lt;td&gt;Yes
<span class="line-modified"> 206  *          &lt;td&gt;Grouping separator</span>
 207  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 208  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;E&lt;/code&gt;</span>
 209  *          &lt;td&gt;Number
 210  *          &lt;td&gt;Yes
 211  *          &lt;td&gt;Separates mantissa and exponent in scientific notation.
 212  *              &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
 213  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 214  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;;&lt;/code&gt;</span>
 215  *          &lt;td&gt;Subpattern boundary
 216  *          &lt;td&gt;Yes
 217  *          &lt;td&gt;Separates positive and negative subpatterns
 218  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 219  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;%&lt;/code&gt;</span>
 220  *          &lt;td&gt;Prefix or suffix
 221  *          &lt;td&gt;Yes
 222  *          &lt;td&gt;Multiply by 100 and show as percentage
 223  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 224  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;</span>
 225  *          &lt;td&gt;Prefix or suffix
 226  *          &lt;td&gt;Yes
 227  *          &lt;td&gt;Multiply by 1000 and show as per mille value
 228  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 229  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)</span>
 230  *          &lt;td&gt;Prefix or suffix
 231  *          &lt;td&gt;No
 232  *          &lt;td&gt;Currency sign, replaced by currency symbol.  If
 233  *              doubled, replaced by international currency symbol.
<span class="line-modified"> 234  *              If present in a pattern, the monetary decimal separator</span>
<span class="line-modified"> 235  *              is used instead of the decimal separator.</span>
 236  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 237  *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&#39;&lt;/code&gt;</span>
 238  *          &lt;td&gt;Prefix or suffix
 239  *          &lt;td&gt;No
 240  *          &lt;td&gt;Used to quote special characters in a prefix or suffix,
<span class="line-modified"> 241  *              for example, &lt;code&gt;&quot;&#39;#&#39;#&quot;&lt;/code&gt; formats 123 to</span>
<span class="line-modified"> 242  *              &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote</span>
<span class="line-modified"> 243  *              itself, use two in a row: &lt;code&gt;&quot;# o&#39;&#39;clock&quot;&lt;/code&gt;.</span>
 244  * &lt;/tbody&gt;
 245  * &lt;/table&gt;
 246  * &lt;/blockquote&gt;
 247  *
<span class="line-modified"> 248  * &lt;h4&gt;Scientific Notation&lt;/h4&gt;</span>
 249  *
 250  * &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
 251  * and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
 252  * mantissa is often in the range 1.0 &amp;le; x {@literal &lt;} 10.0, but it need not
 253  * be.
<span class="line-modified"> 254  * &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific</span>
 255  * notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
 256  * that creates a scientific notation format.  In a pattern, the exponent
 257  * character immediately followed by one or more digit characters indicates
<span class="line-modified"> 258  * scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number</span>
<span class="line-modified"> 259  * 1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.</span>
 260  *
 261  * &lt;ul&gt;
 262  * &lt;li&gt;The number of digit characters after the exponent character gives the
 263  * minimum exponent digit count.  There is no maximum.  Negative exponents are
 264  * formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
<span class="line-modified"> 265  * from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.</span>
 266  *
 267  * &lt;li&gt;The minimum and maximum number of integer digits are interpreted
 268  * together:
 269  *
 270  * &lt;ul&gt;
 271  * &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
 272  * and greater than 1, it forces the exponent to be a multiple of the maximum
 273  * number of integer digits, and the minimum number of integer digits to be
 274  * interpreted as 1.  The most common use of this is to generate
 275  * &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
<span class="line-modified"> 276  * e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345</span>
<span class="line-modified"> 277  * formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to</span>
<span class="line-modified"> 278  * &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</span>
 279  *
 280  * &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
<span class="line-modified"> 281  * exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields</span>
<span class="line-modified"> 282  * &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.</span>
 283  * &lt;/ul&gt;
 284  *
 285  * &lt;li&gt;The number of significant digits in the mantissa is the sum of the
 286  * &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
 287  * unaffected by the maximum integer digits.  For example, 12345 formatted with
<span class="line-modified"> 288  * &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set</span>
 289  * the significant digits count to zero.  The number of significant digits
 290  * does not affect parsing.
 291  *
 292  * &lt;li&gt;Exponential patterns may not contain grouping separators.
 293  * &lt;/ul&gt;
 294  *
<span class="line-modified"> 295  * &lt;h4&gt;Rounding&lt;/h4&gt;</span>
 296  *
<span class="line-modified"> 297  * &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in</span>
 298  * {@link java.math.RoundingMode} for formatting.  By default, it uses
 299  * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
 300  *
<span class="line-modified"> 301  * &lt;h4&gt;Digits&lt;/h4&gt;</span>
 302  *
<span class="line-modified"> 303  * For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive</span>
 304  * characters starting with the localized zero digit defined in the
<span class="line-modified"> 305  * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these</span>
 306  * digits as well as all Unicode decimal digits, as defined by
 307  * {@link Character#digit Character.digit}, are recognized.
 308  *
 309  * &lt;h4&gt;Special Values&lt;/h4&gt;
 310  *
<span class="line-modified"> 311  * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character</span>
<span class="line-modified"> 312  * &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the</span>
<span class="line-modified"> 313  * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which</span>
 314  * the prefixes and suffixes are not used.
 315  *
 316  * &lt;p&gt;Infinity is formatted as a string, which typically has a single character
<span class="line-modified"> 317  * &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes</span>
 318  * applied.  The infinity string is determined by the
<span class="line-modified"> 319  * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.</span>
 320  *
<span class="line-modified"> 321  * &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to</span>
 322  * &lt;ul&gt;
<span class="line-modified"> 323  * &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is</span>
 324  * true,
<span class="line-modified"> 325  * &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false</span>
<span class="line-modified"> 326  *     and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,</span>
<span class="line-modified"> 327  * &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;</span>
<span class="line-modified"> 328  * and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.</span>
 329  * &lt;/ul&gt;
 330  *
<span class="line-modified"> 331  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
 332  *
 333  * &lt;p&gt;
 334  * Decimal formats are generally not synchronized.
 335  * It is recommended to create separate format instances for each thread.
 336  * If multiple threads access a format concurrently, it must be synchronized
 337  * externally.
 338  *
<span class="line-modified"> 339  * &lt;h4&gt;Example&lt;/h4&gt;</span>
 340  *
 341  * &lt;blockquote&gt;&lt;pre&gt;{@code
 342  * &lt;strong&gt;// Print out a number using the localized number, integer, currency,
 343  * // and percent format for each locale&lt;/strong&gt;
 344  * Locale[] locales = NumberFormat.getAvailableLocales();
 345  * double myNumber = -1234.56;
 346  * NumberFormat form;
 347  * for (int j = 0; j &lt; 4; ++j) {
 348  *     System.out.println(&quot;FORMAT&quot;);
 349  *     for (int i = 0; i &lt; locales.length; ++i) {
 350  *         if (locales[i].getCountry().length() == 0) {
 351  *            continue; // Skip language-only locales
 352  *         }
 353  *         System.out.print(locales[i].getDisplayName());
 354  *         switch (j) {
 355  *         case 0:
 356  *             form = NumberFormat.getInstance(locales[i]); break;
 357  *         case 1:
 358  *             form = NumberFormat.getIntegerInstance(locales[i]); break;
 359  *         case 2:
</pre>
<hr />
<pre>
 408         String[] all = adapter.getLocaleResources(def).getNumberPatterns();
 409 
 410         // Always applyPattern after the symbols are set
 411         this.symbols = DecimalFormatSymbols.getInstance(def);
 412         applyPattern(all[0], false);
 413     }
 414 
 415 
 416     /**
 417      * Creates a DecimalFormat using the given pattern and the symbols
 418      * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 419      * This is a convenient way to obtain a
 420      * DecimalFormat when internationalization is not the main concern.
 421      * &lt;p&gt;
 422      * To obtain standard formats for a given locale, use the factory methods
 423      * on NumberFormat such as getNumberInstance. These factories will
 424      * return the most appropriate sub-class of NumberFormat for a given
 425      * locale.
 426      *
 427      * @param pattern a non-localized pattern string.
<span class="line-modified"> 428      * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</span>
<span class="line-modified"> 429      * @exception IllegalArgumentException if the given pattern is invalid.</span>
 430      * @see java.text.NumberFormat#getInstance
 431      * @see java.text.NumberFormat#getNumberInstance
 432      * @see java.text.NumberFormat#getCurrencyInstance
 433      * @see java.text.NumberFormat#getPercentInstance
 434      */
 435     public DecimalFormat(String pattern) {
 436         // Always applyPattern after the symbols are set
 437         this.symbols = DecimalFormatSymbols.getInstance(Locale.getDefault(Locale.Category.FORMAT));
 438         applyPattern(pattern, false);
 439     }
 440 
 441 
 442     /**
 443      * Creates a DecimalFormat using the given pattern and symbols.
 444      * Use this constructor when you need to completely customize the
 445      * behavior of the format.
 446      * &lt;p&gt;
 447      * To obtain standard formats for a given
 448      * locale, use the factory methods on NumberFormat such as
 449      * getInstance or getCurrencyInstance. If you need only minor adjustments
 450      * to a standard format, you can modify the format returned by
 451      * a NumberFormat factory method.
 452      *
 453      * @param pattern a non-localized pattern string
 454      * @param symbols the set of symbols to be used
<span class="line-modified"> 455      * @exception NullPointerException if any of the given arguments is null</span>
<span class="line-modified"> 456      * @exception IllegalArgumentException if the given pattern is invalid</span>
 457      * @see java.text.NumberFormat#getInstance
 458      * @see java.text.NumberFormat#getNumberInstance
 459      * @see java.text.NumberFormat#getCurrencyInstance
 460      * @see java.text.NumberFormat#getPercentInstance
 461      * @see java.text.DecimalFormatSymbols
 462      */
 463     public DecimalFormat (String pattern, DecimalFormatSymbols symbols) {
 464         // Always applyPattern after the symbols are set
 465         this.symbols = (DecimalFormatSymbols)symbols.clone();
 466         applyPattern(pattern, false);
 467     }
 468 
 469 
 470     // Overrides
 471     /**
 472      * Formats a number and appends the resulting text to the given string
 473      * buffer.
 474      * The number can be of any subclass of {@link java.lang.Number}.
 475      * &lt;p&gt;
 476      * This implementation uses the maximum precision permitted.
 477      * @param number     the number to format
<span class="line-modified"> 478      * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted</span>
 479      *                   text is to be appended
 480      * @param pos        keeps track on the position of the field within the
 481      *                   returned string. For example, for formatting a number
 482      *                   {@code 1234567.89} in {@code Locale.US} locale,
 483      *                   if the given {@code fieldPosition} is
 484      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 485      *                   and end index of {@code fieldPosition} will be set
 486      *                   to 0 and 9, respectively for the output string
 487      *                   {@code 1,234,567.89}.
<span class="line-modified"> 488      * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;</span>
<span class="line-modified"> 489      * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is</span>
<span class="line-modified"> 490      *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</span>
<span class="line-modified"> 491      * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified"> 492      *                   &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified"> 493      * @exception        ArithmeticException if rounding is needed with rounding</span>
 494      *                   mode being set to RoundingMode.UNNECESSARY
 495      * @see              java.text.FieldPosition
 496      */
 497     @Override
 498     public final StringBuffer format(Object number,
 499                                      StringBuffer toAppendTo,
 500                                      FieldPosition pos) {
 501         if (number instanceof Long || number instanceof Integer ||
 502                    number instanceof Short || number instanceof Byte ||
 503                    number instanceof AtomicInteger ||
 504                    number instanceof AtomicLong ||
 505                    (number instanceof BigInteger &amp;&amp;
 506                     ((BigInteger)number).bitLength () &lt; 64)) {
 507             return format(((Number)number).longValue(), toAppendTo, pos);
 508         } else if (number instanceof BigDecimal) {
 509             return format((BigDecimal)number, toAppendTo, pos);
 510         } else if (number instanceof BigInteger) {
 511             return format((BigInteger)number, toAppendTo, pos);
 512         } else if (number instanceof Number) {
 513             return format(((Number)number).doubleValue(), toAppendTo, pos);
 514         } else {
 515             throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
 516         }
 517     }
 518 
 519     /**
 520      * Formats a double to produce a string.
 521      * @param number    The double to format
 522      * @param result    where the text is to be appended
 523      * @param fieldPosition    keeps track on the position of the field within
 524      *                         the returned string. For example, for formatting
 525      *                         a number {@code 1234567.89} in {@code Locale.US}
 526      *                         locale, if the given {@code fieldPosition} is
 527      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 528      *                         and end index of {@code fieldPosition} will be set
 529      *                         to 0 and 9, respectively for the output string
 530      *                         {@code 1,234,567.89}.
<span class="line-modified"> 531      * @exception NullPointerException if {@code result} or</span>
 532      *            {@code fieldPosition} is {@code null}
<span class="line-modified"> 533      * @exception ArithmeticException if rounding is needed with rounding</span>
 534      *            mode being set to RoundingMode.UNNECESSARY
 535      * @return The formatted number string
 536      * @see java.text.FieldPosition
 537      */
 538     @Override
 539     public StringBuffer format(double number, StringBuffer result,
 540                                FieldPosition fieldPosition) {
 541         // If fieldPosition is a DontCareFieldPosition instance we can
 542         // try to go to fast-path code.
 543         boolean tryFastPath = false;
 544         if (fieldPosition == DontCareFieldPosition.INSTANCE)
 545             tryFastPath = true;
 546         else {
 547             fieldPosition.setBeginIndex(0);
 548             fieldPosition.setEndIndex(0);
 549         }
 550 
 551         if (tryFastPath) {
 552             String tempResult = fastFormat(number);
 553             if (tempResult != null) {
 554                 result.append(tempResult);
 555                 return result;
 556             }
 557         }
 558 
 559         // if fast-path could not work, we fallback to standard code.
 560         return format(number, result, fieldPosition.getFieldDelegate());
 561     }
 562 
 563     /**
 564      * Formats a double to produce a string.
 565      * @param number    The double to format
 566      * @param result    where the text is to be appended
 567      * @param delegate notified of locations of sub fields
<span class="line-modified"> 568      * @exception       ArithmeticException if rounding is needed with rounding</span>
 569      *                  mode being set to RoundingMode.UNNECESSARY
 570      * @return The formatted number string
 571      */
 572     StringBuffer format(double number, StringBuffer result,
 573                                 FieldDelegate delegate) {
 574 
 575         boolean nanOrInfinity = handleNaN(number, result, delegate);
 576         if (nanOrInfinity) {
 577             return result;
 578         }
 579 
 580         /* Detecting whether a double is negative is easy with the exception of
 581          * the value -0.0.  This is a double which has a zero mantissa (and
 582          * exponent), but a negative sign bit.  It is semantically distinct from
 583          * a zero with a positive sign bit, and this distinction is important
 584          * to certain kinds of computations.  However, it&#39;s a little tricky to
 585          * detect, since (-0.0 == 0.0) and !(-0.0 &lt; 0.0).  How then, you may
 586          * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==
 587          * -Infinity.  Proper detection of -0.0 is needed to deal with the
 588          * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.
</pre>
<hr />
<pre>
 681             digitList.set(isNegative, number, useExponentialNotation
 682                     ? maxIntDigits + maxFraDigits : maxFraDigits,
 683                     !useExponentialNotation);
 684             return subformat(result, delegate, isNegative, false,
 685                     maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 686         }
 687     }
 688 
 689     /**
 690      * Format a long to produce a string.
 691      * @param number    The long to format
 692      * @param result    where the text is to be appended
 693      * @param fieldPosition    keeps track on the position of the field within
 694      *                         the returned string. For example, for formatting
 695      *                         a number {@code 123456789} in {@code Locale.US}
 696      *                         locale, if the given {@code fieldPosition} is
 697      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 698      *                         and end index of {@code fieldPosition} will be set
 699      *                         to 0 and 11, respectively for the output string
 700      *                         {@code 123,456,789}.
<span class="line-modified"> 701      * @exception       NullPointerException if {@code result} or</span>
 702      *                  {@code fieldPosition} is {@code null}
<span class="line-modified"> 703      * @exception       ArithmeticException if rounding is needed with rounding</span>
 704      *                  mode being set to RoundingMode.UNNECESSARY
 705      * @return The formatted number string
 706      * @see java.text.FieldPosition
 707      */
 708     @Override
 709     public StringBuffer format(long number, StringBuffer result,
 710                                FieldPosition fieldPosition) {
 711         fieldPosition.setBeginIndex(0);
 712         fieldPosition.setEndIndex(0);
 713 
 714         return format(number, result, fieldPosition.getFieldDelegate());
 715     }
 716 
 717     /**
 718      * Format a long to produce a string.
 719      * @param number    The long to format
 720      * @param result    where the text is to be appended
 721      * @param delegate notified of locations of sub fields
 722      * @return The formatted number string
<span class="line-modified"> 723      * @exception        ArithmeticException if rounding is needed with rounding</span>
 724      *                   mode being set to RoundingMode.UNNECESSARY
 725      * @see java.text.FieldPosition
 726      */
 727     StringBuffer format(long number, StringBuffer result,
 728                                FieldDelegate delegate) {
 729         boolean isNegative = (number &lt; 0);
 730         if (isNegative) {
 731             number = -number;
 732         }
 733 
 734         // In general, long values always represent real finite numbers, so
 735         // we don&#39;t have to check for +/- Infinity or NaN.  However, there
 736         // is one case we have to be careful of:  The multiplier can push
 737         // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
 738         // check for this before multiplying, and if it happens we use
 739         // BigInteger instead.
 740         boolean useBigInteger = false;
 741         if (number &lt; 0) { // This can only happen if number == Long.MIN_VALUE.
 742             if (multiplier != 0) {
 743                 useBigInteger = true;
</pre>
<hr />
<pre>
 778                      useExponentialNotation ? maxIntDigits + maxFraDigits : 0);
 779 
 780             return subformat(result, delegate, isNegative, true,
 781                        maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 782         }
 783     }
 784 
 785     /**
 786      * Formats a BigDecimal to produce a string.
 787      * @param number    The BigDecimal to format
 788      * @param result    where the text is to be appended
 789      * @param fieldPosition    keeps track on the position of the field within
 790      *                         the returned string. For example, for formatting
 791      *                         a number {@code 1234567.89} in {@code Locale.US}
 792      *                         locale, if the given {@code fieldPosition} is
 793      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 794      *                         and end index of {@code fieldPosition} will be set
 795      *                         to 0 and 9, respectively for the output string
 796      *                         {@code 1,234,567.89}.
 797      * @return The formatted number string
<span class="line-modified"> 798      * @exception        ArithmeticException if rounding is needed with rounding</span>
 799      *                   mode being set to RoundingMode.UNNECESSARY
 800      * @see java.text.FieldPosition
 801      */
 802     private StringBuffer format(BigDecimal number, StringBuffer result,
 803                                 FieldPosition fieldPosition) {
 804         fieldPosition.setBeginIndex(0);
 805         fieldPosition.setEndIndex(0);
 806         return format(number, result, fieldPosition.getFieldDelegate());
 807     }
 808 
 809     /**
 810      * Formats a BigDecimal to produce a string.
 811      * @param number    The BigDecimal to format
 812      * @param result    where the text is to be appended
 813      * @param delegate notified of locations of sub fields
<span class="line-modified"> 814      * @exception        ArithmeticException if rounding is needed with rounding</span>
 815      *                   mode being set to RoundingMode.UNNECESSARY
 816      * @return The formatted number string
 817      */
 818     StringBuffer format(BigDecimal number, StringBuffer result,
 819                                 FieldDelegate delegate) {
 820         if (multiplier != 1) {
 821             number = number.multiply(getBigDecimalMultiplier());
 822         }
 823         boolean isNegative = number.signum() == -1;
 824         if (isNegative) {
 825             number = number.negate();
 826         }
 827 
 828         synchronized(digitList) {
 829             int maxIntDigits = getMaximumIntegerDigits();
 830             int minIntDigits = getMinimumIntegerDigits();
 831             int maxFraDigits = getMaximumFractionDigits();
 832             int minFraDigits = getMinimumFractionDigits();
 833             int maximumDigits = maxIntDigits + maxFraDigits;
 834 
</pre>
<hr />
<pre>
 837                 maxFraDigits, !useExponentialNotation);
 838 
 839             return subformat(result, delegate, isNegative, false,
 840                 maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 841         }
 842     }
 843 
 844     /**
 845      * Format a BigInteger to produce a string.
 846      * @param number    The BigInteger to format
 847      * @param result    where the text is to be appended
 848      * @param fieldPosition    keeps track on the position of the field within
 849      *                         the returned string. For example, for formatting
 850      *                         a number {@code 123456789} in {@code Locale.US}
 851      *                         locale, if the given {@code fieldPosition} is
 852      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 853      *                         and end index of {@code fieldPosition} will be set
 854      *                         to 0 and 11, respectively for the output string
 855      *                         {@code 123,456,789}.
 856      * @return The formatted number string
<span class="line-modified"> 857      * @exception        ArithmeticException if rounding is needed with rounding</span>
 858      *                   mode being set to RoundingMode.UNNECESSARY
 859      * @see java.text.FieldPosition
 860      */
 861     private StringBuffer format(BigInteger number, StringBuffer result,
 862                                FieldPosition fieldPosition) {
 863         fieldPosition.setBeginIndex(0);
 864         fieldPosition.setEndIndex(0);
 865 
 866         return format(number, result, fieldPosition.getFieldDelegate(), false);
 867     }
 868 
 869     /**
 870      * Format a BigInteger to produce a string.
 871      * @param number    The BigInteger to format
 872      * @param result    where the text is to be appended
 873      * @param delegate notified of locations of sub fields
 874      * @return The formatted number string
<span class="line-modified"> 875      * @exception        ArithmeticException if rounding is needed with rounding</span>
 876      *                   mode being set to RoundingMode.UNNECESSARY
 877      * @see java.text.FieldPosition
 878      */
 879     StringBuffer format(BigInteger number, StringBuffer result,
 880                                FieldDelegate delegate, boolean formatLong) {
 881         if (multiplier != 1) {
 882             number = number.multiply(getBigIntegerMultiplier());
 883         }
 884         boolean isNegative = number.signum() == -1;
 885         if (isNegative) {
 886             number = number.negate();
 887         }
 888 
 889         synchronized(digitList) {
 890             int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
 891             if (formatLong) {
 892                 maxIntDigits = super.getMaximumIntegerDigits();
 893                 minIntDigits = super.getMinimumIntegerDigits();
 894                 maxFraDigits = super.getMaximumFractionDigits();
 895                 minFraDigits = super.getMinimumFractionDigits();
</pre>
<hr />
<pre>
 897             } else {
 898                 maxIntDigits = getMaximumIntegerDigits();
 899                 minIntDigits = getMinimumIntegerDigits();
 900                 maxFraDigits = getMaximumFractionDigits();
 901                 minFraDigits = getMinimumFractionDigits();
 902                 maximumDigits = maxIntDigits + maxFraDigits;
 903                 if (maximumDigits &lt; 0) {
 904                     maximumDigits = Integer.MAX_VALUE;
 905                 }
 906             }
 907 
 908             digitList.set(isNegative, number,
 909                           useExponentialNotation ? maximumDigits : 0);
 910 
 911             return subformat(result, delegate, isNegative, true,
 912                 maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 913         }
 914     }
 915 
 916     /**
<span class="line-modified"> 917      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified"> 918      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
 919      * to build the resulting String, as well as to determine information
 920      * about the resulting String.
 921      * &lt;p&gt;
 922      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified"> 923      * &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the</span>
 924      * same as the attribute key.
 925      *
<span class="line-modified"> 926      * @exception NullPointerException if obj is null.</span>
<span class="line-modified"> 927      * @exception IllegalArgumentException when the Format cannot format the</span>
 928      *            given object.
<span class="line-modified"> 929      * @exception        ArithmeticException if rounding is needed with rounding</span>
 930      *                   mode being set to RoundingMode.UNNECESSARY
 931      * @param obj The object to format
 932      * @return AttributedCharacterIterator describing the formatted value.
 933      * @since 1.4
 934      */
 935     @Override
 936     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
 937         CharacterIteratorFieldDelegate delegate =
 938                          new CharacterIteratorFieldDelegate();
 939         StringBuffer sb = new StringBuffer();
 940 
 941         if (obj instanceof Double || obj instanceof Float) {
 942             format(((Number)obj).doubleValue(), sb, delegate);
 943         } else if (obj instanceof Long || obj instanceof Integer ||
 944                    obj instanceof Short || obj instanceof Byte ||
 945                    obj instanceof AtomicInteger || obj instanceof AtomicLong) {
 946             format(((Number)obj).longValue(), sb, delegate);
 947         } else if (obj instanceof BigDecimal) {
 948             format((BigDecimal)obj, sb, delegate);
 949         } else if (obj instanceof BigInteger) {
</pre>
<hr />
<pre>
1086          * setting the fast path data. The return value is used by the
1087          * fastFormat() method to decide whether to call the resetFastPathData
1088          * method to reinitialize fast path data or is it already initialized
1089          * in this method.
1090          */
1091         return true;
1092     }
1093 
1094     private void resetFastPathData(boolean fastPathWasOn) {
1095         // Since some instance properties may have changed while still falling
1096         // in the fast-path case, we need to reinitialize fastPathData anyway.
1097         if (isFastPath) {
1098             // We need to instantiate fastPathData if not already done.
1099             if (fastPathData == null) {
1100                 fastPathData = new FastPathData();
1101             }
1102 
1103             // Sets up the locale specific constants used when formatting.
1104             // &#39;0&#39; is our default representation of zero.
1105             fastPathData.zeroDelta = symbols.getZeroDigit() - &#39;0&#39;;
<span class="line-modified">1106             fastPathData.groupingChar = symbols.getGroupingSeparator();</span>


1107 
1108             // Sets up fractional constants related to currency/decimal pattern.
1109             fastPathData.fractionalMaxIntBound = (isCurrencyFormat)
1110                     ? 99 : 999;
1111             fastPathData.fractionalScaleFactor = (isCurrencyFormat)
1112                     ? 100.0d : 1000.0d;
1113 
1114             // Records the need for adding prefix or suffix
1115             fastPathData.positiveAffixesRequired
1116                     = !positivePrefix.isEmpty() || !positiveSuffix.isEmpty();
1117             fastPathData.negativeAffixesRequired
1118                     = !negativePrefix.isEmpty() || !negativeSuffix.isEmpty();
1119 
1120             // Creates a cached char container for result, with max possible size.
1121             int maxNbIntegralDigits = 10;
1122             int maxNbGroups = 3;
1123             int containerSize
1124                     = Math.max(positivePrefix.length(), negativePrefix.length())
1125                     + maxNbIntegralDigits + maxNbGroups + 1
1126                     + maximumFractionDigits
</pre>
<hr />
<pre>
1757         return result;
1758     }
1759 
1760     /**
1761      * Subformats number part using the {@code DigitList} of this
1762      * {@code DecimalFormat} instance.
1763      * @param result where the text is to be appended
1764      * @param delegate notified of the location of sub fields
1765      * @param isNegative true, if the number is negative; false otherwise
1766      * @param isInteger true, if the number is an integer; false otherwise
1767      * @param maxIntDigits maximum integer digits
1768      * @param minIntDigits minimum integer digits
1769      * @param maxFraDigits maximum fraction digits
1770      * @param minFraDigits minimum fraction digits
1771      */
1772     void subformatNumber(StringBuffer result, FieldDelegate delegate,
1773             boolean isNegative, boolean isInteger,
1774             int maxIntDigits, int minIntDigits,
1775             int maxFraDigits, int minFraDigits) {
1776 
<span class="line-modified">1777         char grouping = symbols.getGroupingSeparator();</span>


1778         char zero = symbols.getZeroDigit();
1779         int zeroDelta = zero - &#39;0&#39;; // &#39;0&#39; is the DigitList representation of zero
1780 
1781         char decimal = isCurrencyFormat ?
1782                 symbols.getMonetaryDecimalSeparator() :
1783                 symbols.getDecimalSeparator();
1784 
1785         /* Per bug 4147706, DecimalFormat must respect the sign of numbers which
1786          * format as zero.  This allows sensible computations and preserves
1787          * relations such as signum(1/x) = signum(x), where x is +Infinity or
1788          * -Infinity.  Prior to this fix, we always formatted zero values as if
1789          * they were positive.  Liu 7/6/98.
1790          */
1791         if (digitList.isZero()) {
1792             digitList.decimalAt = 0; // Normalize
1793         }
1794 
1795         if (useExponentialNotation) {
1796             int iFieldStart = result.length();
1797             int iFieldEnd = -1;
</pre>
<hr />
<pre>
1899             // digits, since truncating the exponent would result in an
1900             // unacceptable inaccuracy.
1901             int fieldStart = result.length();
1902 
1903             result.append(symbols.getExponentSeparator());
1904 
1905             delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL,
1906                     fieldStart, result.length(), result);
1907 
1908             // For zero values, we force the exponent to zero.  We
1909             // must do this here, and not earlier, because the value
1910             // is used to determine integer digit count above.
1911             if (digitList.isZero()) {
1912                 exponent = 0;
1913             }
1914 
1915             boolean negativeExponent = exponent &lt; 0;
1916             if (negativeExponent) {
1917                 exponent = -exponent;
1918                 fieldStart = result.length();
<span class="line-modified">1919                 result.append(symbols.getMinusSign());</span>
1920                 delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN,
1921                         fieldStart, result.length(), result);
1922             }
1923             digitList.set(negativeExponent, exponent);
1924 
1925             int eFieldStart = result.length();
1926 
1927             for (int i=digitList.decimalAt; i&lt;minExponentDigits; ++i) {
1928                 result.append(zero);
1929             }
1930             for (int i=0; i&lt;digitList.decimalAt; ++i) {
1931                 result.append((i &lt; digitList.count) ?
1932                         (char)(digitList.digits[i] + zeroDelta) : zero);
1933             }
1934             delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart,
1935                     result.length(), result);
1936         } else {
1937             int iFieldStart = result.length();
1938 
1939             // Output the integer portion.  Here &#39;count&#39; is the total
</pre>
<hr />
<pre>
2025                     result.append(zero);
2026                     continue;
2027                 }
2028 
2029                 // Output a digit, if we have any precision left, or a
2030                 // zero if we don&#39;t.  We don&#39;t want to output noise digits.
2031                 if (!isInteger &amp;&amp; digitIndex &lt; digitList.count) {
2032                     result.append((char)(digitList.digits[digitIndex++] + zeroDelta));
2033                 } else {
2034                     result.append(zero);
2035                 }
2036             }
2037 
2038             // Record field information for caller.
2039             delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
2040                     fFieldStart, result.length(), result);
2041         }
2042     }
2043 
2044     /**
<span class="line-modified">2045      * Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.</span>
<span class="line-modified">2046      * &lt;code&gt;delegate&lt;/code&gt; is notified of all  the</span>
<span class="line-modified">2047      * &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.</span>
2048      * &lt;p&gt;
<span class="line-modified">2049      * If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;</span>
<span class="line-modified">2050      * identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to</span>
<span class="line-modified">2051      * &lt;code&gt;signAttribute&lt;/code&gt;. This is used</span>
<span class="line-modified">2052      * to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;</span>
2053      * attribute as necessary.
2054      * &lt;p&gt;
<span class="line-modified">2055      * This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.</span>
2056      */
2057     private void append(StringBuffer result, String string,
2058                         FieldDelegate delegate,
2059                         FieldPosition[] positions,
2060                         Format.Field signAttribute) {
2061         int start = result.length();
2062 
2063         if (!string.isEmpty()) {
2064             result.append(string);
2065             for (int counter = 0, max = positions.length; counter &lt; max;
2066                  counter++) {
2067                 FieldPosition fp = positions[counter];
2068                 Format.Field attribute = fp.getFieldAttribute();
2069 
2070                 if (attribute == Field.SIGN) {
2071                     attribute = signAttribute;
2072                 }
2073                 delegate.formatted(attribute, attribute,
2074                                    start + fp.getBeginIndex(),
2075                                    start + fp.getEndIndex(), result);
2076             }
2077         }
2078     }
2079 
2080     /**
<span class="line-modified">2081      * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.</span>
2082      * &lt;p&gt;
2083      * The method attempts to parse text starting at the index given by
<span class="line-modified">2084      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">2085      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
2086      * to the index after the last character used (parsing does not necessarily
2087      * use all characters up to the end of the string), and the parsed
<span class="line-modified">2088      * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
2089      * indicate the starting point for the next call to this method.
<span class="line-modified">2090      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">2091      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
2092      * the character where the error occurred, and null is returned.
2093      * &lt;p&gt;
2094      * The subclass returned depends on the value of {@link #isParseBigDecimal}
2095      * as well as on the string being parsed.
2096      * &lt;ul&gt;
<span class="line-modified">2097      *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),</span>
<span class="line-modified">2098      *       most integer values are returned as &lt;code&gt;Long&lt;/code&gt;</span>
<span class="line-modified">2099      *       objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and</span>
<span class="line-modified">2100      *       &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.</span>
<span class="line-modified">2101      *       Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as</span>
<span class="line-modified">2102      *       &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,</span>
<span class="line-modified">2103      *       infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.</span>
<span class="line-modified">2104      *       &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to</span>
<span class="line-modified">2105      *       return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the</span>
2106      *       presence of a decimal separator in the source string. Doing so
2107      *       would prevent integers that overflow the mantissa of a double,
<span class="line-modified">2108      *       such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being</span>
2109      *       parsed accurately.
2110      *       &lt;p&gt;
<span class="line-modified">2111      *       Callers may use the &lt;code&gt;Number&lt;/code&gt; methods</span>
<span class="line-modified">2112      *       &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain</span>
2113      *       the type they want.
<span class="line-modified">2114      *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned</span>
<span class="line-modified">2115      *       as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones</span>
2116      *       constructed by {@link java.math.BigDecimal#BigDecimal(String)}
2117      *       for corresponding strings in locale-independent format. The
2118      *       special cases negative and positive infinity and NaN are returned
<span class="line-modified">2119      *       as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the</span>
<span class="line-modified">2120      *       corresponding &lt;code&gt;Double&lt;/code&gt; constants.</span>
2121      * &lt;/ul&gt;
2122      * &lt;p&gt;
<span class="line-modified">2123      * &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent</span>
<span class="line-modified">2124      * decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In</span>
<span class="line-modified">2125      * addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten</span>
2126      * consecutive characters starting with the localized zero digit defined in
<span class="line-modified">2127      * the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.</span>
2128      *
2129      * @param text the string to be parsed
<span class="line-modified">2130      * @param pos  A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
2131      *             index information as described above.
<span class="line-modified">2132      * @return     the parsed value, or &lt;code&gt;null&lt;/code&gt; if the parse fails</span>
<span class="line-modified">2133      * @exception  NullPointerException if &lt;code&gt;text&lt;/code&gt; or</span>
<span class="line-modified">2134      *             &lt;code&gt;pos&lt;/code&gt; is null.</span>
2135      */
2136     @Override
2137     public Number parse(String text, ParsePosition pos) {
2138         // special case NaN
2139         if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {
2140             pos.index = pos.index + symbols.getNaN().length();
2141             return Double.valueOf(Double.NaN);
2142         }
2143 
2144         boolean[] status = new boolean[STATUS_LENGTH];
2145         if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {
2146             return null;
2147         }
2148 
2149         // special case INFINITY
2150         if (status[STATUS_INFINITE]) {
2151             if (status[STATUS_POSITIVE] == (multiplier &gt;= 0)) {
2152                 return Double.valueOf(Double.POSITIVE_INFINITY);
2153             } else {
2154                 return Double.valueOf(Double.NEGATIVE_INFINITY);
</pre>
<hr />
<pre>
2376                        boolean isExponent, boolean status[]) {
2377         // process digits or Inf, find decimal position
2378         status[STATUS_INFINITE] = false;
2379         if (!isExponent &amp;&amp; text.regionMatches(position,symbols.getInfinity(),0,
2380                 symbols.getInfinity().length())) {
2381             position += symbols.getInfinity().length();
2382             status[STATUS_INFINITE] = true;
2383         } else {
2384             // We now have a string of digits, possibly with grouping symbols,
2385             // and decimal points.  We want to process these into a DigitList.
2386             // We don&#39;t want to put a bunch of leading zeros into the DigitList
2387             // though, so we keep track of the location of the decimal point,
2388             // put only significant digits into the DigitList, and adjust the
2389             // exponent as needed.
2390 
2391             digits.decimalAt = digits.count = 0;
2392             char zero = symbols.getZeroDigit();
2393             char decimal = isCurrencyFormat ?
2394                     symbols.getMonetaryDecimalSeparator() :
2395                     symbols.getDecimalSeparator();
<span class="line-modified">2396             char grouping = symbols.getGroupingSeparator();</span>


2397             String exponentString = symbols.getExponentSeparator();
2398             boolean sawDecimal = false;
2399             boolean sawExponent = false;
2400             boolean sawDigit = false;
2401             int exponent = 0; // Set to the exponent value, if any
2402 
2403             // We have to track digitCount ourselves, because digits.count will
2404             // pin when the maximum allowable digits is reached.
2405             int digitCount = 0;
2406 
2407             int backup = -1;
2408             for (; position &lt; text.length(); ++position) {
2409                 char ch = text.charAt(position);
2410 
2411                 /* We recognize all digit ranges, not only the Latin digit range
2412                  * &#39;0&#39;..&#39;9&#39;.  We do so by using the Character.digit() method,
2413                  * which converts a valid Unicode digit to the range 0..9.
2414                  *
2415                  * The character &#39;ch&#39; may be a digit.  If so, place its value
2416                  * from 0 to 9 in &#39;digit&#39;.  First try using the locale digit,
</pre>
<hr />
<pre>
2458                     if (isParseIntegerOnly() || sawDecimal) {
2459                         break;
2460                     }
2461                     digits.decimalAt = digitCount; // Not digits.count!
2462                     sawDecimal = true;
2463                 } else if (!isExponent &amp;&amp; ch == grouping &amp;&amp; isGroupingUsed()) {
2464                     if (sawDecimal) {
2465                         break;
2466                     }
2467                     // Ignore grouping characters, if we are using them, but
2468                     // require that they be followed by a digit.  Otherwise
2469                     // we backup and reprocess them.
2470                     backup = position;
2471                 } else if (checkExponent &amp;&amp; !isExponent &amp;&amp; text.regionMatches(position, exponentString, 0, exponentString.length())
2472                         &amp;&amp; !sawExponent) {
2473                     // Process the exponent by recursively calling this method.
2474                     ParsePosition pos = new ParsePosition(position + exponentString.length());
2475                     boolean[] stat = new boolean[STATUS_LENGTH];
2476                     DigitList exponentDigits = new DigitList();
2477 
<span class="line-modified">2478                     if (subparse(text, pos, &quot;&quot;, Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) &amp;&amp;</span>
2479                             exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {
2480                         position = pos.index; // Advance past the exponent
2481                         exponent = (int)exponentDigits.getLong();
2482                         if (!stat[STATUS_POSITIVE]) {
2483                             exponent = -exponent;
2484                         }
2485                         sawExponent = true;
2486                     }
2487                     break; // Whether we fail or succeed, we exit this loop
2488                 } else {
2489                     break;
2490                 }
2491             }
2492 
2493             if (backup != -1) {
2494                 position = backup;
2495             }
2496 
2497             // If there was no decimal point we have an integer
2498             if (!sawDecimal) {
</pre>
<hr />
<pre>
2556     public String getPositivePrefix () {
2557         return positivePrefix;
2558     }
2559 
2560     /**
2561      * Set the positive prefix.
2562      * &lt;P&gt;Examples: +123, $123, sFr123
2563      *
2564      * @param newValue the new positive prefix
2565      */
2566     public void setPositivePrefix (String newValue) {
2567         positivePrefix = newValue;
2568         posPrefixPattern = null;
2569         positivePrefixFieldPositions = null;
2570         fastPathCheckNeeded = true;
2571     }
2572 
2573     /**
2574      * Returns the FieldPositions of the fields in the prefix used for
2575      * positive numbers. This is not used if the user has explicitly set
<span class="line-modified">2576      * a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is</span>
2577      * lazily created.
2578      *
2579      * @return FieldPositions in positive prefix
2580      */
2581     private FieldPosition[] getPositivePrefixFieldPositions() {
2582         if (positivePrefixFieldPositions == null) {
2583             if (posPrefixPattern != null) {
2584                 positivePrefixFieldPositions = expandAffix(posPrefixPattern);
2585             } else {
2586                 positivePrefixFieldPositions = EmptyFieldPositionArray;
2587             }
2588         }
2589         return positivePrefixFieldPositions;
2590     }
2591 
2592     /**
2593      * Get the negative prefix.
2594      * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
2595      *
2596      * @return the negative prefix
2597      */
2598     public String getNegativePrefix () {
2599         return negativePrefix;
2600     }
2601 
2602     /**
2603      * Set the negative prefix.
2604      * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
2605      *
2606      * @param newValue the new negative prefix
2607      */
2608     public void setNegativePrefix (String newValue) {
2609         negativePrefix = newValue;
2610         negPrefixPattern = null;
2611         fastPathCheckNeeded = true;
2612     }
2613 
2614     /**
2615      * Returns the FieldPositions of the fields in the prefix used for
2616      * negative numbers. This is not used if the user has explicitly set
<span class="line-modified">2617      * a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is</span>
2618      * lazily created.
2619      *
2620      * @return FieldPositions in positive prefix
2621      */
2622     private FieldPosition[] getNegativePrefixFieldPositions() {
2623         if (negativePrefixFieldPositions == null) {
2624             if (negPrefixPattern != null) {
2625                 negativePrefixFieldPositions = expandAffix(negPrefixPattern);
2626             } else {
2627                 negativePrefixFieldPositions = EmptyFieldPositionArray;
2628             }
2629         }
2630         return negativePrefixFieldPositions;
2631     }
2632 
2633     /**
2634      * Get the positive suffix.
2635      * &lt;P&gt;Example: 123%
2636      *
2637      * @return the positive suffix
2638      */
2639     public String getPositiveSuffix () {
2640         return positiveSuffix;
2641     }
2642 
2643     /**
2644      * Set the positive suffix.
2645      * &lt;P&gt;Example: 123%
2646      *
2647      * @param newValue the new positive suffix
2648      */
2649     public void setPositiveSuffix (String newValue) {
2650         positiveSuffix = newValue;
2651         posSuffixPattern = null;
2652         fastPathCheckNeeded = true;
2653     }
2654 
2655     /**
2656      * Returns the FieldPositions of the fields in the suffix used for
2657      * positive numbers. This is not used if the user has explicitly set
<span class="line-modified">2658      * a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is</span>
2659      * lazily created.
2660      *
2661      * @return FieldPositions in positive prefix
2662      */
2663     private FieldPosition[] getPositiveSuffixFieldPositions() {
2664         if (positiveSuffixFieldPositions == null) {
2665             if (posSuffixPattern != null) {
2666                 positiveSuffixFieldPositions = expandAffix(posSuffixPattern);
2667             } else {
2668                 positiveSuffixFieldPositions = EmptyFieldPositionArray;
2669             }
2670         }
2671         return positiveSuffixFieldPositions;
2672     }
2673 
2674     /**
2675      * Get the negative suffix.
2676      * &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)
2677      *
2678      * @return the negative suffix
2679      */
2680     public String getNegativeSuffix () {
2681         return negativeSuffix;
2682     }
2683 
2684     /**
2685      * Set the negative suffix.
2686      * &lt;P&gt;Examples: 123%
2687      *
2688      * @param newValue the new negative suffix
2689      */
2690     public void setNegativeSuffix (String newValue) {
2691         negativeSuffix = newValue;
2692         negSuffixPattern = null;
2693         fastPathCheckNeeded = true;
2694     }
2695 
2696     /**
2697      * Returns the FieldPositions of the fields in the suffix used for
2698      * negative numbers. This is not used if the user has explicitly set
<span class="line-modified">2699      * a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is</span>
2700      * lazily created.
2701      *
2702      * @return FieldPositions in positive prefix
2703      */
2704     private FieldPosition[] getNegativeSuffixFieldPositions() {
2705         if (negativeSuffixFieldPositions == null) {
2706             if (negSuffixPattern != null) {
2707                 negativeSuffixFieldPositions = expandAffix(negSuffixPattern);
2708             } else {
2709                 negativeSuffixFieldPositions = EmptyFieldPositionArray;
2710             }
2711         }
2712         return negativeSuffixFieldPositions;
2713     }
2714 
2715     /**
2716      * Gets the multiplier for use in percent, per mille, and similar
2717      * formats.
2718      *
2719      * @return the multiplier
</pre>
<hr />
<pre>
2739      */
2740     public void setMultiplier (int newValue) {
2741         multiplier = newValue;
2742         bigDecimalMultiplier = null;
2743         bigIntegerMultiplier = null;
2744         fastPathCheckNeeded = true;
2745     }
2746 
2747     /**
2748      * {@inheritDoc}
2749      */
2750     @Override
2751     public void setGroupingUsed(boolean newValue) {
2752         super.setGroupingUsed(newValue);
2753         fastPathCheckNeeded = true;
2754     }
2755 
2756     /**
2757      * Return the grouping size. Grouping size is the number of digits between
2758      * grouping separators in the integer portion of a number.  For example,
<span class="line-modified">2759      * in the number &quot;123,456.78&quot;, the grouping size is 3.</span>



2760      *
2761      * @return the grouping size
2762      * @see #setGroupingSize
2763      * @see java.text.NumberFormat#isGroupingUsed
2764      * @see java.text.DecimalFormatSymbols#getGroupingSeparator
2765      */
2766     public int getGroupingSize () {
2767         return groupingSize;
2768     }
2769 
2770     /**
2771      * Set the grouping size. Grouping size is the number of digits between
2772      * grouping separators in the integer portion of a number.  For example,
<span class="line-modified">2773      * in the number &quot;123,456.78&quot;, the grouping size is 3.</span>
<span class="line-modified">2774      * &lt;br&gt;</span>



2775      * The value passed in is converted to a byte, which may lose information.



2776      *
2777      * @param newValue the new grouping size
2778      * @see #getGroupingSize
2779      * @see java.text.NumberFormat#setGroupingUsed
2780      * @see java.text.DecimalFormatSymbols#setGroupingSeparator


2781      */
2782     public void setGroupingSize (int newValue) {




2783         groupingSize = (byte)newValue;
2784         fastPathCheckNeeded = true;
2785     }
2786 
2787     /**
2788      * Allows you to get the behavior of the decimal separator with integers.
2789      * (The decimal separator will always appear with decimals.)
2790      * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
2791      *
2792      * @return {@code true} if the decimal separator is always shown;
2793      *         {@code false} otherwise
2794      */
2795     public boolean isDecimalSeparatorAlwaysShown() {
2796         return decimalSeparatorAlwaysShown;
2797     }
2798 
2799     /**
2800      * Allows you to set the behavior of the decimal separator with integers.
2801      * (The decimal separator will always appear with decimals.)
2802      * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
2803      *
2804      * @param newValue {@code true} if the decimal separator is always shown;
2805      *                 {@code false} otherwise
2806      */
2807     public void setDecimalSeparatorAlwaysShown(boolean newValue) {
2808         decimalSeparatorAlwaysShown = newValue;
2809         fastPathCheckNeeded = true;
2810     }
2811 
2812     /**
2813      * Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
<span class="line-modified">2814      * method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.</span>
2815      *
2816      * @return {@code true} if the parse method returns BigDecimal;
2817      *         {@code false} otherwise
2818      * @see #setParseBigDecimal
2819      * @since 1.5
2820      */
2821     public boolean isParseBigDecimal() {
2822         return parseBigDecimal;
2823     }
2824 
2825     /**
2826      * Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
<span class="line-modified">2827      * method returns &lt;code&gt;BigDecimal&lt;/code&gt;.</span>
2828      *
2829      * @param newValue {@code true} if the parse method returns BigDecimal;
2830      *                 {@code false} otherwise
2831      * @see #isParseBigDecimal
2832      * @since 1.5
2833      */
2834     public void setParseBigDecimal(boolean newValue) {
2835         parseBigDecimal = newValue;
2836     }
2837 
2838     /**
2839      * Standard override; no change in semantics.
2840      */
2841     @Override
2842     public Object clone() {
2843         DecimalFormat other = (DecimalFormat) super.clone();
2844         other.symbols = (DecimalFormatSymbols) symbols.clone();
2845         other.digitList = (DigitList) digitList.clone();
2846 
2847         // Fast-path is almost stateless algorithm. The only logical state is the
</pre>
<hr />
<pre>
2974      * @param buffer a scratch StringBuffer; its contents will be lost
2975      * @return the expanded equivalent of pattern
2976      */
2977     private String expandAffix(String pattern, StringBuffer buffer) {
2978         buffer.setLength(0);
2979         for (int i=0; i&lt;pattern.length(); ) {
2980             char c = pattern.charAt(i++);
2981             if (c == QUOTE) {
2982                 c = pattern.charAt(i++);
2983                 switch (c) {
2984                 case CURRENCY_SIGN:
2985                     if (i&lt;pattern.length() &amp;&amp;
2986                         pattern.charAt(i) == CURRENCY_SIGN) {
2987                         ++i;
2988                         buffer.append(symbols.getInternationalCurrencySymbol());
2989                     } else {
2990                         buffer.append(symbols.getCurrencySymbol());
2991                     }
2992                     continue;
2993                 case PATTERN_PERCENT:
<span class="line-modified">2994                     c = symbols.getPercent();</span>
<span class="line-modified">2995                     break;</span>
2996                 case PATTERN_PER_MILLE:
<span class="line-modified">2997                     c = symbols.getPerMill();</span>
<span class="line-modified">2998                     break;</span>
2999                 case PATTERN_MINUS:
<span class="line-modified">3000                     c = symbols.getMinusSign();</span>
<span class="line-modified">3001                     break;</span>
3002                 }
3003             }
3004             buffer.append(c);
3005         }
3006         return buffer.toString();
3007     }
3008 
3009     /**
3010      * Expand an affix pattern into an array of FieldPositions describing
3011      * how the pattern would be expanded.
3012      * All characters in the
3013      * pattern are literal unless prefixed by QUOTE.  The following characters
3014      * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
3015      * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
3016      * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
3017      * currency code.  Any other character after a QUOTE represents itself.
3018      * QUOTE must be followed by another character; QUOTE may not occur by
3019      * itself at the end of the pattern.
3020      *
3021      * @param pattern the non-null, possibly empty pattern
3022      * @return FieldPosition array of the resulting fields.
3023      */
3024     private FieldPosition[] expandAffix(String pattern) {
3025         ArrayList&lt;FieldPosition&gt; positions = null;
3026         int stringIndex = 0;
3027         for (int i=0; i&lt;pattern.length(); ) {
3028             char c = pattern.charAt(i++);
3029             if (c == QUOTE) {
<span class="line-removed">3030                 int field = -1;</span>
3031                 Format.Field fieldID = null;

3032                 c = pattern.charAt(i++);
3033                 switch (c) {
3034                 case CURRENCY_SIGN:
<span class="line-removed">3035                     String string;</span>
3036                     if (i&lt;pattern.length() &amp;&amp;
3037                         pattern.charAt(i) == CURRENCY_SIGN) {
3038                         ++i;
3039                         string = symbols.getInternationalCurrencySymbol();
3040                     } else {
3041                         string = symbols.getCurrencySymbol();
3042                     }
<span class="line-modified">3043                     if (!string.isEmpty()) {</span>
<span class="line-modified">3044                         if (positions == null) {</span>
<span class="line-removed">3045                             positions = new ArrayList&lt;&gt;(2);</span>
<span class="line-removed">3046                         }</span>
<span class="line-removed">3047                         FieldPosition fp = new FieldPosition(Field.CURRENCY);</span>
<span class="line-removed">3048                         fp.setBeginIndex(stringIndex);</span>
<span class="line-removed">3049                         fp.setEndIndex(stringIndex + string.length());</span>
<span class="line-removed">3050                         positions.add(fp);</span>
<span class="line-removed">3051                         stringIndex += string.length();</span>
<span class="line-removed">3052                     }</span>
<span class="line-removed">3053                     continue;</span>
3054                 case PATTERN_PERCENT:
<span class="line-modified">3055                     c = symbols.getPercent();</span>
<span class="line-removed">3056                     field = -1;</span>
3057                     fieldID = Field.PERCENT;
3058                     break;
3059                 case PATTERN_PER_MILLE:
<span class="line-modified">3060                     c = symbols.getPerMill();</span>
<span class="line-removed">3061                     field = -1;</span>
3062                     fieldID = Field.PERMILLE;
3063                     break;
3064                 case PATTERN_MINUS:
<span class="line-modified">3065                     c = symbols.getMinusSign();</span>
<span class="line-removed">3066                     field = -1;</span>
3067                     fieldID = Field.SIGN;
3068                     break;
3069                 }
<span class="line-modified">3070                 if (fieldID != null) {</span>

3071                     if (positions == null) {
3072                         positions = new ArrayList&lt;&gt;(2);
3073                     }
<span class="line-modified">3074                     FieldPosition fp = new FieldPosition(fieldID, field);</span>
3075                     fp.setBeginIndex(stringIndex);
<span class="line-modified">3076                     fp.setEndIndex(stringIndex + 1);</span>
3077                     positions.add(fp);


3078                 }
3079             }
3080             stringIndex++;
3081         }
3082         if (positions != null) {
3083             return positions.toArray(EmptyFieldPositionArray);
3084         }
3085         return EmptyFieldPositionArray;
3086     }
3087 
3088     /**
3089      * Appends an affix pattern to the given StringBuffer, quoting special
3090      * characters as needed.  Uses the internal affix pattern, if that exists,
3091      * or the literal affix, if the internal affix pattern is null.  The
3092      * appended string will generate the same affix pattern (or literal affix)
3093      * when passed to toPattern().
3094      *
3095      * @param buffer the affix string is appended to this
3096      * @param affixPattern a pattern such as posPrefixPattern; may be null
3097      * @param expAffix a corresponding expanded affix, such as positivePrefix.
</pre>
<hr />
<pre>
3112                     appendAffix(buffer, affixPattern.substring(pos), localized);
3113                     break;
3114                 }
3115                 if (i &gt; pos) {
3116                     appendAffix(buffer, affixPattern.substring(pos, i), localized);
3117                 }
3118                 char c = affixPattern.charAt(++i);
3119                 ++i;
3120                 if (c == QUOTE) {
3121                     buffer.append(c);
3122                     // Fall through and append another QUOTE below
3123                 } else if (c == CURRENCY_SIGN &amp;&amp;
3124                            i&lt;affixPattern.length() &amp;&amp;
3125                            affixPattern.charAt(i) == CURRENCY_SIGN) {
3126                     ++i;
3127                     buffer.append(c);
3128                     // Fall through and append another CURRENCY_SIGN below
3129                 } else if (localized) {
3130                     switch (c) {
3131                     case PATTERN_PERCENT:
<span class="line-modified">3132                         c = symbols.getPercent();</span>
<span class="line-modified">3133                         break;</span>
3134                     case PATTERN_PER_MILLE:
<span class="line-modified">3135                         c = symbols.getPerMill();</span>
<span class="line-modified">3136                         break;</span>
3137                     case PATTERN_MINUS:
<span class="line-modified">3138                         c = symbols.getMinusSign();</span>
<span class="line-modified">3139                         break;</span>
3140                     }
3141                 }
3142                 buffer.append(c);
3143             }
3144         }
3145     }
3146 
3147     /**
3148      * Append an affix to the given StringBuffer, using quotes if
3149      * there are special characters.  Single quotes themselves must be
3150      * escaped in either case.
3151      */
3152     private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
3153         boolean needQuote;
3154         if (localized) {
3155             needQuote = affix.indexOf(symbols.getZeroDigit()) &gt;= 0
3156                 || affix.indexOf(symbols.getGroupingSeparator()) &gt;= 0
3157                 || affix.indexOf(symbols.getDecimalSeparator()) &gt;= 0
<span class="line-modified">3158                 || affix.indexOf(symbols.getPercent()) &gt;= 0</span>
<span class="line-modified">3159                 || affix.indexOf(symbols.getPerMill()) &gt;= 0</span>
3160                 || affix.indexOf(symbols.getDigit()) &gt;= 0
3161                 || affix.indexOf(symbols.getPatternSeparator()) &gt;= 0
<span class="line-modified">3162                 || affix.indexOf(symbols.getMinusSign()) &gt;= 0</span>
3163                 || affix.indexOf(CURRENCY_SIGN) &gt;= 0;
3164         } else {
3165             needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) &gt;= 0
3166                 || affix.indexOf(PATTERN_GROUPING_SEPARATOR) &gt;= 0
3167                 || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) &gt;= 0
3168                 || affix.indexOf(PATTERN_PERCENT) &gt;= 0
3169                 || affix.indexOf(PATTERN_PER_MILLE) &gt;= 0
3170                 || affix.indexOf(PATTERN_DIGIT) &gt;= 0
3171                 || affix.indexOf(PATTERN_SEPARATOR) &gt;= 0
3172                 || affix.indexOf(PATTERN_MINUS) &gt;= 0
3173                 || affix.indexOf(CURRENCY_SIGN) &gt;= 0;
3174         }
3175         if (needQuote) buffer.append(&#39;\&#39;&#39;);
3176         if (affix.indexOf(&#39;\&#39;&#39;) &lt; 0) buffer.append(affix);
3177         else {
3178             for (int j=0; j&lt;affix.length(); ++j) {
3179                 char c = affix.charAt(j);
3180                 buffer.append(c);
3181                 if (c == &#39;\&#39;&#39;) buffer.append(c);
3182             }
</pre>
<hr />
<pre>
3218                                   PATTERN_DIGIT);
3219                 }
3220             }
3221         if (useExponentialNotation)
3222         {
3223             result.append(localized ? symbols.getExponentSeparator() :
3224                   PATTERN_EXPONENT);
3225         for (i=0; i&lt;minExponentDigits; ++i)
3226                     result.append(localized ? symbols.getZeroDigit() :
3227                                   PATTERN_ZERO_DIGIT);
3228         }
3229             if (j == 1) {
3230                 appendAffix(result, posSuffixPattern, positiveSuffix, localized);
3231                 if ((negSuffixPattern == posSuffixPattern &amp;&amp; // n == p == null
3232                      negativeSuffix.equals(positiveSuffix))
3233                     || (negSuffixPattern != null &amp;&amp;
3234                         negSuffixPattern.equals(posSuffixPattern))) {
3235                     if ((negPrefixPattern != null &amp;&amp; posPrefixPattern != null &amp;&amp;
3236                          negPrefixPattern.equals(&quot;&#39;-&quot; + posPrefixPattern)) ||
3237                         (negPrefixPattern == posPrefixPattern &amp;&amp; // n == p == null
<span class="line-modified">3238                          negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))</span>
3239                         break;
3240                 }
3241                 result.append(localized ? symbols.getPatternSeparator() :
3242                               PATTERN_SEPARATOR);
3243             } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);
3244         }
3245         return result.toString();
3246     }
3247 
3248     /**
3249      * Apply the given pattern to this Format object.  A pattern is a
3250      * short-hand specification for the various formatting properties.
3251      * These properties can also be changed individually through the
3252      * various setter methods.
3253      * &lt;p&gt;
3254      * There is no limit to integer digits set
3255      * by this routine, since that is the typical end-user desire;
3256      * use setMaximumInteger if you want to set a real value.
3257      * For negative numbers, use a second pattern, separated by a semicolon
<span class="line-modified">3258      * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56</span>
3259      * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
3260      * a maximum of 2 fraction digits.
<span class="line-modified">3261      * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in</span>
3262      * parentheses.
3263      * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
3264      * these are presumed to be set in the positive pattern.
3265      *
3266      * @param pattern a new pattern
<span class="line-modified">3267      * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</span>
<span class="line-modified">3268      * @exception IllegalArgumentException if the given pattern is invalid.</span>
3269      */
3270     public void applyPattern(String pattern) {
3271         applyPattern(pattern, false);
3272     }
3273 
3274     /**
3275      * Apply the given pattern to this Format object.  The pattern
3276      * is assumed to be in a localized notation. A pattern is a
3277      * short-hand specification for the various formatting properties.
3278      * These properties can also be changed individually through the
3279      * various setter methods.
3280      * &lt;p&gt;
3281      * There is no limit to integer digits set
3282      * by this routine, since that is the typical end-user desire;
3283      * use setMaximumInteger if you want to set a real value.
3284      * For negative numbers, use a second pattern, separated by a semicolon
<span class="line-modified">3285      * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56</span>
3286      * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
3287      * a maximum of 2 fraction digits.
<span class="line-modified">3288      * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in</span>
3289      * parentheses.
3290      * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
3291      * these are presumed to be set in the positive pattern.
3292      *
3293      * @param pattern a new pattern
<span class="line-modified">3294      * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</span>
<span class="line-modified">3295      * @exception IllegalArgumentException if the given pattern is invalid.</span>
3296      */
3297     public void applyLocalizedPattern(String pattern) {
3298         applyPattern(pattern, true);
3299     }
3300 
3301     /**
3302      * Does the real work of applying a pattern.
3303      */
3304     private void applyPattern(String pattern, boolean localized) {
3305         char zeroDigit         = PATTERN_ZERO_DIGIT;
3306         char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
3307         char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;
3308         char percent           = PATTERN_PERCENT;
3309         char perMill           = PATTERN_PER_MILLE;
3310         char digit             = PATTERN_DIGIT;
3311         char separator         = PATTERN_SEPARATOR;
<span class="line-modified">3312         String exponent          = PATTERN_EXPONENT;</span>
3313         char minus             = PATTERN_MINUS;
3314         if (localized) {
3315             zeroDigit         = symbols.getZeroDigit();
3316             groupingSeparator = symbols.getGroupingSeparator();
3317             decimalSeparator  = symbols.getDecimalSeparator();
3318             percent           = symbols.getPercent();
3319             perMill           = symbols.getPerMill();
3320             digit             = symbols.getDigit();
3321             separator         = symbols.getPatternSeparator();
3322             exponent          = symbols.getExponentSeparator();
3323             minus             = symbols.getMinusSign();
3324         }
3325         boolean gotNegative = false;
3326         decimalSeparatorAlwaysShown = false;
3327         isCurrencyFormat = false;
3328         useExponentialNotation = false;
3329 
3330         int start = 0;
3331         for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {
3332             boolean inQuote = false;
</pre>
<hr />
<pre>
3618             setMinimumFractionDigits(0);
3619             setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
3620         }
3621 
3622         // If there was no negative pattern, or if the negative pattern is
3623         // identical to the positive pattern, then prepend the minus sign to
3624         // the positive pattern to form the negative pattern.
3625         if (!gotNegative ||
3626             (negPrefixPattern.equals(posPrefixPattern)
3627              &amp;&amp; negSuffixPattern.equals(posSuffixPattern))) {
3628             negSuffixPattern = posSuffixPattern;
3629             negPrefixPattern = &quot;&#39;-&quot; + posPrefixPattern;
3630         }
3631 
3632         expandAffixes();
3633     }
3634 
3635     /**
3636      * Sets the maximum number of digits allowed in the integer portion of a
3637      * number.
<span class="line-modified">3638      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3639      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and</span>
3640      * 309 is used. Negative input values are replaced with 0.
3641      * @see NumberFormat#setMaximumIntegerDigits
3642      */
3643     @Override
3644     public void setMaximumIntegerDigits(int newValue) {
3645         maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
3646         super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3647             DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
3648         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
3649             minimumIntegerDigits = maximumIntegerDigits;
3650             super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3651                 DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
3652         }
3653         fastPathCheckNeeded = true;
3654     }
3655 
3656     /**
3657      * Sets the minimum number of digits allowed in the integer portion of a
3658      * number.
<span class="line-modified">3659      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3660      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and</span>
3661      * 309 is used. Negative input values are replaced with 0.
3662      * @see NumberFormat#setMinimumIntegerDigits
3663      */
3664     @Override
3665     public void setMinimumIntegerDigits(int newValue) {
3666         minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
3667         super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3668             DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
3669         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
3670             maximumIntegerDigits = minimumIntegerDigits;
3671             super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3672                 DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
3673         }
3674         fastPathCheckNeeded = true;
3675     }
3676 
3677     /**
3678      * Sets the maximum number of digits allowed in the fraction portion of a
3679      * number.
<span class="line-modified">3680      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3681      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and</span>
3682      * 340 is used. Negative input values are replaced with 0.
3683      * @see NumberFormat#setMaximumFractionDigits
3684      */
3685     @Override
3686     public void setMaximumFractionDigits(int newValue) {
3687         maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
3688         super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3689             DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
3690         if (minimumFractionDigits &gt; maximumFractionDigits) {
3691             minimumFractionDigits = maximumFractionDigits;
3692             super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3693                 DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
3694         }
3695         fastPathCheckNeeded = true;
3696     }
3697 
3698     /**
3699      * Sets the minimum number of digits allowed in the fraction portion of a
3700      * number.
<span class="line-modified">3701      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3702      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and</span>
3703      * 340 is used. Negative input values are replaced with 0.
3704      * @see NumberFormat#setMinimumFractionDigits
3705      */
3706     @Override
3707     public void setMinimumFractionDigits(int newValue) {
3708         minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
3709         super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3710             DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
3711         if (minimumFractionDigits &gt; maximumFractionDigits) {
3712             maximumFractionDigits = minimumFractionDigits;
3713             super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3714                 DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
3715         }
3716         fastPathCheckNeeded = true;
3717     }
3718 
3719     /**
3720      * Gets the maximum number of digits allowed in the integer portion of a
3721      * number.
<span class="line-modified">3722      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3723      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and</span>
3724      * 309 is used.
3725      * @see #setMaximumIntegerDigits
3726      */
3727     @Override
3728     public int getMaximumIntegerDigits() {
3729         return maximumIntegerDigits;
3730     }
3731 
3732     /**
3733      * Gets the minimum number of digits allowed in the integer portion of a
3734      * number.
<span class="line-modified">3735      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3736      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and</span>
3737      * 309 is used.
3738      * @see #setMinimumIntegerDigits
3739      */
3740     @Override
3741     public int getMinimumIntegerDigits() {
3742         return minimumIntegerDigits;
3743     }
3744 
3745     /**
3746      * Gets the maximum number of digits allowed in the fraction portion of a
3747      * number.
<span class="line-modified">3748      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3749      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and</span>
3750      * 340 is used.
3751      * @see #setMaximumFractionDigits
3752      */
3753     @Override
3754     public int getMaximumFractionDigits() {
3755         return maximumFractionDigits;
3756     }
3757 
3758     /**
3759      * Gets the minimum number of digits allowed in the fraction portion of a
3760      * number.
<span class="line-modified">3761      * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3762      * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and</span>
3763      * 340 is used.
3764      * @see #setMinimumFractionDigits
3765      */
3766     @Override
3767     public int getMinimumFractionDigits() {
3768         return minimumFractionDigits;
3769     }
3770 
3771     /**
3772      * Gets the currency used by this decimal format when formatting
3773      * currency values.
3774      * The currency is obtained by calling
3775      * {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}
3776      * on this number format&#39;s symbols.
3777      *
<span class="line-modified">3778      * @return the currency used by this decimal format, or &lt;code&gt;null&lt;/code&gt;</span>
3779      * @since 1.4
3780      */
3781     @Override
3782     public Currency getCurrency() {
3783         return symbols.getCurrency();
3784     }
3785 
3786     /**
3787      * Sets the currency used by this number format when formatting
3788      * currency values. This does not update the minimum or maximum
3789      * number of fraction digits used by the number format.
3790      * The currency is set by calling
3791      * {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}
3792      * on this number format&#39;s symbols.
3793      *
3794      * @param currency the new currency to be used by this decimal format
<span class="line-modified">3795      * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</span>
3796      * @since 1.4
3797      */
3798     @Override
3799     public void setCurrency(Currency currency) {
3800         if (currency != symbols.getCurrency()) {
3801             symbols.setCurrency(currency);
3802             if (isCurrencyFormat) {
3803                 expandAffixes();
3804             }
3805         }
3806         fastPathCheckNeeded = true;
3807     }
3808 
3809     /**
3810      * Gets the {@link java.math.RoundingMode} used in this DecimalFormat.
3811      *
<span class="line-modified">3812      * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this DecimalFormat.</span>
3813      * @see #setRoundingMode(RoundingMode)
3814      * @since 1.6
3815      */
3816     @Override
3817     public RoundingMode getRoundingMode() {
3818         return roundingMode;
3819     }
3820 
3821     /**
3822      * Sets the {@link java.math.RoundingMode} used in this DecimalFormat.
3823      *
<span class="line-modified">3824      * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</span>
3825      * @see #getRoundingMode()
<span class="line-modified">3826      * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null.</span>
3827      * @since 1.6
3828      */
3829     @Override
3830     public void setRoundingMode(RoundingMode roundingMode) {
3831         if (roundingMode == null) {
3832             throw new NullPointerException();
3833         }
3834 
3835         this.roundingMode = roundingMode;
3836         digitList.setRoundingMode(roundingMode);
3837         fastPathCheckNeeded = true;
3838     }
3839 
3840     /**
3841      * Reads the default serializable fields from the stream and performs
3842      * validations and adjustments for older serialized versions. The
3843      * validations and adjustments are:
3844      * &lt;ol&gt;
3845      * &lt;li&gt;
3846      * Verify that the superclass&#39;s digit count fields correctly reflect
3847      * the limits imposed on formatting numbers other than
<span class="line-modified">3848      * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These</span>
3849      * limits are stored in the superclass for serialization compatibility
<span class="line-modified">3850      * with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and</span>
<span class="line-modified">3851      * &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.</span>
3852      * If, in the superclass, the minimum or maximum integer digit count is
<span class="line-modified">3853      * larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or</span>
3854      * maximum fraction digit count is larger than
<span class="line-modified">3855      * &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid</span>
<span class="line-modified">3856      * and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</span>
3857      * &lt;li&gt;
<span class="line-modified">3858      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize</span>
<span class="line-modified">3859      * &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVEN</span>
3860      * RoundingMode.HALF_EVEN}.  This field is new with version 4.
3861      * &lt;li&gt;
<span class="line-modified">3862      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call</span>
3863      * the setters for the minimum and maximum integer and fraction digits with
3864      * the values of the corresponding superclass getters to initialize the
3865      * fields in this class. The fields in this class are new with version 3.
3866      * &lt;li&gt;
<span class="line-modified">3867      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that</span>
3868      * the stream was written by JDK 1.1, initialize
<span class="line-modified">3869      * &lt;code&gt;useExponentialNotation&lt;/code&gt;</span>
3870      * to false, since it was not present in JDK 1.1.
3871      * &lt;li&gt;
<span class="line-modified">3872      * Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so</span>
3873      * that default serialization will work properly if this object is streamed
3874      * out again.
3875      * &lt;/ol&gt;
3876      *
3877      * &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
<span class="line-modified">3878      * &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized</span>
<span class="line-modified">3879      * to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as</span>
3880      * literal values.  This is exactly what we want, since that corresponds to
3881      * the pre-version-2 behavior.
3882      */

3883     private void readObject(ObjectInputStream stream)
3884          throws IOException, ClassNotFoundException
3885     {
3886         stream.defaultReadObject();
3887         digitList = new DigitList();
3888 
3889         // We force complete fast-path reinitialization when the instance is
3890         // deserialized. See clone() comment on fastPathCheckNeeded.
3891         fastPathCheckNeeded = true;
3892         isFastPath = false;
3893         fastPathData = null;
3894 
3895         if (serialVersionOnStream &lt; 4) {
3896             setRoundingMode(RoundingMode.HALF_EVEN);
3897         } else {
3898             setRoundingMode(getRoundingMode());
3899         }
3900 
3901         // We only need to check the maximum counts because NumberFormat
3902         // .readObject has already ensured that the maximum is greater than the
3903         // minimum count.
3904         if (super.getMaximumIntegerDigits() &gt; DOUBLE_INTEGER_DIGITS ||
3905             super.getMaximumFractionDigits() &gt; DOUBLE_FRACTION_DIGITS) {
3906             throw new InvalidObjectException(&quot;Digit count out of range&quot;);
3907         }
3908         if (serialVersionOnStream &lt; 3) {
3909             setMaximumIntegerDigits(super.getMaximumIntegerDigits());
3910             setMinimumIntegerDigits(super.getMinimumIntegerDigits());
3911             setMaximumFractionDigits(super.getMaximumFractionDigits());
3912             setMinimumFractionDigits(super.getMinimumFractionDigits());
3913         }
3914         if (serialVersionOnStream &lt; 1) {
3915             // Didn&#39;t have exponential fields
3916             useExponentialNotation = false;
3917         }






3918         serialVersionOnStream = currentSerialVersion;
3919     }
3920 
3921     //----------------------------------------------------------------------
3922     // INSTANCE VARIABLES
3923     //----------------------------------------------------------------------
3924 
3925     private transient DigitList digitList = new DigitList();
3926 
3927     /**
3928      * The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.
3929      *
3930      * @serial
3931      * @see #getPositivePrefix
3932      */
3933     private String  positivePrefix = &quot;&quot;;
3934 
3935     /**
3936      * The symbol used as a suffix when formatting positive numbers.
3937      * This is often an empty string.
</pre>
<hr />
<pre>
3943 
3944     /**
3945      * The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.
3946      *
3947      * @serial
3948      * @see #getNegativePrefix
3949      */
3950     private String  negativePrefix = &quot;-&quot;;
3951 
3952     /**
3953      * The symbol used as a suffix when formatting negative numbers.
3954      * This is often an empty string.
3955      *
3956      * @serial
3957      * @see #getNegativeSuffix
3958      */
3959     private String  negativeSuffix = &quot;&quot;;
3960 
3961     /**
3962      * The prefix pattern for non-negative numbers.  This variable corresponds
<span class="line-modified">3963      * to &lt;code&gt;positivePrefix&lt;/code&gt;.</span>
3964      *
<span class="line-modified">3965      * &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to</span>
<span class="line-modified">3966      * &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in</span>
<span class="line-modified">3967      * &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then</span>
<span class="line-modified">3968      * &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not</span>
<span class="line-modified">3969      * change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always</span>
<span class="line-modified">3970      * &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than</span>
3971      * stream version 2 restored from stream.
3972      *
3973      * @serial
3974      * @since 1.3
3975      */
3976     private String posPrefixPattern;
3977 
3978     /**
3979      * The suffix pattern for non-negative numbers.  This variable corresponds
<span class="line-modified">3980      * to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to</span>
<span class="line-modified">3981      * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further</span>
3982      * documentation.
3983      *
3984      * @serial
3985      * @since 1.3
3986      */
3987     private String posSuffixPattern;
3988 
3989     /**
3990      * The prefix pattern for negative numbers.  This variable corresponds
<span class="line-modified">3991      * to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to</span>
<span class="line-modified">3992      * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further</span>
3993      * documentation.
3994      *
3995      * @serial
3996      * @since 1.3
3997      */
3998     private String negPrefixPattern;
3999 
4000     /**
4001      * The suffix pattern for negative numbers.  This variable corresponds
<span class="line-modified">4002      * to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to</span>
<span class="line-modified">4003      * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further</span>
4004      * documentation.
4005      *
4006      * @serial
4007      * @since 1.3
4008      */
4009     private String negSuffixPattern;
4010 
4011     /**
4012      * The multiplier for use in percent, per mille, etc.
4013      *
4014      * @serial
4015      * @see #getMultiplier
4016      */
4017     private int     multiplier = 1;
4018 
4019     /**
4020      * The number of digits between grouping separators in the integer
<span class="line-modified">4021      * portion of a number.  Must be greater than 0 if</span>
<span class="line-modified">4022      * &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.</span>

4023      *
4024      * @serial
4025      * @see #getGroupingSize
4026      * @see java.text.NumberFormat#isGroupingUsed
4027      */
<span class="line-modified">4028     private byte    groupingSize = 3;  // invariant, &gt; 0 if useThousands</span>
4029 
4030     /**
4031      * If true, forces the decimal separator to always appear in a formatted
4032      * number, even if the fractional part of the number is zero.
4033      *
4034      * @serial
4035      * @see #isDecimalSeparatorAlwaysShown
4036      */
4037     private boolean decimalSeparatorAlwaysShown = false;
4038 
4039     /**
4040      * If true, parse returns BigDecimal wherever possible.
4041      *
4042      * @serial
4043      * @see #isParseBigDecimal
4044      * @since 1.5
4045      */
4046     private boolean parseBigDecimal = false;
4047 
4048 
4049     /**
4050      * True if this object represents a currency format.  This determines
<span class="line-modified">4051      * whether the monetary decimal separator is used instead of the normal one.</span>
4052      */
4053     private transient boolean isCurrencyFormat = false;
4054 
4055     /**
<span class="line-modified">4056      * The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.</span>
4057      * It contains the symbols used to format numbers, e.g. the grouping separator,
4058      * decimal separator, and so on.
4059      *
4060      * @serial
4061      * @see #setDecimalFormatSymbols
4062      * @see java.text.DecimalFormatSymbols
4063      */
4064     private DecimalFormatSymbols symbols = null; // LIU new DecimalFormatSymbols();
4065 
4066     /**
4067      * True to force the use of exponential (i.e. scientific) notation when formatting
4068      * numbers.
4069      *
4070      * @serial
4071      * @since 1.2
4072      */
4073     private boolean useExponentialNotation;  // Newly persistent in the Java 2 platform v.1.2
4074 
4075     /**
4076      * FieldPositions describing the positive prefix String. This is
<span class="line-modified">4077      * lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;</span>
4078      * when needed.
4079      */
4080     private transient FieldPosition[] positivePrefixFieldPositions;
4081 
4082     /**
4083      * FieldPositions describing the positive suffix String. This is
<span class="line-modified">4084      * lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;</span>
4085      * when needed.
4086      */
4087     private transient FieldPosition[] positiveSuffixFieldPositions;
4088 
4089     /**
4090      * FieldPositions describing the negative prefix String. This is
<span class="line-modified">4091      * lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;</span>
4092      * when needed.
4093      */
4094     private transient FieldPosition[] negativePrefixFieldPositions;
4095 
4096     /**
4097      * FieldPositions describing the negative suffix String. This is
<span class="line-modified">4098      * lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;</span>
4099      * when needed.
4100      */
4101     private transient FieldPosition[] negativeSuffixFieldPositions;
4102 
4103     /**
4104      * The minimum number of digits used to display the exponent when a number is
4105      * formatted in exponential notation.  This field is ignored if
<span class="line-modified">4106      * &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.</span>
4107      *
4108      * @serial
4109      * @since 1.2
4110      */
4111     private byte    minExponentDigits;       // Newly persistent in the Java 2 platform v.1.2
4112 
4113     /**
4114      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">4115      * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.</span>
<span class="line-modified">4116      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">4117      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</span>
4118      *
4119      * @serial
4120      * @see #getMaximumIntegerDigits
4121      * @since 1.5
4122      */
4123     private int    maximumIntegerDigits = super.getMaximumIntegerDigits();
4124 
4125     /**
4126      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">4127      * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.</span>
<span class="line-modified">4128      * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">4129      * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.</span>
4130      *
4131      * @serial
4132      * @see #getMinimumIntegerDigits
4133      * @since 1.5
4134      */
4135     private int    minimumIntegerDigits = super.getMinimumIntegerDigits();
4136 
4137     /**
4138      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">4139      * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.</span>
<span class="line-modified">4140      * &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to</span>
<span class="line-modified">4141      * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.</span>
4142      *
4143      * @serial
4144      * @see #getMaximumFractionDigits
4145      * @since 1.5
4146      */
4147     private int    maximumFractionDigits = super.getMaximumFractionDigits();
4148 
4149     /**
4150      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">4151      * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.</span>
<span class="line-modified">4152      * &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to</span>
<span class="line-modified">4153      * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.</span>
4154      *
4155      * @serial
4156      * @see #getMinimumFractionDigits
4157      * @since 1.5
4158      */
4159     private int    minimumFractionDigits = super.getMinimumFractionDigits();
4160 
4161     /**
4162      * The {@link java.math.RoundingMode} used in this DecimalFormat.
4163      *
4164      * @serial
4165      * @since 1.6
4166      */
4167     private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
4168 
4169     // ------ DecimalFormat fields for fast-path for double algorithm  ------
4170 
4171     /**
4172      * Helper inner utility class for storing the data used in the fast-path
4173      * algorithm. Almost all fields related to fast-path are encapsulated in
</pre>
<hr />
<pre>
4230     /** The format fast-path status of the instance. Logical state. */
4231     private transient boolean isFastPath = false;
4232 
4233     /** Flag stating need of check and reinit fast-path status on next format call. */
4234     private transient boolean fastPathCheckNeeded = true;
4235 
4236     /** DecimalFormat reference to its FastPathData */
4237     private transient FastPathData fastPathData;
4238 
4239 
4240     //----------------------------------------------------------------------
4241 
4242     static final int currentSerialVersion = 4;
4243 
4244     /**
4245      * The internal serial version which says which version was written.
4246      * Possible values are:
4247      * &lt;ul&gt;
4248      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
4249      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
<span class="line-modified">4250      *      &lt;code&gt;useExponentialNotation&lt;/code&gt; and</span>
<span class="line-modified">4251      *      &lt;code&gt;minExponentDigits&lt;/code&gt;.</span>
4252      * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
<span class="line-modified">4253      *      &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,</span>
<span class="line-modified">4254      *      &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.</span>
4255      * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
<span class="line-modified">4256      *      &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,</span>
<span class="line-modified">4257      *      &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,</span>
<span class="line-modified">4258      *      &lt;code&gt;maximumFractionDigits&lt;/code&gt;,</span>
<span class="line-modified">4259      *      &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and</span>
<span class="line-modified">4260      *      &lt;code&gt;parseBigDecimal&lt;/code&gt;.</span>
4261      * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
<span class="line-modified">4262      *      &lt;code&gt;roundingMode&lt;/code&gt;.</span>
4263      * &lt;/ul&gt;
4264      * @since 1.2
4265      * @serial
4266      */
4267     private int serialVersionOnStream = currentSerialVersion;
4268 
4269     //----------------------------------------------------------------------
4270     // CONSTANTS
4271     //----------------------------------------------------------------------
4272 
4273     // ------ Fast-Path for double Constants ------
4274 
4275     /** Maximum valid integer value for applying fast-path algorithm */
4276     private static final double MAX_INT_AS_DOUBLE = (double) Integer.MAX_VALUE;
4277 
4278     /**
4279      * The digit arrays used in the fast-path methods for collecting digits.
4280      * Using 3 constants arrays of chars ensures a very fast collection of digits
4281      */
4282     private static class DigitArrays {
</pre>
<hr />
<pre>
4316             }
4317         }
4318     }
4319     // ------ Fast-Path for double Constants end ------
4320 
4321     // Constants for characters used in programmatic (unlocalized) patterns.
4322     private static final char       PATTERN_ZERO_DIGIT         = &#39;0&#39;;
4323     private static final char       PATTERN_GROUPING_SEPARATOR = &#39;,&#39;;
4324     private static final char       PATTERN_DECIMAL_SEPARATOR  = &#39;.&#39;;
4325     private static final char       PATTERN_PER_MILLE          = &#39;\u2030&#39;;
4326     private static final char       PATTERN_PERCENT            = &#39;%&#39;;
4327     private static final char       PATTERN_DIGIT              = &#39;#&#39;;
4328     private static final char       PATTERN_SEPARATOR          = &#39;;&#39;;
4329     private static final String     PATTERN_EXPONENT           = &quot;E&quot;;
4330     private static final char       PATTERN_MINUS              = &#39;-&#39;;
4331 
4332     /**
4333      * The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
4334      * is used in patterns and substituted with either the currency symbol,
4335      * or if it is doubled, with the international currency symbol.  If the
<span class="line-modified">4336      * CURRENCY_SIGN is seen in a pattern, then the decimal separator is</span>
<span class="line-modified">4337      * replaced with the monetary decimal separator.</span>
4338      *
4339      * The CURRENCY_SIGN is not localized.
4340      */
4341     private static final char       CURRENCY_SIGN = &#39;\u00A4&#39;;
4342 
4343     private static final char       QUOTE = &#39;\&#39;&#39;;
4344 
4345     private static FieldPosition[] EmptyFieldPositionArray = new FieldPosition[0];
4346 
4347     // Upper limit on integer and fraction digits for a Java double
4348     static final int DOUBLE_INTEGER_DIGITS  = 309;
4349     static final int DOUBLE_FRACTION_DIGITS = 340;
4350 
4351     // Upper limit on integer and fraction digits for BigDecimal and BigInteger
4352     static final int MAXIMUM_INTEGER_DIGITS  = Integer.MAX_VALUE;
4353     static final int MAXIMUM_FRACTION_DIGITS = Integer.MAX_VALUE;
4354 
4355     // Proclaim JDK 1.1 serial compatibility.

4356     static final long serialVersionUID = 864413376551465018L;
4357 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.IOException;
  42 import java.io.InvalidObjectException;
  43 import java.io.ObjectInputStream;
  44 import java.math.BigDecimal;
  45 import java.math.BigInteger;
  46 import java.math.RoundingMode;
  47 import java.text.spi.NumberFormatProvider;
  48 import java.util.ArrayList;
  49 import java.util.Currency;
  50 import java.util.Locale;
  51 import java.util.concurrent.atomic.AtomicInteger;
  52 import java.util.concurrent.atomic.AtomicLong;
  53 import sun.util.locale.provider.LocaleProviderAdapter;
  54 import sun.util.locale.provider.ResourceBundleBasedAdapter;
  55 
  56 /**
<span class="line-modified">  57  * {@code DecimalFormat} is a concrete subclass of</span>
<span class="line-modified">  58  * {@code NumberFormat} that formats decimal numbers. It has a variety of</span>
  59  * features designed to make it possible to parse and format numbers in any
  60  * locale, including support for Western, Arabic, and Indic digits.  It also
  61  * supports different kinds of numbers, including integers (123), fixed-point
  62  * numbers (123.4), scientific notation (1.23E4), percentages (12%), and
  63  * currency amounts ($123).  All of these can be localized.
  64  *
<span class="line-modified">  65  * &lt;p&gt;To obtain a {@code NumberFormat} for a specific locale, including the</span>
<span class="line-modified">  66  * default locale, call one of {@code NumberFormat}&#39;s factory methods, such</span>
<span class="line-modified">  67  * as {@code getInstance()}.  In general, do not call the</span>
<span class="line-modified">  68  * {@code DecimalFormat} constructors directly, since the</span>
<span class="line-modified">  69  * {@code NumberFormat} factory methods may return subclasses other than</span>
<span class="line-modified">  70  * {@code DecimalFormat}. If you need to customize the format object, do</span>
  71  * something like this:
  72  *
  73  * &lt;blockquote&gt;&lt;pre&gt;
  74  * NumberFormat f = NumberFormat.getInstance(loc);
  75  * if (f instanceof DecimalFormat) {
  76  *     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
  77  * }
  78  * &lt;/pre&gt;&lt;/blockquote&gt;
  79  *
<span class="line-modified">  80  * &lt;p&gt;A {@code DecimalFormat} comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of</span>
  81  * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
<span class="line-modified">  82  * {@code applyPattern()}, or indirectly using the API methods.  The</span>
<span class="line-modified">  83  * symbols are stored in a {@code DecimalFormatSymbols} object.  When using</span>
<span class="line-modified">  84  * the {@code NumberFormat} factory methods, the pattern and symbols are</span>
<span class="line-modified">  85  * read from localized {@code ResourceBundle}s.</span>
  86  *
<span class="line-modified">  87  * &lt;h2&gt;Patterns&lt;/h2&gt;</span>
  88  *
<span class="line-modified">  89  * {@code DecimalFormat} patterns have the following syntax:</span>
  90  * &lt;blockquote&gt;&lt;pre&gt;
  91  * &lt;i&gt;Pattern:&lt;/i&gt;
  92  *         &lt;i&gt;PositivePattern&lt;/i&gt;
  93  *         &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
  94  * &lt;i&gt;PositivePattern:&lt;/i&gt;
  95  *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
  96  * &lt;i&gt;NegativePattern:&lt;/i&gt;
  97  *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
  98  * &lt;i&gt;Prefix:&lt;/i&gt;
  99  *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 100  * &lt;i&gt;Suffix:&lt;/i&gt;
 101  *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 102  * &lt;i&gt;Number:&lt;/i&gt;
 103  *         &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 104  *         &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 105  * &lt;i&gt;Integer:&lt;/i&gt;
 106  *         &lt;i&gt;MinimumInteger&lt;/i&gt;
 107  *         #
 108  *         # &lt;i&gt;Integer&lt;/i&gt;
 109  *         # , &lt;i&gt;Integer&lt;/i&gt;
 110  * &lt;i&gt;MinimumInteger:&lt;/i&gt;
 111  *         0
 112  *         0 &lt;i&gt;MinimumInteger&lt;/i&gt;
 113  *         0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
 114  * &lt;i&gt;Fraction:&lt;/i&gt;
 115  *         &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 116  * &lt;i&gt;MinimumFraction:&lt;/i&gt;
 117  *         0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 118  * &lt;i&gt;OptionalFraction:&lt;/i&gt;
 119  *         # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 120  * &lt;i&gt;Exponent:&lt;/i&gt;
 121  *         E &lt;i&gt;MinimumExponent&lt;/i&gt;
 122  * &lt;i&gt;MinimumExponent:&lt;/i&gt;
 123  *         0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 124  * &lt;/pre&gt;&lt;/blockquote&gt;
 125  *
<span class="line-modified"> 126  * &lt;p&gt;A {@code DecimalFormat} pattern contains a positive and negative</span>
<span class="line-modified"> 127  * subpattern, for example, {@code &quot;#,##0.00;(#,##0.00)&quot;}.  Each</span>
 128  * subpattern has a prefix, numeric part, and suffix. The negative subpattern
 129  * is optional; if absent, then the positive subpattern prefixed with the
<span class="line-modified"> 130  * localized minus sign ({@code &#39;-&#39;} in most locales) is used as the</span>
<span class="line-modified"> 131  * negative subpattern. That is, {@code &quot;0.00&quot;} alone is equivalent to</span>
<span class="line-modified"> 132  * {@code &quot;0.00;-0.00&quot;}.  If there is an explicit negative subpattern, it</span>
 133  * serves only to specify the negative prefix and suffix; the number of digits,
 134  * minimal digits, and other characteristics are all the same as the positive
<span class="line-modified"> 135  * pattern. That means that {@code &quot;#,##0.0#;(#)&quot;} produces precisely</span>
<span class="line-modified"> 136  * the same behavior as {@code &quot;#,##0.0#;(#,##0.0#)&quot;}.</span>
 137  *
 138  * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
<span class="line-modified"> 139  * grouping separators, decimal separators, etc. may be set to arbitrary</span>
 140  * values, and they will appear properly during formatting.  However, care must
 141  * be taken that the symbols and strings do not conflict, or parsing will be
 142  * unreliable.  For example, either the positive and negative prefixes or the
<span class="line-modified"> 143  * suffixes must be distinct for {@code DecimalFormat.parse()} to be able</span>
 144  * to distinguish positive from negative values.  (If they are identical, then
<span class="line-modified"> 145  * {@code DecimalFormat} will behave as if no negative subpattern was</span>
<span class="line-modified"> 146  * specified.)  Another example is that the decimal separator and grouping</span>
 147  * separator should be distinct characters, or parsing will be impossible.
 148  *
 149  * &lt;p&gt;The grouping separator is commonly used for thousands, but in some
 150  * countries it separates ten-thousands. The grouping size is a constant number
 151  * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
 152  * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the
 153  * interval between the last one and the end of the integer is the one that is
<span class="line-modified"> 154  * used. So {@code &quot;#,##,###,####&quot;} == {@code &quot;######,####&quot;} ==</span>
<span class="line-modified"> 155  * {@code &quot;##,####,####&quot;}.</span>
 156  *
<span class="line-modified"> 157  * &lt;h3&gt;&lt;a id=&quot;special_pattern_character&quot;&gt;Special Pattern Characters&lt;/a&gt;&lt;/h3&gt;</span>
 158  *
 159  * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 160  * parsing and output unchanged during formatting.  Special characters, on the
 161  * other hand, stand for other characters, strings, or classes of characters.
 162  * They must be quoted, unless noted otherwise, if they are to appear in the
 163  * prefix or suffix as literals.
 164  *
 165  * &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
 166  * patterns use the corresponding characters taken from this formatter&#39;s
<span class="line-modified"> 167  * {@code DecimalFormatSymbols} object instead, and these characters lose</span>
 168  * their special status.  Two exceptions are the currency sign and quote, which
 169  * are not localized.
 170  *
 171  * &lt;blockquote&gt;
 172  * &lt;table class=&quot;striped&quot;&gt;
 173  * &lt;caption style=&quot;display:none&quot;&gt;Chart showing symbol, location, localized, and meaning.&lt;/caption&gt;
 174  * &lt;thead&gt;
 175  *     &lt;tr&gt;
 176  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Symbol
 177  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Location
 178  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Localized?
 179  *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Meaning
 180  * &lt;/thead&gt;
 181  * &lt;tbody&gt;
 182  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 183  *          &lt;th scope=&quot;row&quot;&gt;{@code 0}</span>
 184  *          &lt;td&gt;Number
 185  *          &lt;td&gt;Yes
 186  *          &lt;td&gt;Digit
 187  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 188  *          &lt;th scope=&quot;row&quot;&gt;{@code #}</span>
 189  *          &lt;td&gt;Number
 190  *          &lt;td&gt;Yes
 191  *          &lt;td&gt;Digit, zero shows as absent
 192  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 193  *          &lt;th scope=&quot;row&quot;&gt;{@code .}</span>
 194  *          &lt;td&gt;Number
 195  *          &lt;td&gt;Yes
 196  *          &lt;td&gt;Decimal separator or monetary decimal separator
 197  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 198  *          &lt;th scope=&quot;row&quot;&gt;{@code -}</span>
 199  *          &lt;td&gt;Number
 200  *          &lt;td&gt;Yes
 201  *          &lt;td&gt;Minus sign
 202  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 203  *          &lt;th scope=&quot;row&quot;&gt;{@code ,}</span>
 204  *          &lt;td&gt;Number
 205  *          &lt;td&gt;Yes
<span class="line-modified"> 206  *          &lt;td&gt;Grouping separator or monetary grouping separator</span>
 207  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 208  *          &lt;th scope=&quot;row&quot;&gt;{@code E}</span>
 209  *          &lt;td&gt;Number
 210  *          &lt;td&gt;Yes
 211  *          &lt;td&gt;Separates mantissa and exponent in scientific notation.
 212  *              &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
 213  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 214  *          &lt;th scope=&quot;row&quot;&gt;{@code ;}</span>
 215  *          &lt;td&gt;Subpattern boundary
 216  *          &lt;td&gt;Yes
 217  *          &lt;td&gt;Separates positive and negative subpatterns
 218  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 219  *          &lt;th scope=&quot;row&quot;&gt;{@code %}</span>
 220  *          &lt;td&gt;Prefix or suffix
 221  *          &lt;td&gt;Yes
 222  *          &lt;td&gt;Multiply by 100 and show as percentage
 223  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 224  *          &lt;th scope=&quot;row&quot;&gt;{@code &amp;#92;u2030}</span>
 225  *          &lt;td&gt;Prefix or suffix
 226  *          &lt;td&gt;Yes
 227  *          &lt;td&gt;Multiply by 1000 and show as per mille value
 228  *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<span class="line-modified"> 229  *          &lt;th scope=&quot;row&quot;&gt;{@code &amp;#164;} ({@code &amp;#92;u00A4})</span>
 230  *          &lt;td&gt;Prefix or suffix
 231  *          &lt;td&gt;No
 232  *          &lt;td&gt;Currency sign, replaced by currency symbol.  If
 233  *              doubled, replaced by international currency symbol.
<span class="line-modified"> 234  *              If present in a pattern, the monetary decimal/grouping separators</span>
<span class="line-modified"> 235  *              are used instead of the decimal/grouping separators.</span>
 236  *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<span class="line-modified"> 237  *          &lt;th scope=&quot;row&quot;&gt;{@code &#39;}</span>
 238  *          &lt;td&gt;Prefix or suffix
 239  *          &lt;td&gt;No
 240  *          &lt;td&gt;Used to quote special characters in a prefix or suffix,
<span class="line-modified"> 241  *              for example, {@code &quot;&#39;#&#39;#&quot;} formats 123 to</span>
<span class="line-modified"> 242  *              {@code &quot;#123&quot;}.  To create a single quote</span>
<span class="line-modified"> 243  *              itself, use two in a row: {@code &quot;# o&#39;&#39;clock&quot;}.</span>
 244  * &lt;/tbody&gt;
 245  * &lt;/table&gt;
 246  * &lt;/blockquote&gt;
 247  *
<span class="line-modified"> 248  * &lt;h3&gt;Scientific Notation&lt;/h3&gt;</span>
 249  *
 250  * &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
 251  * and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
 252  * mantissa is often in the range 1.0 &amp;le; x {@literal &lt;} 10.0, but it need not
 253  * be.
<span class="line-modified"> 254  * {@code DecimalFormat} can be instructed to format and parse scientific</span>
 255  * notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
 256  * that creates a scientific notation format.  In a pattern, the exponent
 257  * character immediately followed by one or more digit characters indicates
<span class="line-modified"> 258  * scientific notation.  Example: {@code &quot;0.###E0&quot;} formats the number</span>
<span class="line-modified"> 259  * 1234 as {@code &quot;1.234E3&quot;}.</span>
 260  *
 261  * &lt;ul&gt;
 262  * &lt;li&gt;The number of digit characters after the exponent character gives the
 263  * minimum exponent digit count.  There is no maximum.  Negative exponents are
 264  * formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
<span class="line-modified"> 265  * from the pattern.  This allows patterns such as {@code &quot;0.###E0 m/s&quot;}.</span>
 266  *
 267  * &lt;li&gt;The minimum and maximum number of integer digits are interpreted
 268  * together:
 269  *
 270  * &lt;ul&gt;
 271  * &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
 272  * and greater than 1, it forces the exponent to be a multiple of the maximum
 273  * number of integer digits, and the minimum number of integer digits to be
 274  * interpreted as 1.  The most common use of this is to generate
 275  * &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
<span class="line-modified"> 276  * e.g., {@code &quot;##0.#####E0&quot;}. Using this pattern, the number 12345</span>
<span class="line-modified"> 277  * formats to {@code &quot;12.345E3&quot;}, and 123456 formats to</span>
<span class="line-modified"> 278  * {@code &quot;123.456E3&quot;}.</span>
 279  *
 280  * &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
<span class="line-modified"> 281  * exponent.  Example: 0.00123 formatted with {@code &quot;00.###E0&quot;} yields</span>
<span class="line-modified"> 282  * {@code &quot;12.3E-4&quot;}.</span>
 283  * &lt;/ul&gt;
 284  *
 285  * &lt;li&gt;The number of significant digits in the mantissa is the sum of the
 286  * &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
 287  * unaffected by the maximum integer digits.  For example, 12345 formatted with
<span class="line-modified"> 288  * {@code &quot;##0.##E0&quot;} is {@code &quot;12.3E3&quot;}. To show all digits, set</span>
 289  * the significant digits count to zero.  The number of significant digits
 290  * does not affect parsing.
 291  *
 292  * &lt;li&gt;Exponential patterns may not contain grouping separators.
 293  * &lt;/ul&gt;
 294  *
<span class="line-modified"> 295  * &lt;h3&gt;Rounding&lt;/h3&gt;</span>
 296  *
<span class="line-modified"> 297  * {@code DecimalFormat} provides rounding modes defined in</span>
 298  * {@link java.math.RoundingMode} for formatting.  By default, it uses
 299  * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
 300  *
<span class="line-modified"> 301  * &lt;h3&gt;Digits&lt;/h3&gt;</span>
 302  *
<span class="line-modified"> 303  * For formatting, {@code DecimalFormat} uses the ten consecutive</span>
 304  * characters starting with the localized zero digit defined in the
<span class="line-modified"> 305  * {@code DecimalFormatSymbols} object as digits. For parsing, these</span>
 306  * digits as well as all Unicode decimal digits, as defined by
 307  * {@link Character#digit Character.digit}, are recognized.
 308  *
 309  * &lt;h4&gt;Special Values&lt;/h4&gt;
 310  *
<span class="line-modified"> 311  * &lt;p&gt;{@code NaN} is formatted as a string, which typically has a single character</span>
<span class="line-modified"> 312  * {@code &amp;#92;uFFFD}.  This string is determined by the</span>
<span class="line-modified"> 313  * {@code DecimalFormatSymbols} object.  This is the only value for which</span>
 314  * the prefixes and suffixes are not used.
 315  *
 316  * &lt;p&gt;Infinity is formatted as a string, which typically has a single character
<span class="line-modified"> 317  * {@code &amp;#92;u221E}, with the positive or negative prefixes and suffixes</span>
 318  * applied.  The infinity string is determined by the
<span class="line-modified"> 319  * {@code DecimalFormatSymbols} object.</span>
 320  *
<span class="line-modified"> 321  * &lt;p&gt;Negative zero ({@code &quot;-0&quot;}) parses to</span>
 322  * &lt;ul&gt;
<span class="line-modified"> 323  * &lt;li&gt;{@code BigDecimal(0)} if {@code isParseBigDecimal()} is</span>
 324  * true,
<span class="line-modified"> 325  * &lt;li&gt;{@code Long(0)} if {@code isParseBigDecimal()} is false</span>
<span class="line-modified"> 326  *     and {@code isParseIntegerOnly()} is true,</span>
<span class="line-modified"> 327  * &lt;li&gt;{@code Double(-0.0)} if both {@code isParseBigDecimal()}</span>
<span class="line-modified"> 328  * and {@code isParseIntegerOnly()} are false.</span>
 329  * &lt;/ul&gt;
 330  *
<span class="line-modified"> 331  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 332  *
 333  * &lt;p&gt;
 334  * Decimal formats are generally not synchronized.
 335  * It is recommended to create separate format instances for each thread.
 336  * If multiple threads access a format concurrently, it must be synchronized
 337  * externally.
 338  *
<span class="line-modified"> 339  * &lt;h3&gt;Example&lt;/h3&gt;</span>
 340  *
 341  * &lt;blockquote&gt;&lt;pre&gt;{@code
 342  * &lt;strong&gt;// Print out a number using the localized number, integer, currency,
 343  * // and percent format for each locale&lt;/strong&gt;
 344  * Locale[] locales = NumberFormat.getAvailableLocales();
 345  * double myNumber = -1234.56;
 346  * NumberFormat form;
 347  * for (int j = 0; j &lt; 4; ++j) {
 348  *     System.out.println(&quot;FORMAT&quot;);
 349  *     for (int i = 0; i &lt; locales.length; ++i) {
 350  *         if (locales[i].getCountry().length() == 0) {
 351  *            continue; // Skip language-only locales
 352  *         }
 353  *         System.out.print(locales[i].getDisplayName());
 354  *         switch (j) {
 355  *         case 0:
 356  *             form = NumberFormat.getInstance(locales[i]); break;
 357  *         case 1:
 358  *             form = NumberFormat.getIntegerInstance(locales[i]); break;
 359  *         case 2:
</pre>
<hr />
<pre>
 408         String[] all = adapter.getLocaleResources(def).getNumberPatterns();
 409 
 410         // Always applyPattern after the symbols are set
 411         this.symbols = DecimalFormatSymbols.getInstance(def);
 412         applyPattern(all[0], false);
 413     }
 414 
 415 
 416     /**
 417      * Creates a DecimalFormat using the given pattern and the symbols
 418      * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 419      * This is a convenient way to obtain a
 420      * DecimalFormat when internationalization is not the main concern.
 421      * &lt;p&gt;
 422      * To obtain standard formats for a given locale, use the factory methods
 423      * on NumberFormat such as getNumberInstance. These factories will
 424      * return the most appropriate sub-class of NumberFormat for a given
 425      * locale.
 426      *
 427      * @param pattern a non-localized pattern string.
<span class="line-modified"> 428      * @throws    NullPointerException if {@code pattern} is null</span>
<span class="line-modified"> 429      * @throws    IllegalArgumentException if the given pattern is invalid.</span>
 430      * @see java.text.NumberFormat#getInstance
 431      * @see java.text.NumberFormat#getNumberInstance
 432      * @see java.text.NumberFormat#getCurrencyInstance
 433      * @see java.text.NumberFormat#getPercentInstance
 434      */
 435     public DecimalFormat(String pattern) {
 436         // Always applyPattern after the symbols are set
 437         this.symbols = DecimalFormatSymbols.getInstance(Locale.getDefault(Locale.Category.FORMAT));
 438         applyPattern(pattern, false);
 439     }
 440 
 441 
 442     /**
 443      * Creates a DecimalFormat using the given pattern and symbols.
 444      * Use this constructor when you need to completely customize the
 445      * behavior of the format.
 446      * &lt;p&gt;
 447      * To obtain standard formats for a given
 448      * locale, use the factory methods on NumberFormat such as
 449      * getInstance or getCurrencyInstance. If you need only minor adjustments
 450      * to a standard format, you can modify the format returned by
 451      * a NumberFormat factory method.
 452      *
 453      * @param pattern a non-localized pattern string
 454      * @param symbols the set of symbols to be used
<span class="line-modified"> 455      * @throws    NullPointerException if any of the given arguments is null</span>
<span class="line-modified"> 456      * @throws    IllegalArgumentException if the given pattern is invalid</span>
 457      * @see java.text.NumberFormat#getInstance
 458      * @see java.text.NumberFormat#getNumberInstance
 459      * @see java.text.NumberFormat#getCurrencyInstance
 460      * @see java.text.NumberFormat#getPercentInstance
 461      * @see java.text.DecimalFormatSymbols
 462      */
 463     public DecimalFormat (String pattern, DecimalFormatSymbols symbols) {
 464         // Always applyPattern after the symbols are set
 465         this.symbols = (DecimalFormatSymbols)symbols.clone();
 466         applyPattern(pattern, false);
 467     }
 468 
 469 
 470     // Overrides
 471     /**
 472      * Formats a number and appends the resulting text to the given string
 473      * buffer.
 474      * The number can be of any subclass of {@link java.lang.Number}.
 475      * &lt;p&gt;
 476      * This implementation uses the maximum precision permitted.
 477      * @param number     the number to format
<span class="line-modified"> 478      * @param toAppendTo the {@code StringBuffer} to which the formatted</span>
 479      *                   text is to be appended
 480      * @param pos        keeps track on the position of the field within the
 481      *                   returned string. For example, for formatting a number
 482      *                   {@code 1234567.89} in {@code Locale.US} locale,
 483      *                   if the given {@code fieldPosition} is
 484      *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
 485      *                   and end index of {@code fieldPosition} will be set
 486      *                   to 0 and 9, respectively for the output string
 487      *                   {@code 1,234,567.89}.
<span class="line-modified"> 488      * @return           the value passed in as {@code toAppendTo}</span>
<span class="line-modified"> 489      * @throws           IllegalArgumentException if {@code number} is</span>
<span class="line-modified"> 490      *                   null or not an instance of {@code Number}.</span>
<span class="line-modified"> 491      * @throws           NullPointerException if {@code toAppendTo} or</span>
<span class="line-modified"> 492      *                   {@code pos} is null</span>
<span class="line-modified"> 493      * @throws           ArithmeticException if rounding is needed with rounding</span>
 494      *                   mode being set to RoundingMode.UNNECESSARY
 495      * @see              java.text.FieldPosition
 496      */
 497     @Override
 498     public final StringBuffer format(Object number,
 499                                      StringBuffer toAppendTo,
 500                                      FieldPosition pos) {
 501         if (number instanceof Long || number instanceof Integer ||
 502                    number instanceof Short || number instanceof Byte ||
 503                    number instanceof AtomicInteger ||
 504                    number instanceof AtomicLong ||
 505                    (number instanceof BigInteger &amp;&amp;
 506                     ((BigInteger)number).bitLength () &lt; 64)) {
 507             return format(((Number)number).longValue(), toAppendTo, pos);
 508         } else if (number instanceof BigDecimal) {
 509             return format((BigDecimal)number, toAppendTo, pos);
 510         } else if (number instanceof BigInteger) {
 511             return format((BigInteger)number, toAppendTo, pos);
 512         } else if (number instanceof Number) {
 513             return format(((Number)number).doubleValue(), toAppendTo, pos);
 514         } else {
 515             throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
 516         }
 517     }
 518 
 519     /**
 520      * Formats a double to produce a string.
 521      * @param number    The double to format
 522      * @param result    where the text is to be appended
 523      * @param fieldPosition    keeps track on the position of the field within
 524      *                         the returned string. For example, for formatting
 525      *                         a number {@code 1234567.89} in {@code Locale.US}
 526      *                         locale, if the given {@code fieldPosition} is
 527      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 528      *                         and end index of {@code fieldPosition} will be set
 529      *                         to 0 and 9, respectively for the output string
 530      *                         {@code 1,234,567.89}.
<span class="line-modified"> 531      * @throws    NullPointerException if {@code result} or</span>
 532      *            {@code fieldPosition} is {@code null}
<span class="line-modified"> 533      * @throws    ArithmeticException if rounding is needed with rounding</span>
 534      *            mode being set to RoundingMode.UNNECESSARY
 535      * @return The formatted number string
 536      * @see java.text.FieldPosition
 537      */
 538     @Override
 539     public StringBuffer format(double number, StringBuffer result,
 540                                FieldPosition fieldPosition) {
 541         // If fieldPosition is a DontCareFieldPosition instance we can
 542         // try to go to fast-path code.
 543         boolean tryFastPath = false;
 544         if (fieldPosition == DontCareFieldPosition.INSTANCE)
 545             tryFastPath = true;
 546         else {
 547             fieldPosition.setBeginIndex(0);
 548             fieldPosition.setEndIndex(0);
 549         }
 550 
 551         if (tryFastPath) {
 552             String tempResult = fastFormat(number);
 553             if (tempResult != null) {
 554                 result.append(tempResult);
 555                 return result;
 556             }
 557         }
 558 
 559         // if fast-path could not work, we fallback to standard code.
 560         return format(number, result, fieldPosition.getFieldDelegate());
 561     }
 562 
 563     /**
 564      * Formats a double to produce a string.
 565      * @param number    The double to format
 566      * @param result    where the text is to be appended
 567      * @param delegate notified of locations of sub fields
<span class="line-modified"> 568      * @throws          ArithmeticException if rounding is needed with rounding</span>
 569      *                  mode being set to RoundingMode.UNNECESSARY
 570      * @return The formatted number string
 571      */
 572     StringBuffer format(double number, StringBuffer result,
 573                                 FieldDelegate delegate) {
 574 
 575         boolean nanOrInfinity = handleNaN(number, result, delegate);
 576         if (nanOrInfinity) {
 577             return result;
 578         }
 579 
 580         /* Detecting whether a double is negative is easy with the exception of
 581          * the value -0.0.  This is a double which has a zero mantissa (and
 582          * exponent), but a negative sign bit.  It is semantically distinct from
 583          * a zero with a positive sign bit, and this distinction is important
 584          * to certain kinds of computations.  However, it&#39;s a little tricky to
 585          * detect, since (-0.0 == 0.0) and !(-0.0 &lt; 0.0).  How then, you may
 586          * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==
 587          * -Infinity.  Proper detection of -0.0 is needed to deal with the
 588          * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.
</pre>
<hr />
<pre>
 681             digitList.set(isNegative, number, useExponentialNotation
 682                     ? maxIntDigits + maxFraDigits : maxFraDigits,
 683                     !useExponentialNotation);
 684             return subformat(result, delegate, isNegative, false,
 685                     maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 686         }
 687     }
 688 
 689     /**
 690      * Format a long to produce a string.
 691      * @param number    The long to format
 692      * @param result    where the text is to be appended
 693      * @param fieldPosition    keeps track on the position of the field within
 694      *                         the returned string. For example, for formatting
 695      *                         a number {@code 123456789} in {@code Locale.US}
 696      *                         locale, if the given {@code fieldPosition} is
 697      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 698      *                         and end index of {@code fieldPosition} will be set
 699      *                         to 0 and 11, respectively for the output string
 700      *                         {@code 123,456,789}.
<span class="line-modified"> 701      * @throws          NullPointerException if {@code result} or</span>
 702      *                  {@code fieldPosition} is {@code null}
<span class="line-modified"> 703      * @throws          ArithmeticException if rounding is needed with rounding</span>
 704      *                  mode being set to RoundingMode.UNNECESSARY
 705      * @return The formatted number string
 706      * @see java.text.FieldPosition
 707      */
 708     @Override
 709     public StringBuffer format(long number, StringBuffer result,
 710                                FieldPosition fieldPosition) {
 711         fieldPosition.setBeginIndex(0);
 712         fieldPosition.setEndIndex(0);
 713 
 714         return format(number, result, fieldPosition.getFieldDelegate());
 715     }
 716 
 717     /**
 718      * Format a long to produce a string.
 719      * @param number    The long to format
 720      * @param result    where the text is to be appended
 721      * @param delegate notified of locations of sub fields
 722      * @return The formatted number string
<span class="line-modified"> 723      * @throws           ArithmeticException if rounding is needed with rounding</span>
 724      *                   mode being set to RoundingMode.UNNECESSARY
 725      * @see java.text.FieldPosition
 726      */
 727     StringBuffer format(long number, StringBuffer result,
 728                                FieldDelegate delegate) {
 729         boolean isNegative = (number &lt; 0);
 730         if (isNegative) {
 731             number = -number;
 732         }
 733 
 734         // In general, long values always represent real finite numbers, so
 735         // we don&#39;t have to check for +/- Infinity or NaN.  However, there
 736         // is one case we have to be careful of:  The multiplier can push
 737         // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
 738         // check for this before multiplying, and if it happens we use
 739         // BigInteger instead.
 740         boolean useBigInteger = false;
 741         if (number &lt; 0) { // This can only happen if number == Long.MIN_VALUE.
 742             if (multiplier != 0) {
 743                 useBigInteger = true;
</pre>
<hr />
<pre>
 778                      useExponentialNotation ? maxIntDigits + maxFraDigits : 0);
 779 
 780             return subformat(result, delegate, isNegative, true,
 781                        maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 782         }
 783     }
 784 
 785     /**
 786      * Formats a BigDecimal to produce a string.
 787      * @param number    The BigDecimal to format
 788      * @param result    where the text is to be appended
 789      * @param fieldPosition    keeps track on the position of the field within
 790      *                         the returned string. For example, for formatting
 791      *                         a number {@code 1234567.89} in {@code Locale.US}
 792      *                         locale, if the given {@code fieldPosition} is
 793      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 794      *                         and end index of {@code fieldPosition} will be set
 795      *                         to 0 and 9, respectively for the output string
 796      *                         {@code 1,234,567.89}.
 797      * @return The formatted number string
<span class="line-modified"> 798      * @throws           ArithmeticException if rounding is needed with rounding</span>
 799      *                   mode being set to RoundingMode.UNNECESSARY
 800      * @see java.text.FieldPosition
 801      */
 802     private StringBuffer format(BigDecimal number, StringBuffer result,
 803                                 FieldPosition fieldPosition) {
 804         fieldPosition.setBeginIndex(0);
 805         fieldPosition.setEndIndex(0);
 806         return format(number, result, fieldPosition.getFieldDelegate());
 807     }
 808 
 809     /**
 810      * Formats a BigDecimal to produce a string.
 811      * @param number    The BigDecimal to format
 812      * @param result    where the text is to be appended
 813      * @param delegate notified of locations of sub fields
<span class="line-modified"> 814      * @throws           ArithmeticException if rounding is needed with rounding</span>
 815      *                   mode being set to RoundingMode.UNNECESSARY
 816      * @return The formatted number string
 817      */
 818     StringBuffer format(BigDecimal number, StringBuffer result,
 819                                 FieldDelegate delegate) {
 820         if (multiplier != 1) {
 821             number = number.multiply(getBigDecimalMultiplier());
 822         }
 823         boolean isNegative = number.signum() == -1;
 824         if (isNegative) {
 825             number = number.negate();
 826         }
 827 
 828         synchronized(digitList) {
 829             int maxIntDigits = getMaximumIntegerDigits();
 830             int minIntDigits = getMinimumIntegerDigits();
 831             int maxFraDigits = getMaximumFractionDigits();
 832             int minFraDigits = getMinimumFractionDigits();
 833             int maximumDigits = maxIntDigits + maxFraDigits;
 834 
</pre>
<hr />
<pre>
 837                 maxFraDigits, !useExponentialNotation);
 838 
 839             return subformat(result, delegate, isNegative, false,
 840                 maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 841         }
 842     }
 843 
 844     /**
 845      * Format a BigInteger to produce a string.
 846      * @param number    The BigInteger to format
 847      * @param result    where the text is to be appended
 848      * @param fieldPosition    keeps track on the position of the field within
 849      *                         the returned string. For example, for formatting
 850      *                         a number {@code 123456789} in {@code Locale.US}
 851      *                         locale, if the given {@code fieldPosition} is
 852      *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
 853      *                         and end index of {@code fieldPosition} will be set
 854      *                         to 0 and 11, respectively for the output string
 855      *                         {@code 123,456,789}.
 856      * @return The formatted number string
<span class="line-modified"> 857      * @throws           ArithmeticException if rounding is needed with rounding</span>
 858      *                   mode being set to RoundingMode.UNNECESSARY
 859      * @see java.text.FieldPosition
 860      */
 861     private StringBuffer format(BigInteger number, StringBuffer result,
 862                                FieldPosition fieldPosition) {
 863         fieldPosition.setBeginIndex(0);
 864         fieldPosition.setEndIndex(0);
 865 
 866         return format(number, result, fieldPosition.getFieldDelegate(), false);
 867     }
 868 
 869     /**
 870      * Format a BigInteger to produce a string.
 871      * @param number    The BigInteger to format
 872      * @param result    where the text is to be appended
 873      * @param delegate notified of locations of sub fields
 874      * @return The formatted number string
<span class="line-modified"> 875      * @throws           ArithmeticException if rounding is needed with rounding</span>
 876      *                   mode being set to RoundingMode.UNNECESSARY
 877      * @see java.text.FieldPosition
 878      */
 879     StringBuffer format(BigInteger number, StringBuffer result,
 880                                FieldDelegate delegate, boolean formatLong) {
 881         if (multiplier != 1) {
 882             number = number.multiply(getBigIntegerMultiplier());
 883         }
 884         boolean isNegative = number.signum() == -1;
 885         if (isNegative) {
 886             number = number.negate();
 887         }
 888 
 889         synchronized(digitList) {
 890             int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
 891             if (formatLong) {
 892                 maxIntDigits = super.getMaximumIntegerDigits();
 893                 minIntDigits = super.getMinimumIntegerDigits();
 894                 maxFraDigits = super.getMaximumFractionDigits();
 895                 minFraDigits = super.getMinimumFractionDigits();
</pre>
<hr />
<pre>
 897             } else {
 898                 maxIntDigits = getMaximumIntegerDigits();
 899                 minIntDigits = getMinimumIntegerDigits();
 900                 maxFraDigits = getMaximumFractionDigits();
 901                 minFraDigits = getMinimumFractionDigits();
 902                 maximumDigits = maxIntDigits + maxFraDigits;
 903                 if (maximumDigits &lt; 0) {
 904                     maximumDigits = Integer.MAX_VALUE;
 905                 }
 906             }
 907 
 908             digitList.set(isNegative, number,
 909                           useExponentialNotation ? maximumDigits : 0);
 910 
 911             return subformat(result, delegate, isNegative, true,
 912                 maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
 913         }
 914     }
 915 
 916     /**
<span class="line-modified"> 917      * Formats an Object producing an {@code AttributedCharacterIterator}.</span>
<span class="line-modified"> 918      * You can use the returned {@code AttributedCharacterIterator}</span>
 919      * to build the resulting String, as well as to determine information
 920      * about the resulting String.
 921      * &lt;p&gt;
 922      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified"> 923      * {@code NumberFormat.Field}, with the attribute value being the</span>
 924      * same as the attribute key.
 925      *
<span class="line-modified"> 926      * @throws    NullPointerException if obj is null.</span>
<span class="line-modified"> 927      * @throws    IllegalArgumentException when the Format cannot format the</span>
 928      *            given object.
<span class="line-modified"> 929      * @throws           ArithmeticException if rounding is needed with rounding</span>
 930      *                   mode being set to RoundingMode.UNNECESSARY
 931      * @param obj The object to format
 932      * @return AttributedCharacterIterator describing the formatted value.
 933      * @since 1.4
 934      */
 935     @Override
 936     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
 937         CharacterIteratorFieldDelegate delegate =
 938                          new CharacterIteratorFieldDelegate();
 939         StringBuffer sb = new StringBuffer();
 940 
 941         if (obj instanceof Double || obj instanceof Float) {
 942             format(((Number)obj).doubleValue(), sb, delegate);
 943         } else if (obj instanceof Long || obj instanceof Integer ||
 944                    obj instanceof Short || obj instanceof Byte ||
 945                    obj instanceof AtomicInteger || obj instanceof AtomicLong) {
 946             format(((Number)obj).longValue(), sb, delegate);
 947         } else if (obj instanceof BigDecimal) {
 948             format((BigDecimal)obj, sb, delegate);
 949         } else if (obj instanceof BigInteger) {
</pre>
<hr />
<pre>
1086          * setting the fast path data. The return value is used by the
1087          * fastFormat() method to decide whether to call the resetFastPathData
1088          * method to reinitialize fast path data or is it already initialized
1089          * in this method.
1090          */
1091         return true;
1092     }
1093 
1094     private void resetFastPathData(boolean fastPathWasOn) {
1095         // Since some instance properties may have changed while still falling
1096         // in the fast-path case, we need to reinitialize fastPathData anyway.
1097         if (isFastPath) {
1098             // We need to instantiate fastPathData if not already done.
1099             if (fastPathData == null) {
1100                 fastPathData = new FastPathData();
1101             }
1102 
1103             // Sets up the locale specific constants used when formatting.
1104             // &#39;0&#39; is our default representation of zero.
1105             fastPathData.zeroDelta = symbols.getZeroDigit() - &#39;0&#39;;
<span class="line-modified">1106             fastPathData.groupingChar = isCurrencyFormat ?</span>
<span class="line-added">1107                     symbols.getMonetaryGroupingSeparator() :</span>
<span class="line-added">1108                     symbols.getGroupingSeparator();</span>
1109 
1110             // Sets up fractional constants related to currency/decimal pattern.
1111             fastPathData.fractionalMaxIntBound = (isCurrencyFormat)
1112                     ? 99 : 999;
1113             fastPathData.fractionalScaleFactor = (isCurrencyFormat)
1114                     ? 100.0d : 1000.0d;
1115 
1116             // Records the need for adding prefix or suffix
1117             fastPathData.positiveAffixesRequired
1118                     = !positivePrefix.isEmpty() || !positiveSuffix.isEmpty();
1119             fastPathData.negativeAffixesRequired
1120                     = !negativePrefix.isEmpty() || !negativeSuffix.isEmpty();
1121 
1122             // Creates a cached char container for result, with max possible size.
1123             int maxNbIntegralDigits = 10;
1124             int maxNbGroups = 3;
1125             int containerSize
1126                     = Math.max(positivePrefix.length(), negativePrefix.length())
1127                     + maxNbIntegralDigits + maxNbGroups + 1
1128                     + maximumFractionDigits
</pre>
<hr />
<pre>
1759         return result;
1760     }
1761 
1762     /**
1763      * Subformats number part using the {@code DigitList} of this
1764      * {@code DecimalFormat} instance.
1765      * @param result where the text is to be appended
1766      * @param delegate notified of the location of sub fields
1767      * @param isNegative true, if the number is negative; false otherwise
1768      * @param isInteger true, if the number is an integer; false otherwise
1769      * @param maxIntDigits maximum integer digits
1770      * @param minIntDigits minimum integer digits
1771      * @param maxFraDigits maximum fraction digits
1772      * @param minFraDigits minimum fraction digits
1773      */
1774     void subformatNumber(StringBuffer result, FieldDelegate delegate,
1775             boolean isNegative, boolean isInteger,
1776             int maxIntDigits, int minIntDigits,
1777             int maxFraDigits, int minFraDigits) {
1778 
<span class="line-modified">1779         char grouping = isCurrencyFormat ?</span>
<span class="line-added">1780                 symbols.getMonetaryGroupingSeparator() :</span>
<span class="line-added">1781                 symbols.getGroupingSeparator();</span>
1782         char zero = symbols.getZeroDigit();
1783         int zeroDelta = zero - &#39;0&#39;; // &#39;0&#39; is the DigitList representation of zero
1784 
1785         char decimal = isCurrencyFormat ?
1786                 symbols.getMonetaryDecimalSeparator() :
1787                 symbols.getDecimalSeparator();
1788 
1789         /* Per bug 4147706, DecimalFormat must respect the sign of numbers which
1790          * format as zero.  This allows sensible computations and preserves
1791          * relations such as signum(1/x) = signum(x), where x is +Infinity or
1792          * -Infinity.  Prior to this fix, we always formatted zero values as if
1793          * they were positive.  Liu 7/6/98.
1794          */
1795         if (digitList.isZero()) {
1796             digitList.decimalAt = 0; // Normalize
1797         }
1798 
1799         if (useExponentialNotation) {
1800             int iFieldStart = result.length();
1801             int iFieldEnd = -1;
</pre>
<hr />
<pre>
1903             // digits, since truncating the exponent would result in an
1904             // unacceptable inaccuracy.
1905             int fieldStart = result.length();
1906 
1907             result.append(symbols.getExponentSeparator());
1908 
1909             delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL,
1910                     fieldStart, result.length(), result);
1911 
1912             // For zero values, we force the exponent to zero.  We
1913             // must do this here, and not earlier, because the value
1914             // is used to determine integer digit count above.
1915             if (digitList.isZero()) {
1916                 exponent = 0;
1917             }
1918 
1919             boolean negativeExponent = exponent &lt; 0;
1920             if (negativeExponent) {
1921                 exponent = -exponent;
1922                 fieldStart = result.length();
<span class="line-modified">1923                 result.append(symbols.getMinusSignText());</span>
1924                 delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN,
1925                         fieldStart, result.length(), result);
1926             }
1927             digitList.set(negativeExponent, exponent);
1928 
1929             int eFieldStart = result.length();
1930 
1931             for (int i=digitList.decimalAt; i&lt;minExponentDigits; ++i) {
1932                 result.append(zero);
1933             }
1934             for (int i=0; i&lt;digitList.decimalAt; ++i) {
1935                 result.append((i &lt; digitList.count) ?
1936                         (char)(digitList.digits[i] + zeroDelta) : zero);
1937             }
1938             delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart,
1939                     result.length(), result);
1940         } else {
1941             int iFieldStart = result.length();
1942 
1943             // Output the integer portion.  Here &#39;count&#39; is the total
</pre>
<hr />
<pre>
2029                     result.append(zero);
2030                     continue;
2031                 }
2032 
2033                 // Output a digit, if we have any precision left, or a
2034                 // zero if we don&#39;t.  We don&#39;t want to output noise digits.
2035                 if (!isInteger &amp;&amp; digitIndex &lt; digitList.count) {
2036                     result.append((char)(digitList.digits[digitIndex++] + zeroDelta));
2037                 } else {
2038                     result.append(zero);
2039                 }
2040             }
2041 
2042             // Record field information for caller.
2043             delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
2044                     fFieldStart, result.length(), result);
2045         }
2046     }
2047 
2048     /**
<span class="line-modified">2049      * Appends the String {@code string} to {@code result}.</span>
<span class="line-modified">2050      * {@code delegate} is notified of all  the</span>
<span class="line-modified">2051      * {@code FieldPosition}s in {@code positions}.</span>
2052      * &lt;p&gt;
<span class="line-modified">2053      * If one of the {@code FieldPosition}s in {@code positions}</span>
<span class="line-modified">2054      * identifies a {@code SIGN} attribute, it is mapped to</span>
<span class="line-modified">2055      * {@code signAttribute}. This is used</span>
<span class="line-modified">2056      * to map the {@code SIGN} attribute to the {@code EXPONENT}</span>
2057      * attribute as necessary.
2058      * &lt;p&gt;
<span class="line-modified">2059      * This is used by {@code subformat} to add the prefix/suffix.</span>
2060      */
2061     private void append(StringBuffer result, String string,
2062                         FieldDelegate delegate,
2063                         FieldPosition[] positions,
2064                         Format.Field signAttribute) {
2065         int start = result.length();
2066 
2067         if (!string.isEmpty()) {
2068             result.append(string);
2069             for (int counter = 0, max = positions.length; counter &lt; max;
2070                  counter++) {
2071                 FieldPosition fp = positions[counter];
2072                 Format.Field attribute = fp.getFieldAttribute();
2073 
2074                 if (attribute == Field.SIGN) {
2075                     attribute = signAttribute;
2076                 }
2077                 delegate.formatted(attribute, attribute,
2078                                    start + fp.getBeginIndex(),
2079                                    start + fp.getEndIndex(), result);
2080             }
2081         }
2082     }
2083 
2084     /**
<span class="line-modified">2085      * Parses text from a string to produce a {@code Number}.</span>
2086      * &lt;p&gt;
2087      * The method attempts to parse text starting at the index given by
<span class="line-modified">2088      * {@code pos}.</span>
<span class="line-modified">2089      * If parsing succeeds, then the index of {@code pos} is updated</span>
2090      * to the index after the last character used (parsing does not necessarily
2091      * use all characters up to the end of the string), and the parsed
<span class="line-modified">2092      * number is returned. The updated {@code pos} can be used to</span>
2093      * indicate the starting point for the next call to this method.
<span class="line-modified">2094      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">2095      * changed, the error index of {@code pos} is set to the index of</span>
2096      * the character where the error occurred, and null is returned.
2097      * &lt;p&gt;
2098      * The subclass returned depends on the value of {@link #isParseBigDecimal}
2099      * as well as on the string being parsed.
2100      * &lt;ul&gt;
<span class="line-modified">2101      *   &lt;li&gt;If {@code isParseBigDecimal()} is false (the default),</span>
<span class="line-modified">2102      *       most integer values are returned as {@code Long}</span>
<span class="line-modified">2103      *       objects, no matter how they are written: {@code &quot;17&quot;} and</span>
<span class="line-modified">2104      *       {@code &quot;17.000&quot;} both parse to {@code Long(17)}.</span>
<span class="line-modified">2105      *       Values that cannot fit into a {@code Long} are returned as</span>
<span class="line-modified">2106      *       {@code Double}s. This includes values with a fractional part,</span>
<span class="line-modified">2107      *       infinite values, {@code NaN}, and the value -0.0.</span>
<span class="line-modified">2108      *       {@code DecimalFormat} does &lt;em&gt;not&lt;/em&gt; decide whether to</span>
<span class="line-modified">2109      *       return a {@code Double} or a {@code Long} based on the</span>
2110      *       presence of a decimal separator in the source string. Doing so
2111      *       would prevent integers that overflow the mantissa of a double,
<span class="line-modified">2112      *       such as {@code &quot;-9,223,372,036,854,775,808.00&quot;}, from being</span>
2113      *       parsed accurately.
2114      *       &lt;p&gt;
<span class="line-modified">2115      *       Callers may use the {@code Number} methods</span>
<span class="line-modified">2116      *       {@code doubleValue}, {@code longValue}, etc., to obtain</span>
2117      *       the type they want.
<span class="line-modified">2118      *   &lt;li&gt;If {@code isParseBigDecimal()} is true, values are returned</span>
<span class="line-modified">2119      *       as {@code BigDecimal} objects. The values are the ones</span>
2120      *       constructed by {@link java.math.BigDecimal#BigDecimal(String)}
2121      *       for corresponding strings in locale-independent format. The
2122      *       special cases negative and positive infinity and NaN are returned
<span class="line-modified">2123      *       as {@code Double} instances holding the values of the</span>
<span class="line-modified">2124      *       corresponding {@code Double} constants.</span>
2125      * &lt;/ul&gt;
2126      * &lt;p&gt;
<span class="line-modified">2127      * {@code DecimalFormat} parses all Unicode characters that represent</span>
<span class="line-modified">2128      * decimal digits, as defined by {@code Character.digit()}. In</span>
<span class="line-modified">2129      * addition, {@code DecimalFormat} also recognizes as digits the ten</span>
2130      * consecutive characters starting with the localized zero digit defined in
<span class="line-modified">2131      * the {@code DecimalFormatSymbols} object.</span>
2132      *
2133      * @param text the string to be parsed
<span class="line-modified">2134      * @param pos  A {@code ParsePosition} object with index and error</span>
2135      *             index information as described above.
<span class="line-modified">2136      * @return     the parsed value, or {@code null} if the parse fails</span>
<span class="line-modified">2137      * @throws     NullPointerException if {@code text} or</span>
<span class="line-modified">2138      *             {@code pos} is null.</span>
2139      */
2140     @Override
2141     public Number parse(String text, ParsePosition pos) {
2142         // special case NaN
2143         if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {
2144             pos.index = pos.index + symbols.getNaN().length();
2145             return Double.valueOf(Double.NaN);
2146         }
2147 
2148         boolean[] status = new boolean[STATUS_LENGTH];
2149         if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {
2150             return null;
2151         }
2152 
2153         // special case INFINITY
2154         if (status[STATUS_INFINITE]) {
2155             if (status[STATUS_POSITIVE] == (multiplier &gt;= 0)) {
2156                 return Double.valueOf(Double.POSITIVE_INFINITY);
2157             } else {
2158                 return Double.valueOf(Double.NEGATIVE_INFINITY);
</pre>
<hr />
<pre>
2380                        boolean isExponent, boolean status[]) {
2381         // process digits or Inf, find decimal position
2382         status[STATUS_INFINITE] = false;
2383         if (!isExponent &amp;&amp; text.regionMatches(position,symbols.getInfinity(),0,
2384                 symbols.getInfinity().length())) {
2385             position += symbols.getInfinity().length();
2386             status[STATUS_INFINITE] = true;
2387         } else {
2388             // We now have a string of digits, possibly with grouping symbols,
2389             // and decimal points.  We want to process these into a DigitList.
2390             // We don&#39;t want to put a bunch of leading zeros into the DigitList
2391             // though, so we keep track of the location of the decimal point,
2392             // put only significant digits into the DigitList, and adjust the
2393             // exponent as needed.
2394 
2395             digits.decimalAt = digits.count = 0;
2396             char zero = symbols.getZeroDigit();
2397             char decimal = isCurrencyFormat ?
2398                     symbols.getMonetaryDecimalSeparator() :
2399                     symbols.getDecimalSeparator();
<span class="line-modified">2400             char grouping = isCurrencyFormat ?</span>
<span class="line-added">2401                     symbols.getMonetaryGroupingSeparator() :</span>
<span class="line-added">2402                     symbols.getGroupingSeparator();</span>
2403             String exponentString = symbols.getExponentSeparator();
2404             boolean sawDecimal = false;
2405             boolean sawExponent = false;
2406             boolean sawDigit = false;
2407             int exponent = 0; // Set to the exponent value, if any
2408 
2409             // We have to track digitCount ourselves, because digits.count will
2410             // pin when the maximum allowable digits is reached.
2411             int digitCount = 0;
2412 
2413             int backup = -1;
2414             for (; position &lt; text.length(); ++position) {
2415                 char ch = text.charAt(position);
2416 
2417                 /* We recognize all digit ranges, not only the Latin digit range
2418                  * &#39;0&#39;..&#39;9&#39;.  We do so by using the Character.digit() method,
2419                  * which converts a valid Unicode digit to the range 0..9.
2420                  *
2421                  * The character &#39;ch&#39; may be a digit.  If so, place its value
2422                  * from 0 to 9 in &#39;digit&#39;.  First try using the locale digit,
</pre>
<hr />
<pre>
2464                     if (isParseIntegerOnly() || sawDecimal) {
2465                         break;
2466                     }
2467                     digits.decimalAt = digitCount; // Not digits.count!
2468                     sawDecimal = true;
2469                 } else if (!isExponent &amp;&amp; ch == grouping &amp;&amp; isGroupingUsed()) {
2470                     if (sawDecimal) {
2471                         break;
2472                     }
2473                     // Ignore grouping characters, if we are using them, but
2474                     // require that they be followed by a digit.  Otherwise
2475                     // we backup and reprocess them.
2476                     backup = position;
2477                 } else if (checkExponent &amp;&amp; !isExponent &amp;&amp; text.regionMatches(position, exponentString, 0, exponentString.length())
2478                         &amp;&amp; !sawExponent) {
2479                     // Process the exponent by recursively calling this method.
2480                     ParsePosition pos = new ParsePosition(position + exponentString.length());
2481                     boolean[] stat = new boolean[STATUS_LENGTH];
2482                     DigitList exponentDigits = new DigitList();
2483 
<span class="line-modified">2484                     if (subparse(text, pos, &quot;&quot;, symbols.getMinusSignText(), exponentDigits, true, stat) &amp;&amp;</span>
2485                             exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {
2486                         position = pos.index; // Advance past the exponent
2487                         exponent = (int)exponentDigits.getLong();
2488                         if (!stat[STATUS_POSITIVE]) {
2489                             exponent = -exponent;
2490                         }
2491                         sawExponent = true;
2492                     }
2493                     break; // Whether we fail or succeed, we exit this loop
2494                 } else {
2495                     break;
2496                 }
2497             }
2498 
2499             if (backup != -1) {
2500                 position = backup;
2501             }
2502 
2503             // If there was no decimal point we have an integer
2504             if (!sawDecimal) {
</pre>
<hr />
<pre>
2562     public String getPositivePrefix () {
2563         return positivePrefix;
2564     }
2565 
2566     /**
2567      * Set the positive prefix.
2568      * &lt;P&gt;Examples: +123, $123, sFr123
2569      *
2570      * @param newValue the new positive prefix
2571      */
2572     public void setPositivePrefix (String newValue) {
2573         positivePrefix = newValue;
2574         posPrefixPattern = null;
2575         positivePrefixFieldPositions = null;
2576         fastPathCheckNeeded = true;
2577     }
2578 
2579     /**
2580      * Returns the FieldPositions of the fields in the prefix used for
2581      * positive numbers. This is not used if the user has explicitly set
<span class="line-modified">2582      * a positive prefix via {@code setPositivePrefix}. This is</span>
2583      * lazily created.
2584      *
2585      * @return FieldPositions in positive prefix
2586      */
2587     private FieldPosition[] getPositivePrefixFieldPositions() {
2588         if (positivePrefixFieldPositions == null) {
2589             if (posPrefixPattern != null) {
2590                 positivePrefixFieldPositions = expandAffix(posPrefixPattern);
2591             } else {
2592                 positivePrefixFieldPositions = EmptyFieldPositionArray;
2593             }
2594         }
2595         return positivePrefixFieldPositions;
2596     }
2597 
2598     /**
2599      * Get the negative prefix.
2600      * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
2601      *
2602      * @return the negative prefix
2603      */
2604     public String getNegativePrefix () {
2605         return negativePrefix;
2606     }
2607 
2608     /**
2609      * Set the negative prefix.
2610      * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
2611      *
2612      * @param newValue the new negative prefix
2613      */
2614     public void setNegativePrefix (String newValue) {
2615         negativePrefix = newValue;
2616         negPrefixPattern = null;
2617         fastPathCheckNeeded = true;
2618     }
2619 
2620     /**
2621      * Returns the FieldPositions of the fields in the prefix used for
2622      * negative numbers. This is not used if the user has explicitly set
<span class="line-modified">2623      * a negative prefix via {@code setNegativePrefix}. This is</span>
2624      * lazily created.
2625      *
2626      * @return FieldPositions in positive prefix
2627      */
2628     private FieldPosition[] getNegativePrefixFieldPositions() {
2629         if (negativePrefixFieldPositions == null) {
2630             if (negPrefixPattern != null) {
2631                 negativePrefixFieldPositions = expandAffix(negPrefixPattern);
2632             } else {
2633                 negativePrefixFieldPositions = EmptyFieldPositionArray;
2634             }
2635         }
2636         return negativePrefixFieldPositions;
2637     }
2638 
2639     /**
2640      * Get the positive suffix.
2641      * &lt;P&gt;Example: 123%
2642      *
2643      * @return the positive suffix
2644      */
2645     public String getPositiveSuffix () {
2646         return positiveSuffix;
2647     }
2648 
2649     /**
2650      * Set the positive suffix.
2651      * &lt;P&gt;Example: 123%
2652      *
2653      * @param newValue the new positive suffix
2654      */
2655     public void setPositiveSuffix (String newValue) {
2656         positiveSuffix = newValue;
2657         posSuffixPattern = null;
2658         fastPathCheckNeeded = true;
2659     }
2660 
2661     /**
2662      * Returns the FieldPositions of the fields in the suffix used for
2663      * positive numbers. This is not used if the user has explicitly set
<span class="line-modified">2664      * a positive suffix via {@code setPositiveSuffix}. This is</span>
2665      * lazily created.
2666      *
2667      * @return FieldPositions in positive prefix
2668      */
2669     private FieldPosition[] getPositiveSuffixFieldPositions() {
2670         if (positiveSuffixFieldPositions == null) {
2671             if (posSuffixPattern != null) {
2672                 positiveSuffixFieldPositions = expandAffix(posSuffixPattern);
2673             } else {
2674                 positiveSuffixFieldPositions = EmptyFieldPositionArray;
2675             }
2676         }
2677         return positiveSuffixFieldPositions;
2678     }
2679 
2680     /**
2681      * Get the negative suffix.
2682      * &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)
2683      *
2684      * @return the negative suffix
2685      */
2686     public String getNegativeSuffix () {
2687         return negativeSuffix;
2688     }
2689 
2690     /**
2691      * Set the negative suffix.
2692      * &lt;P&gt;Examples: 123%
2693      *
2694      * @param newValue the new negative suffix
2695      */
2696     public void setNegativeSuffix (String newValue) {
2697         negativeSuffix = newValue;
2698         negSuffixPattern = null;
2699         fastPathCheckNeeded = true;
2700     }
2701 
2702     /**
2703      * Returns the FieldPositions of the fields in the suffix used for
2704      * negative numbers. This is not used if the user has explicitly set
<span class="line-modified">2705      * a negative suffix via {@code setNegativeSuffix}. This is</span>
2706      * lazily created.
2707      *
2708      * @return FieldPositions in positive prefix
2709      */
2710     private FieldPosition[] getNegativeSuffixFieldPositions() {
2711         if (negativeSuffixFieldPositions == null) {
2712             if (negSuffixPattern != null) {
2713                 negativeSuffixFieldPositions = expandAffix(negSuffixPattern);
2714             } else {
2715                 negativeSuffixFieldPositions = EmptyFieldPositionArray;
2716             }
2717         }
2718         return negativeSuffixFieldPositions;
2719     }
2720 
2721     /**
2722      * Gets the multiplier for use in percent, per mille, and similar
2723      * formats.
2724      *
2725      * @return the multiplier
</pre>
<hr />
<pre>
2745      */
2746     public void setMultiplier (int newValue) {
2747         multiplier = newValue;
2748         bigDecimalMultiplier = null;
2749         bigIntegerMultiplier = null;
2750         fastPathCheckNeeded = true;
2751     }
2752 
2753     /**
2754      * {@inheritDoc}
2755      */
2756     @Override
2757     public void setGroupingUsed(boolean newValue) {
2758         super.setGroupingUsed(newValue);
2759         fastPathCheckNeeded = true;
2760     }
2761 
2762     /**
2763      * Return the grouping size. Grouping size is the number of digits between
2764      * grouping separators in the integer portion of a number.  For example,
<span class="line-modified">2765      * in the number &quot;123,456.78&quot;, the grouping size is 3. Grouping size of</span>
<span class="line-added">2766      * zero designates that grouping is not used, which provides the same</span>
<span class="line-added">2767      * formatting as if calling {@link #setGroupingUsed(boolean)</span>
<span class="line-added">2768      * setGroupingUsed(false)}.</span>
2769      *
2770      * @return the grouping size
2771      * @see #setGroupingSize
2772      * @see java.text.NumberFormat#isGroupingUsed
2773      * @see java.text.DecimalFormatSymbols#getGroupingSeparator
2774      */
2775     public int getGroupingSize () {
2776         return groupingSize;
2777     }
2778 
2779     /**
2780      * Set the grouping size. Grouping size is the number of digits between
2781      * grouping separators in the integer portion of a number.  For example,
<span class="line-modified">2782      * in the number &quot;123,456.78&quot;, the grouping size is 3. Grouping size of</span>
<span class="line-modified">2783      * zero designates that grouping is not used, which provides the same</span>
<span class="line-added">2784      * formatting as if calling {@link #setGroupingUsed(boolean)</span>
<span class="line-added">2785      * setGroupingUsed(false)}.</span>
<span class="line-added">2786      * &lt;p&gt;</span>
2787      * The value passed in is converted to a byte, which may lose information.
<span class="line-added">2788      * Values that are negative or greater than</span>
<span class="line-added">2789      * {@link java.lang.Byte#MAX_VALUE Byte.MAX_VALUE}, will throw an</span>
<span class="line-added">2790      * {@code IllegalArgumentException}.</span>
2791      *
2792      * @param newValue the new grouping size
2793      * @see #getGroupingSize
2794      * @see java.text.NumberFormat#setGroupingUsed
2795      * @see java.text.DecimalFormatSymbols#setGroupingSeparator
<span class="line-added">2796      * @throws IllegalArgumentException if {@code newValue} is negative or</span>
<span class="line-added">2797      *          greater than {@link java.lang.Byte#MAX_VALUE Byte.MAX_VALUE}</span>
2798      */
2799     public void setGroupingSize (int newValue) {
<span class="line-added">2800         if (newValue &lt; 0 || newValue &gt; Byte.MAX_VALUE) {</span>
<span class="line-added">2801             throw new IllegalArgumentException(</span>
<span class="line-added">2802                 &quot;newValue is out of valid range. value: &quot; + newValue);</span>
<span class="line-added">2803         }</span>
2804         groupingSize = (byte)newValue;
2805         fastPathCheckNeeded = true;
2806     }
2807 
2808     /**
2809      * Allows you to get the behavior of the decimal separator with integers.
2810      * (The decimal separator will always appear with decimals.)
2811      * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
2812      *
2813      * @return {@code true} if the decimal separator is always shown;
2814      *         {@code false} otherwise
2815      */
2816     public boolean isDecimalSeparatorAlwaysShown() {
2817         return decimalSeparatorAlwaysShown;
2818     }
2819 
2820     /**
2821      * Allows you to set the behavior of the decimal separator with integers.
2822      * (The decimal separator will always appear with decimals.)
2823      * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
2824      *
2825      * @param newValue {@code true} if the decimal separator is always shown;
2826      *                 {@code false} otherwise
2827      */
2828     public void setDecimalSeparatorAlwaysShown(boolean newValue) {
2829         decimalSeparatorAlwaysShown = newValue;
2830         fastPathCheckNeeded = true;
2831     }
2832 
2833     /**
2834      * Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
<span class="line-modified">2835      * method returns {@code BigDecimal}. The default value is false.</span>
2836      *
2837      * @return {@code true} if the parse method returns BigDecimal;
2838      *         {@code false} otherwise
2839      * @see #setParseBigDecimal
2840      * @since 1.5
2841      */
2842     public boolean isParseBigDecimal() {
2843         return parseBigDecimal;
2844     }
2845 
2846     /**
2847      * Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
<span class="line-modified">2848      * method returns {@code BigDecimal}.</span>
2849      *
2850      * @param newValue {@code true} if the parse method returns BigDecimal;
2851      *                 {@code false} otherwise
2852      * @see #isParseBigDecimal
2853      * @since 1.5
2854      */
2855     public void setParseBigDecimal(boolean newValue) {
2856         parseBigDecimal = newValue;
2857     }
2858 
2859     /**
2860      * Standard override; no change in semantics.
2861      */
2862     @Override
2863     public Object clone() {
2864         DecimalFormat other = (DecimalFormat) super.clone();
2865         other.symbols = (DecimalFormatSymbols) symbols.clone();
2866         other.digitList = (DigitList) digitList.clone();
2867 
2868         // Fast-path is almost stateless algorithm. The only logical state is the
</pre>
<hr />
<pre>
2995      * @param buffer a scratch StringBuffer; its contents will be lost
2996      * @return the expanded equivalent of pattern
2997      */
2998     private String expandAffix(String pattern, StringBuffer buffer) {
2999         buffer.setLength(0);
3000         for (int i=0; i&lt;pattern.length(); ) {
3001             char c = pattern.charAt(i++);
3002             if (c == QUOTE) {
3003                 c = pattern.charAt(i++);
3004                 switch (c) {
3005                 case CURRENCY_SIGN:
3006                     if (i&lt;pattern.length() &amp;&amp;
3007                         pattern.charAt(i) == CURRENCY_SIGN) {
3008                         ++i;
3009                         buffer.append(symbols.getInternationalCurrencySymbol());
3010                     } else {
3011                         buffer.append(symbols.getCurrencySymbol());
3012                     }
3013                     continue;
3014                 case PATTERN_PERCENT:
<span class="line-modified">3015                     buffer.append(symbols.getPercentText());</span>
<span class="line-modified">3016                     continue;</span>
3017                 case PATTERN_PER_MILLE:
<span class="line-modified">3018                     buffer.append(symbols.getPerMillText());</span>
<span class="line-modified">3019                     continue;</span>
3020                 case PATTERN_MINUS:
<span class="line-modified">3021                     buffer.append(symbols.getMinusSignText());</span>
<span class="line-modified">3022                     continue;</span>
3023                 }
3024             }
3025             buffer.append(c);
3026         }
3027         return buffer.toString();
3028     }
3029 
3030     /**
3031      * Expand an affix pattern into an array of FieldPositions describing
3032      * how the pattern would be expanded.
3033      * All characters in the
3034      * pattern are literal unless prefixed by QUOTE.  The following characters
3035      * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
3036      * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
3037      * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
3038      * currency code.  Any other character after a QUOTE represents itself.
3039      * QUOTE must be followed by another character; QUOTE may not occur by
3040      * itself at the end of the pattern.
3041      *
3042      * @param pattern the non-null, possibly empty pattern
3043      * @return FieldPosition array of the resulting fields.
3044      */
3045     private FieldPosition[] expandAffix(String pattern) {
3046         ArrayList&lt;FieldPosition&gt; positions = null;
3047         int stringIndex = 0;
3048         for (int i=0; i&lt;pattern.length(); ) {
3049             char c = pattern.charAt(i++);
3050             if (c == QUOTE) {

3051                 Format.Field fieldID = null;
<span class="line-added">3052                 String string = null;</span>
3053                 c = pattern.charAt(i++);
3054                 switch (c) {
3055                 case CURRENCY_SIGN:

3056                     if (i&lt;pattern.length() &amp;&amp;
3057                         pattern.charAt(i) == CURRENCY_SIGN) {
3058                         ++i;
3059                         string = symbols.getInternationalCurrencySymbol();
3060                     } else {
3061                         string = symbols.getCurrencySymbol();
3062                     }
<span class="line-modified">3063                     fieldID = Field.CURRENCY;</span>
<span class="line-modified">3064                     break;</span>









3065                 case PATTERN_PERCENT:
<span class="line-modified">3066                     string = symbols.getPercentText();</span>

3067                     fieldID = Field.PERCENT;
3068                     break;
3069                 case PATTERN_PER_MILLE:
<span class="line-modified">3070                     string = symbols.getPerMillText();</span>

3071                     fieldID = Field.PERMILLE;
3072                     break;
3073                 case PATTERN_MINUS:
<span class="line-modified">3074                     string = symbols.getMinusSignText();</span>

3075                     fieldID = Field.SIGN;
3076                     break;
3077                 }
<span class="line-modified">3078 </span>
<span class="line-added">3079                 if (fieldID != null &amp;&amp; !string.isEmpty()) {</span>
3080                     if (positions == null) {
3081                         positions = new ArrayList&lt;&gt;(2);
3082                     }
<span class="line-modified">3083                     FieldPosition fp = new FieldPosition(fieldID);</span>
3084                     fp.setBeginIndex(stringIndex);
<span class="line-modified">3085                     fp.setEndIndex(stringIndex + string.length());</span>
3086                     positions.add(fp);
<span class="line-added">3087                     stringIndex += string.length();</span>
<span class="line-added">3088                     continue;</span>
3089                 }
3090             }
3091             stringIndex++;
3092         }
3093         if (positions != null) {
3094             return positions.toArray(EmptyFieldPositionArray);
3095         }
3096         return EmptyFieldPositionArray;
3097     }
3098 
3099     /**
3100      * Appends an affix pattern to the given StringBuffer, quoting special
3101      * characters as needed.  Uses the internal affix pattern, if that exists,
3102      * or the literal affix, if the internal affix pattern is null.  The
3103      * appended string will generate the same affix pattern (or literal affix)
3104      * when passed to toPattern().
3105      *
3106      * @param buffer the affix string is appended to this
3107      * @param affixPattern a pattern such as posPrefixPattern; may be null
3108      * @param expAffix a corresponding expanded affix, such as positivePrefix.
</pre>
<hr />
<pre>
3123                     appendAffix(buffer, affixPattern.substring(pos), localized);
3124                     break;
3125                 }
3126                 if (i &gt; pos) {
3127                     appendAffix(buffer, affixPattern.substring(pos, i), localized);
3128                 }
3129                 char c = affixPattern.charAt(++i);
3130                 ++i;
3131                 if (c == QUOTE) {
3132                     buffer.append(c);
3133                     // Fall through and append another QUOTE below
3134                 } else if (c == CURRENCY_SIGN &amp;&amp;
3135                            i&lt;affixPattern.length() &amp;&amp;
3136                            affixPattern.charAt(i) == CURRENCY_SIGN) {
3137                     ++i;
3138                     buffer.append(c);
3139                     // Fall through and append another CURRENCY_SIGN below
3140                 } else if (localized) {
3141                     switch (c) {
3142                     case PATTERN_PERCENT:
<span class="line-modified">3143                         buffer.append(symbols.getPercentText());</span>
<span class="line-modified">3144                         continue;</span>
3145                     case PATTERN_PER_MILLE:
<span class="line-modified">3146                         buffer.append(symbols.getPerMillText());</span>
<span class="line-modified">3147                         continue;</span>
3148                     case PATTERN_MINUS:
<span class="line-modified">3149                         buffer.append(symbols.getMinusSignText());</span>
<span class="line-modified">3150                         continue;</span>
3151                     }
3152                 }
3153                 buffer.append(c);
3154             }
3155         }
3156     }
3157 
3158     /**
3159      * Append an affix to the given StringBuffer, using quotes if
3160      * there are special characters.  Single quotes themselves must be
3161      * escaped in either case.
3162      */
3163     private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
3164         boolean needQuote;
3165         if (localized) {
3166             needQuote = affix.indexOf(symbols.getZeroDigit()) &gt;= 0
3167                 || affix.indexOf(symbols.getGroupingSeparator()) &gt;= 0
3168                 || affix.indexOf(symbols.getDecimalSeparator()) &gt;= 0
<span class="line-modified">3169                 || affix.indexOf(symbols.getPercentText()) &gt;= 0</span>
<span class="line-modified">3170                 || affix.indexOf(symbols.getPerMillText()) &gt;= 0</span>
3171                 || affix.indexOf(symbols.getDigit()) &gt;= 0
3172                 || affix.indexOf(symbols.getPatternSeparator()) &gt;= 0
<span class="line-modified">3173                 || affix.indexOf(symbols.getMinusSignText()) &gt;= 0</span>
3174                 || affix.indexOf(CURRENCY_SIGN) &gt;= 0;
3175         } else {
3176             needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) &gt;= 0
3177                 || affix.indexOf(PATTERN_GROUPING_SEPARATOR) &gt;= 0
3178                 || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) &gt;= 0
3179                 || affix.indexOf(PATTERN_PERCENT) &gt;= 0
3180                 || affix.indexOf(PATTERN_PER_MILLE) &gt;= 0
3181                 || affix.indexOf(PATTERN_DIGIT) &gt;= 0
3182                 || affix.indexOf(PATTERN_SEPARATOR) &gt;= 0
3183                 || affix.indexOf(PATTERN_MINUS) &gt;= 0
3184                 || affix.indexOf(CURRENCY_SIGN) &gt;= 0;
3185         }
3186         if (needQuote) buffer.append(&#39;\&#39;&#39;);
3187         if (affix.indexOf(&#39;\&#39;&#39;) &lt; 0) buffer.append(affix);
3188         else {
3189             for (int j=0; j&lt;affix.length(); ++j) {
3190                 char c = affix.charAt(j);
3191                 buffer.append(c);
3192                 if (c == &#39;\&#39;&#39;) buffer.append(c);
3193             }
</pre>
<hr />
<pre>
3229                                   PATTERN_DIGIT);
3230                 }
3231             }
3232         if (useExponentialNotation)
3233         {
3234             result.append(localized ? symbols.getExponentSeparator() :
3235                   PATTERN_EXPONENT);
3236         for (i=0; i&lt;minExponentDigits; ++i)
3237                     result.append(localized ? symbols.getZeroDigit() :
3238                                   PATTERN_ZERO_DIGIT);
3239         }
3240             if (j == 1) {
3241                 appendAffix(result, posSuffixPattern, positiveSuffix, localized);
3242                 if ((negSuffixPattern == posSuffixPattern &amp;&amp; // n == p == null
3243                      negativeSuffix.equals(positiveSuffix))
3244                     || (negSuffixPattern != null &amp;&amp;
3245                         negSuffixPattern.equals(posSuffixPattern))) {
3246                     if ((negPrefixPattern != null &amp;&amp; posPrefixPattern != null &amp;&amp;
3247                          negPrefixPattern.equals(&quot;&#39;-&quot; + posPrefixPattern)) ||
3248                         (negPrefixPattern == posPrefixPattern &amp;&amp; // n == p == null
<span class="line-modified">3249                          negativePrefix.equals(symbols.getMinusSignText() + positivePrefix)))</span>
3250                         break;
3251                 }
3252                 result.append(localized ? symbols.getPatternSeparator() :
3253                               PATTERN_SEPARATOR);
3254             } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);
3255         }
3256         return result.toString();
3257     }
3258 
3259     /**
3260      * Apply the given pattern to this Format object.  A pattern is a
3261      * short-hand specification for the various formatting properties.
3262      * These properties can also be changed individually through the
3263      * various setter methods.
3264      * &lt;p&gt;
3265      * There is no limit to integer digits set
3266      * by this routine, since that is the typical end-user desire;
3267      * use setMaximumInteger if you want to set a real value.
3268      * For negative numbers, use a second pattern, separated by a semicolon
<span class="line-modified">3269      * &lt;P&gt;Example {@code &quot;#,#00.0#&quot;} &amp;rarr; 1,234.56</span>
3270      * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
3271      * a maximum of 2 fraction digits.
<span class="line-modified">3272      * &lt;p&gt;Example: {@code &quot;#,#00.0#;(#,#00.0#)&quot;} for negatives in</span>
3273      * parentheses.
3274      * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
3275      * these are presumed to be set in the positive pattern.
3276      *
3277      * @param pattern a new pattern
<span class="line-modified">3278      * @throws    NullPointerException if {@code pattern} is null</span>
<span class="line-modified">3279      * @throws    IllegalArgumentException if the given pattern is invalid.</span>
3280      */
3281     public void applyPattern(String pattern) {
3282         applyPattern(pattern, false);
3283     }
3284 
3285     /**
3286      * Apply the given pattern to this Format object.  The pattern
3287      * is assumed to be in a localized notation. A pattern is a
3288      * short-hand specification for the various formatting properties.
3289      * These properties can also be changed individually through the
3290      * various setter methods.
3291      * &lt;p&gt;
3292      * There is no limit to integer digits set
3293      * by this routine, since that is the typical end-user desire;
3294      * use setMaximumInteger if you want to set a real value.
3295      * For negative numbers, use a second pattern, separated by a semicolon
<span class="line-modified">3296      * &lt;P&gt;Example {@code &quot;#,#00.0#&quot;} &amp;rarr; 1,234.56</span>
3297      * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
3298      * a maximum of 2 fraction digits.
<span class="line-modified">3299      * &lt;p&gt;Example: {@code &quot;#,#00.0#;(#,#00.0#)&quot;} for negatives in</span>
3300      * parentheses.
3301      * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
3302      * these are presumed to be set in the positive pattern.
3303      *
3304      * @param pattern a new pattern
<span class="line-modified">3305      * @throws    NullPointerException if {@code pattern} is null</span>
<span class="line-modified">3306      * @throws    IllegalArgumentException if the given pattern is invalid.</span>
3307      */
3308     public void applyLocalizedPattern(String pattern) {
3309         applyPattern(pattern, true);
3310     }
3311 
3312     /**
3313      * Does the real work of applying a pattern.
3314      */
3315     private void applyPattern(String pattern, boolean localized) {
3316         char zeroDigit         = PATTERN_ZERO_DIGIT;
3317         char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
3318         char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;
3319         char percent           = PATTERN_PERCENT;
3320         char perMill           = PATTERN_PER_MILLE;
3321         char digit             = PATTERN_DIGIT;
3322         char separator         = PATTERN_SEPARATOR;
<span class="line-modified">3323         String exponent        = PATTERN_EXPONENT;</span>
3324         char minus             = PATTERN_MINUS;
3325         if (localized) {
3326             zeroDigit         = symbols.getZeroDigit();
3327             groupingSeparator = symbols.getGroupingSeparator();
3328             decimalSeparator  = symbols.getDecimalSeparator();
3329             percent           = symbols.getPercent();
3330             perMill           = symbols.getPerMill();
3331             digit             = symbols.getDigit();
3332             separator         = symbols.getPatternSeparator();
3333             exponent          = symbols.getExponentSeparator();
3334             minus             = symbols.getMinusSign();
3335         }
3336         boolean gotNegative = false;
3337         decimalSeparatorAlwaysShown = false;
3338         isCurrencyFormat = false;
3339         useExponentialNotation = false;
3340 
3341         int start = 0;
3342         for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {
3343             boolean inQuote = false;
</pre>
<hr />
<pre>
3629             setMinimumFractionDigits(0);
3630             setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);
3631         }
3632 
3633         // If there was no negative pattern, or if the negative pattern is
3634         // identical to the positive pattern, then prepend the minus sign to
3635         // the positive pattern to form the negative pattern.
3636         if (!gotNegative ||
3637             (negPrefixPattern.equals(posPrefixPattern)
3638              &amp;&amp; negSuffixPattern.equals(posSuffixPattern))) {
3639             negSuffixPattern = posSuffixPattern;
3640             negPrefixPattern = &quot;&#39;-&quot; + posPrefixPattern;
3641         }
3642 
3643         expandAffixes();
3644     }
3645 
3646     /**
3647      * Sets the maximum number of digits allowed in the integer portion of a
3648      * number.
<span class="line-modified">3649      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3650      * {@code BigDecimal} objects, the lower of {@code newValue} and</span>
3651      * 309 is used. Negative input values are replaced with 0.
3652      * @see NumberFormat#setMaximumIntegerDigits
3653      */
3654     @Override
3655     public void setMaximumIntegerDigits(int newValue) {
3656         maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
3657         super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3658             DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
3659         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
3660             minimumIntegerDigits = maximumIntegerDigits;
3661             super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3662                 DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
3663         }
3664         fastPathCheckNeeded = true;
3665     }
3666 
3667     /**
3668      * Sets the minimum number of digits allowed in the integer portion of a
3669      * number.
<span class="line-modified">3670      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3671      * {@code BigDecimal} objects, the lower of {@code newValue} and</span>
3672      * 309 is used. Negative input values are replaced with 0.
3673      * @see NumberFormat#setMinimumIntegerDigits
3674      */
3675     @Override
3676     public void setMinimumIntegerDigits(int newValue) {
3677         minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
3678         super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3679             DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
3680         if (minimumIntegerDigits &gt; maximumIntegerDigits) {
3681             maximumIntegerDigits = minimumIntegerDigits;
3682             super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
3683                 DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
3684         }
3685         fastPathCheckNeeded = true;
3686     }
3687 
3688     /**
3689      * Sets the maximum number of digits allowed in the fraction portion of a
3690      * number.
<span class="line-modified">3691      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3692      * {@code BigDecimal} objects, the lower of {@code newValue} and</span>
3693      * 340 is used. Negative input values are replaced with 0.
3694      * @see NumberFormat#setMaximumFractionDigits
3695      */
3696     @Override
3697     public void setMaximumFractionDigits(int newValue) {
3698         maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
3699         super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3700             DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
3701         if (minimumFractionDigits &gt; maximumFractionDigits) {
3702             minimumFractionDigits = maximumFractionDigits;
3703             super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3704                 DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
3705         }
3706         fastPathCheckNeeded = true;
3707     }
3708 
3709     /**
3710      * Sets the minimum number of digits allowed in the fraction portion of a
3711      * number.
<span class="line-modified">3712      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3713      * {@code BigDecimal} objects, the lower of {@code newValue} and</span>
3714      * 340 is used. Negative input values are replaced with 0.
3715      * @see NumberFormat#setMinimumFractionDigits
3716      */
3717     @Override
3718     public void setMinimumFractionDigits(int newValue) {
3719         minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
3720         super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3721             DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
3722         if (minimumFractionDigits &gt; maximumFractionDigits) {
3723             maximumFractionDigits = minimumFractionDigits;
3724             super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
3725                 DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
3726         }
3727         fastPathCheckNeeded = true;
3728     }
3729 
3730     /**
3731      * Gets the maximum number of digits allowed in the integer portion of a
3732      * number.
<span class="line-modified">3733      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3734      * {@code BigDecimal} objects, the lower of the return value and</span>
3735      * 309 is used.
3736      * @see #setMaximumIntegerDigits
3737      */
3738     @Override
3739     public int getMaximumIntegerDigits() {
3740         return maximumIntegerDigits;
3741     }
3742 
3743     /**
3744      * Gets the minimum number of digits allowed in the integer portion of a
3745      * number.
<span class="line-modified">3746      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3747      * {@code BigDecimal} objects, the lower of the return value and</span>
3748      * 309 is used.
3749      * @see #setMinimumIntegerDigits
3750      */
3751     @Override
3752     public int getMinimumIntegerDigits() {
3753         return minimumIntegerDigits;
3754     }
3755 
3756     /**
3757      * Gets the maximum number of digits allowed in the fraction portion of a
3758      * number.
<span class="line-modified">3759      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3760      * {@code BigDecimal} objects, the lower of the return value and</span>
3761      * 340 is used.
3762      * @see #setMaximumFractionDigits
3763      */
3764     @Override
3765     public int getMaximumFractionDigits() {
3766         return maximumFractionDigits;
3767     }
3768 
3769     /**
3770      * Gets the minimum number of digits allowed in the fraction portion of a
3771      * number.
<span class="line-modified">3772      * For formatting numbers other than {@code BigInteger} and</span>
<span class="line-modified">3773      * {@code BigDecimal} objects, the lower of the return value and</span>
3774      * 340 is used.
3775      * @see #setMinimumFractionDigits
3776      */
3777     @Override
3778     public int getMinimumFractionDigits() {
3779         return minimumFractionDigits;
3780     }
3781 
3782     /**
3783      * Gets the currency used by this decimal format when formatting
3784      * currency values.
3785      * The currency is obtained by calling
3786      * {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}
3787      * on this number format&#39;s symbols.
3788      *
<span class="line-modified">3789      * @return the currency used by this decimal format, or {@code null}</span>
3790      * @since 1.4
3791      */
3792     @Override
3793     public Currency getCurrency() {
3794         return symbols.getCurrency();
3795     }
3796 
3797     /**
3798      * Sets the currency used by this number format when formatting
3799      * currency values. This does not update the minimum or maximum
3800      * number of fraction digits used by the number format.
3801      * The currency is set by calling
3802      * {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}
3803      * on this number format&#39;s symbols.
3804      *
3805      * @param currency the new currency to be used by this decimal format
<span class="line-modified">3806      * @throws    NullPointerException if {@code currency} is null</span>
3807      * @since 1.4
3808      */
3809     @Override
3810     public void setCurrency(Currency currency) {
3811         if (currency != symbols.getCurrency()) {
3812             symbols.setCurrency(currency);
3813             if (isCurrencyFormat) {
3814                 expandAffixes();
3815             }
3816         }
3817         fastPathCheckNeeded = true;
3818     }
3819 
3820     /**
3821      * Gets the {@link java.math.RoundingMode} used in this DecimalFormat.
3822      *
<span class="line-modified">3823      * @return The {@code RoundingMode} used for this DecimalFormat.</span>
3824      * @see #setRoundingMode(RoundingMode)
3825      * @since 1.6
3826      */
3827     @Override
3828     public RoundingMode getRoundingMode() {
3829         return roundingMode;
3830     }
3831 
3832     /**
3833      * Sets the {@link java.math.RoundingMode} used in this DecimalFormat.
3834      *
<span class="line-modified">3835      * @param roundingMode The {@code RoundingMode} to be used</span>
3836      * @see #getRoundingMode()
<span class="line-modified">3837      * @throws    NullPointerException if {@code roundingMode} is null.</span>
3838      * @since 1.6
3839      */
3840     @Override
3841     public void setRoundingMode(RoundingMode roundingMode) {
3842         if (roundingMode == null) {
3843             throw new NullPointerException();
3844         }
3845 
3846         this.roundingMode = roundingMode;
3847         digitList.setRoundingMode(roundingMode);
3848         fastPathCheckNeeded = true;
3849     }
3850 
3851     /**
3852      * Reads the default serializable fields from the stream and performs
3853      * validations and adjustments for older serialized versions. The
3854      * validations and adjustments are:
3855      * &lt;ol&gt;
3856      * &lt;li&gt;
3857      * Verify that the superclass&#39;s digit count fields correctly reflect
3858      * the limits imposed on formatting numbers other than
<span class="line-modified">3859      * {@code BigInteger} and {@code BigDecimal} objects. These</span>
3860      * limits are stored in the superclass for serialization compatibility
<span class="line-modified">3861      * with older versions, while the limits for {@code BigInteger} and</span>
<span class="line-modified">3862      * {@code BigDecimal} objects are kept in this class.</span>
3863      * If, in the superclass, the minimum or maximum integer digit count is
<span class="line-modified">3864      * larger than {@code DOUBLE_INTEGER_DIGITS} or if the minimum or</span>
3865      * maximum fraction digit count is larger than
<span class="line-modified">3866      * {@code DOUBLE_FRACTION_DIGITS}, then the stream data is invalid</span>
<span class="line-modified">3867      * and this method throws an {@code InvalidObjectException}.</span>
3868      * &lt;li&gt;
<span class="line-modified">3869      * If {@code serialVersionOnStream} is less than 4, initialize</span>
<span class="line-modified">3870      * {@code roundingMode} to {@link java.math.RoundingMode#HALF_EVEN</span>
3871      * RoundingMode.HALF_EVEN}.  This field is new with version 4.
3872      * &lt;li&gt;
<span class="line-modified">3873      * If {@code serialVersionOnStream} is less than 3, then call</span>
3874      * the setters for the minimum and maximum integer and fraction digits with
3875      * the values of the corresponding superclass getters to initialize the
3876      * fields in this class. The fields in this class are new with version 3.
3877      * &lt;li&gt;
<span class="line-modified">3878      * If {@code serialVersionOnStream} is less than 1, indicating that</span>
3879      * the stream was written by JDK 1.1, initialize
<span class="line-modified">3880      * {@code useExponentialNotation}</span>
3881      * to false, since it was not present in JDK 1.1.
3882      * &lt;li&gt;
<span class="line-modified">3883      * Set {@code serialVersionOnStream} to the maximum allowed value so</span>
3884      * that default serialization will work properly if this object is streamed
3885      * out again.
3886      * &lt;/ol&gt;
3887      *
3888      * &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
<span class="line-modified">3889      * {@code posPrefixPattern} etc.  As a result, they will be initialized</span>
<span class="line-modified">3890      * to {@code null}, which means the affix strings will be taken as</span>
3891      * literal values.  This is exactly what we want, since that corresponds to
3892      * the pre-version-2 behavior.
3893      */
<span class="line-added">3894     @java.io.Serial</span>
3895     private void readObject(ObjectInputStream stream)
3896          throws IOException, ClassNotFoundException
3897     {
3898         stream.defaultReadObject();
3899         digitList = new DigitList();
3900 
3901         // We force complete fast-path reinitialization when the instance is
3902         // deserialized. See clone() comment on fastPathCheckNeeded.
3903         fastPathCheckNeeded = true;
3904         isFastPath = false;
3905         fastPathData = null;
3906 
3907         if (serialVersionOnStream &lt; 4) {
3908             setRoundingMode(RoundingMode.HALF_EVEN);
3909         } else {
3910             setRoundingMode(getRoundingMode());
3911         }
3912 
3913         // We only need to check the maximum counts because NumberFormat
3914         // .readObject has already ensured that the maximum is greater than the
3915         // minimum count.
3916         if (super.getMaximumIntegerDigits() &gt; DOUBLE_INTEGER_DIGITS ||
3917             super.getMaximumFractionDigits() &gt; DOUBLE_FRACTION_DIGITS) {
3918             throw new InvalidObjectException(&quot;Digit count out of range&quot;);
3919         }
3920         if (serialVersionOnStream &lt; 3) {
3921             setMaximumIntegerDigits(super.getMaximumIntegerDigits());
3922             setMinimumIntegerDigits(super.getMinimumIntegerDigits());
3923             setMaximumFractionDigits(super.getMaximumFractionDigits());
3924             setMinimumFractionDigits(super.getMinimumFractionDigits());
3925         }
3926         if (serialVersionOnStream &lt; 1) {
3927             // Didn&#39;t have exponential fields
3928             useExponentialNotation = false;
3929         }
<span class="line-added">3930 </span>
<span class="line-added">3931         // Restore the invariant value if groupingSize is invalid.</span>
<span class="line-added">3932         if (groupingSize &lt; 0) {</span>
<span class="line-added">3933             groupingSize = 3;</span>
<span class="line-added">3934         }</span>
<span class="line-added">3935 </span>
3936         serialVersionOnStream = currentSerialVersion;
3937     }
3938 
3939     //----------------------------------------------------------------------
3940     // INSTANCE VARIABLES
3941     //----------------------------------------------------------------------
3942 
3943     private transient DigitList digitList = new DigitList();
3944 
3945     /**
3946      * The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.
3947      *
3948      * @serial
3949      * @see #getPositivePrefix
3950      */
3951     private String  positivePrefix = &quot;&quot;;
3952 
3953     /**
3954      * The symbol used as a suffix when formatting positive numbers.
3955      * This is often an empty string.
</pre>
<hr />
<pre>
3961 
3962     /**
3963      * The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.
3964      *
3965      * @serial
3966      * @see #getNegativePrefix
3967      */
3968     private String  negativePrefix = &quot;-&quot;;
3969 
3970     /**
3971      * The symbol used as a suffix when formatting negative numbers.
3972      * This is often an empty string.
3973      *
3974      * @serial
3975      * @see #getNegativeSuffix
3976      */
3977     private String  negativeSuffix = &quot;&quot;;
3978 
3979     /**
3980      * The prefix pattern for non-negative numbers.  This variable corresponds
<span class="line-modified">3981      * to {@code positivePrefix}.</span>
3982      *
<span class="line-modified">3983      * &lt;p&gt;This pattern is expanded by the method {@code expandAffix()} to</span>
<span class="line-modified">3984      * {@code positivePrefix} to update the latter to reflect changes in</span>
<span class="line-modified">3985      * {@code symbols}.  If this variable is {@code null} then</span>
<span class="line-modified">3986      * {@code positivePrefix} is taken as a literal value that does not</span>
<span class="line-modified">3987      * change when {@code symbols} changes.  This variable is always</span>
<span class="line-modified">3988      * {@code null} for {@code DecimalFormat} objects older than</span>
3989      * stream version 2 restored from stream.
3990      *
3991      * @serial
3992      * @since 1.3
3993      */
3994     private String posPrefixPattern;
3995 
3996     /**
3997      * The suffix pattern for non-negative numbers.  This variable corresponds
<span class="line-modified">3998      * to {@code positiveSuffix}.  This variable is analogous to</span>
<span class="line-modified">3999      * {@code posPrefixPattern}; see that variable for further</span>
4000      * documentation.
4001      *
4002      * @serial
4003      * @since 1.3
4004      */
4005     private String posSuffixPattern;
4006 
4007     /**
4008      * The prefix pattern for negative numbers.  This variable corresponds
<span class="line-modified">4009      * to {@code negativePrefix}.  This variable is analogous to</span>
<span class="line-modified">4010      * {@code posPrefixPattern}; see that variable for further</span>
4011      * documentation.
4012      *
4013      * @serial
4014      * @since 1.3
4015      */
4016     private String negPrefixPattern;
4017 
4018     /**
4019      * The suffix pattern for negative numbers.  This variable corresponds
<span class="line-modified">4020      * to {@code negativeSuffix}.  This variable is analogous to</span>
<span class="line-modified">4021      * {@code posPrefixPattern}; see that variable for further</span>
4022      * documentation.
4023      *
4024      * @serial
4025      * @since 1.3
4026      */
4027     private String negSuffixPattern;
4028 
4029     /**
4030      * The multiplier for use in percent, per mille, etc.
4031      *
4032      * @serial
4033      * @see #getMultiplier
4034      */
4035     private int     multiplier = 1;
4036 
4037     /**
4038      * The number of digits between grouping separators in the integer
<span class="line-modified">4039      * portion of a number.  Must be non-negative and less than or equal to</span>
<span class="line-modified">4040      * {@link java.lang.Byte#MAX_VALUE Byte.MAX_VALUE} if</span>
<span class="line-added">4041      * {@code NumberFormat.groupingUsed} is true.</span>
4042      *
4043      * @serial
4044      * @see #getGroupingSize
4045      * @see java.text.NumberFormat#isGroupingUsed
4046      */
<span class="line-modified">4047     private byte    groupingSize = 3;  // invariant, 0 - 127, if groupingUsed</span>
4048 
4049     /**
4050      * If true, forces the decimal separator to always appear in a formatted
4051      * number, even if the fractional part of the number is zero.
4052      *
4053      * @serial
4054      * @see #isDecimalSeparatorAlwaysShown
4055      */
4056     private boolean decimalSeparatorAlwaysShown = false;
4057 
4058     /**
4059      * If true, parse returns BigDecimal wherever possible.
4060      *
4061      * @serial
4062      * @see #isParseBigDecimal
4063      * @since 1.5
4064      */
4065     private boolean parseBigDecimal = false;
4066 
4067 
4068     /**
4069      * True if this object represents a currency format.  This determines
<span class="line-modified">4070      * whether the monetary decimal/grouping separators are used instead of the normal ones.</span>
4071      */
4072     private transient boolean isCurrencyFormat = false;
4073 
4074     /**
<span class="line-modified">4075      * The {@code DecimalFormatSymbols} object used by this format.</span>
4076      * It contains the symbols used to format numbers, e.g. the grouping separator,
4077      * decimal separator, and so on.
4078      *
4079      * @serial
4080      * @see #setDecimalFormatSymbols
4081      * @see java.text.DecimalFormatSymbols
4082      */
4083     private DecimalFormatSymbols symbols = null; // LIU new DecimalFormatSymbols();
4084 
4085     /**
4086      * True to force the use of exponential (i.e. scientific) notation when formatting
4087      * numbers.
4088      *
4089      * @serial
4090      * @since 1.2
4091      */
4092     private boolean useExponentialNotation;  // Newly persistent in the Java 2 platform v.1.2
4093 
4094     /**
4095      * FieldPositions describing the positive prefix String. This is
<span class="line-modified">4096      * lazily created. Use {@code getPositivePrefixFieldPositions}</span>
4097      * when needed.
4098      */
4099     private transient FieldPosition[] positivePrefixFieldPositions;
4100 
4101     /**
4102      * FieldPositions describing the positive suffix String. This is
<span class="line-modified">4103      * lazily created. Use {@code getPositiveSuffixFieldPositions}</span>
4104      * when needed.
4105      */
4106     private transient FieldPosition[] positiveSuffixFieldPositions;
4107 
4108     /**
4109      * FieldPositions describing the negative prefix String. This is
<span class="line-modified">4110      * lazily created. Use {@code getNegativePrefixFieldPositions}</span>
4111      * when needed.
4112      */
4113     private transient FieldPosition[] negativePrefixFieldPositions;
4114 
4115     /**
4116      * FieldPositions describing the negative suffix String. This is
<span class="line-modified">4117      * lazily created. Use {@code getNegativeSuffixFieldPositions}</span>
4118      * when needed.
4119      */
4120     private transient FieldPosition[] negativeSuffixFieldPositions;
4121 
4122     /**
4123      * The minimum number of digits used to display the exponent when a number is
4124      * formatted in exponential notation.  This field is ignored if
<span class="line-modified">4125      * {@code useExponentialNotation} is not true.</span>
4126      *
4127      * @serial
4128      * @since 1.2
4129      */
4130     private byte    minExponentDigits;       // Newly persistent in the Java 2 platform v.1.2
4131 
4132     /**
4133      * The maximum number of digits allowed in the integer portion of a
<span class="line-modified">4134      * {@code BigInteger} or {@code BigDecimal} number.</span>
<span class="line-modified">4135      * {@code maximumIntegerDigits} must be greater than or equal to</span>
<span class="line-modified">4136      * {@code minimumIntegerDigits}.</span>
4137      *
4138      * @serial
4139      * @see #getMaximumIntegerDigits
4140      * @since 1.5
4141      */
4142     private int    maximumIntegerDigits = super.getMaximumIntegerDigits();
4143 
4144     /**
4145      * The minimum number of digits allowed in the integer portion of a
<span class="line-modified">4146      * {@code BigInteger} or {@code BigDecimal} number.</span>
<span class="line-modified">4147      * {@code minimumIntegerDigits} must be less than or equal to</span>
<span class="line-modified">4148      * {@code maximumIntegerDigits}.</span>
4149      *
4150      * @serial
4151      * @see #getMinimumIntegerDigits
4152      * @since 1.5
4153      */
4154     private int    minimumIntegerDigits = super.getMinimumIntegerDigits();
4155 
4156     /**
4157      * The maximum number of digits allowed in the fractional portion of a
<span class="line-modified">4158      * {@code BigInteger} or {@code BigDecimal} number.</span>
<span class="line-modified">4159      * {@code maximumFractionDigits} must be greater than or equal to</span>
<span class="line-modified">4160      * {@code minimumFractionDigits}.</span>
4161      *
4162      * @serial
4163      * @see #getMaximumFractionDigits
4164      * @since 1.5
4165      */
4166     private int    maximumFractionDigits = super.getMaximumFractionDigits();
4167 
4168     /**
4169      * The minimum number of digits allowed in the fractional portion of a
<span class="line-modified">4170      * {@code BigInteger} or {@code BigDecimal} number.</span>
<span class="line-modified">4171      * {@code minimumFractionDigits} must be less than or equal to</span>
<span class="line-modified">4172      * {@code maximumFractionDigits}.</span>
4173      *
4174      * @serial
4175      * @see #getMinimumFractionDigits
4176      * @since 1.5
4177      */
4178     private int    minimumFractionDigits = super.getMinimumFractionDigits();
4179 
4180     /**
4181      * The {@link java.math.RoundingMode} used in this DecimalFormat.
4182      *
4183      * @serial
4184      * @since 1.6
4185      */
4186     private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
4187 
4188     // ------ DecimalFormat fields for fast-path for double algorithm  ------
4189 
4190     /**
4191      * Helper inner utility class for storing the data used in the fast-path
4192      * algorithm. Almost all fields related to fast-path are encapsulated in
</pre>
<hr />
<pre>
4249     /** The format fast-path status of the instance. Logical state. */
4250     private transient boolean isFastPath = false;
4251 
4252     /** Flag stating need of check and reinit fast-path status on next format call. */
4253     private transient boolean fastPathCheckNeeded = true;
4254 
4255     /** DecimalFormat reference to its FastPathData */
4256     private transient FastPathData fastPathData;
4257 
4258 
4259     //----------------------------------------------------------------------
4260 
4261     static final int currentSerialVersion = 4;
4262 
4263     /**
4264      * The internal serial version which says which version was written.
4265      * Possible values are:
4266      * &lt;ul&gt;
4267      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
4268      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
<span class="line-modified">4269      *      {@code useExponentialNotation} and</span>
<span class="line-modified">4270      *      {@code minExponentDigits}.</span>
4271      * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
<span class="line-modified">4272      *      {@code posPrefixPattern}, {@code posSuffixPattern},</span>
<span class="line-modified">4273      *      {@code negPrefixPattern}, and {@code negSuffixPattern}.</span>
4274      * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
<span class="line-modified">4275      *      {@code maximumIntegerDigits},</span>
<span class="line-modified">4276      *      {@code minimumIntegerDigits},</span>
<span class="line-modified">4277      *      {@code maximumFractionDigits},</span>
<span class="line-modified">4278      *      {@code minimumFractionDigits}, and</span>
<span class="line-modified">4279      *      {@code parseBigDecimal}.</span>
4280      * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
<span class="line-modified">4281      *      {@code roundingMode}.</span>
4282      * &lt;/ul&gt;
4283      * @since 1.2
4284      * @serial
4285      */
4286     private int serialVersionOnStream = currentSerialVersion;
4287 
4288     //----------------------------------------------------------------------
4289     // CONSTANTS
4290     //----------------------------------------------------------------------
4291 
4292     // ------ Fast-Path for double Constants ------
4293 
4294     /** Maximum valid integer value for applying fast-path algorithm */
4295     private static final double MAX_INT_AS_DOUBLE = (double) Integer.MAX_VALUE;
4296 
4297     /**
4298      * The digit arrays used in the fast-path methods for collecting digits.
4299      * Using 3 constants arrays of chars ensures a very fast collection of digits
4300      */
4301     private static class DigitArrays {
</pre>
<hr />
<pre>
4335             }
4336         }
4337     }
4338     // ------ Fast-Path for double Constants end ------
4339 
4340     // Constants for characters used in programmatic (unlocalized) patterns.
4341     private static final char       PATTERN_ZERO_DIGIT         = &#39;0&#39;;
4342     private static final char       PATTERN_GROUPING_SEPARATOR = &#39;,&#39;;
4343     private static final char       PATTERN_DECIMAL_SEPARATOR  = &#39;.&#39;;
4344     private static final char       PATTERN_PER_MILLE          = &#39;\u2030&#39;;
4345     private static final char       PATTERN_PERCENT            = &#39;%&#39;;
4346     private static final char       PATTERN_DIGIT              = &#39;#&#39;;
4347     private static final char       PATTERN_SEPARATOR          = &#39;;&#39;;
4348     private static final String     PATTERN_EXPONENT           = &quot;E&quot;;
4349     private static final char       PATTERN_MINUS              = &#39;-&#39;;
4350 
4351     /**
4352      * The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
4353      * is used in patterns and substituted with either the currency symbol,
4354      * or if it is doubled, with the international currency symbol.  If the
<span class="line-modified">4355      * CURRENCY_SIGN is seen in a pattern, then the decimal/grouping separators</span>
<span class="line-modified">4356      * are replaced with the monetary decimal/grouping separators.</span>
4357      *
4358      * The CURRENCY_SIGN is not localized.
4359      */
4360     private static final char       CURRENCY_SIGN = &#39;\u00A4&#39;;
4361 
4362     private static final char       QUOTE = &#39;\&#39;&#39;;
4363 
4364     private static FieldPosition[] EmptyFieldPositionArray = new FieldPosition[0];
4365 
4366     // Upper limit on integer and fraction digits for a Java double
4367     static final int DOUBLE_INTEGER_DIGITS  = 309;
4368     static final int DOUBLE_FRACTION_DIGITS = 340;
4369 
4370     // Upper limit on integer and fraction digits for BigDecimal and BigInteger
4371     static final int MAXIMUM_INTEGER_DIGITS  = Integer.MAX_VALUE;
4372     static final int MAXIMUM_FRACTION_DIGITS = Integer.MAX_VALUE;
4373 
4374     // Proclaim JDK 1.1 serial compatibility.
<span class="line-added">4375     @java.io.Serial</span>
4376     static final long serialVersionUID = 864413376551465018L;
4377 }
</pre>
</td>
</tr>
</table>
<center><a href="DateFormatSymbols.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DecimalFormatSymbols.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
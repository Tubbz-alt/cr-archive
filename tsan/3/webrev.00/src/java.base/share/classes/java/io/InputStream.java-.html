<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/io/InputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.List;
 31 import java.util.Objects;
 32 
 33 /**
 34  * This abstract class is the superclass of all classes representing
 35  * an input stream of bytes.
 36  *
 37  * &lt;p&gt; Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt;
 38  * must always provide a method that returns the next byte of input.
 39  *
 40  * @author  Arthur van Hoff
 41  * @see     java.io.BufferedInputStream
 42  * @see     java.io.ByteArrayInputStream
 43  * @see     java.io.DataInputStream
 44  * @see     java.io.FilterInputStream
 45  * @see     java.io.InputStream#read()
 46  * @see     java.io.OutputStream
 47  * @see     java.io.PushbackInputStream
 48  * @since   1.0
 49  */
 50 public abstract class InputStream implements Closeable {
 51 
 52     // MAX_SKIP_BUFFER_SIZE is used to determine the maximum buffer size to
 53     // use when skipping.
 54     private static final int MAX_SKIP_BUFFER_SIZE = 2048;
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 8192;
 57 
 58     /**
 59      * Returns a new {@code InputStream} that reads no bytes. The returned
 60      * stream is initially open.  The stream is closed by calling the
 61      * {@code close()} method.  Subsequent calls to {@code close()} have no
 62      * effect.
 63      *
 64      * &lt;p&gt; While the stream is open, the {@code available()}, {@code read()},
 65      * {@code read(byte[])}, {@code read(byte[], int, int)},
 66      * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},
 67      * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},
 68      * and {@code transferTo()} methods all behave as if end of stream has been
 69      * reached.  After the stream has been closed, these methods all throw
 70      * {@code IOException}.
 71      *
 72      * &lt;p&gt; The {@code markSupported()} method returns {@code false}.  The
 73      * {@code mark()} method does nothing, and the {@code reset()} method
 74      * throws {@code IOException}.
 75      *
 76      * @return an {@code InputStream} which contains no bytes
 77      *
 78      * @since 11
 79      */
 80     public static InputStream nullInputStream() {
 81         return new InputStream() {
 82             private volatile boolean closed;
 83 
 84             private void ensureOpen() throws IOException {
 85                 if (closed) {
 86                     throw new IOException(&quot;Stream closed&quot;);
 87                 }
 88             }
 89 
 90             @Override
 91             public int available () throws IOException {
 92                 ensureOpen();
 93                 return 0;
 94             }
 95 
 96             @Override
 97             public int read() throws IOException {
 98                 ensureOpen();
 99                 return -1;
100             }
101 
102             @Override
103             public int read(byte[] b, int off, int len) throws IOException {
104                 Objects.checkFromIndexSize(off, len, b.length);
105                 if (len == 0) {
106                     return 0;
107                 }
108                 ensureOpen();
109                 return -1;
110             }
111 
112             @Override
113             public byte[] readAllBytes() throws IOException {
114                 ensureOpen();
115                 return new byte[0];
116             }
117 
118             @Override
119             public int readNBytes(byte[] b, int off, int len)
120                 throws IOException {
121                 Objects.checkFromIndexSize(off, len, b.length);
122                 ensureOpen();
123                 return 0;
124             }
125 
126             @Override
127             public byte[] readNBytes(int len) throws IOException {
128                 if (len &lt; 0) {
129                     throw new IllegalArgumentException(&quot;len &lt; 0&quot;);
130                 }
131                 ensureOpen();
132                 return new byte[0];
133             }
134 
135             @Override
136             public long skip(long n) throws IOException {
137                 ensureOpen();
138                 return 0L;
139             }
140 
141             @Override
142             public void skipNBytes(long n) throws IOException {
143                 ensureOpen();
144                 if (n &gt; 0) {
145                     throw new EOFException();
146                 }
147             }
148 
149             @Override
150             public long transferTo(OutputStream out) throws IOException {
151                 Objects.requireNonNull(out);
152                 ensureOpen();
153                 return 0L;
154             }
155 
156             @Override
157             public void close() throws IOException {
158                 closed = true;
159             }
160         };
161     }
162 
163     /**
164      * Reads the next byte of data from the input stream. The value byte is
165      * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to
166      * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream
167      * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method
168      * blocks until input data is available, the end of the stream is detected,
169      * or an exception is thrown.
170      *
171      * &lt;p&gt; A subclass must provide an implementation of this method.
172      *
173      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
174      *             stream is reached.
175      * @exception  IOException  if an I/O error occurs.
176      */
177     public abstract int read() throws IOException;
178 
179     /**
180      * Reads some number of bytes from the input stream and stores them into
181      * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is
182      * returned as an integer.  This method blocks until input data is
183      * available, end of file is detected, or an exception is thrown.
184      *
185      * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and
186      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
187      * least one byte. If no byte is available because the stream is at the
188      * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at
189      * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.
190      *
191      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the
192      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,
193      * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the
194      * number of bytes actually read; these bytes will be stored in elements
195      * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
196      * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
197      * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.
198      *
199      * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;
200      * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;
201      *
202      * @param      b   the buffer into which the data is read.
203      * @return     the total number of bytes read into the buffer, or
204      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
205      *             the stream has been reached.
206      * @exception  IOException  If the first byte cannot be read for any reason
207      * other than the end of the file, if the input stream has been closed, or
208      * if some other I/O error occurs.
209      * @exception  NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
210      * @see        java.io.InputStream#read(byte[], int, int)
211      */
212     public int read(byte b[]) throws IOException {
213         return read(b, 0, b.length);
214     }
215 
216     /**
217      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the input stream into
218      * an array of bytes.  An attempt is made to read as many as
219      * &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read.
220      * The number of bytes actually read is returned as an integer.
221      *
222      * &lt;p&gt; This method blocks until input data is available, end of file is
223      * detected, or an exception is thrown.
224      *
225      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and
226      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
227      * least one byte. If no byte is available because the stream is at end of
228      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one
229      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.
230      *
231      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the
232      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read
233      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of
234      * bytes actually read; these bytes will be stored in elements
235      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
236      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
237      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.
238      *
239      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through
240      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through
241      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.
242      *
243      * &lt;p&gt; The &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method
244      * for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method
245      * &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an
246      * &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to
247      * the &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method.  If
248      * any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a
249      * &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it
250      * were end of file; the bytes read up to that point are stored into
251      * &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception
252      * occurred is returned. The default implementation of this method blocks
253      * until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read,
254      * end of file is detected, or an exception is thrown. Subclasses are
255      * encouraged to provide a more efficient implementation of this method.
256      *
257      * @param      b     the buffer into which the data is read.
258      * @param      off   the start offset in array &lt;code&gt;b&lt;/code&gt;
259      *                   at which the data is written.
260      * @param      len   the maximum number of bytes to read.
261      * @return     the total number of bytes read into the buffer, or
262      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
263      *             the stream has been reached.
264      * @exception  IOException If the first byte cannot be read for any reason
265      * other than end of file, or if the input stream has been closed, or if
266      * some other I/O error occurs.
267      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
268      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
269      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
270      * &lt;code&gt;b.length - off&lt;/code&gt;
271      * @see        java.io.InputStream#read()
272      */
273     public int read(byte b[], int off, int len) throws IOException {
274         Objects.checkFromIndexSize(off, len, b.length);
275         if (len == 0) {
276             return 0;
277         }
278 
279         int c = read();
280         if (c == -1) {
281             return -1;
282         }
283         b[off] = (byte)c;
284 
285         int i = 1;
286         try {
287             for (; i &lt; len ; i++) {
288                 c = read();
289                 if (c == -1) {
290                     break;
291                 }
292                 b[off + i] = (byte)c;
293             }
294         } catch (IOException ee) {
295         }
296         return i;
297     }
298 
299     /**
300      * The maximum size of array to allocate.
301      * Some VMs reserve some header words in an array.
302      * Attempts to allocate larger arrays may result in
303      * OutOfMemoryError: Requested array size exceeds VM limit
304      */
305     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
306 
307     /**
308      * Reads all remaining bytes from the input stream. This method blocks until
309      * all remaining bytes have been read and end of stream is detected, or an
310      * exception is thrown. This method does not close the input stream.
311      *
312      * &lt;p&gt; When this stream reaches end of stream, further invocations of this
313      * method will return an empty byte array.
314      *
315      * &lt;p&gt; Note that this method is intended for simple cases where it is
316      * convenient to read all bytes into a byte array. It is not intended for
317      * reading input streams with large amounts of data.
318      *
319      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
320      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
321      * stream specific, and therefore not specified.
322      *
323      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
324      * so after some, but not all, bytes have been read. Consequently the input
325      * stream may not be at end of stream and may be in an inconsistent state.
326      * It is strongly recommended that the stream be promptly closed if an I/O
327      * error occurs.
328      *
329      * @implSpec
330      * This method invokes {@link #readNBytes(int)} with a length of
331      * {@link Integer#MAX_VALUE}.
332      *
333      * @return a byte array containing the bytes read from this input stream
334      * @throws IOException if an I/O error occurs
335      * @throws OutOfMemoryError if an array of the required size cannot be
336      *         allocated.
337      *
338      * @since 9
339      */
340     public byte[] readAllBytes() throws IOException {
341         return readNBytes(Integer.MAX_VALUE);
342     }
343 
344     /**
345      * Reads up to a specified number of bytes from the input stream. This
346      * method blocks until the requested number of bytes have been read, end
347      * of stream is detected, or an exception is thrown. This method does not
348      * close the input stream.
349      *
350      * &lt;p&gt; The length of the returned array equals the number of bytes read
351      * from the stream. If {@code len} is zero, then no bytes are read and
352      * an empty byte array is returned. Otherwise, up to {@code len} bytes
353      * are read from the stream. Fewer than {@code len} bytes may be read if
354      * end of stream is encountered.
355      *
356      * &lt;p&gt; When this stream reaches end of stream, further invocations of this
357      * method will return an empty byte array.
358      *
359      * &lt;p&gt; Note that this method is intended for simple cases where it is
360      * convenient to read the specified number of bytes into a byte array. The
361      * total amount of memory allocated by this method is proportional to the
362      * number of bytes read from the stream which is bounded by {@code len}.
363      * Therefore, the method may be safely called with very large values of
364      * {@code len} provided sufficient memory is available.
365      *
366      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
367      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
368      * stream specific, and therefore not specified.
369      *
370      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
371      * so after some, but not all, bytes have been read. Consequently the input
372      * stream may not be at end of stream and may be in an inconsistent state.
373      * It is strongly recommended that the stream be promptly closed if an I/O
374      * error occurs.
375      *
376      * @implNote
377      * The number of bytes allocated to read data from this stream and return
378      * the result is bounded by {@code 2*(long)len}, inclusive.
379      *
380      * @param len the maximum number of bytes to read
381      * @return a byte array containing the bytes read from this input stream
382      * @throws IllegalArgumentException if {@code length} is negative
383      * @throws IOException if an I/O error occurs
384      * @throws OutOfMemoryError if an array of the required size cannot be
385      *         allocated.
386      *
387      * @since 11
388      */
389     public byte[] readNBytes(int len) throws IOException {
390         if (len &lt; 0) {
391             throw new IllegalArgumentException(&quot;len &lt; 0&quot;);
392         }
393 
394         List&lt;byte[]&gt; bufs = null;
395         byte[] result = null;
396         int total = 0;
397         int remaining = len;
398         int n;
399         do {
400             byte[] buf = new byte[Math.min(remaining, DEFAULT_BUFFER_SIZE)];
401             int nread = 0;
402 
403             // read to EOF which may read more or less than buffer size
404             while ((n = read(buf, nread,
405                     Math.min(buf.length - nread, remaining))) &gt; 0) {
406                 nread += n;
407                 remaining -= n;
408             }
409 
410             if (nread &gt; 0) {
411                 if (MAX_BUFFER_SIZE - total &lt; nread) {
412                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);
413                 }
414                 total += nread;
415                 if (result == null) {
416                     result = buf;
417                 } else {
418                     if (bufs == null) {
419                         bufs = new ArrayList&lt;&gt;();
420                         bufs.add(result);
421                     }
422                     bufs.add(buf);
423                 }
424             }
425             // if the last call to read returned -1 or the number of bytes
426             // requested have been read then break
427         } while (n &gt;= 0 &amp;&amp; remaining &gt; 0);
428 
429         if (bufs == null) {
430             if (result == null) {
431                 return new byte[0];
432             }
433             return result.length == total ?
434                 result : Arrays.copyOf(result, total);
435         }
436 
437         result = new byte[total];
438         int offset = 0;
439         remaining = total;
440         for (byte[] b : bufs) {
441             int count = Math.min(b.length, remaining);
442             System.arraycopy(b, 0, result, offset, count);
443             offset += count;
444             remaining -= count;
445         }
446 
447         return result;
448     }
449 
450     /**
451      * Reads the requested number of bytes from the input stream into the given
452      * byte array. This method blocks until {@code len} bytes of input data have
453      * been read, end of stream is detected, or an exception is thrown. The
454      * number of bytes actually read, possibly zero, is returned. This method
455      * does not close the input stream.
456      *
457      * &lt;p&gt; In the case where end of stream is reached before {@code len} bytes
458      * have been read, then the actual number of bytes read will be returned.
459      * When this stream reaches end of stream, further invocations of this
460      * method will return zero.
461      *
462      * &lt;p&gt; If {@code len} is zero, then no bytes are read and {@code 0} is
463      * returned; otherwise, there is an attempt to read up to {@code len} bytes.
464      *
465      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the next
466      * one in to {@code b[off+1]}, and so on. The number of bytes read is, at
467      * most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of bytes actually
468      * read; these bytes will be stored in elements {@code b[off]} through
469      * {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]}, leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;
470      * {@code ]} through {@code b[off+len-1]} unaffected.
471      *
472      * &lt;p&gt; The behavior for the case where the input stream is &lt;i&gt;asynchronously
473      * closed&lt;/i&gt;, or the thread interrupted during the read, is highly input
474      * stream specific, and therefore not specified.
475      *
476      * &lt;p&gt; If an I/O error occurs reading from the input stream, then it may do
477      * so after some, but not all, bytes of {@code b} have been updated with
478      * data from the input stream. Consequently the input stream and {@code b}
479      * may be in an inconsistent state. It is strongly recommended that the
480      * stream be promptly closed if an I/O error occurs.
481      *
482      * @param  b the byte array into which the data is read
483      * @param  off the start offset in {@code b} at which the data is written
484      * @param  len the maximum number of bytes to read
485      * @return the actual number of bytes read into the buffer
486      * @throws IOException if an I/O error occurs
487      * @throws NullPointerException if {@code b} is {@code null}
488      * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}
489      *         is negative, or {@code len} is greater than {@code b.length - off}
490      *
491      * @since 9
492      */
493     public int readNBytes(byte[] b, int off, int len) throws IOException {
494         Objects.checkFromIndexSize(off, len, b.length);
495 
496         int n = 0;
497         while (n &lt; len) {
498             int count = read(b, off + n, len - n);
499             if (count &lt; 0)
500                 break;
501             n += count;
502         }
503         return n;
504     }
505 
506     /**
507      * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this input
508      * stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end
509      * up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;.
510      * This may result from any of a number of conditions; reaching end of file
511      * before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one possibility.
512      * The actual number of bytes skipped is returned. If {@code n} is
513      * negative, the {@code skip} method for class {@code InputStream} always
514      * returns 0, and no bytes are skipped. Subclasses may handle the negative
515      * value differently.
516      *
517      * &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a
518      * byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes
519      * have been read or the end of the stream has been reached. Subclasses are
520      * encouraged to provide a more efficient implementation of this method.
521      * For instance, the implementation may depend on the ability to seek.
522      *
523      * @param      n   the number of bytes to be skipped.
524      * @return     the actual number of bytes skipped which might be zero.
525      * @throws     IOException  if an I/O error occurs.
526      * @see        java.io.InputStream#skipNBytes(long)
527      */
528     public long skip(long n) throws IOException {
529         long remaining = n;
530         int nr;
531 
532         if (n &lt;= 0) {
533             return 0;
534         }
535 
536         int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
537         byte[] skipBuffer = new byte[size];
538         while (remaining &gt; 0) {
539             nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
540             if (nr &lt; 0) {
541                 break;
542             }
543             remaining -= nr;
544         }
545 
546         return n - remaining;
547     }
548 
549     /**
550      * Skips over and discards exactly {@code n} bytes of data from this input
551      * stream.  If {@code n} is zero, then no bytes are skipped.
552      * If {@code n} is negative, then no bytes are skipped.
553      * Subclasses may handle the negative value differently.
554      *
555      * &lt;p&gt; This method blocks until the requested number of bytes have been
556      * skipped, end of file is reached, or an exception is thrown.
557      *
558      * &lt;p&gt; If end of stream is reached before the stream is at the desired
559      * position, then an {@code EOFException} is thrown.
560      *
561      * &lt;p&gt; If an I/O error occurs, then the input stream may be
562      * in an inconsistent state. It is strongly recommended that the
563      * stream be promptly closed if an I/O error occurs.
564      *
565      * @implNote
566      * Subclasses are encouraged to provide a more efficient implementation
567      * of this method.
568      *
569      * @implSpec
570      * If {@code n} is zero or negative, then no bytes are skipped.
571      * If {@code n} is positive, the default implementation of this method
572      * invokes {@link #skip(long) skip()} with parameter {@code n}.  If the
573      * return value of {@code skip(n)} is non-negative and less than {@code n},
574      * then {@link #read()} is invoked repeatedly until the stream is {@code n}
575      * bytes beyond its position when this method was invoked or end of stream
576      * is reached.  If the return value of {@code skip(n)} is negative or
577      * greater than {@code n}, then an {@code IOException} is thrown.  Any
578      * exception thrown by {@code skip()} or {@code read()} will be propagated.
579      *
580      * @param      n   the number of bytes to be skipped.
581      * @throws     EOFException if end of stream is encountered before the
582      *             stream can be positioned {@code n} bytes beyond its position
583      *             when this method was invoked.
584      * @throws     IOException  if the stream cannot be positioned properly or
585      *             if an I/O error occurs.
586      * @see        java.io.InputStream#skip(long)
587      */
588     public void skipNBytes(long n) throws IOException {
589         if (n &gt; 0) {
590             long ns = skip(n);
591             if (ns &gt;= 0 &amp;&amp; ns &lt; n) { // skipped too few bytes
592                 // adjust number to skip
593                 n -= ns;
594                 // read until requested number skipped or EOS reached
595                 while (n &gt; 0 &amp;&amp; read() != -1) {
596                     n--;
597                 }
598                 // if not enough skipped, then EOFE
599                 if (n != 0) {
600                     throw new EOFException();
601                 }
602             } else if (ns != n) { // skipped negative or too many bytes
603                 throw new IOException(&quot;Unable to skip exactly&quot;);
604             }
605         }
606     }
607 
608     /**
609      * Returns an estimate of the number of bytes that can be read (or skipped
610      * over) from this input stream without blocking, which may be 0, or 0 when
611      * end of stream is detected.  The read might be on the same thread or
612      * another thread.  A single read or skip of this many bytes will not block,
613      * but may read or skip fewer bytes.
614      *
615      * &lt;p&gt; Note that while some implementations of {@code InputStream} will
616      * return the total number of bytes in the stream, many will not.  It is
617      * never correct to use the return value of this method to allocate
618      * a buffer intended to hold all data in this stream.
619      *
620      * &lt;p&gt; A subclass&#39;s implementation of this method may choose to throw an
621      * {@link IOException} if this input stream has been closed by invoking the
622      * {@link #close()} method.
623      *
624      * &lt;p&gt; The {@code available} method of {@code InputStream} always returns
625      * {@code 0}.
626      *
627      * &lt;p&gt; This method should be overridden by subclasses.
628      *
629      * @return     an estimate of the number of bytes that can be read (or
630      *             skipped over) from this input stream without blocking or
631      *             {@code 0} when it reaches the end of the input stream.
632      * @exception  IOException if an I/O error occurs.
633      */
634     public int available() throws IOException {
635         return 0;
636     }
637 
638     /**
639      * Closes this input stream and releases any system resources associated
640      * with the stream.
641      *
642      * &lt;p&gt; The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does
643      * nothing.
644      *
645      * @exception  IOException  if an I/O error occurs.
646      */
647     public void close() throws IOException {}
648 
649     /**
650      * Marks the current position in this input stream. A subsequent call to
651      * the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at the last marked
652      * position so that subsequent reads re-read the same bytes.
653      *
654      * &lt;p&gt; The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to
655      * allow that many bytes to be read before the mark position gets
656      * invalidated.
657      *
658      * &lt;p&gt; The general contract of &lt;code&gt;mark&lt;/code&gt; is that, if the method
659      * &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the stream somehow
660      * remembers all the bytes read after the call to &lt;code&gt;mark&lt;/code&gt; and
661      * stands ready to supply those same bytes again if and whenever the method
662      * &lt;code&gt;reset&lt;/code&gt; is called.  However, the stream is not required to
663      * remember any data at all if more than &lt;code&gt;readlimit&lt;/code&gt; bytes are
664      * read from the stream before &lt;code&gt;reset&lt;/code&gt; is called.
665      *
666      * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
667      *
668      * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does
669      * nothing.
670      *
671      * @param   readlimit   the maximum limit of bytes that can be read before
672      *                      the mark position becomes invalid.
673      * @see     java.io.InputStream#reset()
674      */
675     public synchronized void mark(int readlimit) {}
676 
677     /**
678      * Repositions this stream to the position at the time the
679      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
680      *
681      * &lt;p&gt; The general contract of &lt;code&gt;reset&lt;/code&gt; is:
682      *
683      * &lt;ul&gt;
684      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns
685      * &lt;code&gt;true&lt;/code&gt;, then:
686      *
687      *     &lt;ul&gt;&lt;li&gt; If the method &lt;code&gt;mark&lt;/code&gt; has not been called since
688      *     the stream was created, or the number of bytes read from the stream
689      *     since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument
690      *     to &lt;code&gt;mark&lt;/code&gt; at that last call, then an
691      *     &lt;code&gt;IOException&lt;/code&gt; might be thrown.
692      *
693      *     &lt;li&gt; If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the
694      *     stream is reset to a state such that all the bytes read since the
695      *     most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the
696      *     file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied
697      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by
698      *     any bytes that otherwise would have been the next input data as of
699      *     the time of the call to &lt;code&gt;reset&lt;/code&gt;. &lt;/ul&gt;
700      *
701      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns
702      * &lt;code&gt;false&lt;/code&gt;, then:
703      *
704      *     &lt;ul&gt;&lt;li&gt; The call to &lt;code&gt;reset&lt;/code&gt; may throw an
705      *     &lt;code&gt;IOException&lt;/code&gt;.
706      *
707      *     &lt;li&gt; If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream
708      *     is reset to a fixed state that depends on the particular type of the
709      *     input stream and how it was created. The bytes that will be supplied
710      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the
711      *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
712      *
713      * &lt;p&gt;The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt;
714      * does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.
715      *
716      * @exception  IOException  if this stream has not been marked or if the
717      *               mark has been invalidated.
718      * @see     java.io.InputStream#mark(int)
719      * @see     java.io.IOException
720      */
721     public synchronized void reset() throws IOException {
722         throw new IOException(&quot;mark/reset not supported&quot;);
723     }
724 
725     /**
726      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and
727      * &lt;code&gt;reset&lt;/code&gt; methods. Whether or not &lt;code&gt;mark&lt;/code&gt; and
728      * &lt;code&gt;reset&lt;/code&gt; are supported is an invariant property of a
729      * particular input stream instance. The &lt;code&gt;markSupported&lt;/code&gt; method
730      * of &lt;code&gt;InputStream&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
731      *
732      * @return  &lt;code&gt;true&lt;/code&gt; if this stream instance supports the mark
733      *          and reset methods; &lt;code&gt;false&lt;/code&gt; otherwise.
734      * @see     java.io.InputStream#mark(int)
735      * @see     java.io.InputStream#reset()
736      */
737     public boolean markSupported() {
738         return false;
739     }
740 
741     /**
742      * Reads all bytes from this input stream and writes the bytes to the
743      * given output stream in the order that they are read. On return, this
744      * input stream will be at end of stream. This method does not close either
745      * stream.
746      * &lt;p&gt;
747      * This method may block indefinitely reading from the input stream, or
748      * writing to the output stream. The behavior for the case where the input
749      * and/or output stream is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
750      * interrupted during the transfer, is highly input and output stream
751      * specific, and therefore not specified.
752      * &lt;p&gt;
753      * If an I/O error occurs reading from the input stream or writing to the
754      * output stream, then it may do so after some bytes have been read or
755      * written. Consequently the input stream may not be at end of stream and
756      * one, or both, streams may be in an inconsistent state. It is strongly
757      * recommended that both streams be promptly closed if an I/O error occurs.
758      *
759      * @param  out the output stream, non-null
760      * @return the number of bytes transferred
761      * @throws IOException if an I/O error occurs when reading or writing
762      * @throws NullPointerException if {@code out} is {@code null}
763      *
764      * @since 9
765      */
766     public long transferTo(OutputStream out) throws IOException {
767         Objects.requireNonNull(out, &quot;out&quot;);
768         long transferred = 0;
769         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
770         int read;
771         while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) &gt;= 0) {
772             out.write(buffer, 0, read);
773             transferred += read;
774         }
775         return transferred;
776     }
777 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemberName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  35 import java.lang.constant.MethodHandleDesc;
  36 import java.lang.constant.MethodTypeDesc;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 import java.util.Optional;
  40 
  41 import static java.lang.invoke.MethodHandleInfo.*;
  42 import static java.lang.invoke.MethodHandleStatics.*;
  43 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  44 
  45 /**
  46  * A method handle is a typed, directly executable reference to an underlying method,
  47  * constructor, field, or similar low-level operation, with optional
  48  * transformations of arguments or return values.
  49  * These transformations are quite general, and include such patterns as
  50  * {@linkplain #asType conversion},
  51  * {@linkplain #bindTo insertion},
  52  * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},
  53  * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.
  54  *
<span class="line-modified">  55  * &lt;h1&gt;Method handle contents&lt;/h1&gt;</span>
  56  * Method handles are dynamically and strongly typed according to their parameter and return types.
  57  * They are not distinguished by the name or the defining class of their underlying methods.
  58  * A method handle must be invoked using a symbolic type descriptor which matches
  59  * the method handle&#39;s own {@linkplain #type() type descriptor}.
  60  * &lt;p&gt;
  61  * Every method handle reports its type descriptor via the {@link #type() type} accessor.
  62  * This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,
  63  * whose structure is a series of classes, one of which is
  64  * the return type of the method (or {@code void.class} if none).
  65  * &lt;p&gt;
  66  * A method handle&#39;s type controls the types of invocations it accepts,
  67  * and the kinds of transformations that apply to it.
  68  * &lt;p&gt;
  69  * A method handle contains a pair of special invoker methods
  70  * called {@link #invokeExact invokeExact} and {@link #invoke invoke}.
  71  * Both invoker methods provide direct access to the method handle&#39;s
  72  * underlying method, constructor, field, or other operation,
  73  * as modified by transformations of arguments and return values.
  74  * Both invokers accept calls which exactly match the method handle&#39;s own type.
  75  * The plain, inexact invoker also accepts a range of other call types.
  76  * &lt;p&gt;
  77  * Method handles are immutable and have no visible state.
  78  * Of course, they can be bound to underlying methods or data which exhibit state.
  79  * With respect to the Java Memory Model, any method handle will behave
  80  * as if all of its (internal) fields are final variables.  This means that any method
  81  * handle made visible to the application will always be fully formed.
  82  * This is true even if the method handle is published through a shared
  83  * variable in a data race.
  84  * &lt;p&gt;
  85  * Method handles cannot be subclassed by the user.
  86  * Implementations may (or may not) create internal subclasses of {@code MethodHandle}
  87  * which may be visible via the {@link java.lang.Object#getClass Object.getClass}
  88  * operation.  The programmer should not draw conclusions about a method handle
  89  * from its specific class, as the method handle class hierarchy (if any)
  90  * may change from time to time or across implementations from different vendors.
  91  *
<span class="line-modified">  92  * &lt;h1&gt;Method handle compilation&lt;/h1&gt;</span>
  93  * A Java method call expression naming {@code invokeExact} or {@code invoke}
  94  * can invoke a method handle from Java source code.
  95  * From the viewpoint of source code, these methods can take any arguments
  96  * and their result can be cast to any return type.
  97  * Formally this is accomplished by giving the invoker methods
  98  * {@code Object} return types and variable arity {@code Object} arguments,
  99  * but they have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt;
 100  * which connects this freedom of invocation directly to the JVM execution stack.
 101  * &lt;p&gt;
 102  * As is usual with virtual methods, source-level calls to {@code invokeExact}
 103  * and {@code invoke} compile to an {@code invokevirtual} instruction.
 104  * More unusually, the compiler must record the actual argument types,
 105  * and may not perform method invocation conversions on the arguments.
 106  * Instead, it must generate instructions that push them on the stack according
 107  * to their own unconverted types.  The method handle object itself is pushed on
 108  * the stack before the arguments.
 109  * The compiler then generates an {@code invokevirtual} instruction that invokes
 110  * the method handle with a symbolic type descriptor which describes the argument
 111  * and return types.
 112  * &lt;p&gt;
 113  * To issue a complete symbolic type descriptor, the compiler must also determine
 114  * the return type.  This is based on a cast on the method invocation expression,
 115  * if there is one, or else {@code Object} if the invocation is an expression,
 116  * or else {@code void} if the invocation is a statement.
 117  * The cast may be to a primitive type (but not {@code void}).
 118  * &lt;p&gt;
 119  * As a corner case, an uncasted {@code null} argument is given
 120  * a symbolic type descriptor of {@code java.lang.Void}.
 121  * The ambiguity with the type {@code Void} is harmless, since there are no references of type
 122  * {@code Void} except the null reference.
 123  *
<span class="line-modified"> 124  * &lt;h1&gt;Method handle invocation&lt;/h1&gt;</span>
 125  * The first time an {@code invokevirtual} instruction is executed
 126  * it is linked by symbolically resolving the names in the instruction
 127  * and verifying that the method call is statically legal.
 128  * This also holds for calls to {@code invokeExact} and {@code invoke}.
 129  * In this case, the symbolic type descriptor emitted by the compiler is checked for
 130  * correct syntax, and names it contains are resolved.
 131  * Thus, an {@code invokevirtual} instruction which invokes
 132  * a method handle will always link, as long
 133  * as the symbolic type descriptor is syntactically well-formed
 134  * and the types exist.
 135  * &lt;p&gt;
 136  * When the {@code invokevirtual} is executed after linking,
 137  * the receiving method handle&#39;s type is first checked by the JVM
 138  * to ensure that it matches the symbolic type descriptor.
 139  * If the type match fails, it means that the method which the
 140  * caller is invoking is not present on the individual
 141  * method handle being invoked.
 142  * &lt;p&gt;
 143  * In the case of {@code invokeExact}, the type descriptor of the invocation
 144  * (after resolving symbolic type names) must exactly match the method type
</pre>
<hr />
<pre>
 147  * must be a valid argument to the receiver&#39;s {@link #asType asType} method.
 148  * Thus, plain {@code invoke} is more permissive than {@code invokeExact}.
 149  * &lt;p&gt;
 150  * After type matching, a call to {@code invokeExact} directly
 151  * and immediately invoke the method handle&#39;s underlying method
 152  * (or other behavior, as the case may be).
 153  * &lt;p&gt;
 154  * A call to plain {@code invoke} works the same as a call to
 155  * {@code invokeExact}, if the symbolic type descriptor specified by the caller
 156  * exactly matches the method handle&#39;s own type.
 157  * If there is a type mismatch, {@code invoke} attempts
 158  * to adjust the type of the receiving method handle,
 159  * as if by a call to {@link #asType asType},
 160  * to obtain an exactly invokable method handle {@code M2}.
 161  * This allows a more powerful negotiation of method type
 162  * between caller and callee.
 163  * &lt;p&gt;
 164  * (&lt;em&gt;Note:&lt;/em&gt; The adjusted method handle {@code M2} is not directly observable,
 165  * and implementations are therefore not required to materialize it.)
 166  *
<span class="line-modified"> 167  * &lt;h1&gt;Invocation checking&lt;/h1&gt;</span>
 168  * In typical programs, method handle type matching will usually succeed.
 169  * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},
 170  * either directly (in the case of {@code invokeExact}) or indirectly as if
 171  * by a failed call to {@code asType} (in the case of {@code invoke}).
 172  * &lt;p&gt;
 173  * Thus, a method type mismatch which might show up as a linkage error
 174  * in a statically typed program can show up as
 175  * a dynamic {@code WrongMethodTypeException}
 176  * in a program which uses method handles.
 177  * &lt;p&gt;
 178  * Because method types contain &quot;live&quot; {@code Class} objects,
 179  * method type matching takes into account both type names and class loaders.
 180  * Thus, even if a method handle {@code M} is created in one
 181  * class loader {@code L1} and used in another {@code L2},
 182  * method handle calls are type-safe, because the caller&#39;s symbolic type
 183  * descriptor, as resolved in {@code L2},
 184  * is matched against the original callee method&#39;s symbolic type descriptor,
 185  * as resolved in {@code L1}.
 186  * The resolution in {@code L1} happens when {@code M} is created
 187  * and its type is assigned, while the resolution in {@code L2} happens
 188  * when the {@code invokevirtual} instruction is linked.
 189  * &lt;p&gt;
 190  * Apart from type descriptor checks,
 191  * a method handle&#39;s capability to call its underlying method is unrestricted.
 192  * If a method handle is formed on a non-public method by a class
 193  * that has access to that method, the resulting handle can be used
 194  * in any place by any caller who receives a reference to it.
 195  * &lt;p&gt;
 196  * Unlike with the Core Reflection API, where access is checked every time
 197  * a reflective method is invoked,
 198  * method handle access checking is performed
 199  * &lt;a href=&quot;MethodHandles.Lookup.html#access&quot;&gt;when the method handle is created&lt;/a&gt;.
 200  * In the case of {@code ldc} (see below), access checking is performed as part of linking
 201  * the constant pool entry underlying the constant method handle.
 202  * &lt;p&gt;
 203  * Thus, handles to non-public methods, or to methods in non-public classes,
 204  * should generally be kept secret.
 205  * They should not be passed to untrusted code unless their use from
 206  * the untrusted code would be harmless.
 207  *
<span class="line-modified"> 208  * &lt;h1&gt;Method handle creation&lt;/h1&gt;</span>
 209  * Java code can create a method handle that directly accesses
 210  * any method, constructor, or field that is accessible to that code.
 211  * This is done via a reflective, capability-based API called
 212  * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}.
 213  * For example, a static method handle can be obtained
 214  * from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.
 215  * There are also conversion methods from Core Reflection API objects,
 216  * such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 217  * &lt;p&gt;
 218  * Like classes and strings, method handles that correspond to accessible
 219  * fields, methods, and constructors can also be represented directly
 220  * in a class file&#39;s constant pool as constants to be loaded by {@code ldc} bytecodes.
 221  * A new type of constant pool entry, {@code CONSTANT_MethodHandle},
 222  * refers directly to an associated {@code CONSTANT_Methodref},
 223  * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}
 224  * constant pool entry.
<span class="line-modified"> 225  * (For full details on method handle constants,</span>
<span class="line-modified"> 226  * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)</span>

 227  * &lt;p&gt;
 228  * Method handles produced by lookups or constant loads from methods or
 229  * constructors with the variable arity modifier bit ({@code 0x0080})
 230  * have a corresponding variable arity, as if they were defined with
 231  * the help of {@link #asVarargsCollector asVarargsCollector}
 232  * or {@link #withVarargs withVarargs}.
 233  * &lt;p&gt;
 234  * A method reference may refer either to a static or non-static method.
 235  * In the non-static case, the method handle type includes an explicit
 236  * receiver argument, prepended before any other arguments.
 237  * In the method handle&#39;s type, the initial receiver argument is typed
 238  * according to the class under which the method was initially requested.
 239  * (E.g., if a non-static method handle is obtained via {@code ldc},
 240  * the type of the receiver is the class named in the constant pool entry.)
 241  * &lt;p&gt;
 242  * Method handle constants are subject to the same link-time access checks
 243  * their corresponding bytecode instructions, and the {@code ldc} instruction
 244  * will throw corresponding linkage errors if the bytecode behaviors would
 245  * throw such errors.
 246  * &lt;p&gt;
 247  * As a corollary of this, access to protected members is restricted
 248  * to receivers only of the accessing class, or one of its subclasses,
 249  * and the accessing class must in turn be a subclass (or package sibling)
 250  * of the protected member&#39;s defining class.
 251  * If a method reference refers to a protected non-static method or field
 252  * of a class outside the current package, the receiver argument will
 253  * be narrowed to the type of the accessing class.
 254  * &lt;p&gt;
 255  * When a method handle to a virtual method is invoked, the method is
 256  * always looked up in the receiver (that is, the first argument).
 257  * &lt;p&gt;
 258  * A non-virtual method handle to a specific virtual method implementation
 259  * can also be created.  These do not perform virtual lookup based on
 260  * receiver type.  Such a method handle simulates the effect of
 261  * an {@code invokespecial} instruction to the same method.
 262  * A non-virtual method handle can also be created to simulate the effect
 263  * of an {@code invokevirtual} or {@code invokeinterface} instruction on
 264  * a private method (as applicable).
 265  *
<span class="line-modified"> 266  * &lt;h1&gt;Usage examples&lt;/h1&gt;</span>
 267  * Here are some examples of usage:
 268  * &lt;blockquote&gt;&lt;pre&gt;{@code
 269 Object x, y; String s; int i;
 270 MethodType mt; MethodHandle mh;
 271 MethodHandles.Lookup lookup = MethodHandles.lookup();
 272 // mt is (char,char)String
 273 mt = MethodType.methodType(String.class, char.class, char.class);
 274 mh = lookup.findVirtual(String.class, &quot;replace&quot;, mt);
 275 s = (String) mh.invokeExact(&quot;daddy&quot;,&#39;d&#39;,&#39;n&#39;);
 276 // invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
 277 assertEquals(s, &quot;nanny&quot;);
 278 // weakly typed invocation (using MHs.invoke)
 279 s = (String) mh.invokeWithArguments(&quot;sappy&quot;, &#39;p&#39;, &#39;v&#39;);
 280 assertEquals(s, &quot;savvy&quot;);
 281 // mt is (Object[])List
 282 mt = MethodType.methodType(java.util.List.class, Object[].class);
 283 mh = lookup.findStatic(java.util.Arrays.class, &quot;asList&quot;, mt);
 284 assert(mh.isVarargsCollector());
 285 x = mh.invoke(&quot;one&quot;, &quot;two&quot;);
 286 // invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
</pre>
<hr />
<pre>
 292 // invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
 293 assertEquals(x, java.util.Arrays.asList(1,2,3));
 294 // mt is ()int
 295 mt = MethodType.methodType(int.class);
 296 mh = lookup.findVirtual(java.util.List.class, &quot;size&quot;, mt);
 297 i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
 298 // invokeExact(Ljava/util/List;)I
 299 assert(i == 3);
 300 mt = MethodType.methodType(void.class, String.class);
 301 mh = lookup.findVirtual(java.io.PrintStream.class, &quot;println&quot;, mt);
 302 mh.invokeExact(System.out, &quot;Hello, world.&quot;);
 303 // invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
 304  * }&lt;/pre&gt;&lt;/blockquote&gt;
 305  * Each of the above calls to {@code invokeExact} or plain {@code invoke}
 306  * generates a single invokevirtual instruction with
 307  * the symbolic type descriptor indicated in the following comment.
 308  * In these examples, the helper method {@code assertEquals} is assumed to
 309  * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}
 310  * on its arguments, and asserts that the result is true.
 311  *
<span class="line-modified"> 312  * &lt;h1&gt;Exceptions&lt;/h1&gt;</span>
 313  * The methods {@code invokeExact} and {@code invoke} are declared
 314  * to throw {@link java.lang.Throwable Throwable},
 315  * which is to say that there is no static restriction on what a method handle
 316  * can throw.  Since the JVM does not distinguish between checked
 317  * and unchecked exceptions (other than by their class, of course),
 318  * there is no particular effect on bytecode shape from ascribing
 319  * checked exceptions to method handle invocations.  But in Java source
 320  * code, methods which perform method handle calls must either explicitly
 321  * throw {@code Throwable}, or else must catch all
 322  * throwables locally, rethrowing only those which are legal in the context,
 323  * and wrapping ones which are illegal.
 324  *
<span class="line-modified"> 325  * &lt;h1&gt;&lt;a id=&quot;sigpoly&quot;&gt;&lt;/a&gt;Signature polymorphism&lt;/h1&gt;</span>
 326  * The unusual compilation and linkage behavior of
 327  * {@code invokeExact} and plain {@code invoke}
 328  * is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;.
 329  * As defined in the Java Language Specification,
 330  * a signature polymorphic method is one which can operate with
 331  * any of a wide range of call signatures and return types.
 332  * &lt;p&gt;
 333  * In source code, a call to a signature polymorphic method will
 334  * compile, regardless of the requested symbolic type descriptor.
 335  * As usual, the Java compiler emits an {@code invokevirtual}
 336  * instruction with the given symbolic type descriptor against the named method.
 337  * The unusual part is that the symbolic type descriptor is derived from
 338  * the actual argument and return types, not from the method declaration.
 339  * &lt;p&gt;
 340  * When the JVM processes bytecode containing signature polymorphic calls,
 341  * it will successfully link any such call, regardless of its symbolic type descriptor.
 342  * (In order to retain type safety, the JVM will guard such calls with suitable
 343  * dynamic type checks, as described elsewhere.)
 344  * &lt;p&gt;
 345  * Bytecode generators, including the compiler back end, are required to emit
 346  * untransformed symbolic type descriptors for these methods.
 347  * Tools which determine symbolic linkage are required to accept such
 348  * untransformed descriptors, without reporting linkage errors.
 349  *
<span class="line-modified"> 350  * &lt;h1&gt;Interoperation between method handles and the Core Reflection API&lt;/h1&gt;</span>
 351  * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,
 352  * any class member represented by a Core Reflection API object
 353  * can be converted to a behaviorally equivalent method handle.
 354  * For example, a reflective {@link java.lang.reflect.Method Method} can
 355  * be converted to a method handle using
 356  * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 357  * The resulting method handles generally provide more direct and efficient
 358  * access to the underlying class members.
 359  * &lt;p&gt;
 360  * As a special case,
 361  * when the Core Reflection API is used to view the signature polymorphic
 362  * methods {@code invokeExact} or plain {@code invoke} in this class,
 363  * they appear as ordinary non-polymorphic methods.
 364  * Their reflective appearance, as viewed by
 365  * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
 366  * is unaffected by their special status in this API.
 367  * For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}
 368  * will report exactly those modifier bits required for any similarly
 369  * declared method, including in this case {@code native} and {@code varargs} bits.
 370  * &lt;p&gt;
</pre>
<hr />
<pre>
 372  * invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.
 373  * However, such reflective calls do not result in method handle invocations.
 374  * Such a call, if passed the required argument
 375  * (a single one, of type {@code Object[]}), will ignore the argument and
 376  * will throw an {@code UnsupportedOperationException}.
 377  * &lt;p&gt;
 378  * Since {@code invokevirtual} instructions can natively
 379  * invoke method handles under any symbolic type descriptor, this reflective view conflicts
 380  * with the normal presentation of these methods via bytecodes.
 381  * Thus, these two native methods, when reflectively viewed by
 382  * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
 383  * &lt;p&gt;
 384  * In order to obtain an invoker method for a particular type descriptor,
 385  * use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},
 386  * or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.
 387  * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
 388  * API is also able to return a method handle
 389  * to call {@code invokeExact} or plain {@code invoke},
 390  * for any specified type descriptor .
 391  *
<span class="line-modified"> 392  * &lt;h1&gt;Interoperation between method handles and Java generics&lt;/h1&gt;</span>
 393  * A method handle can be obtained on a method, constructor, or field
 394  * which is declared with Java generic types.
 395  * As with the Core Reflection API, the type of the method handle
 396  * will be constructed from the erasure of the source-level type.
 397  * When a method handle is invoked, the types of its arguments
 398  * or the return value cast type may be generic types or type instances.
 399  * If this occurs, the compiler will replace those
 400  * types by their erasures when it constructs the symbolic type descriptor
 401  * for the {@code invokevirtual} instruction.
 402  * &lt;p&gt;
 403  * Method handles do not represent
 404  * their function-like types in terms of Java parameterized (generic) types,
 405  * because there are three mismatches between function-like types and parameterized
 406  * Java types.
 407  * &lt;ul&gt;
 408  * &lt;li&gt;Method types range over all possible arities,
 409  * from no arguments to up to the  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;maximum number&lt;/a&gt; of allowed arguments.
 410  * Generics are not variadic, and so cannot represent this.&lt;/li&gt;
 411  * &lt;li&gt;Method types can specify arguments of primitive types,
 412  * which Java generic types cannot range over.&lt;/li&gt;
 413  * &lt;li&gt;Higher order functions over method handles (combinators) are
 414  * often generic across a wide range of function types, including
 415  * those of multiple arities.  It is impossible to represent such
 416  * genericity with a Java type parameter.&lt;/li&gt;
 417  * &lt;/ul&gt;
 418  *
<span class="line-modified"> 419  * &lt;h1&gt;&lt;a id=&quot;maxarity&quot;&gt;&lt;/a&gt;Arity limits&lt;/h1&gt;</span>
 420  * The JVM imposes on all methods and constructors of any kind an absolute
 421  * limit of 255 stacked arguments.  This limit can appear more restrictive
 422  * in certain cases:
 423  * &lt;ul&gt;
 424  * &lt;li&gt;A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.
 425  * &lt;li&gt;A non-static method consumes an extra argument for the object on which the method is called.
 426  * &lt;li&gt;A constructor consumes an extra argument for the object which is being constructed.
 427  * &lt;li&gt;Since a method handle&amp;rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,
 428  *     it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.
 429  * &lt;/ul&gt;
 430  * These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.
 431  * For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.
 432  * Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.
 433  * In particular, a method handle&amp;rsquo;s type must not have an arity of the exact maximum 255.
 434  *
 435  * @see MethodType
 436  * @see MethodHandles
 437  * @author John Rose, JSR 292 EG
 438  * @since 1.7
 439  */
 440 public abstract class MethodHandle implements Constable {
 441 
 442     /**
 443      * Internal marker interface which distinguishes (to the Java compiler)
 444      * those methods which are &lt;a href=&quot;MethodHandle.html#sigpoly&quot;&gt;signature polymorphic&lt;/a&gt;.
 445      */
 446     @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
 447     @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
 448     @interface PolymorphicSignature { }
 449 
 450     private final MethodType type;
<span class="line-modified"> 451     /*private*/ final LambdaForm form;</span>

 452     // form is not private so that invokers can easily fetch it
<span class="line-modified"> 453     /*private*/ MethodHandle asTypeCache;</span>

 454     // asTypeCache is not private so that invokers can easily fetch it
<span class="line-modified"> 455     /*non-public*/ byte customizationCount;</span>

 456     // customizationCount should be accessible from invokers
 457 
 458     /**
 459      * Reports the type of this method handle.
 460      * Every invocation of this method handle via {@code invokeExact} must exactly match this type.
 461      * @return the method handle type
 462      */
 463     public MethodType type() {
 464         return type;
 465     }
 466 
 467     /**
 468      * Package-private constructor for the method handle implementation hierarchy.
 469      * Method handle inheritance will be contained completely within
 470      * the {@code java.lang.invoke} package.
 471      */
 472     // @param type type (permanently assigned) of the new method handle
<span class="line-modified"> 473     /*non-public*/ MethodHandle(MethodType type, LambdaForm form) {</span>

 474         this.type = Objects.requireNonNull(type);
 475         this.form = Objects.requireNonNull(form).uncustomize();
 476 
 477         this.form.prepare();  // TO DO:  Try to delay this step until just before invocation.
 478     }
 479 
 480     /**
 481      * Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.
 482      * The symbolic type descriptor at the call site of {@code invokeExact} must
 483      * exactly match this method handle&#39;s {@link #type() type}.
 484      * No conversions are allowed on arguments or return values.
 485      * &lt;p&gt;
 486      * When this method is observed via the Core Reflection API,
 487      * it will appear as a single native method, taking an object array and returning an object.
 488      * If this native method is invoked directly via
 489      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
 490      * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
 491      * it will throw an {@code UnsupportedOperationException}.
 492      * @param args the signature-polymorphic parameter list, statically represented using varargs
 493      * @return the signature-polymorphic result, statically represented using {@code Object}
</pre>
<hr />
<pre>
 536     public final native @PolymorphicSignature Object invoke(Object... args) throws Throwable;
 537 
 538     /**
 539      * Private method for trusted invocation of a method handle respecting simplified signatures.
 540      * Type mismatches will not throw {@code WrongMethodTypeException}, but could crash the JVM.
 541      * &lt;p&gt;
 542      * The caller signature is restricted to the following basic types:
 543      * Object, int, long, float, double, and void return.
 544      * &lt;p&gt;
 545      * The caller is responsible for maintaining type correctness by ensuring
 546      * that the each outgoing argument value is a member of the range of the corresponding
 547      * callee argument type.
 548      * (The caller should therefore issue appropriate casts and integer narrowing
 549      * operations on outgoing argument values.)
 550      * The caller can assume that the incoming result value is part of the range
 551      * of the callee&#39;s return type.
 552      * @param args the signature-polymorphic parameter list, statically represented using varargs
 553      * @return the signature-polymorphic result, statically represented using {@code Object}
 554      */
 555     @HotSpotIntrinsicCandidate
<span class="line-modified"> 556     /*non-public*/ final native @PolymorphicSignature Object invokeBasic(Object... args) throws Throwable;</span>

 557 
 558     /**
 559      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}.
 560      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 561      * The trailing (not leading) argument must be a MemberName.
 562      * @param args the signature-polymorphic parameter list, statically represented using varargs
 563      * @return the signature-polymorphic result, statically represented using {@code Object}
 564      */
 565     @HotSpotIntrinsicCandidate
<span class="line-modified"> 566     /*non-public*/ static native @PolymorphicSignature Object linkToVirtual(Object... args) throws Throwable;</span>

 567 
 568     /**
 569      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}.
 570      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 571      * The trailing (not leading) argument must be a MemberName.
 572      * @param args the signature-polymorphic parameter list, statically represented using varargs
 573      * @return the signature-polymorphic result, statically represented using {@code Object}
 574      */
 575     @HotSpotIntrinsicCandidate
<span class="line-modified"> 576     /*non-public*/ static native @PolymorphicSignature Object linkToStatic(Object... args) throws Throwable;</span>

 577 
 578     /**
 579      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}.
 580      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 581      * The trailing (not leading) argument must be a MemberName.
 582      * @param args the signature-polymorphic parameter list, statically represented using varargs
 583      * @return the signature-polymorphic result, statically represented using {@code Object}
 584      */
 585     @HotSpotIntrinsicCandidate
<span class="line-modified"> 586     /*non-public*/ static native @PolymorphicSignature Object linkToSpecial(Object... args) throws Throwable;</span>

 587 
 588     /**
 589      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}.
 590      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 591      * The trailing (not leading) argument must be a MemberName.
 592      * @param args the signature-polymorphic parameter list, statically represented using varargs
 593      * @return the signature-polymorphic result, statically represented using {@code Object}
 594      */
 595     @HotSpotIntrinsicCandidate
<span class="line-modified"> 596     /*non-public*/ static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;</span>

 597 
 598     /**
 599      * Performs a variable arity invocation, passing the arguments in the given array
 600      * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
 601      * which mentions only the type {@code Object}, and whose actual argument count is the length
 602      * of the argument array.
 603      * &lt;p&gt;
 604      * Specifically, execution proceeds as if by the following steps,
 605      * although the methods are not guaranteed to be called if the JVM
 606      * can predict their effects.
 607      * &lt;ul&gt;
 608      * &lt;li&gt;Determine the length of the argument array as {@code N}.
 609      *     For a null reference, {@code N=0}. &lt;/li&gt;
 610      * &lt;li&gt;Collect the {@code N} elements of the array as a logical
 611      *     argument list, each argument statically typed as an {@code Object}. &lt;/li&gt;
 612      * &lt;li&gt;Determine, as {@code M}, the parameter count of the type of this
 613      *     method handle. &lt;/li&gt;
 614      * &lt;li&gt;Determine the general type {@code TN} of {@code N} arguments or
 615      *     {@code M} arguments, if smaller than {@code N}, as
 616      *     {@code TN=MethodType.genericMethodType(Math.min(N, M))}.&lt;/li&gt;
</pre>
<hr />
<pre>
 848         if (newType == type) {
 849             return this;
 850         }
 851         // Return &#39;this.asTypeCache&#39; if the conversion is already memoized.
 852         MethodHandle atc = asTypeCached(newType);
 853         if (atc != null) {
 854             return atc;
 855         }
 856         return asTypeUncached(newType);
 857     }
 858 
 859     private MethodHandle asTypeCached(MethodType newType) {
 860         MethodHandle atc = asTypeCache;
 861         if (atc != null &amp;&amp; newType == atc.type) {
 862             return atc;
 863         }
 864         return null;
 865     }
 866 
 867     /** Override this to change asType behavior. */
<span class="line-modified"> 868     /*non-public*/ MethodHandle asTypeUncached(MethodType newType) {</span>

 869         if (!type.isConvertibleTo(newType))
 870             throw new WrongMethodTypeException(&quot;cannot convert &quot;+this+&quot; to &quot;+newType);
 871         return asTypeCache = MethodHandleImpl.makePairwiseConvert(this, newType, true);
 872     }
 873 
 874     /**
 875      * Makes an &lt;em&gt;array-spreading&lt;/em&gt; method handle, which accepts a trailing array argument
 876      * and spreads its elements as positional arguments.
 877      * The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
 878      * the current method handle.  The type of the adapter will be
 879      * the same as the type of the target, except that the final
 880      * {@code arrayLength} parameters of the target&#39;s type are replaced
 881      * by a single array parameter of type {@code arrayType}.
 882      * &lt;p&gt;
 883      * If the array element type differs from any of the corresponding
 884      * argument types on the original target,
 885      * the original target is adapted to take the array elements directly,
 886      * as if by a call to {@link #asType asType}.
 887      * &lt;p&gt;
 888      * When called, the adapter replaces a trailing array argument
</pre>
<hr />
<pre>
1225      * @see #asCollector(Class, int)
1226      * @since 9
1227      */
1228     public MethodHandle asCollector(int collectArgPos, Class&lt;?&gt; arrayType, int arrayLength) {
1229         asCollectorChecks(arrayType, collectArgPos, arrayLength);
1230         BoundMethodHandle mh = rebind();
1231         MethodType resultType = type().asCollectorType(arrayType, collectArgPos, arrayLength);
1232         MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1233         LambdaForm lform = mh.editor().collectArgumentArrayForm(1 + collectArgPos, newArray);
1234         if (lform != null) {
1235             return mh.copyWith(resultType, lform);
1236         }
1237         lform = mh.editor().collectArgumentsForm(1 + collectArgPos, newArray.type().basicType());
1238         return mh.copyWithExtendL(resultType, lform, newArray);
1239     }
1240 
1241     /**
1242      * See if {@code asCollector} can be validly called with the given arguments.
1243      * Return false if the last parameter is not an exact match to arrayType.
1244      */
<span class="line-modified">1245     /*non-public*/ boolean asCollectorChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>

1246         spreadArrayChecks(arrayType, arrayLength);
1247         int nargs = type().parameterCount();
1248         if (pos &lt; 0 || pos &gt;= nargs) {
1249             throw newIllegalArgumentException(&quot;bad collect position&quot;);
1250         }
1251         if (nargs != 0) {
1252             Class&lt;?&gt; param = type().parameterType(pos);
1253             if (param == arrayType)  return true;
1254             if (param.isAssignableFrom(arrayType))  return false;
1255         }
1256         throw newIllegalArgumentException(&quot;array type not assignable to argument&quot;, this, arrayType);
1257     }
1258 
1259     /**
1260      * Makes a &lt;em&gt;variable arity&lt;/em&gt; adapter which is able to accept
1261      * any number of trailing positional arguments and collect them
1262      * into an array argument.
1263      * &lt;p&gt;
1264      * The type and behavior of the adapter will be the same as
1265      * the type and behavior of the target, except that certain
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  35 import java.lang.constant.MethodHandleDesc;
  36 import java.lang.constant.MethodTypeDesc;
  37 import java.util.Arrays;
  38 import java.util.Objects;
  39 import java.util.Optional;
  40 
  41 import static java.lang.invoke.MethodHandleInfo.*;
  42 import static java.lang.invoke.MethodHandleStatics.*;
  43 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  44 
  45 /**
  46  * A method handle is a typed, directly executable reference to an underlying method,
  47  * constructor, field, or similar low-level operation, with optional
  48  * transformations of arguments or return values.
  49  * These transformations are quite general, and include such patterns as
  50  * {@linkplain #asType conversion},
  51  * {@linkplain #bindTo insertion},
  52  * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},
  53  * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.
  54  *
<span class="line-modified">  55  * &lt;h2&gt;Method handle contents&lt;/h2&gt;</span>
  56  * Method handles are dynamically and strongly typed according to their parameter and return types.
  57  * They are not distinguished by the name or the defining class of their underlying methods.
  58  * A method handle must be invoked using a symbolic type descriptor which matches
  59  * the method handle&#39;s own {@linkplain #type() type descriptor}.
  60  * &lt;p&gt;
  61  * Every method handle reports its type descriptor via the {@link #type() type} accessor.
  62  * This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,
  63  * whose structure is a series of classes, one of which is
  64  * the return type of the method (or {@code void.class} if none).
  65  * &lt;p&gt;
  66  * A method handle&#39;s type controls the types of invocations it accepts,
  67  * and the kinds of transformations that apply to it.
  68  * &lt;p&gt;
  69  * A method handle contains a pair of special invoker methods
  70  * called {@link #invokeExact invokeExact} and {@link #invoke invoke}.
  71  * Both invoker methods provide direct access to the method handle&#39;s
  72  * underlying method, constructor, field, or other operation,
  73  * as modified by transformations of arguments and return values.
  74  * Both invokers accept calls which exactly match the method handle&#39;s own type.
  75  * The plain, inexact invoker also accepts a range of other call types.
  76  * &lt;p&gt;
  77  * Method handles are immutable and have no visible state.
  78  * Of course, they can be bound to underlying methods or data which exhibit state.
  79  * With respect to the Java Memory Model, any method handle will behave
  80  * as if all of its (internal) fields are final variables.  This means that any method
  81  * handle made visible to the application will always be fully formed.
  82  * This is true even if the method handle is published through a shared
  83  * variable in a data race.
  84  * &lt;p&gt;
  85  * Method handles cannot be subclassed by the user.
  86  * Implementations may (or may not) create internal subclasses of {@code MethodHandle}
  87  * which may be visible via the {@link java.lang.Object#getClass Object.getClass}
  88  * operation.  The programmer should not draw conclusions about a method handle
  89  * from its specific class, as the method handle class hierarchy (if any)
  90  * may change from time to time or across implementations from different vendors.
  91  *
<span class="line-modified">  92  * &lt;h2&gt;Method handle compilation&lt;/h2&gt;</span>
  93  * A Java method call expression naming {@code invokeExact} or {@code invoke}
  94  * can invoke a method handle from Java source code.
  95  * From the viewpoint of source code, these methods can take any arguments
  96  * and their result can be cast to any return type.
  97  * Formally this is accomplished by giving the invoker methods
  98  * {@code Object} return types and variable arity {@code Object} arguments,
  99  * but they have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt;
 100  * which connects this freedom of invocation directly to the JVM execution stack.
 101  * &lt;p&gt;
 102  * As is usual with virtual methods, source-level calls to {@code invokeExact}
 103  * and {@code invoke} compile to an {@code invokevirtual} instruction.
 104  * More unusually, the compiler must record the actual argument types,
 105  * and may not perform method invocation conversions on the arguments.
 106  * Instead, it must generate instructions that push them on the stack according
 107  * to their own unconverted types.  The method handle object itself is pushed on
 108  * the stack before the arguments.
 109  * The compiler then generates an {@code invokevirtual} instruction that invokes
 110  * the method handle with a symbolic type descriptor which describes the argument
 111  * and return types.
 112  * &lt;p&gt;
 113  * To issue a complete symbolic type descriptor, the compiler must also determine
 114  * the return type.  This is based on a cast on the method invocation expression,
 115  * if there is one, or else {@code Object} if the invocation is an expression,
 116  * or else {@code void} if the invocation is a statement.
 117  * The cast may be to a primitive type (but not {@code void}).
 118  * &lt;p&gt;
 119  * As a corner case, an uncasted {@code null} argument is given
 120  * a symbolic type descriptor of {@code java.lang.Void}.
 121  * The ambiguity with the type {@code Void} is harmless, since there are no references of type
 122  * {@code Void} except the null reference.
 123  *
<span class="line-modified"> 124  * &lt;h2&gt;Method handle invocation&lt;/h2&gt;</span>
 125  * The first time an {@code invokevirtual} instruction is executed
 126  * it is linked by symbolically resolving the names in the instruction
 127  * and verifying that the method call is statically legal.
 128  * This also holds for calls to {@code invokeExact} and {@code invoke}.
 129  * In this case, the symbolic type descriptor emitted by the compiler is checked for
 130  * correct syntax, and names it contains are resolved.
 131  * Thus, an {@code invokevirtual} instruction which invokes
 132  * a method handle will always link, as long
 133  * as the symbolic type descriptor is syntactically well-formed
 134  * and the types exist.
 135  * &lt;p&gt;
 136  * When the {@code invokevirtual} is executed after linking,
 137  * the receiving method handle&#39;s type is first checked by the JVM
 138  * to ensure that it matches the symbolic type descriptor.
 139  * If the type match fails, it means that the method which the
 140  * caller is invoking is not present on the individual
 141  * method handle being invoked.
 142  * &lt;p&gt;
 143  * In the case of {@code invokeExact}, the type descriptor of the invocation
 144  * (after resolving symbolic type names) must exactly match the method type
</pre>
<hr />
<pre>
 147  * must be a valid argument to the receiver&#39;s {@link #asType asType} method.
 148  * Thus, plain {@code invoke} is more permissive than {@code invokeExact}.
 149  * &lt;p&gt;
 150  * After type matching, a call to {@code invokeExact} directly
 151  * and immediately invoke the method handle&#39;s underlying method
 152  * (or other behavior, as the case may be).
 153  * &lt;p&gt;
 154  * A call to plain {@code invoke} works the same as a call to
 155  * {@code invokeExact}, if the symbolic type descriptor specified by the caller
 156  * exactly matches the method handle&#39;s own type.
 157  * If there is a type mismatch, {@code invoke} attempts
 158  * to adjust the type of the receiving method handle,
 159  * as if by a call to {@link #asType asType},
 160  * to obtain an exactly invokable method handle {@code M2}.
 161  * This allows a more powerful negotiation of method type
 162  * between caller and callee.
 163  * &lt;p&gt;
 164  * (&lt;em&gt;Note:&lt;/em&gt; The adjusted method handle {@code M2} is not directly observable,
 165  * and implementations are therefore not required to materialize it.)
 166  *
<span class="line-modified"> 167  * &lt;h2&gt;Invocation checking&lt;/h2&gt;</span>
 168  * In typical programs, method handle type matching will usually succeed.
 169  * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},
 170  * either directly (in the case of {@code invokeExact}) or indirectly as if
 171  * by a failed call to {@code asType} (in the case of {@code invoke}).
 172  * &lt;p&gt;
 173  * Thus, a method type mismatch which might show up as a linkage error
 174  * in a statically typed program can show up as
 175  * a dynamic {@code WrongMethodTypeException}
 176  * in a program which uses method handles.
 177  * &lt;p&gt;
 178  * Because method types contain &quot;live&quot; {@code Class} objects,
 179  * method type matching takes into account both type names and class loaders.
 180  * Thus, even if a method handle {@code M} is created in one
 181  * class loader {@code L1} and used in another {@code L2},
 182  * method handle calls are type-safe, because the caller&#39;s symbolic type
 183  * descriptor, as resolved in {@code L2},
 184  * is matched against the original callee method&#39;s symbolic type descriptor,
 185  * as resolved in {@code L1}.
 186  * The resolution in {@code L1} happens when {@code M} is created
 187  * and its type is assigned, while the resolution in {@code L2} happens
 188  * when the {@code invokevirtual} instruction is linked.
 189  * &lt;p&gt;
 190  * Apart from type descriptor checks,
 191  * a method handle&#39;s capability to call its underlying method is unrestricted.
 192  * If a method handle is formed on a non-public method by a class
 193  * that has access to that method, the resulting handle can be used
 194  * in any place by any caller who receives a reference to it.
 195  * &lt;p&gt;
 196  * Unlike with the Core Reflection API, where access is checked every time
 197  * a reflective method is invoked,
 198  * method handle access checking is performed
 199  * &lt;a href=&quot;MethodHandles.Lookup.html#access&quot;&gt;when the method handle is created&lt;/a&gt;.
 200  * In the case of {@code ldc} (see below), access checking is performed as part of linking
 201  * the constant pool entry underlying the constant method handle.
 202  * &lt;p&gt;
 203  * Thus, handles to non-public methods, or to methods in non-public classes,
 204  * should generally be kept secret.
 205  * They should not be passed to untrusted code unless their use from
 206  * the untrusted code would be harmless.
 207  *
<span class="line-modified"> 208  * &lt;h2&gt;Method handle creation&lt;/h2&gt;</span>
 209  * Java code can create a method handle that directly accesses
 210  * any method, constructor, or field that is accessible to that code.
 211  * This is done via a reflective, capability-based API called
 212  * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}.
 213  * For example, a static method handle can be obtained
 214  * from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.
 215  * There are also conversion methods from Core Reflection API objects,
 216  * such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 217  * &lt;p&gt;
 218  * Like classes and strings, method handles that correspond to accessible
 219  * fields, methods, and constructors can also be represented directly
 220  * in a class file&#39;s constant pool as constants to be loaded by {@code ldc} bytecodes.
 221  * A new type of constant pool entry, {@code CONSTANT_MethodHandle},
 222  * refers directly to an associated {@code CONSTANT_Methodref},
 223  * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}
 224  * constant pool entry.
<span class="line-modified"> 225  * (For full details on method handle constants, see sections {@jvms</span>
<span class="line-modified"> 226  * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine</span>
<span class="line-added"> 227  * Specification.)</span>
 228  * &lt;p&gt;
 229  * Method handles produced by lookups or constant loads from methods or
 230  * constructors with the variable arity modifier bit ({@code 0x0080})
 231  * have a corresponding variable arity, as if they were defined with
 232  * the help of {@link #asVarargsCollector asVarargsCollector}
 233  * or {@link #withVarargs withVarargs}.
 234  * &lt;p&gt;
 235  * A method reference may refer either to a static or non-static method.
 236  * In the non-static case, the method handle type includes an explicit
 237  * receiver argument, prepended before any other arguments.
 238  * In the method handle&#39;s type, the initial receiver argument is typed
 239  * according to the class under which the method was initially requested.
 240  * (E.g., if a non-static method handle is obtained via {@code ldc},
 241  * the type of the receiver is the class named in the constant pool entry.)
 242  * &lt;p&gt;
 243  * Method handle constants are subject to the same link-time access checks
 244  * their corresponding bytecode instructions, and the {@code ldc} instruction
 245  * will throw corresponding linkage errors if the bytecode behaviors would
 246  * throw such errors.
 247  * &lt;p&gt;
 248  * As a corollary of this, access to protected members is restricted
 249  * to receivers only of the accessing class, or one of its subclasses,
 250  * and the accessing class must in turn be a subclass (or package sibling)
 251  * of the protected member&#39;s defining class.
 252  * If a method reference refers to a protected non-static method or field
 253  * of a class outside the current package, the receiver argument will
 254  * be narrowed to the type of the accessing class.
 255  * &lt;p&gt;
 256  * When a method handle to a virtual method is invoked, the method is
 257  * always looked up in the receiver (that is, the first argument).
 258  * &lt;p&gt;
 259  * A non-virtual method handle to a specific virtual method implementation
 260  * can also be created.  These do not perform virtual lookup based on
 261  * receiver type.  Such a method handle simulates the effect of
 262  * an {@code invokespecial} instruction to the same method.
 263  * A non-virtual method handle can also be created to simulate the effect
 264  * of an {@code invokevirtual} or {@code invokeinterface} instruction on
 265  * a private method (as applicable).
 266  *
<span class="line-modified"> 267  * &lt;h2&gt;Usage examples&lt;/h2&gt;</span>
 268  * Here are some examples of usage:
 269  * &lt;blockquote&gt;&lt;pre&gt;{@code
 270 Object x, y; String s; int i;
 271 MethodType mt; MethodHandle mh;
 272 MethodHandles.Lookup lookup = MethodHandles.lookup();
 273 // mt is (char,char)String
 274 mt = MethodType.methodType(String.class, char.class, char.class);
 275 mh = lookup.findVirtual(String.class, &quot;replace&quot;, mt);
 276 s = (String) mh.invokeExact(&quot;daddy&quot;,&#39;d&#39;,&#39;n&#39;);
 277 // invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
 278 assertEquals(s, &quot;nanny&quot;);
 279 // weakly typed invocation (using MHs.invoke)
 280 s = (String) mh.invokeWithArguments(&quot;sappy&quot;, &#39;p&#39;, &#39;v&#39;);
 281 assertEquals(s, &quot;savvy&quot;);
 282 // mt is (Object[])List
 283 mt = MethodType.methodType(java.util.List.class, Object[].class);
 284 mh = lookup.findStatic(java.util.Arrays.class, &quot;asList&quot;, mt);
 285 assert(mh.isVarargsCollector());
 286 x = mh.invoke(&quot;one&quot;, &quot;two&quot;);
 287 // invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
</pre>
<hr />
<pre>
 293 // invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
 294 assertEquals(x, java.util.Arrays.asList(1,2,3));
 295 // mt is ()int
 296 mt = MethodType.methodType(int.class);
 297 mh = lookup.findVirtual(java.util.List.class, &quot;size&quot;, mt);
 298 i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
 299 // invokeExact(Ljava/util/List;)I
 300 assert(i == 3);
 301 mt = MethodType.methodType(void.class, String.class);
 302 mh = lookup.findVirtual(java.io.PrintStream.class, &quot;println&quot;, mt);
 303 mh.invokeExact(System.out, &quot;Hello, world.&quot;);
 304 // invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
 305  * }&lt;/pre&gt;&lt;/blockquote&gt;
 306  * Each of the above calls to {@code invokeExact} or plain {@code invoke}
 307  * generates a single invokevirtual instruction with
 308  * the symbolic type descriptor indicated in the following comment.
 309  * In these examples, the helper method {@code assertEquals} is assumed to
 310  * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}
 311  * on its arguments, and asserts that the result is true.
 312  *
<span class="line-modified"> 313  * &lt;h2&gt;Exceptions&lt;/h2&gt;</span>
 314  * The methods {@code invokeExact} and {@code invoke} are declared
 315  * to throw {@link java.lang.Throwable Throwable},
 316  * which is to say that there is no static restriction on what a method handle
 317  * can throw.  Since the JVM does not distinguish between checked
 318  * and unchecked exceptions (other than by their class, of course),
 319  * there is no particular effect on bytecode shape from ascribing
 320  * checked exceptions to method handle invocations.  But in Java source
 321  * code, methods which perform method handle calls must either explicitly
 322  * throw {@code Throwable}, or else must catch all
 323  * throwables locally, rethrowing only those which are legal in the context,
 324  * and wrapping ones which are illegal.
 325  *
<span class="line-modified"> 326  * &lt;h2&gt;&lt;a id=&quot;sigpoly&quot;&gt;&lt;/a&gt;Signature polymorphism&lt;/h2&gt;</span>
 327  * The unusual compilation and linkage behavior of
 328  * {@code invokeExact} and plain {@code invoke}
 329  * is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;.
 330  * As defined in the Java Language Specification,
 331  * a signature polymorphic method is one which can operate with
 332  * any of a wide range of call signatures and return types.
 333  * &lt;p&gt;
 334  * In source code, a call to a signature polymorphic method will
 335  * compile, regardless of the requested symbolic type descriptor.
 336  * As usual, the Java compiler emits an {@code invokevirtual}
 337  * instruction with the given symbolic type descriptor against the named method.
 338  * The unusual part is that the symbolic type descriptor is derived from
 339  * the actual argument and return types, not from the method declaration.
 340  * &lt;p&gt;
 341  * When the JVM processes bytecode containing signature polymorphic calls,
 342  * it will successfully link any such call, regardless of its symbolic type descriptor.
 343  * (In order to retain type safety, the JVM will guard such calls with suitable
 344  * dynamic type checks, as described elsewhere.)
 345  * &lt;p&gt;
 346  * Bytecode generators, including the compiler back end, are required to emit
 347  * untransformed symbolic type descriptors for these methods.
 348  * Tools which determine symbolic linkage are required to accept such
 349  * untransformed descriptors, without reporting linkage errors.
 350  *
<span class="line-modified"> 351  * &lt;h2&gt;Interoperation between method handles and the Core Reflection API&lt;/h2&gt;</span>
 352  * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,
 353  * any class member represented by a Core Reflection API object
 354  * can be converted to a behaviorally equivalent method handle.
 355  * For example, a reflective {@link java.lang.reflect.Method Method} can
 356  * be converted to a method handle using
 357  * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 358  * The resulting method handles generally provide more direct and efficient
 359  * access to the underlying class members.
 360  * &lt;p&gt;
 361  * As a special case,
 362  * when the Core Reflection API is used to view the signature polymorphic
 363  * methods {@code invokeExact} or plain {@code invoke} in this class,
 364  * they appear as ordinary non-polymorphic methods.
 365  * Their reflective appearance, as viewed by
 366  * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
 367  * is unaffected by their special status in this API.
 368  * For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}
 369  * will report exactly those modifier bits required for any similarly
 370  * declared method, including in this case {@code native} and {@code varargs} bits.
 371  * &lt;p&gt;
</pre>
<hr />
<pre>
 373  * invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.
 374  * However, such reflective calls do not result in method handle invocations.
 375  * Such a call, if passed the required argument
 376  * (a single one, of type {@code Object[]}), will ignore the argument and
 377  * will throw an {@code UnsupportedOperationException}.
 378  * &lt;p&gt;
 379  * Since {@code invokevirtual} instructions can natively
 380  * invoke method handles under any symbolic type descriptor, this reflective view conflicts
 381  * with the normal presentation of these methods via bytecodes.
 382  * Thus, these two native methods, when reflectively viewed by
 383  * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
 384  * &lt;p&gt;
 385  * In order to obtain an invoker method for a particular type descriptor,
 386  * use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},
 387  * or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.
 388  * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
 389  * API is also able to return a method handle
 390  * to call {@code invokeExact} or plain {@code invoke},
 391  * for any specified type descriptor .
 392  *
<span class="line-modified"> 393  * &lt;h2&gt;Interoperation between method handles and Java generics&lt;/h2&gt;</span>
 394  * A method handle can be obtained on a method, constructor, or field
 395  * which is declared with Java generic types.
 396  * As with the Core Reflection API, the type of the method handle
 397  * will be constructed from the erasure of the source-level type.
 398  * When a method handle is invoked, the types of its arguments
 399  * or the return value cast type may be generic types or type instances.
 400  * If this occurs, the compiler will replace those
 401  * types by their erasures when it constructs the symbolic type descriptor
 402  * for the {@code invokevirtual} instruction.
 403  * &lt;p&gt;
 404  * Method handles do not represent
 405  * their function-like types in terms of Java parameterized (generic) types,
 406  * because there are three mismatches between function-like types and parameterized
 407  * Java types.
 408  * &lt;ul&gt;
 409  * &lt;li&gt;Method types range over all possible arities,
 410  * from no arguments to up to the  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;maximum number&lt;/a&gt; of allowed arguments.
 411  * Generics are not variadic, and so cannot represent this.&lt;/li&gt;
 412  * &lt;li&gt;Method types can specify arguments of primitive types,
 413  * which Java generic types cannot range over.&lt;/li&gt;
 414  * &lt;li&gt;Higher order functions over method handles (combinators) are
 415  * often generic across a wide range of function types, including
 416  * those of multiple arities.  It is impossible to represent such
 417  * genericity with a Java type parameter.&lt;/li&gt;
 418  * &lt;/ul&gt;
 419  *
<span class="line-modified"> 420  * &lt;h2&gt;&lt;a id=&quot;maxarity&quot;&gt;&lt;/a&gt;Arity limits&lt;/h2&gt;</span>
 421  * The JVM imposes on all methods and constructors of any kind an absolute
 422  * limit of 255 stacked arguments.  This limit can appear more restrictive
 423  * in certain cases:
 424  * &lt;ul&gt;
 425  * &lt;li&gt;A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.
 426  * &lt;li&gt;A non-static method consumes an extra argument for the object on which the method is called.
 427  * &lt;li&gt;A constructor consumes an extra argument for the object which is being constructed.
 428  * &lt;li&gt;Since a method handle&amp;rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,
 429  *     it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.
 430  * &lt;/ul&gt;
 431  * These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.
 432  * For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.
 433  * Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.
 434  * In particular, a method handle&amp;rsquo;s type must not have an arity of the exact maximum 255.
 435  *
 436  * @see MethodType
 437  * @see MethodHandles
 438  * @author John Rose, JSR 292 EG
 439  * @since 1.7
 440  */
 441 public abstract class MethodHandle implements Constable {
 442 
 443     /**
 444      * Internal marker interface which distinguishes (to the Java compiler)
 445      * those methods which are &lt;a href=&quot;MethodHandle.html#sigpoly&quot;&gt;signature polymorphic&lt;/a&gt;.
 446      */
 447     @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
 448     @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
 449     @interface PolymorphicSignature { }
 450 
 451     private final MethodType type;
<span class="line-modified"> 452     /*private*/</span>
<span class="line-added"> 453     final LambdaForm form;</span>
 454     // form is not private so that invokers can easily fetch it
<span class="line-modified"> 455     /*private*/</span>
<span class="line-added"> 456     MethodHandle asTypeCache;</span>
 457     // asTypeCache is not private so that invokers can easily fetch it
<span class="line-modified"> 458     /*non-public*/</span>
<span class="line-added"> 459     byte customizationCount;</span>
 460     // customizationCount should be accessible from invokers
 461 
 462     /**
 463      * Reports the type of this method handle.
 464      * Every invocation of this method handle via {@code invokeExact} must exactly match this type.
 465      * @return the method handle type
 466      */
 467     public MethodType type() {
 468         return type;
 469     }
 470 
 471     /**
 472      * Package-private constructor for the method handle implementation hierarchy.
 473      * Method handle inheritance will be contained completely within
 474      * the {@code java.lang.invoke} package.
 475      */
 476     // @param type type (permanently assigned) of the new method handle
<span class="line-modified"> 477     /*non-public*/</span>
<span class="line-added"> 478     MethodHandle(MethodType type, LambdaForm form) {</span>
 479         this.type = Objects.requireNonNull(type);
 480         this.form = Objects.requireNonNull(form).uncustomize();
 481 
 482         this.form.prepare();  // TO DO:  Try to delay this step until just before invocation.
 483     }
 484 
 485     /**
 486      * Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.
 487      * The symbolic type descriptor at the call site of {@code invokeExact} must
 488      * exactly match this method handle&#39;s {@link #type() type}.
 489      * No conversions are allowed on arguments or return values.
 490      * &lt;p&gt;
 491      * When this method is observed via the Core Reflection API,
 492      * it will appear as a single native method, taking an object array and returning an object.
 493      * If this native method is invoked directly via
 494      * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
 495      * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
 496      * it will throw an {@code UnsupportedOperationException}.
 497      * @param args the signature-polymorphic parameter list, statically represented using varargs
 498      * @return the signature-polymorphic result, statically represented using {@code Object}
</pre>
<hr />
<pre>
 541     public final native @PolymorphicSignature Object invoke(Object... args) throws Throwable;
 542 
 543     /**
 544      * Private method for trusted invocation of a method handle respecting simplified signatures.
 545      * Type mismatches will not throw {@code WrongMethodTypeException}, but could crash the JVM.
 546      * &lt;p&gt;
 547      * The caller signature is restricted to the following basic types:
 548      * Object, int, long, float, double, and void return.
 549      * &lt;p&gt;
 550      * The caller is responsible for maintaining type correctness by ensuring
 551      * that the each outgoing argument value is a member of the range of the corresponding
 552      * callee argument type.
 553      * (The caller should therefore issue appropriate casts and integer narrowing
 554      * operations on outgoing argument values.)
 555      * The caller can assume that the incoming result value is part of the range
 556      * of the callee&#39;s return type.
 557      * @param args the signature-polymorphic parameter list, statically represented using varargs
 558      * @return the signature-polymorphic result, statically represented using {@code Object}
 559      */
 560     @HotSpotIntrinsicCandidate
<span class="line-modified"> 561     /*non-public*/</span>
<span class="line-added"> 562     final native @PolymorphicSignature Object invokeBasic(Object... args) throws Throwable;</span>
 563 
 564     /**
 565      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}.
 566      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 567      * The trailing (not leading) argument must be a MemberName.
 568      * @param args the signature-polymorphic parameter list, statically represented using varargs
 569      * @return the signature-polymorphic result, statically represented using {@code Object}
 570      */
 571     @HotSpotIntrinsicCandidate
<span class="line-modified"> 572     /*non-public*/</span>
<span class="line-added"> 573     static native @PolymorphicSignature Object linkToVirtual(Object... args) throws Throwable;</span>
 574 
 575     /**
 576      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}.
 577      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 578      * The trailing (not leading) argument must be a MemberName.
 579      * @param args the signature-polymorphic parameter list, statically represented using varargs
 580      * @return the signature-polymorphic result, statically represented using {@code Object}
 581      */
 582     @HotSpotIntrinsicCandidate
<span class="line-modified"> 583     /*non-public*/</span>
<span class="line-added"> 584     static native @PolymorphicSignature Object linkToStatic(Object... args) throws Throwable;</span>
 585 
 586     /**
 587      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}.
 588      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 589      * The trailing (not leading) argument must be a MemberName.
 590      * @param args the signature-polymorphic parameter list, statically represented using varargs
 591      * @return the signature-polymorphic result, statically represented using {@code Object}
 592      */
 593     @HotSpotIntrinsicCandidate
<span class="line-modified"> 594     /*non-public*/</span>
<span class="line-added"> 595     static native @PolymorphicSignature Object linkToSpecial(Object... args) throws Throwable;</span>
 596 
 597     /**
 598      * Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}.
 599      * The caller signature is restricted to basic types as with {@code invokeBasic}.
 600      * The trailing (not leading) argument must be a MemberName.
 601      * @param args the signature-polymorphic parameter list, statically represented using varargs
 602      * @return the signature-polymorphic result, statically represented using {@code Object}
 603      */
 604     @HotSpotIntrinsicCandidate
<span class="line-modified"> 605     /*non-public*/</span>
<span class="line-added"> 606     static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;</span>
 607 
 608     /**
 609      * Performs a variable arity invocation, passing the arguments in the given array
 610      * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
 611      * which mentions only the type {@code Object}, and whose actual argument count is the length
 612      * of the argument array.
 613      * &lt;p&gt;
 614      * Specifically, execution proceeds as if by the following steps,
 615      * although the methods are not guaranteed to be called if the JVM
 616      * can predict their effects.
 617      * &lt;ul&gt;
 618      * &lt;li&gt;Determine the length of the argument array as {@code N}.
 619      *     For a null reference, {@code N=0}. &lt;/li&gt;
 620      * &lt;li&gt;Collect the {@code N} elements of the array as a logical
 621      *     argument list, each argument statically typed as an {@code Object}. &lt;/li&gt;
 622      * &lt;li&gt;Determine, as {@code M}, the parameter count of the type of this
 623      *     method handle. &lt;/li&gt;
 624      * &lt;li&gt;Determine the general type {@code TN} of {@code N} arguments or
 625      *     {@code M} arguments, if smaller than {@code N}, as
 626      *     {@code TN=MethodType.genericMethodType(Math.min(N, M))}.&lt;/li&gt;
</pre>
<hr />
<pre>
 858         if (newType == type) {
 859             return this;
 860         }
 861         // Return &#39;this.asTypeCache&#39; if the conversion is already memoized.
 862         MethodHandle atc = asTypeCached(newType);
 863         if (atc != null) {
 864             return atc;
 865         }
 866         return asTypeUncached(newType);
 867     }
 868 
 869     private MethodHandle asTypeCached(MethodType newType) {
 870         MethodHandle atc = asTypeCache;
 871         if (atc != null &amp;&amp; newType == atc.type) {
 872             return atc;
 873         }
 874         return null;
 875     }
 876 
 877     /** Override this to change asType behavior. */
<span class="line-modified"> 878     /*non-public*/</span>
<span class="line-added"> 879     MethodHandle asTypeUncached(MethodType newType) {</span>
 880         if (!type.isConvertibleTo(newType))
 881             throw new WrongMethodTypeException(&quot;cannot convert &quot;+this+&quot; to &quot;+newType);
 882         return asTypeCache = MethodHandleImpl.makePairwiseConvert(this, newType, true);
 883     }
 884 
 885     /**
 886      * Makes an &lt;em&gt;array-spreading&lt;/em&gt; method handle, which accepts a trailing array argument
 887      * and spreads its elements as positional arguments.
 888      * The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
 889      * the current method handle.  The type of the adapter will be
 890      * the same as the type of the target, except that the final
 891      * {@code arrayLength} parameters of the target&#39;s type are replaced
 892      * by a single array parameter of type {@code arrayType}.
 893      * &lt;p&gt;
 894      * If the array element type differs from any of the corresponding
 895      * argument types on the original target,
 896      * the original target is adapted to take the array elements directly,
 897      * as if by a call to {@link #asType asType}.
 898      * &lt;p&gt;
 899      * When called, the adapter replaces a trailing array argument
</pre>
<hr />
<pre>
1236      * @see #asCollector(Class, int)
1237      * @since 9
1238      */
1239     public MethodHandle asCollector(int collectArgPos, Class&lt;?&gt; arrayType, int arrayLength) {
1240         asCollectorChecks(arrayType, collectArgPos, arrayLength);
1241         BoundMethodHandle mh = rebind();
1242         MethodType resultType = type().asCollectorType(arrayType, collectArgPos, arrayLength);
1243         MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
1244         LambdaForm lform = mh.editor().collectArgumentArrayForm(1 + collectArgPos, newArray);
1245         if (lform != null) {
1246             return mh.copyWith(resultType, lform);
1247         }
1248         lform = mh.editor().collectArgumentsForm(1 + collectArgPos, newArray.type().basicType());
1249         return mh.copyWithExtendL(resultType, lform, newArray);
1250     }
1251 
1252     /**
1253      * See if {@code asCollector} can be validly called with the given arguments.
1254      * Return false if the last parameter is not an exact match to arrayType.
1255      */
<span class="line-modified">1256     /*non-public*/</span>
<span class="line-added">1257     boolean asCollectorChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
1258         spreadArrayChecks(arrayType, arrayLength);
1259         int nargs = type().parameterCount();
1260         if (pos &lt; 0 || pos &gt;= nargs) {
1261             throw newIllegalArgumentException(&quot;bad collect position&quot;);
1262         }
1263         if (nargs != 0) {
1264             Class&lt;?&gt; param = type().parameterType(pos);
1265             if (param == arrayType)  return true;
1266             if (param.isAssignableFrom(arrayType))  return false;
1267         }
1268         throw newIllegalArgumentException(&quot;array type not assignable to argument&quot;, this, arrayType);
1269     }
1270 
1271     /**
1272      * Makes a &lt;em&gt;variable arity&lt;/em&gt; adapter which is able to accept
1273      * any number of trailing positional arguments and collect them
1274      * into an array argument.
1275      * &lt;p&gt;
1276      * The type and behavior of the adapter will be the same as
1277      * the type and behavior of the target, except that certain
</pre>
</td>
</tr>
</table>
<center><a href="MemberName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/InputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="IOException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputStreamReader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/InputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,11 ***</span>
  
  /**
   * This abstract class is the superclass of all classes representing
   * an input stream of bytes.
   *
<span class="line-modified">!  * &lt;p&gt; Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt;</span>
   * must always provide a method that returns the next byte of input.
   *
   * @author  Arthur van Hoff
   * @see     java.io.BufferedInputStream
   * @see     java.io.ByteArrayInputStream
<span class="line-new-header">--- 32,11 ---</span>
  
  /**
   * This abstract class is the superclass of all classes representing
   * an input stream of bytes.
   *
<span class="line-modified">!  * &lt;p&gt; Applications that need to define a subclass of {@code InputStream}</span>
   * must always provide a method that returns the next byte of input.
   *
   * @author  Arthur van Hoff
   * @see     java.io.BufferedInputStream
   * @see     java.io.ByteArrayInputStream
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 53,15 ---</span>
      // use when skipping.
      private static final int MAX_SKIP_BUFFER_SIZE = 2048;
  
      private static final int DEFAULT_BUFFER_SIZE = 8192;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Constructor for subclasses to call.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public InputStream() {}</span>
<span class="line-added">+ </span>
      /**
       * Returns a new {@code InputStream} that reads no bytes. The returned
       * stream is initially open.  The stream is closed by calling the
       * {@code close()} method.  Subsequent calls to {@code close()} have no
       * effect.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,116 ***</span>
          };
      }
  
      /**
       * Reads the next byte of data from the input stream. The value byte is
<span class="line-modified">!      * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to</span>
<span class="line-modified">!      * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream</span>
<span class="line-modified">!      * has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method</span>
       * blocks until input data is available, the end of the stream is detected,
       * or an exception is thrown.
       *
       * &lt;p&gt; A subclass must provide an implementation of this method.
       *
<span class="line-modified">!      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public abstract int read() throws IOException;
  
      /**
       * Reads some number of bytes from the input stream and stores them into
<span class="line-modified">!      * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is</span>
       * returned as an integer.  This method blocks until input data is
       * available, end of file is detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">!      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at the
<span class="line-modified">!      * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at</span>
<span class="line-modified">!      * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span>
<span class="line-modified">!      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,</span>
<span class="line-modified">!      * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the</span>
       * number of bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">!      * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!      * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;</span>
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @exception  IOException  If the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than the end of the file, if the input stream has been closed, or</span>
<span class="line-modified">!      * if some other I/O error occurs.</span>
<span class="line-modified">!      * @exception  NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public int read(byte b[]) throws IOException {
          return read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the input stream into</span>
       * an array of bytes.  An attempt is made to read as many as
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read.</span>
       * The number of bytes actually read is returned as an integer.
       *
       * &lt;p&gt; This method blocks until input data is available, end of file is
       * detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">!      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">!      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one</span>
<span class="line-modified">!      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the</span>
<span class="line-modified">!      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
       * bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">!      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through</span>
<span class="line-modified">!      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method</span>
<span class="line-modified">!      * for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method</span>
<span class="line-modified">!      * &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an</span>
<span class="line-modified">!      * &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to</span>
<span class="line-modified">!      * the &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method.  If</span>
<span class="line-modified">!      * any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a</span>
<span class="line-modified">!      * &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it</span>
       * were end of file; the bytes read up to that point are stored into
<span class="line-modified">!      * &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception</span>
       * occurred is returned. The default implementation of this method blocks
<span class="line-modified">!      * until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read,</span>
       * end of file is detected, or an exception is thrown. Subclasses are
       * encouraged to provide a more efficient implementation of this method.
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in array &lt;code&gt;b&lt;/code&gt;</span>
       *                   at which the data is written.
       * @param      len   the maximum number of bytes to read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @exception  IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than end of file, or if the input stream has been closed, or if</span>
<span class="line-modified">!      * some other I/O error occurs.</span>
<span class="line-modified">!      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
       * @see        java.io.InputStream#read()
       */
      public int read(byte b[], int off, int len) throws IOException {
          Objects.checkFromIndexSize(off, len, b.length);
          if (len == 0) {
<span class="line-new-header">--- 165,116 ---</span>
          };
      }
  
      /**
       * Reads the next byte of data from the input stream. The value byte is
<span class="line-modified">!      * returned as an {@code int} in the range {@code 0} to</span>
<span class="line-modified">!      * {@code 255}. If no byte is available because the end of the stream</span>
<span class="line-modified">!      * has been reached, the value {@code -1} is returned. This method</span>
       * blocks until input data is available, the end of the stream is detected,
       * or an exception is thrown.
       *
       * &lt;p&gt; A subclass must provide an implementation of this method.
       *
<span class="line-modified">!      * @return     the next byte of data, or {@code -1} if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public abstract int read() throws IOException;
  
      /**
       * Reads some number of bytes from the input stream and stores them into
<span class="line-modified">!      * the buffer array {@code b}. The number of bytes actually read is</span>
       * returned as an integer.  This method blocks until input data is
       * available, end of file is detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If the length of {@code b} is zero, then no bytes are read and</span>
<span class="line-modified">!      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at the
<span class="line-modified">!      * end of the file, the value {@code -1} is returned; otherwise, at</span>
<span class="line-modified">!      * least one byte is read and stored into {@code b}.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified">!      * next one into {@code b[1]}, and so on. The number of bytes read is,</span>
<span class="line-modified">!      * at most, equal to the length of {@code b}. Let &lt;i&gt;k&lt;/i&gt; be the</span>
       * number of bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * {@code b[0]} through {@code b[}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">!      * leaving elements {@code b[}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">!      * {@code b[b.length-1]} unaffected.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The {@code read(b)} method for class {@code InputStream}</span>
<span class="line-modified">!      * has the same effect as: &lt;pre&gt;{@code  read(b, 0, b.length) }&lt;/pre&gt;</span>
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @throws     IOException  If the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than the end of the file, if the input stream has been</span>
<span class="line-modified">!      *             closed, or if some other I/O error occurs.</span>
<span class="line-modified">!      * @throws     NullPointerException  if {@code b} is {@code null}.</span>
       * @see        java.io.InputStream#read(byte[], int, int)
       */
      public int read(byte b[]) throws IOException {
          return read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to {@code len} bytes of data from the input stream into</span>
       * an array of bytes.  An attempt is made to read as many as
<span class="line-modified">!      * {@code len} bytes, but a smaller number may be read.</span>
       * The number of bytes actually read is returned as an integer.
       *
       * &lt;p&gt; This method blocks until input data is available, end of file is
       * detected, or an exception is thrown.
       *
<span class="line-modified">!      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">!      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
       * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">!      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">!      * byte is read and stored into {@code b}.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">!      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">!      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
       * bytes actually read; these bytes will be stored in elements
<span class="line-modified">!      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">!      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">!      * {@code b[off+len-1]} unaffected.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">!      * {@code b[off-1]} and elements {@code b[off+len]} through</span>
<span class="line-modified">!      * {@code b[b.length-1]} are unaffected.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; The {@code read(b, off, len)} method</span>
<span class="line-modified">!      * for class {@code InputStream} simply calls the method</span>
<span class="line-modified">!      * {@code read()} repeatedly. If the first such call results in an</span>
<span class="line-modified">!      * {@code IOException}, that exception is returned from the call to</span>
<span class="line-modified">!      * the {@code read(b,} {@code off,} {@code len)} method.  If</span>
<span class="line-modified">!      * any subsequent call to {@code read()} results in a</span>
<span class="line-modified">!      * {@code IOException}, the exception is caught and treated as if it</span>
       * were end of file; the bytes read up to that point are stored into
<span class="line-modified">!      * {@code b} and the number of bytes read before the exception</span>
       * occurred is returned. The default implementation of this method blocks
<span class="line-modified">!      * until the requested amount of input data {@code len} has been read,</span>
       * end of file is detected, or an exception is thrown. Subclasses are
       * encouraged to provide a more efficient implementation of this method.
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in array {@code b}</span>
       *                   at which the data is written.
       * @param      len   the maximum number of bytes to read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @throws     IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than end of file, or if the input stream has been closed,</span>
<span class="line-modified">!      *             or if some other I/O error occurs.</span>
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      *             {@code b.length - off}</span>
       * @see        java.io.InputStream#read()
       */
      public int read(byte b[], int off, int len) throws IOException {
          Objects.checkFromIndexSize(off, len, b.length);
          if (len == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,22 ***</span>
          }
          return n;
      }
  
      /**
<span class="line-modified">!      * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this input</span>
<span class="line-modified">!      * stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end</span>
<span class="line-modified">!      * up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;.</span>
       * This may result from any of a number of conditions; reaching end of file
<span class="line-modified">!      * before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one possibility.</span>
       * The actual number of bytes skipped is returned. If {@code n} is
       * negative, the {@code skip} method for class {@code InputStream} always
       * returns 0, and no bytes are skipped. Subclasses may handle the negative
       * value differently.
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a</span>
<span class="line-modified">!      * byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes</span>
       * have been read or the end of the stream has been reached. Subclasses are
       * encouraged to provide a more efficient implementation of this method.
       * For instance, the implementation may depend on the ability to seek.
       *
       * @param      n   the number of bytes to be skipped.
<span class="line-new-header">--- 507,22 ---</span>
          }
          return n;
      }
  
      /**
<span class="line-modified">!      * Skips over and discards {@code n} bytes of data from this input</span>
<span class="line-modified">!      * stream. The {@code skip} method may, for a variety of reasons, end</span>
<span class="line-modified">!      * up skipping over some smaller number of bytes, possibly {@code 0}.</span>
       * This may result from any of a number of conditions; reaching end of file
<span class="line-modified">!      * before {@code n} bytes have been skipped is only one possibility.</span>
       * The actual number of bytes skipped is returned. If {@code n} is
       * negative, the {@code skip} method for class {@code InputStream} always
       * returns 0, and no bytes are skipped. Subclasses may handle the negative
       * value differently.
       *
<span class="line-modified">!      * &lt;p&gt; The {@code skip} method implementation of this class creates a</span>
<span class="line-modified">!      * byte array and then repeatedly reads into it until {@code n} bytes</span>
       * have been read or the end of the stream has been reached. Subclasses are
       * encouraged to provide a more efficient implementation of this method.
       * For instance, the implementation may depend on the ability to seek.
       *
       * @param      n   the number of bytes to be skipped.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,112 ***</span>
       * &lt;p&gt; This method should be overridden by subclasses.
       *
       * @return     an estimate of the number of bytes that can be read (or
       *             skipped over) from this input stream without blocking or
       *             {@code 0} when it reaches the end of the input stream.
<span class="line-modified">!      * @exception  IOException if an I/O error occurs.</span>
       */
      public int available() throws IOException {
          return 0;
      }
  
      /**
       * Closes this input stream and releases any system resources associated
       * with the stream.
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does</span>
       * nothing.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public void close() throws IOException {}
  
      /**
       * Marks the current position in this input stream. A subsequent call to
<span class="line-modified">!      * the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at the last marked</span>
       * position so that subsequent reads re-read the same bytes.
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to</span>
       * allow that many bytes to be read before the mark position gets
       * invalidated.
       *
<span class="line-modified">!      * &lt;p&gt; The general contract of &lt;code&gt;mark&lt;/code&gt; is that, if the method</span>
<span class="line-modified">!      * &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the stream somehow</span>
<span class="line-modified">!      * remembers all the bytes read after the call to &lt;code&gt;mark&lt;/code&gt; and</span>
       * stands ready to supply those same bytes again if and whenever the method
<span class="line-modified">!      * &lt;code&gt;reset&lt;/code&gt; is called.  However, the stream is not required to</span>
<span class="line-modified">!      * remember any data at all if more than &lt;code&gt;readlimit&lt;/code&gt; bytes are</span>
<span class="line-modified">!      * read from the stream before &lt;code&gt;reset&lt;/code&gt; is called.</span>
       *
       * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
       *
<span class="line-modified">!      * &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does</span>
       * nothing.
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.InputStream#reset()
       */
      public synchronized void mark(int readlimit) {}
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The general contract of &lt;code&gt;reset&lt;/code&gt; is:</span>
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span>
<span class="line-modified">!      * &lt;code&gt;true&lt;/code&gt;, then:</span>
       *
<span class="line-modified">!      *     &lt;ul&gt;&lt;li&gt; If the method &lt;code&gt;mark&lt;/code&gt; has not been called since</span>
       *     the stream was created, or the number of bytes read from the stream
<span class="line-modified">!      *     since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument</span>
<span class="line-modified">!      *     to &lt;code&gt;mark&lt;/code&gt; at that last call, then an</span>
<span class="line-modified">!      *     &lt;code&gt;IOException&lt;/code&gt; might be thrown.</span>
       *
<span class="line-modified">!      *     &lt;li&gt; If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the</span>
       *     stream is reset to a state such that all the bytes read since the
<span class="line-modified">!      *     most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the</span>
<span class="line-modified">!      *     file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied</span>
<span class="line-modified">!      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by</span>
       *     any bytes that otherwise would have been the next input data as of
<span class="line-modified">!      *     the time of the call to &lt;code&gt;reset&lt;/code&gt;. &lt;/ul&gt;</span>
       *
<span class="line-modified">!      * &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns</span>
<span class="line-modified">!      * &lt;code&gt;false&lt;/code&gt;, then:</span>
       *
<span class="line-modified">!      *     &lt;ul&gt;&lt;li&gt; The call to &lt;code&gt;reset&lt;/code&gt; may throw an</span>
<span class="line-modified">!      *     &lt;code&gt;IOException&lt;/code&gt;.</span>
       *
<span class="line-modified">!      *     &lt;li&gt; If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream</span>
       *     is reset to a fixed state that depends on the particular type of the
       *     input stream and how it was created. The bytes that will be supplied
<span class="line-modified">!      *     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the</span>
       *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">!      * does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception  IOException  if this stream has not been marked or if the</span>
<span class="line-modified">!      *               mark has been invalidated.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.IOException
       */
      public synchronized void reset() throws IOException {
          throw new IOException(&quot;mark/reset not supported&quot;);
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;reset&lt;/code&gt; methods. Whether or not &lt;code&gt;mark&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;reset&lt;/code&gt; are supported is an invariant property of a</span>
<span class="line-modified">!      * particular input stream instance. The &lt;code&gt;markSupported&lt;/code&gt; method</span>
<span class="line-modified">!      * of &lt;code&gt;InputStream&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return  &lt;code&gt;true&lt;/code&gt; if this stream instance supports the mark</span>
<span class="line-modified">!      *          and reset methods; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return false;
<span class="line-new-header">--- 632,112 ---</span>
       * &lt;p&gt; This method should be overridden by subclasses.
       *
       * @return     an estimate of the number of bytes that can be read (or
       *             skipped over) from this input stream without blocking or
       *             {@code 0} when it reaches the end of the input stream.
<span class="line-modified">!      * @throws     IOException if an I/O error occurs.</span>
       */
      public int available() throws IOException {
          return 0;
      }
  
      /**
       * Closes this input stream and releases any system resources associated
       * with the stream.
       *
<span class="line-modified">!      * &lt;p&gt; The {@code close} method of {@code InputStream} does</span>
       * nothing.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public void close() throws IOException {}
  
      /**
       * Marks the current position in this input stream. A subsequent call to
<span class="line-modified">!      * the {@code reset} method repositions this stream at the last marked</span>
       * position so that subsequent reads re-read the same bytes.
       *
<span class="line-modified">!      * &lt;p&gt; The {@code readlimit} arguments tells this input stream to</span>
       * allow that many bytes to be read before the mark position gets
       * invalidated.
       *
<span class="line-modified">!      * &lt;p&gt; The general contract of {@code mark} is that, if the method</span>
<span class="line-modified">!      * {@code markSupported} returns {@code true}, the stream somehow</span>
<span class="line-modified">!      * remembers all the bytes read after the call to {@code mark} and</span>
       * stands ready to supply those same bytes again if and whenever the method
<span class="line-modified">!      * {@code reset} is called.  However, the stream is not required to</span>
<span class="line-modified">!      * remember any data at all if more than {@code readlimit} bytes are</span>
<span class="line-modified">!      * read from the stream before {@code reset} is called.</span>
       *
       * &lt;p&gt; Marking a closed stream should not have any effect on the stream.
       *
<span class="line-modified">!      * &lt;p&gt; The {@code mark} method of {@code InputStream} does</span>
       * nothing.
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.InputStream#reset()
       */
      public synchronized void mark(int readlimit) {}
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * {@code mark} method was last called on this input stream.</span>
       *
<span class="line-modified">!      * &lt;p&gt; The general contract of {@code reset} is:</span>
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">!      * {@code true}, then:</span>
       *
<span class="line-modified">!      *     &lt;ul&gt;&lt;li&gt; If the method {@code mark} has not been called since</span>
       *     the stream was created, or the number of bytes read from the stream
<span class="line-modified">!      *     since {@code mark} was last called is larger than the argument</span>
<span class="line-modified">!      *     to {@code mark} at that last call, then an</span>
<span class="line-modified">!      *     {@code IOException} might be thrown.</span>
       *
<span class="line-modified">!      *     &lt;li&gt; If such an {@code IOException} is not thrown, then the</span>
       *     stream is reset to a state such that all the bytes read since the
<span class="line-modified">!      *     most recent call to {@code mark} (or since the start of the</span>
<span class="line-modified">!      *     file, if {@code mark} has not been called) will be resupplied</span>
<span class="line-modified">!      *     to subsequent callers of the {@code read} method, followed by</span>
       *     any bytes that otherwise would have been the next input data as of
<span class="line-modified">!      *     the time of the call to {@code reset}. &lt;/ul&gt;</span>
       *
<span class="line-modified">!      * &lt;li&gt; If the method {@code markSupported} returns</span>
<span class="line-modified">!      * {@code false}, then:</span>
       *
<span class="line-modified">!      *     &lt;ul&gt;&lt;li&gt; The call to {@code reset} may throw an</span>
<span class="line-modified">!      *     {@code IOException}.</span>
       *
<span class="line-modified">!      *     &lt;li&gt; If an {@code IOException} is not thrown, then the stream</span>
       *     is reset to a fixed state that depends on the particular type of the
       *     input stream and how it was created. The bytes that will be supplied
<span class="line-modified">!      *     to subsequent callers of the {@code read} method depend on the</span>
       *     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;The method {@code reset} for class {@code InputStream}</span>
<span class="line-modified">!      * does nothing except throw an {@code IOException}.</span>
       *
<span class="line-modified">!      * @throws  IOException  if this stream has not been marked or if the</span>
<span class="line-modified">!      *          mark has been invalidated.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.IOException
       */
      public synchronized void reset() throws IOException {
          throw new IOException(&quot;mark/reset not supported&quot;);
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the {@code mark} and</span>
<span class="line-modified">!      * {@code reset} methods. Whether or not {@code mark} and</span>
<span class="line-modified">!      * {@code reset} are supported is an invariant property of a</span>
<span class="line-modified">!      * particular input stream instance. The {@code markSupported} method</span>
<span class="line-modified">!      * of {@code InputStream} returns {@code false}.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return  {@code true} if this stream instance supports the mark</span>
<span class="line-modified">!      *          and reset methods; {@code false} otherwise.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return false;
</pre>
<center><a href="IOException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputStreamReader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/util/ResourceBundle.java b/src/java.base/share/classes/java/util/ResourceBundle.java
--- a/src/java.base/share/classes/java/util/ResourceBundle.java
+++ b/src/java.base/share/classes/java/util/ResourceBundle.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -77,11 +77,11 @@
 
 
 /**
  *
  * Resource bundles contain locale-specific objects.  When your program needs a
- * locale-specific resource, a <code>String</code> for example, your program can
+ * locale-specific resource, a {@code String} for example, your program can
  * load it from the resource bundle that is appropriate for the current user's
  * locale. In this way, you can write program code that is largely independent
  * of the user's locale isolating most, if not all, of the locale-specific
  * information in resource bundles.
  *
@@ -106,12 +106,12 @@
  *
  * <P>
  * Each resource bundle in a family contains the same items, but the items have
  * been translated for the locale represented by that resource bundle.
  * For example, both "MyResources" and "MyResources_de" may have a
- * <code>String</code> that's used on a button for canceling operations.
- * In "MyResources" the <code>String</code> may contain "Cancel" and in
+ * {@code String} that's used on a button for canceling operations.
+ * In "MyResources" the {@code String} may contain "Cancel" and in
  * "MyResources_de" it may contain "Abbrechen".
  *
  * <P>
  * If there are different resources for different countries, you
  * can make specializations: for example, "MyResources_de_CH" contains objects for
@@ -119,11 +119,11 @@
  * modify some of the resources
  * in the specialization, you can do so.
  *
  * <P>
  * When your program needs a locale-specific object, it loads
- * the <code>ResourceBundle</code> class using the
+ * the {@code ResourceBundle} class using the
  * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
  * method:
  * <blockquote>
  * <pre>
  * ResourceBundle myResources =
@@ -132,11 +132,11 @@
  * </blockquote>
  *
  * <P>
  * Resource bundles contain key/value pairs. The keys uniquely
  * identify a locale-specific object in the bundle. Here's an
- * example of a <code>ListResourceBundle</code> that contains
+ * example of a {@code ListResourceBundle} that contains
  * two key/value pairs:
  * <blockquote>
  * <pre>
  * public class MyResources extends ListResourceBundle {
  *     protected Object[][] getContents() {
@@ -148,76 +148,76 @@
  *        };
  *     }
  * }
  * </pre>
  * </blockquote>
- * Keys are always <code>String</code>s.
+ * Keys are always {@code String}s.
  * In this example, the keys are "OkKey" and "CancelKey".
  * In the above example, the values
- * are also <code>String</code>s--"OK" and "Cancel"--but
+ * are also {@code String}s--"OK" and "Cancel"--but
  * they don't have to be. The values can be any type of object.
  *
  * <P>
  * You retrieve an object from resource bundle using the appropriate
  * getter method. Because "OkKey" and "CancelKey"
- * are both strings, you would use <code>getString</code> to retrieve them:
+ * are both strings, you would use {@code getString} to retrieve them:
  * <blockquote>
  * <pre>
  * button1 = new Button(myResources.getString("OkKey"));
  * button2 = new Button(myResources.getString("CancelKey"));
  * </pre>
  * </blockquote>
  * The getter methods all require the key as an argument and return
  * the object if found. If the object is not found, the getter method
- * throws a <code>MissingResourceException</code>.
+ * throws a {@code MissingResourceException}.
  *
  * <P>
- * Besides <code>getString</code>, <code>ResourceBundle</code> also provides
- * a method for getting string arrays, <code>getStringArray</code>,
- * as well as a generic <code>getObject</code> method for any other
- * type of object. When using <code>getObject</code>, you'll
+ * Besides {@code getString}, {@code ResourceBundle} also provides
+ * a method for getting string arrays, {@code getStringArray},
+ * as well as a generic {@code getObject} method for any other
+ * type of object. When using {@code getObject}, you'll
  * have to cast the result to the appropriate type. For example:
  * <blockquote>
  * <pre>
  * int[] myIntegers = (int[]) myResources.getObject("intList");
  * </pre>
  * </blockquote>
  *
  * <P>
- * The Java Platform provides two subclasses of <code>ResourceBundle</code>,
- * <code>ListResourceBundle</code> and <code>PropertyResourceBundle</code>,
+ * The Java Platform provides two subclasses of {@code ResourceBundle},
+ * {@code ListResourceBundle} and {@code PropertyResourceBundle},
  * that provide a fairly simple way to create resources.
- * As you saw briefly in a previous example, <code>ListResourceBundle</code>
+ * As you saw briefly in a previous example, {@code ListResourceBundle}
  * manages its resource as a list of key/value pairs.
- * <code>PropertyResourceBundle</code> uses a properties file to manage
+ * {@code PropertyResourceBundle} uses a properties file to manage
  * its resources.
  *
  * <p>
- * If <code>ListResourceBundle</code> or <code>PropertyResourceBundle</code>
- * do not suit your needs, you can write your own <code>ResourceBundle</code>
- * subclass.  Your subclasses must override two methods: <code>handleGetObject</code>
- * and <code>getKeys()</code>.
+ * If {@code ListResourceBundle} or {@code PropertyResourceBundle}
+ * do not suit your needs, you can write your own {@code ResourceBundle}
+ * subclass.  Your subclasses must override two methods: {@code handleGetObject}
+ * and {@code getKeys()}.
  *
  * <p>
  * The implementation of a {@code ResourceBundle} subclass must be thread-safe
  * if it's simultaneously used by multiple threads. The default implementations
  * of the non-abstract methods in this class, and the methods in the direct
  * known concrete subclasses {@code ListResourceBundle} and
  * {@code PropertyResourceBundle} are thread-safe.
  *
- * <h3><a id="resource-bundle-modules">Resource Bundles and Named Modules</a></h3>
+ * <h2><a id="resource-bundle-modules">Resource Bundles and Named Modules</a></h2>
  *
  * Resource bundles can be deployed in modules in the following ways:
  *
- * <h4>Resource bundles together with an application</h4>
+ * <h3>Resource bundles together with an application</h3>
  *
  * Resource bundles can be deployed together with an application in the same
  * module.  In that case, the resource bundles are loaded
  * by code in the module by calling the {@link #getBundle(String)}
  * or {@link #getBundle(String, Locale)} method.
  *
- * <h4><a id="service-providers">Resource bundles as service providers</a></h4>
+ * <h3><a id="service-providers">Resource bundles as service providers</a></h3>
  *
  * Resource bundles can be deployed in one or more <em>service provider modules</em>
  * and they can be located using {@link ServiceLoader}.
  * A {@linkplain ResourceBundleProvider service} interface or class must be
  * defined. The caller module declares that it uses the service, the service
@@ -230,11 +230,11 @@
  *
  * <p>A {@linkplain ResourceBundleProvider resource bundle provider} can
  * provide resource bundles in any format such XML which replaces the need
  * of {@link Control ResourceBundle.Control}.
  *
- * <h4><a id="other-modules">Resource bundles in other modules and class path</a></h4>
+ * <h3><a id="other-modules">Resource bundles in other modules and class path</a></h3>
  *
  * Resource bundles in a named module may be <em>encapsulated</em> so that
  * it cannot be located by code in other modules.  Resource bundles
  * in unnamed modules and class path are open for any module to access.
  * Resource bundle follows the resource encapsulation rules as specified
@@ -253,11 +253,11 @@
  * <p>If the caller module is a
  * <a href="{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle">
  * resource bundle provider</a>, it does not fall back to the
  * class loader search.
  *
- * <h4>Resource bundles in automatic modules</h4>
+ * <h3>Resource bundles in automatic modules</h3>
  *
  * A common format of resource bundles is in {@linkplain PropertyResourceBundle
  * .properties} file format.  Typically {@code .properties} resource bundles
  * are packaged in a JAR file.  Resource bundle only JAR file can be readily
  * deployed as an <a href="{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules">
@@ -270,12 +270,12 @@
  * automatic modules.
  *
  * <h3>ResourceBundle.Control</h3>
  *
  * The {@link ResourceBundle.Control} class provides information necessary
- * to perform the bundle loading process by the <code>getBundle</code>
- * factory methods that take a <code>ResourceBundle.Control</code>
+ * to perform the bundle loading process by the {@code getBundle}
+ * factory methods that take a {@code ResourceBundle.Control}
  * instance. You can implement your own subclass in order to enable
  * non-standard resource bundle formats, change the search strategy, or
  * define caching parameters. Refer to the descriptions of the class and the
  * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
  * factory method for details.
@@ -298,33 +298,33 @@
  * Control} will be used instead of the default {@link Control}. If there is
  * more than one service provider for supporting the same base name,
  * the first one returned from {@link ServiceLoader} will be used.
  * A custom {@link Control} implementation is ignored by named modules.
  *
- * <h3>Cache Management</h3>
+ * <h2>Cache Management</h2>
  *
- * Resource bundle instances created by the <code>getBundle</code> factory
+ * Resource bundle instances created by the {@code getBundle} factory
  * methods are cached by default, and the factory methods return the same
  * resource bundle instance multiple times if it has been
- * cached. <code>getBundle</code> clients may clear the cache, manage the
+ * cached. {@code getBundle} clients may clear the cache, manage the
  * lifetime of cached resource bundle instances using time-to-live values,
  * or specify not to cache resource bundle instances. Refer to the
  * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
- * Control) <code>getBundle</code> factory method}, {@link
+ * Control) {@code getBundle} factory method}, {@link
  * #clearCache(ClassLoader) clearCache}, {@link
  * Control#getTimeToLive(String, Locale)
  * ResourceBundle.Control.getTimeToLive}, and {@link
  * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
  * long) ResourceBundle.Control.needsReload} for details.
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  *
- * The following is a very simple example of a <code>ResourceBundle</code>
- * subclass, <code>MyResources</code>, that manages two resources (for a larger number of
- * resources you would probably use a <code>Map</code>).
+ * The following is a very simple example of a {@code ResourceBundle}
+ * subclass, {@code MyResources}, that manages two resources (for a larger number of
+ * resources you would probably use a {@code Map}).
  * Notice that you don't need to supply a value if
- * a "parent-level" <code>ResourceBundle</code> handles the same
+ * a "parent-level" {@code ResourceBundle} handles the same
  * key with the same value (as for the okKey below).
  * <blockquote>
  * <pre>
  * // default (English language, United States)
  * public class MyResources extends ResourceBundle {
@@ -358,15 +358,15 @@
  *     }
  * }
  * </pre>
  * </blockquote>
  * You do not have to restrict yourself to using a single family of
- * <code>ResourceBundle</code>s. For example, you could have a set of bundles for
- * exception messages, <code>ExceptionResources</code>
- * (<code>ExceptionResources_fr</code>, <code>ExceptionResources_de</code>, ...),
- * and one for widgets, <code>WidgetResource</code> (<code>WidgetResources_fr</code>,
- * <code>WidgetResources_de</code>, ...); breaking up the resources however you like.
+ * {@code ResourceBundle}s. For example, you could have a set of bundles for
+ * exception messages, {@code ExceptionResources}
+ * ({@code ExceptionResources_fr}, {@code ExceptionResources_de}, ...),
+ * and one for widgets, {@code WidgetResource} ({@code WidgetResources_fr},
+ * {@code WidgetResources_de}, ...); breaking up the resources however you like.
  *
  * @see ListResourceBundle
  * @see PropertyResourceBundle
  * @see MissingResourceException
  * @see ResourceBundleProvider
@@ -510,13 +510,13 @@
      * <blockquote>
      * <code>(String) {@link #getObject(java.lang.String) getObject}(key)</code>.
      * </blockquote>
      *
      * @param key the key for the desired string
-     * @exception NullPointerException if <code>key</code> is <code>null</code>
-     * @exception MissingResourceException if no object for the given key can be found
-     * @exception ClassCastException if the object found for the given key is not a string
+     * @throws    NullPointerException if {@code key} is {@code null}
+     * @throws    MissingResourceException if no object for the given key can be found
+     * @throws    ClassCastException if the object found for the given key is not a string
      * @return the string for the given key
      */
     public final String getString(String key) {
         return (String) getObject(key);
     }
@@ -527,13 +527,13 @@
      * <blockquote>
      * <code>(String[]) {@link #getObject(java.lang.String) getObject}(key)</code>.
      * </blockquote>
      *
      * @param key the key for the desired string array
-     * @exception NullPointerException if <code>key</code> is <code>null</code>
-     * @exception MissingResourceException if no object for the given key can be found
-     * @exception ClassCastException if the object found for the given key is not a string array
+     * @throws    NullPointerException if {@code key} is {@code null}
+     * @throws    MissingResourceException if no object for the given key can be found
+     * @throws    ClassCastException if the object found for the given key is not a string array
      * @return the string array for the given key
      */
     public final String[] getStringArray(String key) {
         return (String[]) getObject(key);
     }
@@ -541,16 +541,16 @@
     /**
      * Gets an object for the given key from this resource bundle or one of its parents.
      * This method first tries to obtain the object from this resource bundle using
      * {@link #handleGetObject(java.lang.String) handleGetObject}.
      * If not successful, and the parent resource bundle is not null,
-     * it calls the parent's <code>getObject</code> method.
+     * it calls the parent's {@code getObject} method.
      * If still not successful, it throws a MissingResourceException.
      *
      * @param key the key for the desired object
-     * @exception NullPointerException if <code>key</code> is <code>null</code>
-     * @exception MissingResourceException if no object for the given key can be found
+     * @throws    NullPointerException if {@code key} is {@code null}
+     * @throws    MissingResourceException if no object for the given key can be found
      * @return the object for the given key
      */
     public final Object getObject(String key) {
         Object obj = handleGetObject(key);
         if (obj == null) {
@@ -835,17 +835,17 @@
 
     /**
      * Gets a resource bundle using the specified base name, the default locale,
      * and the caller module. Calling this method is equivalent to calling
      * <blockquote>
-     * <code>getBundle(baseName, Locale.getDefault(), callerModule)</code>,
+     * {@code getBundle(baseName, Locale.getDefault(), callerModule)},
      * </blockquote>
      *
      * @param baseName the base name of the resource bundle, a fully qualified class name
-     * @exception java.lang.NullPointerException
-     *     if <code>baseName</code> is <code>null</code>
-     * @exception MissingResourceException
+     * @throws    java.lang.NullPointerException
+     *     if {@code baseName} is {@code null}
+     * @throws    MissingResourceException
      *     if no resource bundle for the specified base name can be found
      * @return a resource bundle for the given base name and the default locale
      *
      * @see <a href="#default_behavior">Resource Bundle Search and Loading Strategy</a>
      * @see <a href="#resource-bundle-modules">Resource Bundles and Named Modules</a>
@@ -864,32 +864,32 @@
      * is equivalent to calling
      * <pre>
      * getBundle(baseName, Locale.getDefault(),
      *           this.getClass().getClassLoader(), control),
      * </pre>
-     * except that <code>getClassLoader()</code> is run with the security
-     * privileges of <code>ResourceBundle</code>.  See {@link
+     * except that {@code getClassLoader()} is run with the security
+     * privileges of {@code ResourceBundle}.  See {@link
      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
      * complete description of the resource bundle loading process with a
-     * <code>ResourceBundle.Control</code>.
+     * {@code ResourceBundle.Control}.
      *
      * @param baseName
      *        the base name of the resource bundle, a fully qualified class
      *        name
      * @param control
      *        the control which gives information for the resource bundle
      *        loading process
      * @return a resource bundle for the given base name and the default locale
      * @throws NullPointerException
-     *         if <code>baseName</code> or <code>control</code> is
-     *         <code>null</code>
+     *         if {@code baseName} or {@code control} is
+     *         {@code null}
      * @throws MissingResourceException
      *         if no resource bundle for the specified base name can be found
      * @throws IllegalArgumentException
-     *         if the given <code>control</code> doesn't perform properly
-     *         (e.g., <code>control.getCandidateLocales</code> returns null.)
-     *         Note that validation of <code>control</code> is performed as
+     *         if the given {@code control} doesn't perform properly
+     *         (e.g., {@code control.getCandidateLocales} returns null.)
+     *         Note that validation of {@code control} is performed as
      *         needed.
      * @throws UnsupportedOperationException
      *         if this method is called in a named module
      * @since 1.6
      * @revised 9
@@ -906,20 +906,20 @@
 
     /**
      * Gets a resource bundle using the specified base name and locale,
      * and the caller module. Calling this method is equivalent to calling
      * <blockquote>
-     * <code>getBundle(baseName, locale, callerModule)</code>,
+     * {@code getBundle(baseName, locale, callerModule)},
      * </blockquote>
      *
      * @param baseName
      *        the base name of the resource bundle, a fully qualified class name
      * @param locale
      *        the locale for which a resource bundle is desired
-     * @exception NullPointerException
-     *        if <code>baseName</code> or <code>locale</code> is <code>null</code>
-     * @exception MissingResourceException
+     * @throws    NullPointerException
+     *        if {@code baseName} or {@code locale} is {@code null}
+     * @throws    MissingResourceException
      *        if no resource bundle for the specified base name can be found
      * @return a resource bundle for the given base name and locale
      *
      * @see <a href="#default_behavior">Resource Bundle Search and Loading Strategy</a>
      * @see <a href="#resource-bundle-modules">Resource Bundles and Named Modules</a>
@@ -935,11 +935,11 @@
 
     /**
      * Gets a resource bundle using the specified base name and the default locale
      * on behalf of the specified module. This method is equivalent to calling
      * <blockquote>
-     * <code>getBundle(baseName, Locale.getDefault(), module)</code>
+     * {@code getBundle(baseName, Locale.getDefault(), module)}
      * </blockquote>
      *
      * @param baseName the base name of the resource bundle,
      *                 a fully qualified class name
      * @param module   the module for which the resource bundle is searched
@@ -1023,36 +1023,36 @@
      * method is equivalent to calling
      * <pre>
      * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
      *           control),
      * </pre>
-     * except that <code>getClassLoader()</code> is run with the security
-     * privileges of <code>ResourceBundle</code>.  See {@link
+     * except that {@code getClassLoader()} is run with the security
+     * privileges of {@code ResourceBundle}.  See {@link
      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
      * complete description of the resource bundle loading process with a
-     * <code>ResourceBundle.Control</code>.
+     * {@code ResourceBundle.Control}.
      *
      * @param baseName
      *        the base name of the resource bundle, a fully qualified
      *        class name
      * @param targetLocale
      *        the locale for which a resource bundle is desired
      * @param control
      *        the control which gives information for the resource
      *        bundle loading process
      * @return a resource bundle for the given base name and a
-     *         <code>Locale</code> in <code>locales</code>
+     *         {@code Locale} in {@code locales}
      * @throws NullPointerException
-     *         if <code>baseName</code>, <code>locales</code> or
-     *         <code>control</code> is <code>null</code>
+     *         if {@code baseName}, {@code locales} or
+     *         {@code control} is {@code null}
      * @throws MissingResourceException
      *         if no resource bundle for the specified base name in any
-     *         of the <code>locales</code> can be found.
+     *         of the {@code locales} can be found.
      * @throws IllegalArgumentException
-     *         if the given <code>control</code> doesn't perform properly
-     *         (e.g., <code>control.getCandidateLocales</code> returns null.)
-     *         Note that validation of <code>control</code> is performed as
+     *         if the given {@code control} doesn't perform properly
+     *         (e.g., {@code control.getCandidateLocales} returns null.)
+     *         Note that validation of {@code control} is performed as
      *         needed.
      * @throws UnsupportedOperationException
      *         if this method is called in a named module
      * @since 1.6
      * @revised 9
@@ -1088,11 +1088,11 @@
      * behavior</a>. The following describes the default behavior.
      *
      * <p>
      * <b><a id="default_behavior">Resource Bundle Search and Loading Strategy</a></b>
      *
-     * <p><code>getBundle</code> uses the base name, the specified locale, and
+     * <p>{@code getBundle} uses the base name, the specified locale, and
      * the default locale (obtained from {@link java.util.Locale#getDefault()
      * Locale.getDefault}) to generate a sequence of <a
      * id="candidates"><em>candidate bundle names</em></a>.  If the specified
      * locale's language, script, country, and variant are all empty strings,
      * then the base name is the only candidate bundle name.  Otherwise, a list
@@ -1138,38 +1138,38 @@
      * MyResource_en_US_WINDOWS
      * MyResource_en_US
      * MyResource_en
      * </pre>
      *
-     * <blockquote><b>Note:</b> For some <code>Locale</code>s, the list of
+     * <blockquote><b>Note:</b> For some {@code Locale}s, the list of
      * candidate bundle names contains extra names, or the order of bundle names
      * is slightly modified.  See the description of the default implementation
      * of {@link Control#getCandidateLocales(String, Locale)
      * getCandidateLocales} for details.</blockquote>
      *
-     * <p><code>getBundle</code> then iterates over the candidate bundle names
+     * <p>{@code getBundle} then iterates over the candidate bundle names
      * to find the first one for which it can <em>instantiate</em> an actual
      * resource bundle. It uses the default controls' {@link Control#getFormats
      * getFormats} method, which generates two bundle names for each generated
      * name, the first a class name and the second a properties file name. For
      * each candidate bundle name, it attempts to create a resource bundle:
      *
      * <ul><li>First, it attempts to load a class using the generated class name.
      * If such a class can be found and loaded using the specified class
      * loader, is assignment compatible with ResourceBundle, is accessible from
-     * ResourceBundle, and can be instantiated, <code>getBundle</code> creates a
+     * ResourceBundle, and can be instantiated, {@code getBundle} creates a
      * new instance of this class and uses it as the <em>result resource
      * bundle</em>.
      *
-     * <li>Otherwise, <code>getBundle</code> attempts to locate a property
+     * <li>Otherwise, {@code getBundle} attempts to locate a property
      * resource file using the generated properties file name.  It generates a
      * path name from the candidate bundle name by replacing all "." characters
      * with "/" and appending the string ".properties".  It attempts to find a
      * "resource" with this name using {@link
      * java.lang.ClassLoader#getResource(java.lang.String)
      * ClassLoader.getResource}.  (Note that a "resource" in the sense of
-     * <code>getResource</code> has nothing to do with the contents of a
+     * {@code getResource} has nothing to do with the contents of a
      * resource bundle, it is just a container of data, such as a file.)  If it
      * finds a "resource", it attempts to create a new {@link
      * PropertyResourceBundle} instance from its contents.  If successful, this
      * instance becomes the <em>result resource bundle</em>.  </ul>
      *
@@ -1179,18 +1179,18 @@
      * getFallbackLocale} method is called, which returns the current default
      * locale.  A new sequence of candidate locale names is generated using this
      * locale and searched again, as above.
      *
      * <p>If still no result bundle is found, the base name alone is looked up. If
-     * this still fails, a <code>MissingResourceException</code> is thrown.
+     * this still fails, a {@code MissingResourceException} is thrown.
      *
      * <p><a id="parent_chain"> Once a result resource bundle has been found,
      * its <em>parent chain</em> is instantiated</a>.  If the result bundle already
      * has a parent (perhaps because it was returned from a cache) the chain is
      * complete.
      *
-     * <p>Otherwise, <code>getBundle</code> examines the remainder of the
+     * <p>Otherwise, {@code getBundle} examines the remainder of the
      * candidate locale list that was used during the pass that generated the
      * result resource bundle.  (As before, candidate bundle names where the
      * final component is an empty string are omitted.)  When it comes to the
      * end of the candidate list, it tries the plain bundle name.  With each of the
      * candidate bundle names it attempts to instantiate a resource bundle (first
@@ -1201,17 +1201,17 @@
      * with the new resource bundle.  This continues until the list of names
      * is exhausted or the current bundle already has a non-null parent.
      *
      * <p>Once the parent chain is complete, the bundle is returned.
      *
-     * <p><b>Note:</b> <code>getBundle</code> caches instantiated resource
+     * <p><b>Note:</b> {@code getBundle} caches instantiated resource
      * bundles and might return the same resource bundle instance multiple times.
      *
-     * <p><b>Note:</b>The <code>baseName</code> argument should be a fully
+     * <p><b>Note:</b>The {@code baseName} argument should be a fully
      * qualified class name. However, for compatibility with earlier versions,
      * Java SE Runtime Environments do not verify this, and so it is
-     * possible to access <code>PropertyResourceBundle</code>s by specifying a
+     * possible to access {@code PropertyResourceBundle}s by specifying a
      * path name (using "/") instead of a fully qualified class name (using
      * ".").
      *
      * <p><a id="default_behavior_example">
      * <strong>Example:</strong></a>
@@ -1226,15 +1226,15 @@
      *     <li>MyResources_en.properties
      *     <li>MyResources_es_ES.class
      * </ul>
      *
      * The contents of all files are valid (that is, public non-abstract
-     * subclasses of <code>ResourceBundle</code> for the ".class" files,
+     * subclasses of {@code ResourceBundle} for the ".class" files,
      * syntactically correct ".properties" files).  The default locale is
-     * <code>Locale("en", "GB")</code>.
+     * {@code Locale("en", "GB")}.
      *
-     * <p>Calling <code>getBundle</code> with the locale arguments below will
+     * <p>Calling {@code getBundle} with the locale arguments below will
      * instantiate resource bundles as follows:
      *
      * <table class="striped">
      * <caption style="display:none">getBundle() locale to resource bundle mapping</caption>
      * <thead>
@@ -1262,13 +1262,13 @@
      *
      * @param baseName the base name of the resource bundle, a fully qualified class name
      * @param locale the locale for which a resource bundle is desired
      * @param loader the class loader from which to load the resource bundle
      * @return a resource bundle for the given base name and locale
-     * @exception java.lang.NullPointerException
-     *        if <code>baseName</code>, <code>locale</code>, or <code>loader</code> is <code>null</code>
-     * @exception MissingResourceException
+     * @throws    java.lang.NullPointerException
+     *        if {@code baseName}, {@code locale}, or {@code loader} is {@code null}
+     * @throws    MissingResourceException
      *        if no resource bundle for the specified base name can be found
      * @since 1.2
      * @revised 9
      * @spec JPMS
      * @see <a href="#resource-bundle-modules">Resource Bundles and Named Modules</a>
@@ -1287,100 +1287,100 @@
     /**
      * Returns a resource bundle using the specified base name, target
      * locale, class loader and control. Unlike the {@link
      * #getBundle(String, Locale, ClassLoader) getBundle}
      * factory methods with no {@code control} argument, the given
-     * <code>control</code> specifies how to locate and instantiate resource
+     * {@code control} specifies how to locate and instantiate resource
      * bundles. Conceptually, the bundle loading process with the given
-     * <code>control</code> is performed in the following steps.
+     * {@code control} is performed in the following steps.
      *
      * <ol>
      * <li>This factory method looks up the resource bundle in the cache for
-     * the specified <code>baseName</code>, <code>targetLocale</code> and
-     * <code>loader</code>.  If the requested resource bundle instance is
+     * the specified {@code baseName}, {@code targetLocale} and
+     * {@code loader}.  If the requested resource bundle instance is
      * found in the cache and the time-to-live periods of the instance and
      * all of its parent instances have not expired, the instance is returned
      * to the caller. Otherwise, this factory method proceeds with the
      * loading process below.</li>
      *
      * <li>The {@link ResourceBundle.Control#getFormats(String)
      * control.getFormats} method is called to get resource bundle formats
      * to produce bundle or resource names. The strings
-     * <code>"java.class"</code> and <code>"java.properties"</code>
+     * {@code "java.class"} and {@code "java.properties"}
      * designate class-based and {@linkplain PropertyResourceBundle
      * property}-based resource bundles, respectively. Other strings
-     * starting with <code>"java."</code> are reserved for future extensions
+     * starting with {@code "java."} are reserved for future extensions
      * and must not be used for application-defined formats. Other strings
      * designate application-defined formats.</li>
      *
      * <li>The {@link ResourceBundle.Control#getCandidateLocales(String,
      * Locale) control.getCandidateLocales} method is called with the target
-     * locale to get a list of <em>candidate <code>Locale</code>s</em> for
+     * locale to get a list of <em>candidate {@code Locale}s</em> for
      * which resource bundles are searched.</li>
      *
      * <li>The {@link ResourceBundle.Control#newBundle(String, Locale,
      * String, ClassLoader, boolean) control.newBundle} method is called to
-     * instantiate a <code>ResourceBundle</code> for the base bundle name, a
+     * instantiate a {@code ResourceBundle} for the base bundle name, a
      * candidate locale, and a format. (Refer to the note on the cache
      * lookup below.) This step is iterated over all combinations of the
-     * candidate locales and formats until the <code>newBundle</code> method
-     * returns a <code>ResourceBundle</code> instance or the iteration has
+     * candidate locales and formats until the {@code newBundle} method
+     * returns a {@code ResourceBundle} instance or the iteration has
      * used up all the combinations. For example, if the candidate locales
-     * are <code>Locale("de", "DE")</code>, <code>Locale("de")</code> and
-     * <code>Locale("")</code> and the formats are <code>"java.class"</code>
-     * and <code>"java.properties"</code>, then the following is the
+     * are {@code Locale("de", "DE")}, {@code Locale("de")} and
+     * {@code Locale("")} and the formats are {@code "java.class"}
+     * and {@code "java.properties"}, then the following is the
      * sequence of locale-format combinations to be used to call
-     * <code>control.newBundle</code>.
+     * {@code control.newBundle}.
      *
      * <table class=striped style="width: 50%; text-align: left; margin-left: 40px;">
      * <caption style="display:none">locale-format combinations for newBundle</caption>
      * <thead>
      * <tr>
      * <th scope="col">Index</th>
-     * <th scope="col"><code>Locale</code></th>
-     * <th scope="col"><code>format</code></th>
+     * <th scope="col">{@code Locale}</th>
+     * <th scope="col">{@code format}</th>
      * </tr>
      * </thead>
      * <tbody>
      * <tr>
      * <th scope="row">1</th>
-     * <td><code>Locale("de", "DE")</code></td>
-     * <td><code>java.class</code></td>
+     * <td>{@code Locale("de", "DE")}</td>
+     * <td>{@code java.class}</td>
      * </tr>
      * <tr>
      * <th scope="row">2</th>
-     * <td><code>Locale("de", "DE")</code></td>
-     * <td><code>java.properties</code></td>
+     * <td>{@code Locale("de", "DE")}</td>
+     * <td>{@code java.properties}</td>
      * </tr>
      * <tr>
      * <th scope="row">3</th>
-     * <td><code>Locale("de")</code></td>
-     * <td><code>java.class</code></td>
+     * <td>{@code Locale("de")}</td>
+     * <td>{@code java.class}</td>
      * </tr>
      * <tr>
      * <th scope="row">4</th>
-     * <td><code>Locale("de")</code></td>
-     * <td><code>java.properties</code></td>
+     * <td>{@code Locale("de")}</td>
+     * <td>{@code java.properties}</td>
      * </tr>
      * <tr>
      * <th scope="row">5</th>
-     * <td><code>Locale("")</code></td>
-     * <td><code>java.class</code></td>
+     * <td>{@code Locale("")}</td>
+     * <td>{@code java.class}</td>
      * </tr>
      * <tr>
      * <th scope="row">6</th>
-     * <td><code>Locale("")</code></td>
-     * <td><code>java.properties</code></td>
+     * <td>{@code Locale("")}</td>
+     * <td>{@code java.properties}</td>
      * </tr>
      * </tbody>
      * </table>
      * </li>
      *
      * <li>If the previous step has found no resource bundle, proceed to
      * Step 6. If a bundle has been found that is a base bundle (a bundle
-     * for <code>Locale("")</code>), and the candidate locale list only contained
-     * <code>Locale("")</code>, return the bundle to the caller. If a bundle
+     * for {@code Locale("")}), and the candidate locale list only contained
+     * {@code Locale("")}, return the bundle to the caller. If a bundle
      * has been found that is a base bundle, but the candidate locale list
      * contained locales other than Locale(""), put the bundle on hold and
      * proceed to Step 6. If a bundle has been found that is not a base
      * bundle, proceed to Step 7.</li>
      *
@@ -1408,69 +1408,69 @@
      * resource bundle found in the cache has expired, the factory method
      * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
      * String, ClassLoader, ResourceBundle, long) control.needsReload}
      * method to determine whether the resource bundle needs to be reloaded.
      * If reloading is required, the factory method calls
-     * <code>control.newBundle</code> to reload the resource bundle.  If
-     * <code>control.newBundle</code> returns <code>null</code>, the factory
+     * {@code control.newBundle} to reload the resource bundle.  If
+     * {@code control.newBundle} returns {@code null}, the factory
      * method puts a dummy resource bundle in the cache as a mark of
      * nonexistent resource bundles in order to avoid lookup overhead for
      * subsequent requests. Such dummy resource bundles are under the same
-     * expiration control as specified by <code>control</code>.
+     * expiration control as specified by {@code control}.
      *
      * <p>All resource bundles loaded are cached by default. Refer to
      * {@link Control#getTimeToLive(String,Locale)
      * control.getTimeToLive} for details.
      *
      * <p>The following is an example of the bundle loading process with the
-     * default <code>ResourceBundle.Control</code> implementation.
+     * default {@code ResourceBundle.Control} implementation.
      *
      * <p>Conditions:
      * <ul>
-     * <li>Base bundle name: <code>foo.bar.Messages</code>
-     * <li>Requested <code>Locale</code>: {@link Locale#ITALY}</li>
-     * <li>Default <code>Locale</code>: {@link Locale#FRENCH}</li>
+     * <li>Base bundle name: {@code foo.bar.Messages}
+     * <li>Requested {@code Locale}: {@link Locale#ITALY}</li>
+     * <li>Default {@code Locale}: {@link Locale#FRENCH}</li>
      * <li>Available resource bundles:
-     * <code>foo/bar/Messages_fr.properties</code> and
-     * <code>foo/bar/Messages.properties</code></li>
+     * {@code foo/bar/Messages_fr.properties} and
+     * {@code foo/bar/Messages.properties}</li>
      * </ul>
      *
-     * <p>First, <code>getBundle</code> tries loading a resource bundle in
+     * <p>First, {@code getBundle} tries loading a resource bundle in
      * the following sequence.
      *
      * <ul>
-     * <li>class <code>foo.bar.Messages_it_IT</code>
-     * <li>file <code>foo/bar/Messages_it_IT.properties</code>
-     * <li>class <code>foo.bar.Messages_it</code></li>
-     * <li>file <code>foo/bar/Messages_it.properties</code></li>
-     * <li>class <code>foo.bar.Messages</code></li>
-     * <li>file <code>foo/bar/Messages.properties</code></li>
+     * <li>class {@code foo.bar.Messages_it_IT}
+     * <li>file {@code foo/bar/Messages_it_IT.properties}
+     * <li>class {@code foo.bar.Messages_it}</li>
+     * <li>file {@code foo/bar/Messages_it.properties}</li>
+     * <li>class {@code foo.bar.Messages}</li>
+     * <li>file {@code foo/bar/Messages.properties}</li>
      * </ul>
      *
-     * <p>At this point, <code>getBundle</code> finds
-     * <code>foo/bar/Messages.properties</code>, which is put on hold
-     * because it's the base bundle.  <code>getBundle</code> calls {@link
+     * <p>At this point, {@code getBundle} finds
+     * {@code foo/bar/Messages.properties}, which is put on hold
+     * because it's the base bundle.  {@code getBundle} calls {@link
      * Control#getFallbackLocale(String, Locale)
      * control.getFallbackLocale("foo.bar.Messages", Locale.ITALY)} which
-     * returns <code>Locale.FRENCH</code>. Next, <code>getBundle</code>
+     * returns {@code Locale.FRENCH}. Next, {@code getBundle}
      * tries loading a bundle in the following sequence.
      *
      * <ul>
-     * <li>class <code>foo.bar.Messages_fr</code></li>
-     * <li>file <code>foo/bar/Messages_fr.properties</code></li>
-     * <li>class <code>foo.bar.Messages</code></li>
-     * <li>file <code>foo/bar/Messages.properties</code></li>
+     * <li>class {@code foo.bar.Messages_fr}</li>
+     * <li>file {@code foo/bar/Messages_fr.properties}</li>
+     * <li>class {@code foo.bar.Messages}</li>
+     * <li>file {@code foo/bar/Messages.properties}</li>
      * </ul>
      *
-     * <p><code>getBundle</code> finds
-     * <code>foo/bar/Messages_fr.properties</code> and creates a
-     * <code>ResourceBundle</code> instance. Then, <code>getBundle</code>
+     * <p>{@code getBundle} finds
+     * {@code foo/bar/Messages_fr.properties} and creates a
+     * {@code ResourceBundle} instance. Then, {@code getBundle}
      * sets up its parent chain from the list of the candidate locales.  Only
-     * <code>foo/bar/Messages.properties</code> is found in the list and
-     * <code>getBundle</code> creates a <code>ResourceBundle</code> instance
+     * {@code foo/bar/Messages.properties} is found in the list and
+     * {@code getBundle} creates a {@code ResourceBundle} instance
      * that becomes the parent of the instance for
-     * <code>foo/bar/Messages_fr.properties</code>.
+     * {@code foo/bar/Messages_fr.properties}.
      *
      * @param baseName
      *        the base name of the resource bundle, a fully qualified
      *        class name
      * @param targetLocale
@@ -1480,19 +1480,19 @@
      * @param control
      *        the control which gives information for the resource
      *        bundle loading process
      * @return a resource bundle for the given base name and locale
      * @throws NullPointerException
-     *         if <code>baseName</code>, <code>targetLocale</code>,
-     *         <code>loader</code>, or <code>control</code> is
-     *         <code>null</code>
+     *         if {@code baseName}, {@code targetLocale},
+     *         {@code loader}, or {@code control} is
+     *         {@code null}
      * @throws MissingResourceException
      *         if no resource bundle for the specified base name can be found
      * @throws IllegalArgumentException
-     *         if the given <code>control</code> doesn't perform properly
-     *         (e.g., <code>control.getCandidateLocales</code> returns null.)
-     *         Note that validation of <code>control</code> is performed as
+     *         if the given {@code control} doesn't perform properly
+     *         (e.g., {@code control.getCandidateLocales} returns null.)
+     *         Note that validation of {@code control} is performed as
      *         needed.
      * @throws UnsupportedOperationException
      *         if this method is called in a named module
      * @since 1.6
      * @revised 9
@@ -1698,11 +1698,11 @@
 
         return bundle;
     }
 
     /**
-     * Checks if the given <code>List</code> is not null, not empty,
+     * Checks if the given {@code List} is not null, not empty,
      * not having null in its elements.
      */
     private static boolean checkList(List<?> a) {
         boolean valid = (a != null && !a.isEmpty());
         if (valid) {
@@ -2064,11 +2064,11 @@
      * `expired' and removed from the cache upon return.
      *
      * @param cacheKey the key to look up the cache
      * @param control the Control to be used for the expiration control
      * @return the cached bundle, or null if the bundle is not found in the
-     * cache or its parent has expired. <code>bundle.expire</code> is true
+     * cache or its parent has expired. {@code bundle.expire} is true
      * upon return if the bundle in the cache has expired.
      */
     private static ResourceBundle findBundleInCache(CacheKey cacheKey,
                                                     Control control) {
         BundleReference bundleRef = cacheList.get(cacheKey);
@@ -2248,11 +2248,11 @@
     /**
      * Removes all resource bundles from the cache that have been loaded
      * by the given class loader.
      *
      * @param loader the class loader
-     * @exception NullPointerException if <code>loader</code> is null
+     * @throws    NullPointerException if {@code loader} is null
      * @since 1.6
      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
      */
     public static final void clearCache(ClassLoader loader) {
         Objects.requireNonNull(loader);
@@ -2269,34 +2269,34 @@
      * Gets an object for the given key from this resource bundle.
      * Returns null if this resource bundle does not contain an
      * object for the given key.
      *
      * @param key the key for the desired object
-     * @exception NullPointerException if <code>key</code> is <code>null</code>
+     * @throws    NullPointerException if {@code key} is {@code null}
      * @return the object for the given key, or null
      */
     protected abstract Object handleGetObject(String key);
 
     /**
      * Returns an enumeration of the keys.
      *
-     * @return an <code>Enumeration</code> of the keys contained in
-     *         this <code>ResourceBundle</code> and its parent bundles.
+     * @return an {@code Enumeration} of the keys contained in
+     *         this {@code ResourceBundle} and its parent bundles.
      */
     public abstract Enumeration<String> getKeys();
 
     /**
-     * Determines whether the given <code>key</code> is contained in
-     * this <code>ResourceBundle</code> or its parent bundles.
+     * Determines whether the given {@code key} is contained in
+     * this {@code ResourceBundle} or its parent bundles.
      *
      * @param key
-     *        the resource <code>key</code>
-     * @return <code>true</code> if the given <code>key</code> is
-     *        contained in this <code>ResourceBundle</code> or its
-     *        parent bundles; <code>false</code> otherwise.
-     * @exception NullPointerException
-     *         if <code>key</code> is <code>null</code>
+     *        the resource {@code key}
+     * @return {@code true} if the given {@code key} is
+     *        contained in this {@code ResourceBundle} or its
+     *        parent bundles; {@code false} otherwise.
+     * @throws    NullPointerException
+     *         if {@code key} is {@code null}
      * @since 1.6
      */
     public boolean containsKey(String key) {
         if (key == null) {
             throw new NullPointerException();
@@ -2308,15 +2308,15 @@
         }
         return false;
     }
 
     /**
-     * Returns a <code>Set</code> of all keys contained in this
-     * <code>ResourceBundle</code> and its parent bundles.
+     * Returns a {@code Set} of all keys contained in this
+     * {@code ResourceBundle} and its parent bundles.
      *
-     * @return a <code>Set</code> of all keys contained in this
-     *         <code>ResourceBundle</code> and its parent bundles.
+     * @return a {@code Set} of all keys contained in this
+     *         {@code ResourceBundle} and its parent bundles.
      * @since 1.6
      */
     public Set<String> keySet() {
         Set<String> keys = new HashSet<>();
         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
@@ -2324,24 +2324,24 @@
         }
         return keys;
     }
 
     /**
-     * Returns a <code>Set</code> of the keys contained <em>only</em>
-     * in this <code>ResourceBundle</code>.
+     * Returns a {@code Set} of the keys contained <em>only</em>
+     * in this {@code ResourceBundle}.
      *
-     * <p>The default implementation returns a <code>Set</code> of the
+     * <p>The default implementation returns a {@code Set} of the
      * keys returned by the {@link #getKeys() getKeys} method except
      * for the ones for which the {@link #handleGetObject(String)
-     * handleGetObject} method returns <code>null</code>. Once the
-     * <code>Set</code> has been created, the value is kept in this
-     * <code>ResourceBundle</code> in order to avoid producing the
-     * same <code>Set</code> in subsequent calls. Subclasses can
+     * handleGetObject} method returns {@code null}. Once the
+     * {@code Set} has been created, the value is kept in this
+     * {@code ResourceBundle} in order to avoid producing the
+     * same {@code Set} in subsequent calls. Subclasses can
      * override this method for faster handling.
      *
-     * @return a <code>Set</code> of the keys contained only in this
-     *        <code>ResourceBundle</code>
+     * @return a {@code Set} of the keys contained only in this
+     *        {@code ResourceBundle}
      * @since 1.6
      */
     protected Set<String> handleKeySet() {
         if (keySet == null) {
             synchronized (this) {
@@ -2362,15 +2362,15 @@
     }
 
 
 
     /**
-     * <code>ResourceBundle.Control</code> defines a set of callback methods
+     * {@code ResourceBundle.Control} defines a set of callback methods
      * that are invoked by the {@link ResourceBundle#getBundle(String,
      * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
      * methods during the bundle loading process. In other words, a
-     * <code>ResourceBundle.Control</code> collaborates with the factory
+     * {@code ResourceBundle.Control} collaborates with the factory
      * methods for loading resource bundles. The default implementation of
      * the callback methods provides the information necessary for the
      * factory methods to perform the <a
      * href="./ResourceBundle.html#default_behavior">default behavior</a>.
      *
@@ -2384,49 +2384,49 @@
      *
      * <p>In addition to the callback methods, the {@link
      * #toBundleName(String, Locale) toBundleName} and {@link
      * #toResourceName(String, String) toResourceName} methods are defined
      * primarily for convenience in implementing the callback
-     * methods. However, the <code>toBundleName</code> method could be
+     * methods. However, the {@code toBundleName} method could be
      * overridden to provide different conventions in the organization and
-     * packaging of localized resources.  The <code>toResourceName</code>
-     * method is <code>final</code> to avoid use of wrong resource and class
+     * packaging of localized resources.  The {@code toResourceName}
+     * method is {@code final} to avoid use of wrong resource and class
      * name separators.
      *
      * <p>Two factory methods, {@link #getControl(List)} and {@link
      * #getNoFallbackControl(List)}, provide
-     * <code>ResourceBundle.Control</code> instances that implement common
+     * {@code ResourceBundle.Control} instances that implement common
      * variations of the default bundle loading process.
      *
      * <p>The formats returned by the {@link Control#getFormats(String)
      * getFormats} method and candidate locales returned by the {@link
      * ResourceBundle.Control#getCandidateLocales(String, Locale)
      * getCandidateLocales} method must be consistent in all
-     * <code>ResourceBundle.getBundle</code> invocations for the same base
-     * bundle. Otherwise, the <code>ResourceBundle.getBundle</code> methods
+     * {@code ResourceBundle.getBundle} invocations for the same base
+     * bundle. Otherwise, the {@code ResourceBundle.getBundle} methods
      * may return unintended bundles. For example, if only
-     * <code>"java.class"</code> is returned by the <code>getFormats</code>
-     * method for the first call to <code>ResourceBundle.getBundle</code>
-     * and only <code>"java.properties"</code> for the second call, then the
+     * {@code "java.class"} is returned by the {@code getFormats}
+     * method for the first call to {@code ResourceBundle.getBundle}
+     * and only {@code "java.properties"} for the second call, then the
      * second call will return the class-based one that has been cached
      * during the first call.
      *
-     * <p>A <code>ResourceBundle.Control</code> instance must be thread-safe
+     * <p>A {@code ResourceBundle.Control} instance must be thread-safe
      * if it's simultaneously used by multiple threads.
-     * <code>ResourceBundle.getBundle</code> does not synchronize to call
-     * the <code>ResourceBundle.Control</code> methods. The default
+     * {@code ResourceBundle.getBundle} does not synchronize to call
+     * the {@code ResourceBundle.Control} methods. The default
      * implementations of the methods are thread-safe.
      *
-     * <p>Applications can specify <code>ResourceBundle.Control</code>
-     * instances returned by the <code>getControl</code> factory methods or
-     * created from a subclass of <code>ResourceBundle.Control</code> to
+     * <p>Applications can specify {@code ResourceBundle.Control}
+     * instances returned by the {@code getControl} factory methods or
+     * created from a subclass of {@code ResourceBundle.Control} to
      * customize the bundle loading process. The following are examples of
      * changing the default bundle loading process.
      *
      * <p><b>Example 1</b>
      *
-     * <p>The following code lets <code>ResourceBundle.getBundle</code> look
+     * <p>The following code lets {@code ResourceBundle.getBundle} look
      * up only properties-based resources.
      *
      * <pre>
      * import java.util.*;
      * import static java.util.ResourceBundle.Control.*;
@@ -2436,16 +2436,16 @@
      *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
      * </pre>
      *
      * Given the resource bundles in the <a
      * href="./ResourceBundle.html#default_behavior_example">example</a> in
-     * the <code>ResourceBundle.getBundle</code> description, this
-     * <code>ResourceBundle.getBundle</code> call loads
-     * <code>MyResources_fr_CH.properties</code> whose parent is
-     * <code>MyResources_fr.properties</code> whose parent is
-     * <code>MyResources.properties</code>. (<code>MyResources_fr_CH.properties</code>
-     * is not hidden, but <code>MyResources_fr_CH.class</code> is.)
+     * the {@code ResourceBundle.getBundle} description, this
+     * {@code ResourceBundle.getBundle} call loads
+     * {@code MyResources_fr_CH.properties} whose parent is
+     * {@code MyResources_fr.properties} whose parent is
+     * {@code MyResources.properties}. ({@code MyResources_fr_CH.properties}
+     * is not hidden, but {@code MyResources_fr_CH.class} is.)
      *
      * <p><b>Example 2</b>
      *
      * <p>The following is an example of loading XML-based bundles
      * using {@link Properties#loadFromXML(java.io.InputStream)
@@ -2527,30 +2527,30 @@
      * @spec JPMS
      * @see java.util.spi.ResourceBundleProvider
      */
     public static class Control {
         /**
-         * The default format <code>List</code>, which contains the strings
-         * <code>"java.class"</code> and <code>"java.properties"</code>, in
-         * this order. This <code>List</code> is unmodifiable.
+         * The default format {@code List}, which contains the strings
+         * {@code "java.class"} and {@code "java.properties"}, in
+         * this order. This {@code List} is unmodifiable.
          *
          * @see #getFormats(String)
          */
         public static final List<String> FORMAT_DEFAULT
             = List.of("java.class", "java.properties");
 
         /**
-         * The class-only format <code>List</code> containing
-         * <code>"java.class"</code>. This <code>List</code> is unmodifiable.
+         * The class-only format {@code List} containing
+         * {@code "java.class"}. This {@code List} is unmodifiable.
          *
          * @see #getFormats(String)
          */
         public static final List<String> FORMAT_CLASS = List.of("java.class");
 
         /**
-         * The properties-only format <code>List</code> containing
-         * <code>"java.properties"</code>. This <code>List</code> is unmodifiable.
+         * The properties-only format {@code List} containing
+         * {@code "java.properties"}. This {@code List} is unmodifiable.
          *
          * @see #getFormats(String)
          */
         public static final List<String> FORMAT_PROPERTIES
             = List.of("java.properties");
@@ -2579,31 +2579,31 @@
          */
         protected Control() {
         }
 
         /**
-         * Returns a <code>ResourceBundle.Control</code> in which the {@link
+         * Returns a {@code ResourceBundle.Control} in which the {@link
          * #getFormats(String) getFormats} method returns the specified
-         * <code>formats</code>. The <code>formats</code> must be equal to
+         * {@code formats}. The {@code formats} must be equal to
          * one of {@link Control#FORMAT_PROPERTIES}, {@link
          * Control#FORMAT_CLASS} or {@link
-         * Control#FORMAT_DEFAULT}. <code>ResourceBundle.Control</code>
+         * Control#FORMAT_DEFAULT}. {@code ResourceBundle.Control}
          * instances returned by this method are singletons and thread-safe.
          *
          * <p>Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
-         * instantiating the <code>ResourceBundle.Control</code> class,
+         * instantiating the {@code ResourceBundle.Control} class,
          * except that this method returns a singleton.
          *
          * @param formats
          *        the formats to be returned by the
-         *        <code>ResourceBundle.Control.getFormats</code> method
-         * @return a <code>ResourceBundle.Control</code> supporting the
-         *        specified <code>formats</code>
-         * @exception NullPointerException
-         *        if <code>formats</code> is <code>null</code>
-         * @exception IllegalArgumentException
-         *        if <code>formats</code> is unknown
+         *        {@code ResourceBundle.Control.getFormats} method
+         * @return a {@code ResourceBundle.Control} supporting the
+         *        specified {@code formats}
+         * @throws    NullPointerException
+         *        if {@code formats} is {@code null}
+         * @throws    IllegalArgumentException
+         *        if {@code formats} is unknown
          */
         public static final Control getControl(List<String> formats) {
             if (formats.equals(Control.FORMAT_PROPERTIES)) {
                 return SingleFormatControl.PROPERTIES_ONLY;
             }
@@ -2615,30 +2615,30 @@
             }
             throw new IllegalArgumentException();
         }
 
         /**
-         * Returns a <code>ResourceBundle.Control</code> in which the {@link
+         * Returns a {@code ResourceBundle.Control} in which the {@link
          * #getFormats(String) getFormats} method returns the specified
-         * <code>formats</code> and the {@link
+         * {@code formats} and the {@link
          * Control#getFallbackLocale(String, Locale) getFallbackLocale}
-         * method returns <code>null</code>. The <code>formats</code> must
+         * method returns {@code null}. The {@code formats} must
          * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
          * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
-         * <code>ResourceBundle.Control</code> instances returned by this
+         * {@code ResourceBundle.Control} instances returned by this
          * method are singletons and thread-safe.
          *
          * @param formats
          *        the formats to be returned by the
-         *        <code>ResourceBundle.Control.getFormats</code> method
-         * @return a <code>ResourceBundle.Control</code> supporting the
-         *        specified <code>formats</code> with no fallback
-         *        <code>Locale</code> support
-         * @exception NullPointerException
-         *        if <code>formats</code> is <code>null</code>
-         * @exception IllegalArgumentException
-         *        if <code>formats</code> is unknown
+         *        {@code ResourceBundle.Control.getFormats} method
+         * @return a {@code ResourceBundle.Control} supporting the
+         *        specified {@code formats} with no fallback
+         *        {@code Locale} support
+         * @throws    NullPointerException
+         *        if {@code formats} is {@code null}
+         * @throws    IllegalArgumentException
+         *        if {@code formats} is unknown
          */
         public static final Control getNoFallbackControl(List<String> formats) {
             if (formats.equals(Control.FORMAT_DEFAULT)) {
                 return NoFallbackControl.NO_FALLBACK;
             }
@@ -2650,39 +2650,39 @@
             }
             throw new IllegalArgumentException();
         }
 
         /**
-         * Returns a <code>List</code> of <code>String</code>s containing
+         * Returns a {@code List} of {@code String}s containing
          * formats to be used to load resource bundles for the given
-         * <code>baseName</code>. The <code>ResourceBundle.getBundle</code>
+         * {@code baseName}. The {@code ResourceBundle.getBundle}
          * factory method tries to load resource bundles with formats in the
          * order specified by the list. The list returned by this method
-         * must have at least one <code>String</code>. The predefined
-         * formats are <code>"java.class"</code> for class-based resource
-         * bundles and <code>"java.properties"</code> for {@linkplain
+         * must have at least one {@code String}. The predefined
+         * formats are {@code "java.class"} for class-based resource
+         * bundles and {@code "java.properties"} for {@linkplain
          * PropertyResourceBundle properties-based} ones. Strings starting
-         * with <code>"java."</code> are reserved for future extensions and
+         * with {@code "java."} are reserved for future extensions and
          * must not be used by application-defined formats.
          *
          * <p>It is not a requirement to return an immutable (unmodifiable)
-         * <code>List</code>.  However, the returned <code>List</code> must
+         * {@code List}.  However, the returned {@code List} must
          * not be mutated after it has been returned by
-         * <code>getFormats</code>.
+         * {@code getFormats}.
          *
          * <p>The default implementation returns {@link #FORMAT_DEFAULT} so
-         * that the <code>ResourceBundle.getBundle</code> factory method
+         * that the {@code ResourceBundle.getBundle} factory method
          * looks up first class-based resource bundles, then
          * properties-based ones.
          *
          * @param baseName
          *        the base name of the resource bundle, a fully qualified class
          *        name
-         * @return a <code>List</code> of <code>String</code>s containing
+         * @return a {@code List} of {@code String}s containing
          *        formats for loading resource bundles.
-         * @exception NullPointerException
-         *        if <code>baseName</code> is null
+         * @throws    NullPointerException
+         *        if {@code baseName} is null
          * @see #FORMAT_DEFAULT
          * @see #FORMAT_CLASS
          * @see #FORMAT_PROPERTIES
          */
         public List<String> getFormats(String baseName) {
@@ -2691,75 +2691,75 @@
             }
             return FORMAT_DEFAULT;
         }
 
         /**
-         * Returns a <code>List</code> of <code>Locale</code>s as candidate
-         * locales for <code>baseName</code> and <code>locale</code>. This
-         * method is called by the <code>ResourceBundle.getBundle</code>
+         * Returns a {@code List} of {@code Locale}s as candidate
+         * locales for {@code baseName} and {@code locale}. This
+         * method is called by the {@code ResourceBundle.getBundle}
          * factory method each time the factory method tries finding a
-         * resource bundle for a target <code>Locale</code>.
+         * resource bundle for a target {@code Locale}.
          *
          * <p>The sequence of the candidate locales also corresponds to the
          * runtime resource lookup path (also known as the <I>parent
          * chain</I>), if the corresponding resource bundles for the
          * candidate locales exist and their parents are not defined by
          * loaded resource bundles themselves.  The last element of the list
          * must be a {@linkplain Locale#ROOT root locale} if it is desired to
          * have the base bundle as the terminal of the parent chain.
          *
-         * <p>If the given locale is equal to <code>Locale.ROOT</code> (the
-         * root locale), a <code>List</code> containing only the root
-         * <code>Locale</code> must be returned. In this case, the
-         * <code>ResourceBundle.getBundle</code> factory method loads only
+         * <p>If the given locale is equal to {@code Locale.ROOT} (the
+         * root locale), a {@code List} containing only the root
+         * {@code Locale} must be returned. In this case, the
+         * {@code ResourceBundle.getBundle} factory method loads only
          * the base bundle as the resulting resource bundle.
          *
          * <p>It is not a requirement to return an immutable (unmodifiable)
-         * <code>List</code>. However, the returned <code>List</code> must not
+         * {@code List}. However, the returned {@code List} must not
          * be mutated after it has been returned by
-         * <code>getCandidateLocales</code>.
+         * {@code getCandidateLocales}.
          *
-         * <p>The default implementation returns a <code>List</code> containing
-         * <code>Locale</code>s using the rules described below.  In the
+         * <p>The default implementation returns a {@code List} containing
+         * {@code Locale}s using the rules described below.  In the
          * description below, <em>L</em>, <em>S</em>, <em>C</em> and <em>V</em>
          * respectively represent non-empty language, script, country, and
          * variant.  For example, [<em>L</em>, <em>C</em>] represents a
-         * <code>Locale</code> that has non-empty values only for language and
+         * {@code Locale} that has non-empty values only for language and
          * country.  The form <em>L</em>("xx") represents the (non-empty)
-         * language value is "xx".  For all cases, <code>Locale</code>s whose
+         * language value is "xx".  For all cases, {@code Locale}s whose
          * final component values are empty strings are omitted.
          *
-         * <ol><li>For an input <code>Locale</code> with an empty script value,
-         * append candidate <code>Locale</code>s by omitting the final component
+         * <ol><li>For an input {@code Locale} with an empty script value,
+         * append candidate {@code Locale}s by omitting the final component
          * one by one as below:
          *
          * <ul>
          * <li> [<em>L</em>, <em>C</em>, <em>V</em>] </li>
          * <li> [<em>L</em>, <em>C</em>] </li>
          * <li> [<em>L</em>] </li>
-         * <li> <code>Locale.ROOT</code> </li>
+         * <li> {@code Locale.ROOT} </li>
          * </ul></li>
          *
-         * <li>For an input <code>Locale</code> with a non-empty script value,
-         * append candidate <code>Locale</code>s by omitting the final component
+         * <li>For an input {@code Locale} with a non-empty script value,
+         * append candidate {@code Locale}s by omitting the final component
          * up to language, then append candidates generated from the
-         * <code>Locale</code> with country and variant restored:
+         * {@code Locale} with country and variant restored:
          *
          * <ul>
          * <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V</em>]</li>
          * <li> [<em>L</em>, <em>S</em>, <em>C</em>]</li>
          * <li> [<em>L</em>, <em>S</em>]</li>
          * <li> [<em>L</em>, <em>C</em>, <em>V</em>]</li>
          * <li> [<em>L</em>, <em>C</em>]</li>
          * <li> [<em>L</em>]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul></li>
          *
-         * <li>For an input <code>Locale</code> with a variant value consisting
+         * <li>For an input {@code Locale} with a variant value consisting
          * of multiple subtags separated by underscore, generate candidate
-         * <code>Locale</code>s by omitting the variant subtags one by one, then
-         * insert them after every occurrence of <code> Locale</code>s with the
+         * {@code Locale}s by omitting the variant subtags one by one, then
+         * insert them after every occurrence of {@code  Locale}s with the
          * full variant value in the original list.  For example, if
          * the variant consists of two subtags <em>V1</em> and <em>V2</em>:
          *
          * <ul>
          * <li> [<em>L</em>, <em>S</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li>
@@ -2768,14 +2768,14 @@
          * <li> [<em>L</em>, <em>S</em>]</li>
          * <li> [<em>L</em>, <em>C</em>, <em>V1</em>, <em>V2</em>]</li>
          * <li> [<em>L</em>, <em>C</em>, <em>V1</em>]</li>
          * <li> [<em>L</em>, <em>C</em>]</li>
          * <li> [<em>L</em>]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul></li>
          *
-         * <li>Special cases for Chinese.  When an input <code>Locale</code> has the
+         * <li>Special cases for Chinese.  When an input {@code Locale} has the
          * language "zh" (Chinese) and an empty script value, either "Hans" (Simplified) or
          * "Hant" (Traditional) might be supplied, depending on the country.
          * When the country is "CN" (China) or "SG" (Singapore), "Hans" is supplied.
          * When the country is "HK" (Hong Kong SAR China), "MO" (Macau SAR China),
          * or "TW" (Taiwan), "Hant" is supplied.  For all other countries or when the country
@@ -2784,93 +2784,93 @@
          * <ul>
          * <li> [<em>L</em>("zh"), <em>S</em>("Hans"), <em>C</em>("CN")]</li>
          * <li> [<em>L</em>("zh"), <em>S</em>("Hans")]</li>
          * <li> [<em>L</em>("zh"), <em>C</em>("CN")]</li>
          * <li> [<em>L</em>("zh")]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul>
          *
-         * For <code>Locale("zh", "TW")</code>, the candidate list will be:
+         * For {@code Locale("zh", "TW")}, the candidate list will be:
          * <ul>
          * <li> [<em>L</em>("zh"), <em>S</em>("Hant"), <em>C</em>("TW")]</li>
          * <li> [<em>L</em>("zh"), <em>S</em>("Hant")]</li>
          * <li> [<em>L</em>("zh"), <em>C</em>("TW")]</li>
          * <li> [<em>L</em>("zh")]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul></li>
          *
-         * <li>Special cases for Norwegian.  Both <code>Locale("no", "NO",
-         * "NY")</code> and <code>Locale("nn", "NO")</code> represent Norwegian
+         * <li>Special cases for Norwegian.  Both {@code Locale("no", "NO",
+         * "NY")} and {@code Locale("nn", "NO")} represent Norwegian
          * Nynorsk.  When a locale's language is "nn", the standard candidate
          * list is generated up to [<em>L</em>("nn")], and then the following
          * candidates are added:
          *
          * <ul><li> [<em>L</em>("no"), <em>C</em>("NO"), <em>V</em>("NY")]</li>
          * <li> [<em>L</em>("no"), <em>C</em>("NO")]</li>
          * <li> [<em>L</em>("no")]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul>
          *
-         * If the locale is exactly <code>Locale("no", "NO", "NY")</code>, it is first
-         * converted to <code>Locale("nn", "NO")</code> and then the above procedure is
+         * If the locale is exactly {@code Locale("no", "NO", "NY")}, it is first
+         * converted to {@code Locale("nn", "NO")} and then the above procedure is
          * followed.
          *
          * <p>Also, Java treats the language "no" as a synonym of Norwegian
-         * Bokm&#xE5;l "nb".  Except for the single case <code>Locale("no",
-         * "NO", "NY")</code> (handled above), when an input <code>Locale</code>
-         * has language "no" or "nb", candidate <code>Locale</code>s with
+         * Bokm&#xE5;l "nb".  Except for the single case {@code Locale("no",
+         * "NO", "NY")} (handled above), when an input {@code Locale}
+         * has language "no" or "nb", candidate {@code Locale}s with
          * language code "no" and "nb" are interleaved, first using the
          * requested language, then using its synonym. For example,
-         * <code>Locale("nb", "NO", "POSIX")</code> generates the following
+         * {@code Locale("nb", "NO", "POSIX")} generates the following
          * candidate list:
          *
          * <ul>
          * <li> [<em>L</em>("nb"), <em>C</em>("NO"), <em>V</em>("POSIX")]</li>
          * <li> [<em>L</em>("no"), <em>C</em>("NO"), <em>V</em>("POSIX")]</li>
          * <li> [<em>L</em>("nb"), <em>C</em>("NO")]</li>
          * <li> [<em>L</em>("no"), <em>C</em>("NO")]</li>
          * <li> [<em>L</em>("nb")]</li>
          * <li> [<em>L</em>("no")]</li>
-         * <li> <code>Locale.ROOT</code></li>
+         * <li> {@code Locale.ROOT}</li>
          * </ul>
          *
-         * <code>Locale("no", "NO", "POSIX")</code> would generate the same list
+         * {@code Locale("no", "NO", "POSIX")} would generate the same list
          * except that locales with "no" would appear before the corresponding
          * locales with "nb".</li>
          * </ol>
          *
          * <p>The default implementation uses an {@link ArrayList} that
          * overriding implementations may modify before returning it to the
          * caller. However, a subclass must not modify it after it has
-         * been returned by <code>getCandidateLocales</code>.
+         * been returned by {@code getCandidateLocales}.
          *
-         * <p>For example, if the given <code>baseName</code> is "Messages"
-         * and the given <code>locale</code> is
+         * <p>For example, if the given {@code baseName} is "Messages"
+         * and the given {@code locale} is
          * <code>Locale("ja",&nbsp;"",&nbsp;"XX")</code>, then a
-         * <code>List</code> of <code>Locale</code>s:
+         * {@code List} of {@code Locale}s:
          * <pre>
          *     Locale("ja", "", "XX")
          *     Locale("ja")
          *     Locale.ROOT
          * </pre>
          * is returned. And if the resource bundles for the "ja" and
-         * "" <code>Locale</code>s are found, then the runtime resource
+         * "" {@code Locale}s are found, then the runtime resource
          * lookup path (parent chain) is:
          * <pre>{@code
          *     Messages_ja -> Messages
          * }</pre>
          *
          * @param baseName
          *        the base name of the resource bundle, a fully
          *        qualified class name
          * @param locale
          *        the locale for which a resource bundle is desired
-         * @return a <code>List</code> of candidate
-         *        <code>Locale</code>s for the given <code>locale</code>
-         * @exception NullPointerException
-         *        if <code>baseName</code> or <code>locale</code> is
-         *        <code>null</code>
+         * @return a {@code List} of candidate
+         *        {@code Locale}s for the given {@code locale}
+         * @throws    NullPointerException
+         *        if {@code baseName} or {@code locale} is
+         *        {@code null}
          */
         public List<Locale> getCandidateLocales(String baseName, Locale locale) {
             if (baseName == null) {
                 throw new NullPointerException();
             }
@@ -3001,44 +3001,44 @@
                 return list;
             }
         }
 
         /**
-         * Returns a <code>Locale</code> to be used as a fallback locale for
+         * Returns a {@code Locale} to be used as a fallback locale for
          * further resource bundle searches by the
-         * <code>ResourceBundle.getBundle</code> factory method. This method
+         * {@code ResourceBundle.getBundle} factory method. This method
          * is called from the factory method every time when no resulting
-         * resource bundle has been found for <code>baseName</code> and
-         * <code>locale</code>, where locale is either the parameter for
-         * <code>ResourceBundle.getBundle</code> or the previous fallback
+         * resource bundle has been found for {@code baseName} and
+         * {@code locale}, where locale is either the parameter for
+         * {@code ResourceBundle.getBundle} or the previous fallback
          * locale returned by this method.
          *
-         * <p>The method returns <code>null</code> if no further fallback
+         * <p>The method returns {@code null} if no further fallback
          * search is desired.
          *
          * <p>The default implementation returns the {@linkplain
-         * Locale#getDefault() default <code>Locale</code>} if the given
-         * <code>locale</code> isn't the default one.  Otherwise,
-         * <code>null</code> is returned.
+         * Locale#getDefault() default {@code Locale}} if the given
+         * {@code locale} isn't the default one.  Otherwise,
+         * {@code null} is returned.
          *
          * @param baseName
          *        the base name of the resource bundle, a fully
          *        qualified class name for which
-         *        <code>ResourceBundle.getBundle</code> has been
+         *        {@code ResourceBundle.getBundle} has been
          *        unable to find any resource bundles (except for the
          *        base bundle)
          * @param locale
-         *        the <code>Locale</code> for which
-         *        <code>ResourceBundle.getBundle</code> has been
+         *        the {@code Locale} for which
+         *        {@code ResourceBundle.getBundle} has been
          *        unable to find any resource bundles (except for the
          *        base bundle)
-         * @return a <code>Locale</code> for the fallback search,
-         *        or <code>null</code> if no further fallback search
+         * @return a {@code Locale} for the fallback search,
+         *        or {@code null} if no further fallback search
          *        is desired.
-         * @exception NullPointerException
-         *        if <code>baseName</code> or <code>locale</code>
-         *        is <code>null</code>
+         * @throws    NullPointerException
+         *        if {@code baseName} or {@code locale}
+         *        is {@code null}
          */
         public Locale getFallbackLocale(String baseName, Locale locale) {
             if (baseName == null) {
                 throw new NullPointerException();
             }
@@ -3047,18 +3047,18 @@
         }
 
         /**
          * Instantiates a resource bundle for the given bundle name of the
          * given format and locale, using the given class loader if
-         * necessary. This method returns <code>null</code> if there is no
+         * necessary. This method returns {@code null} if there is no
          * resource bundle available for the given parameters. If a resource
          * bundle can't be instantiated due to an unexpected error, the
-         * error must be reported by throwing an <code>Error</code> or
-         * <code>Exception</code> rather than simply returning
-         * <code>null</code>.
+         * error must be reported by throwing an {@code Error} or
+         * {@code Exception} rather than simply returning
+         * {@code null}.
          *
-         * <p>If the <code>reload</code> flag is <code>true</code>, it
+         * <p>If the {@code reload} flag is {@code true}, it
          * indicates that this method is being called because the previously
          * loaded resource bundle has expired.
          *
          * @implSpec
          *
@@ -3067,49 +3067,49 @@
          * A resource bundle in a named module visible to the given class loader
          * is accessible when the package of the resource file corresponding
          * to the resource bundle is open unconditionally.
          *
          * <p>The default implementation instantiates a
-         * <code>ResourceBundle</code> as follows.
+         * {@code ResourceBundle} as follows.
          *
          * <ul>
          *
          * <li>The bundle name is obtained by calling {@link
          * #toBundleName(String, Locale) toBundleName(baseName,
          * locale)}.</li>
          *
-         * <li>If <code>format</code> is <code>"java.class"</code>, the
+         * <li>If {@code format} is {@code "java.class"}, the
          * {@link Class} specified by the bundle name is loaded with the
          * given class loader. If the {@code Class} is found and accessible
-         * then the <code>ResourceBundle</code> is instantiated.  The
+         * then the {@code ResourceBundle} is instantiated.  The
          * resource bundle is accessible if the package of the bundle class file
          * is open unconditionally; otherwise, {@code IllegalAccessException}
          * will be thrown.
-         * Note that the <code>reload</code> flag is ignored for loading
+         * Note that the {@code reload} flag is ignored for loading
          * class-based resource bundles in this default implementation.
          * </li>
          *
-         * <li>If <code>format</code> is <code>"java.properties"</code>,
+         * <li>If {@code format} is {@code "java.properties"},
          * {@link #toResourceName(String, String) toResourceName(bundlename,
          * "properties")} is called to get the resource name.
-         * If <code>reload</code> is <code>true</code>, {@link
+         * If {@code reload} is {@code true}, {@link
          * ClassLoader#getResource(String) load.getResource} is called
          * to get a {@link URL} for creating a {@link
-         * URLConnection}. This <code>URLConnection</code> is used to
+         * URLConnection}. This {@code URLConnection} is used to
          * {@linkplain URLConnection#setUseCaches(boolean) disable the
          * caches} of the underlying resource loading layers,
          * and to {@linkplain URLConnection#getInputStream() get an
-         * <code>InputStream</code>}.
+         * {@code InputStream}}.
          * Otherwise, {@link ClassLoader#getResourceAsStream(String)
          * loader.getResourceAsStream} is called to get an {@link
          * InputStream}. Then, a {@link
          * PropertyResourceBundle} is constructed with the
-         * <code>InputStream</code>.</li>
+         * {@code InputStream}.</li>
          *
-         * <li>If <code>format</code> is neither <code>"java.class"</code>
-         * nor <code>"java.properties"</code>, an
-         * <code>IllegalArgumentException</code> is thrown.</li>
+         * <li>If {@code format} is neither {@code "java.class"}
+         * nor {@code "java.properties"}, an
+         * {@code IllegalArgumentException} is thrown.</li>
          *
          * </ul>
          *
          * @param baseName
          *        the base bundle name of the resource bundle, a fully
@@ -3118,40 +3118,40 @@
          *        the locale for which the resource bundle should be
          *        instantiated
          * @param format
          *        the resource bundle format to be loaded
          * @param loader
-         *        the <code>ClassLoader</code> to use to load the bundle
+         *        the {@code ClassLoader} to use to load the bundle
          * @param reload
-         *        the flag to indicate bundle reloading; <code>true</code>
+         *        the flag to indicate bundle reloading; {@code true}
          *        if reloading an expired resource bundle,
-         *        <code>false</code> otherwise
+         *        {@code false} otherwise
          * @return the resource bundle instance,
-         *        or <code>null</code> if none could be found.
-         * @exception NullPointerException
-         *        if <code>bundleName</code>, <code>locale</code>,
-         *        <code>format</code>, or <code>loader</code> is
-         *        <code>null</code>, or if <code>null</code> is returned by
+         *        or {@code null} if none could be found.
+         * @throws    NullPointerException
+         *        if {@code bundleName}, {@code locale},
+         *        {@code format}, or {@code loader} is
+         *        {@code null}, or if {@code null} is returned by
          *        {@link #toBundleName(String, Locale) toBundleName}
-         * @exception IllegalArgumentException
-         *        if <code>format</code> is unknown, or if the resource
+         * @throws    IllegalArgumentException
+         *        if {@code format} is unknown, or if the resource
          *        found for the given parameters contains malformed data.
-         * @exception ClassCastException
-         *        if the loaded class cannot be cast to <code>ResourceBundle</code>
-         * @exception IllegalAccessException
+         * @throws    ClassCastException
+         *        if the loaded class cannot be cast to {@code ResourceBundle}
+         * @throws    IllegalAccessException
          *        if the class or its nullary constructor is not
          *        accessible.
-         * @exception InstantiationException
+         * @throws    InstantiationException
          *        if the instantiation of a class fails for some other
          *        reason.
-         * @exception ExceptionInInitializerError
+         * @throws    ExceptionInInitializerError
          *        if the initialization provoked by this method fails.
-         * @exception SecurityException
+         * @throws    SecurityException
          *        If a security manager is present and creation of new
          *        instances is denied. See {@link Class#newInstance()}
          *        for details.
-         * @exception IOException
+         * @throws    IOException
          *        if an error occurred when reading resources using
          *        any I/O operations
          * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
          * @revised 9
          * @spec JPMS
@@ -3254,28 +3254,28 @@
         }
 
         /**
          * Returns the time-to-live (TTL) value for resource bundles that
          * are loaded under this
-         * <code>ResourceBundle.Control</code>. Positive time-to-live values
+         * {@code ResourceBundle.Control}. Positive time-to-live values
          * specify the number of milliseconds a bundle can remain in the
          * cache without being validated against the source data from which
          * it was constructed. The value 0 indicates that a bundle must be
          * validated each time it is retrieved from the cache. {@link
          * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
          * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
          * that loaded resource bundles are put in the cache with no
          * expiration control.
          *
          * <p>The expiration affects only the bundle loading process by the
-         * <code>ResourceBundle.getBundle</code> factory method.  That is,
+         * {@code ResourceBundle.getBundle} factory method.  That is,
          * if the factory method finds a resource bundle in the cache that
          * has expired, the factory method calls the {@link
          * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
          * long) needsReload} method to determine whether the resource
-         * bundle needs to be reloaded. If <code>needsReload</code> returns
-         * <code>true</code>, the cached resource bundle instance is removed
+         * bundle needs to be reloaded. If {@code needsReload} returns
+         * {@code true}, the cached resource bundle instance is removed
          * from the cache. Otherwise, the instance stays in the cache,
          * updated with the new TTL value returned by this method.
          *
          * <p>All cached resource bundles are subject to removal from the
          * cache due to memory constraints of the runtime environment.
@@ -3293,69 +3293,69 @@
          * @return the time (0 or a positive millisecond offset from the
          *        cached time) to get loaded bundles expired in the cache,
          *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
          *        expiration control, or {@link #TTL_DONT_CACHE} to disable
          *        caching.
-         * @exception NullPointerException
-         *        if <code>baseName</code> or <code>locale</code> is
-         *        <code>null</code>
+         * @throws    NullPointerException
+         *        if {@code baseName} or {@code locale} is
+         *        {@code null}
          */
         public long getTimeToLive(String baseName, Locale locale) {
             if (baseName == null || locale == null) {
                 throw new NullPointerException();
             }
             return TTL_NO_EXPIRATION_CONTROL;
         }
 
         /**
-         * Determines if the expired <code>bundle</code> in the cache needs
+         * Determines if the expired {@code bundle} in the cache needs
          * to be reloaded based on the loading time given by
-         * <code>loadTime</code> or some other criteria. The method returns
-         * <code>true</code> if reloading is required; <code>false</code>
-         * otherwise. <code>loadTime</code> is a millisecond offset since
-         * the <a href="Calendar.html#Epoch"> <code>Calendar</code>
+         * {@code loadTime} or some other criteria. The method returns
+         * {@code true} if reloading is required; {@code false}
+         * otherwise. {@code loadTime} is a millisecond offset since
+         * the <a href="Calendar.html#Epoch"> {@code Calendar}
          * Epoch</a>.
          *
          * <p>
-         * The calling <code>ResourceBundle.getBundle</code> factory method
-         * calls this method on the <code>ResourceBundle.Control</code>
+         * The calling {@code ResourceBundle.getBundle} factory method
+         * calls this method on the {@code ResourceBundle.Control}
          * instance used for its current invocation, not on the instance
          * used in the invocation that originally loaded the resource
          * bundle.
          *
-         * <p>The default implementation compares <code>loadTime</code> and
+         * <p>The default implementation compares {@code loadTime} and
          * the last modified time of the source data of the resource
          * bundle. If it's determined that the source data has been modified
-         * since <code>loadTime</code>, <code>true</code> is
-         * returned. Otherwise, <code>false</code> is returned. This
-         * implementation assumes that the given <code>format</code> is the
+         * since {@code loadTime}, {@code true} is
+         * returned. Otherwise, {@code false} is returned. This
+         * implementation assumes that the given {@code format} is the
          * same string as its file suffix if it's not one of the default
-         * formats, <code>"java.class"</code> or
-         * <code>"java.properties"</code>.
+         * formats, {@code "java.class"} or
+         * {@code "java.properties"}.
          *
          * @param baseName
          *        the base bundle name of the resource bundle, a
          *        fully qualified class name
          * @param locale
          *        the locale for which the resource bundle
          *        should be instantiated
          * @param format
          *        the resource bundle format to be loaded
          * @param loader
-         *        the <code>ClassLoader</code> to use to load the bundle
+         *        the {@code ClassLoader} to use to load the bundle
          * @param bundle
          *        the resource bundle instance that has been expired
          *        in the cache
          * @param loadTime
-         *        the time when <code>bundle</code> was loaded and put
+         *        the time when {@code bundle} was loaded and put
          *        in the cache
-         * @return <code>true</code> if the expired bundle needs to be
-         *        reloaded; <code>false</code> otherwise.
-         * @exception NullPointerException
-         *        if <code>baseName</code>, <code>locale</code>,
-         *        <code>format</code>, <code>loader</code>, or
-         *        <code>bundle</code> is <code>null</code>
+         * @return {@code true} if the expired bundle needs to be
+         *        reloaded; {@code false} otherwise.
+         * @throws    NullPointerException
+         *        if {@code baseName}, {@code locale},
+         *        {@code format}, {@code loader}, or
+         *        {@code bundle} is {@code null}
          */
         public boolean needsReload(String baseName, Locale locale,
                                    String format, ClassLoader loader,
                                    ResourceBundle bundle, long loadTime) {
             if (bundle == null) {
@@ -3398,35 +3398,35 @@
             }
             return result;
         }
 
         /**
-         * Converts the given <code>baseName</code> and <code>locale</code>
+         * Converts the given {@code baseName} and {@code locale}
          * to the bundle name. This method is called from the default
          * implementation of the {@link #newBundle(String, Locale, String,
          * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
          * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
          * methods.
          *
          * <p>This implementation returns the following value:
          * <pre>
          *     baseName + "_" + language + "_" + script + "_" + country + "_" + variant
          * </pre>
-         * where <code>language</code>, <code>script</code>, <code>country</code>,
-         * and <code>variant</code> are the language, script, country, and variant
-         * values of <code>locale</code>, respectively. Final component values that
+         * where {@code language}, {@code script}, {@code country},
+         * and {@code variant} are the language, script, country, and variant
+         * values of {@code locale}, respectively. Final component values that
          * are empty Strings are omitted along with the preceding '_'.  When the
          * script is empty, the script value is omitted along with the preceding '_'.
-         * If all of the values are empty strings, then <code>baseName</code>
+         * If all of the values are empty strings, then {@code baseName}
          * is returned.
          *
-         * <p>For example, if <code>baseName</code> is
-         * <code>"baseName"</code> and <code>locale</code> is
+         * <p>For example, if {@code baseName} is
+         * {@code "baseName"} and {@code locale} is
          * <code>Locale("ja",&nbsp;"",&nbsp;"XX")</code>, then
          * <code>"baseName_ja_&thinsp;_XX"</code> is returned. If the given
-         * locale is <code>Locale("en")</code>, then
-         * <code>"baseName_en"</code> is returned.
+         * locale is {@code Locale("en")}, then
+         * {@code "baseName_en"} is returned.
          *
          * <p>Overriding this method allows applications to use different
          * conventions in the organization and packaging of localized
          * resources.
          *
@@ -3435,13 +3435,13 @@
          *        qualified class name
          * @param locale
          *        the locale for which a resource bundle should be
          *        loaded
          * @return the bundle name for the resource bundle
-         * @exception NullPointerException
-         *        if <code>baseName</code> or <code>locale</code>
-         *        is <code>null</code>
+         * @throws    NullPointerException
+         *        if {@code baseName} or {@code locale}
+         *        is {@code null}
          * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
          */
         public String toBundleName(String baseName, Locale locale) {
             if (locale == Locale.ROOT) {
                 return baseName;
@@ -3493,11 +3493,11 @@
          * @param bundleName
          *        the bundle name
          * @param suffix
          *        the file type suffix
          * @return the converted resource name
-         * @exception NullPointerException
+         * @throws    NullPointerException
          *         if {@code bundleName} or {@code suffix}
          *         is {@code null}
          */
         public final String toResourceName(String bundleName, String suffix) {
             StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/Locale.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ListResourceBundle.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LongSummaryStatistics.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Locale.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,13 ***</span>
  import sun.util.locale.provider.LocaleResources;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  import sun.util.locale.provider.TimeZoneNameUtility;
  
  /**
<span class="line-modified">!  * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,</span>
<span class="line-modified">!  * or cultural region. An operation that requires a &lt;code&gt;Locale&lt;/code&gt; to perform</span>
<span class="line-modified">!  * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the &lt;code&gt;Locale&lt;/code&gt;</span>
   * to tailor information for the user. For example, displaying a number
   * is a locale-sensitive operation&amp;mdash; the number should be formatted
   * according to the customs and conventions of the user&#39;s native country,
   * region, or culture.
   *
<span class="line-new-header">--- 64,13 ---</span>
  import sun.util.locale.provider.LocaleResources;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  import sun.util.locale.provider.TimeZoneNameUtility;
  
  /**
<span class="line-modified">!  * A {@code Locale} object represents a specific geographical, political,</span>
<span class="line-modified">!  * or cultural region. An operation that requires a {@code Locale} to perform</span>
<span class="line-modified">!  * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the {@code Locale}</span>
   * to tailor information for the user. For example, displaying a number
   * is a locale-sensitive operation&amp;mdash; the number should be formatted
   * according to the customs and conventions of the user&#39;s native country,
   * region, or culture.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,11 ***</span>
   * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
   * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
   * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
   * exchange.
   *
<span class="line-modified">!  * &lt;p&gt; A &lt;code&gt;Locale&lt;/code&gt; object logically consists of the fields</span>
   * described below.
   *
   * &lt;dl&gt;
   *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
<span class="line-new-header">--- 79,11 ---</span>
   * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
   * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
   * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
   * exchange.
   *
<span class="line-modified">!  * &lt;p&gt; A {@code Locale} object logically consists of the fields</span>
   * described below.
   *
   * &lt;dl&gt;
   *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,11 ***</span>
   *   language subtags up to 8 alpha letters (for future enhancements).
   *   When a language has both an alpha-2 code and an alpha-3 code, the
   *   alpha-2 code must be used.  You can find a full list of valid
   *   language codes in the IANA Language Subtag Registry (search for
   *   &quot;Type: language&quot;).  The language field is case insensitive, but
<span class="line-modified">!  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to lower case.&lt;/dd&gt;</span>
   *
   *   &lt;dd&gt;Well-formed language values have the form
   *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
   *   BCP47 language production, since it excludes extlang.  They are
   *   not needed since modern three-letter language codes replace
<span class="line-new-header">--- 91,11 ---</span>
   *   language subtags up to 8 alpha letters (for future enhancements).
   *   When a language has both an alpha-2 code and an alpha-3 code, the
   *   alpha-2 code must be used.  You can find a full list of valid
   *   language codes in the IANA Language Subtag Registry (search for
   *   &quot;Type: language&quot;).  The language field is case insensitive, but
<span class="line-modified">!  *   {@code Locale} always canonicalizes to lower case.&lt;/dd&gt;</span>
   *
   *   &lt;dd&gt;Well-formed language values have the form
   *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
   *   BCP47 language production, since it excludes extlang.  They are
   *   not needed since modern three-letter language codes replace
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,11 ***</span>
   *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
   *   valid script codes in the IANA Language Subtag Registry (search
   *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<span class="line-modified">!  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to title case (the first</span>
   *   letter is upper case and the rest of the letters are lower
   *   case).&lt;/dd&gt;
   *
   *   &lt;dd&gt;Well-formed script values have the form
   *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
<span class="line-new-header">--- 106,11 ---</span>
   *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
   *   valid script codes in the IANA Language Subtag Registry (search
   *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<span class="line-modified">!  *   {@code Locale} always canonicalizes to title case (the first</span>
   *   letter is upper case and the rest of the letters are lower
   *   case).&lt;/dd&gt;
   *
   *   &lt;dd&gt;Well-formed script values have the form
   *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,22 ***</span>
   *
   *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
   *   You can find a full list of valid country and region codes in the
   *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
   *   country (region) field is case insensitive, but
<span class="line-modified">!  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to upper case.&lt;/dd&gt;</span>
   *
   *   &lt;dd&gt;Well-formed country/region values have
   *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
   *
   *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
   *   (Caribbean)&lt;/dd&gt;
   *
   *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<span class="line-modified">!  *   &lt;code&gt;Locale&lt;/code&gt;.  Where there are two or more variant values</span>
   *   each indicating its own semantics, these values should be ordered
   *   by importance, with most important first, separated by
   *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
   *
   *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
<span class="line-new-header">--- 121,22 ---</span>
   *
   *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
   *   You can find a full list of valid country and region codes in the
   *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
   *   country (region) field is case insensitive, but
<span class="line-modified">!  *   {@code Locale} always canonicalizes to upper case.&lt;/dd&gt;</span>
   *
   *   &lt;dd&gt;Well-formed country/region values have
   *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
   *
   *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
   *   (Caribbean)&lt;/dd&gt;
   *
   *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<span class="line-modified">!  *   {@code Locale}.  Where there are two or more variant values</span>
   *   each indicating its own semantics, these values should be ordered
   *   by importance, with most important first, separated by
   *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
   *
   *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,11 ***</span>
   *   additional variations that define a language or its dialects that
   *   are not covered by any combinations of language, script and
   *   region subtags.  You can find a full list of valid variant codes
   *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
   *
<span class="line-modified">!  *   &lt;p&gt;However, the variant field in &lt;code&gt;Locale&lt;/code&gt; has</span>
   *   historically been used for any kind of variation, not just
   *   language variations.  For example, some supported variants
   *   available in Java SE Runtime Environments indicate alternative
   *   cultural behaviors such as calendar type or number script.  In
   *   BCP 47 this kind of information, which does not identify the
<span class="line-new-header">--- 144,11 ---</span>
   *   additional variations that define a language or its dialects that
   *   are not covered by any combinations of language, script and
   *   region subtags.  You can find a full list of valid variant codes
   *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
   *
<span class="line-modified">!  *   &lt;p&gt;However, the variant field in {@code Locale} has</span>
   *   historically been used for any kind of variation, not just
   *   language variations.  For example, some supported variants
   *   available in Java SE Runtime Environments indicate alternative
   *   cultural behaviors such as calendar type or number script.  In
   *   BCP 47 this kind of information, which does not identify the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,35 ***</span>
   *
   *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;A map from single character keys to string values, indicating
   *   extensions apart from language identification.  The extensions in
<span class="line-modified">!  *   &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47</span>
   *   extension subtags and private use subtags. The extensions are
<span class="line-modified">!  *   case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all</span>
   *   extension keys and values to lower case. Note that extensions
   *   cannot have empty values.&lt;/dd&gt;
   *
   *   &lt;dd&gt;Well-formed keys are single characters from the set
<span class="line-modified">!  *   &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;.  Well-formed values have the form</span>
<span class="line-modified">!  *   &lt;code&gt;SUBTAG (&#39;-&#39; SUBTAG)*&lt;/code&gt; where for the key &#39;x&#39;</span>
   *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
   *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
   *   single-character subtags).&lt;/dd&gt;
   *
   *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
   *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
   * &lt;/dl&gt;
   *
   * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<span class="line-modified">!  * in the IANA Language Subtag Registry, the &lt;code&gt;Locale&lt;/code&gt; class</span>
<span class="line-modified">!  * does not provide any validation features.  The &lt;code&gt;Builder&lt;/code&gt;</span>
   * only checks if an individual field satisfies the syntactic
   * requirement (is well-formed), but does not validate the value
   * itself.  See {@link Builder} for details.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
   * attributes and keywords to override or refine the default behavior
   * associated with a locale.  A keyword is represented by a pair of
   * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
<span class="line-new-header">--- 164,35 ---</span>
   *
   *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
   *
   *   &lt;dd&gt;A map from single character keys to string values, indicating
   *   extensions apart from language identification.  The extensions in
<span class="line-modified">!  *   {@code Locale} implement the semantics and syntax of BCP 47</span>
   *   extension subtags and private use subtags. The extensions are
<span class="line-modified">!  *   case insensitive, but {@code Locale} canonicalizes all</span>
   *   extension keys and values to lower case. Note that extensions
   *   cannot have empty values.&lt;/dd&gt;
   *
   *   &lt;dd&gt;Well-formed keys are single characters from the set
<span class="line-modified">!  *   {@code [0-9a-zA-Z]}.  Well-formed values have the form</span>
<span class="line-modified">!  *   {@code SUBTAG (&#39;-&#39; SUBTAG)*} where for the key &#39;x&#39;</span>
   *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
   *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
   *   single-character subtags).&lt;/dd&gt;
   *
   *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
   *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
   * &lt;/dl&gt;
   *
   * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<span class="line-modified">!  * in the IANA Language Subtag Registry, the {@code Locale} class</span>
<span class="line-modified">!  * does not provide any validation features.  The {@code Builder}</span>
   * only checks if an individual field satisfies the syntactic
   * requirement (is well-formed), but does not validate the value
   * itself.  See {@link Builder} for details.
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
   * attributes and keywords to override or refine the default behavior
   * associated with a locale.  A keyword is represented by a pair of
   * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,15 ***</span>
   *
   * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
   * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
   * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
   *
<span class="line-modified">!  * &lt;p&gt;Thus, when a &lt;code&gt;Locale&lt;/code&gt; object contains Unicode locale</span>
   * attributes and keywords,
<span class="line-modified">!  * &lt;code&gt;getExtension(UNICODE_LOCALE_EXTENSION)&lt;/code&gt; will return a</span>
   * String representing this information, for example, &quot;nu-thai&quot;.  The
<span class="line-modified">!  * &lt;code&gt;Locale&lt;/code&gt; class also provides {@link</span>
   * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
   * {@link #getUnicodeLocaleType} which allow you to access Unicode
   * locale attributes and key/type pairs directly.  When represented as
   * a string, the Unicode Locale Extension lists attributes
   * alphabetically, followed by key/type sequences with keys listed
<span class="line-new-header">--- 201,15 ---</span>
   *
   * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
   * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
   * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
   *
<span class="line-modified">!  * &lt;p&gt;Thus, when a {@code Locale} object contains Unicode locale</span>
   * attributes and keywords,
<span class="line-modified">!  * {@code getExtension(UNICODE_LOCALE_EXTENSION)} will return a</span>
   * String representing this information, for example, &quot;nu-thai&quot;.  The
<span class="line-modified">!  * {@code Locale} class also provides {@link</span>
   * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
   * {@link #getUnicodeLocaleType} which allow you to access Unicode
   * locale attributes and key/type pairs directly.  When represented as
   * a string, the Unicode Locale Extension lists attributes
   * alphabetically, followed by key/type sequences with keys listed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,52 ***</span>
   * locale-sensitive services.  Although the LDML specification defines
   * various keys and values, actual locale-sensitive service
   * implementations in a Java Runtime Environment might not support any
   * particular Unicode locale attributes or key/type pairs.
   *
<span class="line-modified">!  * &lt;h4&gt;Creating a Locale&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt;</span>
   * object.
   *
<span class="line-modified">!  * &lt;h5&gt;Builder&lt;/h5&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Using {@link Builder} you can construct a &lt;code&gt;Locale&lt;/code&gt; object</span>
   * that conforms to BCP 47 syntax.
   *
<span class="line-modified">!  * &lt;h5&gt;Constructors&lt;/h5&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides three constructors:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     {@link #Locale(String language)}
   *     {@link #Locale(String language, String country)}
   *     {@link #Locale(String language, String country, String variant)}
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
   * with language, country and variant, but you cannot specify
   * script or extensions.
   *
<span class="line-modified">!  * &lt;h5&gt;Factory Methods&lt;/h5&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The method {@link #forLanguageTag} creates a &lt;code&gt;Locale&lt;/code&gt;</span>
   * object for a well-formed BCP 47 language tag.
   *
<span class="line-modified">!  * &lt;h5&gt;Locale Constants&lt;/h5&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides a number of convenient constants</span>
<span class="line-modified">!  * that you can use to create &lt;code&gt;Locale&lt;/code&gt; objects for commonly used</span>
<span class="line-modified">!  * locales. For example, the following creates a &lt;code&gt;Locale&lt;/code&gt; object</span>
   * for the United States:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     Locale.US
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * &lt;p&gt;If an application or a system is internationalized and provides localized
   * resources for multiple locales, it sometimes needs to find one or more
   * locales (or language tags) which meet each user&#39;s specific preferences. Note
   * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
<span class="line-new-header">--- 228,52 ---</span>
   * locale-sensitive services.  Although the LDML specification defines
   * various keys and values, actual locale-sensitive service
   * implementations in a Java Runtime Environment might not support any
   * particular Unicode locale attributes or key/type pairs.
   *
<span class="line-modified">!  * &lt;h3&gt;Creating a Locale&lt;/h3&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;There are several different ways to create a {@code Locale}</span>
   * object.
   *
<span class="line-modified">!  * &lt;h4&gt;Builder&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Using {@link Builder} you can construct a {@code Locale} object</span>
   * that conforms to BCP 47 syntax.
   *
<span class="line-modified">!  * &lt;h4&gt;Constructors&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The {@code Locale} class provides three constructors:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     {@link #Locale(String language)}
   *     {@link #Locale(String language, String country)}
   *     {@link #Locale(String language, String country, String variant)}
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * These constructors allow you to create a {@code Locale} object</span>
   * with language, country and variant, but you cannot specify
   * script or extensions.
   *
<span class="line-modified">!  * &lt;h4&gt;Factory Methods&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The method {@link #forLanguageTag} creates a {@code Locale}</span>
   * object for a well-formed BCP 47 language tag.
   *
<span class="line-modified">!  * &lt;h4&gt;Locale Constants&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;The {@code Locale} class provides a number of convenient constants</span>
<span class="line-modified">!  * that you can use to create {@code Locale} objects for commonly used</span>
<span class="line-modified">!  * locales. For example, the following creates a {@code Locale} object</span>
   * for the United States:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     Locale.US
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;If an application or a system is internationalized and provides localized
   * resources for multiple locales, it sometimes needs to find one or more
   * locales (or language tags) which meet each user&#39;s specific preferences. Note
   * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,11 ***</span>
   * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
   * expressed as a list of language ranges. There are syntactically two types of
   * language ranges: basic and extended. See
   * {@link Locale.LanguageRange Locale.LanguageRange} for details.
   *
<span class="line-modified">!  * &lt;h5&gt;Filtering&lt;/h5&gt;</span>
   *
   * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
   * in RFC 4647 as follows:
   * &quot;In filtering, each language range represents the least specific language
   * tag (that is, the language tag with fewest number of subtags) that is an
<span class="line-new-header">--- 290,11 ---</span>
   * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
   * expressed as a list of language ranges. There are syntactically two types of
   * language ranges: basic and extended. See
   * {@link Locale.LanguageRange Locale.LanguageRange} for details.
   *
<span class="line-modified">!  * &lt;h4&gt;Filtering&lt;/h4&gt;</span>
   *
   * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
   * in RFC 4647 as follows:
   * &quot;In filtering, each language range represents the least specific language
   * tag (that is, the language tag with fewest number of subtags) that is an
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,11 ***</span>
   * (called &quot;extended filtering&quot;). They may return different results by what
   * kind of language ranges are included in the given Language Priority List.
   * {@link Locale.FilteringMode} is a parameter to specify how filtering should
   * be done.
   *
<span class="line-modified">!  * &lt;h5&gt;Lookup&lt;/h5&gt;</span>
   *
   * &lt;p&gt;The lookup operation returns the best matching language tags. It is
   * defined in RFC 4647 as follows:
   * &quot;By contrast with filtering, each language range represents the most
   * specific tag that is an acceptable match.  The first matching tag found,
<span class="line-new-header">--- 308,11 ---</span>
   * (called &quot;extended filtering&quot;). They may return different results by what
   * kind of language ranges are included in the given Language Priority List.
   * {@link Locale.FilteringMode} is a parameter to specify how filtering should
   * be done.
   *
<span class="line-modified">!  * &lt;h4&gt;Lookup&lt;/h4&gt;</span>
   *
   * &lt;p&gt;The lookup operation returns the best matching language tags. It is
   * defined in RFC 4647 as follows:
   * &quot;By contrast with filtering, each language range represents the most
   * specific tag that is an acceptable match.  The first matching tag found,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,31 ***</span>
   * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
   * included in a language range, the first matching language tag returned by
   * an {@link Iterator} over a {@link Collection} of language tags is treated as
   * the best matching one.
   *
<span class="line-modified">!  * &lt;h4&gt;Use of Locale&lt;/h4&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Once you&#39;ve created a &lt;code&gt;Locale&lt;/code&gt; you can query it for information</span>
<span class="line-modified">!  * about itself. Use &lt;code&gt;getCountry&lt;/code&gt; to get the country (or region)</span>
<span class="line-modified">!  * code and &lt;code&gt;getLanguage&lt;/code&gt; to get the language code.</span>
<span class="line-modified">!  * You can use &lt;code&gt;getDisplayCountry&lt;/code&gt; to get the</span>
   * name of the country suitable for displaying to the user. Similarly,
<span class="line-modified">!  * you can use &lt;code&gt;getDisplayLanguage&lt;/code&gt; to get the name of</span>
   * the language suitable for displaying to the user. Interestingly,
<span class="line-modified">!  * the &lt;code&gt;getDisplayXXX&lt;/code&gt; methods are themselves locale-sensitive</span>
   * and have two versions: one that uses the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale and one
   * that uses the locale specified as an argument.
   *
   * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<span class="line-modified">!  * operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats</span>
   * numbers, currency, and percentages in a locale-sensitive manner. Classes
<span class="line-modified">!  * such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods</span>
   * for creating a default object of that type. For example, the
<span class="line-modified">!  * &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods</span>
<span class="line-modified">!  * for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     NumberFormat.getInstance()
   *     NumberFormat.getCurrencyInstance()
   *     NumberFormat.getPercentInstance()
<span class="line-new-header">--- 340,31 ---</span>
   * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
   * included in a language range, the first matching language tag returned by
   * an {@link Iterator} over a {@link Collection} of language tags is treated as
   * the best matching one.
   *
<span class="line-modified">!  * &lt;h3&gt;Use of Locale&lt;/h3&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt;Once you&#39;ve created a {@code Locale} you can query it for information</span>
<span class="line-modified">!  * about itself. Use {@code getCountry} to get the country (or region)</span>
<span class="line-modified">!  * code and {@code getLanguage} to get the language code.</span>
<span class="line-modified">!  * You can use {@code getDisplayCountry} to get the</span>
   * name of the country suitable for displaying to the user. Similarly,
<span class="line-modified">!  * you can use {@code getDisplayLanguage} to get the name of</span>
   * the language suitable for displaying to the user. Interestingly,
<span class="line-modified">!  * the {@code getDisplayXXX} methods are themselves locale-sensitive</span>
   * and have two versions: one that uses the default
   * {@link Locale.Category#DISPLAY DISPLAY} locale and one
   * that uses the locale specified as an argument.
   *
   * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<span class="line-modified">!  * operations. For example, the {@code NumberFormat} class formats</span>
   * numbers, currency, and percentages in a locale-sensitive manner. Classes
<span class="line-modified">!  * such as {@code NumberFormat} have several convenience methods</span>
   * for creating a default object of that type. For example, the
<span class="line-modified">!  * {@code NumberFormat} class provides these three convenience methods</span>
<span class="line-modified">!  * for creating a default {@code NumberFormat} object:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   *     NumberFormat.getInstance()
   *     NumberFormat.getCurrencyInstance()
   *     NumberFormat.getPercentInstance()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,41 ***</span>
   *     NumberFormat.getInstance(myLocale)
   *     NumberFormat.getCurrencyInstance(myLocale)
   *     NumberFormat.getPercentInstance(myLocale)
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * A &lt;code&gt;Locale&lt;/code&gt; is the mechanism for identifying the kind of object</span>
<span class="line-modified">!  * (&lt;code&gt;NumberFormat&lt;/code&gt;) that you would like to get. The locale is</span>
   * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
   * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
   *
<span class="line-modified">!  * &lt;h4&gt;Compatibility&lt;/h4&gt;</span>
   *
   * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
   * constructors retain their behavior prior to the Java Runtime
   * Environment version 1.7.  The same is largely true for the
<span class="line-modified">!  * &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to</span>
   * be used as they were. In particular, clients who parse the output
   * of toString into language, country, and variant fields can continue
   * to do so (although this is strongly discouraged), although the
   * variant field will have additional information in it if script or
   * extensions are present.
   *
   * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
   * imposed by Locale&#39;s constructors. This means that conversions
   * between some Locales and BCP 47 language tags cannot be made without
<span class="line-modified">!  * losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot</span>
   * represent the state of locales whose language, country, or variant
   * do not conform to BCP 47.
   *
   * &lt;p&gt;Because of these issues, it is recommended that clients migrate
   * away from constructing non-conforming locales and use the
<span class="line-modified">!  * &lt;code&gt;forLanguageTag&lt;/code&gt; and &lt;code&gt;Locale.Builder&lt;/code&gt; APIs instead.</span>
   * Clients desiring a string representation of the complete locale can
<span class="line-modified">!  * then always rely on &lt;code&gt;toLanguageTag&lt;/code&gt; for this purpose.</span>
   *
<span class="line-modified">!  * &lt;h5&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h5&gt;</span>
   *
   * &lt;p&gt;For compatibility reasons, two
   * non-conforming locales are treated as special cases.  These are
   * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
   * in BCP 47 since the variants are too short. To ease migration to BCP 47,
<span class="line-new-header">--- 378,41 ---</span>
   *     NumberFormat.getInstance(myLocale)
   *     NumberFormat.getCurrencyInstance(myLocale)
   *     NumberFormat.getPercentInstance(myLocale)
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * A {@code Locale} is the mechanism for identifying the kind of object</span>
<span class="line-modified">!  * ({@code NumberFormat}) that you would like to get. The locale is</span>
   * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
   * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
   *
<span class="line-modified">!  * &lt;h3&gt;Compatibility&lt;/h3&gt;</span>
   *
   * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
   * constructors retain their behavior prior to the Java Runtime
   * Environment version 1.7.  The same is largely true for the
<span class="line-modified">!  * {@code toString} method. Thus Locale objects can continue to</span>
   * be used as they were. In particular, clients who parse the output
   * of toString into language, country, and variant fields can continue
   * to do so (although this is strongly discouraged), although the
   * variant field will have additional information in it if script or
   * extensions are present.
   *
   * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
   * imposed by Locale&#39;s constructors. This means that conversions
   * between some Locales and BCP 47 language tags cannot be made without
<span class="line-modified">!  * losing information. Thus {@code toLanguageTag} cannot</span>
   * represent the state of locales whose language, country, or variant
   * do not conform to BCP 47.
   *
   * &lt;p&gt;Because of these issues, it is recommended that clients migrate
   * away from constructing non-conforming locales and use the
<span class="line-modified">!  * {@code forLanguageTag} and {@code Locale.Builder} APIs instead.</span>
   * Clients desiring a string representation of the complete locale can
<span class="line-modified">!  * then always rely on {@code toLanguageTag} for this purpose.</span>
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * &lt;p&gt;For compatibility reasons, two
   * non-conforming locales are treated as special cases.  These are
   * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
   * in BCP 47 since the variants are too short. To ease migration to BCP 47,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,38 ***</span>
   * a Unicode locale extension, by specifying the Unicode locale key
   * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
   * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
   * extension &quot;u-nu-thai&quot; is automatically added.
   *
<span class="line-modified">!  * &lt;h5&gt;Serialization&lt;/h5&gt;</span>
   *
   * &lt;p&gt;During serialization, writeObject writes all fields to the output
   * stream, including extensions.
   *
   * &lt;p&gt;During deserialization, readResolve adds extensions as described
   * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
   * for the two cases th_TH_TH and ja_JP_JP.
   *
<span class="line-modified">!  * &lt;h5&gt;Legacy language codes&lt;/h5&gt;</span>
   *
   * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
   * their earlier, obsoleted forms: {@code he} maps to {@code iw},
   * {@code yi} maps to {@code ji}, and {@code id} maps to
   * {@code in}.  This continues to be the case, in order to not break
   * backwards compatibility.
   *
   * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
   * maintaining the old codes internal to Locale (so that
<span class="line-modified">!  * &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old</span>
   * code), but using the new codes in the BCP 47 language tag APIs (so
<span class="line-modified">!  * that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This</span>
   * preserves the equivalence between Locales no matter which code or
   * API is used to construct them. Java&#39;s default resource bundle
   * lookup mechanism also implements this mapping, so that resources
   * can be named using either convention, see {@link ResourceBundle.Control}.
   *
<span class="line-modified">!  * &lt;h5&gt;Three-letter language/country(region) codes&lt;/h5&gt;</span>
   *
   * &lt;p&gt;The Locale constructors have always specified that the language
   * and the country param be two characters in length, although in
   * practice they have accepted any length.  The specification has now
   * been relaxed to allow language codes of two to eight characters and
<span class="line-new-header">--- 433,38 ---</span>
   * a Unicode locale extension, by specifying the Unicode locale key
   * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
   * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
   * extension &quot;u-nu-thai&quot; is automatically added.
   *
<span class="line-modified">!  * &lt;h4&gt;Serialization&lt;/h4&gt;</span>
   *
   * &lt;p&gt;During serialization, writeObject writes all fields to the output
   * stream, including extensions.
   *
   * &lt;p&gt;During deserialization, readResolve adds extensions as described
   * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
   * for the two cases th_TH_TH and ja_JP_JP.
   *
<span class="line-modified">!  * &lt;h4&gt;Legacy language codes&lt;/h4&gt;</span>
   *
   * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
   * their earlier, obsoleted forms: {@code he} maps to {@code iw},
   * {@code yi} maps to {@code ji}, and {@code id} maps to
   * {@code in}.  This continues to be the case, in order to not break
   * backwards compatibility.
   *
   * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
   * maintaining the old codes internal to Locale (so that
<span class="line-modified">!  * {@code getLanguage} and {@code toString} reflect the old</span>
   * code), but using the new codes in the BCP 47 language tag APIs (so
<span class="line-modified">!  * that {@code toLanguageTag} reflects the new one). This</span>
   * preserves the equivalence between Locales no matter which code or
   * API is used to construct them. Java&#39;s default resource bundle
   * lookup mechanism also implements this mapping, so that resources
   * can be named using either convention, see {@link ResourceBundle.Control}.
   *
<span class="line-modified">!  * &lt;h4&gt;Three-letter language/country(region) codes&lt;/h4&gt;</span>
   *
   * &lt;p&gt;The Locale constructors have always specified that the language
   * and the country param be two characters in length, although in
   * practice they have accepted any length.  The specification has now
   * been relaxed to allow language codes of two to eight characters and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,105 ***</span>
   * @author Mark Davis
   * @since 1.1
   */
  public final class Locale implements Cloneable, Serializable {
  
<span class="line-removed">-     private static final  Cache LOCALECACHE = new Cache();</span>
<span class="line-removed">- </span>
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale SIMPLIFIED_CHINESE = createConstant(&quot;zh&quot;, &quot;CN&quot;);</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale TRADITIONAL_CHINESE = createConstant(&quot;zh&quot;, &quot;TW&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale FRANCE = createConstant(&quot;fr&quot;, &quot;FR&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale GERMANY = createConstant(&quot;de&quot;, &quot;DE&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale ITALY = createConstant(&quot;it&quot;, &quot;IT&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale JAPAN = createConstant(&quot;ja&quot;, &quot;JP&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale KOREA = createConstant(&quot;ko&quot;, &quot;KR&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CHINA = SIMPLIFIED_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale PRC = SIMPLIFIED_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale TAIWAN = TRADITIONAL_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale UK = createConstant(&quot;en&quot;, &quot;GB&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale US = createConstant(&quot;en&quot;, &quot;US&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CANADA = createConstant(&quot;en&quot;, &quot;CA&quot;);</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CANADA_FRENCH = createConstant(&quot;fr&quot;, &quot;CA&quot;);</span>
  
      /**
<span class="line-modified">!      * Useful constant for the root locale.  The root locale is the locale whose</span>
<span class="line-modified">!      * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded</span>
<span class="line-removed">-      * as the base locale of all locales, and is used as the language/country</span>
<span class="line-removed">-      * neutral locale for the locale sensitive operations.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @since 1.6</span>
       */
<span class="line-modified">!     public static final Locale ROOT = createConstant(&quot;&quot;, &quot;&quot;);</span>
  
      /**
       * The key for the private use extension (&#39;x&#39;).
       *
       * @see #getExtension(char)
<span class="line-new-header">--- 482,138 ---</span>
   * @author Mark Davis
   * @since 1.1
   */
  public final class Locale implements Cloneable, Serializable {
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale ENGLISH;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale FRENCH;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale GERMAN;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale ITALIAN;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale JAPANESE;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale KOREAN;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale CHINESE;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale SIMPLIFIED_CHINESE;</span>
  
      /** Useful constant for language.
       */
<span class="line-modified">!     public static final Locale TRADITIONAL_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale FRANCE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale GERMANY;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale ITALY;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale JAPAN;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale KOREA;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale UK;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale US;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CANADA;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CANADA_FRENCH;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Useful constant for the root locale.  The root locale is the locale whose</span>
<span class="line-added">+      * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded</span>
<span class="line-added">+      * as the base locale of all locales, and is used as the language/country</span>
<span class="line-added">+      * neutral locale for the locale sensitive operations.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 1.6</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static final Locale ROOT;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final Map&lt;BaseLocale, Locale&gt; CONSTANT_LOCALES = new HashMap&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+     static {</span>
<span class="line-added">+         ENGLISH = createConstant(BaseLocale.ENGLISH);</span>
<span class="line-added">+         FRENCH = createConstant(BaseLocale.FRENCH);</span>
<span class="line-added">+         GERMAN = createConstant(BaseLocale.GERMAN);</span>
<span class="line-added">+         ITALIAN = createConstant(BaseLocale.ITALIAN);</span>
<span class="line-added">+         JAPANESE = createConstant(BaseLocale.JAPANESE);</span>
<span class="line-added">+         KOREAN = createConstant(BaseLocale.KOREAN);</span>
<span class="line-added">+         CHINESE = createConstant(BaseLocale.CHINESE);</span>
<span class="line-added">+         SIMPLIFIED_CHINESE = createConstant(BaseLocale.SIMPLIFIED_CHINESE);</span>
<span class="line-added">+         TRADITIONAL_CHINESE = createConstant(BaseLocale.TRADITIONAL_CHINESE);</span>
<span class="line-added">+         FRANCE = createConstant(BaseLocale.FRANCE);</span>
<span class="line-added">+         GERMANY = createConstant(BaseLocale.GERMANY);</span>
<span class="line-added">+         ITALY = createConstant(BaseLocale.ITALY);</span>
<span class="line-added">+         JAPAN = createConstant(BaseLocale.JAPAN);</span>
<span class="line-added">+         KOREA = createConstant(BaseLocale.KOREA);</span>
<span class="line-added">+         UK = createConstant(BaseLocale.UK);</span>
<span class="line-added">+         US = createConstant(BaseLocale.US);</span>
<span class="line-added">+         CANADA = createConstant(BaseLocale.CANADA);</span>
<span class="line-added">+         CANADA_FRENCH = createConstant(BaseLocale.CANADA_FRENCH);</span>
<span class="line-added">+         ROOT = createConstant(BaseLocale.ROOT);</span>
<span class="line-added">+     }</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale CHINA = SIMPLIFIED_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale PRC = SIMPLIFIED_CHINESE;</span>
  
      /** Useful constant for country.
       */
<span class="line-modified">!     public static final Locale TAIWAN = TRADITIONAL_CHINESE;</span>
  
      /**
<span class="line-modified">!      * This method must be called only for creating the Locale.*</span>
<span class="line-modified">!      * constants due to making shortcuts.</span>
       */
<span class="line-modified">!     private static Locale createConstant(byte baseType) {</span>
<span class="line-added">+         BaseLocale base = BaseLocale.constantBaseLocales[baseType];</span>
<span class="line-added">+         Locale locale = new Locale(base, null);</span>
<span class="line-added">+         CONSTANT_LOCALES.put(base, locale);</span>
<span class="line-added">+         return locale;</span>
<span class="line-added">+     }</span>
  
      /**
       * The key for the private use extension (&#39;x&#39;).
       *
       * @see #getExtension(char)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,10 ***</span>
<span class="line-new-header">--- 631,11 ---</span>
       */
      public static final char UNICODE_LOCALE_EXTENSION = &#39;u&#39;;
  
      /** serialization ID
       */
<span class="line-added">+     @java.io.Serial</span>
      static final long serialVersionUID = 9149081749638150636L;
  
      /**
       * Enum for specifying the type defined in ISO 3166. This enum is used to
       * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,20 ***</span>
       * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
       * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
       * valid language values.
       * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified">!      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified">!      * @param variant Any arbitrary value used to indicate a variation of a &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified">!      * See the &lt;code&gt;Locale&lt;/code&gt; class description for the details.</span>
<span class="line-modified">!      * @exception NullPointerException thrown if any argument is null.</span>
       */
      public Locale(String language, String country, String variant) {
<span class="line-modified">!         if (language== null || country == null || variant == null) {</span>
              throw new NullPointerException();
          }
          baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
          localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
      }
<span class="line-new-header">--- 732,20 ---</span>
       * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
       * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the {@code Locale} class description about</span>
       * valid language values.
       * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified">!      * See the {@code Locale} class description about valid country values.</span>
<span class="line-modified">!      * @param variant Any arbitrary value used to indicate a variation of a {@code Locale}.</span>
<span class="line-modified">!      * See the {@code Locale} class description for the details.</span>
<span class="line-modified">!      * @throws    NullPointerException thrown if any argument is null.</span>
       */
      public Locale(String language, String country, String variant) {
<span class="line-modified">!         if (language == null || country == null || variant == null) {</span>
              throw new NullPointerException();
          }
          baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
          localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 730,15 ***</span>
       * &lt;li&gt;For backward compatibility reasons, this constructor does not make
       * any syntactic checks on the input.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
       * valid language values.
       * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified">!      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified">!      * @exception NullPointerException thrown if either argument is null.</span>
       */
      public Locale(String language, String country) {
          this(language, country, &quot;&quot;);
      }
  
<span class="line-new-header">--- 764,15 ---</span>
       * &lt;li&gt;For backward compatibility reasons, this constructor does not make
       * any syntactic checks on the input.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the {@code Locale} class description about</span>
       * valid language values.
       * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<span class="line-modified">!      * See the {@code Locale} class description about valid country values.</span>
<span class="line-modified">!      * @throws    NullPointerException thrown if either argument is null.</span>
       */
      public Locale(String language, String country) {
          this(language, country, &quot;&quot;);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,41 ***</span>
       * &lt;li&gt;For backward compatibility reasons, this constructor does not make
       * any syntactic checks on the input.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
       * valid language values.
<span class="line-modified">!      * @exception NullPointerException thrown if argument is null.</span>
       * @since 1.4
       */
      public Locale(String language) {
          this(language, &quot;&quot;, &quot;&quot;);
      }
  
      /**
<span class="line-modified">!      * This method must be called only for creating the Locale.*</span>
<span class="line-modified">!      * constants due to making shortcuts.</span>
<span class="line-modified">!      */</span>
<span class="line-removed">-     private static Locale createConstant(String lang, String country) {</span>
<span class="line-removed">-         BaseLocale base = BaseLocale.createInstance(lang, country);</span>
<span class="line-removed">-         return getInstance(base, null);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns a &lt;code&gt;Locale&lt;/code&gt; constructed from the given</span>
<span class="line-removed">-      * &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt; and</span>
<span class="line-removed">-      * &lt;code&gt;variant&lt;/code&gt;. If the same &lt;code&gt;Locale&lt;/code&gt; instance</span>
       * is available in the cache, then that instance is
<span class="line-modified">!      * returned. Otherwise, a new &lt;code&gt;Locale&lt;/code&gt; instance is</span>
       * created and cached.
       *
       * @param language lowercase 2 to 8 language code.
       * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.
       * @param variant vendor and browser specific code. See class description.
<span class="line-modified">!      * @return the &lt;code&gt;Locale&lt;/code&gt; instance requested</span>
<span class="line-modified">!      * @exception NullPointerException if any argument is null.</span>
       */
      static Locale getInstance(String language, String country, String variant) {
          return getInstance(language, &quot;&quot;, country, variant, null);
      }
  
<span class="line-new-header">--- 789,32 ---</span>
       * &lt;li&gt;For backward compatibility reasons, this constructor does not make
       * any syntactic checks on the input.
       * &lt;/ul&gt;
       *
       * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<span class="line-modified">!      * up to 8 characters in length.  See the {@code Locale} class description about</span>
       * valid language values.
<span class="line-modified">!      * @throws    NullPointerException thrown if argument is null.</span>
       * @since 1.4
       */
      public Locale(String language) {
          this(language, &quot;&quot;, &quot;&quot;);
      }
  
      /**
<span class="line-modified">!      * Returns a {@code Locale} constructed from the given</span>
<span class="line-modified">!      * {@code language}, {@code country} and</span>
<span class="line-modified">!      * {@code variant}. If the same {@code Locale} instance</span>
       * is available in the cache, then that instance is
<span class="line-modified">!      * returned. Otherwise, a new {@code Locale} instance is</span>
       * created and cached.
       *
       * @param language lowercase 2 to 8 language code.
       * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.
       * @param variant vendor and browser specific code. See class description.
<span class="line-modified">!      * @return the {@code Locale} instance requested</span>
<span class="line-modified">!      * @throws    NullPointerException if any argument is null.</span>
       */
      static Locale getInstance(String language, String country, String variant) {
          return getInstance(language, &quot;&quot;, country, variant, null);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 801,24 ***</span>
  
          if (extensions == null) {
              extensions = getCompatibilityExtensions(language, script, country, variant);
          }
  
<span class="line-modified">!         BaseLocale baseloc = BaseLocale.getInstance(language, script, country, variant);</span>
          return getInstance(baseloc, extensions);
      }
  
      static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
          if (extensions == null) {
<span class="line-modified">!             return LOCALECACHE.get(baseloc);</span>
          } else {
              LocaleKey key = new LocaleKey(baseloc, extensions);
<span class="line-modified">!             return LOCALECACHE.get(key);</span>
          }
      }
  
      private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {
          private Cache() {
          }
  
          @Override
          protected Locale createObject(Object key) {
<span class="line-new-header">--- 826,31 ---</span>
  
          if (extensions == null) {
              extensions = getCompatibilityExtensions(language, script, country, variant);
          }
  
<span class="line-modified">!         BaseLocale baseloc = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);</span>
          return getInstance(baseloc, extensions);
      }
  
      static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
          if (extensions == null) {
<span class="line-modified">!             Locale locale = CONSTANT_LOCALES.get(baseloc);</span>
<span class="line-added">+             if (locale != null) {</span>
<span class="line-added">+                 return locale;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return Cache.LOCALECACHE.get(baseloc);</span>
          } else {
              LocaleKey key = new LocaleKey(baseloc, extensions);
<span class="line-modified">!             return Cache.LOCALECACHE.get(key);</span>
          }
      }
  
      private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {
<span class="line-added">+ </span>
<span class="line-added">+         private static final Cache LOCALECACHE = new Cache();</span>
<span class="line-added">+ </span>
          private Cache() {
          }
  
          @Override
          protected Locale createObject(Object key) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,11 ***</span>
       * The Java Virtual Machine sets the default locale during startup based
       * on the host environment. It is used by many locale-sensitive methods
       * if no locale is explicitly specified. It can be changed using the
       * setDefault(Locale.Category, Locale) method.
       *
<span class="line-modified">!      * @param category - the specified category to get the default locale</span>
       * @throws NullPointerException if category is null
       * @return the default locale for the specified Category for this instance
       *     of the Java Virtual Machine
       * @see #setDefault(Locale.Category, Locale)
       * @since 1.7
<span class="line-new-header">--- 928,11 ---</span>
       * The Java Virtual Machine sets the default locale during startup based
       * on the host environment. It is used by many locale-sensitive methods
       * if no locale is explicitly specified. It can be changed using the
       * setDefault(Locale.Category, Locale) method.
       *
<span class="line-modified">!      * @param category the specified category to get the default locale</span>
       * @throws NullPointerException if category is null
       * @return the default locale for the specified Category for this instance
       *     of the Java Virtual Machine
       * @see #setDefault(Locale.Category, Locale)
       * @since 1.7
</pre>
<hr />
<pre>
<span class="line-old-header">*** 975,12 ***</span>
              getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
                  .orElse(defaultLocale.getLocaleExtensions()));
      }
  
      private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {
<span class="line-modified">!         LocaleExtensions exts = null;</span>
  
          try {
              exts = new InternalLocaleBuilder()
                  .setExtensions(extensionsProp)
                  .getLocaleExtensions();
          } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 1007,15 ---</span>
              getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
                  .orElse(defaultLocale.getLocaleExtensions()));
      }
  
      private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {
<span class="line-modified">!         if (LocaleUtils.isEmpty(extensionsProp)) {</span>
<span class="line-added">+             return Optional.empty();</span>
<span class="line-added">+         }</span>
  
<span class="line-added">+         LocaleExtensions exts = null;</span>
          try {
              exts = new InternalLocaleBuilder()
                  .setExtensions(extensionsProp)
                  .getLocaleExtensions();
          } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 992,12 ***</span>
  
      /**
       * Sets the default locale for this instance of the Java Virtual Machine.
       * This does not affect the host locale.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;</span>
<span class="line-modified">!      * method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt;</span>
       * permission before the default locale is changed.
       * &lt;p&gt;
       * The Java Virtual Machine sets the default locale during startup
       * based on the host environment. It is used by many locale-sensitive
       * methods if no locale is explicitly specified.
<span class="line-new-header">--- 1027,12 ---</span>
  
      /**
       * Sets the default locale for this instance of the Java Virtual Machine.
       * This does not affect the host locale.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, its {@code checkPermission}</span>
<span class="line-modified">!      * method is called with a {@code PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)}</span>
       * permission before the default locale is changed.
       * &lt;p&gt;
       * The Java Virtual Machine sets the default locale during startup
       * based on the host environment. It is used by many locale-sensitive
       * methods if no locale is explicitly specified.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1010,12 ***</span>
       * By setting the default locale with this method, all of the default
       * locales for each Category are also set to the specified default locale.
       *
       * @throws SecurityException
       *        if a security manager exists and its
<span class="line-modified">!      *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @throws NullPointerException if &lt;code&gt;newLocale&lt;/code&gt; is null</span>
       * @param newLocale the new default locale
       * @see SecurityManager#checkPermission
       * @see java.util.PropertyPermission
       */
      public static synchronized void setDefault(Locale newLocale) {
<span class="line-new-header">--- 1045,12 ---</span>
       * By setting the default locale with this method, all of the default
       * locales for each Category are also set to the specified default locale.
       *
       * @throws SecurityException
       *        if a security manager exists and its
<span class="line-modified">!      *        {@code checkPermission} method doesn&#39;t allow the operation.</span>
<span class="line-modified">!      * @throws NullPointerException if {@code newLocale} is null</span>
       * @param newLocale the new default locale
       * @see SecurityManager#checkPermission
       * @see java.util.PropertyPermission
       */
      public static synchronized void setDefault(Locale newLocale) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1039,12 ***</span>
       * Since changing the default locale may affect many different areas of
       * functionality, this method should only be used if the caller is
       * prepared to reinitialize locale-sensitive code running within the
       * same Java Virtual Machine.
       *
<span class="line-modified">!      * @param category - the specified category to set the default locale</span>
<span class="line-modified">!      * @param newLocale - the new default locale</span>
       * @throws SecurityException if a security manager exists and its
       *     checkPermission method doesn&#39;t allow the operation.
       * @throws NullPointerException if category and/or newLocale is null
       * @see SecurityManager#checkPermission(java.security.Permission)
       * @see PropertyPermission
<span class="line-new-header">--- 1074,12 ---</span>
       * Since changing the default locale may affect many different areas of
       * functionality, this method should only be used if the caller is
       * prepared to reinitialize locale-sensitive code running within the
       * same Java Virtual Machine.
       *
<span class="line-modified">!      * @param category the specified category to set the default locale</span>
<span class="line-modified">!      * @param newLocale the new default locale</span>
       * @throws SecurityException if a security manager exists and its
       *     checkPermission method doesn&#39;t allow the operation.
       * @throws NullPointerException if category and/or newLocale is null
       * @see SecurityManager#checkPermission(java.security.Permission)
       * @see PropertyPermission
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1076,11 ***</span>
      /**
       * Returns an array of all installed locales.
       * The returned array represents the union of locales supported
       * by the Java runtime environment and by installed
       * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<span class="line-modified">!      * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
       * instance equal to {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of installed locales.
       */
      public static Locale[] getAvailableLocales() {
<span class="line-new-header">--- 1111,11 ---</span>
      /**
       * Returns an array of all installed locales.
       * The returned array represents the union of locales supported
       * by the Java runtime environment and by installed
       * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<span class="line-modified">!      * implementations.  It must contain at least a {@code Locale}</span>
       * instance equal to {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of installed locales.
       */
      public static Locale[] getAvailableLocales() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1091,11 ***</span>
       * Returns a list of all 2-letter country codes defined in ISO 3166.
       * Can be used to create Locales.
       * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
       * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
       * &lt;p&gt;
<span class="line-modified">!      * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class also supports other codes for</span>
       * country (region), such as 3-letter numeric UN M.49 area codes.
       * Therefore, the list returned by this method does not contain ALL valid
       * codes that can be used to create Locales.
       * &lt;p&gt;
       * Note that this method does not return obsolete 2-letter country codes.
<span class="line-new-header">--- 1126,11 ---</span>
       * Returns a list of all 2-letter country codes defined in ISO 3166.
       * Can be used to create Locales.
       * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
       * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
       * &lt;p&gt;
<span class="line-modified">!      * &lt;b&gt;Note:&lt;/b&gt; The {@code Locale} class also supports other codes for</span>
       * country (region), such as 3-letter numeric UN M.49 area codes.
       * Therefore, the list returned by this method does not contain ALL valid
       * codes that can be used to create Locales.
       * &lt;p&gt;
       * Note that this method does not return obsolete 2-letter country codes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1134,11 ***</span>
       * &lt;b&gt;Note:&lt;/b&gt;
       * &lt;ul&gt;
       * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
       * The list this function returns includes both the new and the old codes for the
       * languages whose codes have changed.
<span class="line-modified">!      * &lt;li&gt;The &lt;code&gt;Locale&lt;/code&gt; class also supports language codes up to</span>
       * 8 characters in length.  Therefore, the list returned by this method does
       * not contain ALL valid codes that can be used to create Locales.
       * &lt;/ul&gt;
       *
       * @return An array of ISO 639 two-letter language codes.
<span class="line-new-header">--- 1169,11 ---</span>
       * &lt;b&gt;Note:&lt;/b&gt;
       * &lt;ul&gt;
       * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
       * The list this function returns includes both the new and the old codes for the
       * languages whose codes have changed.
<span class="line-modified">!      * &lt;li&gt;The {@code Locale} class also supports language codes up to</span>
       * 8 characters in length.  Therefore, the list returned by this method does
       * not contain ALL valid codes that can be used to create Locales.
       * &lt;/ul&gt;
       *
       * @return An array of ISO 639 two-letter language codes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,11 ***</span>
  
      /**
       * Returns the extension (or private use) value associated with
       * the specified key, or null if there is no extension
       * associated with the key. To be well-formed, the key must be one
<span class="line-modified">!      * of &lt;code&gt;[0-9A-Za-z]&lt;/code&gt;. Keys are case-insensitive, so</span>
       * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
       *
       * @param key the extension key
       * @return The extension, or null if this locale defines no
       * extension for the specified key.
<span class="line-new-header">--- 1281,11 ---</span>
  
      /**
       * Returns the extension (or private use) value associated with
       * the specified key, or null if there is no extension
       * associated with the key. To be well-formed, the key must be one
<span class="line-modified">!      * of {@code [0-9A-Za-z]}. Keys are case-insensitive, so</span>
       * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
       *
       * @param key the extension key
       * @return The extension, or null if this locale defines no
       * extension for the specified key.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1306,11 ***</span>
       *
       * @param key the Unicode locale key
       * @return The Unicode locale type associated with the key, or null if the
       * locale does not define the key.
       * @throws IllegalArgumentException if the key is not well-formed
<span class="line-modified">!      * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
       * @since 1.7
       */
      public String getUnicodeLocaleType(String key) {
          if (!isUnicodeExtensionKey(key)) {
              throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
<span class="line-new-header">--- 1341,11 ---</span>
       *
       * @param key the Unicode locale key
       * @return The Unicode locale type associated with the key, or null if the
       * locale does not define the key.
       * @throws IllegalArgumentException if the key is not well-formed
<span class="line-modified">!      * @throws NullPointerException if {@code key} is null</span>
       * @since 1.7
       */
      public String getUnicodeLocaleType(String key) {
          if (!isUnicodeExtensionKey(key)) {
              throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1351,11 ***</span>
       LocaleExtensions getLocaleExtensions() {
           return localeExtensions;
       }
  
      /**
<span class="line-modified">!      * Returns a string representation of this &lt;code&gt;Locale&lt;/code&gt;</span>
       * object, consisting of language, country, variant, script,
       * and extensions as below:
       * &lt;blockquote&gt;
       * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
       * &lt;/blockquote&gt;
<span class="line-new-header">--- 1386,11 ---</span>
       LocaleExtensions getLocaleExtensions() {
           return localeExtensions;
       }
  
      /**
<span class="line-modified">!      * Returns a string representation of this {@code Locale}</span>
       * object, consisting of language, country, variant, script,
       * and extensions as below:
       * &lt;blockquote&gt;
       * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
       * &lt;/blockquote&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1374,11 ***</span>
       *
       * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
       * added before the &quot;#&quot;.
       *
       * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<span class="line-modified">!      * previous uses of &lt;code&gt;toString&lt;/code&gt; that expected language, country, and variant</span>
       * fields only.  To represent a Locale as a String for interchange purposes, use
       * {@link #toLanguageTag}.
       *
       * &lt;p&gt;Examples: &lt;ul&gt;
       * &lt;li&gt;{@code en}&lt;/li&gt;
<span class="line-new-header">--- 1409,11 ---</span>
       *
       * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
       * added before the &quot;#&quot;.
       *
       * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<span class="line-modified">!      * previous uses of {@code toString} that expected language, country, and variant</span>
       * fields only.  To represent a Locale as a String for interchange purposes, use
       * {@link #toLanguageTag}.
       *
       * &lt;p&gt;Examples: &lt;ul&gt;
       * &lt;li&gt;{@code en}&lt;/li&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1430,11 ***</span>
  
      /**
       * Returns a well-formed IETF BCP 47 language tag representing
       * this locale.
       *
<span class="line-modified">!      * &lt;p&gt;If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or</span>
       * variant that does not satisfy the IETF BCP 47 language tag
       * syntax requirements, this method handles these fields as
       * described below:
       *
       * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a
<span class="line-new-header">--- 1465,11 ---</span>
  
      /**
       * Returns a well-formed IETF BCP 47 language tag representing
       * this locale.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Locale} has a language, country, or</span>
       * variant that does not satisfy the IETF BCP 47 language tag
       * syntax requirements, this method handles these fields as
       * described below:
       *
       * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1666,16 ***</span>
       * &lt;/table&gt;
       *
       * &lt;p&gt;For a list of all grandfathered tags, see the
       * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that &lt;code&gt;toLanguageTag&lt;/code&gt;</span>
<span class="line-modified">!      * and &lt;code&gt;forLanguageTag&lt;/code&gt; will round-trip.</span>
       *
       * @param languageTag the language tag
       * @return The locale that best represents the language tag.
<span class="line-modified">!      * @throws NullPointerException if &lt;code&gt;languageTag&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @see #toLanguageTag()
       * @see java.util.Locale.Builder#setLanguageTag(String)
       * @since 1.7
       */
      public static Locale forLanguageTag(String languageTag) {
<span class="line-new-header">--- 1701,16 ---</span>
       * &lt;/table&gt;
       *
       * &lt;p&gt;For a list of all grandfathered tags, see the
       * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that {@code toLanguageTag}</span>
<span class="line-modified">!      * and {@code forLanguageTag} will round-trip.</span>
       *
       * @param languageTag the language tag
       * @return The locale that best represents the language tag.
<span class="line-modified">!      * @throws NullPointerException if {@code languageTag} is {@code null}</span>
       * @see #toLanguageTag()
       * @see java.util.Locale.Builder#setLanguageTag(String)
       * @since 1.7
       */
      public static Locale forLanguageTag(String languageTag) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1700,11 ***</span>
       * Alpha-3 Code&quot;.  If the locale specifies a three-letter
       * language, the language is returned as is.  If the locale does
       * not specify a language the empty string is returned.
       *
       * @return A three-letter abbreviation of this locale&#39;s language.
<span class="line-modified">!      * @exception MissingResourceException Throws MissingResourceException if</span>
       * three-letter language abbreviation is not available for this locale.
       */
      public String getISO3Language() throws MissingResourceException {
          String lang = baseLocale.getLanguage();
          if (lang.length() == 3) {
<span class="line-new-header">--- 1735,11 ---</span>
       * Alpha-3 Code&quot;.  If the locale specifies a three-letter
       * language, the language is returned as is.  If the locale does
       * not specify a language the empty string is returned.
       *
       * @return A three-letter abbreviation of this locale&#39;s language.
<span class="line-modified">!      * @throws    MissingResourceException Throws MissingResourceException if</span>
       * three-letter language abbreviation is not available for this locale.
       */
      public String getISO3Language() throws MissingResourceException {
          String lang = baseLocale.getLanguage();
          if (lang.length() == 3) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1727,11 ***</span>
       * string.
       *
       * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
       *
       * @return A three-letter abbreviation of this locale&#39;s country.
<span class="line-modified">!      * @exception MissingResourceException Throws MissingResourceException if the</span>
       * three-letter country abbreviation is not available for this locale.
       */
      public String getISO3Country() throws MissingResourceException {
          String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
          if (country3 == null) {
<span class="line-new-header">--- 1762,11 ---</span>
       * string.
       *
       * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
       *
       * @return A three-letter abbreviation of this locale&#39;s country.
<span class="line-modified">!      * @throws    MissingResourceException Throws MissingResourceException if the</span>
       * three-letter country abbreviation is not available for this locale.
       */
      public String getISO3Country() throws MissingResourceException {
          String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
          if (country3 == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1797,11 ***</span>
       * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
       * this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display language.
       * @return The name of the display language appropriate to the given locale.
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       */
      public String getDisplayLanguage(Locale inLocale) {
          return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
      }
  
<span class="line-new-header">--- 1832,11 ---</span>
       * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
       * this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display language.
       * @return The name of the display language appropriate to the given locale.
<span class="line-modified">!      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
       */
      public String getDisplayLanguage(Locale inLocale) {
          return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1826,11 ***</span>
       * this locale doesn&#39;t specify a script code.
       *
       * @param inLocale The locale for which to retrieve the display script.
       * @return the display name of the script code for the current default
       * {@link Locale.Category#DISPLAY DISPLAY} locale
<span class="line-modified">!      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @since 1.7
       */
      public String getDisplayScript(Locale inLocale) {
          return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
      }
<span class="line-new-header">--- 1861,11 ---</span>
       * this locale doesn&#39;t specify a script code.
       *
       * @param inLocale The locale for which to retrieve the display script.
       * @return the display name of the script code for the current default
       * {@link Locale.Category#DISPLAY DISPLAY} locale
<span class="line-modified">!      * @throws NullPointerException if {@code inLocale} is {@code null}</span>
       * @since 1.7
       */
      public String getDisplayScript(Locale inLocale) {
          return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1870,11 ***</span>
       * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
       * this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display country.
       * @return The name of the country appropriate to the given locale.
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       */
      public String getDisplayCountry(Locale inLocale) {
          return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
      }
  
<span class="line-new-header">--- 1905,11 ---</span>
       * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
       * this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display country.
       * @return The name of the country appropriate to the given locale.
<span class="line-modified">!      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
       */
      public String getDisplayCountry(Locale inLocale) {
          return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1912,11 ***</span>
       * user.  If possible, the name will be localized for inLocale.  If the locale
       * doesn&#39;t specify a variant code, this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display variant code.
       * @return The name of the display variant code appropriate to the given locale.
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       */
      public String getDisplayVariant(Locale inLocale) {
          if (baseLocale.getVariant().isEmpty())
              return &quot;&quot;;
  
<span class="line-new-header">--- 1947,11 ---</span>
       * user.  If possible, the name will be localized for inLocale.  If the locale
       * doesn&#39;t specify a variant code, this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display variant code.
       * @return The name of the display variant code appropriate to the given locale.
<span class="line-modified">!      * @throws    NullPointerException if {@code inLocale} is {@code null}</span>
       */
      public String getDisplayVariant(Locale inLocale) {
          if (baseLocale.getVariant().isEmpty())
              return &quot;&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1977,11 ***</span>
       * be localized depending on the locale. If the language, script, country,
       * and variant fields are all empty, this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display name.
       * @return The name of the locale appropriate to display.
<span class="line-modified">!      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       */
      public String getDisplayName(Locale inLocale) {
          LocaleResources lr =  LocaleProviderAdapter
              .getResourceBundleBased()
              .getLocaleResources(inLocale);
<span class="line-new-header">--- 2012,11 ---</span>
       * be localized depending on the locale. If the language, script, country,
       * and variant fields are all empty, this function returns the empty string.
       *
       * @param inLocale The locale for which to retrieve the display name.
       * @return The name of the locale appropriate to display.
<span class="line-modified">!      * @throws NullPointerException if {@code inLocale} is {@code null}</span>
       */
      public String getDisplayName(Locale inLocale) {
          LocaleResources lr =  LocaleProviderAdapter
              .getResourceBundleBased()
              .getLocaleResources(inLocale);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2265,25 ***</span>
       *      BCP47 private use subtags, all in lower case letters
       *      separated by HYPHEN-MINUS characters.
       *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
       *      &lt;a href=&quot;java.base/java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
       */
      private static final ObjectStreamField[] serialPersistentFields = {
          new ObjectStreamField(&quot;language&quot;, String.class),
          new ObjectStreamField(&quot;country&quot;, String.class),
          new ObjectStreamField(&quot;variant&quot;, String.class),
          new ObjectStreamField(&quot;hashcode&quot;, int.class),
          new ObjectStreamField(&quot;script&quot;, String.class),
          new ObjectStreamField(&quot;extensions&quot;, String.class),
      };
  
      /**
<span class="line-modified">!      * Serializes this &lt;code&gt;Locale&lt;/code&gt; to the specified &lt;code&gt;ObjectOutputStream&lt;/code&gt;.</span>
<span class="line-modified">!      * @param out the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write</span>
       * @throws IOException
       * @since 1.7
       */
      private void writeObject(ObjectOutputStream out) throws IOException {
          ObjectOutputStream.PutField fields = out.putFields();
          fields.put(&quot;language&quot;, baseLocale.getLanguage());
          fields.put(&quot;script&quot;, baseLocale.getScript());
          fields.put(&quot;country&quot;, baseLocale.getRegion());
<span class="line-new-header">--- 2300,27 ---</span>
       *      BCP47 private use subtags, all in lower case letters
       *      separated by HYPHEN-MINUS characters.
       *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
       *      &lt;a href=&quot;java.base/java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
       */
<span class="line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields = {
          new ObjectStreamField(&quot;language&quot;, String.class),
          new ObjectStreamField(&quot;country&quot;, String.class),
          new ObjectStreamField(&quot;variant&quot;, String.class),
          new ObjectStreamField(&quot;hashcode&quot;, int.class),
          new ObjectStreamField(&quot;script&quot;, String.class),
          new ObjectStreamField(&quot;extensions&quot;, String.class),
      };
  
      /**
<span class="line-modified">!      * Serializes this {@code Locale} to the specified {@code ObjectOutputStream}.</span>
<span class="line-modified">!      * @param out the {@code ObjectOutputStream} to write</span>
       * @throws IOException
       * @since 1.7
       */
<span class="line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream out) throws IOException {
          ObjectOutputStream.PutField fields = out.putFields();
          fields.put(&quot;language&quot;, baseLocale.getLanguage());
          fields.put(&quot;script&quot;, baseLocale.getScript());
          fields.put(&quot;country&quot;, baseLocale.getRegion());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2292,24 ***</span>
          fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
          out.writeFields();
      }
  
      /**
<span class="line-modified">!      * Deserializes this &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified">!      * @param in the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read</span>
       * @throws IOException
       * @throws ClassNotFoundException
       * @throws IllformedLocaleException
       * @since 1.7
       */
      private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
          ObjectInputStream.GetField fields = in.readFields();
          String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
          String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
          String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);
          String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
          String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);
          baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
          if (!extStr.isEmpty()) {
              try {
                  InternalLocaleBuilder bldr = new InternalLocaleBuilder();
                  bldr.setExtensions(extStr);
<span class="line-new-header">--- 2329,26 ---</span>
          fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
          out.writeFields();
      }
  
      /**
<span class="line-modified">!      * Deserializes this {@code Locale}.</span>
<span class="line-modified">!      * @param in the {@code ObjectInputStream} to read</span>
       * @throws IOException
       * @throws ClassNotFoundException
       * @throws IllformedLocaleException
       * @since 1.7
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
          ObjectInputStream.GetField fields = in.readFields();
          String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
          String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
          String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);
          String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
          String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);
<span class="line-added">+ </span>
          baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
          if (!extStr.isEmpty()) {
              try {
                  InternalLocaleBuilder bldr = new InternalLocaleBuilder();
                  bldr.setExtensions(extStr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2321,23 ***</span>
              localeExtensions = null;
          }
      }
  
      /**
<span class="line-modified">!      * Returns a cached &lt;code&gt;Locale&lt;/code&gt; instance equivalent to</span>
<span class="line-modified">!      * the deserialized &lt;code&gt;Locale&lt;/code&gt;. When serialized</span>
       * language, country and variant fields read from the object data stream
       * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<span class="line-modified">!      * fields are empty, this method supplies &lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt;</span>
       * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
       * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
       * for more information.
       *
<span class="line-modified">!      * @return an instance of &lt;code&gt;Locale&lt;/code&gt; equivalent to</span>
<span class="line-modified">!      * the deserialized &lt;code&gt;Locale&lt;/code&gt;.</span>
       * @throws java.io.ObjectStreamException
       */
      private Object readResolve() throws java.io.ObjectStreamException {
          return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
                  baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
      }
  
<span class="line-new-header">--- 2360,24 ---</span>
              localeExtensions = null;
          }
      }
  
      /**
<span class="line-modified">!      * Returns a cached {@code Locale} instance equivalent to</span>
<span class="line-modified">!      * the deserialized {@code Locale}. When serialized</span>
       * language, country and variant fields read from the object data stream
       * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<span class="line-modified">!      * fields are empty, this method supplies {@code UNICODE_LOCALE_EXTENSION}</span>
       * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
       * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
       * for more information.
       *
<span class="line-modified">!      * @return an instance of {@code Locale} equivalent to</span>
<span class="line-modified">!      * the deserialized {@code Locale}.</span>
       * @throws java.io.ObjectStreamException
       */
<span class="line-added">+     @java.io.Serial</span>
      private Object readResolve() throws java.io.ObjectStreamException {
          return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
                  baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2467,37 ***</span>
          final String variantKey;
          final String extensionsKey;
      }
  
      /**
<span class="line-modified">!      * &lt;code&gt;Builder&lt;/code&gt; is used to build instances of &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">!      * from values configured by the setters.  Unlike the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">!      * constructors, the &lt;code&gt;Builder&lt;/code&gt; checks if a value configured by a</span>
<span class="line-modified">!      * setter satisfies the syntax requirements defined by the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">!      * class.  A &lt;code&gt;Locale&lt;/code&gt; object created by a &lt;code&gt;Builder&lt;/code&gt; is</span>
       * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
       * without losing information.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class does not provide any</span>
       * syntactic restrictions on variant, while BCP 47 requires each variant
       * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<span class="line-modified">!      * alphanumerics.  The method &lt;code&gt;setVariant&lt;/code&gt; throws</span>
<span class="line-modified">!      * &lt;code&gt;IllformedLocaleException&lt;/code&gt; for a variant that does not satisfy</span>
       * this restriction. If it is necessary to support such a variant, use a
<span class="line-modified">!      * Locale constructor.  However, keep in mind that a &lt;code&gt;Locale&lt;/code&gt;</span>
       * object created this way might lose the variant information when
       * transformed to a BCP 47 language tag.
       *
<span class="line-modified">!      * &lt;p&gt;The following example shows how to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
<span class="line-modified">!      * with the &lt;code&gt;Builder&lt;/code&gt;.</span>
       * &lt;blockquote&gt;
       * &lt;pre&gt;
       *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
       * &lt;/pre&gt;
       * &lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt;Builders can be reused; &lt;code&gt;clear()&lt;/code&gt; resets all</span>
       * fields to their default values.
       *
       * @see Locale#forLanguageTag
       * @since 1.7
       */
<span class="line-new-header">--- 2507,37 ---</span>
          final String variantKey;
          final String extensionsKey;
      }
  
      /**
<span class="line-modified">!      * {@code Builder} is used to build instances of {@code Locale}</span>
<span class="line-modified">!      * from values configured by the setters.  Unlike the {@code Locale}</span>
<span class="line-modified">!      * constructors, the {@code Builder} checks if a value configured by a</span>
<span class="line-modified">!      * setter satisfies the syntax requirements defined by the {@code Locale}</span>
<span class="line-modified">!      * class.  A {@code Locale} object created by a {@code Builder} is</span>
       * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
       * without losing information.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The {@code Locale} class does not provide any</span>
       * syntactic restrictions on variant, while BCP 47 requires each variant
       * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<span class="line-modified">!      * alphanumerics.  The method {@code setVariant} throws</span>
<span class="line-modified">!      * {@code IllformedLocaleException} for a variant that does not satisfy</span>
       * this restriction. If it is necessary to support such a variant, use a
<span class="line-modified">!      * Locale constructor.  However, keep in mind that a {@code Locale}</span>
       * object created this way might lose the variant information when
       * transformed to a BCP 47 language tag.
       *
<span class="line-modified">!      * &lt;p&gt;The following example shows how to create a {@code Locale} object</span>
<span class="line-modified">!      * with the {@code Builder}.</span>
       * &lt;blockquote&gt;
       * &lt;pre&gt;
       *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
       * &lt;/pre&gt;
       * &lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt;Builders can be reused; {@code clear()} resets all</span>
       * fields to their default values.
       *
       * @see Locale#forLanguageTag
       * @since 1.7
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2512,28 ***</span>
          public Builder() {
              localeBuilder = new InternalLocaleBuilder();
          }
  
          /**
<span class="line-modified">!          * Resets the &lt;code&gt;Builder&lt;/code&gt; to match the provided</span>
<span class="line-modified">!          * &lt;code&gt;locale&lt;/code&gt;.  Existing state is discarded.</span>
           *
           * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
           *
           * &lt;p&gt;Locales with any ill-formed fields cause
<span class="line-modified">!          * &lt;code&gt;IllformedLocaleException&lt;/code&gt; to be thrown, except for the</span>
           * following three cases which are accepted for compatibility
           * reasons:&lt;ul&gt;
           * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;
           * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;
           * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;
           *
           * @param locale the locale
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;locale&lt;/code&gt; has</span>
           * any ill-formed fields.
<span class="line-modified">!          * @throws NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null.</span>
           */
          public Builder setLocale(Locale locale) {
              try {
                  localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
              } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 2552,28 ---</span>
          public Builder() {
              localeBuilder = new InternalLocaleBuilder();
          }
  
          /**
<span class="line-modified">!          * Resets the {@code Builder} to match the provided</span>
<span class="line-modified">!          * {@code locale}.  Existing state is discarded.</span>
           *
           * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
           *
           * &lt;p&gt;Locales with any ill-formed fields cause
<span class="line-modified">!          * {@code IllformedLocaleException} to be thrown, except for the</span>
           * following three cases which are accepted for compatibility
           * reasons:&lt;ul&gt;
           * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;
           * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;
           * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;
           *
           * @param locale the locale
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code locale} has</span>
           * any ill-formed fields.
<span class="line-modified">!          * @throws NullPointerException if {@code locale} is null.</span>
           */
          public Builder setLocale(Locale locale) {
              try {
                  localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
              } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2548,17 ***</span>
           * empty string cause the builder to be reset, like {@link
           * #clear}.  Grandfathered tags (see {@link
           * Locale#forLanguageTag}) are converted to their canonical
           * form before being processed.  Otherwise, the language tag
           * must be well-formed (see {@link Locale}) or an exception is
<span class="line-modified">!          * thrown (unlike &lt;code&gt;Locale.forLanguageTag&lt;/code&gt;, which</span>
           * just discards ill-formed and following portions of the
           * tag).
           *
           * @param languageTag the language tag
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;languageTag&lt;/code&gt; is ill-formed</span>
           * @see Locale#forLanguageTag(String)
           */
          public Builder setLanguageTag(String languageTag) {
              ParseStatus sts = new ParseStatus();
              LanguageTag tag = LanguageTag.parse(languageTag, sts);
<span class="line-new-header">--- 2588,17 ---</span>
           * empty string cause the builder to be reset, like {@link
           * #clear}.  Grandfathered tags (see {@link
           * Locale#forLanguageTag}) are converted to their canonical
           * form before being processed.  Otherwise, the language tag
           * must be well-formed (see {@link Locale}) or an exception is
<span class="line-modified">!          * thrown (unlike {@code Locale.forLanguageTag}, which</span>
           * just discards ill-formed and following portions of the
           * tag).
           *
           * @param languageTag the language tag
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code languageTag} is ill-formed</span>
           * @see Locale#forLanguageTag(String)
           */
          public Builder setLanguageTag(String languageTag) {
              ParseStatus sts = new ParseStatus();
              LanguageTag tag = LanguageTag.parse(languageTag, sts);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2568,21 ***</span>
              localeBuilder.setLanguageTag(tag);
              return this;
          }
  
          /**
<span class="line-modified">!          * Sets the language.  If &lt;code&gt;language&lt;/code&gt; is the empty string or</span>
<span class="line-modified">!          * null, the language in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
           * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
           * or an exception is thrown.
           *
           * &lt;p&gt;The typical language value is a two or three-letter language
           * code as defined in ISO639.
           *
           * @param language the language
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;language&lt;/code&gt; is ill-formed</span>
           */
          public Builder setLanguage(String language) {
              try {
                  localeBuilder.setLanguage(language);
              } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 2608,21 ---</span>
              localeBuilder.setLanguageTag(tag);
              return this;
          }
  
          /**
<span class="line-modified">!          * Sets the language.  If {@code language} is the empty string or</span>
<span class="line-modified">!          * null, the language in this {@code Builder} is removed.  Otherwise,</span>
           * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
           * or an exception is thrown.
           *
           * &lt;p&gt;The typical language value is a two or three-letter language
           * code as defined in ISO639.
           *
           * @param language the language
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code language} is ill-formed</span>
           */
          public Builder setLanguage(String language) {
              try {
                  localeBuilder.setLanguage(language);
              } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2590,20 ***</span>
              }
              return this;
          }
  
          /**
<span class="line-modified">!          * Sets the script. If &lt;code&gt;script&lt;/code&gt; is null or the empty string,</span>
<span class="line-modified">!          * the script in this &lt;code&gt;Builder&lt;/code&gt; is removed.</span>
           * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
           * exception is thrown.
           *
           * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
           *
           * @param script the script
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;script&lt;/code&gt; is ill-formed</span>
           */
          public Builder setScript(String script) {
              try {
                  localeBuilder.setScript(script);
              } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 2630,20 ---</span>
              }
              return this;
          }
  
          /**
<span class="line-modified">!          * Sets the script. If {@code script} is null or the empty string,</span>
<span class="line-modified">!          * the script in this {@code Builder} is removed.</span>
           * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
           * exception is thrown.
           *
           * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
           *
           * @param script the script
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code script} is ill-formed</span>
           */
          public Builder setScript(String script) {
              try {
                  localeBuilder.setScript(script);
              } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2612,23 ***</span>
              return this;
          }
  
          /**
           * Sets the region.  If region is null or the empty string, the region
<span class="line-modified">!          * in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
           * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
           * exception is thrown.
           *
           * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
           * three-digit UN M.49 area code.
           *
<span class="line-modified">!          * &lt;p&gt;The country value in the &lt;code&gt;Locale&lt;/code&gt; created by the</span>
<span class="line-modified">!          * &lt;code&gt;Builder&lt;/code&gt; is always normalized to upper case.</span>
           *
           * @param region the region
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;region&lt;/code&gt; is ill-formed</span>
           */
          public Builder setRegion(String region) {
              try {
                  localeBuilder.setRegion(region);
              } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 2652,23 ---</span>
              return this;
          }
  
          /**
           * Sets the region.  If region is null or the empty string, the region
<span class="line-modified">!          * in this {@code Builder} is removed.  Otherwise,</span>
           * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
           * exception is thrown.
           *
           * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
           * three-digit UN M.49 area code.
           *
<span class="line-modified">!          * &lt;p&gt;The country value in the {@code Locale} created by the</span>
<span class="line-modified">!          * {@code Builder} is always normalized to upper case.</span>
           *
           * @param region the region
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code region} is ill-formed</span>
           */
          public Builder setRegion(String region) {
              try {
                  localeBuilder.setRegion(region);
              } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2637,25 ***</span>
              return this;
          }
  
          /**
           * Sets the variant.  If variant is null or the empty string, the
<span class="line-modified">!          * variant in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise, it</span>
           * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;
           * subtags, or an exception is thrown.
           *
<span class="line-modified">!          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if &lt;code&gt;variant&lt;/code&gt;</span>
           * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
           * and normalizes the value to lowercase letters.  However,
<span class="line-modified">!          * the &lt;code&gt;Locale&lt;/code&gt; class does not impose any syntactic</span>
           * restriction on variant, and the variant value in
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt; is case sensitive.  To set such a variant,</span>
           * use a Locale constructor.
           *
           * @param variant the variant
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;variant&lt;/code&gt; is ill-formed</span>
           */
          public Builder setVariant(String variant) {
              try {
                  localeBuilder.setVariant(variant);
              } catch (LocaleSyntaxException e) {
<span class="line-new-header">--- 2677,25 ---</span>
              return this;
          }
  
          /**
           * Sets the variant.  If variant is null or the empty string, the
<span class="line-modified">!          * variant in this {@code Builder} is removed.  Otherwise, it</span>
           * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;
           * subtags, or an exception is thrown.
           *
<span class="line-modified">!          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if {@code variant}</span>
           * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
           * and normalizes the value to lowercase letters.  However,
<span class="line-modified">!          * the {@code Locale} class does not impose any syntactic</span>
           * restriction on variant, and the variant value in
<span class="line-modified">!          * {@code Locale} is case sensitive.  To set such a variant,</span>
           * use a Locale constructor.
           *
           * @param variant the variant
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code variant} is ill-formed</span>
           */
          public Builder setVariant(String variant) {
              try {
                  localeBuilder.setVariant(variant);
              } catch (LocaleSyntaxException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2681,12 ***</span>
           * eight alphanumeric characters, not two to eight as in the general case.
           *
           * @param key the extension key
           * @param value the extension value
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; is illegal</span>
<span class="line-modified">!          * or &lt;code&gt;value&lt;/code&gt; is ill-formed</span>
           * @see #setUnicodeLocaleKeyword(String, String)
           */
          public Builder setExtension(char key, String value) {
              try {
                  localeBuilder.setExtension(key, value);
<span class="line-new-header">--- 2721,12 ---</span>
           * eight alphanumeric characters, not two to eight as in the general case.
           *
           * @param key the extension key
           * @param value the extension value
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code key} is illegal</span>
<span class="line-modified">!          * or {@code value} is ill-formed</span>
           * @see #setUnicodeLocaleKeyword(String, String)
           */
          public Builder setExtension(char key, String value) {
              try {
                  localeBuilder.setExtension(key, value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2710,13 ***</span>
           * extension.
           *
           * @param key the Unicode locale key
           * @param type the Unicode locale type
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;</span>
           * is ill-formed
<span class="line-modified">!          * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
           * @see #setExtension(char, String)
           */
          public Builder setUnicodeLocaleKeyword(String key, String type) {
              try {
                  localeBuilder.setUnicodeLocaleKeyword(key, type);
<span class="line-new-header">--- 2750,13 ---</span>
           * extension.
           *
           * @param key the Unicode locale key
           * @param type the Unicode locale type
           * @return This builder.
<span class="line-modified">!          * @throws IllformedLocaleException if {@code key} or {@code type}</span>
           * is ill-formed
<span class="line-modified">!          * @throws NullPointerException if {@code key} is null</span>
           * @see #setExtension(char, String)
           */
          public Builder setUnicodeLocaleKeyword(String key, String type) {
              try {
                  localeBuilder.setUnicodeLocaleKeyword(key, type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2732,12 ***</span>
           * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
           * is thrown.
           *
           * @param attribute the attribute
           * @return This builder.
<span class="line-modified">!          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
           * @see #setExtension(char, String)
           */
          public Builder addUnicodeLocaleAttribute(String attribute) {
              try {
                  localeBuilder.addUnicodeLocaleAttribute(attribute);
<span class="line-new-header">--- 2772,12 ---</span>
           * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
           * is thrown.
           *
           * @param attribute the attribute
           * @return This builder.
<span class="line-modified">!          * @throws NullPointerException if {@code attribute} is null</span>
<span class="line-modified">!          * @throws IllformedLocaleException if {@code attribute} is ill-formed</span>
           * @see #setExtension(char, String)
           */
          public Builder addUnicodeLocaleAttribute(String attribute) {
              try {
                  localeBuilder.addUnicodeLocaleAttribute(attribute);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2755,12 ***</span>
           *
           * &lt;p&gt;Attribute comparison for removal is case-insensitive.
           *
           * @param attribute the attribute
           * @return This builder.
<span class="line-modified">!          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">!          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
           * @see #setExtension(char, String)
           */
          public Builder removeUnicodeLocaleAttribute(String attribute) {
              Objects.requireNonNull(attribute);
              try {
<span class="line-new-header">--- 2795,12 ---</span>
           *
           * &lt;p&gt;Attribute comparison for removal is case-insensitive.
           *
           * @param attribute the attribute
           * @return This builder.
<span class="line-modified">!          * @throws NullPointerException if {@code attribute} is null</span>
<span class="line-modified">!          * @throws IllformedLocaleException if {@code attribute} is ill-formed</span>
           * @see #setExtension(char, String)
           */
          public Builder removeUnicodeLocaleAttribute(String attribute) {
              Objects.requireNonNull(attribute);
              try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2792,11 ***</span>
              localeBuilder.clearExtensions();
              return this;
          }
  
          /**
<span class="line-modified">!          * Returns an instance of &lt;code&gt;Locale&lt;/code&gt; created from the fields set</span>
           * on this builder.
           *
           * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
           * when constructing a Locale. (Grandfathered tags are handled in
           * {@link #setLanguageTag}.)
<span class="line-new-header">--- 2832,11 ---</span>
              localeBuilder.clearExtensions();
              return this;
          }
  
          /**
<span class="line-modified">!          * Returns an instance of {@code Locale} created from the fields set</span>
           * on this builder.
           *
           * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
           * when constructing a Locale. (Grandfathered tags are handled in
           * {@link #setLanguageTag}.)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3440,11 ***</span>
       * tag using the lookup mechanism defined in RFC 4647.
       *
       * @param priorityList user&#39;s Language Priority List in which each language
       *     tag is sorted in descending order based on priority or weight
       * @param locales {@code Locale} instances used for matching
<span class="line-modified">!      * @return the best matching &lt;code&gt;Locale&lt;/code&gt; instance chosen based on</span>
       *     priority or weight, or {@code null} if nothing matches.
       * @throws NullPointerException if {@code priorityList} or {@code tags} is
       *     {@code null}
       *
       * @since 1.8
<span class="line-new-header">--- 3480,11 ---</span>
       * tag using the lookup mechanism defined in RFC 4647.
       *
       * @param priorityList user&#39;s Language Priority List in which each language
       *     tag is sorted in descending order based on priority or weight
       * @param locales {@code Locale} instances used for matching
<span class="line-modified">!      * @return the best matching {@code Locale} instance chosen based on</span>
       *     priority or weight, or {@code null} if nothing matches.
       * @throws NullPointerException if {@code priorityList} or {@code tags} is
       *     {@code null}
       *
       * @since 1.8
</pre>
<center><a href="ListResourceBundle.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LongSummaryStatistics.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
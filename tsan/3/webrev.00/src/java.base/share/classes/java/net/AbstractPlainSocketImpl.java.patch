diff a/src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java b/src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java
--- a/src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java
+++ b/src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,27 +28,34 @@
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Objects;
 import java.util.Set;
 
 import sun.net.ConnectionResetException;
 import sun.net.NetHooks;
+import sun.net.PlatformSocketImpl;
 import sun.net.ResourceManager;
+import sun.net.ext.ExtendedSocketOptions;
+import sun.net.util.IPAddressUtil;
 import sun.net.util.SocketExceptions;
 
 /**
  * Default Socket Implementation. This implementation does
  * not implement any security checks.
  * Note this class should <b>NOT</b> be public.
  *
  * @author  Steven B. Byrne
  */
-abstract class AbstractPlainSocketImpl extends SocketImpl {
+abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {
     /* instance variable for SO_TIMEOUT */
     int timeout;   // timeout in millisec
     // traffic class
     private int trafficClass;
 
@@ -68,25 +75,28 @@
     protected boolean closePending = false;
 
     /* indicates connection reset state */
     private volatile boolean connectionReset;
 
+    /* indicates whether impl is bound  */
+    boolean isBound;
+
+    /* indicates whether impl is connected  */
+    volatile boolean isConnected;
+
    /* whether this Socket is a stream (TCP) socket or not (UDP)
     */
     protected boolean stream;
 
+    /* whether this is a server or not */
+    final boolean isServer;
+
     /**
      * Load net library into runtime.
      */
     static {
-        java.security.AccessController.doPrivileged(
-            new java.security.PrivilegedAction<>() {
-                public Void run() {
-                    System.loadLibrary("net");
-                    return null;
-                }
-            });
+        jdk.internal.loader.BootLoader.loadLibrary("net");
     }
 
     private static volatile boolean checkedReusePort;
     private static volatile boolean isReusePortAvailable;
 
@@ -99,28 +109,12 @@
             checkedReusePort = true;
         }
         return isReusePortAvailable;
     }
 
-    /**
-     * Returns a set of SocketOptions supported by this impl and by this impl's
-     * socket (Socket or ServerSocket)
-     *
-     * @return a Set of SocketOptions
-     */
-    @Override
-    protected Set<SocketOption<?>> supportedOptions() {
-        Set<SocketOption<?>> options;
-        if (isReusePortAvailable()) {
-            options = new HashSet<>();
-            options.addAll(super.supportedOptions());
-            options.add(StandardSocketOptions.SO_REUSEPORT);
-            options = Collections.unmodifiableSet(options);
-        } else {
-            options = super.supportedOptions();
-        }
-        return options;
+    AbstractPlainSocketImpl(boolean isServer) {
+        this.isServer = isServer;
     }
 
     /**
      * Creates a socket with a boolean that specifies whether this
      * is a stream socket (true) or an unconnected UDP socket (false).
@@ -131,25 +125,21 @@
             ResourceManager.beforeUdpCreate();
             // only create the fd after we know we will be able to create the socket
             fd = new FileDescriptor();
             try {
                 socketCreate(false);
-                SocketCleanable.register(fd);
+                SocketCleanable.register(fd, false);
             } catch (IOException ioe) {
                 ResourceManager.afterUdpClose();
                 fd = null;
                 throw ioe;
             }
         } else {
             fd = new FileDescriptor();
             socketCreate(true);
-            SocketCleanable.register(fd);
+            SocketCleanable.register(fd, true);
         }
-        if (socket != null)
-            socket.setCreated();
-        if (serverSocket != null)
-            serverSocket.setCreated();
     }
 
     /**
      * Creates a socket and connects it to the specified port on
      * the specified host.
@@ -160,12 +150,16 @@
         throws UnknownHostException, IOException
     {
         boolean connected = false;
         try {
             InetAddress address = InetAddress.getByName(host);
-            this.port = port;
+            // recording this.address as supplied by caller before calling connect
             this.address = address;
+            this.port = port;
+            if (address.isLinkLocalAddress()) {
+                address = IPAddressUtil.toScopedAddress(address);
+            }
 
             connectToAddress(address, port, timeout);
             connected = true;
         } finally {
             if (!connected) {
@@ -174,25 +168,31 @@
                 } catch (IOException ioe) {
                     /* Do nothing. If connect threw an exception then
                        it will be passed up the call stack */
                 }
             }
+            isConnected = connected;
         }
     }
 
     /**
      * Creates a socket and connects it to the specified address on
      * the specified port.
      * @param address the address
      * @param port the specified port
      */
     protected void connect(InetAddress address, int port) throws IOException {
-        this.port = port;
+        // recording this.address as supplied by caller before calling connect
         this.address = address;
+        this.port = port;
+        if (address.isLinkLocalAddress()) {
+            address = IPAddressUtil.toScopedAddress(address);
+        }
 
         try {
             connectToAddress(address, port, timeout);
+            isConnected = true;
             return;
         } catch (IOException e) {
             // everything failed
             close();
             throw e;
@@ -216,24 +216,29 @@
             if (address == null || !(address instanceof InetSocketAddress))
                 throw new IllegalArgumentException("unsupported address type");
             InetSocketAddress addr = (InetSocketAddress) address;
             if (addr.isUnresolved())
                 throw new UnknownHostException(addr.getHostName());
+            // recording this.address as supplied by caller before calling connect
+            InetAddress ia = addr.getAddress();
+            this.address = ia;
             this.port = addr.getPort();
-            this.address = addr.getAddress();
-
-            connectToAddress(this.address, port, timeout);
+            if (ia.isLinkLocalAddress()) {
+                ia = IPAddressUtil.toScopedAddress(ia);
+            }
+            connectToAddress(ia, port, timeout);
             connected = true;
         } finally {
             if (!connected) {
                 try {
                     close();
                 } catch (IOException ioe) {
                     /* Do nothing. If connect threw an exception then
                        it will be passed up the call stack */
                 }
             }
+            isConnected = connected;
         }
     }
 
     private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
         if (address.isAnyLocalAddress()) {
@@ -379,19 +384,142 @@
         default:
             return null;
         }
     }
 
+    static final ExtendedSocketOptions extendedOptions =
+            ExtendedSocketOptions.getInstance();
+
+    private static final Set<SocketOption<?>> clientSocketOptions = clientSocketOptions();
+    private static final Set<SocketOption<?>> serverSocketOptions = serverSocketOptions();
+
+    private static Set<SocketOption<?>> clientSocketOptions() {
+        HashSet<SocketOption<?>> options = new HashSet<>();
+        options.add(StandardSocketOptions.SO_KEEPALIVE);
+        options.add(StandardSocketOptions.SO_SNDBUF);
+        options.add(StandardSocketOptions.SO_RCVBUF);
+        options.add(StandardSocketOptions.SO_REUSEADDR);
+        options.add(StandardSocketOptions.SO_LINGER);
+        options.add(StandardSocketOptions.IP_TOS);
+        options.add(StandardSocketOptions.TCP_NODELAY);
+        if (isReusePortAvailable())
+            options.add(StandardSocketOptions.SO_REUSEPORT);
+        options.addAll(ExtendedSocketOptions.clientSocketOptions());
+        return Collections.unmodifiableSet(options);
+    }
+
+    private static Set<SocketOption<?>> serverSocketOptions() {
+        HashSet<SocketOption<?>> options = new HashSet<>();
+        options.add(StandardSocketOptions.SO_RCVBUF);
+        options.add(StandardSocketOptions.SO_REUSEADDR);
+        options.add(StandardSocketOptions.IP_TOS);
+        if (isReusePortAvailable())
+            options.add(StandardSocketOptions.SO_REUSEPORT);
+        options.addAll(ExtendedSocketOptions.serverSocketOptions());
+        return Collections.unmodifiableSet(options);
+    }
+
+    @Override
+    protected Set<SocketOption<?>> supportedOptions() {
+        if (isServer)
+            return serverSocketOptions;
+        else
+            return clientSocketOptions;
+    }
+
+    @Override
+    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {
+        Objects.requireNonNull(name);
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        if (!name.type().isInstance(value))
+            throw new IllegalArgumentException("Invalid value '" + value + "'");
+
+        if (isClosedOrPending())
+            throw new SocketException("Socket closed");
+
+        if (name == StandardSocketOptions.SO_KEEPALIVE) {
+            setOption(SocketOptions.SO_KEEPALIVE, value);
+        } else if (name == StandardSocketOptions.SO_SNDBUF) {
+            if (((Integer)value).intValue() < 0)
+                throw new IllegalArgumentException("Invalid send buffer size:" + value);
+            setOption(SocketOptions.SO_SNDBUF, value);
+        } else if (name == StandardSocketOptions.SO_RCVBUF) {
+            if (((Integer)value).intValue() < 0)
+                throw new IllegalArgumentException("Invalid recv buffer size:" + value);
+            setOption(SocketOptions.SO_RCVBUF, value);
+        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
+            setOption(SocketOptions.SO_REUSEADDR, value);
+        } else if (name == StandardSocketOptions.SO_REUSEPORT) {
+            setOption(SocketOptions.SO_REUSEPORT, value);
+        } else if (name == StandardSocketOptions.SO_LINGER ) {
+            if (((Integer)value).intValue() < 0)
+                setOption(SocketOptions.SO_LINGER, false);
+            else
+                setOption(SocketOptions.SO_LINGER, value);
+        } else if (name == StandardSocketOptions.IP_TOS) {
+            int i = ((Integer)value).intValue();
+            if (i < 0 || i > 255)
+                throw new IllegalArgumentException("Invalid IP_TOS value: " + value);
+            setOption(SocketOptions.IP_TOS, value);
+        } else if (name == StandardSocketOptions.TCP_NODELAY) {
+            setOption(SocketOptions.TCP_NODELAY, value);
+        } else if (extendedOptions.isOptionSupported(name)) {
+            extendedOptions.setOption(fd, name, value);
+        } else {
+            throw new AssertionError("unknown option: " + name);
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    protected <T> T getOption(SocketOption<T> name) throws IOException {
+        Objects.requireNonNull(name);
+        if (!supportedOptions().contains(name))
+            throw new UnsupportedOperationException("'" + name + "' not supported");
+
+        if (isClosedOrPending())
+            throw new SocketException("Socket closed");
+
+        if (name == StandardSocketOptions.SO_KEEPALIVE) {
+            return (T)getOption(SocketOptions.SO_KEEPALIVE);
+        } else if (name == StandardSocketOptions.SO_SNDBUF) {
+            return (T)getOption(SocketOptions.SO_SNDBUF);
+        } else if (name == StandardSocketOptions.SO_RCVBUF) {
+            return (T)getOption(SocketOptions.SO_RCVBUF);
+        } else if (name == StandardSocketOptions.SO_REUSEADDR) {
+            return (T)getOption(SocketOptions.SO_REUSEADDR);
+        } else if (name == StandardSocketOptions.SO_REUSEPORT) {
+            return (T)getOption(SocketOptions.SO_REUSEPORT);
+        } else if (name == StandardSocketOptions.SO_LINGER) {
+            Object value = getOption(SocketOptions.SO_LINGER);
+            if (value instanceof Boolean) {
+                assert ((Boolean)value).booleanValue() == false;
+                value = -1;
+            }
+            return (T)value;
+        } else if (name == StandardSocketOptions.IP_TOS) {
+            return (T)getOption(SocketOptions.IP_TOS);
+        } else if (name == StandardSocketOptions.TCP_NODELAY) {
+            return (T)getOption(SocketOptions.TCP_NODELAY);
+        } else if (extendedOptions.isOptionSupported(name)) {
+            return (T) extendedOptions.getOption(fd, name);
+        } else {
+            throw new AssertionError("unknown option: " + name);
+        }
+    }
+
     /**
      * The workhorse of the connection operation.  Tries several times to
      * establish a connection to the given <host, port>.  If unsuccessful,
      * throws an IOException indicating what went wrong.
      */
 
     synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
         synchronized (fdLock) {
-            if (!closePending && (socket == null || !socket.isBound())) {
+            if (!closePending && !isBound) {
                 NetHooks.beforeTcpConnect(fd, address, port);
             }
         }
         try {
             acquireFD();
@@ -401,18 +529,10 @@
                 synchronized (fdLock) {
                     if (closePending) {
                         throw new SocketException ("Socket closed");
                     }
                 }
-                // If we have a ref. to the Socket, then sets the flags
-                // created, bound & connected to true.
-                // This is normally done in Socket.connect() but some
-                // subclasses of Socket may call impl.connect() directly!
-                if (socket != null) {
-                    socket.setBound();
-                    socket.setConnected();
-                }
             } finally {
                 releaseFD();
             }
         } catch (IOException e) {
             close();
@@ -427,19 +547,19 @@
      */
     protected synchronized void bind(InetAddress address, int lport)
         throws IOException
     {
        synchronized (fdLock) {
-            if (!closePending && (socket == null || !socket.isBound())) {
+            if (!closePending && !isBound) {
                 NetHooks.beforeTcpBind(fd, address, lport);
             }
         }
+        if (address.isLinkLocalAddress()) {
+            address = IPAddressUtil.toScopedAddress(address);
+        }
         socketBind(address, lport);
-        if (socket != null)
-            socket.setBound();
-        if (serverSocket != null)
-            serverSocket.setBound();
+        isBound = true;
     }
 
     /**
      * Listens, for a specified amount of time, for connections.
      * @param count the amount of time to listen for connections
@@ -448,19 +568,21 @@
         socketListen(count);
     }
 
     /**
      * Accepts connections.
-     * @param s the connection
+     * @param si the socket impl
      */
-    protected void accept(SocketImpl s) throws IOException {
+    protected void accept(SocketImpl si) throws IOException {
+        si.fd = new FileDescriptor();
         acquireFD();
         try {
-            socketAccept(s);
+            socketAccept(si);
         } finally {
             releaseFD();
         }
+        SocketCleanable.register(si.fd, true);
     }
 
     /**
      * Gets an InputStream for this socket.
      */
@@ -468,12 +590,18 @@
         synchronized (fdLock) {
             if (isClosedOrPending())
                 throw new IOException("Socket Closed");
             if (shut_rd)
                 throw new IOException("Socket input is shutdown");
-            if (socketInputStream == null)
-                socketInputStream = new SocketInputStream(this);
+            if (socketInputStream == null) {
+                PrivilegedExceptionAction<SocketInputStream> pa = () -> new SocketInputStream(this);
+                try {
+                    socketInputStream = AccessController.doPrivileged(pa);
+                } catch (PrivilegedActionException e) {
+                    throw (IOException) e.getCause();
+                }
+            }
         }
         return socketInputStream;
     }
 
     void setInputStream(SocketInputStream in) {
@@ -487,12 +615,18 @@
         synchronized (fdLock) {
             if (isClosedOrPending())
                 throw new IOException("Socket Closed");
             if (shut_wr)
                 throw new IOException("Socket output is shutdown");
-            if (socketOutputStream == null)
-                socketOutputStream = new SocketOutputStream(this);
+            if (socketOutputStream == null) {
+                PrivilegedExceptionAction<SocketOutputStream> pa = () -> new SocketOutputStream(this);
+                try {
+                    socketOutputStream = AccessController.doPrivileged(pa);
+                } catch (PrivilegedActionException e) {
+                    throw (IOException) e.getCause();
+                }
+            }
         }
         return socketOutputStream;
     }
 
     void setFileDescriptor(FileDescriptor fd) {
@@ -547,13 +681,10 @@
      * Closes the socket.
      */
     protected void close() throws IOException {
         synchronized(fdLock) {
             if (fd != null) {
-                if (!stream) {
-                    ResourceManager.afterUdpClose();
-                }
                 if (fdUseCount == 0) {
                     if (closePending) {
                         return;
                     }
                     closePending = true;
@@ -587,19 +718,14 @@
                 }
             }
         }
     }
 
-    void reset() throws IOException {
-        if (fd != null) {
-            socketClose();
-        }
-        fd = null;
-        super.reset();
+    void reset() {
+        throw new InternalError("should not get here");
     }
 
-
     /**
      * Shutdown read-half of the socket connection;
      */
     protected void shutdownInput() throws IOException {
       if (fd != null) {
@@ -709,14 +835,20 @@
     /*
      * Close the socket (and release the file descriptor).
      */
     protected void socketClose() throws IOException {
         SocketCleanable.unregister(fd);
-        socketClose0(false);
+        try {
+            socketClose0(false);
+        } finally {
+            if (!stream) {
+                ResourceManager.afterUdpClose();
+            }
+        }
     }
 
-    abstract void socketCreate(boolean isServer) throws IOException;
+    abstract void socketCreate(boolean stream) throws IOException;
     abstract void socketConnect(InetAddress address, int port, int timeout)
         throws IOException;
     abstract void socketBind(InetAddress address, int port)
         throws IOException;
     abstract void socketListen(int count)

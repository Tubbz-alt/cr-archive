<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/DataInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DataInput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataOutput.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/DataInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data input stream lets an application read primitive Java data
 30  * types from an underlying input stream in a machine-independent
 31  * way. An application uses a data output stream to write data that
 32  * can later be read by a data input stream.
 33  * &lt;p&gt;
 34  * DataInputStream is not necessarily safe for multithreaded access.
 35  * Thread safety is optional and is the responsibility of users of
 36  * methods in this class.
 37  *
 38  * @author  Arthur van Hoff
 39  * @see     java.io.DataOutputStream
 40  * @since   1.0
 41  */
<span class="line-modified"> 42 public</span>
<span class="line-removed"> 43 class DataInputStream extends FilterInputStream implements DataInput {</span>
 44 
 45     /**
 46      * Creates a DataInputStream that uses the specified
 47      * underlying InputStream.
 48      *
 49      * @param  in   the specified input stream
 50      */
 51     public DataInputStream(InputStream in) {
 52         super(in);
 53     }
 54 
 55     /**
 56      * working arrays initialized on demand by readUTF
 57      */
 58     private byte bytearr[] = new byte[80];
 59     private char chararr[] = new char[80];
 60 
 61     /**
 62      * Reads some number of bytes from the contained input stream and
<span class="line-modified"> 63      * stores them into the buffer array &lt;code&gt;b&lt;/code&gt;. The number of</span>
 64      * bytes actually read is returned as an integer. This method blocks
 65      * until input data is available, end of file is detected, or an
 66      * exception is thrown.
 67      *
<span class="line-modified"> 68      * &lt;p&gt;If &lt;code&gt;b&lt;/code&gt; is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is</span>
<span class="line-modified"> 69      * thrown. If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are</span>
<span class="line-modified"> 70      * read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt</span>
 71      * to read at least one byte. If no byte is available because the
<span class="line-modified"> 72      * stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned;</span>
<span class="line-modified"> 73      * otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
 74      *
<span class="line-modified"> 75      * &lt;p&gt;The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span>
<span class="line-modified"> 76      * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified"> 77      * is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;code&gt;k&lt;/code&gt;</span>
 78      * be the number of bytes actually read; these bytes will be stored in
<span class="line-modified"> 79      * elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[k-1]&lt;/code&gt;, leaving</span>
<span class="line-modified"> 80      * elements &lt;code&gt;b[k]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt;</span>
 81      * unaffected.
 82      *
<span class="line-modified"> 83      * &lt;p&gt;The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:</span>
 84      * &lt;blockquote&gt;&lt;pre&gt;
 85      * read(b, 0, b.length)
 86      * &lt;/pre&gt;&lt;/blockquote&gt;
 87      *
 88      * @param      b   the buffer into which the data is read.
 89      * @return     the total number of bytes read into the buffer, or
<span class="line-modified"> 90      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
 91      *             of the stream has been reached.
<span class="line-modified"> 92      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified"> 93      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified"> 94      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified"> 95      * error occurs.</span>
 96      * @see        java.io.FilterInputStream#in
 97      * @see        java.io.InputStream#read(byte[], int, int)
 98      */
 99     public final int read(byte b[]) throws IOException {
100         return in.read(b, 0, b.length);
101     }
102 
103     /**
<span class="line-modified">104      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the contained</span>
105      * input stream into an array of bytes.  An attempt is made to read
<span class="line-modified">106      * as many as &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read,</span>
107      * possibly zero. The number of bytes actually read is returned as an
108      * integer.
109      *
110      * &lt;p&gt; This method blocks until input data is available, end of file is
111      * detected, or an exception is thrown.
112      *
<span class="line-modified">113      * &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and</span>
<span class="line-modified">114      * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span>
115      * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">116      * file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one</span>
<span class="line-modified">117      * byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span>
118      *
<span class="line-modified">119      * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the</span>
<span class="line-modified">120      * next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read</span>
<span class="line-modified">121      * is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
122      * bytes actually read; these bytes will be stored in elements
<span class="line-modified">123      * &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span>
<span class="line-modified">124      * leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span>
<span class="line-modified">125      * &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.</span>
126      *
<span class="line-modified">127      * &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through</span>
<span class="line-modified">128      * &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through</span>
<span class="line-modified">129      * &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</span>
130      *
131      * @param      b     the buffer into which the data is read.
<span class="line-modified">132      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
133      * @param      len   the maximum number of bytes read.
134      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">135      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end</span>
136      *             of the stream has been reached.
<span class="line-modified">137      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">138      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">139      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">140      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">141      * @exception  IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">142      * other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">143      * input stream does not support reading after close, or another I/O</span>
<span class="line-modified">144      * error occurs.</span>
145      * @see        java.io.FilterInputStream#in
146      * @see        java.io.InputStream#read(byte[], int, int)
147      */
148     public final int read(byte b[], int off, int len) throws IOException {
149         return in.read(b, off, len);
150     }
151 
152     /**
153      * See the general contract of the {@code readFully}
154      * method of {@code DataInput}.
155      * &lt;p&gt;
156      * Bytes
157      * for this operation are read from the contained
158      * input stream.
159      *
160      * @param   b   the buffer into which the data is read.
161      * @throws  NullPointerException if {@code b} is {@code null}.
162      * @throws  EOFException  if this input stream reaches the end before
163      *          reading all the bytes.
164      * @throws  IOException   the stream has been closed and the contained
165      *          input stream does not support reading after close, or
166      *          another I/O error occurs.
167      * @see     java.io.FilterInputStream#in
168      */
169     public final void readFully(byte b[]) throws IOException {
170         readFully(b, 0, b.length);
171     }
172 
173     /**
174      * See the general contract of the {@code readFully}
175      * method of {@code DataInput}.
176      * &lt;p&gt;
177      * Bytes
178      * for this operation are read from the contained
179      * input stream.
180      *
181      * @param      b     the buffer into which the data is read.
182      * @param      off   the start offset in the data array {@code b}.
183      * @param      len   the number of bytes to read.
<span class="line-modified">184      * @exception  NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">185      * @exception  IndexOutOfBoundsException if {@code off} is negative,</span>
186      *             {@code len} is negative, or {@code len} is greater than
187      *             {@code b.length - off}.
<span class="line-modified">188      * @exception  EOFException  if this input stream reaches the end before</span>
189      *             reading all the bytes.
<span class="line-modified">190      * @exception  IOException   the stream has been closed and the contained</span>
191      *             input stream does not support reading after close, or
192      *             another I/O error occurs.
193      * @see        java.io.FilterInputStream#in
194      */
195     public final void readFully(byte b[], int off, int len) throws IOException {
196         if (len &lt; 0)
197             throw new IndexOutOfBoundsException();
198         int n = 0;
199         while (n &lt; len) {
200             int count = in.read(b, off + n, len - n);
201             if (count &lt; 0)
202                 throw new EOFException();
203             n += count;
204         }
205     }
206 
207     /**
<span class="line-modified">208      * See the general contract of the &lt;code&gt;skipBytes&lt;/code&gt;</span>
<span class="line-modified">209      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
210      * &lt;p&gt;
211      * Bytes for this operation are read from the contained
212      * input stream.
213      *
214      * @param      n   the number of bytes to be skipped.
215      * @return     the actual number of bytes skipped.
<span class="line-modified">216      * @exception  IOException  if the contained input stream does not support</span>
217      *             seek, or the stream has been closed and
218      *             the contained input stream does not support
219      *             reading after close, or another I/O error occurs.
220      */
221     public final int skipBytes(int n) throws IOException {
222         int total = 0;
223         int cur = 0;
224 
225         while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) {
226             total += cur;
227         }
228 
229         return total;
230     }
231 
232     /**
<span class="line-modified">233      * See the general contract of the &lt;code&gt;readBoolean&lt;/code&gt;</span>
<span class="line-modified">234      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
235      * &lt;p&gt;
236      * Bytes for this operation are read from the contained
237      * input stream.
238      *
<span class="line-modified">239      * @return     the &lt;code&gt;boolean&lt;/code&gt; value read.</span>
<span class="line-modified">240      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">241      * @exception  IOException   the stream has been closed and the contained</span>
242      *             input stream does not support reading after close, or
243      *             another I/O error occurs.
244      * @see        java.io.FilterInputStream#in
245      */
246     public final boolean readBoolean() throws IOException {
247         int ch = in.read();
248         if (ch &lt; 0)
249             throw new EOFException();
250         return (ch != 0);
251     }
252 
253     /**
<span class="line-modified">254      * See the general contract of the &lt;code&gt;readByte&lt;/code&gt;</span>
<span class="line-modified">255      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
256      * &lt;p&gt;
257      * Bytes
258      * for this operation are read from the contained
259      * input stream.
260      *
261      * @return     the next byte of this input stream as a signed 8-bit
<span class="line-modified">262      *             &lt;code&gt;byte&lt;/code&gt;.</span>
<span class="line-modified">263      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">264      * @exception  IOException   the stream has been closed and the contained</span>
265      *             input stream does not support reading after close, or
266      *             another I/O error occurs.
267      * @see        java.io.FilterInputStream#in
268      */
269     public final byte readByte() throws IOException {
270         int ch = in.read();
271         if (ch &lt; 0)
272             throw new EOFException();
273         return (byte)(ch);
274     }
275 
276     /**
<span class="line-modified">277      * See the general contract of the &lt;code&gt;readUnsignedByte&lt;/code&gt;</span>
<span class="line-modified">278      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
279      * &lt;p&gt;
280      * Bytes
281      * for this operation are read from the contained
282      * input stream.
283      *
284      * @return     the next byte of this input stream, interpreted as an
285      *             unsigned 8-bit number.
<span class="line-modified">286      * @exception  EOFException  if this input stream has reached the end.</span>
<span class="line-modified">287      * @exception  IOException   the stream has been closed and the contained</span>
288      *             input stream does not support reading after close, or
289      *             another I/O error occurs.
290      * @see         java.io.FilterInputStream#in
291      */
292     public final int readUnsignedByte() throws IOException {
293         int ch = in.read();
294         if (ch &lt; 0)
295             throw new EOFException();
296         return ch;
297     }
298 
299     /**
<span class="line-modified">300      * See the general contract of the &lt;code&gt;readShort&lt;/code&gt;</span>
<span class="line-modified">301      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
302      * &lt;p&gt;
303      * Bytes
304      * for this operation are read from the contained
305      * input stream.
306      *
307      * @return     the next two bytes of this input stream, interpreted as a
308      *             signed 16-bit number.
<span class="line-modified">309      * @exception  EOFException  if this input stream reaches the end before</span>
310      *               reading two bytes.
<span class="line-modified">311      * @exception  IOException   the stream has been closed and the contained</span>
312      *             input stream does not support reading after close, or
313      *             another I/O error occurs.
314      * @see        java.io.FilterInputStream#in
315      */
316     public final short readShort() throws IOException {
317         int ch1 = in.read();
318         int ch2 = in.read();
319         if ((ch1 | ch2) &lt; 0)
320             throw new EOFException();
321         return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
322     }
323 
324     /**
<span class="line-modified">325      * See the general contract of the &lt;code&gt;readUnsignedShort&lt;/code&gt;</span>
<span class="line-modified">326      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
327      * &lt;p&gt;
328      * Bytes
329      * for this operation are read from the contained
330      * input stream.
331      *
332      * @return     the next two bytes of this input stream, interpreted as an
333      *             unsigned 16-bit integer.
<span class="line-modified">334      * @exception  EOFException  if this input stream reaches the end before</span>
335      *             reading two bytes.
<span class="line-modified">336      * @exception  IOException   the stream has been closed and the contained</span>
337      *             input stream does not support reading after close, or
338      *             another I/O error occurs.
339      * @see        java.io.FilterInputStream#in
340      */
341     public final int readUnsignedShort() throws IOException {
342         int ch1 = in.read();
343         int ch2 = in.read();
344         if ((ch1 | ch2) &lt; 0)
345             throw new EOFException();
346         return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
347     }
348 
349     /**
<span class="line-modified">350      * See the general contract of the &lt;code&gt;readChar&lt;/code&gt;</span>
<span class="line-modified">351      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
352      * &lt;p&gt;
353      * Bytes
354      * for this operation are read from the contained
355      * input stream.
356      *
357      * @return     the next two bytes of this input stream, interpreted as a
<span class="line-modified">358      *             &lt;code&gt;char&lt;/code&gt;.</span>
<span class="line-modified">359      * @exception  EOFException  if this input stream reaches the end before</span>
360      *               reading two bytes.
<span class="line-modified">361      * @exception  IOException   the stream has been closed and the contained</span>
362      *             input stream does not support reading after close, or
363      *             another I/O error occurs.
364      * @see        java.io.FilterInputStream#in
365      */
366     public final char readChar() throws IOException {
367         int ch1 = in.read();
368         int ch2 = in.read();
369         if ((ch1 | ch2) &lt; 0)
370             throw new EOFException();
371         return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
372     }
373 
374     /**
<span class="line-modified">375      * See the general contract of the &lt;code&gt;readInt&lt;/code&gt;</span>
<span class="line-modified">376      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
377      * &lt;p&gt;
378      * Bytes
379      * for this operation are read from the contained
380      * input stream.
381      *
382      * @return     the next four bytes of this input stream, interpreted as an
<span class="line-modified">383      *             &lt;code&gt;int&lt;/code&gt;.</span>
<span class="line-modified">384      * @exception  EOFException  if this input stream reaches the end before</span>
385      *               reading four bytes.
<span class="line-modified">386      * @exception  IOException   the stream has been closed and the contained</span>
387      *             input stream does not support reading after close, or
388      *             another I/O error occurs.
389      * @see        java.io.FilterInputStream#in
390      */
391     public final int readInt() throws IOException {
392         int ch1 = in.read();
393         int ch2 = in.read();
394         int ch3 = in.read();
395         int ch4 = in.read();
396         if ((ch1 | ch2 | ch3 | ch4) &lt; 0)
397             throw new EOFException();
398         return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));
399     }
400 
401     private byte readBuffer[] = new byte[8];
402 
403     /**
<span class="line-modified">404      * See the general contract of the &lt;code&gt;readLong&lt;/code&gt;</span>
<span class="line-modified">405      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
406      * &lt;p&gt;
407      * Bytes
408      * for this operation are read from the contained
409      * input stream.
410      *
411      * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">412      *             &lt;code&gt;long&lt;/code&gt;.</span>
<span class="line-modified">413      * @exception  EOFException  if this input stream reaches the end before</span>
414      *               reading eight bytes.
<span class="line-modified">415      * @exception  IOException   the stream has been closed and the contained</span>
416      *             input stream does not support reading after close, or
417      *             another I/O error occurs.
418      * @see        java.io.FilterInputStream#in
419      */
420     public final long readLong() throws IOException {
421         readFully(readBuffer, 0, 8);
422         return (((long)readBuffer[0] &lt;&lt; 56) +
423                 ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) +
424                 ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) +
425                 ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) +
426                 ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) +
427                 ((readBuffer[5] &amp; 255) &lt;&lt; 16) +
428                 ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
429                 ((readBuffer[7] &amp; 255) &lt;&lt;  0));
430     }
431 
432     /**
<span class="line-modified">433      * See the general contract of the &lt;code&gt;readFloat&lt;/code&gt;</span>
<span class="line-modified">434      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
435      * &lt;p&gt;
436      * Bytes
437      * for this operation are read from the contained
438      * input stream.
439      *
440      * @return     the next four bytes of this input stream, interpreted as a
<span class="line-modified">441      *             &lt;code&gt;float&lt;/code&gt;.</span>
<span class="line-modified">442      * @exception  EOFException  if this input stream reaches the end before</span>
443      *               reading four bytes.
<span class="line-modified">444      * @exception  IOException   the stream has been closed and the contained</span>
445      *             input stream does not support reading after close, or
446      *             another I/O error occurs.
447      * @see        java.io.DataInputStream#readInt()
448      * @see        java.lang.Float#intBitsToFloat(int)
449      */
450     public final float readFloat() throws IOException {
451         return Float.intBitsToFloat(readInt());
452     }
453 
454     /**
<span class="line-modified">455      * See the general contract of the &lt;code&gt;readDouble&lt;/code&gt;</span>
<span class="line-modified">456      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
457      * &lt;p&gt;
458      * Bytes
459      * for this operation are read from the contained
460      * input stream.
461      *
462      * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">463      *             &lt;code&gt;double&lt;/code&gt;.</span>
<span class="line-modified">464      * @exception  EOFException  if this input stream reaches the end before</span>
465      *               reading eight bytes.
<span class="line-modified">466      * @exception  IOException   the stream has been closed and the contained</span>
467      *             input stream does not support reading after close, or
468      *             another I/O error occurs.
469      * @see        java.io.DataInputStream#readLong()
470      * @see        java.lang.Double#longBitsToDouble(long)
471      */
472     public final double readDouble() throws IOException {
473         return Double.longBitsToDouble(readLong());
474     }
475 
476     private char lineBuffer[];
477 
478     /**
<span class="line-modified">479      * See the general contract of the &lt;code&gt;readLine&lt;/code&gt;</span>
<span class="line-modified">480      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
481      * &lt;p&gt;
482      * Bytes
483      * for this operation are read from the contained
484      * input stream.
485      *
486      * @deprecated This method does not properly convert bytes to characters.
487      * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<span class="line-modified">488      * &lt;code&gt;BufferedReader.readLine()&lt;/code&gt; method.  Programs that use the</span>
<span class="line-modified">489      * &lt;code&gt;DataInputStream&lt;/code&gt; class to read lines can be converted to use</span>
<span class="line-modified">490      * the &lt;code&gt;BufferedReader&lt;/code&gt; class by replacing code of the form:</span>
491      * &lt;blockquote&gt;&lt;pre&gt;
492      *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
493      * &lt;/pre&gt;&lt;/blockquote&gt;
494      * with:
495      * &lt;blockquote&gt;&lt;pre&gt;
496      *     BufferedReader d
497      *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
498      * &lt;/pre&gt;&lt;/blockquote&gt;
499      *
500      * @return     the next line of text from this input stream.
<span class="line-modified">501      * @exception  IOException  if an I/O error occurs.</span>
502      * @see        java.io.BufferedReader#readLine()
503      * @see        java.io.FilterInputStream#in
504      */
505     @Deprecated
506     public final String readLine() throws IOException {
507         char buf[] = lineBuffer;
508 
509         if (buf == null) {
510             buf = lineBuffer = new char[128];
511         }
512 
513         int room = buf.length;
514         int offset = 0;
515         int c;
516 
517 loop:   while (true) {
518             switch (c = in.read()) {
519               case -1:
520               case &#39;\n&#39;:
521                 break loop;
</pre>
<hr />
<pre>
531                 break loop;
532 
533               default:
534                 if (--room &lt; 0) {
535                     buf = new char[offset + 128];
536                     room = buf.length - offset - 1;
537                     System.arraycopy(lineBuffer, 0, buf, 0, offset);
538                     lineBuffer = buf;
539                 }
540                 buf[offset++] = (char) c;
541                 break;
542             }
543         }
544         if ((c == -1) &amp;&amp; (offset == 0)) {
545             return null;
546         }
547         return String.copyValueOf(buf, 0, offset);
548     }
549 
550     /**
<span class="line-modified">551      * See the general contract of the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">552      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
553      * &lt;p&gt;
554      * Bytes
555      * for this operation are read from the contained
556      * input stream.
557      *
558      * @return     a Unicode string.
<span class="line-modified">559      * @exception  EOFException  if this input stream reaches the end before</span>
560      *               reading all the bytes.
<span class="line-modified">561      * @exception  IOException   the stream has been closed and the contained</span>
562      *             input stream does not support reading after close, or
563      *             another I/O error occurs.
<span class="line-modified">564      * @exception  UTFDataFormatException if the bytes do not represent a valid</span>
565      *             modified UTF-8 encoding of a string.
566      * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
567      */
568     public final String readUTF() throws IOException {
569         return readUTF(this);
570     }
571 
572     /**
573      * Reads from the
<span class="line-modified">574      * stream &lt;code&gt;in&lt;/code&gt; a representation</span>
575      * of a Unicode  character string encoded in
576      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<span class="line-modified">577      * this string of characters is then returned as a &lt;code&gt;String&lt;/code&gt;.</span>
578      * The details of the modified UTF-8 representation
<span class="line-modified">579      * are  exactly the same as for the &lt;code&gt;readUTF&lt;/code&gt;</span>
<span class="line-modified">580      * method of &lt;code&gt;DataInput&lt;/code&gt;.</span>
581      *
582      * @param      in   a data input stream.
583      * @return     a Unicode string.
<span class="line-modified">584      * @exception  EOFException            if the input stream reaches the end</span>
585      *               before all the bytes.
<span class="line-modified">586      * @exception  IOException   the stream has been closed and the contained</span>
587      *             input stream does not support reading after close, or
588      *             another I/O error occurs.
<span class="line-modified">589      * @exception  UTFDataFormatException  if the bytes do not represent a</span>
590      *               valid modified UTF-8 encoding of a Unicode string.
591      * @see        java.io.DataInputStream#readUnsignedShort()
592      */
593     public static final String readUTF(DataInput in) throws IOException {
594         int utflen = in.readUnsignedShort();
595         byte[] bytearr = null;
596         char[] chararr = null;
597         if (in instanceof DataInputStream) {
598             DataInputStream dis = (DataInputStream)in;
599             if (dis.bytearr.length &lt; utflen){
600                 dis.bytearr = new byte[utflen*2];
601                 dis.chararr = new char[utflen*2];
602             }
603             chararr = dis.chararr;
604             bytearr = dis.bytearr;
605         } else {
606             bytearr = new byte[utflen];
607             chararr = new char[utflen];
608         }
609 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data input stream lets an application read primitive Java data
 30  * types from an underlying input stream in a machine-independent
 31  * way. An application uses a data output stream to write data that
 32  * can later be read by a data input stream.
 33  * &lt;p&gt;
 34  * DataInputStream is not necessarily safe for multithreaded access.
 35  * Thread safety is optional and is the responsibility of users of
 36  * methods in this class.
 37  *
 38  * @author  Arthur van Hoff
 39  * @see     java.io.DataOutputStream
 40  * @since   1.0
 41  */
<span class="line-modified"> 42 public class DataInputStream extends FilterInputStream implements DataInput {</span>

 43 
 44     /**
 45      * Creates a DataInputStream that uses the specified
 46      * underlying InputStream.
 47      *
 48      * @param  in   the specified input stream
 49      */
 50     public DataInputStream(InputStream in) {
 51         super(in);
 52     }
 53 
 54     /**
 55      * working arrays initialized on demand by readUTF
 56      */
 57     private byte bytearr[] = new byte[80];
 58     private char chararr[] = new char[80];
 59 
 60     /**
 61      * Reads some number of bytes from the contained input stream and
<span class="line-modified"> 62      * stores them into the buffer array {@code b}. The number of</span>
 63      * bytes actually read is returned as an integer. This method blocks
 64      * until input data is available, end of file is detected, or an
 65      * exception is thrown.
 66      *
<span class="line-modified"> 67      * &lt;p&gt;If {@code b} is null, a {@code NullPointerException} is</span>
<span class="line-modified"> 68      * thrown. If the length of {@code b} is zero, then no bytes are</span>
<span class="line-modified"> 69      * read and {@code 0} is returned; otherwise, there is an attempt</span>
 70      * to read at least one byte. If no byte is available because the
<span class="line-modified"> 71      * stream is at end of file, the value {@code -1} is returned;</span>
<span class="line-modified"> 72      * otherwise, at least one byte is read and stored into {@code b}.</span>
 73      *
<span class="line-modified"> 74      * &lt;p&gt;The first byte read is stored into element {@code b[0]}, the</span>
<span class="line-modified"> 75      * next one into {@code b[1]}, and so on. The number of bytes read</span>
<span class="line-modified"> 76      * is, at most, equal to the length of {@code b}. Let {@code k}</span>
 77      * be the number of bytes actually read; these bytes will be stored in
<span class="line-modified"> 78      * elements {@code b[0]} through {@code b[k-1]}, leaving</span>
<span class="line-modified"> 79      * elements {@code b[k]} through {@code b[b.length-1]}</span>
 80      * unaffected.
 81      *
<span class="line-modified"> 82      * &lt;p&gt;The {@code read(b)} method has the same effect as:</span>
 83      * &lt;blockquote&gt;&lt;pre&gt;
 84      * read(b, 0, b.length)
 85      * &lt;/pre&gt;&lt;/blockquote&gt;
 86      *
 87      * @param      b   the buffer into which the data is read.
 88      * @return     the total number of bytes read into the buffer, or
<span class="line-modified"> 89      *             {@code -1} if there is no more data because the end</span>
 90      *             of the stream has been reached.
<span class="line-modified"> 91      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified"> 92      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified"> 93      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified"> 94      *             error occurs.</span>
 95      * @see        java.io.FilterInputStream#in
 96      * @see        java.io.InputStream#read(byte[], int, int)
 97      */
 98     public final int read(byte b[]) throws IOException {
 99         return in.read(b, 0, b.length);
100     }
101 
102     /**
<span class="line-modified">103      * Reads up to {@code len} bytes of data from the contained</span>
104      * input stream into an array of bytes.  An attempt is made to read
<span class="line-modified">105      * as many as {@code len} bytes, but a smaller number may be read,</span>
106      * possibly zero. The number of bytes actually read is returned as an
107      * integer.
108      *
109      * &lt;p&gt; This method blocks until input data is available, end of file is
110      * detected, or an exception is thrown.
111      *
<span class="line-modified">112      * &lt;p&gt; If {@code len} is zero, then no bytes are read and</span>
<span class="line-modified">113      * {@code 0} is returned; otherwise, there is an attempt to read at</span>
114      * least one byte. If no byte is available because the stream is at end of
<span class="line-modified">115      * file, the value {@code -1} is returned; otherwise, at least one</span>
<span class="line-modified">116      * byte is read and stored into {@code b}.</span>
117      *
<span class="line-modified">118      * &lt;p&gt; The first byte read is stored into element {@code b[off]}, the</span>
<span class="line-modified">119      * next one into {@code b[off+1]}, and so on. The number of bytes read</span>
<span class="line-modified">120      * is, at most, equal to {@code len}. Let &lt;i&gt;k&lt;/i&gt; be the number of</span>
121      * bytes actually read; these bytes will be stored in elements
<span class="line-modified">122      * {@code b[off]} through {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code -1]},</span>
<span class="line-modified">123      * leaving elements {@code b[off+}&lt;i&gt;k&lt;/i&gt;{@code ]} through</span>
<span class="line-modified">124      * {@code b[off+len-1]} unaffected.</span>
125      *
<span class="line-modified">126      * &lt;p&gt; In every case, elements {@code b[0]} through</span>
<span class="line-modified">127      * {@code b[off]} and elements {@code b[off+len]} through</span>
<span class="line-modified">128      * {@code b[b.length-1]} are unaffected.</span>
129      *
130      * @param      b     the buffer into which the data is read.
<span class="line-modified">131      * @param      off the start offset in the destination array {@code b}</span>
132      * @param      len   the maximum number of bytes read.
133      * @return     the total number of bytes read into the buffer, or
<span class="line-modified">134      *             {@code -1} if there is no more data because the end</span>
135      *             of the stream has been reached.
<span class="line-modified">136      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">137      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">138      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">139      *             {@code b.length - off}</span>
<span class="line-modified">140      * @throws     IOException if the first byte cannot be read for any reason</span>
<span class="line-modified">141      *             other than end of file, the stream has been closed and the underlying</span>
<span class="line-modified">142      *             input stream does not support reading after close, or another I/O</span>
<span class="line-modified">143      *             error occurs.</span>
144      * @see        java.io.FilterInputStream#in
145      * @see        java.io.InputStream#read(byte[], int, int)
146      */
147     public final int read(byte b[], int off, int len) throws IOException {
148         return in.read(b, off, len);
149     }
150 
151     /**
152      * See the general contract of the {@code readFully}
153      * method of {@code DataInput}.
154      * &lt;p&gt;
155      * Bytes
156      * for this operation are read from the contained
157      * input stream.
158      *
159      * @param   b   the buffer into which the data is read.
160      * @throws  NullPointerException if {@code b} is {@code null}.
161      * @throws  EOFException  if this input stream reaches the end before
162      *          reading all the bytes.
163      * @throws  IOException   the stream has been closed and the contained
164      *          input stream does not support reading after close, or
165      *          another I/O error occurs.
166      * @see     java.io.FilterInputStream#in
167      */
168     public final void readFully(byte b[]) throws IOException {
169         readFully(b, 0, b.length);
170     }
171 
172     /**
173      * See the general contract of the {@code readFully}
174      * method of {@code DataInput}.
175      * &lt;p&gt;
176      * Bytes
177      * for this operation are read from the contained
178      * input stream.
179      *
180      * @param      b     the buffer into which the data is read.
181      * @param      off   the start offset in the data array {@code b}.
182      * @param      len   the number of bytes to read.
<span class="line-modified">183      * @throws     NullPointerException if {@code b} is {@code null}.</span>
<span class="line-modified">184      * @throws     IndexOutOfBoundsException if {@code off} is negative,</span>
185      *             {@code len} is negative, or {@code len} is greater than
186      *             {@code b.length - off}.
<span class="line-modified">187      * @throws     EOFException  if this input stream reaches the end before</span>
188      *             reading all the bytes.
<span class="line-modified">189      * @throws     IOException   the stream has been closed and the contained</span>
190      *             input stream does not support reading after close, or
191      *             another I/O error occurs.
192      * @see        java.io.FilterInputStream#in
193      */
194     public final void readFully(byte b[], int off, int len) throws IOException {
195         if (len &lt; 0)
196             throw new IndexOutOfBoundsException();
197         int n = 0;
198         while (n &lt; len) {
199             int count = in.read(b, off + n, len - n);
200             if (count &lt; 0)
201                 throw new EOFException();
202             n += count;
203         }
204     }
205 
206     /**
<span class="line-modified">207      * See the general contract of the {@code skipBytes}</span>
<span class="line-modified">208      * method of {@code DataInput}.</span>
209      * &lt;p&gt;
210      * Bytes for this operation are read from the contained
211      * input stream.
212      *
213      * @param      n   the number of bytes to be skipped.
214      * @return     the actual number of bytes skipped.
<span class="line-modified">215      * @throws     IOException  if the contained input stream does not support</span>
216      *             seek, or the stream has been closed and
217      *             the contained input stream does not support
218      *             reading after close, or another I/O error occurs.
219      */
220     public final int skipBytes(int n) throws IOException {
221         int total = 0;
222         int cur = 0;
223 
224         while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) {
225             total += cur;
226         }
227 
228         return total;
229     }
230 
231     /**
<span class="line-modified">232      * See the general contract of the {@code readBoolean}</span>
<span class="line-modified">233      * method of {@code DataInput}.</span>
234      * &lt;p&gt;
235      * Bytes for this operation are read from the contained
236      * input stream.
237      *
<span class="line-modified">238      * @return     the {@code boolean} value read.</span>
<span class="line-modified">239      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">240      * @throws     IOException   the stream has been closed and the contained</span>
241      *             input stream does not support reading after close, or
242      *             another I/O error occurs.
243      * @see        java.io.FilterInputStream#in
244      */
245     public final boolean readBoolean() throws IOException {
246         int ch = in.read();
247         if (ch &lt; 0)
248             throw new EOFException();
249         return (ch != 0);
250     }
251 
252     /**
<span class="line-modified">253      * See the general contract of the {@code readByte}</span>
<span class="line-modified">254      * method of {@code DataInput}.</span>
255      * &lt;p&gt;
256      * Bytes
257      * for this operation are read from the contained
258      * input stream.
259      *
260      * @return     the next byte of this input stream as a signed 8-bit
<span class="line-modified">261      *             {@code byte}.</span>
<span class="line-modified">262      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">263      * @throws     IOException   the stream has been closed and the contained</span>
264      *             input stream does not support reading after close, or
265      *             another I/O error occurs.
266      * @see        java.io.FilterInputStream#in
267      */
268     public final byte readByte() throws IOException {
269         int ch = in.read();
270         if (ch &lt; 0)
271             throw new EOFException();
272         return (byte)(ch);
273     }
274 
275     /**
<span class="line-modified">276      * See the general contract of the {@code readUnsignedByte}</span>
<span class="line-modified">277      * method of {@code DataInput}.</span>
278      * &lt;p&gt;
279      * Bytes
280      * for this operation are read from the contained
281      * input stream.
282      *
283      * @return     the next byte of this input stream, interpreted as an
284      *             unsigned 8-bit number.
<span class="line-modified">285      * @throws     EOFException  if this input stream has reached the end.</span>
<span class="line-modified">286      * @throws     IOException   the stream has been closed and the contained</span>
287      *             input stream does not support reading after close, or
288      *             another I/O error occurs.
289      * @see         java.io.FilterInputStream#in
290      */
291     public final int readUnsignedByte() throws IOException {
292         int ch = in.read();
293         if (ch &lt; 0)
294             throw new EOFException();
295         return ch;
296     }
297 
298     /**
<span class="line-modified">299      * See the general contract of the {@code readShort}</span>
<span class="line-modified">300      * method of {@code DataInput}.</span>
301      * &lt;p&gt;
302      * Bytes
303      * for this operation are read from the contained
304      * input stream.
305      *
306      * @return     the next two bytes of this input stream, interpreted as a
307      *             signed 16-bit number.
<span class="line-modified">308      * @throws     EOFException  if this input stream reaches the end before</span>
309      *               reading two bytes.
<span class="line-modified">310      * @throws     IOException   the stream has been closed and the contained</span>
311      *             input stream does not support reading after close, or
312      *             another I/O error occurs.
313      * @see        java.io.FilterInputStream#in
314      */
315     public final short readShort() throws IOException {
316         int ch1 = in.read();
317         int ch2 = in.read();
318         if ((ch1 | ch2) &lt; 0)
319             throw new EOFException();
320         return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
321     }
322 
323     /**
<span class="line-modified">324      * See the general contract of the {@code readUnsignedShort}</span>
<span class="line-modified">325      * method of {@code DataInput}.</span>
326      * &lt;p&gt;
327      * Bytes
328      * for this operation are read from the contained
329      * input stream.
330      *
331      * @return     the next two bytes of this input stream, interpreted as an
332      *             unsigned 16-bit integer.
<span class="line-modified">333      * @throws     EOFException  if this input stream reaches the end before</span>
334      *             reading two bytes.
<span class="line-modified">335      * @throws     IOException   the stream has been closed and the contained</span>
336      *             input stream does not support reading after close, or
337      *             another I/O error occurs.
338      * @see        java.io.FilterInputStream#in
339      */
340     public final int readUnsignedShort() throws IOException {
341         int ch1 = in.read();
342         int ch2 = in.read();
343         if ((ch1 | ch2) &lt; 0)
344             throw new EOFException();
345         return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0);
346     }
347 
348     /**
<span class="line-modified">349      * See the general contract of the {@code readChar}</span>
<span class="line-modified">350      * method of {@code DataInput}.</span>
351      * &lt;p&gt;
352      * Bytes
353      * for this operation are read from the contained
354      * input stream.
355      *
356      * @return     the next two bytes of this input stream, interpreted as a
<span class="line-modified">357      *             {@code char}.</span>
<span class="line-modified">358      * @throws     EOFException  if this input stream reaches the end before</span>
359      *               reading two bytes.
<span class="line-modified">360      * @throws     IOException   the stream has been closed and the contained</span>
361      *             input stream does not support reading after close, or
362      *             another I/O error occurs.
363      * @see        java.io.FilterInputStream#in
364      */
365     public final char readChar() throws IOException {
366         int ch1 = in.read();
367         int ch2 = in.read();
368         if ((ch1 | ch2) &lt; 0)
369             throw new EOFException();
370         return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0));
371     }
372 
373     /**
<span class="line-modified">374      * See the general contract of the {@code readInt}</span>
<span class="line-modified">375      * method of {@code DataInput}.</span>
376      * &lt;p&gt;
377      * Bytes
378      * for this operation are read from the contained
379      * input stream.
380      *
381      * @return     the next four bytes of this input stream, interpreted as an
<span class="line-modified">382      *             {@code int}.</span>
<span class="line-modified">383      * @throws     EOFException  if this input stream reaches the end before</span>
384      *               reading four bytes.
<span class="line-modified">385      * @throws     IOException   the stream has been closed and the contained</span>
386      *             input stream does not support reading after close, or
387      *             another I/O error occurs.
388      * @see        java.io.FilterInputStream#in
389      */
390     public final int readInt() throws IOException {
391         int ch1 = in.read();
392         int ch2 = in.read();
393         int ch3 = in.read();
394         int ch4 = in.read();
395         if ((ch1 | ch2 | ch3 | ch4) &lt; 0)
396             throw new EOFException();
397         return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0));
398     }
399 
400     private byte readBuffer[] = new byte[8];
401 
402     /**
<span class="line-modified">403      * See the general contract of the {@code readLong}</span>
<span class="line-modified">404      * method of {@code DataInput}.</span>
405      * &lt;p&gt;
406      * Bytes
407      * for this operation are read from the contained
408      * input stream.
409      *
410      * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">411      *             {@code long}.</span>
<span class="line-modified">412      * @throws     EOFException  if this input stream reaches the end before</span>
413      *               reading eight bytes.
<span class="line-modified">414      * @throws     IOException   the stream has been closed and the contained</span>
415      *             input stream does not support reading after close, or
416      *             another I/O error occurs.
417      * @see        java.io.FilterInputStream#in
418      */
419     public final long readLong() throws IOException {
420         readFully(readBuffer, 0, 8);
421         return (((long)readBuffer[0] &lt;&lt; 56) +
422                 ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) +
423                 ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) +
424                 ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) +
425                 ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) +
426                 ((readBuffer[5] &amp; 255) &lt;&lt; 16) +
427                 ((readBuffer[6] &amp; 255) &lt;&lt;  8) +
428                 ((readBuffer[7] &amp; 255) &lt;&lt;  0));
429     }
430 
431     /**
<span class="line-modified">432      * See the general contract of the {@code readFloat}</span>
<span class="line-modified">433      * method of {@code DataInput}.</span>
434      * &lt;p&gt;
435      * Bytes
436      * for this operation are read from the contained
437      * input stream.
438      *
439      * @return     the next four bytes of this input stream, interpreted as a
<span class="line-modified">440      *             {@code float}.</span>
<span class="line-modified">441      * @throws     EOFException  if this input stream reaches the end before</span>
442      *               reading four bytes.
<span class="line-modified">443      * @throws     IOException   the stream has been closed and the contained</span>
444      *             input stream does not support reading after close, or
445      *             another I/O error occurs.
446      * @see        java.io.DataInputStream#readInt()
447      * @see        java.lang.Float#intBitsToFloat(int)
448      */
449     public final float readFloat() throws IOException {
450         return Float.intBitsToFloat(readInt());
451     }
452 
453     /**
<span class="line-modified">454      * See the general contract of the {@code readDouble}</span>
<span class="line-modified">455      * method of {@code DataInput}.</span>
456      * &lt;p&gt;
457      * Bytes
458      * for this operation are read from the contained
459      * input stream.
460      *
461      * @return     the next eight bytes of this input stream, interpreted as a
<span class="line-modified">462      *             {@code double}.</span>
<span class="line-modified">463      * @throws     EOFException  if this input stream reaches the end before</span>
464      *               reading eight bytes.
<span class="line-modified">465      * @throws     IOException   the stream has been closed and the contained</span>
466      *             input stream does not support reading after close, or
467      *             another I/O error occurs.
468      * @see        java.io.DataInputStream#readLong()
469      * @see        java.lang.Double#longBitsToDouble(long)
470      */
471     public final double readDouble() throws IOException {
472         return Double.longBitsToDouble(readLong());
473     }
474 
475     private char lineBuffer[];
476 
477     /**
<span class="line-modified">478      * See the general contract of the {@code readLine}</span>
<span class="line-modified">479      * method of {@code DataInput}.</span>
480      * &lt;p&gt;
481      * Bytes
482      * for this operation are read from the contained
483      * input stream.
484      *
485      * @deprecated This method does not properly convert bytes to characters.
486      * As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
<span class="line-modified">487      * {@code BufferedReader.readLine()} method.  Programs that use the</span>
<span class="line-modified">488      * {@code DataInputStream} class to read lines can be converted to use</span>
<span class="line-modified">489      * the {@code BufferedReader} class by replacing code of the form:</span>
490      * &lt;blockquote&gt;&lt;pre&gt;
491      *     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
492      * &lt;/pre&gt;&lt;/blockquote&gt;
493      * with:
494      * &lt;blockquote&gt;&lt;pre&gt;
495      *     BufferedReader d
496      *          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
497      * &lt;/pre&gt;&lt;/blockquote&gt;
498      *
499      * @return     the next line of text from this input stream.
<span class="line-modified">500      * @throws     IOException  if an I/O error occurs.</span>
501      * @see        java.io.BufferedReader#readLine()
502      * @see        java.io.FilterInputStream#in
503      */
504     @Deprecated
505     public final String readLine() throws IOException {
506         char buf[] = lineBuffer;
507 
508         if (buf == null) {
509             buf = lineBuffer = new char[128];
510         }
511 
512         int room = buf.length;
513         int offset = 0;
514         int c;
515 
516 loop:   while (true) {
517             switch (c = in.read()) {
518               case -1:
519               case &#39;\n&#39;:
520                 break loop;
</pre>
<hr />
<pre>
530                 break loop;
531 
532               default:
533                 if (--room &lt; 0) {
534                     buf = new char[offset + 128];
535                     room = buf.length - offset - 1;
536                     System.arraycopy(lineBuffer, 0, buf, 0, offset);
537                     lineBuffer = buf;
538                 }
539                 buf[offset++] = (char) c;
540                 break;
541             }
542         }
543         if ((c == -1) &amp;&amp; (offset == 0)) {
544             return null;
545         }
546         return String.copyValueOf(buf, 0, offset);
547     }
548 
549     /**
<span class="line-modified">550      * See the general contract of the {@code readUTF}</span>
<span class="line-modified">551      * method of {@code DataInput}.</span>
552      * &lt;p&gt;
553      * Bytes
554      * for this operation are read from the contained
555      * input stream.
556      *
557      * @return     a Unicode string.
<span class="line-modified">558      * @throws     EOFException  if this input stream reaches the end before</span>
559      *               reading all the bytes.
<span class="line-modified">560      * @throws     IOException   the stream has been closed and the contained</span>
561      *             input stream does not support reading after close, or
562      *             another I/O error occurs.
<span class="line-modified">563      * @throws     UTFDataFormatException if the bytes do not represent a valid</span>
564      *             modified UTF-8 encoding of a string.
565      * @see        java.io.DataInputStream#readUTF(java.io.DataInput)
566      */
567     public final String readUTF() throws IOException {
568         return readUTF(this);
569     }
570 
571     /**
572      * Reads from the
<span class="line-modified">573      * stream {@code in} a representation</span>
574      * of a Unicode  character string encoded in
575      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
<span class="line-modified">576      * this string of characters is then returned as a {@code String}.</span>
577      * The details of the modified UTF-8 representation
<span class="line-modified">578      * are  exactly the same as for the {@code readUTF}</span>
<span class="line-modified">579      * method of {@code DataInput}.</span>
580      *
581      * @param      in   a data input stream.
582      * @return     a Unicode string.
<span class="line-modified">583      * @throws     EOFException            if the input stream reaches the end</span>
584      *               before all the bytes.
<span class="line-modified">585      * @throws     IOException   the stream has been closed and the contained</span>
586      *             input stream does not support reading after close, or
587      *             another I/O error occurs.
<span class="line-modified">588      * @throws     UTFDataFormatException  if the bytes do not represent a</span>
589      *               valid modified UTF-8 encoding of a Unicode string.
590      * @see        java.io.DataInputStream#readUnsignedShort()
591      */
592     public static final String readUTF(DataInput in) throws IOException {
593         int utflen = in.readUnsignedShort();
594         byte[] bytearr = null;
595         char[] chararr = null;
596         if (in instanceof DataInputStream) {
597             DataInputStream dis = (DataInputStream)in;
598             if (dis.bytearr.length &lt; utflen){
599                 dis.bytearr = new byte[utflen*2];
600                 dis.chararr = new char[utflen*2];
601             }
602             chararr = dis.chararr;
603             bytearr = dis.bytearr;
604         } else {
605             bytearr = new byte[utflen];
606             chararr = new char[utflen];
607         }
608 
</pre>
</td>
</tr>
</table>
<center><a href="DataInput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataOutput.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
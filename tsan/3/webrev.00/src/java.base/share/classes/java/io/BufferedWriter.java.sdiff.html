<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/BufferedWriter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BufferedReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ByteArrayOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/BufferedWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 72 
 73     private static int defaultCharBufferSize = 8192;
 74 
 75     /**
 76      * Creates a buffered character-output stream that uses a default-sized
 77      * output buffer.
 78      *
 79      * @param  out  A Writer
 80      */
 81     public BufferedWriter(Writer out) {
 82         this(out, defaultCharBufferSize);
 83     }
 84 
 85     /**
 86      * Creates a new buffered character-output stream that uses an output
 87      * buffer of the given size.
 88      *
 89      * @param  out  A Writer
 90      * @param  sz   Output-buffer size, a positive integer
 91      *
<span class="line-modified"> 92      * @exception  IllegalArgumentException  If {@code sz &lt;= 0}</span>
 93      */
 94     public BufferedWriter(Writer out, int sz) {
 95         super(out);
 96         if (sz &lt;= 0)
 97             throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
 98         this.out = out;
 99         cb = new char[sz];
100         nChars = sz;
101         nextChar = 0;
102     }
103 
104     /** Checks to make sure that the stream has not been closed */
105     private void ensureOpen() throws IOException {
106         if (out == null)
107             throw new IOException(&quot;Stream closed&quot;);
108     }
109 
110     /**
111      * Flushes the output buffer to the underlying character stream, without
112      * flushing the stream itself.  This method is non-private only so that it
113      * may be invoked by PrintStream.
114      */
115     void flushBuffer() throws IOException {
116         synchronized (lock) {
117             ensureOpen();
118             if (nextChar == 0)
119                 return;
120             out.write(cb, 0, nextChar);
121             nextChar = 0;
122         }
123     }
124 
125     /**
126      * Writes a single character.
127      *
<span class="line-modified">128      * @exception  IOException  If an I/O error occurs</span>
129      */
130     public void write(int c) throws IOException {
131         synchronized (lock) {
132             ensureOpen();
133             if (nextChar &gt;= nChars)
134                 flushBuffer();
135             cb[nextChar++] = (char) c;
136         }
137     }
138 
139     /**
140      * Our own little min method, to avoid loading java.lang.Math if we&#39;ve run
141      * out of file descriptors and we&#39;re trying to print a stack trace.
142      */
143     private int min(int a, int b) {
144         if (a &lt; b) return a;
145         return b;
146     }
147 
148     /**
</pre>
<hr />
<pre>
223         synchronized (lock) {
224             ensureOpen();
225 
226             int b = off, t = off + len;
227             while (b &lt; t) {
228                 int d = min(nChars - nextChar, t - b);
229                 s.getChars(b, b + d, cb, nextChar);
230                 b += d;
231                 nextChar += d;
232                 if (nextChar &gt;= nChars)
233                     flushBuffer();
234             }
235         }
236     }
237 
238     /**
239      * Writes a line separator.  The line separator string is defined by the
240      * system property {@code line.separator}, and is not necessarily a single
241      * newline (&#39;\n&#39;) character.
242      *
<span class="line-modified">243      * @exception  IOException  If an I/O error occurs</span>
244      */
245     public void newLine() throws IOException {
246         write(System.lineSeparator());
247     }
248 
249     /**
250      * Flushes the stream.
251      *
<span class="line-modified">252      * @exception  IOException  If an I/O error occurs</span>
253      */
254     public void flush() throws IOException {
255         synchronized (lock) {
256             flushBuffer();
257             out.flush();
258         }
259     }
260 
261     @SuppressWarnings(&quot;try&quot;)
262     public void close() throws IOException {
263         synchronized (lock) {
264             if (out == null) {
265                 return;
266             }
267             try (Writer w = out) {
268                 flushBuffer();
269             } finally {
270                 out = null;
271                 cb = null;
272             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 72 
 73     private static int defaultCharBufferSize = 8192;
 74 
 75     /**
 76      * Creates a buffered character-output stream that uses a default-sized
 77      * output buffer.
 78      *
 79      * @param  out  A Writer
 80      */
 81     public BufferedWriter(Writer out) {
 82         this(out, defaultCharBufferSize);
 83     }
 84 
 85     /**
 86      * Creates a new buffered character-output stream that uses an output
 87      * buffer of the given size.
 88      *
 89      * @param  out  A Writer
 90      * @param  sz   Output-buffer size, a positive integer
 91      *
<span class="line-modified"> 92      * @throws     IllegalArgumentException  If {@code sz &lt;= 0}</span>
 93      */
 94     public BufferedWriter(Writer out, int sz) {
 95         super(out);
 96         if (sz &lt;= 0)
 97             throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
 98         this.out = out;
 99         cb = new char[sz];
100         nChars = sz;
101         nextChar = 0;
102     }
103 
104     /** Checks to make sure that the stream has not been closed */
105     private void ensureOpen() throws IOException {
106         if (out == null)
107             throw new IOException(&quot;Stream closed&quot;);
108     }
109 
110     /**
111      * Flushes the output buffer to the underlying character stream, without
112      * flushing the stream itself.  This method is non-private only so that it
113      * may be invoked by PrintStream.
114      */
115     void flushBuffer() throws IOException {
116         synchronized (lock) {
117             ensureOpen();
118             if (nextChar == 0)
119                 return;
120             out.write(cb, 0, nextChar);
121             nextChar = 0;
122         }
123     }
124 
125     /**
126      * Writes a single character.
127      *
<span class="line-modified">128      * @throws     IOException  If an I/O error occurs</span>
129      */
130     public void write(int c) throws IOException {
131         synchronized (lock) {
132             ensureOpen();
133             if (nextChar &gt;= nChars)
134                 flushBuffer();
135             cb[nextChar++] = (char) c;
136         }
137     }
138 
139     /**
140      * Our own little min method, to avoid loading java.lang.Math if we&#39;ve run
141      * out of file descriptors and we&#39;re trying to print a stack trace.
142      */
143     private int min(int a, int b) {
144         if (a &lt; b) return a;
145         return b;
146     }
147 
148     /**
</pre>
<hr />
<pre>
223         synchronized (lock) {
224             ensureOpen();
225 
226             int b = off, t = off + len;
227             while (b &lt; t) {
228                 int d = min(nChars - nextChar, t - b);
229                 s.getChars(b, b + d, cb, nextChar);
230                 b += d;
231                 nextChar += d;
232                 if (nextChar &gt;= nChars)
233                     flushBuffer();
234             }
235         }
236     }
237 
238     /**
239      * Writes a line separator.  The line separator string is defined by the
240      * system property {@code line.separator}, and is not necessarily a single
241      * newline (&#39;\n&#39;) character.
242      *
<span class="line-modified">243      * @throws     IOException  If an I/O error occurs</span>
244      */
245     public void newLine() throws IOException {
246         write(System.lineSeparator());
247     }
248 
249     /**
250      * Flushes the stream.
251      *
<span class="line-modified">252      * @throws     IOException  If an I/O error occurs</span>
253      */
254     public void flush() throws IOException {
255         synchronized (lock) {
256             flushBuffer();
257             out.flush();
258         }
259     }
260 
261     @SuppressWarnings(&quot;try&quot;)
262     public void close() throws IOException {
263         synchronized (lock) {
264             if (out == null) {
265                 return;
266             }
267             try (Writer w = out) {
268                 flushBuffer();
269             } finally {
270                 out = null;
271                 cb = null;
272             }
</pre>
</td>
</tr>
</table>
<center><a href="BufferedReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ByteArrayOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
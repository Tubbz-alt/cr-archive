<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/File.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Externalizable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileDescriptor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/File.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.net.URI;
  29 import java.net.URL;
  30 import java.net.MalformedURLException;
  31 import java.net.URISyntaxException;

  32 import java.nio.file.FileSystems;
  33 import java.nio.file.Path;
  34 import java.security.SecureRandom;
  35 import java.util.ArrayList;
  36 import java.util.List;
  37 import sun.security.action.GetPropertyAction;
  38 
  39 /**
  40  * An abstract representation of file and directory pathnames.
  41  *
  42  * &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname
  43  * strings&lt;/em&gt; to name files and directories.  This class presents an
  44  * abstract, system-independent view of hierarchical pathnames.  An
  45  * &lt;em&gt;abstract pathname&lt;/em&gt; has two components:
  46  *
  47  * &lt;ol&gt;
  48  * &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,
<span class="line-modified">  49  *      such as a disk-drive specifier, &lt;code&gt;&quot;/&quot;&lt;/code&gt;&amp;nbsp;for the UNIX root</span>
<span class="line-modified">  50  *      directory, or &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and</span>
  51  * &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.
  52  * &lt;/ol&gt;
  53  *
  54  * The first name in an abstract pathname may be a directory name or, in the
  55  * case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
  56  * in an abstract pathname denotes a directory; the last name may denote
  57  * either a directory or a file.  The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no
  58  * prefix and an empty name sequence.
  59  *
  60  * &lt;p&gt; The conversion of a pathname string to or from an abstract pathname is
  61  * inherently system-dependent.  When an abstract pathname is converted into a
  62  * pathname string, each name is separated from the next by a single copy of
  63  * the default &lt;em&gt;separator character&lt;/em&gt;.  The default name-separator
<span class="line-modified">  64  * character is defined by the system property &lt;code&gt;file.separator&lt;/code&gt;, and</span>
  65  * is made available in the public static fields {@link
  66  * #separator} and {@link #separatorChar} of this class.
  67  * When a pathname string is converted into an abstract pathname, the names
  68  * within it may be separated by the default name-separator character or by any
  69  * other name-separator character that is supported by the underlying system.
  70  *
  71  * &lt;p&gt; A pathname, whether abstract or in string form, may be either
  72  * &lt;em&gt;absolute&lt;/em&gt; or &lt;em&gt;relative&lt;/em&gt;.  An absolute pathname is complete in
  73  * that no other information is required in order to locate the file that it
  74  * denotes.  A relative pathname, in contrast, must be interpreted in terms of
  75  * information taken from some other pathname.  By default the classes in the
<span class="line-modified">  76  * &lt;code&gt;java.io&lt;/code&gt; package always resolve relative pathnames against the</span>
  77  * current user directory.  This directory is named by the system property
<span class="line-modified">  78  * &lt;code&gt;user.dir&lt;/code&gt;, and is typically the directory in which the Java</span>
  79  * virtual machine was invoked.
  80  *
  81  * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking
  82  * the {@link #getParent} method of this class and consists of the pathname&#39;s
  83  * prefix and each name in the pathname&#39;s name sequence except for the last.
  84  * Each directory&#39;s absolute pathname is an ancestor of any {@code File}
  85  * object with an absolute abstract pathname which begins with the directory&#39;s
  86  * absolute pathname.  For example, the directory denoted by the abstract
  87  * pathname {@code &quot;/usr&quot;} is an ancestor of the directory denoted by the
  88  * pathname {@code &quot;/usr/local/bin&quot;}.
  89  *
  90  * &lt;p&gt; The prefix concept is used to handle root directories on UNIX platforms,
  91  * and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
  92  * as follows:
  93  *
  94  * &lt;ul&gt;
  95  *
  96  * &lt;li&gt; For UNIX platforms, the prefix of an absolute pathname is always
<span class="line-modified">  97  * &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  Relative pathnames have no prefix.  The abstract pathname</span>
<span class="line-modified">  98  * denoting the root directory has the prefix &lt;code&gt;&quot;/&quot;&lt;/code&gt; and an empty</span>
  99  * name sequence.
 100  *
 101  * &lt;li&gt; For Microsoft Windows platforms, the prefix of a pathname that contains a drive
<span class="line-modified"> 102  * specifier consists of the drive letter followed by &lt;code&gt;&quot;:&quot;&lt;/code&gt; and</span>
<span class="line-modified"> 103  * possibly followed by &lt;code&gt;&quot;\\&quot;&lt;/code&gt; if the pathname is absolute.  The</span>
<span class="line-modified"> 104  * prefix of a UNC pathname is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;; the hostname and the share</span>
 105  * name are the first two names in the name sequence.  A relative pathname that
 106  * does not specify a drive has no prefix.
 107  *
 108  * &lt;/ul&gt;
 109  *
 110  * &lt;p&gt; Instances of this class may or may not denote an actual file-system
 111  * object such as a file or a directory.  If it does denote such an object
 112  * then that object resides in a &lt;i&gt;partition&lt;/i&gt;.  A partition is an
 113  * operating system-specific portion of storage for a file system.  A single
 114  * storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
 115  * contain multiple partitions.  The object, if any, will reside on the
 116  * partition &lt;a id=&quot;partName&quot;&gt;named&lt;/a&gt; by some ancestor of the absolute
 117  * form of this pathname.
 118  *
 119  * &lt;p&gt; A file system may implement restrictions to certain operations on the
 120  * actual file-system object, such as reading, writing, and executing.  These
 121  * restrictions are collectively known as &lt;i&gt;access permissions&lt;/i&gt;.  The file
 122  * system may have multiple sets of access permissions on a single object.
 123  * For example, one set may apply to the object&#39;s &lt;i&gt;owner&lt;/i&gt;, and another
 124  * may apply to all other users.  The access permissions on an object may
 125  * cause some methods in this class to fail.
 126  *
<span class="line-modified"> 127  * &lt;p&gt; Instances of the &lt;code&gt;File&lt;/code&gt; class are immutable; that is, once</span>
<span class="line-modified"> 128  * created, the abstract pathname represented by a &lt;code&gt;File&lt;/code&gt; object</span>
 129  * will never change.
 130  *
<span class="line-modified"> 131  * &lt;h3&gt;Interoperability with {@code java.nio.file} package&lt;/h3&gt;</span>
 132  *
 133  * &lt;p&gt; The &lt;a href=&quot;../../java/nio/file/package-summary.html&quot;&gt;{@code java.nio.file}&lt;/a&gt;
 134  * package defines interfaces and classes for the Java virtual machine to access
 135  * files, file attributes, and file systems. This API may be used to overcome
 136  * many of the limitations of the {@code java.io.File} class.
 137  * The {@link #toPath toPath} method may be used to obtain a {@link
 138  * Path} that uses the abstract path represented by a {@code File} object to
 139  * locate a file. The resulting {@code Path} may be used with the {@link
 140  * java.nio.file.Files} class to provide more efficient and extensive access to
 141  * additional file operations, file attributes, and I/O exceptions to help
 142  * diagnose errors when an operation on a file fails.
 143  *
 144  * @author  unascribed
 145  * @since   1.0
 146  */
 147 
 148 public class File
 149     implements Serializable, Comparable&lt;File&gt;
 150 {
 151 
</pre>
<hr />
<pre>
 165 
 166     /**
 167      * Enum type that indicates the status of a file path.
 168      */
 169     private static enum PathStatus { INVALID, CHECKED };
 170 
 171     /**
 172      * The flag indicating whether the file path is invalid.
 173      */
 174     private transient PathStatus status = null;
 175 
 176     /**
 177      * Check if the file has an invalid path. Currently, the inspection of
 178      * a file path is very limited, and it only covers Nul character check.
 179      * Returning true means the path is definitely invalid/garbage. But
 180      * returning false does not guarantee that the path is valid.
 181      *
 182      * @return true if the file path is invalid.
 183      */
 184     final boolean isInvalid() {
<span class="line-modified"> 185         if (status == null) {</span>
<span class="line-modified"> 186             status = (this.path.indexOf(&#39;\u0000&#39;) &lt; 0) ? PathStatus.CHECKED</span>
<span class="line-modified"> 187                                                        : PathStatus.INVALID;</span>


 188         }
<span class="line-modified"> 189         return status == PathStatus.INVALID;</span>
 190     }
 191 
 192     /**
 193      * The length of this abstract pathname&#39;s prefix, or zero if it has no
 194      * prefix.
 195      */
 196     private final transient int prefixLength;
 197 
 198     /**
 199      * Returns the length of this abstract pathname&#39;s prefix.
 200      * For use by FileSystem classes.
 201      */
 202     int getPrefixLength() {
 203         return prefixLength;
 204     }
 205 
 206     /**
 207      * The system-dependent default name-separator character.  This field is
 208      * initialized to contain the first character of the value of the system
<span class="line-modified"> 209      * property &lt;code&gt;file.separator&lt;/code&gt;.  On UNIX systems the value of this</span>
<span class="line-modified"> 210      * field is &lt;code&gt;&#39;/&#39;&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;&#39;\\&#39;&lt;/code&gt;.</span>
 211      *
 212      * @see     java.lang.System#getProperty(java.lang.String)
 213      */
 214     public static final char separatorChar = fs.getSeparator();
 215 
 216     /**
 217      * The system-dependent default name-separator character, represented as a
 218      * string for convenience.  This string contains a single character, namely
 219      * {@link #separatorChar}.
 220      */
 221     public static final String separator = &quot;&quot; + separatorChar;
 222 
 223     /**
 224      * The system-dependent path-separator character.  This field is
 225      * initialized to contain the first character of the value of the system
<span class="line-modified"> 226      * property &lt;code&gt;path.separator&lt;/code&gt;.  This character is used to</span>
 227      * separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;.
<span class="line-modified"> 228      * On UNIX systems, this character is &lt;code&gt;&#39;:&#39;&lt;/code&gt;; on Microsoft Windows systems it</span>
<span class="line-modified"> 229      * is &lt;code&gt;&#39;;&#39;&lt;/code&gt;.</span>
 230      *
 231      * @see     java.lang.System#getProperty(java.lang.String)
 232      */
 233     public static final char pathSeparatorChar = fs.getPathSeparator();
 234 
 235     /**
 236      * The system-dependent path-separator character, represented as a string
 237      * for convenience.  This string contains a single character, namely
 238      * {@link #pathSeparatorChar}.
 239      */
 240     public static final String pathSeparator = &quot;&quot; + pathSeparatorChar;
 241 
 242 
 243     /* -- Constructors -- */
 244 
 245     /**
 246      * Internal constructor for already-normalized pathname strings.
 247      */
 248     private File(String pathname, int prefixLength) {
 249         this.path = pathname;
 250         this.prefixLength = prefixLength;
 251     }
 252 
 253     /**
 254      * Internal constructor for already-normalized pathname strings.
 255      * The parameter order is used to disambiguate this method from the
 256      * public(File, String) constructor.
 257      */
 258     private File(String child, File parent) {
 259         assert parent.path != null;
 260         assert (!parent.path.isEmpty());
 261         this.path = fs.resolve(parent.path, child);
 262         this.prefixLength = parent.prefixLength;
 263     }
 264 
 265     /**
<span class="line-modified"> 266      * Creates a new &lt;code&gt;File&lt;/code&gt; instance by converting the given</span>
 267      * pathname string into an abstract pathname.  If the given string is
 268      * the empty string, then the result is the empty abstract pathname.
 269      *
 270      * @param   pathname  A pathname string
 271      * @throws  NullPointerException
<span class="line-modified"> 272      *          If the &lt;code&gt;pathname&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;</span>
 273      */
 274     public File(String pathname) {
 275         if (pathname == null) {
 276             throw new NullPointerException();
 277         }
 278         this.path = fs.normalize(pathname);
 279         this.prefixLength = fs.prefixLength(this.path);
 280     }
 281 
 282     /* Note: The two-argument File constructors do not interpret an empty
 283        parent abstract pathname as the current user directory.  An empty parent
 284        instead causes the child to be resolved against the system-dependent
 285        directory defined by the FileSystem.getDefaultParent method.  On Unix
 286        this default is &quot;/&quot;, while on Microsoft Windows it is &quot;\\&quot;.  This is required for
 287        compatibility with the original behavior of this class. */
 288 
 289     /**
<span class="line-modified"> 290      * Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent pathname string</span>
 291      * and a child pathname string.
 292      *
<span class="line-modified"> 293      * &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new</span>
<span class="line-modified"> 294      * &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the</span>
<span class="line-modified"> 295      * single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given</span>
<span class="line-modified"> 296      * &lt;code&gt;child&lt;/code&gt; pathname string.</span>
 297      *
<span class="line-modified"> 298      * &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; pathname string is taken to denote</span>
<span class="line-modified"> 299      * a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken to</span>
<span class="line-modified"> 300      * denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt; pathname</span>
 301      * string is absolute then it is converted into a relative pathname in a
<span class="line-modified"> 302      * system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty string then</span>
<span class="line-modified"> 303      * the new &lt;code&gt;File&lt;/code&gt; instance is created by converting</span>
<span class="line-modified"> 304      * &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving the result</span>
 305      * against a system-dependent default directory.  Otherwise each pathname
 306      * string is converted into an abstract pathname and the child abstract
 307      * pathname is resolved against the parent.
 308      *
 309      * @param   parent  The parent pathname string
 310      * @param   child   The child pathname string
 311      * @throws  NullPointerException
<span class="line-modified"> 312      *          If &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
 313      */
 314     public File(String parent, String child) {
 315         if (child == null) {
 316             throw new NullPointerException();
 317         }
 318         if (parent != null) {
 319             if (parent.isEmpty()) {
 320                 this.path = fs.resolve(fs.getDefaultParent(),
 321                                        fs.normalize(child));
 322             } else {
 323                 this.path = fs.resolve(fs.normalize(parent),
 324                                        fs.normalize(child));
 325             }
 326         } else {
 327             this.path = fs.normalize(child);
 328         }
 329         this.prefixLength = fs.prefixLength(this.path);
 330     }
 331 
 332     /**
<span class="line-modified"> 333      * Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent abstract</span>
 334      * pathname and a child pathname string.
 335      *
<span class="line-modified"> 336      * &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new</span>
<span class="line-modified"> 337      * &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the</span>
<span class="line-modified"> 338      * single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given</span>
<span class="line-modified"> 339      * &lt;code&gt;child&lt;/code&gt; pathname string.</span>
 340      *
<span class="line-modified"> 341      * &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; abstract pathname is taken to</span>
<span class="line-modified"> 342      * denote a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken</span>
<span class="line-modified"> 343      * to denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt;</span>
 344      * pathname string is absolute then it is converted into a relative
<span class="line-modified"> 345      * pathname in a system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty</span>
<span class="line-modified"> 346      * abstract pathname then the new &lt;code&gt;File&lt;/code&gt; instance is created by</span>
<span class="line-modified"> 347      * converting &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving</span>
 348      * the result against a system-dependent default directory.  Otherwise each
 349      * pathname string is converted into an abstract pathname and the child
 350      * abstract pathname is resolved against the parent.
 351      *
 352      * @param   parent  The parent abstract pathname
 353      * @param   child   The child pathname string
 354      * @throws  NullPointerException
<span class="line-modified"> 355      *          If &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
 356      */
 357     public File(File parent, String child) {
 358         if (child == null) {
 359             throw new NullPointerException();
 360         }
 361         if (parent != null) {
 362             if (parent.path.isEmpty()) {
 363                 this.path = fs.resolve(fs.getDefaultParent(),
 364                                        fs.normalize(child));
 365             } else {
 366                 this.path = fs.resolve(parent.path,
 367                                        fs.normalize(child));
 368             }
 369         } else {
 370             this.path = fs.normalize(child);
 371         }
 372         this.prefixLength = fs.prefixLength(this.path);
 373     }
 374 
 375     /**
</pre>
<hr />
<pre>
 441     /* -- Path-component accessors -- */
 442 
 443     /**
 444      * Returns the name of the file or directory denoted by this abstract
 445      * pathname.  This is just the last name in the pathname&#39;s name
 446      * sequence.  If the pathname&#39;s name sequence is empty, then the empty
 447      * string is returned.
 448      *
 449      * @return  The name of the file or directory denoted by this abstract
 450      *          pathname, or the empty string if this pathname&#39;s name sequence
 451      *          is empty
 452      */
 453     public String getName() {
 454         int index = path.lastIndexOf(separatorChar);
 455         if (index &lt; prefixLength) return path.substring(prefixLength);
 456         return path.substring(index + 1);
 457     }
 458 
 459     /**
 460      * Returns the pathname string of this abstract pathname&#39;s parent, or
<span class="line-modified"> 461      * &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent directory.</span>
 462      *
 463      * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 464      * pathname&#39;s prefix, if any, and each name in the pathname&#39;s name
 465      * sequence except for the last.  If the name sequence is empty then
 466      * the pathname does not name a parent directory.
 467      *
 468      * @return  The pathname string of the parent directory named by this
<span class="line-modified"> 469      *          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname</span>
 470      *          does not name a parent
 471      */
 472     public String getParent() {
 473         int index = path.lastIndexOf(separatorChar);
 474         if (index &lt; prefixLength) {
 475             if ((prefixLength &gt; 0) &amp;&amp; (path.length() &gt; prefixLength))
 476                 return path.substring(0, prefixLength);
 477             return null;
 478         }
 479         return path.substring(0, index);
 480     }
 481 
 482     /**
 483      * Returns the abstract pathname of this abstract pathname&#39;s parent,
<span class="line-modified"> 484      * or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</span>
 485      * directory.
 486      *
 487      * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 488      * pathname&#39;s prefix, if any, and each name in the pathname&#39;s name
 489      * sequence except for the last.  If the name sequence is empty then
 490      * the pathname does not name a parent directory.
 491      *
 492      * @return  The abstract pathname of the parent directory named by this
<span class="line-modified"> 493      *          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname</span>
 494      *          does not name a parent
 495      *
 496      * @since 1.2
 497      */
 498     public File getParentFile() {
 499         String p = this.getParent();
 500         if (p == null) return null;
 501         return new File(p, this.prefixLength);
 502     }
 503 
 504     /**
 505      * Converts this abstract pathname into a pathname string.  The resulting
 506      * string uses the {@link #separator default name-separator character} to
 507      * separate the names in the name sequence.
 508      *
 509      * @return  The string form of this abstract pathname
 510      */
 511     public String getPath() {
 512         return path;
 513     }
 514 
 515 
 516     /* -- Path operations -- */
 517 
 518     /**
 519      * Tests whether this abstract pathname is absolute.  The definition of
 520      * absolute pathname is system dependent.  On UNIX systems, a pathname is
<span class="line-modified"> 521      * absolute if its prefix is &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  On Microsoft Windows systems, a</span>
 522      * pathname is absolute if its prefix is a drive specifier followed by
<span class="line-modified"> 523      * &lt;code&gt;&quot;\\&quot;&lt;/code&gt;, or if its prefix is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</span>
 524      *
<span class="line-modified"> 525      * @return  &lt;code&gt;true&lt;/code&gt; if this abstract pathname is absolute,</span>
<span class="line-modified"> 526      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
 527      */
 528     public boolean isAbsolute() {
 529         return fs.isAbsolute(this);
 530     }
 531 
 532     /**
 533      * Returns the absolute pathname string of this abstract pathname.
 534      *
 535      * &lt;p&gt; If this abstract pathname is already absolute, then the pathname
 536      * string is simply returned as if by the {@link #getPath}
 537      * method.  If this abstract pathname is the empty abstract pathname then
 538      * the pathname string of the current user directory, which is named by the
<span class="line-modified"> 539      * system property &lt;code&gt;user.dir&lt;/code&gt;, is returned.  Otherwise this</span>
 540      * pathname is resolved in a system-dependent way.  On UNIX systems, a
 541      * relative pathname is made absolute by resolving it against the current
 542      * user directory.  On Microsoft Windows systems, a relative pathname is made absolute
 543      * by resolving it against the current directory of the drive named by the
 544      * pathname, if any; if not, it is resolved against the current user
 545      * directory.
 546      *
 547      * @return  The absolute pathname string denoting the same file or
 548      *          directory as this abstract pathname
 549      *
 550      * @throws  SecurityException
 551      *          If a required system property value cannot be accessed.
 552      *
 553      * @see     java.io.File#isAbsolute()
 554      */
 555     public String getAbsolutePath() {
 556         return fs.resolve(this);
 557     }
 558 
 559     /**
</pre>
<hr />
<pre>
 639      * @since 1.2
 640      * @see     Path#toRealPath
 641      */
 642     public File getCanonicalFile() throws IOException {
 643         String canonPath = getCanonicalPath();
 644         return new File(canonPath, fs.prefixLength(canonPath));
 645     }
 646 
 647     private static String slashify(String path, boolean isDirectory) {
 648         String p = path;
 649         if (File.separatorChar != &#39;/&#39;)
 650             p = p.replace(File.separatorChar, &#39;/&#39;);
 651         if (!p.startsWith(&quot;/&quot;))
 652             p = &quot;/&quot; + p;
 653         if (!p.endsWith(&quot;/&quot;) &amp;&amp; isDirectory)
 654             p = p + &quot;/&quot;;
 655         return p;
 656     }
 657 
 658     /**
<span class="line-modified"> 659      * Converts this abstract pathname into a &lt;code&gt;file:&lt;/code&gt; URL.  The</span>
 660      * exact form of the URL is system-dependent.  If it can be determined that
 661      * the file denoted by this abstract pathname is a directory, then the
 662      * resulting URL will end with a slash.
 663      *
 664      * @return  A URL object representing the equivalent file URL
 665      *
 666      * @throws  MalformedURLException
 667      *          If the path cannot be parsed as a URL
 668      *
 669      * @see     #toURI()
 670      * @see     java.net.URI
 671      * @see     java.net.URI#toURL()
 672      * @see     java.net.URL
 673      * @since   1.2
 674      *
 675      * @deprecated This method does not automatically escape characters that
 676      * are illegal in URLs.  It is recommended that new code convert an
 677      * abstract pathname into a URL by first converting it into a URI, via the
 678      * {@link #toURI() toURI} method, and then converting the URI into a URL
 679      * via the {@link java.net.URI#toURL() URI.toURL} method.
</pre>
<hr />
<pre>
 732             File f = getAbsoluteFile();
 733             String sp = slashify(f.getPath(), f.isDirectory());
 734             if (sp.startsWith(&quot;//&quot;))
 735                 sp = &quot;//&quot; + sp;
 736             return new URI(&quot;file&quot;, null, sp, null);
 737         } catch (URISyntaxException x) {
 738             throw new Error(x);         // Can&#39;t happen
 739         }
 740     }
 741 
 742 
 743     /* -- Attribute accessors -- */
 744 
 745     /**
 746      * Tests whether the application can read the file denoted by this
 747      * abstract pathname. On some platforms it may be possible to start the
 748      * Java virtual machine with special privileges that allow it to read
 749      * files that are marked as unreadable. Consequently this method may return
 750      * {@code true} even though the file does not have read permissions.
 751      *
<span class="line-modified"> 752      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file specified by this</span>
 753      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; can be read by the
<span class="line-modified"> 754      *          application; &lt;code&gt;false&lt;/code&gt; otherwise</span>
 755      *
 756      * @throws  SecurityException
 757      *          If a security manager exists and its {@link
 758      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 759      *          method denies read access to the file
 760      */
 761     public boolean canRead() {
 762         SecurityManager security = System.getSecurityManager();
 763         if (security != null) {
 764             security.checkRead(path);
 765         }
 766         if (isInvalid()) {
 767             return false;
 768         }
 769         return fs.checkAccess(this, FileSystem.ACCESS_READ);
 770     }
 771 
 772     /**
 773      * Tests whether the application can modify the file denoted by this
 774      * abstract pathname. On some platforms it may be possible to start the
 775      * Java virtual machine with special privileges that allow it to modify
 776      * files that are marked read-only. Consequently this method may return
 777      * {@code true} even though the file is marked read-only.
 778      *
<span class="line-modified"> 779      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file system actually</span>
 780      *          contains a file denoted by this abstract pathname &lt;em&gt;and&lt;/em&gt;
 781      *          the application is allowed to write to the file;
<span class="line-modified"> 782      *          &lt;code&gt;false&lt;/code&gt; otherwise.</span>
 783      *
 784      * @throws  SecurityException
 785      *          If a security manager exists and its {@link
 786      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
 787      *          method denies write access to the file
 788      */
 789     public boolean canWrite() {
 790         SecurityManager security = System.getSecurityManager();
 791         if (security != null) {
 792             security.checkWrite(path);
 793         }
 794         if (isInvalid()) {
 795             return false;
 796         }
 797         return fs.checkAccess(this, FileSystem.ACCESS_WRITE);
 798     }
 799 
 800     /**
 801      * Tests whether the file or directory denoted by this abstract pathname
 802      * exists.
 803      *
<span class="line-modified"> 804      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file or directory denoted</span>
<span class="line-modified"> 805      *          by this abstract pathname exists; &lt;code&gt;false&lt;/code&gt; otherwise</span>
 806      *
 807      * @throws  SecurityException
 808      *          If a security manager exists and its {@link
 809      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 810      *          method denies read access to the file or directory
 811      */
 812     public boolean exists() {
 813         SecurityManager security = System.getSecurityManager();
 814         if (security != null) {
 815             security.checkRead(path);
 816         }
 817         if (isInvalid()) {
 818             return false;
 819         }
 820         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_EXISTS) != 0);
 821     }
 822 
 823     /**
 824      * Tests whether the file denoted by this abstract pathname is a
 825      * directory.
 826      *
 827      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 828      * that the file is not a directory, or where several attributes of the
 829      * same file are required at the same time, then the {@link
 830      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 831      * Files.readAttributes} method may be used.
 832      *
<span class="line-modified"> 833      * @return &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this</span>
 834      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a directory;
<span class="line-modified"> 835      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
 836      *
 837      * @throws  SecurityException
 838      *          If a security manager exists and its {@link
 839      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 840      *          method denies read access to the file
 841      */
 842     public boolean isDirectory() {
 843         SecurityManager security = System.getSecurityManager();
 844         if (security != null) {
 845             security.checkRead(path);
 846         }
 847         if (isInvalid()) {
 848             return false;
 849         }
 850         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_DIRECTORY)
 851                 != 0);
 852     }
 853 
 854     /**
 855      * Tests whether the file denoted by this abstract pathname is a normal
 856      * file.  A file is &lt;em&gt;normal&lt;/em&gt; if it is not a directory and, in
 857      * addition, satisfies other system-dependent criteria.  Any non-directory
 858      * file created by a Java application is guaranteed to be a normal file.
 859      *
 860      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 861      * that the file is not a normal file, or where several attributes of the
 862      * same file are required at the same time, then the {@link
 863      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 864      * Files.readAttributes} method may be used.
 865      *
<span class="line-modified"> 866      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this</span>
 867      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a normal file;
<span class="line-modified"> 868      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
 869      *
 870      * @throws  SecurityException
 871      *          If a security manager exists and its {@link
 872      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 873      *          method denies read access to the file
 874      */
 875     public boolean isFile() {
 876         SecurityManager security = System.getSecurityManager();
 877         if (security != null) {
 878             security.checkRead(path);
 879         }
 880         if (isInvalid()) {
 881             return false;
 882         }
 883         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_REGULAR) != 0);
 884     }
 885 
 886     /**
 887      * Tests whether the file named by this abstract pathname is a hidden
 888      * file.  The exact definition of &lt;em&gt;hidden&lt;/em&gt; is system-dependent.  On
 889      * UNIX systems, a file is considered to be hidden if its name begins with
<span class="line-modified"> 890      * a period character (&lt;code&gt;&#39;.&#39;&lt;/code&gt;).  On Microsoft Windows systems, a file is</span>
 891      * considered to be hidden if it has been marked as such in the filesystem.
 892      *
<span class="line-modified"> 893      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this</span>
 894      *          abstract pathname is hidden according to the conventions of the
 895      *          underlying platform
 896      *
 897      * @throws  SecurityException
 898      *          If a security manager exists and its {@link
 899      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 900      *          method denies read access to the file
 901      *
 902      * @since 1.2
 903      */
 904     public boolean isHidden() {
 905         SecurityManager security = System.getSecurityManager();
 906         if (security != null) {
 907             security.checkRead(path);
 908         }
 909         if (isInvalid()) {
 910             return false;
 911         }
 912         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_HIDDEN) != 0);
 913     }
</pre>
<hr />
<pre>
 915     /**
 916      * Returns the time that the file denoted by this abstract pathname was
 917      * last modified.
 918      *
 919      * @apiNote
 920      * While the unit of time of the return value is milliseconds, the
 921      * granularity of the value depends on the underlying file system and may
 922      * be larger.  For example, some file systems use time stamps in units of
 923      * seconds.
 924      *
 925      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 926      * where {@code 0L} is returned, or where several attributes of the
 927      * same file are required at the same time, or where the time of last
 928      * access or the creation time are required, then the {@link
 929      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 930      * Files.readAttributes} method may be used.  If however only the
 931      * time of last modification is required, then the
 932      * {@link java.nio.file.Files#getLastModifiedTime(Path,LinkOption[])
 933      * Files.getLastModifiedTime} method may be used instead.
 934      *
<span class="line-modified"> 935      * @return  A &lt;code&gt;long&lt;/code&gt; value representing the time the file was</span>
 936      *          last modified, measured in milliseconds since the epoch
<span class="line-modified"> 937      *          (00:00:00 GMT, January 1, 1970), or &lt;code&gt;0L&lt;/code&gt; if the</span>
 938      *          file does not exist or if an I/O error occurs.  The value may
 939      *          be negative indicating the number of milliseconds before the
 940      *          epoch
 941      *
 942      * @throws  SecurityException
 943      *          If a security manager exists and its {@link
 944      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 945      *          method denies read access to the file
 946      */
 947     public long lastModified() {
 948         SecurityManager security = System.getSecurityManager();
 949         if (security != null) {
 950             security.checkRead(path);
 951         }
 952         if (isInvalid()) {
 953             return 0L;
 954         }
 955         return fs.getLastModifiedTime(this);
 956     }
 957 
 958     /**
 959      * Returns the length of the file denoted by this abstract pathname.
 960      * The return value is unspecified if this pathname denotes a directory.
 961      *
 962      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 963      * that {@code 0L} is returned, or where several attributes of the same file
 964      * are required at the same time, then the {@link
 965      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 966      * Files.readAttributes} method may be used.
 967      *
 968      * @return  The length, in bytes, of the file denoted by this abstract
<span class="line-modified"> 969      *          pathname, or &lt;code&gt;0L&lt;/code&gt; if the file does not exist.  Some</span>
<span class="line-modified"> 970      *          operating systems may return &lt;code&gt;0L&lt;/code&gt; for pathnames</span>
 971      *          denoting system-dependent entities such as devices or pipes.
 972      *
 973      * @throws  SecurityException
 974      *          If a security manager exists and its {@link
 975      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 976      *          method denies read access to the file
 977      */
 978     public long length() {
 979         SecurityManager security = System.getSecurityManager();
 980         if (security != null) {
 981             security.checkRead(path);
 982         }
 983         if (isInvalid()) {
 984             return 0L;
 985         }
 986         return fs.getLength(this);
 987     }
 988 
 989 
 990     /* -- File operations -- */
 991 
 992     /**
 993      * Atomically creates a new, empty file named by this abstract pathname if
 994      * and only if a file with this name does not yet exist.  The check for the
 995      * existence of the file and the creation of the file if it does not exist
 996      * are a single operation that is atomic with respect to all other
 997      * filesystem activities that might affect the file.
 998      * &lt;P&gt;
 999      * Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
1000      * the resulting protocol cannot be made to work reliably. The
1001      * {@link java.nio.channels.FileLock FileLock}
1002      * facility should be used instead.
1003      *
<span class="line-modified">1004      * @return  &lt;code&gt;true&lt;/code&gt; if the named file does not exist and was</span>
<span class="line-modified">1005      *          successfully created; &lt;code&gt;false&lt;/code&gt; if the named file</span>
1006      *          already exists
1007      *
1008      * @throws  IOException
1009      *          If an I/O error occurred
1010      *
1011      * @throws  SecurityException
1012      *          If a security manager exists and its {@link
1013      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1014      *          method denies write access to the file
1015      *
1016      * @since 1.2
1017      */
1018     public boolean createNewFile() throws IOException {
1019         SecurityManager security = System.getSecurityManager();
1020         if (security != null) security.checkWrite(path);
1021         if (isInvalid()) {
1022             throw new IOException(&quot;Invalid file path&quot;);
1023         }
1024         return fs.createFileExclusively(path);
1025     }
1026 
1027     /**
1028      * Deletes the file or directory denoted by this abstract pathname.  If
1029      * this pathname denotes a directory, then the directory must be empty in
1030      * order to be deleted.
1031      *
1032      * &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link
1033      * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}
1034      * when a file cannot be deleted. This is useful for error reporting and to
1035      * diagnose why a file cannot be deleted.
1036      *
<span class="line-modified">1037      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the file or directory is</span>
<span class="line-modified">1038      *          successfully deleted; &lt;code&gt;false&lt;/code&gt; otherwise</span>
1039      *
1040      * @throws  SecurityException
1041      *          If a security manager exists and its {@link
1042      *          java.lang.SecurityManager#checkDelete} method denies
1043      *          delete access to the file
1044      */
1045     public boolean delete() {
1046         SecurityManager security = System.getSecurityManager();
1047         if (security != null) {
1048             security.checkDelete(path);
1049         }
1050         if (isInvalid()) {
1051             return false;
1052         }
1053         return fs.delete(this);
1054     }
1055 
1056     /**
1057      * Requests that the file or directory denoted by this abstract
1058      * pathname be deleted when the virtual machine terminates.
</pre>
<hr />
<pre>
1292      *          the directory
1293      *
1294      * @since  1.2
1295      * @see java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)
1296      */
1297     public File[] listFiles(FileFilter filter) {
1298         String ss[] = list();
1299         if (ss == null) return null;
1300         ArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();
1301         for (String s : ss) {
1302             File f = new File(s, this);
1303             if ((filter == null) || filter.accept(f))
1304                 files.add(f);
1305         }
1306         return files.toArray(new File[files.size()]);
1307     }
1308 
1309     /**
1310      * Creates the directory named by this abstract pathname.
1311      *
<span class="line-modified">1312      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the directory was</span>
<span class="line-modified">1313      *          created; &lt;code&gt;false&lt;/code&gt; otherwise</span>
1314      *
1315      * @throws  SecurityException
1316      *          If a security manager exists and its {@link
1317      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1318      *          method does not permit the named directory to be created
1319      */
1320     public boolean mkdir() {
1321         SecurityManager security = System.getSecurityManager();
1322         if (security != null) {
1323             security.checkWrite(path);
1324         }
1325         if (isInvalid()) {
1326             return false;
1327         }
1328         return fs.createDirectory(this);
1329     }
1330 
1331     /**
1332      * Creates the directory named by this abstract pathname, including any
1333      * necessary but nonexistent parent directories.  Note that if this
1334      * operation fails it may have succeeded in creating some of the necessary
1335      * parent directories.
1336      *
<span class="line-modified">1337      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the directory was created,</span>
<span class="line-modified">1338      *          along with all necessary parent directories; &lt;code&gt;false&lt;/code&gt;</span>
1339      *          otherwise
1340      *
1341      * @throws  SecurityException
1342      *          If a security manager exists and its {@link
1343      *          java.lang.SecurityManager#checkRead(java.lang.String)}
1344      *          method does not permit verification of the existence of the
1345      *          named directory and all necessary parent directories; or if
1346      *          the {@link
1347      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1348      *          method does not permit the named directory and all necessary
1349      *          parent directories to be created
1350      */
1351     public boolean mkdirs() {
1352         if (exists()) {
1353             return false;
1354         }
1355         if (mkdir()) {
1356             return true;
1357         }
1358         File canonFile = null;
</pre>
<hr />
<pre>
1366         return (parent != null &amp;&amp; (parent.mkdirs() || parent.exists()) &amp;&amp;
1367                 canonFile.mkdir());
1368     }
1369 
1370     /**
1371      * Renames the file denoted by this abstract pathname.
1372      *
1373      * &lt;p&gt; Many aspects of the behavior of this method are inherently
1374      * platform-dependent: The rename operation might not be able to move a
1375      * file from one filesystem to another, it might not be atomic, and it
1376      * might not succeed if a file with the destination abstract pathname
1377      * already exists.  The return value should always be checked to make sure
1378      * that the rename operation was successful.
1379      *
1380      * &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link
1381      * java.nio.file.Files#move move} method to move or rename a file in a
1382      * platform independent manner.
1383      *
1384      * @param  dest  The new abstract pathname for the named file
1385      *
<span class="line-modified">1386      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the renaming succeeded;</span>
<span class="line-modified">1387      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
1388      *
1389      * @throws  SecurityException
1390      *          If a security manager exists and its {@link
1391      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1392      *          method denies write access to either the old or new pathnames
1393      *
1394      * @throws  NullPointerException
<span class="line-modified">1395      *          If parameter &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1396      */
1397     public boolean renameTo(File dest) {
1398         if (dest == null) {
1399             throw new NullPointerException();
1400         }
1401         SecurityManager security = System.getSecurityManager();
1402         if (security != null) {
1403             security.checkWrite(path);
1404             security.checkWrite(dest.path);
1405         }
1406         if (this.isInvalid() || dest.isInvalid()) {
1407             return false;
1408         }
1409         return fs.rename(this, dest);
1410     }
1411 
1412     /**
1413      * Sets the last-modified time of the file or directory named by this
1414      * abstract pathname.
1415      *
1416      * &lt;p&gt; All platforms support file-modification times to the nearest second,
1417      * but some provide more precision.  The argument will be truncated to fit
1418      * the supported precision.  If the operation succeeds and no intervening
1419      * operations on the file take place, then the next invocation of the
1420      * {@link #lastModified} method will return the (possibly
<span class="line-modified">1421      * truncated) &lt;code&gt;time&lt;/code&gt; argument that was passed to this method.</span>
1422      *
1423      * @param  time  The new last-modified time, measured in milliseconds since
1424      *               the epoch (00:00:00 GMT, January 1, 1970)
1425      *
<span class="line-modified">1426      * @return &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;</span>
<span class="line-modified">1427      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
1428      *
1429      * @throws  IllegalArgumentException  If the argument is negative
1430      *
1431      * @throws  SecurityException
1432      *          If a security manager exists and its {@link
1433      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1434      *          method denies write access to the named file
1435      *
1436      * @since 1.2
1437      */
1438     public boolean setLastModified(long time) {
1439         if (time &lt; 0) throw new IllegalArgumentException(&quot;Negative time&quot;);
1440         SecurityManager security = System.getSecurityManager();
1441         if (security != null) {
1442             security.checkWrite(path);
1443         }
1444         if (isInvalid()) {
1445             return false;
1446         }
1447         return fs.setLastModifiedTime(this, time);
1448     }
1449 
1450     /**
1451      * Marks the file or directory named by this abstract pathname so that
1452      * only read operations are allowed. After invoking this method the file
1453      * or directory will not change until it is either deleted or marked
1454      * to allow write access. On some platforms it may be possible to start the
1455      * Java virtual machine with special privileges that allow it to modify
1456      * files that are marked read-only. Whether or not a read-only file or
1457      * directory may be deleted depends upon the underlying system.
1458      *
<span class="line-modified">1459      * @return &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;</span>
<span class="line-modified">1460      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
1461      *
1462      * @throws  SecurityException
1463      *          If a security manager exists and its {@link
1464      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1465      *          method denies write access to the named file
1466      *
1467      * @since 1.2
1468      */
1469     public boolean setReadOnly() {
1470         SecurityManager security = System.getSecurityManager();
1471         if (security != null) {
1472             security.checkWrite(path);
1473         }
1474         if (isInvalid()) {
1475             return false;
1476         }
1477         return fs.setReadOnly(this);
1478     }
1479 
1480     /**
1481      * Sets the owner&#39;s or everybody&#39;s write permission for this abstract
1482      * pathname. On some platforms it may be possible to start the Java virtual
1483      * machine with special privileges that allow it to modify files that
1484      * disallow write operations.
1485      *
1486      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1487      * file attributes including file permissions. This may be used when finer
1488      * manipulation of file permissions is required.
1489      *
1490      * @param   writable
<span class="line-modified">1491      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write</span>
<span class="line-modified">1492      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations</span>
1493      *
1494      * @param   ownerOnly
<span class="line-modified">1495      *          If &lt;code&gt;true&lt;/code&gt;, the write permission applies only to the</span>
1496      *          owner&#39;s write permission; otherwise, it applies to everybody.  If
1497      *          the underlying file system can not distinguish the owner&#39;s write
1498      *          permission from that of others, then the permission will apply to
1499      *          everybody, regardless of this value.
1500      *
<span class="line-modified">1501      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded. The</span>
1502      *          operation will fail if the user does not have permission to change
1503      *          the access permissions of this abstract pathname.
1504      *
1505      * @throws  SecurityException
1506      *          If a security manager exists and its {@link
1507      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1508      *          method denies write access to the named file
1509      *
1510      * @since 1.6
1511      */
1512     public boolean setWritable(boolean writable, boolean ownerOnly) {
1513         SecurityManager security = System.getSecurityManager();
1514         if (security != null) {
1515             security.checkWrite(path);
1516         }
1517         if (isInvalid()) {
1518             return false;
1519         }
1520         return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);
1521     }
1522 
1523     /**
1524      * A convenience method to set the owner&#39;s write permission for this abstract
1525      * pathname. On some platforms it may be possible to start the Java virtual
1526      * machine with special privileges that allow it to modify files that
1527      * disallow write operations.
1528      *
1529      * &lt;p&gt; An invocation of this method of the form {@code file.setWritable(arg)}
1530      * behaves in exactly the same way as the invocation
1531      *
1532      * &lt;pre&gt;{@code
1533      *     file.setWritable(arg, true)
1534      * }&lt;/pre&gt;
1535      *
1536      * @param   writable
<span class="line-modified">1537      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write</span>
<span class="line-modified">1538      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations</span>
1539      *
<span class="line-modified">1540      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The</span>
1541      *          operation will fail if the user does not have permission to
1542      *          change the access permissions of this abstract pathname.
1543      *
1544      * @throws  SecurityException
1545      *          If a security manager exists and its {@link
1546      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1547      *          method denies write access to the file
1548      *
1549      * @since 1.6
1550      */
1551     public boolean setWritable(boolean writable) {
1552         return setWritable(writable, true);
1553     }
1554 
1555     /**
1556      * Sets the owner&#39;s or everybody&#39;s read permission for this abstract
1557      * pathname. On some platforms it may be possible to start the Java virtual
1558      * machine with special privileges that allow it to read files that are
1559      * marked as unreadable.
1560      *
1561      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1562      * file attributes including file permissions. This may be used when finer
1563      * manipulation of file permissions is required.
1564      *
1565      * @param   readable
<span class="line-modified">1566      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read</span>
<span class="line-modified">1567      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations</span>
1568      *
1569      * @param   ownerOnly
<span class="line-modified">1570      *          If &lt;code&gt;true&lt;/code&gt;, the read permission applies only to the</span>
1571      *          owner&#39;s read permission; otherwise, it applies to everybody.  If
1572      *          the underlying file system can not distinguish the owner&#39;s read
1573      *          permission from that of others, then the permission will apply to
1574      *          everybody, regardless of this value.
1575      *
<span class="line-modified">1576      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The</span>
1577      *          operation will fail if the user does not have permission to
1578      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1579      *          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying</span>
1580      *          file system does not implement a read permission, then the
1581      *          operation will fail.
1582      *
1583      * @throws  SecurityException
1584      *          If a security manager exists and its {@link
1585      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1586      *          method denies write access to the file
1587      *
1588      * @since 1.6
1589      */
1590     public boolean setReadable(boolean readable, boolean ownerOnly) {
1591         SecurityManager security = System.getSecurityManager();
1592         if (security != null) {
1593             security.checkWrite(path);
1594         }
1595         if (isInvalid()) {
1596             return false;
1597         }
1598         return fs.setPermission(this, FileSystem.ACCESS_READ, readable, ownerOnly);
1599     }
1600 
1601     /**
1602      * A convenience method to set the owner&#39;s read permission for this abstract
1603      * pathname. On some platforms it may be possible to start the Java virtual
1604      * machine with special privileges that allow it to read files that are
1605      * marked as unreadable.
1606      *
1607      * &lt;p&gt;An invocation of this method of the form {@code file.setReadable(arg)}
1608      * behaves in exactly the same way as the invocation
1609      *
1610      * &lt;pre&gt;{@code
1611      *     file.setReadable(arg, true)
1612      * }&lt;/pre&gt;
1613      *
1614      * @param  readable
<span class="line-modified">1615      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read</span>
<span class="line-modified">1616      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations</span>
1617      *
<span class="line-modified">1618      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The</span>
1619      *          operation will fail if the user does not have permission to
1620      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1621      *          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying</span>
1622      *          file system does not implement a read permission, then the
1623      *          operation will fail.
1624      *
1625      * @throws  SecurityException
1626      *          If a security manager exists and its {@link
1627      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1628      *          method denies write access to the file
1629      *
1630      * @since 1.6
1631      */
1632     public boolean setReadable(boolean readable) {
1633         return setReadable(readable, true);
1634     }
1635 
1636     /**
1637      * Sets the owner&#39;s or everybody&#39;s execute permission for this abstract
1638      * pathname. On some platforms it may be possible to start the Java virtual
1639      * machine with special privileges that allow it to execute files that are
1640      * not marked executable.
1641      *
1642      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1643      * file attributes including file permissions. This may be used when finer
1644      * manipulation of file permissions is required.
1645      *
1646      * @param   executable
<span class="line-modified">1647      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute</span>
<span class="line-modified">1648      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations</span>
1649      *
1650      * @param   ownerOnly
<span class="line-modified">1651      *          If &lt;code&gt;true&lt;/code&gt;, the execute permission applies only to the</span>
1652      *          owner&#39;s execute permission; otherwise, it applies to everybody.
1653      *          If the underlying file system can not distinguish the owner&#39;s
1654      *          execute permission from that of others, then the permission will
1655      *          apply to everybody, regardless of this value.
1656      *
<span class="line-modified">1657      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The</span>
1658      *          operation will fail if the user does not have permission to
1659      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1660      *          &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying</span>
1661      *          file system does not implement an execute permission, then the
1662      *          operation will fail.
1663      *
1664      * @throws  SecurityException
1665      *          If a security manager exists and its {@link
1666      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1667      *          method denies write access to the file
1668      *
1669      * @since 1.6
1670      */
1671     public boolean setExecutable(boolean executable, boolean ownerOnly) {
1672         SecurityManager security = System.getSecurityManager();
1673         if (security != null) {
1674             security.checkWrite(path);
1675         }
1676         if (isInvalid()) {
1677             return false;
1678         }
1679         return fs.setPermission(this, FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
1680     }
1681 
1682     /**
1683      * A convenience method to set the owner&#39;s execute permission for this
1684      * abstract pathname. On some platforms it may be possible to start the Java
1685      * virtual machine with special privileges that allow it to execute files
1686      * that are not marked executable.
1687      *
1688      * &lt;p&gt;An invocation of this method of the form {@code file.setExcutable(arg)}
1689      * behaves in exactly the same way as the invocation
1690      *
1691      * &lt;pre&gt;{@code
1692      *     file.setExecutable(arg, true)
1693      * }&lt;/pre&gt;
1694      *
1695      * @param   executable
<span class="line-modified">1696      *          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute</span>
<span class="line-modified">1697      *          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations</span>
1698      *
<span class="line-modified">1699      * @return   &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The</span>
1700      *           operation will fail if the user does not have permission to
1701      *           change the access permissions of this abstract pathname.  If
<span class="line-modified">1702      *           &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying</span>
1703      *           file system does not implement an execute permission, then the
1704      *           operation will fail.
1705      *
1706      * @throws  SecurityException
1707      *          If a security manager exists and its {@link
1708      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1709      *          method denies write access to the file
1710      *
1711      * @since 1.6
1712      */
1713     public boolean setExecutable(boolean executable) {
1714         return setExecutable(executable, true);
1715     }
1716 
1717     /**
1718      * Tests whether the application can execute the file denoted by this
1719      * abstract pathname. On some platforms it may be possible to start the
1720      * Java virtual machine with special privileges that allow it to execute
1721      * files that are not marked executable. Consequently this method may return
1722      * {@code true} even though the file does not have execute permissions.
1723      *
<span class="line-modified">1724      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the abstract pathname exists</span>
1725      *          &lt;em&gt;and&lt;/em&gt; the application is allowed to execute the file
1726      *
1727      * @throws  SecurityException
1728      *          If a security manager exists and its {@link
1729      *          java.lang.SecurityManager#checkExec(java.lang.String)}
1730      *          method denies execute access to the file
1731      *
1732      * @since 1.6
1733      */
1734     public boolean canExecute() {
1735         SecurityManager security = System.getSecurityManager();
1736         if (security != null) {
1737             security.checkExec(path);
1738         }
1739         if (isInvalid()) {
1740             return false;
1741         }
1742         return fs.checkAccess(this, FileSystem.ACCESS_EXECUTE);
1743     }
1744 
</pre>
<hr />
<pre>
1779      * particular root directory, then that directory will not appear in the
1780      * result.
1781      *
1782      * @return  An array of {@code File} objects denoting the available
1783      *          filesystem roots, or {@code null} if the set of roots could not
1784      *          be determined.  The array will be empty if there are no
1785      *          filesystem roots.
1786      *
1787      * @since  1.2
1788      * @see java.nio.file.FileStore
1789      */
1790     public static File[] listRoots() {
1791         return fs.listRoots();
1792     }
1793 
1794 
1795     /* -- Disk usage -- */
1796 
1797     /**
1798      * Returns the size of the partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this
<span class="line-modified">1799      * abstract pathname.</span>


1800      *
1801      * @return  The size, in bytes, of the partition or {@code 0L} if this
<span class="line-modified">1802      *          abstract pathname does not name a partition</span>

1803      *
1804      * @throws  SecurityException
1805      *          If a security manager has been installed and it denies
1806      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1807      *          or its {@link SecurityManager#checkRead(String)} method denies
1808      *          read access to the file named by this abstract pathname
1809      *
1810      * @since  1.6

1811      */
1812     public long getTotalSpace() {
1813         SecurityManager sm = System.getSecurityManager();
1814         if (sm != null) {
1815             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1816             sm.checkRead(path);
1817         }
1818         if (isInvalid()) {
1819             return 0L;
1820         }
<span class="line-modified">1821         return fs.getSpace(this, FileSystem.SPACE_TOTAL);</span>

1822     }
1823 
1824     /**
1825      * Returns the number of unallocated bytes in the partition &lt;a
<span class="line-modified">1826      * href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract path name.</span>


1827      *
1828      * &lt;p&gt; The returned number of unallocated bytes is a hint, but not
1829      * a guarantee, that it is possible to use most or any of these
1830      * bytes.  The number of unallocated bytes is most likely to be
1831      * accurate immediately after this call.  It is likely to be made
1832      * inaccurate by any external I/O operations including those made
1833      * on the system outside of this virtual machine.  This method
1834      * makes no guarantee that write operations to this file system
1835      * will succeed.
1836      *
1837      * @return  The number of unallocated bytes on the partition or {@code 0L}
<span class="line-modified">1838      *          if the abstract pathname does not name a partition.  This</span>
<span class="line-modified">1839      *          value will be less than or equal to the total file system size</span>
<span class="line-modified">1840      *          returned by {@link #getTotalSpace}.</span>

1841      *
1842      * @throws  SecurityException
1843      *          If a security manager has been installed and it denies
1844      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1845      *          or its {@link SecurityManager#checkRead(String)} method denies
1846      *          read access to the file named by this abstract pathname
1847      *
1848      * @since  1.6

1849      */
1850     public long getFreeSpace() {
1851         SecurityManager sm = System.getSecurityManager();
1852         if (sm != null) {
1853             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1854             sm.checkRead(path);
1855         }
1856         if (isInvalid()) {
1857             return 0L;
1858         }
<span class="line-modified">1859         return fs.getSpace(this, FileSystem.SPACE_FREE);</span>

1860     }
1861 
1862     /**
1863      * Returns the number of bytes available to this virtual machine on the
<span class="line-modified">1864      * partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract pathname.  When</span>
<span class="line-modified">1865      * possible, this method checks for write permissions and other operating</span>
<span class="line-modified">1866      * system restrictions and will therefore usually provide a more accurate</span>
<span class="line-modified">1867      * estimate of how much new data can actually be written than {@link</span>
<span class="line-modified">1868      * #getFreeSpace}.</span>


1869      *
1870      * &lt;p&gt; The returned number of available bytes is a hint, but not a
1871      * guarantee, that it is possible to use most or any of these bytes.  The
<span class="line-modified">1872      * number of unallocated bytes is most likely to be accurate immediately</span>
1873      * after this call.  It is likely to be made inaccurate by any external
1874      * I/O operations including those made on the system outside of this
1875      * virtual machine.  This method makes no guarantee that write operations
1876      * to this file system will succeed.
1877      *
1878      * @return  The number of available bytes on the partition or {@code 0L}
<span class="line-modified">1879      *          if the abstract pathname does not name a partition.  On</span>
<span class="line-modified">1880      *          systems where this information is not available, this method</span>
<span class="line-modified">1881      *          will be equivalent to a call to {@link #getFreeSpace}.</span>

1882      *
1883      * @throws  SecurityException
1884      *          If a security manager has been installed and it denies
1885      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1886      *          or its {@link SecurityManager#checkRead(String)} method denies
1887      *          read access to the file named by this abstract pathname
1888      *
1889      * @since  1.6

1890      */
1891     public long getUsableSpace() {
1892         SecurityManager sm = System.getSecurityManager();
1893         if (sm != null) {
1894             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1895             sm.checkRead(path);
1896         }
1897         if (isInvalid()) {
1898             return 0L;
1899         }
<span class="line-modified">1900         return fs.getSpace(this, FileSystem.SPACE_USABLE);</span>

1901     }
1902 
1903     /* -- Temporary files -- */
1904 
1905     private static class TempDirectory {
1906         private TempDirectory() { }
1907 
1908         // temporary directory location
1909         private static final File tmpdir = new File(
1910                 GetPropertyAction.privilegedGetProperty(&quot;java.io.tmpdir&quot;));
1911         static File location() {
1912             return tmpdir;
1913         }
1914 
1915         // file name generation
1916         private static final SecureRandom random = new SecureRandom();
1917         private static int shortenSubName(int subNameLength, int excess,
1918             int nameMin) {
1919             int newLength = Math.max(nameMin, subNameLength - excess);
1920             if (newLength &lt; subNameLength) {
</pre>
<hr />
<pre>
1988         }
1989     }
1990 
1991     /**
1992      * &lt;p&gt; Creates a new empty file in the specified directory, using the
1993      * given prefix and suffix strings to generate its name.  If this method
1994      * returns successfully then it is guaranteed that:
1995      *
1996      * &lt;ol&gt;
1997      * &lt;li&gt; The file denoted by the returned abstract pathname did not exist
1998      *      before this method was invoked, and
1999      * &lt;li&gt; Neither this method nor any of its variants will return the same
2000      *      abstract pathname again in the current invocation of the virtual
2001      *      machine.
2002      * &lt;/ol&gt;
2003      *
2004      * This method provides only part of a temporary-file facility.  To arrange
2005      * for a file created by this method to be deleted automatically, use the
2006      * {@link #deleteOnExit} method.
2007      *
<span class="line-modified">2008      * &lt;p&gt; The &lt;code&gt;prefix&lt;/code&gt; argument must be at least three characters</span>
2009      * long.  It is recommended that the prefix be a short, meaningful string
<span class="line-modified">2010      * such as &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; or &lt;code&gt;&quot;mail&quot;&lt;/code&gt;.  The</span>
<span class="line-modified">2011      * &lt;code&gt;suffix&lt;/code&gt; argument may be &lt;code&gt;null&lt;/code&gt;, in which case the</span>
<span class="line-modified">2012      * suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used.</span>
2013      *
2014      * &lt;p&gt; To create the new file, the prefix and the suffix may first be
2015      * adjusted to fit the limitations of the underlying platform.  If the
2016      * prefix is too long then it will be truncated, but its first three
2017      * characters will always be preserved.  If the suffix is too long then it
2018      * too will be truncated, but if it begins with a period character
<span class="line-modified">2019      * (&lt;code&gt;&#39;.&#39;&lt;/code&gt;) then the period and the first three characters</span>
2020      * following it will always be preserved.  Once these adjustments have been
2021      * made the name of the new file will be generated by concatenating the
2022      * prefix, five or more internally-generated characters, and the suffix.
2023      *
<span class="line-modified">2024      * &lt;p&gt; If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the</span>
2025      * system-dependent default temporary-file directory will be used.  The
2026      * default temporary-file directory is specified by the system property
<span class="line-modified">2027      * &lt;code&gt;java.io.tmpdir&lt;/code&gt;.  On UNIX systems the default value of this</span>
<span class="line-modified">2028      * property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on</span>
<span class="line-modified">2029      * Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;.  A different</span>
2030      * value may be given to this system property when the Java virtual machine
2031      * is invoked, but programmatic changes to this property are not guaranteed
2032      * to have any effect upon the temporary directory used by this method.
2033      *
2034      * @param  prefix     The prefix string to be used in generating the file&#39;s
2035      *                    name; must be at least three characters long
2036      *
2037      * @param  suffix     The suffix string to be used in generating the file&#39;s
<span class="line-modified">2038      *                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the</span>
<span class="line-modified">2039      *                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used</span>
2040      *
2041      * @param  directory  The directory in which the file is to be created, or
<span class="line-modified">2042      *                    &lt;code&gt;null&lt;/code&gt; if the default temporary-file</span>
2043      *                    directory is to be used
2044      *
2045      * @return  An abstract pathname denoting a newly-created empty file
2046      *
2047      * @throws  IllegalArgumentException
<span class="line-modified">2048      *          If the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three</span>
2049      *          characters
2050      *
2051      * @throws  IOException  If a file could not be created
2052      *
2053      * @throws  SecurityException
2054      *          If a security manager exists and its {@link
2055      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
2056      *          method does not allow a file to be created
2057      *
2058      * @since 1.2
2059      */
2060     public static File createTempFile(String prefix, String suffix,
2061                                       File directory)
2062         throws IOException
2063     {
2064         if (prefix.length() &lt; 3) {
2065             throw new IllegalArgumentException(&quot;Prefix string \&quot;&quot; + prefix +
2066                 &quot;\&quot; too short: length must be at least 3&quot;);
2067         }
2068         if (suffix == null)
</pre>
<hr />
<pre>
2094     }
2095 
2096     /**
2097      * Creates an empty file in the default temporary-file directory, using
2098      * the given prefix and suffix to generate its name. Invoking this method
2099      * is equivalent to invoking {@link #createTempFile(java.lang.String,
2100      * java.lang.String, java.io.File)
2101      * createTempFile(prefix,&amp;nbsp;suffix,&amp;nbsp;null)}.
2102      *
2103      * &lt;p&gt; The {@link
2104      * java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])
2105      * Files.createTempFile} method provides an alternative method to create an
2106      * empty file in the temporary-file directory. Files created by that method
2107      * may have more restrictive access permissions to files created by this
2108      * method and so may be more suited to security-sensitive applications.
2109      *
2110      * @param  prefix     The prefix string to be used in generating the file&#39;s
2111      *                    name; must be at least three characters long
2112      *
2113      * @param  suffix     The suffix string to be used in generating the file&#39;s
<span class="line-modified">2114      *                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the</span>
<span class="line-modified">2115      *                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used</span>
2116      *
2117      * @return  An abstract pathname denoting a newly-created empty file
2118      *
2119      * @throws  IllegalArgumentException
<span class="line-modified">2120      *          If the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three</span>
2121      *          characters
2122      *
2123      * @throws  IOException  If a file could not be created
2124      *
2125      * @throws  SecurityException
2126      *          If a security manager exists and its {@link
2127      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
2128      *          method does not allow a file to be created
2129      *
2130      * @since 1.2
2131      * @see java.nio.file.Files#createTempDirectory(String,FileAttribute[])
2132      */
2133     public static File createTempFile(String prefix, String suffix)
2134         throws IOException
2135     {
2136         return createTempFile(prefix, suffix, null);
2137     }
2138 
2139     /* -- Basic infrastructure -- */
2140 
</pre>
<hr />
<pre>
2144      * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
2145      * systems it is not.
2146      *
2147      * @param   pathname  The abstract pathname to be compared to this abstract
2148      *                    pathname
2149      *
2150      * @return  Zero if the argument is equal to this abstract pathname, a
2151      *          value less than zero if this abstract pathname is
2152      *          lexicographically less than the argument, or a value greater
2153      *          than zero if this abstract pathname is lexicographically
2154      *          greater than the argument
2155      *
2156      * @since   1.2
2157      */
2158     public int compareTo(File pathname) {
2159         return fs.compare(this, pathname);
2160     }
2161 
2162     /**
2163      * Tests this abstract pathname for equality with the given object.
<span class="line-modified">2164      * Returns &lt;code&gt;true&lt;/code&gt; if and only if the argument is not</span>
<span class="line-modified">2165      * &lt;code&gt;null&lt;/code&gt; and is an abstract pathname that denotes the same file</span>
2166      * or directory as this abstract pathname.  Whether or not two abstract
2167      * pathnames are equal depends upon the underlying system.  On UNIX
2168      * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
2169      * systems it is not.
2170      *
2171      * @param   obj   The object to be compared with this abstract pathname
2172      *
<span class="line-modified">2173      * @return  &lt;code&gt;true&lt;/code&gt; if and only if the objects are the same;</span>
<span class="line-modified">2174      *          &lt;code&gt;false&lt;/code&gt; otherwise</span>
2175      */
2176     public boolean equals(Object obj) {
2177         if ((obj != null) &amp;&amp; (obj instanceof File)) {
2178             return compareTo((File)obj) == 0;
2179         }
2180         return false;
2181     }
2182 
2183     /**
2184      * Computes a hash code for this abstract pathname.  Because equality of
2185      * abstract pathnames is inherently system-dependent, so is the computation
2186      * of their hash codes.  On UNIX systems, the hash code of an abstract
2187      * pathname is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code
2188      * of its pathname string and the decimal value
<span class="line-modified">2189      * &lt;code&gt;1234321&lt;/code&gt;.  On Microsoft Windows systems, the hash</span>
2190      * code is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code of
2191      * its pathname string converted to lower case and the decimal
<span class="line-modified">2192      * value &lt;code&gt;1234321&lt;/code&gt;.  Locale is not taken into account on</span>
2193      * lowercasing the pathname string.
2194      *
2195      * @return  A hash code for this abstract pathname
2196      */
2197     public int hashCode() {
2198         return fs.hashCode(this);
2199     }
2200 
2201     /**
2202      * Returns the pathname string of this abstract pathname.  This is just the
2203      * string returned by the {@link #getPath} method.
2204      *
2205      * @return  The string form of this abstract pathname
2206      */
2207     public String toString() {
2208         return getPath();
2209     }
2210 
2211     /**
2212      * WriteObject is called to save this filename.
2213      * The separator character is saved also so it can be replaced
2214      * in case the path is reconstituted on a different host type.
2215      *
2216      * @serialData  Default fields followed by separator character.
2217      */

2218     private synchronized void writeObject(java.io.ObjectOutputStream s)
2219         throws IOException
2220     {
2221         s.defaultWriteObject();
2222         s.writeChar(separatorChar); // Add the separator character
2223     }
2224 
2225     /**
2226      * readObject is called to restore this filename.
2227      * The original separator character is read.  If it is different
2228      * than the separator character on this system, then the old separator
2229      * is replaced by the local separator.
2230      */

2231     private synchronized void readObject(java.io.ObjectInputStream s)
2232          throws IOException, ClassNotFoundException
2233     {
2234         ObjectInputStream.GetField fields = s.readFields();
2235         String pathField = (String)fields.get(&quot;path&quot;, null);
2236         char sep = s.readChar(); // read the previous separator char
2237         if (sep != separatorChar)
2238             pathField = pathField.replace(sep, separatorChar);
2239         String path = fs.normalize(pathField);
2240         UNSAFE.putReference(this, PATH_OFFSET, path);
2241         UNSAFE.putIntVolatile(this, PREFIX_LENGTH_OFFSET, fs.prefixLength(path));
2242     }
2243 
2244     private static final jdk.internal.misc.Unsafe UNSAFE
2245             = jdk.internal.misc.Unsafe.getUnsafe();
2246     private static final long PATH_OFFSET
2247             = UNSAFE.objectFieldOffset(File.class, &quot;path&quot;);
2248     private static final long PREFIX_LENGTH_OFFSET
2249             = UNSAFE.objectFieldOffset(File.class, &quot;prefixLength&quot;);
2250 
2251     /** use serialVersionUID from JDK 1.0.2 for interoperability */

2252     private static final long serialVersionUID = 301077366599181567L;
2253 
2254     // -- Integration with java.nio.file --
2255 
2256     private transient volatile Path filePath;
2257 
2258     /**
2259      * Returns a {@link Path java.nio.file.Path} object constructed from
2260      * this abstract path. The resulting {@code Path} is associated with the
2261      * {@link java.nio.file.FileSystems#getDefault default-filesystem}.
2262      *
2263      * &lt;p&gt; The first invocation of this method works as if invoking it were
2264      * equivalent to evaluating the expression:
2265      * &lt;blockquote&gt;&lt;pre&gt;
2266      * {@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link
2267      * java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());
2268      * &lt;/pre&gt;&lt;/blockquote&gt;
2269      * Subsequent invocations of this method return the same {@code Path}.
2270      *
2271      * &lt;p&gt; If this abstract pathname is the empty abstract pathname then this
</pre>
</td>
<td>
<hr />
<pre>
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.net.URI;
  29 import java.net.URL;
  30 import java.net.MalformedURLException;
  31 import java.net.URISyntaxException;
<span class="line-added">  32 import java.nio.file.FileStore;</span>
  33 import java.nio.file.FileSystems;
  34 import java.nio.file.Path;
  35 import java.security.SecureRandom;
  36 import java.util.ArrayList;
  37 import java.util.List;
  38 import sun.security.action.GetPropertyAction;
  39 
  40 /**
  41  * An abstract representation of file and directory pathnames.
  42  *
  43  * &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname
  44  * strings&lt;/em&gt; to name files and directories.  This class presents an
  45  * abstract, system-independent view of hierarchical pathnames.  An
  46  * &lt;em&gt;abstract pathname&lt;/em&gt; has two components:
  47  *
  48  * &lt;ol&gt;
  49  * &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,
<span class="line-modified">  50  *      such as a disk-drive specifier, {@code &quot;/&quot;}&amp;nbsp;for the UNIX root</span>
<span class="line-modified">  51  *      directory, or {@code &quot;\\\\&quot;}&amp;nbsp;for a Microsoft Windows UNC pathname, and</span>
  52  * &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.
  53  * &lt;/ol&gt;
  54  *
  55  * The first name in an abstract pathname may be a directory name or, in the
  56  * case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
  57  * in an abstract pathname denotes a directory; the last name may denote
  58  * either a directory or a file.  The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no
  59  * prefix and an empty name sequence.
  60  *
  61  * &lt;p&gt; The conversion of a pathname string to or from an abstract pathname is
  62  * inherently system-dependent.  When an abstract pathname is converted into a
  63  * pathname string, each name is separated from the next by a single copy of
  64  * the default &lt;em&gt;separator character&lt;/em&gt;.  The default name-separator
<span class="line-modified">  65  * character is defined by the system property {@code file.separator}, and</span>
  66  * is made available in the public static fields {@link
  67  * #separator} and {@link #separatorChar} of this class.
  68  * When a pathname string is converted into an abstract pathname, the names
  69  * within it may be separated by the default name-separator character or by any
  70  * other name-separator character that is supported by the underlying system.
  71  *
  72  * &lt;p&gt; A pathname, whether abstract or in string form, may be either
  73  * &lt;em&gt;absolute&lt;/em&gt; or &lt;em&gt;relative&lt;/em&gt;.  An absolute pathname is complete in
  74  * that no other information is required in order to locate the file that it
  75  * denotes.  A relative pathname, in contrast, must be interpreted in terms of
  76  * information taken from some other pathname.  By default the classes in the
<span class="line-modified">  77  * {@code java.io} package always resolve relative pathnames against the</span>
  78  * current user directory.  This directory is named by the system property
<span class="line-modified">  79  * {@code user.dir}, and is typically the directory in which the Java</span>
  80  * virtual machine was invoked.
  81  *
  82  * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking
  83  * the {@link #getParent} method of this class and consists of the pathname&#39;s
  84  * prefix and each name in the pathname&#39;s name sequence except for the last.
  85  * Each directory&#39;s absolute pathname is an ancestor of any {@code File}
  86  * object with an absolute abstract pathname which begins with the directory&#39;s
  87  * absolute pathname.  For example, the directory denoted by the abstract
  88  * pathname {@code &quot;/usr&quot;} is an ancestor of the directory denoted by the
  89  * pathname {@code &quot;/usr/local/bin&quot;}.
  90  *
  91  * &lt;p&gt; The prefix concept is used to handle root directories on UNIX platforms,
  92  * and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
  93  * as follows:
  94  *
  95  * &lt;ul&gt;
  96  *
  97  * &lt;li&gt; For UNIX platforms, the prefix of an absolute pathname is always
<span class="line-modified">  98  * {@code &quot;/&quot;}.  Relative pathnames have no prefix.  The abstract pathname</span>
<span class="line-modified">  99  * denoting the root directory has the prefix {@code &quot;/&quot;} and an empty</span>
 100  * name sequence.
 101  *
 102  * &lt;li&gt; For Microsoft Windows platforms, the prefix of a pathname that contains a drive
<span class="line-modified"> 103  * specifier consists of the drive letter followed by {@code &quot;:&quot;} and</span>
<span class="line-modified"> 104  * possibly followed by {@code &quot;\\&quot;} if the pathname is absolute.  The</span>
<span class="line-modified"> 105  * prefix of a UNC pathname is {@code &quot;\\\\&quot;}; the hostname and the share</span>
 106  * name are the first two names in the name sequence.  A relative pathname that
 107  * does not specify a drive has no prefix.
 108  *
 109  * &lt;/ul&gt;
 110  *
 111  * &lt;p&gt; Instances of this class may or may not denote an actual file-system
 112  * object such as a file or a directory.  If it does denote such an object
 113  * then that object resides in a &lt;i&gt;partition&lt;/i&gt;.  A partition is an
 114  * operating system-specific portion of storage for a file system.  A single
 115  * storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
 116  * contain multiple partitions.  The object, if any, will reside on the
 117  * partition &lt;a id=&quot;partName&quot;&gt;named&lt;/a&gt; by some ancestor of the absolute
 118  * form of this pathname.
 119  *
 120  * &lt;p&gt; A file system may implement restrictions to certain operations on the
 121  * actual file-system object, such as reading, writing, and executing.  These
 122  * restrictions are collectively known as &lt;i&gt;access permissions&lt;/i&gt;.  The file
 123  * system may have multiple sets of access permissions on a single object.
 124  * For example, one set may apply to the object&#39;s &lt;i&gt;owner&lt;/i&gt;, and another
 125  * may apply to all other users.  The access permissions on an object may
 126  * cause some methods in this class to fail.
 127  *
<span class="line-modified"> 128  * &lt;p&gt; Instances of the {@code File} class are immutable; that is, once</span>
<span class="line-modified"> 129  * created, the abstract pathname represented by a {@code File} object</span>
 130  * will never change.
 131  *
<span class="line-modified"> 132  * &lt;h2&gt;Interoperability with {@code java.nio.file} package&lt;/h2&gt;</span>
 133  *
 134  * &lt;p&gt; The &lt;a href=&quot;../../java/nio/file/package-summary.html&quot;&gt;{@code java.nio.file}&lt;/a&gt;
 135  * package defines interfaces and classes for the Java virtual machine to access
 136  * files, file attributes, and file systems. This API may be used to overcome
 137  * many of the limitations of the {@code java.io.File} class.
 138  * The {@link #toPath toPath} method may be used to obtain a {@link
 139  * Path} that uses the abstract path represented by a {@code File} object to
 140  * locate a file. The resulting {@code Path} may be used with the {@link
 141  * java.nio.file.Files} class to provide more efficient and extensive access to
 142  * additional file operations, file attributes, and I/O exceptions to help
 143  * diagnose errors when an operation on a file fails.
 144  *
 145  * @author  unascribed
 146  * @since   1.0
 147  */
 148 
 149 public class File
 150     implements Serializable, Comparable&lt;File&gt;
 151 {
 152 
</pre>
<hr />
<pre>
 166 
 167     /**
 168      * Enum type that indicates the status of a file path.
 169      */
 170     private static enum PathStatus { INVALID, CHECKED };
 171 
 172     /**
 173      * The flag indicating whether the file path is invalid.
 174      */
 175     private transient PathStatus status = null;
 176 
 177     /**
 178      * Check if the file has an invalid path. Currently, the inspection of
 179      * a file path is very limited, and it only covers Nul character check.
 180      * Returning true means the path is definitely invalid/garbage. But
 181      * returning false does not guarantee that the path is valid.
 182      *
 183      * @return true if the file path is invalid.
 184      */
 185     final boolean isInvalid() {
<span class="line-modified"> 186         PathStatus s = status;</span>
<span class="line-modified"> 187         if (s == null) {</span>
<span class="line-modified"> 188             s = (this.path.indexOf(&#39;\u0000&#39;) &lt; 0) ? PathStatus.CHECKED</span>
<span class="line-added"> 189                                                   : PathStatus.INVALID;</span>
<span class="line-added"> 190             status = s;</span>
 191         }
<span class="line-modified"> 192         return s == PathStatus.INVALID;</span>
 193     }
 194 
 195     /**
 196      * The length of this abstract pathname&#39;s prefix, or zero if it has no
 197      * prefix.
 198      */
 199     private final transient int prefixLength;
 200 
 201     /**
 202      * Returns the length of this abstract pathname&#39;s prefix.
 203      * For use by FileSystem classes.
 204      */
 205     int getPrefixLength() {
 206         return prefixLength;
 207     }
 208 
 209     /**
 210      * The system-dependent default name-separator character.  This field is
 211      * initialized to contain the first character of the value of the system
<span class="line-modified"> 212      * property {@code file.separator}.  On UNIX systems the value of this</span>
<span class="line-modified"> 213      * field is {@code &#39;/&#39;}; on Microsoft Windows systems it is {@code &#39;\\&#39;}.</span>
 214      *
 215      * @see     java.lang.System#getProperty(java.lang.String)
 216      */
 217     public static final char separatorChar = fs.getSeparator();
 218 
 219     /**
 220      * The system-dependent default name-separator character, represented as a
 221      * string for convenience.  This string contains a single character, namely
 222      * {@link #separatorChar}.
 223      */
 224     public static final String separator = &quot;&quot; + separatorChar;
 225 
 226     /**
 227      * The system-dependent path-separator character.  This field is
 228      * initialized to contain the first character of the value of the system
<span class="line-modified"> 229      * property {@code path.separator}.  This character is used to</span>
 230      * separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;.
<span class="line-modified"> 231      * On UNIX systems, this character is {@code &#39;:&#39;}; on Microsoft Windows systems it</span>
<span class="line-modified"> 232      * is {@code &#39;;&#39;}.</span>
 233      *
 234      * @see     java.lang.System#getProperty(java.lang.String)
 235      */
 236     public static final char pathSeparatorChar = fs.getPathSeparator();
 237 
 238     /**
 239      * The system-dependent path-separator character, represented as a string
 240      * for convenience.  This string contains a single character, namely
 241      * {@link #pathSeparatorChar}.
 242      */
 243     public static final String pathSeparator = &quot;&quot; + pathSeparatorChar;
 244 
 245 
 246     /* -- Constructors -- */
 247 
 248     /**
 249      * Internal constructor for already-normalized pathname strings.
 250      */
 251     private File(String pathname, int prefixLength) {
 252         this.path = pathname;
 253         this.prefixLength = prefixLength;
 254     }
 255 
 256     /**
 257      * Internal constructor for already-normalized pathname strings.
 258      * The parameter order is used to disambiguate this method from the
 259      * public(File, String) constructor.
 260      */
 261     private File(String child, File parent) {
 262         assert parent.path != null;
 263         assert (!parent.path.isEmpty());
 264         this.path = fs.resolve(parent.path, child);
 265         this.prefixLength = parent.prefixLength;
 266     }
 267 
 268     /**
<span class="line-modified"> 269      * Creates a new {@code File} instance by converting the given</span>
 270      * pathname string into an abstract pathname.  If the given string is
 271      * the empty string, then the result is the empty abstract pathname.
 272      *
 273      * @param   pathname  A pathname string
 274      * @throws  NullPointerException
<span class="line-modified"> 275      *          If the {@code pathname} argument is {@code null}</span>
 276      */
 277     public File(String pathname) {
 278         if (pathname == null) {
 279             throw new NullPointerException();
 280         }
 281         this.path = fs.normalize(pathname);
 282         this.prefixLength = fs.prefixLength(this.path);
 283     }
 284 
 285     /* Note: The two-argument File constructors do not interpret an empty
 286        parent abstract pathname as the current user directory.  An empty parent
 287        instead causes the child to be resolved against the system-dependent
 288        directory defined by the FileSystem.getDefaultParent method.  On Unix
 289        this default is &quot;/&quot;, while on Microsoft Windows it is &quot;\\&quot;.  This is required for
 290        compatibility with the original behavior of this class. */
 291 
 292     /**
<span class="line-modified"> 293      * Creates a new {@code File} instance from a parent pathname string</span>
 294      * and a child pathname string.
 295      *
<span class="line-modified"> 296      * &lt;p&gt; If {@code parent} is {@code null} then the new</span>
<span class="line-modified"> 297      * {@code File} instance is created as if by invoking the</span>
<span class="line-modified"> 298      * single-argument {@code File} constructor on the given</span>
<span class="line-modified"> 299      * {@code child} pathname string.</span>
 300      *
<span class="line-modified"> 301      * &lt;p&gt; Otherwise the {@code parent} pathname string is taken to denote</span>
<span class="line-modified"> 302      * a directory, and the {@code child} pathname string is taken to</span>
<span class="line-modified"> 303      * denote either a directory or a file.  If the {@code child} pathname</span>
 304      * string is absolute then it is converted into a relative pathname in a
<span class="line-modified"> 305      * system-dependent way.  If {@code parent} is the empty string then</span>
<span class="line-modified"> 306      * the new {@code File} instance is created by converting</span>
<span class="line-modified"> 307      * {@code child} into an abstract pathname and resolving the result</span>
 308      * against a system-dependent default directory.  Otherwise each pathname
 309      * string is converted into an abstract pathname and the child abstract
 310      * pathname is resolved against the parent.
 311      *
 312      * @param   parent  The parent pathname string
 313      * @param   child   The child pathname string
 314      * @throws  NullPointerException
<span class="line-modified"> 315      *          If {@code child} is {@code null}</span>
 316      */
 317     public File(String parent, String child) {
 318         if (child == null) {
 319             throw new NullPointerException();
 320         }
 321         if (parent != null) {
 322             if (parent.isEmpty()) {
 323                 this.path = fs.resolve(fs.getDefaultParent(),
 324                                        fs.normalize(child));
 325             } else {
 326                 this.path = fs.resolve(fs.normalize(parent),
 327                                        fs.normalize(child));
 328             }
 329         } else {
 330             this.path = fs.normalize(child);
 331         }
 332         this.prefixLength = fs.prefixLength(this.path);
 333     }
 334 
 335     /**
<span class="line-modified"> 336      * Creates a new {@code File} instance from a parent abstract</span>
 337      * pathname and a child pathname string.
 338      *
<span class="line-modified"> 339      * &lt;p&gt; If {@code parent} is {@code null} then the new</span>
<span class="line-modified"> 340      * {@code File} instance is created as if by invoking the</span>
<span class="line-modified"> 341      * single-argument {@code File} constructor on the given</span>
<span class="line-modified"> 342      * {@code child} pathname string.</span>
 343      *
<span class="line-modified"> 344      * &lt;p&gt; Otherwise the {@code parent} abstract pathname is taken to</span>
<span class="line-modified"> 345      * denote a directory, and the {@code child} pathname string is taken</span>
<span class="line-modified"> 346      * to denote either a directory or a file.  If the {@code child}</span>
 347      * pathname string is absolute then it is converted into a relative
<span class="line-modified"> 348      * pathname in a system-dependent way.  If {@code parent} is the empty</span>
<span class="line-modified"> 349      * abstract pathname then the new {@code File} instance is created by</span>
<span class="line-modified"> 350      * converting {@code child} into an abstract pathname and resolving</span>
 351      * the result against a system-dependent default directory.  Otherwise each
 352      * pathname string is converted into an abstract pathname and the child
 353      * abstract pathname is resolved against the parent.
 354      *
 355      * @param   parent  The parent abstract pathname
 356      * @param   child   The child pathname string
 357      * @throws  NullPointerException
<span class="line-modified"> 358      *          If {@code child} is {@code null}</span>
 359      */
 360     public File(File parent, String child) {
 361         if (child == null) {
 362             throw new NullPointerException();
 363         }
 364         if (parent != null) {
 365             if (parent.path.isEmpty()) {
 366                 this.path = fs.resolve(fs.getDefaultParent(),
 367                                        fs.normalize(child));
 368             } else {
 369                 this.path = fs.resolve(parent.path,
 370                                        fs.normalize(child));
 371             }
 372         } else {
 373             this.path = fs.normalize(child);
 374         }
 375         this.prefixLength = fs.prefixLength(this.path);
 376     }
 377 
 378     /**
</pre>
<hr />
<pre>
 444     /* -- Path-component accessors -- */
 445 
 446     /**
 447      * Returns the name of the file or directory denoted by this abstract
 448      * pathname.  This is just the last name in the pathname&#39;s name
 449      * sequence.  If the pathname&#39;s name sequence is empty, then the empty
 450      * string is returned.
 451      *
 452      * @return  The name of the file or directory denoted by this abstract
 453      *          pathname, or the empty string if this pathname&#39;s name sequence
 454      *          is empty
 455      */
 456     public String getName() {
 457         int index = path.lastIndexOf(separatorChar);
 458         if (index &lt; prefixLength) return path.substring(prefixLength);
 459         return path.substring(index + 1);
 460     }
 461 
 462     /**
 463      * Returns the pathname string of this abstract pathname&#39;s parent, or
<span class="line-modified"> 464      * {@code null} if this pathname does not name a parent directory.</span>
 465      *
 466      * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 467      * pathname&#39;s prefix, if any, and each name in the pathname&#39;s name
 468      * sequence except for the last.  If the name sequence is empty then
 469      * the pathname does not name a parent directory.
 470      *
 471      * @return  The pathname string of the parent directory named by this
<span class="line-modified"> 472      *          abstract pathname, or {@code null} if this pathname</span>
 473      *          does not name a parent
 474      */
 475     public String getParent() {
 476         int index = path.lastIndexOf(separatorChar);
 477         if (index &lt; prefixLength) {
 478             if ((prefixLength &gt; 0) &amp;&amp; (path.length() &gt; prefixLength))
 479                 return path.substring(0, prefixLength);
 480             return null;
 481         }
 482         return path.substring(0, index);
 483     }
 484 
 485     /**
 486      * Returns the abstract pathname of this abstract pathname&#39;s parent,
<span class="line-modified"> 487      * or {@code null} if this pathname does not name a parent</span>
 488      * directory.
 489      *
 490      * &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 491      * pathname&#39;s prefix, if any, and each name in the pathname&#39;s name
 492      * sequence except for the last.  If the name sequence is empty then
 493      * the pathname does not name a parent directory.
 494      *
 495      * @return  The abstract pathname of the parent directory named by this
<span class="line-modified"> 496      *          abstract pathname, or {@code null} if this pathname</span>
 497      *          does not name a parent
 498      *
 499      * @since 1.2
 500      */
 501     public File getParentFile() {
 502         String p = this.getParent();
 503         if (p == null) return null;
 504         return new File(p, this.prefixLength);
 505     }
 506 
 507     /**
 508      * Converts this abstract pathname into a pathname string.  The resulting
 509      * string uses the {@link #separator default name-separator character} to
 510      * separate the names in the name sequence.
 511      *
 512      * @return  The string form of this abstract pathname
 513      */
 514     public String getPath() {
 515         return path;
 516     }
 517 
 518 
 519     /* -- Path operations -- */
 520 
 521     /**
 522      * Tests whether this abstract pathname is absolute.  The definition of
 523      * absolute pathname is system dependent.  On UNIX systems, a pathname is
<span class="line-modified"> 524      * absolute if its prefix is {@code &quot;/&quot;}.  On Microsoft Windows systems, a</span>
 525      * pathname is absolute if its prefix is a drive specifier followed by
<span class="line-modified"> 526      * {@code &quot;\\&quot;}, or if its prefix is {@code &quot;\\\\&quot;}.</span>
 527      *
<span class="line-modified"> 528      * @return  {@code true} if this abstract pathname is absolute,</span>
<span class="line-modified"> 529      *          {@code false} otherwise</span>
 530      */
 531     public boolean isAbsolute() {
 532         return fs.isAbsolute(this);
 533     }
 534 
 535     /**
 536      * Returns the absolute pathname string of this abstract pathname.
 537      *
 538      * &lt;p&gt; If this abstract pathname is already absolute, then the pathname
 539      * string is simply returned as if by the {@link #getPath}
 540      * method.  If this abstract pathname is the empty abstract pathname then
 541      * the pathname string of the current user directory, which is named by the
<span class="line-modified"> 542      * system property {@code user.dir}, is returned.  Otherwise this</span>
 543      * pathname is resolved in a system-dependent way.  On UNIX systems, a
 544      * relative pathname is made absolute by resolving it against the current
 545      * user directory.  On Microsoft Windows systems, a relative pathname is made absolute
 546      * by resolving it against the current directory of the drive named by the
 547      * pathname, if any; if not, it is resolved against the current user
 548      * directory.
 549      *
 550      * @return  The absolute pathname string denoting the same file or
 551      *          directory as this abstract pathname
 552      *
 553      * @throws  SecurityException
 554      *          If a required system property value cannot be accessed.
 555      *
 556      * @see     java.io.File#isAbsolute()
 557      */
 558     public String getAbsolutePath() {
 559         return fs.resolve(this);
 560     }
 561 
 562     /**
</pre>
<hr />
<pre>
 642      * @since 1.2
 643      * @see     Path#toRealPath
 644      */
 645     public File getCanonicalFile() throws IOException {
 646         String canonPath = getCanonicalPath();
 647         return new File(canonPath, fs.prefixLength(canonPath));
 648     }
 649 
 650     private static String slashify(String path, boolean isDirectory) {
 651         String p = path;
 652         if (File.separatorChar != &#39;/&#39;)
 653             p = p.replace(File.separatorChar, &#39;/&#39;);
 654         if (!p.startsWith(&quot;/&quot;))
 655             p = &quot;/&quot; + p;
 656         if (!p.endsWith(&quot;/&quot;) &amp;&amp; isDirectory)
 657             p = p + &quot;/&quot;;
 658         return p;
 659     }
 660 
 661     /**
<span class="line-modified"> 662      * Converts this abstract pathname into a {@code file:} URL.  The</span>
 663      * exact form of the URL is system-dependent.  If it can be determined that
 664      * the file denoted by this abstract pathname is a directory, then the
 665      * resulting URL will end with a slash.
 666      *
 667      * @return  A URL object representing the equivalent file URL
 668      *
 669      * @throws  MalformedURLException
 670      *          If the path cannot be parsed as a URL
 671      *
 672      * @see     #toURI()
 673      * @see     java.net.URI
 674      * @see     java.net.URI#toURL()
 675      * @see     java.net.URL
 676      * @since   1.2
 677      *
 678      * @deprecated This method does not automatically escape characters that
 679      * are illegal in URLs.  It is recommended that new code convert an
 680      * abstract pathname into a URL by first converting it into a URI, via the
 681      * {@link #toURI() toURI} method, and then converting the URI into a URL
 682      * via the {@link java.net.URI#toURL() URI.toURL} method.
</pre>
<hr />
<pre>
 735             File f = getAbsoluteFile();
 736             String sp = slashify(f.getPath(), f.isDirectory());
 737             if (sp.startsWith(&quot;//&quot;))
 738                 sp = &quot;//&quot; + sp;
 739             return new URI(&quot;file&quot;, null, sp, null);
 740         } catch (URISyntaxException x) {
 741             throw new Error(x);         // Can&#39;t happen
 742         }
 743     }
 744 
 745 
 746     /* -- Attribute accessors -- */
 747 
 748     /**
 749      * Tests whether the application can read the file denoted by this
 750      * abstract pathname. On some platforms it may be possible to start the
 751      * Java virtual machine with special privileges that allow it to read
 752      * files that are marked as unreadable. Consequently this method may return
 753      * {@code true} even though the file does not have read permissions.
 754      *
<span class="line-modified"> 755      * @return  {@code true} if and only if the file specified by this</span>
 756      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; can be read by the
<span class="line-modified"> 757      *          application; {@code false} otherwise</span>
 758      *
 759      * @throws  SecurityException
 760      *          If a security manager exists and its {@link
 761      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 762      *          method denies read access to the file
 763      */
 764     public boolean canRead() {
 765         SecurityManager security = System.getSecurityManager();
 766         if (security != null) {
 767             security.checkRead(path);
 768         }
 769         if (isInvalid()) {
 770             return false;
 771         }
 772         return fs.checkAccess(this, FileSystem.ACCESS_READ);
 773     }
 774 
 775     /**
 776      * Tests whether the application can modify the file denoted by this
 777      * abstract pathname. On some platforms it may be possible to start the
 778      * Java virtual machine with special privileges that allow it to modify
 779      * files that are marked read-only. Consequently this method may return
 780      * {@code true} even though the file is marked read-only.
 781      *
<span class="line-modified"> 782      * @return  {@code true} if and only if the file system actually</span>
 783      *          contains a file denoted by this abstract pathname &lt;em&gt;and&lt;/em&gt;
 784      *          the application is allowed to write to the file;
<span class="line-modified"> 785      *          {@code false} otherwise.</span>
 786      *
 787      * @throws  SecurityException
 788      *          If a security manager exists and its {@link
 789      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
 790      *          method denies write access to the file
 791      */
 792     public boolean canWrite() {
 793         SecurityManager security = System.getSecurityManager();
 794         if (security != null) {
 795             security.checkWrite(path);
 796         }
 797         if (isInvalid()) {
 798             return false;
 799         }
 800         return fs.checkAccess(this, FileSystem.ACCESS_WRITE);
 801     }
 802 
 803     /**
 804      * Tests whether the file or directory denoted by this abstract pathname
 805      * exists.
 806      *
<span class="line-modified"> 807      * @return  {@code true} if and only if the file or directory denoted</span>
<span class="line-modified"> 808      *          by this abstract pathname exists; {@code false} otherwise</span>
 809      *
 810      * @throws  SecurityException
 811      *          If a security manager exists and its {@link
 812      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 813      *          method denies read access to the file or directory
 814      */
 815     public boolean exists() {
 816         SecurityManager security = System.getSecurityManager();
 817         if (security != null) {
 818             security.checkRead(path);
 819         }
 820         if (isInvalid()) {
 821             return false;
 822         }
 823         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_EXISTS) != 0);
 824     }
 825 
 826     /**
 827      * Tests whether the file denoted by this abstract pathname is a
 828      * directory.
 829      *
 830      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 831      * that the file is not a directory, or where several attributes of the
 832      * same file are required at the same time, then the {@link
 833      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 834      * Files.readAttributes} method may be used.
 835      *
<span class="line-modified"> 836      * @return {@code true} if and only if the file denoted by this</span>
 837      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a directory;
<span class="line-modified"> 838      *          {@code false} otherwise</span>
 839      *
 840      * @throws  SecurityException
 841      *          If a security manager exists and its {@link
 842      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 843      *          method denies read access to the file
 844      */
 845     public boolean isDirectory() {
 846         SecurityManager security = System.getSecurityManager();
 847         if (security != null) {
 848             security.checkRead(path);
 849         }
 850         if (isInvalid()) {
 851             return false;
 852         }
 853         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_DIRECTORY)
 854                 != 0);
 855     }
 856 
 857     /**
 858      * Tests whether the file denoted by this abstract pathname is a normal
 859      * file.  A file is &lt;em&gt;normal&lt;/em&gt; if it is not a directory and, in
 860      * addition, satisfies other system-dependent criteria.  Any non-directory
 861      * file created by a Java application is guaranteed to be a normal file.
 862      *
 863      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 864      * that the file is not a normal file, or where several attributes of the
 865      * same file are required at the same time, then the {@link
 866      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 867      * Files.readAttributes} method may be used.
 868      *
<span class="line-modified"> 869      * @return  {@code true} if and only if the file denoted by this</span>
 870      *          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a normal file;
<span class="line-modified"> 871      *          {@code false} otherwise</span>
 872      *
 873      * @throws  SecurityException
 874      *          If a security manager exists and its {@link
 875      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 876      *          method denies read access to the file
 877      */
 878     public boolean isFile() {
 879         SecurityManager security = System.getSecurityManager();
 880         if (security != null) {
 881             security.checkRead(path);
 882         }
 883         if (isInvalid()) {
 884             return false;
 885         }
 886         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_REGULAR) != 0);
 887     }
 888 
 889     /**
 890      * Tests whether the file named by this abstract pathname is a hidden
 891      * file.  The exact definition of &lt;em&gt;hidden&lt;/em&gt; is system-dependent.  On
 892      * UNIX systems, a file is considered to be hidden if its name begins with
<span class="line-modified"> 893      * a period character ({@code &#39;.&#39;}).  On Microsoft Windows systems, a file is</span>
 894      * considered to be hidden if it has been marked as such in the filesystem.
 895      *
<span class="line-modified"> 896      * @return  {@code true} if and only if the file denoted by this</span>
 897      *          abstract pathname is hidden according to the conventions of the
 898      *          underlying platform
 899      *
 900      * @throws  SecurityException
 901      *          If a security manager exists and its {@link
 902      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 903      *          method denies read access to the file
 904      *
 905      * @since 1.2
 906      */
 907     public boolean isHidden() {
 908         SecurityManager security = System.getSecurityManager();
 909         if (security != null) {
 910             security.checkRead(path);
 911         }
 912         if (isInvalid()) {
 913             return false;
 914         }
 915         return ((fs.getBooleanAttributes(this) &amp; FileSystem.BA_HIDDEN) != 0);
 916     }
</pre>
<hr />
<pre>
 918     /**
 919      * Returns the time that the file denoted by this abstract pathname was
 920      * last modified.
 921      *
 922      * @apiNote
 923      * While the unit of time of the return value is milliseconds, the
 924      * granularity of the value depends on the underlying file system and may
 925      * be larger.  For example, some file systems use time stamps in units of
 926      * seconds.
 927      *
 928      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 929      * where {@code 0L} is returned, or where several attributes of the
 930      * same file are required at the same time, or where the time of last
 931      * access or the creation time are required, then the {@link
 932      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 933      * Files.readAttributes} method may be used.  If however only the
 934      * time of last modification is required, then the
 935      * {@link java.nio.file.Files#getLastModifiedTime(Path,LinkOption[])
 936      * Files.getLastModifiedTime} method may be used instead.
 937      *
<span class="line-modified"> 938      * @return  A {@code long} value representing the time the file was</span>
 939      *          last modified, measured in milliseconds since the epoch
<span class="line-modified"> 940      *          (00:00:00 GMT, January 1, 1970), or {@code 0L} if the</span>
 941      *          file does not exist or if an I/O error occurs.  The value may
 942      *          be negative indicating the number of milliseconds before the
 943      *          epoch
 944      *
 945      * @throws  SecurityException
 946      *          If a security manager exists and its {@link
 947      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 948      *          method denies read access to the file
 949      */
 950     public long lastModified() {
 951         SecurityManager security = System.getSecurityManager();
 952         if (security != null) {
 953             security.checkRead(path);
 954         }
 955         if (isInvalid()) {
 956             return 0L;
 957         }
 958         return fs.getLastModifiedTime(this);
 959     }
 960 
 961     /**
 962      * Returns the length of the file denoted by this abstract pathname.
 963      * The return value is unspecified if this pathname denotes a directory.
 964      *
 965      * &lt;p&gt; Where it is required to distinguish an I/O exception from the case
 966      * that {@code 0L} is returned, or where several attributes of the same file
 967      * are required at the same time, then the {@link
 968      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
 969      * Files.readAttributes} method may be used.
 970      *
 971      * @return  The length, in bytes, of the file denoted by this abstract
<span class="line-modified"> 972      *          pathname, or {@code 0L} if the file does not exist.  Some</span>
<span class="line-modified"> 973      *          operating systems may return {@code 0L} for pathnames</span>
 974      *          denoting system-dependent entities such as devices or pipes.
 975      *
 976      * @throws  SecurityException
 977      *          If a security manager exists and its {@link
 978      *          java.lang.SecurityManager#checkRead(java.lang.String)}
 979      *          method denies read access to the file
 980      */
 981     public long length() {
 982         SecurityManager security = System.getSecurityManager();
 983         if (security != null) {
 984             security.checkRead(path);
 985         }
 986         if (isInvalid()) {
 987             return 0L;
 988         }
 989         return fs.getLength(this);
 990     }
 991 
 992 
 993     /* -- File operations -- */
 994 
 995     /**
 996      * Atomically creates a new, empty file named by this abstract pathname if
 997      * and only if a file with this name does not yet exist.  The check for the
 998      * existence of the file and the creation of the file if it does not exist
 999      * are a single operation that is atomic with respect to all other
1000      * filesystem activities that might affect the file.
1001      * &lt;P&gt;
1002      * Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
1003      * the resulting protocol cannot be made to work reliably. The
1004      * {@link java.nio.channels.FileLock FileLock}
1005      * facility should be used instead.
1006      *
<span class="line-modified">1007      * @return  {@code true} if the named file does not exist and was</span>
<span class="line-modified">1008      *          successfully created; {@code false} if the named file</span>
1009      *          already exists
1010      *
1011      * @throws  IOException
1012      *          If an I/O error occurred
1013      *
1014      * @throws  SecurityException
1015      *          If a security manager exists and its {@link
1016      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1017      *          method denies write access to the file
1018      *
1019      * @since 1.2
1020      */
1021     public boolean createNewFile() throws IOException {
1022         SecurityManager security = System.getSecurityManager();
1023         if (security != null) security.checkWrite(path);
1024         if (isInvalid()) {
1025             throw new IOException(&quot;Invalid file path&quot;);
1026         }
1027         return fs.createFileExclusively(path);
1028     }
1029 
1030     /**
1031      * Deletes the file or directory denoted by this abstract pathname.  If
1032      * this pathname denotes a directory, then the directory must be empty in
1033      * order to be deleted.
1034      *
1035      * &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link
1036      * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}
1037      * when a file cannot be deleted. This is useful for error reporting and to
1038      * diagnose why a file cannot be deleted.
1039      *
<span class="line-modified">1040      * @return  {@code true} if and only if the file or directory is</span>
<span class="line-modified">1041      *          successfully deleted; {@code false} otherwise</span>
1042      *
1043      * @throws  SecurityException
1044      *          If a security manager exists and its {@link
1045      *          java.lang.SecurityManager#checkDelete} method denies
1046      *          delete access to the file
1047      */
1048     public boolean delete() {
1049         SecurityManager security = System.getSecurityManager();
1050         if (security != null) {
1051             security.checkDelete(path);
1052         }
1053         if (isInvalid()) {
1054             return false;
1055         }
1056         return fs.delete(this);
1057     }
1058 
1059     /**
1060      * Requests that the file or directory denoted by this abstract
1061      * pathname be deleted when the virtual machine terminates.
</pre>
<hr />
<pre>
1295      *          the directory
1296      *
1297      * @since  1.2
1298      * @see java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)
1299      */
1300     public File[] listFiles(FileFilter filter) {
1301         String ss[] = list();
1302         if (ss == null) return null;
1303         ArrayList&lt;File&gt; files = new ArrayList&lt;&gt;();
1304         for (String s : ss) {
1305             File f = new File(s, this);
1306             if ((filter == null) || filter.accept(f))
1307                 files.add(f);
1308         }
1309         return files.toArray(new File[files.size()]);
1310     }
1311 
1312     /**
1313      * Creates the directory named by this abstract pathname.
1314      *
<span class="line-modified">1315      * @return  {@code true} if and only if the directory was</span>
<span class="line-modified">1316      *          created; {@code false} otherwise</span>
1317      *
1318      * @throws  SecurityException
1319      *          If a security manager exists and its {@link
1320      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1321      *          method does not permit the named directory to be created
1322      */
1323     public boolean mkdir() {
1324         SecurityManager security = System.getSecurityManager();
1325         if (security != null) {
1326             security.checkWrite(path);
1327         }
1328         if (isInvalid()) {
1329             return false;
1330         }
1331         return fs.createDirectory(this);
1332     }
1333 
1334     /**
1335      * Creates the directory named by this abstract pathname, including any
1336      * necessary but nonexistent parent directories.  Note that if this
1337      * operation fails it may have succeeded in creating some of the necessary
1338      * parent directories.
1339      *
<span class="line-modified">1340      * @return  {@code true} if and only if the directory was created,</span>
<span class="line-modified">1341      *          along with all necessary parent directories; {@code false}</span>
1342      *          otherwise
1343      *
1344      * @throws  SecurityException
1345      *          If a security manager exists and its {@link
1346      *          java.lang.SecurityManager#checkRead(java.lang.String)}
1347      *          method does not permit verification of the existence of the
1348      *          named directory and all necessary parent directories; or if
1349      *          the {@link
1350      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1351      *          method does not permit the named directory and all necessary
1352      *          parent directories to be created
1353      */
1354     public boolean mkdirs() {
1355         if (exists()) {
1356             return false;
1357         }
1358         if (mkdir()) {
1359             return true;
1360         }
1361         File canonFile = null;
</pre>
<hr />
<pre>
1369         return (parent != null &amp;&amp; (parent.mkdirs() || parent.exists()) &amp;&amp;
1370                 canonFile.mkdir());
1371     }
1372 
1373     /**
1374      * Renames the file denoted by this abstract pathname.
1375      *
1376      * &lt;p&gt; Many aspects of the behavior of this method are inherently
1377      * platform-dependent: The rename operation might not be able to move a
1378      * file from one filesystem to another, it might not be atomic, and it
1379      * might not succeed if a file with the destination abstract pathname
1380      * already exists.  The return value should always be checked to make sure
1381      * that the rename operation was successful.
1382      *
1383      * &lt;p&gt; Note that the {@link java.nio.file.Files} class defines the {@link
1384      * java.nio.file.Files#move move} method to move or rename a file in a
1385      * platform independent manner.
1386      *
1387      * @param  dest  The new abstract pathname for the named file
1388      *
<span class="line-modified">1389      * @return  {@code true} if and only if the renaming succeeded;</span>
<span class="line-modified">1390      *          {@code false} otherwise</span>
1391      *
1392      * @throws  SecurityException
1393      *          If a security manager exists and its {@link
1394      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1395      *          method denies write access to either the old or new pathnames
1396      *
1397      * @throws  NullPointerException
<span class="line-modified">1398      *          If parameter {@code dest} is {@code null}</span>
1399      */
1400     public boolean renameTo(File dest) {
1401         if (dest == null) {
1402             throw new NullPointerException();
1403         }
1404         SecurityManager security = System.getSecurityManager();
1405         if (security != null) {
1406             security.checkWrite(path);
1407             security.checkWrite(dest.path);
1408         }
1409         if (this.isInvalid() || dest.isInvalid()) {
1410             return false;
1411         }
1412         return fs.rename(this, dest);
1413     }
1414 
1415     /**
1416      * Sets the last-modified time of the file or directory named by this
1417      * abstract pathname.
1418      *
1419      * &lt;p&gt; All platforms support file-modification times to the nearest second,
1420      * but some provide more precision.  The argument will be truncated to fit
1421      * the supported precision.  If the operation succeeds and no intervening
1422      * operations on the file take place, then the next invocation of the
1423      * {@link #lastModified} method will return the (possibly
<span class="line-modified">1424      * truncated) {@code time} argument that was passed to this method.</span>
1425      *
1426      * @param  time  The new last-modified time, measured in milliseconds since
1427      *               the epoch (00:00:00 GMT, January 1, 1970)
1428      *
<span class="line-modified">1429      * @return {@code true} if and only if the operation succeeded;</span>
<span class="line-modified">1430      *          {@code false} otherwise</span>
1431      *
1432      * @throws  IllegalArgumentException  If the argument is negative
1433      *
1434      * @throws  SecurityException
1435      *          If a security manager exists and its {@link
1436      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1437      *          method denies write access to the named file
1438      *
1439      * @since 1.2
1440      */
1441     public boolean setLastModified(long time) {
1442         if (time &lt; 0) throw new IllegalArgumentException(&quot;Negative time&quot;);
1443         SecurityManager security = System.getSecurityManager();
1444         if (security != null) {
1445             security.checkWrite(path);
1446         }
1447         if (isInvalid()) {
1448             return false;
1449         }
1450         return fs.setLastModifiedTime(this, time);
1451     }
1452 
1453     /**
1454      * Marks the file or directory named by this abstract pathname so that
1455      * only read operations are allowed. After invoking this method the file
1456      * or directory will not change until it is either deleted or marked
1457      * to allow write access. On some platforms it may be possible to start the
1458      * Java virtual machine with special privileges that allow it to modify
1459      * files that are marked read-only. Whether or not a read-only file or
1460      * directory may be deleted depends upon the underlying system.
1461      *
<span class="line-modified">1462      * @return {@code true} if and only if the operation succeeded;</span>
<span class="line-modified">1463      *          {@code false} otherwise</span>
1464      *
1465      * @throws  SecurityException
1466      *          If a security manager exists and its {@link
1467      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1468      *          method denies write access to the named file
1469      *
1470      * @since 1.2
1471      */
1472     public boolean setReadOnly() {
1473         SecurityManager security = System.getSecurityManager();
1474         if (security != null) {
1475             security.checkWrite(path);
1476         }
1477         if (isInvalid()) {
1478             return false;
1479         }
1480         return fs.setReadOnly(this);
1481     }
1482 
1483     /**
1484      * Sets the owner&#39;s or everybody&#39;s write permission for this abstract
1485      * pathname. On some platforms it may be possible to start the Java virtual
1486      * machine with special privileges that allow it to modify files that
1487      * disallow write operations.
1488      *
1489      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1490      * file attributes including file permissions. This may be used when finer
1491      * manipulation of file permissions is required.
1492      *
1493      * @param   writable
<span class="line-modified">1494      *          If {@code true}, sets the access permission to allow write</span>
<span class="line-modified">1495      *          operations; if {@code false} to disallow write operations</span>
1496      *
1497      * @param   ownerOnly
<span class="line-modified">1498      *          If {@code true}, the write permission applies only to the</span>
1499      *          owner&#39;s write permission; otherwise, it applies to everybody.  If
1500      *          the underlying file system can not distinguish the owner&#39;s write
1501      *          permission from that of others, then the permission will apply to
1502      *          everybody, regardless of this value.
1503      *
<span class="line-modified">1504      * @return  {@code true} if and only if the operation succeeded. The</span>
1505      *          operation will fail if the user does not have permission to change
1506      *          the access permissions of this abstract pathname.
1507      *
1508      * @throws  SecurityException
1509      *          If a security manager exists and its {@link
1510      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1511      *          method denies write access to the named file
1512      *
1513      * @since 1.6
1514      */
1515     public boolean setWritable(boolean writable, boolean ownerOnly) {
1516         SecurityManager security = System.getSecurityManager();
1517         if (security != null) {
1518             security.checkWrite(path);
1519         }
1520         if (isInvalid()) {
1521             return false;
1522         }
1523         return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);
1524     }
1525 
1526     /**
1527      * A convenience method to set the owner&#39;s write permission for this abstract
1528      * pathname. On some platforms it may be possible to start the Java virtual
1529      * machine with special privileges that allow it to modify files that
1530      * disallow write operations.
1531      *
1532      * &lt;p&gt; An invocation of this method of the form {@code file.setWritable(arg)}
1533      * behaves in exactly the same way as the invocation
1534      *
1535      * &lt;pre&gt;{@code
1536      *     file.setWritable(arg, true)
1537      * }&lt;/pre&gt;
1538      *
1539      * @param   writable
<span class="line-modified">1540      *          If {@code true}, sets the access permission to allow write</span>
<span class="line-modified">1541      *          operations; if {@code false} to disallow write operations</span>
1542      *
<span class="line-modified">1543      * @return  {@code true} if and only if the operation succeeded.  The</span>
1544      *          operation will fail if the user does not have permission to
1545      *          change the access permissions of this abstract pathname.
1546      *
1547      * @throws  SecurityException
1548      *          If a security manager exists and its {@link
1549      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1550      *          method denies write access to the file
1551      *
1552      * @since 1.6
1553      */
1554     public boolean setWritable(boolean writable) {
1555         return setWritable(writable, true);
1556     }
1557 
1558     /**
1559      * Sets the owner&#39;s or everybody&#39;s read permission for this abstract
1560      * pathname. On some platforms it may be possible to start the Java virtual
1561      * machine with special privileges that allow it to read files that are
1562      * marked as unreadable.
1563      *
1564      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1565      * file attributes including file permissions. This may be used when finer
1566      * manipulation of file permissions is required.
1567      *
1568      * @param   readable
<span class="line-modified">1569      *          If {@code true}, sets the access permission to allow read</span>
<span class="line-modified">1570      *          operations; if {@code false} to disallow read operations</span>
1571      *
1572      * @param   ownerOnly
<span class="line-modified">1573      *          If {@code true}, the read permission applies only to the</span>
1574      *          owner&#39;s read permission; otherwise, it applies to everybody.  If
1575      *          the underlying file system can not distinguish the owner&#39;s read
1576      *          permission from that of others, then the permission will apply to
1577      *          everybody, regardless of this value.
1578      *
<span class="line-modified">1579      * @return  {@code true} if and only if the operation succeeded.  The</span>
1580      *          operation will fail if the user does not have permission to
1581      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1582      *          {@code readable} is {@code false} and the underlying</span>
1583      *          file system does not implement a read permission, then the
1584      *          operation will fail.
1585      *
1586      * @throws  SecurityException
1587      *          If a security manager exists and its {@link
1588      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1589      *          method denies write access to the file
1590      *
1591      * @since 1.6
1592      */
1593     public boolean setReadable(boolean readable, boolean ownerOnly) {
1594         SecurityManager security = System.getSecurityManager();
1595         if (security != null) {
1596             security.checkWrite(path);
1597         }
1598         if (isInvalid()) {
1599             return false;
1600         }
1601         return fs.setPermission(this, FileSystem.ACCESS_READ, readable, ownerOnly);
1602     }
1603 
1604     /**
1605      * A convenience method to set the owner&#39;s read permission for this abstract
1606      * pathname. On some platforms it may be possible to start the Java virtual
1607      * machine with special privileges that allow it to read files that are
1608      * marked as unreadable.
1609      *
1610      * &lt;p&gt;An invocation of this method of the form {@code file.setReadable(arg)}
1611      * behaves in exactly the same way as the invocation
1612      *
1613      * &lt;pre&gt;{@code
1614      *     file.setReadable(arg, true)
1615      * }&lt;/pre&gt;
1616      *
1617      * @param  readable
<span class="line-modified">1618      *          If {@code true}, sets the access permission to allow read</span>
<span class="line-modified">1619      *          operations; if {@code false} to disallow read operations</span>
1620      *
<span class="line-modified">1621      * @return  {@code true} if and only if the operation succeeded.  The</span>
1622      *          operation will fail if the user does not have permission to
1623      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1624      *          {@code readable} is {@code false} and the underlying</span>
1625      *          file system does not implement a read permission, then the
1626      *          operation will fail.
1627      *
1628      * @throws  SecurityException
1629      *          If a security manager exists and its {@link
1630      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1631      *          method denies write access to the file
1632      *
1633      * @since 1.6
1634      */
1635     public boolean setReadable(boolean readable) {
1636         return setReadable(readable, true);
1637     }
1638 
1639     /**
1640      * Sets the owner&#39;s or everybody&#39;s execute permission for this abstract
1641      * pathname. On some platforms it may be possible to start the Java virtual
1642      * machine with special privileges that allow it to execute files that are
1643      * not marked executable.
1644      *
1645      * &lt;p&gt; The {@link java.nio.file.Files} class defines methods that operate on
1646      * file attributes including file permissions. This may be used when finer
1647      * manipulation of file permissions is required.
1648      *
1649      * @param   executable
<span class="line-modified">1650      *          If {@code true}, sets the access permission to allow execute</span>
<span class="line-modified">1651      *          operations; if {@code false} to disallow execute operations</span>
1652      *
1653      * @param   ownerOnly
<span class="line-modified">1654      *          If {@code true}, the execute permission applies only to the</span>
1655      *          owner&#39;s execute permission; otherwise, it applies to everybody.
1656      *          If the underlying file system can not distinguish the owner&#39;s
1657      *          execute permission from that of others, then the permission will
1658      *          apply to everybody, regardless of this value.
1659      *
<span class="line-modified">1660      * @return  {@code true} if and only if the operation succeeded.  The</span>
1661      *          operation will fail if the user does not have permission to
1662      *          change the access permissions of this abstract pathname.  If
<span class="line-modified">1663      *          {@code executable} is {@code false} and the underlying</span>
1664      *          file system does not implement an execute permission, then the
1665      *          operation will fail.
1666      *
1667      * @throws  SecurityException
1668      *          If a security manager exists and its {@link
1669      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1670      *          method denies write access to the file
1671      *
1672      * @since 1.6
1673      */
1674     public boolean setExecutable(boolean executable, boolean ownerOnly) {
1675         SecurityManager security = System.getSecurityManager();
1676         if (security != null) {
1677             security.checkWrite(path);
1678         }
1679         if (isInvalid()) {
1680             return false;
1681         }
1682         return fs.setPermission(this, FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
1683     }
1684 
1685     /**
1686      * A convenience method to set the owner&#39;s execute permission for this
1687      * abstract pathname. On some platforms it may be possible to start the Java
1688      * virtual machine with special privileges that allow it to execute files
1689      * that are not marked executable.
1690      *
1691      * &lt;p&gt;An invocation of this method of the form {@code file.setExcutable(arg)}
1692      * behaves in exactly the same way as the invocation
1693      *
1694      * &lt;pre&gt;{@code
1695      *     file.setExecutable(arg, true)
1696      * }&lt;/pre&gt;
1697      *
1698      * @param   executable
<span class="line-modified">1699      *          If {@code true}, sets the access permission to allow execute</span>
<span class="line-modified">1700      *          operations; if {@code false} to disallow execute operations</span>
1701      *
<span class="line-modified">1702      * @return   {@code true} if and only if the operation succeeded.  The</span>
1703      *           operation will fail if the user does not have permission to
1704      *           change the access permissions of this abstract pathname.  If
<span class="line-modified">1705      *           {@code executable} is {@code false} and the underlying</span>
1706      *           file system does not implement an execute permission, then the
1707      *           operation will fail.
1708      *
1709      * @throws  SecurityException
1710      *          If a security manager exists and its {@link
1711      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
1712      *          method denies write access to the file
1713      *
1714      * @since 1.6
1715      */
1716     public boolean setExecutable(boolean executable) {
1717         return setExecutable(executable, true);
1718     }
1719 
1720     /**
1721      * Tests whether the application can execute the file denoted by this
1722      * abstract pathname. On some platforms it may be possible to start the
1723      * Java virtual machine with special privileges that allow it to execute
1724      * files that are not marked executable. Consequently this method may return
1725      * {@code true} even though the file does not have execute permissions.
1726      *
<span class="line-modified">1727      * @return  {@code true} if and only if the abstract pathname exists</span>
1728      *          &lt;em&gt;and&lt;/em&gt; the application is allowed to execute the file
1729      *
1730      * @throws  SecurityException
1731      *          If a security manager exists and its {@link
1732      *          java.lang.SecurityManager#checkExec(java.lang.String)}
1733      *          method denies execute access to the file
1734      *
1735      * @since 1.6
1736      */
1737     public boolean canExecute() {
1738         SecurityManager security = System.getSecurityManager();
1739         if (security != null) {
1740             security.checkExec(path);
1741         }
1742         if (isInvalid()) {
1743             return false;
1744         }
1745         return fs.checkAccess(this, FileSystem.ACCESS_EXECUTE);
1746     }
1747 
</pre>
<hr />
<pre>
1782      * particular root directory, then that directory will not appear in the
1783      * result.
1784      *
1785      * @return  An array of {@code File} objects denoting the available
1786      *          filesystem roots, or {@code null} if the set of roots could not
1787      *          be determined.  The array will be empty if there are no
1788      *          filesystem roots.
1789      *
1790      * @since  1.2
1791      * @see java.nio.file.FileStore
1792      */
1793     public static File[] listRoots() {
1794         return fs.listRoots();
1795     }
1796 
1797 
1798     /* -- Disk usage -- */
1799 
1800     /**
1801      * Returns the size of the partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this
<span class="line-modified">1802      * abstract pathname. If the total number of bytes in the partition is</span>
<span class="line-added">1803      * greater than {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be</span>
<span class="line-added">1804      * returned.</span>
1805      *
1806      * @return  The size, in bytes, of the partition or {@code 0L} if this
<span class="line-modified">1807      *          abstract pathname does not name a partition or if the size</span>
<span class="line-added">1808      *          cannot be obtained</span>
1809      *
1810      * @throws  SecurityException
1811      *          If a security manager has been installed and it denies
1812      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1813      *          or its {@link SecurityManager#checkRead(String)} method denies
1814      *          read access to the file named by this abstract pathname
1815      *
1816      * @since  1.6
<span class="line-added">1817      * @see FileStore#getTotalSpace</span>
1818      */
1819     public long getTotalSpace() {
1820         SecurityManager sm = System.getSecurityManager();
1821         if (sm != null) {
1822             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1823             sm.checkRead(path);
1824         }
1825         if (isInvalid()) {
1826             return 0L;
1827         }
<span class="line-modified">1828         long space = fs.getSpace(this, FileSystem.SPACE_TOTAL);</span>
<span class="line-added">1829         return space &gt;= 0L ? space : Long.MAX_VALUE;</span>
1830     }
1831 
1832     /**
1833      * Returns the number of unallocated bytes in the partition &lt;a
<span class="line-modified">1834      * href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract path name.  If the</span>
<span class="line-added">1835      * number of unallocated bytes in the partition is greater than</span>
<span class="line-added">1836      * {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be returned.</span>
1837      *
1838      * &lt;p&gt; The returned number of unallocated bytes is a hint, but not
1839      * a guarantee, that it is possible to use most or any of these
1840      * bytes.  The number of unallocated bytes is most likely to be
1841      * accurate immediately after this call.  It is likely to be made
1842      * inaccurate by any external I/O operations including those made
1843      * on the system outside of this virtual machine.  This method
1844      * makes no guarantee that write operations to this file system
1845      * will succeed.
1846      *
1847      * @return  The number of unallocated bytes on the partition or {@code 0L}
<span class="line-modified">1848      *          if the abstract pathname does not name a partition or if this</span>
<span class="line-modified">1849      *          number cannot be obtained.  This value will be less than or</span>
<span class="line-modified">1850      *          equal to the total file system size returned by</span>
<span class="line-added">1851      *          {@link #getTotalSpace}.</span>
1852      *
1853      * @throws  SecurityException
1854      *          If a security manager has been installed and it denies
1855      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1856      *          or its {@link SecurityManager#checkRead(String)} method denies
1857      *          read access to the file named by this abstract pathname
1858      *
1859      * @since  1.6
<span class="line-added">1860      * @see FileStore#getUnallocatedSpace</span>
1861      */
1862     public long getFreeSpace() {
1863         SecurityManager sm = System.getSecurityManager();
1864         if (sm != null) {
1865             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1866             sm.checkRead(path);
1867         }
1868         if (isInvalid()) {
1869             return 0L;
1870         }
<span class="line-modified">1871         long space = fs.getSpace(this, FileSystem.SPACE_FREE);</span>
<span class="line-added">1872         return space &gt;= 0L ? space : Long.MAX_VALUE;</span>
1873     }
1874 
1875     /**
1876      * Returns the number of bytes available to this virtual machine on the
<span class="line-modified">1877      * partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract pathname.  If</span>
<span class="line-modified">1878      * the number of available bytes in the partition is greater than</span>
<span class="line-modified">1879      * {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be returned.</span>
<span class="line-modified">1880      * When possible, this method checks for write permissions and other</span>
<span class="line-modified">1881      * operating system restrictions and will therefore usually provide a more</span>
<span class="line-added">1882      * accurate estimate of how much new data can actually be written than</span>
<span class="line-added">1883      * {@link #getFreeSpace}.</span>
1884      *
1885      * &lt;p&gt; The returned number of available bytes is a hint, but not a
1886      * guarantee, that it is possible to use most or any of these bytes.  The
<span class="line-modified">1887      * number of available bytes is most likely to be accurate immediately</span>
1888      * after this call.  It is likely to be made inaccurate by any external
1889      * I/O operations including those made on the system outside of this
1890      * virtual machine.  This method makes no guarantee that write operations
1891      * to this file system will succeed.
1892      *
1893      * @return  The number of available bytes on the partition or {@code 0L}
<span class="line-modified">1894      *          if the abstract pathname does not name a partition or if this</span>
<span class="line-modified">1895      *          number cannot be obtained.  On systems where this information</span>
<span class="line-modified">1896      *          is not available, this method will be equivalent to a call to</span>
<span class="line-added">1897      *          {@link #getFreeSpace}.</span>
1898      *
1899      * @throws  SecurityException
1900      *          If a security manager has been installed and it denies
1901      *          {@link RuntimePermission}{@code (&quot;getFileSystemAttributes&quot;)}
1902      *          or its {@link SecurityManager#checkRead(String)} method denies
1903      *          read access to the file named by this abstract pathname
1904      *
1905      * @since  1.6
<span class="line-added">1906      * @see FileStore#getUsableSpace</span>
1907      */
1908     public long getUsableSpace() {
1909         SecurityManager sm = System.getSecurityManager();
1910         if (sm != null) {
1911             sm.checkPermission(new RuntimePermission(&quot;getFileSystemAttributes&quot;));
1912             sm.checkRead(path);
1913         }
1914         if (isInvalid()) {
1915             return 0L;
1916         }
<span class="line-modified">1917         long space = fs.getSpace(this, FileSystem.SPACE_USABLE);</span>
<span class="line-added">1918         return space &gt;= 0L ? space : Long.MAX_VALUE;</span>
1919     }
1920 
1921     /* -- Temporary files -- */
1922 
1923     private static class TempDirectory {
1924         private TempDirectory() { }
1925 
1926         // temporary directory location
1927         private static final File tmpdir = new File(
1928                 GetPropertyAction.privilegedGetProperty(&quot;java.io.tmpdir&quot;));
1929         static File location() {
1930             return tmpdir;
1931         }
1932 
1933         // file name generation
1934         private static final SecureRandom random = new SecureRandom();
1935         private static int shortenSubName(int subNameLength, int excess,
1936             int nameMin) {
1937             int newLength = Math.max(nameMin, subNameLength - excess);
1938             if (newLength &lt; subNameLength) {
</pre>
<hr />
<pre>
2006         }
2007     }
2008 
2009     /**
2010      * &lt;p&gt; Creates a new empty file in the specified directory, using the
2011      * given prefix and suffix strings to generate its name.  If this method
2012      * returns successfully then it is guaranteed that:
2013      *
2014      * &lt;ol&gt;
2015      * &lt;li&gt; The file denoted by the returned abstract pathname did not exist
2016      *      before this method was invoked, and
2017      * &lt;li&gt; Neither this method nor any of its variants will return the same
2018      *      abstract pathname again in the current invocation of the virtual
2019      *      machine.
2020      * &lt;/ol&gt;
2021      *
2022      * This method provides only part of a temporary-file facility.  To arrange
2023      * for a file created by this method to be deleted automatically, use the
2024      * {@link #deleteOnExit} method.
2025      *
<span class="line-modified">2026      * &lt;p&gt; The {@code prefix} argument must be at least three characters</span>
2027      * long.  It is recommended that the prefix be a short, meaningful string
<span class="line-modified">2028      * such as {@code &quot;hjb&quot;} or {@code &quot;mail&quot;}.  The</span>
<span class="line-modified">2029      * {@code suffix} argument may be {@code null}, in which case the</span>
<span class="line-modified">2030      * suffix {@code &quot;.tmp&quot;} will be used.</span>
2031      *
2032      * &lt;p&gt; To create the new file, the prefix and the suffix may first be
2033      * adjusted to fit the limitations of the underlying platform.  If the
2034      * prefix is too long then it will be truncated, but its first three
2035      * characters will always be preserved.  If the suffix is too long then it
2036      * too will be truncated, but if it begins with a period character
<span class="line-modified">2037      * ({@code &#39;.&#39;}) then the period and the first three characters</span>
2038      * following it will always be preserved.  Once these adjustments have been
2039      * made the name of the new file will be generated by concatenating the
2040      * prefix, five or more internally-generated characters, and the suffix.
2041      *
<span class="line-modified">2042      * &lt;p&gt; If the {@code directory} argument is {@code null} then the</span>
2043      * system-dependent default temporary-file directory will be used.  The
2044      * default temporary-file directory is specified by the system property
<span class="line-modified">2045      * {@code java.io.tmpdir}.  On UNIX systems the default value of this</span>
<span class="line-modified">2046      * property is typically {@code &quot;/tmp&quot;} or {@code &quot;/var/tmp&quot;}; on</span>
<span class="line-modified">2047      * Microsoft Windows systems it is typically {@code &quot;C:\\WINNT\\TEMP&quot;}.  A different</span>
2048      * value may be given to this system property when the Java virtual machine
2049      * is invoked, but programmatic changes to this property are not guaranteed
2050      * to have any effect upon the temporary directory used by this method.
2051      *
2052      * @param  prefix     The prefix string to be used in generating the file&#39;s
2053      *                    name; must be at least three characters long
2054      *
2055      * @param  suffix     The suffix string to be used in generating the file&#39;s
<span class="line-modified">2056      *                    name; may be {@code null}, in which case the</span>
<span class="line-modified">2057      *                    suffix {@code &quot;.tmp&quot;} will be used</span>
2058      *
2059      * @param  directory  The directory in which the file is to be created, or
<span class="line-modified">2060      *                    {@code null} if the default temporary-file</span>
2061      *                    directory is to be used
2062      *
2063      * @return  An abstract pathname denoting a newly-created empty file
2064      *
2065      * @throws  IllegalArgumentException
<span class="line-modified">2066      *          If the {@code prefix} argument contains fewer than three</span>
2067      *          characters
2068      *
2069      * @throws  IOException  If a file could not be created
2070      *
2071      * @throws  SecurityException
2072      *          If a security manager exists and its {@link
2073      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
2074      *          method does not allow a file to be created
2075      *
2076      * @since 1.2
2077      */
2078     public static File createTempFile(String prefix, String suffix,
2079                                       File directory)
2080         throws IOException
2081     {
2082         if (prefix.length() &lt; 3) {
2083             throw new IllegalArgumentException(&quot;Prefix string \&quot;&quot; + prefix +
2084                 &quot;\&quot; too short: length must be at least 3&quot;);
2085         }
2086         if (suffix == null)
</pre>
<hr />
<pre>
2112     }
2113 
2114     /**
2115      * Creates an empty file in the default temporary-file directory, using
2116      * the given prefix and suffix to generate its name. Invoking this method
2117      * is equivalent to invoking {@link #createTempFile(java.lang.String,
2118      * java.lang.String, java.io.File)
2119      * createTempFile(prefix,&amp;nbsp;suffix,&amp;nbsp;null)}.
2120      *
2121      * &lt;p&gt; The {@link
2122      * java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])
2123      * Files.createTempFile} method provides an alternative method to create an
2124      * empty file in the temporary-file directory. Files created by that method
2125      * may have more restrictive access permissions to files created by this
2126      * method and so may be more suited to security-sensitive applications.
2127      *
2128      * @param  prefix     The prefix string to be used in generating the file&#39;s
2129      *                    name; must be at least three characters long
2130      *
2131      * @param  suffix     The suffix string to be used in generating the file&#39;s
<span class="line-modified">2132      *                    name; may be {@code null}, in which case the</span>
<span class="line-modified">2133      *                    suffix {@code &quot;.tmp&quot;} will be used</span>
2134      *
2135      * @return  An abstract pathname denoting a newly-created empty file
2136      *
2137      * @throws  IllegalArgumentException
<span class="line-modified">2138      *          If the {@code prefix} argument contains fewer than three</span>
2139      *          characters
2140      *
2141      * @throws  IOException  If a file could not be created
2142      *
2143      * @throws  SecurityException
2144      *          If a security manager exists and its {@link
2145      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
2146      *          method does not allow a file to be created
2147      *
2148      * @since 1.2
2149      * @see java.nio.file.Files#createTempDirectory(String,FileAttribute[])
2150      */
2151     public static File createTempFile(String prefix, String suffix)
2152         throws IOException
2153     {
2154         return createTempFile(prefix, suffix, null);
2155     }
2156 
2157     /* -- Basic infrastructure -- */
2158 
</pre>
<hr />
<pre>
2162      * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
2163      * systems it is not.
2164      *
2165      * @param   pathname  The abstract pathname to be compared to this abstract
2166      *                    pathname
2167      *
2168      * @return  Zero if the argument is equal to this abstract pathname, a
2169      *          value less than zero if this abstract pathname is
2170      *          lexicographically less than the argument, or a value greater
2171      *          than zero if this abstract pathname is lexicographically
2172      *          greater than the argument
2173      *
2174      * @since   1.2
2175      */
2176     public int compareTo(File pathname) {
2177         return fs.compare(this, pathname);
2178     }
2179 
2180     /**
2181      * Tests this abstract pathname for equality with the given object.
<span class="line-modified">2182      * Returns {@code true} if and only if the argument is not</span>
<span class="line-modified">2183      * {@code null} and is an abstract pathname that denotes the same file</span>
2184      * or directory as this abstract pathname.  Whether or not two abstract
2185      * pathnames are equal depends upon the underlying system.  On UNIX
2186      * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
2187      * systems it is not.
2188      *
2189      * @param   obj   The object to be compared with this abstract pathname
2190      *
<span class="line-modified">2191      * @return  {@code true} if and only if the objects are the same;</span>
<span class="line-modified">2192      *          {@code false} otherwise</span>
2193      */
2194     public boolean equals(Object obj) {
2195         if ((obj != null) &amp;&amp; (obj instanceof File)) {
2196             return compareTo((File)obj) == 0;
2197         }
2198         return false;
2199     }
2200 
2201     /**
2202      * Computes a hash code for this abstract pathname.  Because equality of
2203      * abstract pathnames is inherently system-dependent, so is the computation
2204      * of their hash codes.  On UNIX systems, the hash code of an abstract
2205      * pathname is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code
2206      * of its pathname string and the decimal value
<span class="line-modified">2207      * {@code 1234321}.  On Microsoft Windows systems, the hash</span>
2208      * code is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code of
2209      * its pathname string converted to lower case and the decimal
<span class="line-modified">2210      * value {@code 1234321}.  Locale is not taken into account on</span>
2211      * lowercasing the pathname string.
2212      *
2213      * @return  A hash code for this abstract pathname
2214      */
2215     public int hashCode() {
2216         return fs.hashCode(this);
2217     }
2218 
2219     /**
2220      * Returns the pathname string of this abstract pathname.  This is just the
2221      * string returned by the {@link #getPath} method.
2222      *
2223      * @return  The string form of this abstract pathname
2224      */
2225     public String toString() {
2226         return getPath();
2227     }
2228 
2229     /**
2230      * WriteObject is called to save this filename.
2231      * The separator character is saved also so it can be replaced
2232      * in case the path is reconstituted on a different host type.
2233      *
2234      * @serialData  Default fields followed by separator character.
2235      */
<span class="line-added">2236     @java.io.Serial</span>
2237     private synchronized void writeObject(java.io.ObjectOutputStream s)
2238         throws IOException
2239     {
2240         s.defaultWriteObject();
2241         s.writeChar(separatorChar); // Add the separator character
2242     }
2243 
2244     /**
2245      * readObject is called to restore this filename.
2246      * The original separator character is read.  If it is different
2247      * than the separator character on this system, then the old separator
2248      * is replaced by the local separator.
2249      */
<span class="line-added">2250     @java.io.Serial</span>
2251     private synchronized void readObject(java.io.ObjectInputStream s)
2252          throws IOException, ClassNotFoundException
2253     {
2254         ObjectInputStream.GetField fields = s.readFields();
2255         String pathField = (String)fields.get(&quot;path&quot;, null);
2256         char sep = s.readChar(); // read the previous separator char
2257         if (sep != separatorChar)
2258             pathField = pathField.replace(sep, separatorChar);
2259         String path = fs.normalize(pathField);
2260         UNSAFE.putReference(this, PATH_OFFSET, path);
2261         UNSAFE.putIntVolatile(this, PREFIX_LENGTH_OFFSET, fs.prefixLength(path));
2262     }
2263 
2264     private static final jdk.internal.misc.Unsafe UNSAFE
2265             = jdk.internal.misc.Unsafe.getUnsafe();
2266     private static final long PATH_OFFSET
2267             = UNSAFE.objectFieldOffset(File.class, &quot;path&quot;);
2268     private static final long PREFIX_LENGTH_OFFSET
2269             = UNSAFE.objectFieldOffset(File.class, &quot;prefixLength&quot;);
2270 
2271     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">2272     @java.io.Serial</span>
2273     private static final long serialVersionUID = 301077366599181567L;
2274 
2275     // -- Integration with java.nio.file --
2276 
2277     private transient volatile Path filePath;
2278 
2279     /**
2280      * Returns a {@link Path java.nio.file.Path} object constructed from
2281      * this abstract path. The resulting {@code Path} is associated with the
2282      * {@link java.nio.file.FileSystems#getDefault default-filesystem}.
2283      *
2284      * &lt;p&gt; The first invocation of this method works as if invoking it were
2285      * equivalent to evaluating the expression:
2286      * &lt;blockquote&gt;&lt;pre&gt;
2287      * {@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link
2288      * java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());
2289      * &lt;/pre&gt;&lt;/blockquote&gt;
2290      * Subsequent invocations of this method return the same {@code Path}.
2291      *
2292      * &lt;p&gt; If this abstract pathname is the empty abstract pathname then this
</pre>
</td>
</tr>
</table>
<center><a href="Externalizable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileDescriptor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
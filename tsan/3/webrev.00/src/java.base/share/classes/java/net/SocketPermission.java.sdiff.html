<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/SocketPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketTimeoutException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocketPermission.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  *
 134  * &lt;p&gt;Note: Granting code permission to accept or make connections to remote
 135  * hosts may be dangerous because malevolent code can then more easily
 136  * transfer and share confidential data among parties who may not
 137  * otherwise have access to the data.
 138  *
 139  * @see java.security.Permissions
 140  * @see SocketPermission
 141  *
 142  *
 143  * @author Marianne Mueller
 144  * @author Roland Schemers
 145  * @since 1.2
 146  *
 147  * @serial exclude
 148  */
 149 
 150 public final class SocketPermission extends Permission
 151     implements java.io.Serializable
 152 {

 153     private static final long serialVersionUID = -7204263841984476862L;
 154 
 155     /**
 156      * Connect to host:port
 157      */
 158     private static final int CONNECT    = 0x1;
 159 
 160     /**
 161      * Listen on host:port
 162      */
 163     private static final int LISTEN     = 0x2;
 164 
 165     /**
 166      * Accept a connection from host:port
 167      */
 168     private static final int ACCEPT     = 0x4;
 169 
 170     /**
 171      * Resolve DNS queries
 172      */
</pre>
<hr />
<pre>
 269      * The &lt;i&gt;actions&lt;/i&gt; parameter contains a comma-separated list of the
 270      * actions granted for the specified host (and port(s)). Possible actions are
 271      * &quot;connect&quot;, &quot;listen&quot;, &quot;accept&quot;, &quot;resolve&quot;, or
 272      * any combination of those. &quot;resolve&quot; is automatically added
 273      * when any of the other three are specified.
 274      * &lt;p&gt;
 275      * Examples of SocketPermission instantiation are the following:
 276      * &lt;pre&gt;
 277      *    nr = new SocketPermission(&quot;www.example.com&quot;, &quot;connect&quot;);
 278      *    nr = new SocketPermission(&quot;www.example.com:80&quot;, &quot;connect&quot;);
 279      *    nr = new SocketPermission(&quot;*.example.com&quot;, &quot;connect&quot;);
 280      *    nr = new SocketPermission(&quot;*.edu&quot;, &quot;resolve&quot;);
 281      *    nr = new SocketPermission(&quot;204.160.241.0&quot;, &quot;connect&quot;);
 282      *    nr = new SocketPermission(&quot;localhost:1024-65535&quot;, &quot;listen&quot;);
 283      *    nr = new SocketPermission(&quot;204.160.241.0:1024-65535&quot;, &quot;connect&quot;);
 284      * &lt;/pre&gt;
 285      *
 286      * @param host the hostname or IP address of the computer, optionally
 287      * including a colon followed by a port or port range.
 288      * @param action the action string.





 289      */
 290     public SocketPermission(String host, String action) {
 291         super(getHost(host));
 292         // name initialized to getHost(host); NPE detected in getHost()
 293         init(getName(), getMask(action));
 294     }
 295 
 296 
 297     SocketPermission(String host, int mask) {
 298         super(getHost(host));
 299         // name initialized to getHost(host); NPE detected in getHost()
 300         init(getName(), mask);
 301     }
 302 
 303     private void setDeny() {
 304         defaultDeny = true;
 305     }
 306 
 307     private static String getHost(String host) {
 308         if (host.isEmpty()) {
</pre>
<hr />
<pre>
 571             } else if (i &gt;= 5 &amp;&amp; (a[i-5] == &#39;a&#39; || a[i-5] == &#39;A&#39;) &amp;&amp;
 572                                  (a[i-4] == &#39;c&#39; || a[i-4] == &#39;C&#39;) &amp;&amp;
 573                                  (a[i-3] == &#39;c&#39; || a[i-3] == &#39;C&#39;) &amp;&amp;
 574                                  (a[i-2] == &#39;e&#39; || a[i-2] == &#39;E&#39;) &amp;&amp;
 575                                  (a[i-1] == &#39;p&#39; || a[i-1] == &#39;P&#39;) &amp;&amp;
 576                                  (a[i] == &#39;t&#39; || a[i] == &#39;T&#39;))
 577             {
 578                 matchlen = 6;
 579                 mask |= ACCEPT;
 580 
 581             } else {
 582                 // parse error
 583                 throw new IllegalArgumentException(
 584                         &quot;invalid permission: &quot; + action);
 585             }
 586 
 587             // make sure we didn&#39;t just match the tail of a word
 588             // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
 589             boolean seencomma = false;
 590             while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified"> 591                 switch(a[i-matchlen]) {</span>
<span class="line-removed"> 592                 case &#39;,&#39;:</span>
<span class="line-removed"> 593                     seencomma = true;</span>
<span class="line-removed"> 594                     break;</span>
 595                 case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
 596                 case &#39;\f&#39;: case &#39;\t&#39;:
 597                     break;
 598                 default:




 599                     throw new IllegalArgumentException(
 600                             &quot;invalid permission: &quot; + action);
 601                 }
 602                 i--;
 603             }
 604 
 605             // point i at the location of the comma minus one (or -1).
 606             i -= matchlen;
 607         }
 608 
 609         return mask;
 610     }
 611 
 612     private boolean isUntrusted()
 613         throws UnknownHostException
 614     {
 615         if (trusted) return false;
 616         if (invalid || untrusted) return true;
 617         try {
 618             if (!trustNameService &amp;&amp; (defaultDeny ||
</pre>
<hr />
<pre>
1169      * Returns a new PermissionCollection object for storing SocketPermission
1170      * objects.
1171      * &lt;p&gt;
1172      * SocketPermission objects must be stored in a manner that allows them
1173      * to be inserted into the collection in any order, but that also enables the
1174      * PermissionCollection {@code implies}
1175      * method to be implemented in an efficient (and consistent) manner.
1176      *
1177      * @return a new PermissionCollection object suitable for storing SocketPermissions.
1178      */
1179     @Override
1180     public PermissionCollection newPermissionCollection() {
1181         return new SocketPermissionCollection();
1182     }
1183 
1184     /**
1185      * WriteObject is called to save the state of the SocketPermission
1186      * to a stream. The actions are serialized, and the superclass
1187      * takes care of the name.
1188      */

1189     private synchronized void writeObject(java.io.ObjectOutputStream s)
1190         throws IOException
1191     {
1192         // Write out the actions. The superclass takes care of the name
1193         // call getActions to make sure actions field is initialized
1194         if (actions == null)
1195             getActions();
1196         s.defaultWriteObject();
1197     }
1198 
1199     /**
1200      * readObject is called to restore the state of the SocketPermission from
1201      * a stream.
1202      */

1203     private synchronized void readObject(java.io.ObjectInputStream s)
1204          throws IOException, ClassNotFoundException
1205     {
1206         // Read in the action, then initialize the rest
1207         s.defaultReadObject();
1208         init(getName(),getMask(actions));
1209     }
1210 
1211     /**
1212      * Check the system/security property for the ephemeral port range
1213      * for this system. The suffix is either &quot;high&quot; or &quot;low&quot;
1214      */
1215     private static int initEphemeralPorts(String suffix, int defval) {
1216         return AccessController.doPrivileged(
1217             new PrivilegedAction&lt;&gt;(){
1218                 public Integer run() {
1219                     int val = Integer.getInteger(
1220                             &quot;jdk.net.ephemeralPortRange.&quot;+suffix, -1
1221                     );
1222                     if (val != -1) {
</pre>
<hr />
<pre>
1341 {
1342     // Not serialized; see serialization section at end of class
1343     // A ConcurrentSkipListMap is used to preserve order, so that most
1344     // recently added permissions are checked first (see JDK-4301064).
1345     private transient ConcurrentSkipListMap&lt;String, SocketPermission&gt; perms;
1346 
1347     /**
1348      * Create an empty SocketPermissions object.
1349      *
1350      */
1351     public SocketPermissionCollection() {
1352         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1353     }
1354 
1355     /**
1356      * Adds a permission to the SocketPermissions. The key for the hash is
1357      * the name in the case of wildcards, or all the IP addresses.
1358      *
1359      * @param permission the Permission object to add.
1360      *
<span class="line-modified">1361      * @exception IllegalArgumentException - if the permission is not a</span>
1362      *                                       SocketPermission
1363      *
<span class="line-modified">1364      * @exception SecurityException - if this SocketPermissionCollection object</span>
1365      *                                has been marked readonly
1366      */
1367     @Override
1368     public void add(Permission permission) {
1369         if (! (permission instanceof SocketPermission))
1370             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1371                                                permission);
1372         if (isReadOnly())
1373             throw new SecurityException(
1374                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
1375 
1376         SocketPermission sp = (SocketPermission)permission;
1377 
1378         // Add permission to map if it is absent, or replace with new
1379         // permission if applicable. NOTE: cannot use lambda for
1380         // remappingFunction parameter until JDK-8076596 is fixed.
1381         perms.merge(sp.getName(), sp,
1382             new java.util.function.BiFunction&lt;&gt;() {
1383                 @Override
1384                 public SocketPermission apply(SocketPermission existingVal,
</pre>
<hr />
<pre>
1413     @Override
1414     public boolean implies(Permission permission)
1415     {
1416         if (! (permission instanceof SocketPermission))
1417                 return false;
1418 
1419         SocketPermission np = (SocketPermission) permission;
1420 
1421         int desired = np.getMask();
1422         int effective = 0;
1423         int needed = desired;
1424 
1425         //System.out.println(&quot;implies &quot;+np);
1426         for (SocketPermission x : perms.values()) {
1427             //System.out.println(&quot;  trying &quot;+x);
1428             if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {
1429                 effective |=  x.getMask();
1430                 if ((effective &amp; desired) == desired) {
1431                     return true;
1432                 }
<span class="line-modified">1433                 needed = (desired ^ effective);</span>
1434             }
1435         }
1436         return false;
1437     }
1438 
1439     /**
1440      * Returns an enumeration of all the SocketPermission objects in the
1441      * container.
1442      *
1443      * @return an enumeration of all the SocketPermission objects.
1444      */
1445     @Override
1446     @SuppressWarnings(&quot;unchecked&quot;)
1447     public Enumeration&lt;Permission&gt; elements() {
1448         return (Enumeration)Collections.enumeration(perms.values());
1449     }
1450 

1451     private static final long serialVersionUID = 2787186408602843674L;
1452 
1453     // Need to maintain serialization interoperability with earlier releases,
1454     // which had the serializable field:
1455 
1456     //
1457     // The SocketPermissions for this set.
1458     // @serial
1459     //
1460     // private Vector permissions;
1461 
1462     /**
1463      * @serialField permissions java.util.Vector
1464      *     A list of the SocketPermissions for this set.
1465      */

1466     private static final ObjectStreamField[] serialPersistentFields = {
1467         new ObjectStreamField(&quot;permissions&quot;, Vector.class),
1468     };
1469 
1470     /**
1471      * @serialData &quot;permissions&quot; field (a Vector containing the SocketPermissions).
1472      */
1473     /*
1474      * Writes the contents of the perms field out as a Vector for
1475      * serialization compatibility with earlier releases.
1476      */

1477     private void writeObject(ObjectOutputStream out) throws IOException {
1478         // Don&#39;t call out.defaultWriteObject()
1479 
1480         // Write out Vector
1481         Vector&lt;SocketPermission&gt; permissions = new Vector&lt;&gt;(perms.values());
1482 
1483         ObjectOutputStream.PutField pfields = out.putFields();
1484         pfields.put(&quot;permissions&quot;, permissions);
1485         out.writeFields();
1486     }
1487 
1488     /*
1489      * Reads in a Vector of SocketPermissions and saves them in the perms field.
1490      */

1491     private void readObject(ObjectInputStream in)
1492         throws IOException, ClassNotFoundException
1493     {
1494         // Don&#39;t call in.defaultReadObject()
1495 
1496         // Read in serialized fields
1497         ObjectInputStream.GetField gfields = in.readFields();
1498 
1499         // Get the one we want
1500         @SuppressWarnings(&quot;unchecked&quot;)
1501         Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);
1502         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1503         for (SocketPermission sp : permissions) {
1504             perms.put(sp.getName(), sp);
1505         }
1506     }
1507 
1508     /**
1509      * A simple comparator that orders new non-equal entries at the beginning.
1510      */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 133  *
 134  * &lt;p&gt;Note: Granting code permission to accept or make connections to remote
 135  * hosts may be dangerous because malevolent code can then more easily
 136  * transfer and share confidential data among parties who may not
 137  * otherwise have access to the data.
 138  *
 139  * @see java.security.Permissions
 140  * @see SocketPermission
 141  *
 142  *
 143  * @author Marianne Mueller
 144  * @author Roland Schemers
 145  * @since 1.2
 146  *
 147  * @serial exclude
 148  */
 149 
 150 public final class SocketPermission extends Permission
 151     implements java.io.Serializable
 152 {
<span class="line-added"> 153     @java.io.Serial</span>
 154     private static final long serialVersionUID = -7204263841984476862L;
 155 
 156     /**
 157      * Connect to host:port
 158      */
 159     private static final int CONNECT    = 0x1;
 160 
 161     /**
 162      * Listen on host:port
 163      */
 164     private static final int LISTEN     = 0x2;
 165 
 166     /**
 167      * Accept a connection from host:port
 168      */
 169     private static final int ACCEPT     = 0x4;
 170 
 171     /**
 172      * Resolve DNS queries
 173      */
</pre>
<hr />
<pre>
 270      * The &lt;i&gt;actions&lt;/i&gt; parameter contains a comma-separated list of the
 271      * actions granted for the specified host (and port(s)). Possible actions are
 272      * &quot;connect&quot;, &quot;listen&quot;, &quot;accept&quot;, &quot;resolve&quot;, or
 273      * any combination of those. &quot;resolve&quot; is automatically added
 274      * when any of the other three are specified.
 275      * &lt;p&gt;
 276      * Examples of SocketPermission instantiation are the following:
 277      * &lt;pre&gt;
 278      *    nr = new SocketPermission(&quot;www.example.com&quot;, &quot;connect&quot;);
 279      *    nr = new SocketPermission(&quot;www.example.com:80&quot;, &quot;connect&quot;);
 280      *    nr = new SocketPermission(&quot;*.example.com&quot;, &quot;connect&quot;);
 281      *    nr = new SocketPermission(&quot;*.edu&quot;, &quot;resolve&quot;);
 282      *    nr = new SocketPermission(&quot;204.160.241.0&quot;, &quot;connect&quot;);
 283      *    nr = new SocketPermission(&quot;localhost:1024-65535&quot;, &quot;listen&quot;);
 284      *    nr = new SocketPermission(&quot;204.160.241.0:1024-65535&quot;, &quot;connect&quot;);
 285      * &lt;/pre&gt;
 286      *
 287      * @param host the hostname or IP address of the computer, optionally
 288      * including a colon followed by a port or port range.
 289      * @param action the action string.
<span class="line-added"> 290      *</span>
<span class="line-added"> 291      * @throws NullPointerException if any parameters are null</span>
<span class="line-added"> 292      * @throws IllegalArgumentException if the format of {@code host} is</span>
<span class="line-added"> 293      *         invalid, or if the {@code action} string is empty, malformed, or</span>
<span class="line-added"> 294      *         contains an action other than the specified possible actions</span>
 295      */
 296     public SocketPermission(String host, String action) {
 297         super(getHost(host));
 298         // name initialized to getHost(host); NPE detected in getHost()
 299         init(getName(), getMask(action));
 300     }
 301 
 302 
 303     SocketPermission(String host, int mask) {
 304         super(getHost(host));
 305         // name initialized to getHost(host); NPE detected in getHost()
 306         init(getName(), mask);
 307     }
 308 
 309     private void setDeny() {
 310         defaultDeny = true;
 311     }
 312 
 313     private static String getHost(String host) {
 314         if (host.isEmpty()) {
</pre>
<hr />
<pre>
 577             } else if (i &gt;= 5 &amp;&amp; (a[i-5] == &#39;a&#39; || a[i-5] == &#39;A&#39;) &amp;&amp;
 578                                  (a[i-4] == &#39;c&#39; || a[i-4] == &#39;C&#39;) &amp;&amp;
 579                                  (a[i-3] == &#39;c&#39; || a[i-3] == &#39;C&#39;) &amp;&amp;
 580                                  (a[i-2] == &#39;e&#39; || a[i-2] == &#39;E&#39;) &amp;&amp;
 581                                  (a[i-1] == &#39;p&#39; || a[i-1] == &#39;P&#39;) &amp;&amp;
 582                                  (a[i] == &#39;t&#39; || a[i] == &#39;T&#39;))
 583             {
 584                 matchlen = 6;
 585                 mask |= ACCEPT;
 586 
 587             } else {
 588                 // parse error
 589                 throw new IllegalArgumentException(
 590                         &quot;invalid permission: &quot; + action);
 591             }
 592 
 593             // make sure we didn&#39;t just match the tail of a word
 594             // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
 595             boolean seencomma = false;
 596             while (i &gt;= matchlen &amp;&amp; !seencomma) {
<span class="line-modified"> 597                 switch (c = a[i-matchlen]) {</span>



 598                 case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
 599                 case &#39;\f&#39;: case &#39;\t&#39;:
 600                     break;
 601                 default:
<span class="line-added"> 602                     if (c == &#39;,&#39; &amp;&amp; i &gt; matchlen) {</span>
<span class="line-added"> 603                         seencomma = true;</span>
<span class="line-added"> 604                         break;</span>
<span class="line-added"> 605                     }</span>
 606                     throw new IllegalArgumentException(
 607                             &quot;invalid permission: &quot; + action);
 608                 }
 609                 i--;
 610             }
 611 
 612             // point i at the location of the comma minus one (or -1).
 613             i -= matchlen;
 614         }
 615 
 616         return mask;
 617     }
 618 
 619     private boolean isUntrusted()
 620         throws UnknownHostException
 621     {
 622         if (trusted) return false;
 623         if (invalid || untrusted) return true;
 624         try {
 625             if (!trustNameService &amp;&amp; (defaultDeny ||
</pre>
<hr />
<pre>
1176      * Returns a new PermissionCollection object for storing SocketPermission
1177      * objects.
1178      * &lt;p&gt;
1179      * SocketPermission objects must be stored in a manner that allows them
1180      * to be inserted into the collection in any order, but that also enables the
1181      * PermissionCollection {@code implies}
1182      * method to be implemented in an efficient (and consistent) manner.
1183      *
1184      * @return a new PermissionCollection object suitable for storing SocketPermissions.
1185      */
1186     @Override
1187     public PermissionCollection newPermissionCollection() {
1188         return new SocketPermissionCollection();
1189     }
1190 
1191     /**
1192      * WriteObject is called to save the state of the SocketPermission
1193      * to a stream. The actions are serialized, and the superclass
1194      * takes care of the name.
1195      */
<span class="line-added">1196     @java.io.Serial</span>
1197     private synchronized void writeObject(java.io.ObjectOutputStream s)
1198         throws IOException
1199     {
1200         // Write out the actions. The superclass takes care of the name
1201         // call getActions to make sure actions field is initialized
1202         if (actions == null)
1203             getActions();
1204         s.defaultWriteObject();
1205     }
1206 
1207     /**
1208      * readObject is called to restore the state of the SocketPermission from
1209      * a stream.
1210      */
<span class="line-added">1211     @java.io.Serial</span>
1212     private synchronized void readObject(java.io.ObjectInputStream s)
1213          throws IOException, ClassNotFoundException
1214     {
1215         // Read in the action, then initialize the rest
1216         s.defaultReadObject();
1217         init(getName(),getMask(actions));
1218     }
1219 
1220     /**
1221      * Check the system/security property for the ephemeral port range
1222      * for this system. The suffix is either &quot;high&quot; or &quot;low&quot;
1223      */
1224     private static int initEphemeralPorts(String suffix, int defval) {
1225         return AccessController.doPrivileged(
1226             new PrivilegedAction&lt;&gt;(){
1227                 public Integer run() {
1228                     int val = Integer.getInteger(
1229                             &quot;jdk.net.ephemeralPortRange.&quot;+suffix, -1
1230                     );
1231                     if (val != -1) {
</pre>
<hr />
<pre>
1350 {
1351     // Not serialized; see serialization section at end of class
1352     // A ConcurrentSkipListMap is used to preserve order, so that most
1353     // recently added permissions are checked first (see JDK-4301064).
1354     private transient ConcurrentSkipListMap&lt;String, SocketPermission&gt; perms;
1355 
1356     /**
1357      * Create an empty SocketPermissions object.
1358      *
1359      */
1360     public SocketPermissionCollection() {
1361         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1362     }
1363 
1364     /**
1365      * Adds a permission to the SocketPermissions. The key for the hash is
1366      * the name in the case of wildcards, or all the IP addresses.
1367      *
1368      * @param permission the Permission object to add.
1369      *
<span class="line-modified">1370      * @throws    IllegalArgumentException   if the permission is not a</span>
1371      *                                       SocketPermission
1372      *
<span class="line-modified">1373      * @throws    SecurityException   if this SocketPermissionCollection object</span>
1374      *                                has been marked readonly
1375      */
1376     @Override
1377     public void add(Permission permission) {
1378         if (! (permission instanceof SocketPermission))
1379             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1380                                                permission);
1381         if (isReadOnly())
1382             throw new SecurityException(
1383                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
1384 
1385         SocketPermission sp = (SocketPermission)permission;
1386 
1387         // Add permission to map if it is absent, or replace with new
1388         // permission if applicable. NOTE: cannot use lambda for
1389         // remappingFunction parameter until JDK-8076596 is fixed.
1390         perms.merge(sp.getName(), sp,
1391             new java.util.function.BiFunction&lt;&gt;() {
1392                 @Override
1393                 public SocketPermission apply(SocketPermission existingVal,
</pre>
<hr />
<pre>
1422     @Override
1423     public boolean implies(Permission permission)
1424     {
1425         if (! (permission instanceof SocketPermission))
1426                 return false;
1427 
1428         SocketPermission np = (SocketPermission) permission;
1429 
1430         int desired = np.getMask();
1431         int effective = 0;
1432         int needed = desired;
1433 
1434         //System.out.println(&quot;implies &quot;+np);
1435         for (SocketPermission x : perms.values()) {
1436             //System.out.println(&quot;  trying &quot;+x);
1437             if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {
1438                 effective |=  x.getMask();
1439                 if ((effective &amp; desired) == desired) {
1440                     return true;
1441                 }
<span class="line-modified">1442                 needed = (desired &amp; ~effective);</span>
1443             }
1444         }
1445         return false;
1446     }
1447 
1448     /**
1449      * Returns an enumeration of all the SocketPermission objects in the
1450      * container.
1451      *
1452      * @return an enumeration of all the SocketPermission objects.
1453      */
1454     @Override
1455     @SuppressWarnings(&quot;unchecked&quot;)
1456     public Enumeration&lt;Permission&gt; elements() {
1457         return (Enumeration)Collections.enumeration(perms.values());
1458     }
1459 
<span class="line-added">1460     @java.io.Serial</span>
1461     private static final long serialVersionUID = 2787186408602843674L;
1462 
1463     // Need to maintain serialization interoperability with earlier releases,
1464     // which had the serializable field:
1465 
1466     //
1467     // The SocketPermissions for this set.
1468     // @serial
1469     //
1470     // private Vector permissions;
1471 
1472     /**
1473      * @serialField permissions java.util.Vector
1474      *     A list of the SocketPermissions for this set.
1475      */
<span class="line-added">1476     @java.io.Serial</span>
1477     private static final ObjectStreamField[] serialPersistentFields = {
1478         new ObjectStreamField(&quot;permissions&quot;, Vector.class),
1479     };
1480 
1481     /**
1482      * @serialData &quot;permissions&quot; field (a Vector containing the SocketPermissions).
1483      */
1484     /*
1485      * Writes the contents of the perms field out as a Vector for
1486      * serialization compatibility with earlier releases.
1487      */
<span class="line-added">1488     @java.io.Serial</span>
1489     private void writeObject(ObjectOutputStream out) throws IOException {
1490         // Don&#39;t call out.defaultWriteObject()
1491 
1492         // Write out Vector
1493         Vector&lt;SocketPermission&gt; permissions = new Vector&lt;&gt;(perms.values());
1494 
1495         ObjectOutputStream.PutField pfields = out.putFields();
1496         pfields.put(&quot;permissions&quot;, permissions);
1497         out.writeFields();
1498     }
1499 
1500     /*
1501      * Reads in a Vector of SocketPermissions and saves them in the perms field.
1502      */
<span class="line-added">1503     @java.io.Serial</span>
1504     private void readObject(ObjectInputStream in)
1505         throws IOException, ClassNotFoundException
1506     {
1507         // Don&#39;t call in.defaultReadObject()
1508 
1509         // Read in serialized fields
1510         ObjectInputStream.GetField gfields = in.readFields();
1511 
1512         // Get the one we want
1513         @SuppressWarnings(&quot;unchecked&quot;)
1514         Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);
1515         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1516         for (SocketPermission sp : permissions) {
1517             perms.put(sp.getName(), sp);
1518         }
1519     }
1520 
1521     /**
1522      * A simple comparator that orders new non-equal entries at the beginning.
1523      */
</pre>
</td>
</tr>
</table>
<center><a href="SocketOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketTimeoutException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
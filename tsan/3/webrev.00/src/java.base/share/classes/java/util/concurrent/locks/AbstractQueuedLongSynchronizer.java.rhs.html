<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 
<a name="1" id="anc1"></a>

  38 import java.util.ArrayList;
  39 import java.util.Collection;
  40 import java.util.Date;
  41 import java.util.concurrent.TimeUnit;
<a name="2" id="anc2"></a><span class="line-modified">  42 import java.util.concurrent.ForkJoinPool;</span>
<span class="line-added">  43 import jdk.internal.misc.Unsafe;</span>
  44 
  45 /**
  46  * A version of {@link AbstractQueuedSynchronizer} in
  47  * which synchronization state is maintained as a {@code long}.
  48  * This class has exactly the same structure, properties, and methods
  49  * as {@code AbstractQueuedSynchronizer} with the exception
  50  * that all state-related parameters and results are defined
  51  * as {@code long} rather than {@code int}. This class
  52  * may be useful when creating synchronizers such as
  53  * multilevel locks and barriers that require
  54  * 64 bits of state.
  55  *
  56  * &lt;p&gt;See {@link AbstractQueuedSynchronizer} for usage
  57  * notes and examples.
  58  *
  59  * @since 1.6
  60  * @author Doug Lea
  61  */
  62 public abstract class AbstractQueuedLongSynchronizer
  63     extends AbstractOwnableSynchronizer
  64     implements java.io.Serializable {
  65 
  66     private static final long serialVersionUID = 7373984972572414692L;
  67 
  68     /*
  69      * To keep sources in sync, the remainder of this source file is
  70      * exactly cloned from AbstractQueuedSynchronizer, replacing class
  71      * name and changing ints related with sync state to longs. Please
  72      * keep it that way.
  73      */
  74 
<a name="3" id="anc3"></a><span class="line-modified">  75     // Node status bits, also used as argument and return values</span>
<span class="line-modified">  76     static final int WAITING   = 1;          // must be 1</span>
<span class="line-modified">  77     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="line-modified">  78     static final int COND      = 2;          // in a condition wait</span>
<span class="line-modified">  79 </span>
<span class="line-added">  80     /** CLH Nodes */</span>
<span class="line-added">  81     abstract static class Node {</span>
<span class="line-added">  82         volatile Node prev;       // initially attached via casTail</span>
<span class="line-added">  83         volatile Node next;       // visibly nonnull when signallable</span>
<span class="line-added">  84         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="line-added">  85         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="line-added">  86 </span>
<span class="line-added">  87         // methods for atomic operations</span>
<span class="line-added">  88         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="line-added">  89             return U.weakCompareAndSetReference(this, PREV, c, v);</span>
<span class="line-added">  90         }</span>
<span class="line-added">  91         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="line-added">  92             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>
<span class="line-added">  93         }</span>
<span class="line-added">  94         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="line-added">  95             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>
<span class="line-added">  96         }</span>
<span class="line-added">  97         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="line-added">  98             U.putReference(this, PREV, p);</span>
<span class="line-added">  99         }</span>
<span class="line-added"> 100         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="line-added"> 101             U.putInt(this, STATUS, s);</span>
<span class="line-added"> 102         }</span>
<span class="line-added"> 103         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="line-added"> 104             U.putIntOpaque(this, STATUS, 0);</span>
<span class="line-added"> 105         }</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107         private static final long STATUS</span>
<span class="line-added"> 108             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="line-added"> 109         private static final long NEXT</span>
<span class="line-added"> 110             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="line-added"> 111         private static final long PREV</span>
<span class="line-added"> 112             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="line-added"> 113     }</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115     // Concrete classes tagged by type</span>
<span class="line-added"> 116     static final class ExclusiveNode extends Node { }</span>
<span class="line-added"> 117     static final class SharedNode extends Node { }</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119     static final class ConditionNode extends Node</span>
<span class="line-added"> 120         implements ForkJoinPool.ManagedBlocker {</span>
<span class="line-added"> 121         ConditionNode nextWaiter;            // link to next waiting node</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123         /**</span>
<span class="line-added"> 124          * Allows Conditions to be used in ForkJoinPools without</span>
<span class="line-added"> 125          * risking fixed pool exhaustion. This is usable only for</span>
<span class="line-added"> 126          * untimed Condition waits, not timed versions.</span>
<span class="line-added"> 127          */</span>
<span class="line-added"> 128         public final boolean isReleasable() {</span>
<span class="line-added"> 129             return status &lt;= 1 || Thread.currentThread().isInterrupted();</span>
<span class="line-added"> 130         }</span>
<span class="line-added"> 131 </span>
<span class="line-added"> 132         public final boolean block() {</span>
<span class="line-added"> 133             while (!isReleasable()) LockSupport.park();</span>
<span class="line-added"> 134             return true;</span>
<span class="line-added"> 135         }</span>
<span class="line-added"> 136     }</span>
 137 
 138     /**
<a name="4" id="anc4"></a><span class="line-modified"> 139      * Head of the wait queue, lazily initialized.</span>



 140      */
 141     private transient volatile Node head;
 142 
 143     /**
<a name="5" id="anc5"></a><span class="line-modified"> 144      * Tail of the wait queue. After initialization, modified only via casTail.</span>

 145      */
 146     private transient volatile Node tail;
 147 
 148     /**
 149      * The synchronization state.
 150      */
 151     private volatile long state;
 152 
 153     /**
 154      * Returns the current value of synchronization state.
 155      * This operation has memory semantics of a {@code volatile} read.
 156      * @return current state value
 157      */
 158     protected final long getState() {
 159         return state;
 160     }
 161 
 162     /**
 163      * Sets the value of synchronization state.
 164      * This operation has memory semantics of a {@code volatile} write.
 165      * @param newState the new state value
 166      */
 167     protected final void setState(long newState) {
<a name="6" id="anc6"></a><span class="line-modified"> 168         state = newState;</span>

 169     }
 170 
 171     /**
 172      * Atomically sets synchronization state to the given updated
 173      * value if the current state value equals the expected value.
 174      * This operation has memory semantics of a {@code volatile} read
 175      * and write.
 176      *
 177      * @param expect the expected value
 178      * @param update the new value
 179      * @return {@code true} if successful. False return indicates that the actual
 180      *         value was not equal to the expected value.
 181      */
 182     protected final boolean compareAndSetState(long expect, long update) {
<a name="7" id="anc7"></a><span class="line-modified"> 183         return U.compareAndSetLong(this, STATE, expect, update);</span>
 184     }
 185 
 186     // Queuing utilities
 187 
<a name="8" id="anc8"></a><span class="line-modified"> 188     private boolean casTail(Node c, Node v) {</span>
<span class="line-modified"> 189         return U.compareAndSetReference(this, TAIL, c, v);</span>



























































 190     }
 191 
<a name="9" id="anc9"></a><span class="line-modified"> 192     /** tries once to CAS a new dummy node for head */</span>
<span class="line-modified"> 193     private void tryInitializeHead() {</span>
<span class="line-modified"> 194         Node h = new ExclusiveNode();</span>
<span class="line-modified"> 195         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="line-modified"> 196             tail = h;</span>

























 197     }
 198 
 199     /**
<a name="10" id="anc10"></a><span class="line-modified"> 200      * Enqueues the node unless null. (Currently used only for</span>
<span class="line-modified"> 201      * ConditionNodes; other cases are interleaved with acquires.)</span>

 202      */
<a name="11" id="anc11"></a><span class="line-modified"> 203     final void enqueue(Node node) {</span>
<span class="line-modified"> 204         if (node != null) {</span>
<span class="line-modified"> 205             for (;;) {</span>
<span class="line-modified"> 206                 Node t = tail;</span>
<span class="line-modified"> 207                 node.setPrevRelaxed(t);        // avoid unnecessary fence</span>
<span class="line-modified"> 208                 if (t == null)                 // initialize</span>
<span class="line-modified"> 209                     tryInitializeHead();</span>
<span class="line-modified"> 210                 else if (casTail(t, node)) {</span>
<span class="line-modified"> 211                     t.next = node;</span>
<span class="line-modified"> 212                     if (t.status &lt; 0)          // wake up to clean link</span>
<span class="line-modified"> 213                         LockSupport.unpark(node.waiter);</span>
<span class="line-modified"> 214                     break;</span>








 215                 }
<a name="12" id="anc12"></a>


 216             }
<a name="13" id="anc13"></a>

 217         }
 218     }
 219 
<a name="14" id="anc14"></a><span class="line-modified"> 220     /** Returns true if node is found in traversal from tail */</span>
<span class="line-modified"> 221     final boolean isEnqueued(Node node) {</span>
<span class="line-modified"> 222         for (Node t = tail; t != null; t = t.prev)</span>
<span class="line-modified"> 223             if (t == node)</span>
<span class="line-modified"> 224                 return true;</span>
<span class="line-modified"> 225         return false;</span>



























 226     }
 227 
<a name="15" id="anc15"></a>

 228     /**
<a name="16" id="anc16"></a><span class="line-modified"> 229      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="line-modified"> 230      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="line-modified"> 231      * eligible thread when one or more have been cancelled, but</span>
<span class="line-added"> 232      * cancelAcquire ensures liveness.</span>
 233      */
<a name="17" id="anc17"></a><span class="line-modified"> 234     private static void signalNext(Node h) {</span>
<span class="line-modified"> 235         Node s;</span>
<span class="line-modified"> 236         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 237             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 238             LockSupport.unpark(s.waiter);</span>






































 239         }
 240     }
 241 
<a name="18" id="anc18"></a><span class="line-modified"> 242     /** Wakes up the given node if in shared mode */</span>
<span class="line-modified"> 243     private static void signalNextIfShared(Node h) {</span>
<span class="line-modified"> 244         Node s;</span>
<span class="line-modified"> 245         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-modified"> 246             (s instanceof SharedNode) &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 247             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 248             LockSupport.unpark(s.waiter);</span>


























 249         }
<a name="19" id="anc19"></a>







 250     }
 251 
 252     /**
<a name="20" id="anc20"></a><span class="line-modified"> 253      * Main acquire method, invoked by all exported acquire methods.</span>




















 254      *
<a name="21" id="anc21"></a><span class="line-modified"> 255      * @param node null unless a reacquiring Condition</span>
 256      * @param arg the acquire argument
<a name="22" id="anc22"></a><span class="line-modified"> 257      * @param shared true if shared mode else exclusive</span>
<span class="line-added"> 258      * @param interruptible if abort and return negative on interrupt</span>
<span class="line-added"> 259      * @param timed if true use timed waits</span>
<span class="line-added"> 260      * @param time if timed, the System.nanoTime value to timeout</span>
<span class="line-added"> 261      * @return positive if acquired, 0 if timed out, negative if interrupted</span>
 262      */
<a name="23" id="anc23"></a><span class="line-modified"> 263     final int acquire(Node node, long arg, boolean shared,</span>
<span class="line-modified"> 264                       boolean interruptible, boolean timed, long time) {</span>
<span class="line-modified"> 265         Thread current = Thread.currentThread();</span>
<span class="line-modified"> 266         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="line-modified"> 267         boolean interrupted = false, first = false;</span>
<span class="line-modified"> 268         Node pred = null;                // predecessor of node when enqueued</span>














 269 
<a name="24" id="anc24"></a><span class="line-modified"> 270         /*</span>
<span class="line-modified"> 271          * Repeatedly:</span>
<span class="line-modified"> 272          *  Check if node now first</span>
<span class="line-modified"> 273          *    if so, ensure head stable, else ensure valid predecessor</span>
<span class="line-modified"> 274          *  if node is first or not yet enqueued, try acquiring</span>
<span class="line-modified"> 275          *  else if node not yet created, create it</span>
<span class="line-modified"> 276          *  else if not yet enqueued, try once to enqueue</span>
<span class="line-modified"> 277          *  else if woken from park, retry (up to postSpins times)</span>
<span class="line-modified"> 278          *  else if WAITING status not set, set and retry</span>
<span class="line-modified"> 279          *  else park and clear WAITING status, and check cancellation</span>
<span class="line-modified"> 280          */</span>
<span class="line-modified"> 281 </span>
<span class="line-modified"> 282         for (;;) {</span>
<span class="line-modified"> 283             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="line-added"> 284                 !(first = (head == pred))) {</span>
<span class="line-added"> 285                 if (pred.status &lt; 0) {</span>
<span class="line-added"> 286                     cleanQueue();           // predecessor cancelled</span>
<span class="line-added"> 287                     continue;</span>
<span class="line-added"> 288                 } else if (pred.prev == null) {</span>
<span class="line-added"> 289                     Thread.onSpinWait();    // ensure serialization</span>
<span class="line-added"> 290                     continue;</span>
 291                 }
<a name="25" id="anc25"></a>


 292             }
<a name="26" id="anc26"></a><span class="line-modified"> 293             if (first || pred == null) {</span>
<span class="line-modified"> 294                 boolean acquired;</span>
<span class="line-modified"> 295                 try {</span>
<span class="line-modified"> 296                     if (shared)</span>
<span class="line-modified"> 297                         acquired = (tryAcquireShared(arg) &gt;= 0);</span>
<span class="line-modified"> 298                     else</span>
<span class="line-modified"> 299                         acquired = tryAcquire(arg);</span>
<span class="line-modified"> 300                 } catch (Throwable ex) {</span>
<span class="line-modified"> 301                     cancelAcquire(node, interrupted, false);</span>
<span class="line-modified"> 302                     throw ex;</span>
















 303                 }
<a name="27" id="anc27"></a><span class="line-modified"> 304                 if (acquired) {</span>
<span class="line-modified"> 305                     if (first) {</span>
<span class="line-modified"> 306                         node.prev = null;</span>
<span class="line-modified"> 307                         head = node;</span>
<span class="line-added"> 308                         pred.next = null;</span>
<span class="line-added"> 309                         node.waiter = null;</span>
<span class="line-added"> 310                         if (shared)</span>
<span class="line-added"> 311                             signalNextIfShared(node);</span>
<span class="line-added"> 312                         if (interrupted)</span>
<span class="line-added"> 313                             current.interrupt();</span>
<span class="line-added"> 314                     }</span>
<span class="line-added"> 315                     return 1;</span>
 316                 }
<a name="28" id="anc28"></a>




 317             }
<a name="29" id="anc29"></a><span class="line-modified"> 318             if (node == null) {                 // allocate; retry before enqueue</span>
<span class="line-modified"> 319                 if (shared)</span>
<span class="line-modified"> 320                     node = new SharedNode();</span>
<span class="line-added"> 321                 else</span>
<span class="line-added"> 322                     node = new ExclusiveNode();</span>
<span class="line-added"> 323             } else if (pred == null) {          // try to enqueue</span>
<span class="line-added"> 324                 node.waiter = current;</span>
<span class="line-added"> 325                 Node t = tail;</span>
<span class="line-added"> 326                 node.setPrevRelaxed(t);         // avoid unnecessary fence</span>
<span class="line-added"> 327                 if (t == null)</span>
<span class="line-added"> 328                     tryInitializeHead();</span>
<span class="line-added"> 329                 else if (!casTail(t, node))</span>
<span class="line-added"> 330                     node.setPrevRelaxed(null);  // back out</span>
<span class="line-added"> 331                 else</span>
<span class="line-added"> 332                     t.next = node;</span>
<span class="line-added"> 333             } else if (first &amp;&amp; spins != 0) {</span>
<span class="line-added"> 334                 --spins;                        // reduce unfairness on rewaits</span>
<span class="line-added"> 335                 Thread.onSpinWait();</span>
<span class="line-added"> 336             } else if (node.status == 0) {</span>
<span class="line-added"> 337                 node.status = WAITING;          // enable signal and recheck</span>
<span class="line-added"> 338             } else {</span>
<span class="line-added"> 339                 long nanos;</span>
<span class="line-added"> 340                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="line-added"> 341                 if (!timed)</span>
<span class="line-added"> 342                     LockSupport.park(this);</span>
<span class="line-added"> 343                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-added"> 344                     LockSupport.parkNanos(this, nanos);</span>
<span class="line-added"> 345                 else</span>
<span class="line-added"> 346                     break;</span>
<span class="line-added"> 347                 node.clearStatus();</span>
<span class="line-added"> 348                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="line-added"> 349                     break;</span>
<span class="line-added"> 350             }</span>
 351         }
<a name="30" id="anc30"></a><span class="line-added"> 352         return cancelAcquire(node, interrupted, interruptible);</span>
 353     }
 354 
 355     /**
<a name="31" id="anc31"></a><span class="line-modified"> 356      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="line-modified"> 357      * nodes until none are found.</span>
 358      */
<a name="32" id="anc32"></a><span class="line-modified"> 359     private void cleanQueue() {</span>
<span class="line-modified"> 360         for (;;) {                               // restart point</span>
<span class="line-modified"> 361             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="line-modified"> 362                 if (q == null || (p = q.prev) == null)</span>
<span class="line-modified"> 363                     return;                      // end of list</span>
<span class="line-modified"> 364                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="line-modified"> 365                     break;                       // inconsistent</span>
<span class="line-modified"> 366                 if (q.status &lt; 0) {              // cancelled</span>
<span class="line-modified"> 367                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="line-modified"> 368                         q.prev == p) {</span>
<span class="line-modified"> 369                         p.casNext(q, s);         // OK if fails</span>
<span class="line-modified"> 370                         if (p.prev == null)</span>
<span class="line-added"> 371                             signalNext(p);</span>
 372                     }
<a name="33" id="anc33"></a><span class="line-added"> 373                     break;</span>
 374                 }
<a name="34" id="anc34"></a><span class="line-modified"> 375                 if ((n = p.next) != q) {         // help finish</span>
<span class="line-modified"> 376                     if (n != null &amp;&amp; q.prev == p) {</span>
<span class="line-modified"> 377                         p.casNext(n, q);</span>
<span class="line-modified"> 378                         if (p.prev == null)</span>
<span class="line-modified"> 379                             signalNext(p);</span>























 380                     }
<a name="35" id="anc35"></a><span class="line-added"> 381                     break;</span>
 382                 }
<a name="36" id="anc36"></a><span class="line-modified"> 383                 s = q;</span>
<span class="line-modified"> 384                 q = q.prev;</span>

 385             }
<a name="37" id="anc37"></a>


 386         }
 387     }
 388 
 389     /**
<a name="38" id="anc38"></a><span class="line-modified"> 390      * Cancels an ongoing attempt to acquire.</span>
 391      *
<a name="39" id="anc39"></a><span class="line-modified"> 392      * @param node the node (may be null if cancelled before enqueuing)</span>
<span class="line-modified"> 393      * @param interrupted true if thread interrupted</span>
<span class="line-modified"> 394      * @param interruptible if should report interruption vs reset</span>
 395      */
<a name="40" id="anc40"></a><span class="line-modified"> 396     private int cancelAcquire(Node node, boolean interrupted,</span>
<span class="line-modified"> 397                               boolean interruptible) {</span>
<span class="line-modified"> 398         if (node != null) {</span>
<span class="line-modified"> 399             node.waiter = null;</span>
<span class="line-modified"> 400             node.status = CANCELLED;</span>
<span class="line-modified"> 401             if (node.prev != null)</span>
<span class="line-modified"> 402                 cleanQueue();</span>
<span class="line-modified"> 403         }</span>
<span class="line-modified"> 404         if (interrupted) {</span>
<span class="line-modified"> 405             if (interruptible)</span>
<span class="line-modified"> 406                 return CANCELLED;</span>
<span class="line-modified"> 407             else</span>
<span class="line-modified"> 408                 Thread.currentThread().interrupt();</span>


















 409         }
<a name="41" id="anc41"></a><span class="line-added"> 410         return 0;</span>
 411     }
 412 
 413     // Main exported methods
 414 
 415     /**
 416      * Attempts to acquire in exclusive mode. This method should query
 417      * if the state of the object permits it to be acquired in the
 418      * exclusive mode, and if so to acquire it.
 419      *
 420      * &lt;p&gt;This method is always invoked by the thread performing
 421      * acquire.  If this method reports failure, the acquire method
 422      * may queue the thread, if it is not already queued, until it is
 423      * signalled by a release from some other thread. This can be used
 424      * to implement method {@link Lock#tryLock()}.
 425      *
 426      * &lt;p&gt;The default
 427      * implementation throws {@link UnsupportedOperationException}.
 428      *
 429      * @param arg the acquire argument. This value is always the one
 430      *        passed to an acquire method, or is the value saved on entry
 431      *        to a condition wait.  The value is otherwise uninterpreted
 432      *        and can represent anything you like.
 433      * @return {@code true} if successful. Upon success, this object has
 434      *         been acquired.
 435      * @throws IllegalMonitorStateException if acquiring would place this
 436      *         synchronizer in an illegal state. This exception must be
 437      *         thrown in a consistent fashion for synchronization to work
 438      *         correctly.
 439      * @throws UnsupportedOperationException if exclusive mode is not supported
 440      */
 441     protected boolean tryAcquire(long arg) {
 442         throw new UnsupportedOperationException();
 443     }
 444 
 445     /**
 446      * Attempts to set the state to reflect a release in exclusive
 447      * mode.
 448      *
 449      * &lt;p&gt;This method is always invoked by the thread performing release.
 450      *
 451      * &lt;p&gt;The default implementation throws
 452      * {@link UnsupportedOperationException}.
 453      *
 454      * @param arg the release argument. This value is always the one
 455      *        passed to a release method, or the current state value upon
 456      *        entry to a condition wait.  The value is otherwise
 457      *        uninterpreted and can represent anything you like.
 458      * @return {@code true} if this object is now in a fully released
 459      *         state, so that any waiting threads may attempt to acquire;
 460      *         and {@code false} otherwise.
 461      * @throws IllegalMonitorStateException if releasing would place this
 462      *         synchronizer in an illegal state. This exception must be
 463      *         thrown in a consistent fashion for synchronization to work
 464      *         correctly.
 465      * @throws UnsupportedOperationException if exclusive mode is not supported
 466      */
 467     protected boolean tryRelease(long arg) {
 468         throw new UnsupportedOperationException();
 469     }
 470 
 471     /**
 472      * Attempts to acquire in shared mode. This method should query if
 473      * the state of the object permits it to be acquired in the shared
 474      * mode, and if so to acquire it.
 475      *
 476      * &lt;p&gt;This method is always invoked by the thread performing
 477      * acquire.  If this method reports failure, the acquire method
 478      * may queue the thread, if it is not already queued, until it is
 479      * signalled by a release from some other thread.
 480      *
 481      * &lt;p&gt;The default implementation throws {@link
 482      * UnsupportedOperationException}.
 483      *
 484      * @param arg the acquire argument. This value is always the one
 485      *        passed to an acquire method, or is the value saved on entry
 486      *        to a condition wait.  The value is otherwise uninterpreted
 487      *        and can represent anything you like.
 488      * @return a negative value on failure; zero if acquisition in shared
 489      *         mode succeeded but no subsequent shared-mode acquire can
 490      *         succeed; and a positive value if acquisition in shared
 491      *         mode succeeded and subsequent shared-mode acquires might
 492      *         also succeed, in which case a subsequent waiting thread
 493      *         must check availability. (Support for three different
 494      *         return values enables this method to be used in contexts
 495      *         where acquires only sometimes act exclusively.)  Upon
 496      *         success, this object has been acquired.
 497      * @throws IllegalMonitorStateException if acquiring would place this
 498      *         synchronizer in an illegal state. This exception must be
 499      *         thrown in a consistent fashion for synchronization to work
 500      *         correctly.
 501      * @throws UnsupportedOperationException if shared mode is not supported
 502      */
 503     protected long tryAcquireShared(long arg) {
 504         throw new UnsupportedOperationException();
 505     }
 506 
 507     /**
 508      * Attempts to set the state to reflect a release in shared mode.
 509      *
 510      * &lt;p&gt;This method is always invoked by the thread performing release.
 511      *
 512      * &lt;p&gt;The default implementation throws
 513      * {@link UnsupportedOperationException}.
 514      *
 515      * @param arg the release argument. This value is always the one
 516      *        passed to a release method, or the current state value upon
 517      *        entry to a condition wait.  The value is otherwise
 518      *        uninterpreted and can represent anything you like.
 519      * @return {@code true} if this release of shared mode may permit a
 520      *         waiting acquire (shared or exclusive) to succeed; and
 521      *         {@code false} otherwise
 522      * @throws IllegalMonitorStateException if releasing would place this
 523      *         synchronizer in an illegal state. This exception must be
 524      *         thrown in a consistent fashion for synchronization to work
 525      *         correctly.
 526      * @throws UnsupportedOperationException if shared mode is not supported
 527      */
 528     protected boolean tryReleaseShared(long arg) {
 529         throw new UnsupportedOperationException();
 530     }
 531 
 532     /**
 533      * Returns {@code true} if synchronization is held exclusively with
 534      * respect to the current (calling) thread.  This method is invoked
 535      * upon each call to a {@link ConditionObject} method.
 536      *
 537      * &lt;p&gt;The default implementation throws {@link
 538      * UnsupportedOperationException}. This method is invoked
 539      * internally only within {@link ConditionObject} methods, so need
 540      * not be defined if conditions are not used.
 541      *
 542      * @return {@code true} if synchronization is held exclusively;
 543      *         {@code false} otherwise
 544      * @throws UnsupportedOperationException if conditions are not supported
 545      */
 546     protected boolean isHeldExclusively() {
 547         throw new UnsupportedOperationException();
 548     }
 549 
 550     /**
 551      * Acquires in exclusive mode, ignoring interrupts.  Implemented
 552      * by invoking at least once {@link #tryAcquire},
 553      * returning on success.  Otherwise the thread is queued, possibly
 554      * repeatedly blocking and unblocking, invoking {@link
 555      * #tryAcquire} until success.  This method can be used
 556      * to implement method {@link Lock#lock}.
 557      *
 558      * @param arg the acquire argument.  This value is conveyed to
 559      *        {@link #tryAcquire} but is otherwise uninterpreted and
 560      *        can represent anything you like.
 561      */
 562     public final void acquire(long arg) {
<a name="42" id="anc42"></a><span class="line-modified"> 563         if (!tryAcquire(arg))</span>
<span class="line-modified"> 564             acquire(null, arg, false, false, false, 0L);</span>

 565     }
 566 
 567     /**
 568      * Acquires in exclusive mode, aborting if interrupted.
 569      * Implemented by first checking interrupt status, then invoking
 570      * at least once {@link #tryAcquire}, returning on
 571      * success.  Otherwise the thread is queued, possibly repeatedly
 572      * blocking and unblocking, invoking {@link #tryAcquire}
 573      * until success or the thread is interrupted.  This method can be
 574      * used to implement method {@link Lock#lockInterruptibly}.
 575      *
 576      * @param arg the acquire argument.  This value is conveyed to
 577      *        {@link #tryAcquire} but is otherwise uninterpreted and
 578      *        can represent anything you like.
 579      * @throws InterruptedException if the current thread is interrupted
 580      */
 581     public final void acquireInterruptibly(long arg)
<a name="43" id="anc43"></a><span class="line-modified"> 582         throws InterruptedException {</span>
<span class="line-modified"> 583         if (Thread.interrupted() ||</span>
<span class="line-added"> 584             (!tryAcquire(arg) &amp;&amp; acquire(null, arg, false, true, false, 0L) &lt; 0))</span>
 585             throw new InterruptedException();
<a name="44" id="anc44"></a>

 586     }
 587 
 588     /**
 589      * Attempts to acquire in exclusive mode, aborting if interrupted,
 590      * and failing if the given timeout elapses.  Implemented by first
 591      * checking interrupt status, then invoking at least once {@link
 592      * #tryAcquire}, returning on success.  Otherwise, the thread is
 593      * queued, possibly repeatedly blocking and unblocking, invoking
 594      * {@link #tryAcquire} until success or the thread is interrupted
 595      * or the timeout elapses.  This method can be used to implement
 596      * method {@link Lock#tryLock(long, TimeUnit)}.
 597      *
 598      * @param arg the acquire argument.  This value is conveyed to
 599      *        {@link #tryAcquire} but is otherwise uninterpreted and
 600      *        can represent anything you like.
 601      * @param nanosTimeout the maximum number of nanoseconds to wait
 602      * @return {@code true} if acquired; {@code false} if timed out
 603      * @throws InterruptedException if the current thread is interrupted
 604      */
 605     public final boolean tryAcquireNanos(long arg, long nanosTimeout)
<a name="45" id="anc45"></a><span class="line-modified"> 606         throws InterruptedException {</span>
<span class="line-modified"> 607         if (!Thread.interrupted()) {</span>
<span class="line-modified"> 608             if (tryAcquire(arg))</span>
<span class="line-modified"> 609                 return true;</span>
<span class="line-modified"> 610             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added"> 611                 return false;</span>
<span class="line-added"> 612             int stat = acquire(null, arg, false, true, true,</span>
<span class="line-added"> 613                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added"> 614             if (stat &gt; 0)</span>
<span class="line-added"> 615                 return true;</span>
<span class="line-added"> 616             if (stat == 0)</span>
<span class="line-added"> 617                 return false;</span>
<span class="line-added"> 618         }</span>
<span class="line-added"> 619         throw new InterruptedException();</span>
 620     }
 621 
 622     /**
 623      * Releases in exclusive mode.  Implemented by unblocking one or
 624      * more threads if {@link #tryRelease} returns true.
 625      * This method can be used to implement method {@link Lock#unlock}.
 626      *
 627      * @param arg the release argument.  This value is conveyed to
 628      *        {@link #tryRelease} but is otherwise uninterpreted and
 629      *        can represent anything you like.
 630      * @return the value returned from {@link #tryRelease}
 631      */
 632     public final boolean release(long arg) {
 633         if (tryRelease(arg)) {
<a name="46" id="anc46"></a><span class="line-modified"> 634             signalNext(head);</span>


 635             return true;
 636         }
 637         return false;
 638     }
 639 
 640     /**
 641      * Acquires in shared mode, ignoring interrupts.  Implemented by
 642      * first invoking at least once {@link #tryAcquireShared},
 643      * returning on success.  Otherwise the thread is queued, possibly
 644      * repeatedly blocking and unblocking, invoking {@link
 645      * #tryAcquireShared} until success.
 646      *
 647      * @param arg the acquire argument.  This value is conveyed to
 648      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 649      *        and can represent anything you like.
 650      */
 651     public final void acquireShared(long arg) {
 652         if (tryAcquireShared(arg) &lt; 0)
<a name="47" id="anc47"></a><span class="line-modified"> 653             acquire(null, arg, true, false, false, 0L);</span>
 654     }
 655 
 656     /**
 657      * Acquires in shared mode, aborting if interrupted.  Implemented
 658      * by first checking interrupt status, then invoking at least once
 659      * {@link #tryAcquireShared}, returning on success.  Otherwise the
 660      * thread is queued, possibly repeatedly blocking and unblocking,
 661      * invoking {@link #tryAcquireShared} until success or the thread
 662      * is interrupted.
 663      * @param arg the acquire argument.
 664      * This value is conveyed to {@link #tryAcquireShared} but is
 665      * otherwise uninterpreted and can represent anything
 666      * you like.
 667      * @throws InterruptedException if the current thread is interrupted
 668      */
 669     public final void acquireSharedInterruptibly(long arg)
<a name="48" id="anc48"></a><span class="line-modified"> 670         throws InterruptedException {</span>
<span class="line-modified"> 671         if (Thread.interrupted() ||</span>
<span class="line-added"> 672             (tryAcquireShared(arg) &lt; 0 &amp;&amp;</span>
<span class="line-added"> 673              acquire(null, arg, true, true, false, 0L) &lt; 0))</span>
 674             throw new InterruptedException();
<a name="49" id="anc49"></a>

 675     }
 676 
 677     /**
 678      * Attempts to acquire in shared mode, aborting if interrupted, and
 679      * failing if the given timeout elapses.  Implemented by first
 680      * checking interrupt status, then invoking at least once {@link
 681      * #tryAcquireShared}, returning on success.  Otherwise, the
 682      * thread is queued, possibly repeatedly blocking and unblocking,
 683      * invoking {@link #tryAcquireShared} until success or the thread
 684      * is interrupted or the timeout elapses.
 685      *
 686      * @param arg the acquire argument.  This value is conveyed to
 687      *        {@link #tryAcquireShared} but is otherwise uninterpreted
 688      *        and can represent anything you like.
 689      * @param nanosTimeout the maximum number of nanoseconds to wait
 690      * @return {@code true} if acquired; {@code false} if timed out
 691      * @throws InterruptedException if the current thread is interrupted
 692      */
 693     public final boolean tryAcquireSharedNanos(long arg, long nanosTimeout)
 694             throws InterruptedException {
<a name="50" id="anc50"></a><span class="line-modified"> 695         if (!Thread.interrupted()) {</span>
<span class="line-modified"> 696             if (tryAcquireShared(arg) &gt;= 0)</span>
<span class="line-modified"> 697                 return true;</span>
<span class="line-modified"> 698             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added"> 699                 return false;</span>
<span class="line-added"> 700             int stat = acquire(null, arg, true, true, true,</span>
<span class="line-added"> 701                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added"> 702             if (stat &gt; 0)</span>
<span class="line-added"> 703                 return true;</span>
<span class="line-added"> 704             if (stat == 0)</span>
<span class="line-added"> 705                 return false;</span>
<span class="line-added"> 706         }</span>
<span class="line-added"> 707         throw new InterruptedException();</span>
 708     }
 709 
 710     /**
 711      * Releases in shared mode.  Implemented by unblocking one or more
 712      * threads if {@link #tryReleaseShared} returns true.
 713      *
 714      * @param arg the release argument.  This value is conveyed to
 715      *        {@link #tryReleaseShared} but is otherwise uninterpreted
 716      *        and can represent anything you like.
 717      * @return the value returned from {@link #tryReleaseShared}
 718      */
 719     public final boolean releaseShared(long arg) {
 720         if (tryReleaseShared(arg)) {
<a name="51" id="anc51"></a><span class="line-modified"> 721             signalNext(head);</span>
 722             return true;
 723         }
 724         return false;
 725     }
 726 
 727     // Queue inspection methods
 728 
 729     /**
 730      * Queries whether any threads are waiting to acquire. Note that
 731      * because cancellations due to interrupts and timeouts may occur
 732      * at any time, a {@code true} return does not guarantee that any
 733      * other thread will ever acquire.
 734      *
 735      * @return {@code true} if there may be other threads waiting to acquire
 736      */
 737     public final boolean hasQueuedThreads() {
 738         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<a name="52" id="anc52"></a><span class="line-modified"> 739             if (p.status &gt;= 0)</span>
 740                 return true;
 741         return false;
 742     }
 743 
 744     /**
 745      * Queries whether any threads have ever contended to acquire this
 746      * synchronizer; that is, if an acquire method has ever blocked.
 747      *
 748      * &lt;p&gt;In this implementation, this operation returns in
 749      * constant time.
 750      *
 751      * @return {@code true} if there has ever been contention
 752      */
 753     public final boolean hasContended() {
 754         return head != null;
 755     }
 756 
 757     /**
 758      * Returns the first (longest-waiting) thread in the queue, or
 759      * {@code null} if no threads are currently queued.
 760      *
 761      * &lt;p&gt;In this implementation, this operation normally returns in
 762      * constant time, but may iterate upon contention if other threads are
 763      * concurrently modifying the queue.
 764      *
 765      * @return the first (longest-waiting) thread in the queue, or
 766      *         {@code null} if no threads are currently queued
 767      */
 768     public final Thread getFirstQueuedThread() {
<a name="53" id="anc53"></a><span class="line-modified"> 769         Thread first = null, w; Node h, s;</span>
<span class="line-modified"> 770         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified"> 771                                    (first = s.waiter) == null ||</span>
<span class="line-modified"> 772                                    s.prev == null)) {</span>
<span class="line-modified"> 773             // traverse from tail on stale reads</span>
<span class="line-modified"> 774             for (Node p = tail, q; p != null &amp;&amp; (q = p.prev) != null; p = q)</span>
<span class="line-modified"> 775                 if ((w = p.waiter) != null)</span>
<span class="line-modified"> 776                     first = w;</span>





























 777         }
<a name="54" id="anc54"></a><span class="line-modified"> 778         return first;</span>
 779     }
 780 
 781     /**
 782      * Returns true if the given thread is currently queued.
 783      *
 784      * &lt;p&gt;This implementation traverses the queue to determine
 785      * presence of the given thread.
 786      *
 787      * @param thread the thread
 788      * @return {@code true} if the given thread is on the queue
 789      * @throws NullPointerException if the thread is null
 790      */
 791     public final boolean isQueued(Thread thread) {
 792         if (thread == null)
 793             throw new NullPointerException();
 794         for (Node p = tail; p != null; p = p.prev)
<a name="55" id="anc55"></a><span class="line-modified"> 795             if (p.waiter == thread)</span>
 796                 return true;
 797         return false;
 798     }
 799 
 800     /**
 801      * Returns {@code true} if the apparent first queued thread, if one
 802      * exists, is waiting in exclusive mode.  If this method returns
 803      * {@code true}, and the current thread is attempting to acquire in
 804      * shared mode (that is, this method is invoked from {@link
 805      * #tryAcquireShared}) then it is guaranteed that the current thread
 806      * is not the first queued thread.  Used only as a heuristic in
 807      * ReentrantReadWriteLock.
 808      */
 809     final boolean apparentlyFirstQueuedIsExclusive() {
 810         Node h, s;
<a name="56" id="anc56"></a><span class="line-modified"> 811         return (h = head) != null &amp;&amp; (s = h.next)  != null &amp;&amp;</span>
<span class="line-modified"> 812             !(s instanceof SharedNode) &amp;&amp; s.waiter != null;</span>


 813     }
 814 
 815     /**
 816      * Queries whether any threads have been waiting to acquire longer
 817      * than the current thread.
 818      *
 819      * &lt;p&gt;An invocation of this method is equivalent to (but may be
 820      * more efficient than):
 821      * &lt;pre&gt; {@code
 822      * getFirstQueuedThread() != Thread.currentThread()
 823      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
 824      *
 825      * &lt;p&gt;Note that because cancellations due to interrupts and
 826      * timeouts may occur at any time, a {@code true} return does not
 827      * guarantee that some other thread will acquire before the current
 828      * thread.  Likewise, it is possible for another thread to win a
 829      * race to enqueue after this method has returned {@code false},
 830      * due to the queue being empty.
 831      *
 832      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
 833      * avoid &lt;a href=&quot;AbstractQueuedSynchronizer.html#barging&quot;&gt;barging&lt;/a&gt;.
 834      * Such a synchronizer&#39;s {@link #tryAcquire} method should return
 835      * {@code false}, and its {@link #tryAcquireShared} method should
 836      * return a negative value, if this method returns {@code true}
 837      * (unless this is a reentrant acquire).  For example, the {@code
 838      * tryAcquire} method for a fair, reentrant, exclusive mode
 839      * synchronizer might look like this:
 840      *
 841      * &lt;pre&gt; {@code
<a name="57" id="anc57"></a><span class="line-modified"> 842      * protected boolean tryAcquire(long arg) {</span>
 843      *   if (isHeldExclusively()) {
 844      *     // A reentrant acquire; increment hold count
 845      *     return true;
 846      *   } else if (hasQueuedPredecessors()) {
 847      *     return false;
 848      *   } else {
 849      *     // try to acquire normally
 850      *   }
 851      * }}&lt;/pre&gt;
 852      *
 853      * @return {@code true} if there is a queued thread preceding the
 854      *         current thread, and {@code false} if the current thread
 855      *         is at the head of the queue or the queue is empty
 856      * @since 1.7
 857      */
 858     public final boolean hasQueuedPredecessors() {
<a name="58" id="anc58"></a><span class="line-modified"> 859         Thread first = null; Node h, s;</span>
<span class="line-modified"> 860         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified"> 861                                    (first = s.waiter) == null ||</span>
<span class="line-modified"> 862                                    s.prev == null))</span>
<span class="line-modified"> 863             first = getFirstQueuedThread(); // retry via getFirstQueuedThread</span>
<span class="line-modified"> 864         return first != null &amp;&amp; first != Thread.currentThread();</span>







 865     }
 866 
 867     // Instrumentation and monitoring methods
 868 
 869     /**
 870      * Returns an estimate of the number of threads waiting to
 871      * acquire.  The value is only an estimate because the number of
 872      * threads may change dynamically while this method traverses
 873      * internal data structures.  This method is designed for use in
 874      * monitoring system state, not for synchronization control.
 875      *
 876      * @return the estimated number of threads waiting to acquire
 877      */
 878     public final int getQueueLength() {
 879         int n = 0;
 880         for (Node p = tail; p != null; p = p.prev) {
<a name="59" id="anc59"></a><span class="line-modified"> 881             if (p.waiter != null)</span>
 882                 ++n;
 883         }
 884         return n;
 885     }
 886 
 887     /**
 888      * Returns a collection containing threads that may be waiting to
 889      * acquire.  Because the actual set of threads may change
 890      * dynamically while constructing this result, the returned
 891      * collection is only a best-effort estimate.  The elements of the
 892      * returned collection are in no particular order.  This method is
 893      * designed to facilitate construction of subclasses that provide
 894      * more extensive monitoring facilities.
 895      *
 896      * @return the collection of threads
 897      */
 898     public final Collection&lt;Thread&gt; getQueuedThreads() {
 899         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 900         for (Node p = tail; p != null; p = p.prev) {
<a name="60" id="anc60"></a><span class="line-modified"> 901             Thread t = p.waiter;</span>
 902             if (t != null)
 903                 list.add(t);
 904         }
 905         return list;
 906     }
 907 
 908     /**
 909      * Returns a collection containing threads that may be waiting to
 910      * acquire in exclusive mode. This has the same properties
 911      * as {@link #getQueuedThreads} except that it only returns
 912      * those threads waiting due to an exclusive acquire.
 913      *
 914      * @return the collection of threads
 915      */
 916     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
 917         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 918         for (Node p = tail; p != null; p = p.prev) {
<a name="61" id="anc61"></a><span class="line-modified"> 919             if (!(p instanceof SharedNode)) {</span>
<span class="line-modified"> 920                 Thread t = p.waiter;</span>
 921                 if (t != null)
 922                     list.add(t);
 923             }
 924         }
 925         return list;
 926     }
 927 
 928     /**
 929      * Returns a collection containing threads that may be waiting to
 930      * acquire in shared mode. This has the same properties
 931      * as {@link #getQueuedThreads} except that it only returns
 932      * those threads waiting due to a shared acquire.
 933      *
 934      * @return the collection of threads
 935      */
 936     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
 937         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
 938         for (Node p = tail; p != null; p = p.prev) {
<a name="62" id="anc62"></a><span class="line-modified"> 939             if (p instanceof SharedNode) {</span>
<span class="line-modified"> 940                 Thread t = p.waiter;</span>
 941                 if (t != null)
 942                     list.add(t);
 943             }
 944         }
 945         return list;
 946     }
 947 
 948     /**
 949      * Returns a string identifying this synchronizer, as well as its state.
 950      * The state, in brackets, includes the String {@code &quot;State =&quot;}
 951      * followed by the current value of {@link #getState}, and either
 952      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
 953      * queue is empty.
 954      *
 955      * @return a string identifying this synchronizer, as well as its state
 956      */
 957     public String toString() {
 958         return super.toString()
 959             + &quot;[State = &quot; + getState() + &quot;, &quot;
 960             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
 961     }
 962 
<a name="63" id="anc63"></a>














































































































 963     // Instrumentation methods for conditions
 964 
 965     /**
 966      * Queries whether the given ConditionObject
 967      * uses this synchronizer as its lock.
 968      *
 969      * @param condition the condition
 970      * @return {@code true} if owned
 971      * @throws NullPointerException if the condition is null
 972      */
 973     public final boolean owns(ConditionObject condition) {
 974         return condition.isOwnedBy(this);
 975     }
 976 
 977     /**
 978      * Queries whether any threads are waiting on the given condition
 979      * associated with this synchronizer. Note that because timeouts
 980      * and interrupts may occur at any time, a {@code true} return
 981      * does not guarantee that a future {@code signal} will awaken
 982      * any threads.  This method is designed primarily for use in
 983      * monitoring of the system state.
 984      *
 985      * @param condition the condition
 986      * @return {@code true} if there are any waiting threads
 987      * @throws IllegalMonitorStateException if exclusive synchronization
 988      *         is not held
 989      * @throws IllegalArgumentException if the given condition is
 990      *         not associated with this synchronizer
 991      * @throws NullPointerException if the condition is null
 992      */
 993     public final boolean hasWaiters(ConditionObject condition) {
 994         if (!owns(condition))
 995             throw new IllegalArgumentException(&quot;Not owner&quot;);
 996         return condition.hasWaiters();
 997     }
 998 
 999     /**
1000      * Returns an estimate of the number of threads waiting on the
1001      * given condition associated with this synchronizer. Note that
1002      * because timeouts and interrupts may occur at any time, the
1003      * estimate serves only as an upper bound on the actual number of
1004      * waiters.  This method is designed for use in monitoring system
1005      * state, not for synchronization control.
1006      *
1007      * @param condition the condition
1008      * @return the estimated number of waiting threads
1009      * @throws IllegalMonitorStateException if exclusive synchronization
1010      *         is not held
1011      * @throws IllegalArgumentException if the given condition is
1012      *         not associated with this synchronizer
1013      * @throws NullPointerException if the condition is null
1014      */
1015     public final int getWaitQueueLength(ConditionObject condition) {
1016         if (!owns(condition))
1017             throw new IllegalArgumentException(&quot;Not owner&quot;);
1018         return condition.getWaitQueueLength();
1019     }
1020 
1021     /**
1022      * Returns a collection containing those threads that may be
1023      * waiting on the given condition associated with this
1024      * synchronizer.  Because the actual set of threads may change
1025      * dynamically while constructing this result, the returned
1026      * collection is only a best-effort estimate. The elements of the
1027      * returned collection are in no particular order.
1028      *
1029      * @param condition the condition
1030      * @return the collection of threads
1031      * @throws IllegalMonitorStateException if exclusive synchronization
1032      *         is not held
1033      * @throws IllegalArgumentException if the given condition is
1034      *         not associated with this synchronizer
1035      * @throws NullPointerException if the condition is null
1036      */
1037     public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition) {
1038         if (!owns(condition))
1039             throw new IllegalArgumentException(&quot;Not owner&quot;);
1040         return condition.getWaitingThreads();
1041     }
1042 
1043     /**
1044      * Condition implementation for a {@link AbstractQueuedLongSynchronizer}
1045      * serving as the basis of a {@link Lock} implementation.
1046      *
1047      * &lt;p&gt;Method documentation for this class describes mechanics,
1048      * not behavioral specifications from the point of view of Lock
1049      * and Condition users. Exported versions of this class will in
1050      * general need to be accompanied by documentation describing
1051      * condition semantics that rely on those of the associated
1052      * {@code AbstractQueuedLongSynchronizer}.
1053      *
1054      * &lt;p&gt;This class is Serializable, but all fields are transient,
1055      * so deserialized conditions have no waiters.
<a name="64" id="anc64"></a>

1056      */
1057     public class ConditionObject implements Condition, java.io.Serializable {
1058         private static final long serialVersionUID = 1173984872572414699L;
1059         /** First node of condition queue. */
<a name="65" id="anc65"></a><span class="line-modified">1060         private transient ConditionNode firstWaiter;</span>
1061         /** Last node of condition queue. */
<a name="66" id="anc66"></a><span class="line-modified">1062         private transient ConditionNode lastWaiter;</span>
1063 
1064         /**
1065          * Creates a new {@code ConditionObject} instance.
1066          */
1067         public ConditionObject() { }
1068 
<a name="67" id="anc67"></a><span class="line-modified">1069         // Signalling methods</span>
























1070 
1071         /**
<a name="68" id="anc68"></a><span class="line-modified">1072          * Removes and transfers one or all waiters to sync queue.</span>



1073          */
<a name="69" id="anc69"></a><span class="line-modified">1074         private void doSignal(ConditionNode first, boolean all) {</span>
<span class="line-modified">1075             while (first != null) {</span>
<span class="line-modified">1076                 ConditionNode next = first.nextWaiter;</span>
<span class="line-added">1077                 if ((firstWaiter = next) == null)</span>
1078                     lastWaiter = null;
<a name="70" id="anc70"></a><span class="line-modified">1079                 if ((first.getAndUnsetStatus(COND) &amp; COND) != 0) {</span>
<span class="line-modified">1080                     enqueue(first);</span>
<span class="line-modified">1081                     if (!all)</span>
<span class="line-modified">1082                         break;</span>










































1083                 }
<a name="71" id="anc71"></a><span class="line-modified">1084                 first = next;</span>


1085             }
1086         }
1087 
<a name="72" id="anc72"></a>

1088         /**
1089          * Moves the longest-waiting thread, if one exists, from the
1090          * wait queue for this condition to the wait queue for the
1091          * owning lock.
1092          *
1093          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1094          *         returns {@code false}
1095          */
1096         public final void signal() {
<a name="73" id="anc73"></a><span class="line-added">1097             ConditionNode first = firstWaiter;</span>
1098             if (!isHeldExclusively())
1099                 throw new IllegalMonitorStateException();
<a name="74" id="anc74"></a>
1100             if (first != null)
<a name="75" id="anc75"></a><span class="line-modified">1101                 doSignal(first, false);</span>
1102         }
1103 
1104         /**
1105          * Moves all threads from the wait queue for this condition to
1106          * the wait queue for the owning lock.
1107          *
1108          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1109          *         returns {@code false}
1110          */
1111         public final void signalAll() {
<a name="76" id="anc76"></a><span class="line-added">1112             ConditionNode first = firstWaiter;</span>
1113             if (!isHeldExclusively())
1114                 throw new IllegalMonitorStateException();
<a name="77" id="anc77"></a>
1115             if (first != null)
<a name="78" id="anc78"></a><span class="line-modified">1116                 doSignal(first, true);</span>
<span class="line-added">1117         }</span>
<span class="line-added">1118 </span>
<span class="line-added">1119         // Waiting methods</span>
<span class="line-added">1120 </span>
<span class="line-added">1121         /**</span>
<span class="line-added">1122          * Adds node to condition list and releases lock.</span>
<span class="line-added">1123          *</span>
<span class="line-added">1124          * @param node the node</span>
<span class="line-added">1125          * @return savedState to reacquire after wait</span>
<span class="line-added">1126          */</span>
<span class="line-added">1127         private long enableWait(ConditionNode node) {</span>
<span class="line-added">1128             if (isHeldExclusively()) {</span>
<span class="line-added">1129                 node.waiter = Thread.currentThread();</span>
<span class="line-added">1130                 node.setStatusRelaxed(COND | WAITING);</span>
<span class="line-added">1131                 ConditionNode last = lastWaiter;</span>
<span class="line-added">1132                 if (last == null)</span>
<span class="line-added">1133                     firstWaiter = node;</span>
<span class="line-added">1134                 else</span>
<span class="line-added">1135                     last.nextWaiter = node;</span>
<span class="line-added">1136                 lastWaiter = node;</span>
<span class="line-added">1137                 long savedState = getState();</span>
<span class="line-added">1138                 if (release(savedState))</span>
<span class="line-added">1139                     return savedState;</span>
<span class="line-added">1140             }</span>
<span class="line-added">1141             node.status = CANCELLED; // lock not held or inconsistent</span>
<span class="line-added">1142             throw new IllegalMonitorStateException();</span>
<span class="line-added">1143         }</span>
<span class="line-added">1144 </span>
<span class="line-added">1145         /**</span>
<span class="line-added">1146          * Returns true if a node that was initially placed on a condition</span>
<span class="line-added">1147          * queue is now ready to reacquire on sync queue.</span>
<span class="line-added">1148          * @param node the node</span>
<span class="line-added">1149          * @return true if is reacquiring</span>
<span class="line-added">1150          */</span>
<span class="line-added">1151         private boolean canReacquire(ConditionNode node) {</span>
<span class="line-added">1152             // check links, not status to avoid enqueue race</span>
<span class="line-added">1153             return node != null &amp;&amp; node.prev != null &amp;&amp; isEnqueued(node);</span>
<span class="line-added">1154         }</span>
<span class="line-added">1155 </span>
<span class="line-added">1156         /**</span>
<span class="line-added">1157          * Unlinks the given node and other non-waiting nodes from</span>
<span class="line-added">1158          * condition queue unless already unlinked.</span>
<span class="line-added">1159          */</span>
<span class="line-added">1160         private void unlinkCancelledWaiters(ConditionNode node) {</span>
<span class="line-added">1161             if (node == null || node.nextWaiter != null || node == lastWaiter) {</span>
<span class="line-added">1162                 ConditionNode w = firstWaiter, trail = null;</span>
<span class="line-added">1163                 while (w != null) {</span>
<span class="line-added">1164                     ConditionNode next = w.nextWaiter;</span>
<span class="line-added">1165                     if ((w.status &amp; COND) == 0) {</span>
<span class="line-added">1166                         w.nextWaiter = null;</span>
<span class="line-added">1167                         if (trail == null)</span>
<span class="line-added">1168                             firstWaiter = next;</span>
<span class="line-added">1169                         else</span>
<span class="line-added">1170                             trail.nextWaiter = next;</span>
<span class="line-added">1171                         if (next == null)</span>
<span class="line-added">1172                             lastWaiter = trail;</span>
<span class="line-added">1173                     } else</span>
<span class="line-added">1174                         trail = w;</span>
<span class="line-added">1175                     w = next;</span>
<span class="line-added">1176                 }</span>
<span class="line-added">1177             }</span>
1178         }
1179 
1180         /**
1181          * Implements uninterruptible condition wait.
1182          * &lt;ol&gt;
1183          * &lt;li&gt;Save lock state returned by {@link #getState}.
1184          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1185          *     throwing IllegalMonitorStateException if it fails.
1186          * &lt;li&gt;Block until signalled.
1187          * &lt;li&gt;Reacquire by invoking specialized version of
1188          *     {@link #acquire} with saved state as argument.
1189          * &lt;/ol&gt;
1190          */
1191         public final void awaitUninterruptibly() {
<a name="79" id="anc79"></a><span class="line-modified">1192             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1193             long savedState = enableWait(node);</span>
<span class="line-added">1194             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
1195             boolean interrupted = false;
<a name="80" id="anc80"></a><span class="line-modified">1196             while (!canReacquire(node)) {</span>

1197                 if (Thread.interrupted())
1198                     interrupted = true;
<a name="81" id="anc81"></a><span class="line-added">1199                 else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1200                     try {</span>
<span class="line-added">1201                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1202                     } catch (InterruptedException ie) {</span>
<span class="line-added">1203                         interrupted = true;</span>
<span class="line-added">1204                     }</span>
<span class="line-added">1205                 } else</span>
<span class="line-added">1206                     Thread.onSpinWait();    // awoke while enqueuing</span>
1207             }
<a name="82" id="anc82"></a><span class="line-modified">1208             LockSupport.setCurrentBlocker(null);</span>
<span class="line-modified">1209             node.clearStatus();</span>
<span class="line-modified">1210             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1211             if (interrupted)</span>
<span class="line-modified">1212                 Thread.currentThread().interrupt();</span>
































1213         }
1214 
1215         /**
1216          * Implements interruptible condition wait.
1217          * &lt;ol&gt;
1218          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1219          * &lt;li&gt;Save lock state returned by {@link #getState}.
1220          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1221          *     throwing IllegalMonitorStateException if it fails.
1222          * &lt;li&gt;Block until signalled or interrupted.
1223          * &lt;li&gt;Reacquire by invoking specialized version of
1224          *     {@link #acquire} with saved state as argument.
1225          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1226          * &lt;/ol&gt;
1227          */
1228         public final void await() throws InterruptedException {
1229             if (Thread.interrupted())
1230                 throw new InterruptedException();
<a name="83" id="anc83"></a><span class="line-modified">1231             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1232             long savedState = enableWait(node);</span>
<span class="line-modified">1233             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
<span class="line-modified">1234             boolean interrupted = false, cancelled = false;</span>
<span class="line-modified">1235             while (!canReacquire(node)) {</span>
<span class="line-modified">1236                 if (interrupted |= Thread.interrupted()) {</span>
<span class="line-modified">1237                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-added">1238                         break;              // else interrupted after signal</span>
<span class="line-added">1239                 } else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1240                     try {</span>
<span class="line-added">1241                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1242                     } catch (InterruptedException ie) {</span>
<span class="line-added">1243                         interrupted = true;</span>
<span class="line-added">1244                     }</span>
<span class="line-added">1245                 } else</span>
<span class="line-added">1246                     Thread.onSpinWait();    // awoke while enqueuing</span>
<span class="line-added">1247             }</span>
<span class="line-added">1248             LockSupport.setCurrentBlocker(null);</span>
<span class="line-added">1249             node.clearStatus();</span>
<span class="line-added">1250             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-added">1251             if (interrupted) {</span>
<span class="line-added">1252                 if (cancelled) {</span>
<span class="line-added">1253                     unlinkCancelledWaiters(node);</span>
<span class="line-added">1254                     throw new InterruptedException();</span>
<span class="line-added">1255                 }</span>
<span class="line-added">1256                 Thread.currentThread().interrupt();</span>
1257             }
<a name="84" id="anc84"></a>





1258         }
1259 
1260         /**
1261          * Implements timed condition wait.
1262          * &lt;ol&gt;
1263          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1264          * &lt;li&gt;Save lock state returned by {@link #getState}.
1265          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1266          *     throwing IllegalMonitorStateException if it fails.
1267          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1268          * &lt;li&gt;Reacquire by invoking specialized version of
1269          *     {@link #acquire} with saved state as argument.
1270          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1271          * &lt;/ol&gt;
1272          */
1273         public final long awaitNanos(long nanosTimeout)
1274                 throws InterruptedException {
1275             if (Thread.interrupted())
1276                 throw new InterruptedException();
<a name="85" id="anc85"></a><span class="line-modified">1277             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1278             long savedState = enableWait(node);</span>
<span class="line-modified">1279             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1280             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1281             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1282             while (!canReacquire(node)) {</span>
<span class="line-modified">1283                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1284                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1285                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1286                         break;</span>
<span class="line-modified">1287                 } else</span>
<span class="line-modified">1288                     LockSupport.parkNanos(this, nanos);</span>





1289             }
<a name="86" id="anc86"></a><span class="line-modified">1290             node.clearStatus();</span>
<span class="line-modified">1291             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1292             if (cancelled) {</span>
<span class="line-modified">1293                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1294                 if (interrupted)</span>
<span class="line-modified">1295                     throw new InterruptedException();</span>
<span class="line-added">1296             } else if (interrupted)</span>
<span class="line-added">1297                 Thread.currentThread().interrupt();</span>
1298             long remaining = deadline - System.nanoTime(); // avoid overflow
<a name="87" id="anc87"></a><span class="line-modified">1299             return (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;</span>
1300         }
1301 
1302         /**
1303          * Implements absolute timed condition wait.
1304          * &lt;ol&gt;
1305          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1306          * &lt;li&gt;Save lock state returned by {@link #getState}.
1307          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1308          *     throwing IllegalMonitorStateException if it fails.
1309          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1310          * &lt;li&gt;Reacquire by invoking specialized version of
1311          *     {@link #acquire} with saved state as argument.
1312          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1313          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1314          * &lt;/ol&gt;
1315          */
1316         public final boolean awaitUntil(Date deadline)
1317                 throws InterruptedException {
1318             long abstime = deadline.getTime();
1319             if (Thread.interrupted())
1320                 throw new InterruptedException();
<a name="88" id="anc88"></a><span class="line-modified">1321             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1322             long savedState = enableWait(node);</span>
<span class="line-modified">1323             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1324             while (!canReacquire(node)) {</span>
<span class="line-modified">1325                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1326                     System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">1327                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1328                         break;</span>
<span class="line-modified">1329                 } else</span>
<span class="line-modified">1330                     LockSupport.parkUntil(this, abstime);</span>


1331             }
<a name="89" id="anc89"></a><span class="line-modified">1332             node.clearStatus();</span>
<span class="line-modified">1333             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1334             if (cancelled) {</span>
<span class="line-modified">1335                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1336                 if (interrupted)</span>
<span class="line-modified">1337                     throw new InterruptedException();</span>
<span class="line-modified">1338             } else if (interrupted)</span>
<span class="line-added">1339                 Thread.currentThread().interrupt();</span>
<span class="line-added">1340             return !cancelled;</span>
1341         }
1342 
1343         /**
1344          * Implements timed condition wait.
1345          * &lt;ol&gt;
1346          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1347          * &lt;li&gt;Save lock state returned by {@link #getState}.
1348          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1349          *     throwing IllegalMonitorStateException if it fails.
1350          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1351          * &lt;li&gt;Reacquire by invoking specialized version of
1352          *     {@link #acquire} with saved state as argument.
1353          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1354          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1355          * &lt;/ol&gt;
1356          */
1357         public final boolean await(long time, TimeUnit unit)
1358                 throws InterruptedException {
1359             long nanosTimeout = unit.toNanos(time);
1360             if (Thread.interrupted())
1361                 throw new InterruptedException();
<a name="90" id="anc90"></a><span class="line-modified">1362             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1363             long savedState = enableWait(node);</span>
<span class="line-modified">1364             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1365             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1366             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1367             while (!canReacquire(node)) {</span>
<span class="line-modified">1368                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1369                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1370                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1371                         break;</span>
<span class="line-modified">1372                 } else</span>
<span class="line-modified">1373                     LockSupport.parkNanos(this, nanos);</span>





1374             }
<a name="91" id="anc91"></a><span class="line-modified">1375             node.clearStatus();</span>
<span class="line-modified">1376             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1377             if (cancelled) {</span>
<span class="line-modified">1378                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1379                 if (interrupted)</span>
<span class="line-modified">1380                     throw new InterruptedException();</span>
<span class="line-modified">1381             } else if (interrupted)</span>
<span class="line-added">1382                 Thread.currentThread().interrupt();</span>
<span class="line-added">1383             return !cancelled;</span>
1384         }
1385 
1386         //  support for instrumentation
1387 
1388         /**
1389          * Returns true if this condition was created by the given
1390          * synchronization object.
1391          *
1392          * @return {@code true} if owned
1393          */
1394         final boolean isOwnedBy(AbstractQueuedLongSynchronizer sync) {
1395             return sync == AbstractQueuedLongSynchronizer.this;
1396         }
1397 
1398         /**
1399          * Queries whether any threads are waiting on this condition.
1400          * Implements {@link AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)}.
1401          *
1402          * @return {@code true} if there are any waiting threads
1403          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1404          *         returns {@code false}
1405          */
1406         protected final boolean hasWaiters() {
1407             if (!isHeldExclusively())
1408                 throw new IllegalMonitorStateException();
<a name="92" id="anc92"></a><span class="line-modified">1409             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1410                 if ((w.status &amp; COND) != 0)</span>
1411                     return true;
1412             }
1413             return false;
1414         }
1415 
1416         /**
1417          * Returns an estimate of the number of threads waiting on
1418          * this condition.
1419          * Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)}.
1420          *
1421          * @return the estimated number of waiting threads
1422          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1423          *         returns {@code false}
1424          */
1425         protected final int getWaitQueueLength() {
1426             if (!isHeldExclusively())
1427                 throw new IllegalMonitorStateException();
1428             int n = 0;
<a name="93" id="anc93"></a><span class="line-modified">1429             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1430                 if ((w.status &amp; COND) != 0)</span>
1431                     ++n;
1432             }
1433             return n;
1434         }
1435 
1436         /**
1437          * Returns a collection containing those threads that may be
1438          * waiting on this Condition.
1439          * Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)}.
1440          *
1441          * @return the collection of threads
1442          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1443          *         returns {@code false}
1444          */
1445         protected final Collection&lt;Thread&gt; getWaitingThreads() {
1446             if (!isHeldExclusively())
1447                 throw new IllegalMonitorStateException();
1448             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<a name="94" id="anc94"></a><span class="line-modified">1449             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1450                 if ((w.status &amp; COND) != 0) {</span>
<span class="line-modified">1451                     Thread t = w.waiter;</span>
1452                     if (t != null)
1453                         list.add(t);
1454                 }
1455             }
1456             return list;
1457         }
1458     }
1459 
<a name="95" id="anc95"></a><span class="line-modified">1460     // Unsafe</span>
<span class="line-modified">1461     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified">1462     private static final long STATE</span>
<span class="line-modified">1463         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;state&quot;);</span>
<span class="line-added">1464     private static final long HEAD</span>
<span class="line-added">1465         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;head&quot;);</span>
<span class="line-added">1466     private static final long TAIL</span>
<span class="line-added">1467         = U.objectFieldOffset(AbstractQueuedLongSynchronizer.class, &quot;tail&quot;);</span>
1468 
1469     static {
<a name="96" id="anc96"></a>










1470         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1471     }
<a name="97" id="anc97"></a>















1472 }
<a name="98" id="anc98"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="98" type="hidden" />
</body>
</html>
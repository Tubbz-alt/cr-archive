<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/BoundMethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BootstrapMethodInvoker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CallSite.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/BoundMethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 
 34 import static java.lang.invoke.LambdaForm.BasicType;
 35 import static java.lang.invoke.LambdaForm.BasicType.*;
 36 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 37 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 38 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 39 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
 40 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 41 import static java.lang.invoke.MethodHandleStatics.newInternalError;
 42 import static java.lang.invoke.MethodHandleStatics.uncaughtException;
 43 
 44 /**
 45  * The flavor of method handle which emulates an invoke instruction
 46  * on a predetermined argument.  The JVM dispatches to the correct method
 47  * when the handle is created, not when it is invoked.
 48  *
 49  * All bound arguments are encapsulated in dedicated species.
 50  */
<span class="line-modified"> 51 /*non-public*/ abstract class BoundMethodHandle extends MethodHandle {</span>

 52 
<span class="line-modified"> 53     /*non-public*/ BoundMethodHandle(MethodType type, LambdaForm form) {</span>

 54         super(type, form);
 55         assert(speciesData() == speciesDataFor(form));
 56     }
 57 
 58     //
 59     // BMH API and internals
 60     //
 61 
 62     static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {
 63         // for some type signatures, there exist pre-defined concrete BMH classes
 64         try {
 65             switch (xtype) {
 66             case L_TYPE:
 67                 return bindSingle(type, form, x);  // Use known fast path.
 68             case I_TYPE:
 69                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));
 70             case J_TYPE:
 71                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);
 72             case F_TYPE:
 73                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);
</pre>
<hr />
<pre>
124                 form.expressionCount() &gt; FORM_EXPRESSION_THRESHOLD);
125     }
126     private static final int FIELD_COUNT_THRESHOLD = 12;      // largest convenient BMH field count
127     private static final int FORM_EXPRESSION_THRESHOLD = 24;  // largest convenient BMH expression count
128 
129     /**
130      * A reinvoker MH has this form:
131      * {@code lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }}
132      */
133     static BoundMethodHandle makeReinvoker(MethodHandle target) {
134         LambdaForm form = DelegatingMethodHandle.makeReinvokerForm(
135                 target, MethodTypeForm.LF_REBIND,
136                 Species_L.BMH_SPECIES, Species_L.BMH_SPECIES.getterFunction(0));
137         return Species_L.make(target.type(), form, target);
138     }
139 
140     /**
141      * Return the {@link BoundMethodHandle.SpeciesData} instance representing this BMH species. All subclasses must provide a
142      * static field containing this value, and they must accordingly implement this method.
143      */
<span class="line-modified">144     /*non-public*/ abstract BoundMethodHandle.SpeciesData speciesData();</span>

145 
<span class="line-modified">146     /*non-public*/ static BoundMethodHandle.SpeciesData speciesDataFor(LambdaForm form) {</span>

147         Object c = form.names[0].constraint;
148         if (c instanceof SpeciesData) {
149             return (SpeciesData) c;
150         }
151         // if there is no BMH constraint, then use the null constraint
152         return SPECIALIZER.topSpecies();
153     }
154 
155     /**
156      * Return the number of fields in this BMH.  Equivalent to speciesData().fieldCount().
157      */
<span class="line-modified">158     /*non-public*/ final int fieldCount() { return speciesData().fieldCount(); }</span>

159 
160     @Override
161     Object internalProperties() {
162         return &quot;\n&amp; BMH=&quot;+internalValues();
163     }
164 
165     @Override
166     final String internalValues() {
167         int count = fieldCount();
168         if (count == 1) {
169             return &quot;[&quot; + arg(0) + &quot;]&quot;;
170         }
171         StringBuilder sb = new StringBuilder(&quot;[&quot;);
172         for (int i = 0; i &lt; count; ++i) {
173             sb.append(&quot;\n  &quot;).append(i).append(&quot;: ( &quot;).append(arg(i)).append(&quot; )&quot;);
174         }
175         return sb.append(&quot;\n]&quot;).toString();
176     }
177 
<span class="line-modified">178     /*non-public*/ final Object arg(int i) {</span>

179         try {
180             Class&lt;?&gt; fieldType = speciesData().fieldTypes().get(i);
181             switch (BasicType.basicType(fieldType)) {
182                 case L_TYPE: return          speciesData().getter(i).invokeBasic(this);
183                 case I_TYPE: return (int)    speciesData().getter(i).invokeBasic(this);
184                 case J_TYPE: return (long)   speciesData().getter(i).invokeBasic(this);
185                 case F_TYPE: return (float)  speciesData().getter(i).invokeBasic(this);
186                 case D_TYPE: return (double) speciesData().getter(i).invokeBasic(this);
187             }
188         } catch (Throwable ex) {
189             throw uncaughtException(ex);
190         }
191         throw new InternalError(&quot;unexpected type: &quot; + speciesData().key()+&quot;.&quot;+i);
192     }
193 
194     //
195     // cloning API
196     //
197 
<span class="line-modified">198     /*non-public*/ abstract BoundMethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-modified">199     /*non-public*/ abstract BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg);</span>
<span class="line-modified">200     /*non-public*/ abstract BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int    narg);</span>
<span class="line-modified">201     /*non-public*/ abstract BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long   narg);</span>
<span class="line-modified">202     /*non-public*/ abstract BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float  narg);</span>
<span class="line-modified">203     /*non-public*/ abstract BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg);</span>






204 
205     //
206     // concrete BMH classes required to close bootstrap loops
207     //
208 
209     private  // make it private to force users to access the enclosing class first
210     static final class Species_L extends BoundMethodHandle {
211 
212         final Object argL0;
213 
214         private Species_L(MethodType mt, LambdaForm lf, Object argL0) {
215             super(mt, lf);
216             this.argL0 = argL0;
217         }
218 
219         @Override
<span class="line-modified">220         /*non-public*/ SpeciesData speciesData() {</span>

221             return BMH_SPECIES;
222         }
223 
<span class="line-modified">224         /*non-public*/ static @Stable SpeciesData BMH_SPECIES;</span>

225 
<span class="line-modified">226         /*non-public*/ static BoundMethodHandle make(MethodType mt, LambdaForm lf, Object argL0) {</span>

227             return new Species_L(mt, lf, argL0);
228         }
229         @Override
<span class="line-modified">230         /*non-public*/ final BoundMethodHandle copyWith(MethodType mt, LambdaForm lf) {</span>

231             return new Species_L(mt, lf, argL0);
232         }
233         @Override
<span class="line-modified">234         /*non-public*/ final BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg) {</span>

235             try {
236                 return (BoundMethodHandle) BMH_SPECIES.extendWith(L_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
237             } catch (Throwable ex) {
238                 throw uncaughtException(ex);
239             }
240         }
241         @Override
<span class="line-modified">242         /*non-public*/ final BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int narg) {</span>

243             try {
244                 return (BoundMethodHandle) BMH_SPECIES.extendWith(I_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
245             } catch (Throwable ex) {
246                 throw uncaughtException(ex);
247             }
248         }
249         @Override
<span class="line-modified">250         /*non-public*/ final BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long narg) {</span>

251             try {
252                 return (BoundMethodHandle) BMH_SPECIES.extendWith(J_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
253             } catch (Throwable ex) {
254                 throw uncaughtException(ex);
255             }
256         }
257         @Override
<span class="line-modified">258         /*non-public*/ final BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float narg) {</span>

259             try {
260                 return (BoundMethodHandle) BMH_SPECIES.extendWith(F_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
261             } catch (Throwable ex) {
262                 throw uncaughtException(ex);
263             }
264         }
265         @Override
<span class="line-modified">266         /*non-public*/ final BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg) {</span>

267             try {
268                 return (BoundMethodHandle) BMH_SPECIES.extendWith(D_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
269             } catch (Throwable ex) {
270                 throw uncaughtException(ex);
271             }
272         }
273     }
274 
275     //
276     // BMH species meta-data
277     //
278 
279     /*non-public*/
<span class="line-modified">280     static final class SpeciesData extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt;.SpeciesData {</span>

281         // This array is filled in lazily, as new species come into being over time.
282         @Stable final private SpeciesData[] extensions = new SpeciesData[ARG_TYPE_LIMIT];
283 
284         public SpeciesData(Specializer outer, String key) {
285             outer.super(key);
286         }
287 
288         @Override
289         protected String deriveClassName() {
290             String typeString = deriveTypeString();
291             if (typeString.isEmpty()) {
292                 return SimpleMethodHandle.class.getName();
293             }
294             return BoundMethodHandle.class.getName() + &quot;$Species_&quot; + typeString;
295         }
296 
297         @Override
298         protected List&lt;Class&lt;?&gt;&gt; deriveFieldTypes(String key) {
299             ArrayList&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;&gt;(key.length());
300             for (int i = 0; i &lt; key.length(); i++) {
</pre>
<hr />
<pre>
329             return args;
330         }
331 
332         private boolean verifyTHAargs(MemberName transform, int whichtm, List&lt;?&gt; args, List&lt;?&gt; fields) {
333             assert(transform == Specializer.BMH_TRANSFORMS.get(whichtm));
334             assert(args.size() == transform.getMethodType().parameterCount());
335             assert(fields.size() == this.fieldCount());
336             final int MH_AND_LF = 2;
337             if (whichtm == Specializer.TN_COPY_NO_EXTEND) {
338                 assert(transform.getMethodType().parameterCount() == MH_AND_LF);
339             } else if (whichtm &lt; ARG_TYPE_LIMIT) {
340                 assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);
341                 final BasicType type = basicType((byte) whichtm);
342                 assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());
343             } else {
344                 return false;
345             }
346             return true;
347         }
348 
<span class="line-modified">349         /*non-public*/ SpeciesData extendWith(byte typeNum) {</span>

350             SpeciesData sd = extensions[typeNum];
351             if (sd != null)  return sd;
352             sd = SPECIALIZER.findSpecies(key() + BasicType.basicType(typeNum).basicTypeChar());
353             extensions[typeNum] = sd;
354             return sd;
355         }
356     }
357 
358     /*non-public*/
359     static final Specializer SPECIALIZER = new Specializer();
360     static {
361         SimpleMethodHandle.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;&quot;);
362         Species_L.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;L&quot;);
363     }
364 
365     /*non-public*/
<span class="line-modified">366     static final class Specializer extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt; {</span>

367 
368         private static final MemberName SPECIES_DATA_ACCESSOR;
369 
370         static {
371             try {
372                 SPECIES_DATA_ACCESSOR = IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BoundMethodHandle.class,
373                         &quot;speciesData&quot;, MethodType.methodType(BoundMethodHandle.SpeciesData.class));
374             } catch (ReflectiveOperationException ex) {
375                 throw newInternalError(&quot;Bootstrap link error&quot;, ex);
376             }
377         }
378 
379         private Specializer() {
380             super(  // Reified type parameters:
381                     BoundMethodHandle.class, String.class, BoundMethodHandle.SpeciesData.class,
382                     // Principal constructor type:
383                     MethodType.methodType(void.class, MethodType.class, LambdaForm.class),
384                     // Required linkage between class and species:
385                     SPECIES_DATA_ACCESSOR,
386                     &quot;BMH_SPECIES&quot;,
</pre>
</td>
<td>
<hr />
<pre>
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 
 34 import static java.lang.invoke.LambdaForm.BasicType;
 35 import static java.lang.invoke.LambdaForm.BasicType.*;
 36 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 37 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 38 import static java.lang.invoke.LambdaForm.BasicType.V_TYPE_NUM;
 39 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
 40 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 41 import static java.lang.invoke.MethodHandleStatics.newInternalError;
 42 import static java.lang.invoke.MethodHandleStatics.uncaughtException;
 43 
 44 /**
 45  * The flavor of method handle which emulates an invoke instruction
 46  * on a predetermined argument.  The JVM dispatches to the correct method
 47  * when the handle is created, not when it is invoked.
 48  *
 49  * All bound arguments are encapsulated in dedicated species.
 50  */
<span class="line-modified"> 51 /*non-public*/</span>
<span class="line-added"> 52 abstract class BoundMethodHandle extends MethodHandle {</span>
 53 
<span class="line-modified"> 54     /*non-public*/</span>
<span class="line-added"> 55     BoundMethodHandle(MethodType type, LambdaForm form) {</span>
 56         super(type, form);
 57         assert(speciesData() == speciesDataFor(form));
 58     }
 59 
 60     //
 61     // BMH API and internals
 62     //
 63 
 64     static BoundMethodHandle bindSingle(MethodType type, LambdaForm form, BasicType xtype, Object x) {
 65         // for some type signatures, there exist pre-defined concrete BMH classes
 66         try {
 67             switch (xtype) {
 68             case L_TYPE:
 69                 return bindSingle(type, form, x);  // Use known fast path.
 70             case I_TYPE:
 71                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));
 72             case J_TYPE:
 73                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);
 74             case F_TYPE:
 75                 return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);
</pre>
<hr />
<pre>
126                 form.expressionCount() &gt; FORM_EXPRESSION_THRESHOLD);
127     }
128     private static final int FIELD_COUNT_THRESHOLD = 12;      // largest convenient BMH field count
129     private static final int FORM_EXPRESSION_THRESHOLD = 24;  // largest convenient BMH expression count
130 
131     /**
132      * A reinvoker MH has this form:
133      * {@code lambda (bmh, arg*) { thismh = bmh[0]; invokeBasic(thismh, arg*) }}
134      */
135     static BoundMethodHandle makeReinvoker(MethodHandle target) {
136         LambdaForm form = DelegatingMethodHandle.makeReinvokerForm(
137                 target, MethodTypeForm.LF_REBIND,
138                 Species_L.BMH_SPECIES, Species_L.BMH_SPECIES.getterFunction(0));
139         return Species_L.make(target.type(), form, target);
140     }
141 
142     /**
143      * Return the {@link BoundMethodHandle.SpeciesData} instance representing this BMH species. All subclasses must provide a
144      * static field containing this value, and they must accordingly implement this method.
145      */
<span class="line-modified">146     /*non-public*/</span>
<span class="line-added">147     abstract BoundMethodHandle.SpeciesData speciesData();</span>
148 
<span class="line-modified">149     /*non-public*/</span>
<span class="line-added">150     static BoundMethodHandle.SpeciesData speciesDataFor(LambdaForm form) {</span>
151         Object c = form.names[0].constraint;
152         if (c instanceof SpeciesData) {
153             return (SpeciesData) c;
154         }
155         // if there is no BMH constraint, then use the null constraint
156         return SPECIALIZER.topSpecies();
157     }
158 
159     /**
160      * Return the number of fields in this BMH.  Equivalent to speciesData().fieldCount().
161      */
<span class="line-modified">162     /*non-public*/</span>
<span class="line-added">163     final int fieldCount() { return speciesData().fieldCount(); }</span>
164 
165     @Override
166     Object internalProperties() {
167         return &quot;\n&amp; BMH=&quot;+internalValues();
168     }
169 
170     @Override
171     final String internalValues() {
172         int count = fieldCount();
173         if (count == 1) {
174             return &quot;[&quot; + arg(0) + &quot;]&quot;;
175         }
176         StringBuilder sb = new StringBuilder(&quot;[&quot;);
177         for (int i = 0; i &lt; count; ++i) {
178             sb.append(&quot;\n  &quot;).append(i).append(&quot;: ( &quot;).append(arg(i)).append(&quot; )&quot;);
179         }
180         return sb.append(&quot;\n]&quot;).toString();
181     }
182 
<span class="line-modified">183     /*non-public*/</span>
<span class="line-added">184     final Object arg(int i) {</span>
185         try {
186             Class&lt;?&gt; fieldType = speciesData().fieldTypes().get(i);
187             switch (BasicType.basicType(fieldType)) {
188                 case L_TYPE: return          speciesData().getter(i).invokeBasic(this);
189                 case I_TYPE: return (int)    speciesData().getter(i).invokeBasic(this);
190                 case J_TYPE: return (long)   speciesData().getter(i).invokeBasic(this);
191                 case F_TYPE: return (float)  speciesData().getter(i).invokeBasic(this);
192                 case D_TYPE: return (double) speciesData().getter(i).invokeBasic(this);
193             }
194         } catch (Throwable ex) {
195             throw uncaughtException(ex);
196         }
197         throw new InternalError(&quot;unexpected type: &quot; + speciesData().key()+&quot;.&quot;+i);
198     }
199 
200     //
201     // cloning API
202     //
203 
<span class="line-modified">204     /*non-public*/</span>
<span class="line-modified">205     abstract BoundMethodHandle copyWith(MethodType mt, LambdaForm lf);</span>
<span class="line-modified">206     /*non-public*/</span>
<span class="line-modified">207     abstract BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg);</span>
<span class="line-modified">208     /*non-public*/</span>
<span class="line-modified">209     abstract BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int    narg);</span>
<span class="line-added">210     /*non-public*/</span>
<span class="line-added">211     abstract BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long   narg);</span>
<span class="line-added">212     /*non-public*/</span>
<span class="line-added">213     abstract BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float  narg);</span>
<span class="line-added">214     /*non-public*/</span>
<span class="line-added">215     abstract BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg);</span>
216 
217     //
218     // concrete BMH classes required to close bootstrap loops
219     //
220 
221     private  // make it private to force users to access the enclosing class first
222     static final class Species_L extends BoundMethodHandle {
223 
224         final Object argL0;
225 
226         private Species_L(MethodType mt, LambdaForm lf, Object argL0) {
227             super(mt, lf);
228             this.argL0 = argL0;
229         }
230 
231         @Override
<span class="line-modified">232         /*non-public*/</span>
<span class="line-added">233         SpeciesData speciesData() {</span>
234             return BMH_SPECIES;
235         }
236 
<span class="line-modified">237         /*non-public*/</span>
<span class="line-added">238         static @Stable SpeciesData BMH_SPECIES;</span>
239 
<span class="line-modified">240         /*non-public*/</span>
<span class="line-added">241         static BoundMethodHandle make(MethodType mt, LambdaForm lf, Object argL0) {</span>
242             return new Species_L(mt, lf, argL0);
243         }
244         @Override
<span class="line-modified">245         /*non-public*/</span>
<span class="line-added">246         final BoundMethodHandle copyWith(MethodType mt, LambdaForm lf) {</span>
247             return new Species_L(mt, lf, argL0);
248         }
249         @Override
<span class="line-modified">250         /*non-public*/</span>
<span class="line-added">251         final BoundMethodHandle copyWithExtendL(MethodType mt, LambdaForm lf, Object narg) {</span>
252             try {
253                 return (BoundMethodHandle) BMH_SPECIES.extendWith(L_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
254             } catch (Throwable ex) {
255                 throw uncaughtException(ex);
256             }
257         }
258         @Override
<span class="line-modified">259         /*non-public*/</span>
<span class="line-added">260         final BoundMethodHandle copyWithExtendI(MethodType mt, LambdaForm lf, int narg) {</span>
261             try {
262                 return (BoundMethodHandle) BMH_SPECIES.extendWith(I_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
263             } catch (Throwable ex) {
264                 throw uncaughtException(ex);
265             }
266         }
267         @Override
<span class="line-modified">268         /*non-public*/</span>
<span class="line-added">269         final BoundMethodHandle copyWithExtendJ(MethodType mt, LambdaForm lf, long narg) {</span>
270             try {
271                 return (BoundMethodHandle) BMH_SPECIES.extendWith(J_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
272             } catch (Throwable ex) {
273                 throw uncaughtException(ex);
274             }
275         }
276         @Override
<span class="line-modified">277         /*non-public*/</span>
<span class="line-added">278         final BoundMethodHandle copyWithExtendF(MethodType mt, LambdaForm lf, float narg) {</span>
279             try {
280                 return (BoundMethodHandle) BMH_SPECIES.extendWith(F_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
281             } catch (Throwable ex) {
282                 throw uncaughtException(ex);
283             }
284         }
285         @Override
<span class="line-modified">286         /*non-public*/</span>
<span class="line-added">287         final BoundMethodHandle copyWithExtendD(MethodType mt, LambdaForm lf, double narg) {</span>
288             try {
289                 return (BoundMethodHandle) BMH_SPECIES.extendWith(D_TYPE_NUM).factory().invokeBasic(mt, lf, argL0, narg);
290             } catch (Throwable ex) {
291                 throw uncaughtException(ex);
292             }
293         }
294     }
295 
296     //
297     // BMH species meta-data
298     //
299 
300     /*non-public*/
<span class="line-modified">301     static final class SpeciesData</span>
<span class="line-added">302             extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt;.SpeciesData {</span>
303         // This array is filled in lazily, as new species come into being over time.
304         @Stable final private SpeciesData[] extensions = new SpeciesData[ARG_TYPE_LIMIT];
305 
306         public SpeciesData(Specializer outer, String key) {
307             outer.super(key);
308         }
309 
310         @Override
311         protected String deriveClassName() {
312             String typeString = deriveTypeString();
313             if (typeString.isEmpty()) {
314                 return SimpleMethodHandle.class.getName();
315             }
316             return BoundMethodHandle.class.getName() + &quot;$Species_&quot; + typeString;
317         }
318 
319         @Override
320         protected List&lt;Class&lt;?&gt;&gt; deriveFieldTypes(String key) {
321             ArrayList&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;&gt;(key.length());
322             for (int i = 0; i &lt; key.length(); i++) {
</pre>
<hr />
<pre>
351             return args;
352         }
353 
354         private boolean verifyTHAargs(MemberName transform, int whichtm, List&lt;?&gt; args, List&lt;?&gt; fields) {
355             assert(transform == Specializer.BMH_TRANSFORMS.get(whichtm));
356             assert(args.size() == transform.getMethodType().parameterCount());
357             assert(fields.size() == this.fieldCount());
358             final int MH_AND_LF = 2;
359             if (whichtm == Specializer.TN_COPY_NO_EXTEND) {
360                 assert(transform.getMethodType().parameterCount() == MH_AND_LF);
361             } else if (whichtm &lt; ARG_TYPE_LIMIT) {
362                 assert(transform.getMethodType().parameterCount() == MH_AND_LF+1);
363                 final BasicType type = basicType((byte) whichtm);
364                 assert(transform.getParameterTypes()[MH_AND_LF] == type.basicTypeClass());
365             } else {
366                 return false;
367             }
368             return true;
369         }
370 
<span class="line-modified">371         /*non-public*/</span>
<span class="line-added">372         SpeciesData extendWith(byte typeNum) {</span>
373             SpeciesData sd = extensions[typeNum];
374             if (sd != null)  return sd;
375             sd = SPECIALIZER.findSpecies(key() + BasicType.basicType(typeNum).basicTypeChar());
376             extensions[typeNum] = sd;
377             return sd;
378         }
379     }
380 
381     /*non-public*/
382     static final Specializer SPECIALIZER = new Specializer();
383     static {
384         SimpleMethodHandle.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;&quot;);
385         Species_L.BMH_SPECIES = BoundMethodHandle.SPECIALIZER.findSpecies(&quot;L&quot;);
386     }
387 
388     /*non-public*/
<span class="line-modified">389     static final class Specializer</span>
<span class="line-added">390             extends ClassSpecializer&lt;BoundMethodHandle, String, SpeciesData&gt; {</span>
391 
392         private static final MemberName SPECIES_DATA_ACCESSOR;
393 
394         static {
395             try {
396                 SPECIES_DATA_ACCESSOR = IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, BoundMethodHandle.class,
397                         &quot;speciesData&quot;, MethodType.methodType(BoundMethodHandle.SpeciesData.class));
398             } catch (ReflectiveOperationException ex) {
399                 throw newInternalError(&quot;Bootstrap link error&quot;, ex);
400             }
401         }
402 
403         private Specializer() {
404             super(  // Reified type parameters:
405                     BoundMethodHandle.class, String.class, BoundMethodHandle.SpeciesData.class,
406                     // Principal constructor type:
407                     MethodType.methodType(void.class, MethodType.class, LambdaForm.class),
408                     // Required linkage between class and species:
409                     SPECIES_DATA_ACCESSOR,
410                     &quot;BMH_SPECIES&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="BootstrapMethodInvoker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CallSite.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
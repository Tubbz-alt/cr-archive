<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantLock.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/LockSupport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
123  *       Thread.currentThread().interrupt();
124  *   }
125  *
126  *   public void unlock() {
127  *     locked.set(false);
128  *     LockSupport.unpark(waiters.peek());
129  *   }
130  *
131  *   static {
132  *     // Reduce the risk of &quot;lost unpark&quot; due to classloading
133  *     Class&lt;?&gt; ensureLoaded = LockSupport.class;
134  *   }
135  * }}&lt;/pre&gt;
136  *
137  * @since 1.5
138  */
139 public class LockSupport {
140     private LockSupport() {} // Cannot be instantiated.
141 
142     private static void setBlocker(Thread t, Object arg) {
<span class="line-modified">143         // Even though volatile, hotspot doesn&#39;t need a write barrier here.</span>
<span class="line-modified">144         U.putReference(t, PARKBLOCKER, arg);</span>

















145     }
146 
147     /**
148      * Makes available the permit for the given thread, if it
149      * was not already available.  If the thread was blocked on
150      * {@code park} then it will unblock.  Otherwise, its next call
151      * to {@code park} is guaranteed not to block. This operation
152      * is not guaranteed to have any effect at all if the given
153      * thread has not been started.
154      *
155      * @param thread the thread to unpark, or {@code null}, in which case
156      *        this operation has no effect
157      */
158     public static void unpark(Thread thread) {
159         if (thread != null)
160             U.unpark(thread);
161     }
162 
163     /**
164      * Disables the current thread for thread scheduling purposes unless the
</pre>
<hr />
<pre>
275         setBlocker(t, blocker);
276         U.park(true, deadline);
277         setBlocker(t, null);
278     }
279 
280     /**
281      * Returns the blocker object supplied to the most recent
282      * invocation of a park method that has not yet unblocked, or null
283      * if not blocked.  The value returned is just a momentary
284      * snapshot -- the thread may have since unblocked or blocked on a
285      * different blocker object.
286      *
287      * @param t the thread
288      * @return the blocker
289      * @throws NullPointerException if argument is null
290      * @since 1.6
291      */
292     public static Object getBlocker(Thread t) {
293         if (t == null)
294             throw new NullPointerException();
<span class="line-modified">295         return U.getReferenceVolatile(t, PARKBLOCKER);</span>
296     }
297 
298     /**
299      * Disables the current thread for thread scheduling purposes unless the
300      * permit is available.
301      *
302      * &lt;p&gt;If the permit is available then it is consumed and the call
303      * returns immediately; otherwise the current thread becomes disabled
304      * for thread scheduling purposes and lies dormant until one of three
305      * things happens:
306      *
307      * &lt;ul&gt;
308      *
309      * &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
310      * current thread as the target; or
311      *
312      * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
313      * the current thread; or
314      *
315      * &lt;li&gt;The call spuriously (that is, for no reason) returns.
</pre>
<hr />
<pre>
376      * the current thread; or
377      *
378      * &lt;li&gt;The specified deadline passes; or
379      *
380      * &lt;li&gt;The call spuriously (that is, for no reason) returns.
381      * &lt;/ul&gt;
382      *
383      * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
384      * method to return. Callers should re-check the conditions which caused
385      * the thread to park in the first place. Callers may also determine,
386      * for example, the interrupt status of the thread, or the current time
387      * upon return.
388      *
389      * @param deadline the absolute time, in milliseconds from the Epoch,
390      *        to wait until
391      */
392     public static void parkUntil(long deadline) {
393         U.park(true, deadline);
394     }
395 
<span class="line-removed">396     /**</span>
<span class="line-removed">397      * Returns the pseudo-randomly initialized or updated secondary seed.</span>
<span class="line-removed">398      * Copied from ThreadLocalRandom due to package access restrictions.</span>
<span class="line-removed">399      */</span>
<span class="line-removed">400     static final int nextSecondarySeed() {</span>
<span class="line-removed">401         int r;</span>
<span class="line-removed">402         Thread t = Thread.currentThread();</span>
<span class="line-removed">403         if ((r = U.getInt(t, SECONDARY)) != 0) {</span>
<span class="line-removed">404             r ^= r &lt;&lt; 13;   // xorshift</span>
<span class="line-removed">405             r ^= r &gt;&gt;&gt; 17;</span>
<span class="line-removed">406             r ^= r &lt;&lt; 5;</span>
<span class="line-removed">407         }</span>
<span class="line-removed">408         else if ((r = java.util.concurrent.ThreadLocalRandom.current().nextInt()) == 0)</span>
<span class="line-removed">409             r = 1; // avoid zero</span>
<span class="line-removed">410         U.putInt(t, SECONDARY, r);</span>
<span class="line-removed">411         return r;</span>
<span class="line-removed">412     }</span>
<span class="line-removed">413 </span>
414     /**
415      * Returns the thread id for the given thread.  We must access
416      * this directly rather than via method Thread.getId() because
417      * getId() has been known to be overridden in ways that do not
418      * preserve unique mappings.
419      */
420     static final long getThreadId(Thread thread) {
421         return U.getLong(thread, TID);
422     }
423 
424     // Hotspot implementation via intrinsics API
425     private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">426     private static final long PARKBLOCKER = U.objectFieldOffset</span>
<span class="line-modified">427             (Thread.class, &quot;parkBlocker&quot;);</span>
<span class="line-modified">428     private static final long SECONDARY = U.objectFieldOffset</span>
<span class="line-modified">429             (Thread.class, &quot;threadLocalRandomSecondarySeed&quot;);</span>
<span class="line-removed">430     private static final long TID = U.objectFieldOffset</span>
<span class="line-removed">431             (Thread.class, &quot;tid&quot;);</span>
432 
433 }
</pre>
</td>
<td>
<hr />
<pre>
123  *       Thread.currentThread().interrupt();
124  *   }
125  *
126  *   public void unlock() {
127  *     locked.set(false);
128  *     LockSupport.unpark(waiters.peek());
129  *   }
130  *
131  *   static {
132  *     // Reduce the risk of &quot;lost unpark&quot; due to classloading
133  *     Class&lt;?&gt; ensureLoaded = LockSupport.class;
134  *   }
135  * }}&lt;/pre&gt;
136  *
137  * @since 1.5
138  */
139 public class LockSupport {
140     private LockSupport() {} // Cannot be instantiated.
141 
142     private static void setBlocker(Thread t, Object arg) {
<span class="line-modified">143         U.putReferenceOpaque(t, PARKBLOCKER, arg);</span>
<span class="line-modified">144     }</span>
<span class="line-added">145 </span>
<span class="line-added">146     /**</span>
<span class="line-added">147      * Sets the object to be returned by invocations of {@link</span>
<span class="line-added">148      * #getBlocker getBlocker} for the current thread. This method may</span>
<span class="line-added">149      * be used before invoking the no-argument version of {@link</span>
<span class="line-added">150      * LockSupport#park() park()} from non-public objects, allowing</span>
<span class="line-added">151      * more helpful diagnostics, or retaining compatibility with</span>
<span class="line-added">152      * previous implementations of blocking methods.  Previous values</span>
<span class="line-added">153      * of the blocker are not automatically restored after blocking.</span>
<span class="line-added">154      * To obtain the effects of {@code park(b}}, use {@code</span>
<span class="line-added">155      * setCurrentBlocker(b); park(); setCurrentBlocker(null);}</span>
<span class="line-added">156      *</span>
<span class="line-added">157      * @param blocker the blocker object</span>
<span class="line-added">158      * @since 14</span>
<span class="line-added">159      */</span>
<span class="line-added">160     public static void setCurrentBlocker(Object blocker) {</span>
<span class="line-added">161         U.putReferenceOpaque(Thread.currentThread(), PARKBLOCKER, blocker);</span>
162     }
163 
164     /**
165      * Makes available the permit for the given thread, if it
166      * was not already available.  If the thread was blocked on
167      * {@code park} then it will unblock.  Otherwise, its next call
168      * to {@code park} is guaranteed not to block. This operation
169      * is not guaranteed to have any effect at all if the given
170      * thread has not been started.
171      *
172      * @param thread the thread to unpark, or {@code null}, in which case
173      *        this operation has no effect
174      */
175     public static void unpark(Thread thread) {
176         if (thread != null)
177             U.unpark(thread);
178     }
179 
180     /**
181      * Disables the current thread for thread scheduling purposes unless the
</pre>
<hr />
<pre>
292         setBlocker(t, blocker);
293         U.park(true, deadline);
294         setBlocker(t, null);
295     }
296 
297     /**
298      * Returns the blocker object supplied to the most recent
299      * invocation of a park method that has not yet unblocked, or null
300      * if not blocked.  The value returned is just a momentary
301      * snapshot -- the thread may have since unblocked or blocked on a
302      * different blocker object.
303      *
304      * @param t the thread
305      * @return the blocker
306      * @throws NullPointerException if argument is null
307      * @since 1.6
308      */
309     public static Object getBlocker(Thread t) {
310         if (t == null)
311             throw new NullPointerException();
<span class="line-modified">312         return U.getReferenceOpaque(t, PARKBLOCKER);</span>
313     }
314 
315     /**
316      * Disables the current thread for thread scheduling purposes unless the
317      * permit is available.
318      *
319      * &lt;p&gt;If the permit is available then it is consumed and the call
320      * returns immediately; otherwise the current thread becomes disabled
321      * for thread scheduling purposes and lies dormant until one of three
322      * things happens:
323      *
324      * &lt;ul&gt;
325      *
326      * &lt;li&gt;Some other thread invokes {@link #unpark unpark} with the
327      * current thread as the target; or
328      *
329      * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
330      * the current thread; or
331      *
332      * &lt;li&gt;The call spuriously (that is, for no reason) returns.
</pre>
<hr />
<pre>
393      * the current thread; or
394      *
395      * &lt;li&gt;The specified deadline passes; or
396      *
397      * &lt;li&gt;The call spuriously (that is, for no reason) returns.
398      * &lt;/ul&gt;
399      *
400      * &lt;p&gt;This method does &lt;em&gt;not&lt;/em&gt; report which of these caused the
401      * method to return. Callers should re-check the conditions which caused
402      * the thread to park in the first place. Callers may also determine,
403      * for example, the interrupt status of the thread, or the current time
404      * upon return.
405      *
406      * @param deadline the absolute time, in milliseconds from the Epoch,
407      *        to wait until
408      */
409     public static void parkUntil(long deadline) {
410         U.park(true, deadline);
411     }
412 


















413     /**
414      * Returns the thread id for the given thread.  We must access
415      * this directly rather than via method Thread.getId() because
416      * getId() has been known to be overridden in ways that do not
417      * preserve unique mappings.
418      */
419     static final long getThreadId(Thread thread) {
420         return U.getLong(thread, TID);
421     }
422 
423     // Hotspot implementation via intrinsics API
424     private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">425     private static final long PARKBLOCKER</span>
<span class="line-modified">426         = U.objectFieldOffset(Thread.class, &quot;parkBlocker&quot;);</span>
<span class="line-modified">427     private static final long TID</span>
<span class="line-modified">428         = U.objectFieldOffset(Thread.class, &quot;tid&quot;);</span>


429 
430 }
</pre>
</td>
</tr>
</table>
<center><a href="Lock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantLock.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
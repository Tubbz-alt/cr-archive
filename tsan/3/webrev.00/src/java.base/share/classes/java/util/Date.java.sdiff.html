<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Date.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Currency.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Dictionary.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Date.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 137                                 CalendarSystem.getGregorianCalendar();
 138     private static BaseCalendar jcal;
 139 
 140     private transient long fastTime;
 141 
 142     /*
 143      * If cdate is null, then fastTime indicates the time in millis.
 144      * If cdate.isNormalized() is true, then fastTime and cdate are in
 145      * synch. Otherwise, fastTime is ignored, and cdate indicates the
 146      * time.
 147      */
 148     private transient BaseCalendar.Date cdate;
 149 
 150     // Initialized just before the value is used. See parse().
 151     private static int defaultCenturyStart;
 152 
 153     /* use serialVersionUID from modified java.util.Date for
 154      * interoperability with JDK1.1. The Date was modified to write
 155      * and read only the UTC time.
 156      */

 157     private static final long serialVersionUID = 7523967970034938905L;
 158 
 159     /**
 160      * Allocates a {@code Date} object and initializes it so that
 161      * it represents the time at which it was allocated, measured to the
 162      * nearest millisecond.
 163      *
 164      * @see     java.lang.System#currentTimeMillis()
 165      */
 166     public Date() {
 167         this(System.currentTimeMillis());
 168     }
 169 
 170     /**
 171      * Allocates a {@code Date} object and initializes it to
 172      * represent the specified number of milliseconds since the
 173      * standard base time known as &quot;the epoch&quot;, namely January 1,
 174      * 1970, 00:00:00 GMT.
 175      *
 176      * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.
</pre>
<hr />
<pre>
 892 
 893     /**
 894      * Sets this {@code Date} object to represent a point in time that is
 895      * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.
 896      *
 897      * @param   time   the number of milliseconds.
 898      */
 899     public void setTime(long time) {
 900         fastTime = time;
 901         cdate = null;
 902     }
 903 
 904     /**
 905      * Tests if this date is before the specified date.
 906      *
 907      * @param   when   a date.
 908      * @return  {@code true} if and only if the instant of time
 909      *            represented by this {@code Date} object is strictly
 910      *            earlier than the instant represented by {@code when};
 911      *          {@code false} otherwise.
<span class="line-modified"> 912      * @exception NullPointerException if {@code when} is null.</span>
 913      */
 914     public boolean before(Date when) {
 915         return getMillisOf(this) &lt; getMillisOf(when);
 916     }
 917 
 918     /**
 919      * Tests if this date is after the specified date.
 920      *
 921      * @param   when   a date.
 922      * @return  {@code true} if and only if the instant represented
 923      *          by this {@code Date} object is strictly later than the
 924      *          instant represented by {@code when};
 925      *          {@code false} otherwise.
<span class="line-modified"> 926      * @exception NullPointerException if {@code when} is null.</span>
 927      */
 928     public boolean after(Date when) {
 929         return getMillisOf(this) &gt; getMillisOf(when);
 930     }
 931 
 932     /**
 933      * Compares two dates for equality.
 934      * The result is {@code true} if and only if the argument is
 935      * not {@code null} and is a {@code Date} object that
 936      * represents the same point in time, to the millisecond, as this object.
 937      * &lt;p&gt;
 938      * Thus, two {@code Date} objects are equal if and only if the
 939      * {@code getTime} method returns the same {@code long}
 940      * value for both.
 941      *
 942      * @param   obj   the object to compare with.
 943      * @return  {@code true} if the objects are the same;
 944      *          {@code false} otherwise.
 945      * @see     java.util.Date#getTime()
 946      */
</pre>
<hr />
<pre>
 955     static final long getMillisOf(Date date) {
 956         if (date.getClass() != Date.class) {
 957             return date.getTime();
 958         }
 959         if (date.cdate == null || date.cdate.isNormalized()) {
 960             return date.fastTime;
 961         }
 962         BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();
 963         return gcal.getTime(d);
 964     }
 965 
 966     /**
 967      * Compares two Dates for ordering.
 968      *
 969      * @param   anotherDate   the {@code Date} to be compared.
 970      * @return  the value {@code 0} if the argument Date is equal to
 971      *          this Date; a value less than {@code 0} if this Date
 972      *          is before the Date argument; and a value greater than
 973      *      {@code 0} if this Date is after the Date argument.
 974      * @since   1.2
<span class="line-modified"> 975      * @exception NullPointerException if {@code anotherDate} is null.</span>
 976      */
 977     public int compareTo(Date anotherDate) {
 978         long thisTime = getMillisOf(this);
 979         long anotherTime = getMillisOf(anotherDate);
 980         return (thisTime&lt;anotherTime ? -1 : (thisTime==anotherTime ? 0 : 1));
 981     }
 982 
 983     /**
 984      * Returns a hash code value for this object. The result is the
 985      * exclusive OR of the two halves of the primitive {@code long}
 986      * value returned by the {@link Date#getTime}
 987      * method. That is, the hash code is the value of the expression:
 988      * &lt;blockquote&gt;&lt;pre&gt;{@code
 989      * (int)(this.getTime()^(this.getTime() &gt;&gt;&gt; 32))
 990      * }&lt;/pre&gt;&lt;/blockquote&gt;
 991      *
 992      * @return  a hash code value for this object.
 993      */
 994     public int hashCode() {
 995         long ht = this.getTime();
</pre>
<hr />
<pre>
1301         if (cdate.getEra() != null) {
1302             return jcal;
1303         }
1304         return gcal;
1305     }
1306 
1307     private static final synchronized BaseCalendar getJulianCalendar() {
1308         if (jcal == null) {
1309             jcal = (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);
1310         }
1311         return jcal;
1312     }
1313 
1314     /**
1315      * Save the state of this object to a stream (i.e., serialize it).
1316      *
1317      * @serialData The value returned by {@code getTime()}
1318      *             is emitted (long).  This represents the offset from
1319      *             January 1, 1970, 00:00:00 GMT in milliseconds.
1320      */

1321     private void writeObject(ObjectOutputStream s)
1322          throws IOException
1323     {
1324         s.defaultWriteObject();
1325         s.writeLong(getTimeImpl());
1326     }
1327 
1328     /**
1329      * Reconstitute this object from a stream (i.e., deserialize it).
1330      */

1331     private void readObject(ObjectInputStream s)
1332          throws IOException, ClassNotFoundException
1333     {
1334         s.defaultReadObject();
1335         fastTime = s.readLong();
1336     }
1337 
1338     /**
1339      * Obtains an instance of {@code Date} from an {@code Instant} object.
1340      * &lt;p&gt;
1341      * {@code Instant} uses a precision of nanoseconds, whereas {@code Date}
1342      * uses a precision of milliseconds.  The conversion will truncate any
1343      * excess precision information as though the amount in nanoseconds was
1344      * subject to integer division by one million.
1345      * &lt;p&gt;
1346      * {@code Instant} can store points on the time-line further in the future
1347      * and further in the past than {@code Date}. In this scenario, this method
1348      * will throw an exception.
1349      *
1350      * @param instant  the instant to convert
1351      * @return a {@code Date} representing the same point on the time-line as
1352      *  the provided instant
<span class="line-modified">1353      * @exception NullPointerException if {@code instant} is null.</span>
<span class="line-modified">1354      * @exception IllegalArgumentException if the instant is too large to</span>
1355      *  represent as a {@code Date}
1356      * @since 1.8
1357      */
1358     public static Date from(Instant instant) {
1359         try {
1360             return new Date(instant.toEpochMilli());
1361         } catch (ArithmeticException ex) {
1362             throw new IllegalArgumentException(ex);
1363         }
1364     }
1365 
1366     /**
1367      * Converts this {@code Date} object to an {@code Instant}.
1368      * &lt;p&gt;
1369      * The conversion creates an {@code Instant} that represents the same
1370      * point on the time-line as this {@code Date}.
1371      *
1372      * @return an instant representing the same point on the time-line as
1373      *  this {@code Date} object
1374      * @since 1.8
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 137                                 CalendarSystem.getGregorianCalendar();
 138     private static BaseCalendar jcal;
 139 
 140     private transient long fastTime;
 141 
 142     /*
 143      * If cdate is null, then fastTime indicates the time in millis.
 144      * If cdate.isNormalized() is true, then fastTime and cdate are in
 145      * synch. Otherwise, fastTime is ignored, and cdate indicates the
 146      * time.
 147      */
 148     private transient BaseCalendar.Date cdate;
 149 
 150     // Initialized just before the value is used. See parse().
 151     private static int defaultCenturyStart;
 152 
 153     /* use serialVersionUID from modified java.util.Date for
 154      * interoperability with JDK1.1. The Date was modified to write
 155      * and read only the UTC time.
 156      */
<span class="line-added"> 157     @java.io.Serial</span>
 158     private static final long serialVersionUID = 7523967970034938905L;
 159 
 160     /**
 161      * Allocates a {@code Date} object and initializes it so that
 162      * it represents the time at which it was allocated, measured to the
 163      * nearest millisecond.
 164      *
 165      * @see     java.lang.System#currentTimeMillis()
 166      */
 167     public Date() {
 168         this(System.currentTimeMillis());
 169     }
 170 
 171     /**
 172      * Allocates a {@code Date} object and initializes it to
 173      * represent the specified number of milliseconds since the
 174      * standard base time known as &quot;the epoch&quot;, namely January 1,
 175      * 1970, 00:00:00 GMT.
 176      *
 177      * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.
</pre>
<hr />
<pre>
 893 
 894     /**
 895      * Sets this {@code Date} object to represent a point in time that is
 896      * {@code time} milliseconds after January 1, 1970 00:00:00 GMT.
 897      *
 898      * @param   time   the number of milliseconds.
 899      */
 900     public void setTime(long time) {
 901         fastTime = time;
 902         cdate = null;
 903     }
 904 
 905     /**
 906      * Tests if this date is before the specified date.
 907      *
 908      * @param   when   a date.
 909      * @return  {@code true} if and only if the instant of time
 910      *            represented by this {@code Date} object is strictly
 911      *            earlier than the instant represented by {@code when};
 912      *          {@code false} otherwise.
<span class="line-modified"> 913      * @throws    NullPointerException if {@code when} is null.</span>
 914      */
 915     public boolean before(Date when) {
 916         return getMillisOf(this) &lt; getMillisOf(when);
 917     }
 918 
 919     /**
 920      * Tests if this date is after the specified date.
 921      *
 922      * @param   when   a date.
 923      * @return  {@code true} if and only if the instant represented
 924      *          by this {@code Date} object is strictly later than the
 925      *          instant represented by {@code when};
 926      *          {@code false} otherwise.
<span class="line-modified"> 927      * @throws    NullPointerException if {@code when} is null.</span>
 928      */
 929     public boolean after(Date when) {
 930         return getMillisOf(this) &gt; getMillisOf(when);
 931     }
 932 
 933     /**
 934      * Compares two dates for equality.
 935      * The result is {@code true} if and only if the argument is
 936      * not {@code null} and is a {@code Date} object that
 937      * represents the same point in time, to the millisecond, as this object.
 938      * &lt;p&gt;
 939      * Thus, two {@code Date} objects are equal if and only if the
 940      * {@code getTime} method returns the same {@code long}
 941      * value for both.
 942      *
 943      * @param   obj   the object to compare with.
 944      * @return  {@code true} if the objects are the same;
 945      *          {@code false} otherwise.
 946      * @see     java.util.Date#getTime()
 947      */
</pre>
<hr />
<pre>
 956     static final long getMillisOf(Date date) {
 957         if (date.getClass() != Date.class) {
 958             return date.getTime();
 959         }
 960         if (date.cdate == null || date.cdate.isNormalized()) {
 961             return date.fastTime;
 962         }
 963         BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();
 964         return gcal.getTime(d);
 965     }
 966 
 967     /**
 968      * Compares two Dates for ordering.
 969      *
 970      * @param   anotherDate   the {@code Date} to be compared.
 971      * @return  the value {@code 0} if the argument Date is equal to
 972      *          this Date; a value less than {@code 0} if this Date
 973      *          is before the Date argument; and a value greater than
 974      *      {@code 0} if this Date is after the Date argument.
 975      * @since   1.2
<span class="line-modified"> 976      * @throws    NullPointerException if {@code anotherDate} is null.</span>
 977      */
 978     public int compareTo(Date anotherDate) {
 979         long thisTime = getMillisOf(this);
 980         long anotherTime = getMillisOf(anotherDate);
 981         return (thisTime&lt;anotherTime ? -1 : (thisTime==anotherTime ? 0 : 1));
 982     }
 983 
 984     /**
 985      * Returns a hash code value for this object. The result is the
 986      * exclusive OR of the two halves of the primitive {@code long}
 987      * value returned by the {@link Date#getTime}
 988      * method. That is, the hash code is the value of the expression:
 989      * &lt;blockquote&gt;&lt;pre&gt;{@code
 990      * (int)(this.getTime()^(this.getTime() &gt;&gt;&gt; 32))
 991      * }&lt;/pre&gt;&lt;/blockquote&gt;
 992      *
 993      * @return  a hash code value for this object.
 994      */
 995     public int hashCode() {
 996         long ht = this.getTime();
</pre>
<hr />
<pre>
1302         if (cdate.getEra() != null) {
1303             return jcal;
1304         }
1305         return gcal;
1306     }
1307 
1308     private static final synchronized BaseCalendar getJulianCalendar() {
1309         if (jcal == null) {
1310             jcal = (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);
1311         }
1312         return jcal;
1313     }
1314 
1315     /**
1316      * Save the state of this object to a stream (i.e., serialize it).
1317      *
1318      * @serialData The value returned by {@code getTime()}
1319      *             is emitted (long).  This represents the offset from
1320      *             January 1, 1970, 00:00:00 GMT in milliseconds.
1321      */
<span class="line-added">1322     @java.io.Serial</span>
1323     private void writeObject(ObjectOutputStream s)
1324          throws IOException
1325     {
1326         s.defaultWriteObject();
1327         s.writeLong(getTimeImpl());
1328     }
1329 
1330     /**
1331      * Reconstitute this object from a stream (i.e., deserialize it).
1332      */
<span class="line-added">1333     @java.io.Serial</span>
1334     private void readObject(ObjectInputStream s)
1335          throws IOException, ClassNotFoundException
1336     {
1337         s.defaultReadObject();
1338         fastTime = s.readLong();
1339     }
1340 
1341     /**
1342      * Obtains an instance of {@code Date} from an {@code Instant} object.
1343      * &lt;p&gt;
1344      * {@code Instant} uses a precision of nanoseconds, whereas {@code Date}
1345      * uses a precision of milliseconds.  The conversion will truncate any
1346      * excess precision information as though the amount in nanoseconds was
1347      * subject to integer division by one million.
1348      * &lt;p&gt;
1349      * {@code Instant} can store points on the time-line further in the future
1350      * and further in the past than {@code Date}. In this scenario, this method
1351      * will throw an exception.
1352      *
1353      * @param instant  the instant to convert
1354      * @return a {@code Date} representing the same point on the time-line as
1355      *  the provided instant
<span class="line-modified">1356      * @throws    NullPointerException if {@code instant} is null.</span>
<span class="line-modified">1357      * @throws    IllegalArgumentException if the instant is too large to</span>
1358      *  represent as a {@code Date}
1359      * @since 1.8
1360      */
1361     public static Date from(Instant instant) {
1362         try {
1363             return new Date(instant.toEpochMilli());
1364         } catch (ArithmeticException ex) {
1365             throw new IllegalArgumentException(ex);
1366         }
1367     }
1368 
1369     /**
1370      * Converts this {@code Date} object to an {@code Instant}.
1371      * &lt;p&gt;
1372      * The conversion creates an {@code Instant} that represents the same
1373      * point on the time-line as this {@code Date}.
1374      *
1375      * @return an instant representing the same point on the time-line as
1376      *  this {@code Date} object
1377      * @since 1.8
</pre>
</td>
</tr>
</table>
<center><a href="Currency.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Dictionary.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
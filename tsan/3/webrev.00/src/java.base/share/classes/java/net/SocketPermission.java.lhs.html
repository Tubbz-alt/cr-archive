<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/SocketPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.ObjectStreamField;
  32 import java.io.Serializable;
  33 import java.net.InetAddress;
  34 import java.security.AccessController;
  35 import java.security.Permission;
  36 import java.security.PermissionCollection;
  37 import java.security.PrivilegedAction;
  38 import java.security.Security;
  39 import java.util.Collections;
  40 import java.util.Comparator;
  41 import java.util.Enumeration;
  42 import java.util.Vector;
  43 import java.util.StringJoiner;
  44 import java.util.StringTokenizer;
  45 import java.util.concurrent.ConcurrentSkipListMap;
  46 import sun.net.util.IPAddressUtil;
  47 import sun.net.PortConfig;
  48 import sun.security.util.RegisteredDomain;
  49 import sun.security.util.SecurityConstants;
  50 import sun.security.util.Debug;
  51 
  52 
  53 /**
  54  * This class represents access to a network via sockets.
  55  * A SocketPermission consists of a
  56  * host specification and a set of &quot;actions&quot; specifying ways to
  57  * connect to that host. The host is specified as
  58  * &lt;pre&gt;
  59  *    host = (hostname | IPv4address | iPv6reference) [:portrange]
  60  *    portrange = portnumber | -portnumber | portnumber-[portnumber]
  61  * &lt;/pre&gt;
  62  * The host is expressed as a DNS name, as a numerical IP address,
  63  * or as &quot;localhost&quot; (for the local machine).
  64  * The wildcard &quot;*&quot; may be included once in a DNS name host
  65  * specification. If it is included, it must be in the leftmost
  66  * position, as in &quot;*.example.com&quot;.
  67  * &lt;p&gt;
  68  * The format of the IPv6reference should follow that specified in &lt;a
  69  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format
  70  * for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;:
  71  * &lt;pre&gt;
  72  *    ipv6reference = &quot;[&quot; IPv6address &quot;]&quot;
  73  *&lt;/pre&gt;
  74  * For example, you can construct a SocketPermission instance
  75  * as the following:
  76  * &lt;pre&gt;
  77  *    String hostAddress = inetaddress.getHostAddress();
  78  *    if (inetaddress instanceof Inet6Address) {
  79  *        sp = new SocketPermission(&quot;[&quot; + hostAddress + &quot;]:&quot; + port, action);
  80  *    } else {
  81  *        sp = new SocketPermission(hostAddress + &quot;:&quot; + port, action);
  82  *    }
  83  * &lt;/pre&gt;
  84  * or
  85  * &lt;pre&gt;
  86  *    String host = url.getHost();
  87  *    sp = new SocketPermission(host + &quot;:&quot; + port, action);
  88  * &lt;/pre&gt;
  89  * &lt;p&gt;
  90  * The &lt;A HREF=&quot;Inet6Address.html#lform&quot;&gt;full uncompressed form&lt;/A&gt; of
  91  * an IPv6 literal address is also valid.
  92  * &lt;p&gt;
  93  * The port or portrange is optional. A port specification of the
  94  * form &quot;N-&quot;, where &lt;i&gt;N&lt;/i&gt; is a port number, signifies all ports
  95  * numbered &lt;i&gt;N&lt;/i&gt; and above, while a specification of the
  96  * form &quot;-N&quot; indicates all ports numbered &lt;i&gt;N&lt;/i&gt; and below.
  97  * The special port value {@code 0} refers to the entire &lt;i&gt;ephemeral&lt;/i&gt;
  98  * port range. This is a fixed range of ports a system may use to
  99  * allocate dynamic ports from. The actual range may be system dependent.
 100  * &lt;p&gt;
 101  * The possible ways to connect to the host are
 102  * &lt;pre&gt;
 103  * accept
 104  * connect
 105  * listen
 106  * resolve
 107  * &lt;/pre&gt;
 108  * The &quot;listen&quot; action is only meaningful when used with &quot;localhost&quot; and
 109  * means the ability to bind to a specified port.
 110  * The &quot;resolve&quot; action is implied when any of the other actions are present.
 111  * The action &quot;resolve&quot; refers to host/ip name service lookups.
 112  * &lt;P&gt;
 113  * The actions string is converted to lowercase before processing.
 114  * &lt;p&gt;As an example of the creation and meaning of SocketPermissions,
 115  * note that if the following permission:
 116  *
 117  * &lt;pre&gt;
 118  *   p1 = new SocketPermission(&quot;foo.example.com:7777&quot;, &quot;connect,accept&quot;);
 119  * &lt;/pre&gt;
 120  *
 121  * is granted to some code, it allows that code to connect to port 7777 on
 122  * {@code foo.example.com}, and to accept connections on that port.
 123  *
 124  * &lt;p&gt;Similarly, if the following permission:
 125  *
 126  * &lt;pre&gt;
 127  *   p2 = new SocketPermission(&quot;localhost:1024-&quot;, &quot;accept,connect,listen&quot;);
 128  * &lt;/pre&gt;
 129  *
 130  * is granted to some code, it allows that code to
 131  * accept connections on, connect to, or listen on any port between
 132  * 1024 and 65535 on the local host.
 133  *
 134  * &lt;p&gt;Note: Granting code permission to accept or make connections to remote
 135  * hosts may be dangerous because malevolent code can then more easily
 136  * transfer and share confidential data among parties who may not
 137  * otherwise have access to the data.
 138  *
 139  * @see java.security.Permissions
 140  * @see SocketPermission
 141  *
 142  *
 143  * @author Marianne Mueller
 144  * @author Roland Schemers
 145  * @since 1.2
 146  *
 147  * @serial exclude
 148  */
 149 
 150 public final class SocketPermission extends Permission
 151     implements java.io.Serializable
 152 {
<a name="2" id="anc2"></a>
 153     private static final long serialVersionUID = -7204263841984476862L;
 154 
 155     /**
 156      * Connect to host:port
 157      */
 158     private static final int CONNECT    = 0x1;
 159 
 160     /**
 161      * Listen on host:port
 162      */
 163     private static final int LISTEN     = 0x2;
 164 
 165     /**
 166      * Accept a connection from host:port
 167      */
 168     private static final int ACCEPT     = 0x4;
 169 
 170     /**
 171      * Resolve DNS queries
 172      */
 173     private static final int RESOLVE    = 0x8;
 174 
 175     /**
 176      * No actions
 177      */
 178     private static final int NONE               = 0x0;
 179 
 180     /**
 181      * All actions
 182      */
 183     private static final int ALL        = CONNECT|LISTEN|ACCEPT|RESOLVE;
 184 
 185     // various port constants
 186     private static final int PORT_MIN = 0;
 187     private static final int PORT_MAX = 65535;
 188     private static final int PRIV_PORT_MAX = 1023;
 189     private static final int DEF_EPH_LOW = 49152;
 190 
 191     // the actions mask
 192     private transient int mask;
 193 
 194     /**
 195      * the actions string.
 196      *
 197      * @serial
 198      */
 199 
 200     private String actions; // Left null as long as possible, then
 201                             // created and re-used in the getAction function.
 202 
 203     // hostname part as it is passed
 204     private transient String hostname;
 205 
 206     // the canonical name of the host
 207     // in the case of &quot;*.foo.com&quot;, cname is &quot;.foo.com&quot;.
 208 
 209     private transient String cname;
 210 
 211     // all the IP addresses of the host
 212     private transient InetAddress[] addresses;
 213 
 214     // true if the hostname is a wildcard (e.g. &quot;*.example.com&quot;)
 215     private transient boolean wildcard;
 216 
 217     // true if we were initialized with a single numeric IP address
 218     private transient boolean init_with_ip;
 219 
 220     // true if this SocketPermission represents an invalid/unknown host
 221     // used for implies when the delayed lookup has already failed
 222     private transient boolean invalid;
 223 
 224     // port range on host
 225     private transient int[] portrange;
 226 
 227     private transient boolean defaultDeny = false;
 228 
 229     // true if this SocketPermission represents a hostname
 230     // that failed our reverse mapping heuristic test
 231     private transient boolean untrusted;
 232     private transient boolean trusted;
 233 
 234     // true if the sun.net.trustNameService system property is set
 235     private static boolean trustNameService;
 236 
 237     private static Debug debug = null;
 238     private static boolean debugInit = false;
 239 
 240     // lazy initializer
 241     private static class EphemeralRange {
 242         static final int low = initEphemeralPorts(&quot;low&quot;, DEF_EPH_LOW);
 243             static final int high = initEphemeralPorts(&quot;high&quot;, PORT_MAX);
 244     };
 245 
 246     static {
 247         Boolean tmp = java.security.AccessController.doPrivileged(
 248                 new sun.security.action.GetBooleanAction(&quot;sun.net.trustNameService&quot;));
 249         trustNameService = tmp.booleanValue();
 250     }
 251 
 252     private static synchronized Debug getDebug() {
 253         if (!debugInit) {
 254             debug = Debug.getInstance(&quot;access&quot;);
 255             debugInit = true;
 256         }
 257         return debug;
 258     }
 259 
 260     /**
 261      * Creates a new SocketPermission object with the specified actions.
 262      * The host is expressed as a DNS name, or as a numerical IP address.
 263      * Optionally, a port or a portrange may be supplied (separated
 264      * from the DNS name or IP address by a colon).
 265      * &lt;p&gt;
 266      * To specify the local machine, use &quot;localhost&quot; as the &lt;i&gt;host&lt;/i&gt;.
 267      * Also note: An empty &lt;i&gt;host&lt;/i&gt; String (&quot;&quot;) is equivalent to &quot;localhost&quot;.
 268      * &lt;p&gt;
 269      * The &lt;i&gt;actions&lt;/i&gt; parameter contains a comma-separated list of the
 270      * actions granted for the specified host (and port(s)). Possible actions are
 271      * &quot;connect&quot;, &quot;listen&quot;, &quot;accept&quot;, &quot;resolve&quot;, or
 272      * any combination of those. &quot;resolve&quot; is automatically added
 273      * when any of the other three are specified.
 274      * &lt;p&gt;
 275      * Examples of SocketPermission instantiation are the following:
 276      * &lt;pre&gt;
 277      *    nr = new SocketPermission(&quot;www.example.com&quot;, &quot;connect&quot;);
 278      *    nr = new SocketPermission(&quot;www.example.com:80&quot;, &quot;connect&quot;);
 279      *    nr = new SocketPermission(&quot;*.example.com&quot;, &quot;connect&quot;);
 280      *    nr = new SocketPermission(&quot;*.edu&quot;, &quot;resolve&quot;);
 281      *    nr = new SocketPermission(&quot;204.160.241.0&quot;, &quot;connect&quot;);
 282      *    nr = new SocketPermission(&quot;localhost:1024-65535&quot;, &quot;listen&quot;);
 283      *    nr = new SocketPermission(&quot;204.160.241.0:1024-65535&quot;, &quot;connect&quot;);
 284      * &lt;/pre&gt;
 285      *
 286      * @param host the hostname or IP address of the computer, optionally
 287      * including a colon followed by a port or port range.
 288      * @param action the action string.
<a name="3" id="anc3"></a>




 289      */
 290     public SocketPermission(String host, String action) {
 291         super(getHost(host));
 292         // name initialized to getHost(host); NPE detected in getHost()
 293         init(getName(), getMask(action));
 294     }
 295 
 296 
 297     SocketPermission(String host, int mask) {
 298         super(getHost(host));
 299         // name initialized to getHost(host); NPE detected in getHost()
 300         init(getName(), mask);
 301     }
 302 
 303     private void setDeny() {
 304         defaultDeny = true;
 305     }
 306 
 307     private static String getHost(String host) {
 308         if (host.isEmpty()) {
 309             return &quot;localhost&quot;;
 310         } else {
 311             /* IPv6 literal address used in this context should follow
 312              * the format specified in RFC 2732;
 313              * if not, we try to solve the unambiguous case
 314              */
 315             int ind;
 316             if (host.charAt(0) != &#39;[&#39;) {
 317                 if ((ind = host.indexOf(&#39;:&#39;)) != host.lastIndexOf(&#39;:&#39;)) {
 318                     /* More than one &quot;:&quot;, meaning IPv6 address is not
 319                      * in RFC 2732 format;
 320                      * We will rectify user errors for all unambiguous cases
 321                      */
 322                     StringTokenizer st = new StringTokenizer(host, &quot;:&quot;);
 323                     int tokens = st.countTokens();
 324                     if (tokens == 9) {
 325                         // IPv6 address followed by port
 326                         ind = host.lastIndexOf(&#39;:&#39;);
 327                         host = &quot;[&quot; + host.substring(0, ind) + &quot;]&quot; +
 328                             host.substring(ind);
 329                     } else if (tokens == 8 &amp;&amp; host.indexOf(&quot;::&quot;) == -1) {
 330                         // IPv6 address only, not followed by port
 331                         host = &quot;[&quot; + host + &quot;]&quot;;
 332                     } else {
 333                         // could be ambiguous
 334                         throw new IllegalArgumentException(&quot;Ambiguous&quot;+
 335                                                            &quot; hostport part&quot;);
 336                     }
 337                 }
 338             }
 339             return host;
 340         }
 341     }
 342 
 343     private int[] parsePort(String port)
 344         throws Exception
 345     {
 346 
 347         if (port == null || port.isEmpty() || port.equals(&quot;*&quot;)) {
 348             return new int[] {PORT_MIN, PORT_MAX};
 349         }
 350 
 351         int dash = port.indexOf(&#39;-&#39;);
 352 
 353         if (dash == -1) {
 354             int p = Integer.parseInt(port);
 355             return new int[] {p, p};
 356         } else {
 357             String low = port.substring(0, dash);
 358             String high = port.substring(dash+1);
 359             int l,h;
 360 
 361             if (low.isEmpty()) {
 362                 l = PORT_MIN;
 363             } else {
 364                 l = Integer.parseInt(low);
 365             }
 366 
 367             if (high.isEmpty()) {
 368                 h = PORT_MAX;
 369             } else {
 370                 h = Integer.parseInt(high);
 371             }
 372             if (l &lt; 0 || h &lt; 0 || h&lt;l)
 373                 throw new IllegalArgumentException(&quot;invalid port range&quot;);
 374 
 375             return new int[] {l, h};
 376         }
 377     }
 378 
 379     /**
 380      * Returns true if the permission has specified zero
 381      * as its value (or lower bound) signifying the ephemeral range
 382      */
 383     private boolean includesEphemerals() {
 384         return portrange[0] == 0;
 385     }
 386 
 387     /**
 388      * Initialize the SocketPermission object. We don&#39;t do any DNS lookups
 389      * as this point, instead we hold off until the implies method is
 390      * called.
 391      */
 392     private void init(String host, int mask) {
 393         // Set the integer mask that represents the actions
 394 
 395         if ((mask &amp; ALL) != mask)
 396             throw new IllegalArgumentException(&quot;invalid actions mask&quot;);
 397 
 398         // always OR in RESOLVE if we allow any of the others
 399         this.mask = mask | RESOLVE;
 400 
 401         // Parse the host name.  A name has up to three components, the
 402         // hostname, a port number, or two numbers representing a port
 403         // range.   &quot;www.example.com:8080-9090&quot; is a valid host name.
 404 
 405         // With IPv6 an address can be 2010:836B:4179::836B:4179
 406         // An IPv6 address needs to be enclose in []
 407         // For ex: [2010:836B:4179::836B:4179]:8080-9090
 408         // Refer to RFC 2732 for more information.
 409 
 410         int rb = 0 ;
 411         int start = 0, end = 0;
 412         int sep = -1;
 413         String hostport = host;
 414         if (host.charAt(0) == &#39;[&#39;) {
 415             start = 1;
 416             rb = host.indexOf(&#39;]&#39;);
 417             if (rb != -1) {
 418                 host = host.substring(start, rb);
 419             } else {
 420                 throw new
 421                     IllegalArgumentException(&quot;invalid host/port: &quot;+host);
 422             }
 423             sep = hostport.indexOf(&#39;:&#39;, rb+1);
 424         } else {
 425             start = 0;
 426             sep = host.indexOf(&#39;:&#39;, rb);
 427             end = sep;
 428             if (sep != -1) {
 429                 host = host.substring(start, end);
 430             }
 431         }
 432 
 433         if (sep != -1) {
 434             String port = hostport.substring(sep+1);
 435             try {
 436                 portrange = parsePort(port);
 437             } catch (Exception e) {
 438                 throw new
 439                     IllegalArgumentException(&quot;invalid port range: &quot;+port);
 440             }
 441         } else {
 442             portrange = new int[] { PORT_MIN, PORT_MAX };
 443         }
 444 
 445         hostname = host;
 446 
 447         // is this a domain wildcard specification
 448         if (host.lastIndexOf(&#39;*&#39;) &gt; 0) {
 449             throw new
 450                IllegalArgumentException(&quot;invalid host wildcard specification&quot;);
 451         } else if (host.startsWith(&quot;*&quot;)) {
 452             wildcard = true;
 453             if (host.equals(&quot;*&quot;)) {
 454                 cname = &quot;&quot;;
 455             } else if (host.startsWith(&quot;*.&quot;)) {
 456                 cname = host.substring(1).toLowerCase();
 457             } else {
 458               throw new
 459                IllegalArgumentException(&quot;invalid host wildcard specification&quot;);
 460             }
 461             return;
 462         } else {
 463             if (!host.isEmpty()) {
 464                 // see if we are being initialized with an IP address.
 465                 char ch = host.charAt(0);
 466                 if (ch == &#39;:&#39; || Character.digit(ch, 16) != -1) {
 467                     byte ip[] = IPAddressUtil.textToNumericFormatV4(host);
 468                     if (ip == null) {
 469                         ip = IPAddressUtil.textToNumericFormatV6(host);
 470                     }
 471                     if (ip != null) {
 472                         try {
 473                             addresses =
 474                                 new InetAddress[]
 475                                 {InetAddress.getByAddress(ip) };
 476                             init_with_ip = true;
 477                         } catch (UnknownHostException uhe) {
 478                             // this shouldn&#39;t happen
 479                             invalid = true;
 480                         }
 481                     }
 482                 }
 483             }
 484         }
 485     }
 486 
 487     /**
 488      * Convert an action string to an integer actions mask.
 489      *
 490      * @param action the action string
 491      * @return the action mask
 492      */
 493     private static int getMask(String action) {
 494 
 495         if (action == null) {
 496             throw new NullPointerException(&quot;action can&#39;t be null&quot;);
 497         }
 498 
 499         if (action.isEmpty()) {
 500             throw new IllegalArgumentException(&quot;action can&#39;t be empty&quot;);
 501         }
 502 
 503         int mask = NONE;
 504 
 505         // Use object identity comparison against known-interned strings for
 506         // performance benefit (these values are used heavily within the JDK).
 507         if (action == SecurityConstants.SOCKET_RESOLVE_ACTION) {
 508             return RESOLVE;
 509         } else if (action == SecurityConstants.SOCKET_CONNECT_ACTION) {
 510             return CONNECT;
 511         } else if (action == SecurityConstants.SOCKET_LISTEN_ACTION) {
 512             return LISTEN;
 513         } else if (action == SecurityConstants.SOCKET_ACCEPT_ACTION) {
 514             return ACCEPT;
 515         } else if (action == SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION) {
 516             return CONNECT|ACCEPT;
 517         }
 518 
 519         char[] a = action.toCharArray();
 520 
 521         int i = a.length - 1;
 522         if (i &lt; 0)
 523             return mask;
 524 
 525         while (i != -1) {
 526             char c;
 527 
 528             // skip whitespace
 529             while ((i!=-1) &amp;&amp; ((c = a[i]) == &#39; &#39; ||
 530                                c == &#39;\r&#39; ||
 531                                c == &#39;\n&#39; ||
 532                                c == &#39;\f&#39; ||
 533                                c == &#39;\t&#39;))
 534                 i--;
 535 
 536             // check for the known strings
 537             int matchlen;
 538 
 539             if (i &gt;= 6 &amp;&amp; (a[i-6] == &#39;c&#39; || a[i-6] == &#39;C&#39;) &amp;&amp;
 540                           (a[i-5] == &#39;o&#39; || a[i-5] == &#39;O&#39;) &amp;&amp;
 541                           (a[i-4] == &#39;n&#39; || a[i-4] == &#39;N&#39;) &amp;&amp;
 542                           (a[i-3] == &#39;n&#39; || a[i-3] == &#39;N&#39;) &amp;&amp;
 543                           (a[i-2] == &#39;e&#39; || a[i-2] == &#39;E&#39;) &amp;&amp;
 544                           (a[i-1] == &#39;c&#39; || a[i-1] == &#39;C&#39;) &amp;&amp;
 545                           (a[i] == &#39;t&#39; || a[i] == &#39;T&#39;))
 546             {
 547                 matchlen = 7;
 548                 mask |= CONNECT;
 549 
 550             } else if (i &gt;= 6 &amp;&amp; (a[i-6] == &#39;r&#39; || a[i-6] == &#39;R&#39;) &amp;&amp;
 551                                  (a[i-5] == &#39;e&#39; || a[i-5] == &#39;E&#39;) &amp;&amp;
 552                                  (a[i-4] == &#39;s&#39; || a[i-4] == &#39;S&#39;) &amp;&amp;
 553                                  (a[i-3] == &#39;o&#39; || a[i-3] == &#39;O&#39;) &amp;&amp;
 554                                  (a[i-2] == &#39;l&#39; || a[i-2] == &#39;L&#39;) &amp;&amp;
 555                                  (a[i-1] == &#39;v&#39; || a[i-1] == &#39;V&#39;) &amp;&amp;
 556                                  (a[i] == &#39;e&#39; || a[i] == &#39;E&#39;))
 557             {
 558                 matchlen = 7;
 559                 mask |= RESOLVE;
 560 
 561             } else if (i &gt;= 5 &amp;&amp; (a[i-5] == &#39;l&#39; || a[i-5] == &#39;L&#39;) &amp;&amp;
 562                                  (a[i-4] == &#39;i&#39; || a[i-4] == &#39;I&#39;) &amp;&amp;
 563                                  (a[i-3] == &#39;s&#39; || a[i-3] == &#39;S&#39;) &amp;&amp;
 564                                  (a[i-2] == &#39;t&#39; || a[i-2] == &#39;T&#39;) &amp;&amp;
 565                                  (a[i-1] == &#39;e&#39; || a[i-1] == &#39;E&#39;) &amp;&amp;
 566                                  (a[i] == &#39;n&#39; || a[i] == &#39;N&#39;))
 567             {
 568                 matchlen = 6;
 569                 mask |= LISTEN;
 570 
 571             } else if (i &gt;= 5 &amp;&amp; (a[i-5] == &#39;a&#39; || a[i-5] == &#39;A&#39;) &amp;&amp;
 572                                  (a[i-4] == &#39;c&#39; || a[i-4] == &#39;C&#39;) &amp;&amp;
 573                                  (a[i-3] == &#39;c&#39; || a[i-3] == &#39;C&#39;) &amp;&amp;
 574                                  (a[i-2] == &#39;e&#39; || a[i-2] == &#39;E&#39;) &amp;&amp;
 575                                  (a[i-1] == &#39;p&#39; || a[i-1] == &#39;P&#39;) &amp;&amp;
 576                                  (a[i] == &#39;t&#39; || a[i] == &#39;T&#39;))
 577             {
 578                 matchlen = 6;
 579                 mask |= ACCEPT;
 580 
 581             } else {
 582                 // parse error
 583                 throw new IllegalArgumentException(
 584                         &quot;invalid permission: &quot; + action);
 585             }
 586 
 587             // make sure we didn&#39;t just match the tail of a word
 588             // like &quot;ackbarfaccept&quot;.  Also, skip to the comma.
 589             boolean seencomma = false;
 590             while (i &gt;= matchlen &amp;&amp; !seencomma) {
<a name="4" id="anc4"></a><span class="line-modified"> 591                 switch(a[i-matchlen]) {</span>
<span class="line-removed"> 592                 case &#39;,&#39;:</span>
<span class="line-removed"> 593                     seencomma = true;</span>
<span class="line-removed"> 594                     break;</span>
 595                 case &#39; &#39;: case &#39;\r&#39;: case &#39;\n&#39;:
 596                 case &#39;\f&#39;: case &#39;\t&#39;:
 597                     break;
 598                 default:
<a name="5" id="anc5"></a>



 599                     throw new IllegalArgumentException(
 600                             &quot;invalid permission: &quot; + action);
 601                 }
 602                 i--;
 603             }
 604 
 605             // point i at the location of the comma minus one (or -1).
 606             i -= matchlen;
 607         }
 608 
 609         return mask;
 610     }
 611 
 612     private boolean isUntrusted()
 613         throws UnknownHostException
 614     {
 615         if (trusted) return false;
 616         if (invalid || untrusted) return true;
 617         try {
 618             if (!trustNameService &amp;&amp; (defaultDeny ||
 619                 sun.net.www.URLConnection.isProxiedHost(hostname))) {
 620                 if (this.cname == null) {
 621                     this.getCanonName();
 622                 }
 623                 if (!match(cname, hostname)) {
 624                     // Last chance
 625                     if (!authorized(hostname, addresses[0].getAddress())) {
 626                         untrusted = true;
 627                         Debug debug = getDebug();
 628                         if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {
 629                             debug.println(&quot;socket access restriction: proxied host &quot; + &quot;(&quot; + addresses[0] + &quot;)&quot; + &quot; does not match &quot; + cname + &quot; from reverse lookup&quot;);
 630                         }
 631                         return true;
 632                     }
 633                 }
 634                 trusted = true;
 635             }
 636         } catch (UnknownHostException uhe) {
 637             invalid = true;
 638             throw uhe;
 639         }
 640         return false;
 641     }
 642 
 643     /**
 644      * attempt to get the fully qualified domain name
 645      *
 646      */
 647     void getCanonName()
 648         throws UnknownHostException
 649     {
 650         if (cname != null || invalid || untrusted) return;
 651 
 652         // attempt to get the canonical name
 653 
 654         try {
 655             // first get the IP addresses if we don&#39;t have them yet
 656             // this is because we need the IP address to then get
 657             // FQDN.
 658             if (addresses == null) {
 659                 getIP();
 660             }
 661 
 662             // we have to do this check, otherwise we might not
 663             // get the fully qualified domain name
 664             if (init_with_ip) {
 665                 cname = addresses[0].getHostName(false).toLowerCase();
 666             } else {
 667              cname = InetAddress.getByName(addresses[0].getHostAddress()).
 668                                               getHostName(false).toLowerCase();
 669             }
 670         } catch (UnknownHostException uhe) {
 671             invalid = true;
 672             throw uhe;
 673         }
 674     }
 675 
 676     private transient String cdomain, hdomain;
 677 
 678     /**
 679      * previously we allowed domain names to be specified in IDN ACE form
 680      * Need to check for that and convert to Unicode
 681      */
 682     private static String checkForIDN(String name) {
 683         if (name.startsWith(&quot;xn--&quot;) || name.contains(&quot;.xn--&quot;)) {
 684             return IDN.toUnicode(name);
 685         } else {
 686             return name;
 687         }
 688     }
 689 
 690     private boolean match(String cname, String hname) {
 691         String a = checkForIDN(cname.toLowerCase());
 692         String b = checkForIDN(hname.toLowerCase());
 693         if (a.startsWith(b)  &amp;&amp;
 694             ((a.length() == b.length()) || (a.charAt(b.length()) == &#39;.&#39;))) {
 695             return true;
 696         }
 697         if (cdomain == null) {
 698             cdomain = RegisteredDomain.from(a)
 699                                       .map(RegisteredDomain::name)
 700                                       .orElse(a);
 701         }
 702         if (hdomain == null) {
 703             hdomain = RegisteredDomain.from(b)
 704                                       .map(RegisteredDomain::name)
 705                                       .orElse(b);
 706         }
 707 
 708         return !cdomain.isEmpty() &amp;&amp; !hdomain.isEmpty() &amp;&amp; cdomain.equals(hdomain);
 709     }
 710 
 711     private boolean authorized(String cname, byte[] addr) {
 712         if (addr.length == 4)
 713             return authorizedIPv4(cname, addr);
 714         else if (addr.length == 16)
 715             return authorizedIPv6(cname, addr);
 716         else
 717             return false;
 718     }
 719 
 720     private boolean authorizedIPv4(String cname, byte[] addr) {
 721         String authHost = &quot;&quot;;
 722         InetAddress auth;
 723 
 724         try {
 725             authHost = &quot;auth.&quot; +
 726                         (addr[3] &amp; 0xff) + &quot;.&quot; + (addr[2] &amp; 0xff) + &quot;.&quot; +
 727                         (addr[1] &amp; 0xff) + &quot;.&quot; + (addr[0] &amp; 0xff) +
 728                         &quot;.in-addr.arpa&quot;;
 729             // Following check seems unnecessary
 730             // auth = InetAddress.getAllByName0(authHost, false)[0];
 731             authHost = hostname + &#39;.&#39; + authHost;
 732             auth = InetAddress.getAllByName0(authHost, false)[0];
 733             if (auth.equals(InetAddress.getByAddress(addr))) {
 734                 return true;
 735             }
 736             Debug debug = getDebug();
 737             if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {
 738                 debug.println(&quot;socket access restriction: IP address of &quot; + auth + &quot; != &quot; + InetAddress.getByAddress(addr));
 739             }
 740         } catch (UnknownHostException uhe) {
 741             Debug debug = getDebug();
 742             if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {
 743                 debug.println(&quot;socket access restriction: forward lookup failed for &quot; + authHost);
 744             }
 745         }
 746         return false;
 747     }
 748 
 749     private boolean authorizedIPv6(String cname, byte[] addr) {
 750         String authHost = &quot;&quot;;
 751         InetAddress auth;
 752 
 753         try {
 754             StringBuilder sb = new StringBuilder(39);
 755 
 756             for (int i = 15; i &gt;= 0; i--) {
 757                 sb.append(Integer.toHexString(((addr[i]) &amp; 0x0f)));
 758                 sb.append(&#39;.&#39;);
 759                 sb.append(Integer.toHexString(((addr[i] &gt;&gt; 4) &amp; 0x0f)));
 760                 sb.append(&#39;.&#39;);
 761             }
 762             authHost = &quot;auth.&quot; + sb.toString() + &quot;IP6.ARPA&quot;;
 763             //auth = InetAddress.getAllByName0(authHost, false)[0];
 764             authHost = hostname + &#39;.&#39; + authHost;
 765             auth = InetAddress.getAllByName0(authHost, false)[0];
 766             if (auth.equals(InetAddress.getByAddress(addr)))
 767                 return true;
 768             Debug debug = getDebug();
 769             if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {
 770                 debug.println(&quot;socket access restriction: IP address of &quot; + auth + &quot; != &quot; + InetAddress.getByAddress(addr));
 771             }
 772         } catch (UnknownHostException uhe) {
 773             Debug debug = getDebug();
 774             if (debug != null &amp;&amp; Debug.isOn(&quot;failure&quot;)) {
 775                 debug.println(&quot;socket access restriction: forward lookup failed for &quot; + authHost);
 776             }
 777         }
 778         return false;
 779     }
 780 
 781 
 782     /**
 783      * get IP addresses. Sets invalid to true if we can&#39;t get them.
 784      *
 785      */
 786     void getIP()
 787         throws UnknownHostException
 788     {
 789         if (addresses != null || wildcard || invalid) return;
 790 
 791         try {
 792             // now get all the IP addresses
 793             String host;
 794             if (getName().charAt(0) == &#39;[&#39;) {
 795                 // Literal IPv6 address
 796                 host = getName().substring(1, getName().indexOf(&#39;]&#39;));
 797             } else {
 798                 int i = getName().indexOf(&#39;:&#39;);
 799                 if (i == -1)
 800                     host = getName();
 801                 else {
 802                     host = getName().substring(0,i);
 803                 }
 804             }
 805 
 806             addresses =
 807                 new InetAddress[] {InetAddress.getAllByName0(host, false)[0]};
 808 
 809         } catch (UnknownHostException uhe) {
 810             invalid = true;
 811             throw uhe;
 812         }  catch (IndexOutOfBoundsException iobe) {
 813             invalid = true;
 814             throw new UnknownHostException(getName());
 815         }
 816     }
 817 
 818     /**
 819      * Checks if this socket permission object &quot;implies&quot; the
 820      * specified permission.
 821      * &lt;P&gt;
 822      * More specifically, this method first ensures that all of the following
 823      * are true (and returns false if any of them are not):
 824      * &lt;ul&gt;
 825      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof SocketPermission,
 826      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s actions are a proper subset of this
 827      * object&#39;s actions, and
 828      * &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&#39;s port range is included in this port range. Note:
 829      * port range is ignored when p only contains the action, &#39;resolve&#39;.
 830      * &lt;/ul&gt;
 831      *
 832      * Then {@code implies} checks each of the following, in order,
 833      * and for each returns true if the stated condition is true:
 834      * &lt;ul&gt;
 835      * &lt;li&gt; If this object was initialized with a single IP address and one of &lt;i&gt;p&lt;/i&gt;&#39;s
 836      * IP addresses is equal to this object&#39;s IP address.
 837      * &lt;li&gt;If this object is a wildcard domain (such as *.example.com), and
 838      * &lt;i&gt;p&lt;/i&gt;&#39;s canonical name (the name without any preceding *)
 839      * ends with this object&#39;s canonical host name. For example, *.example.com
 840      * implies *.foo.example.com.
 841      * &lt;li&gt;If this object was not initialized with a single IP address, and one of this
 842      * object&#39;s IP addresses equals one of &lt;i&gt;p&lt;/i&gt;&#39;s IP addresses.
 843      * &lt;li&gt;If this canonical name equals &lt;i&gt;p&lt;/i&gt;&#39;s canonical name.
 844      * &lt;/ul&gt;
 845      *
 846      * If none of the above are true, {@code implies} returns false.
 847      * @param p the permission to check against.
 848      *
 849      * @return true if the specified permission is implied by this object,
 850      * false if not.
 851      */
 852     @Override
 853     public boolean implies(Permission p) {
 854         int i,j;
 855 
 856         if (!(p instanceof SocketPermission))
 857             return false;
 858 
 859         if (p == this)
 860             return true;
 861 
 862         SocketPermission that = (SocketPermission) p;
 863 
 864         return ((this.mask &amp; that.mask) == that.mask) &amp;&amp;
 865                                         impliesIgnoreMask(that);
 866     }
 867 
 868     /**
 869      * Checks if the incoming Permission&#39;s action are a proper subset of
 870      * the this object&#39;s actions.
 871      * &lt;P&gt;
 872      * Check, in the following order:
 873      * &lt;ul&gt;
 874      * &lt;li&gt; Checks that &quot;p&quot; is an instanceof a SocketPermission
 875      * &lt;li&gt; Checks that &quot;p&quot;&#39;s actions are a proper subset of the
 876      * current object&#39;s actions.
 877      * &lt;li&gt; Checks that &quot;p&quot;&#39;s port range is included in this port range
 878      * &lt;li&gt; If this object was initialized with an IP address, checks that
 879      *      one of &quot;p&quot;&#39;s IP addresses is equal to this object&#39;s IP address.
 880      * &lt;li&gt; If either object is a wildcard domain (i.e., &quot;*.example.com&quot;),
 881      *      attempt to match based on the wildcard.
 882      * &lt;li&gt; If this object was not initialized with an IP address, attempt
 883      *      to find a match based on the IP addresses in both objects.
 884      * &lt;li&gt; Attempt to match on the canonical hostnames of both objects.
 885      * &lt;/ul&gt;
 886      * @param that the incoming permission request
 887      *
 888      * @return true if &quot;permission&quot; is a proper subset of the current object,
 889      * false if not.
 890      */
 891     boolean impliesIgnoreMask(SocketPermission that) {
 892         int i,j;
 893 
 894         if ((that.mask &amp; RESOLVE) != that.mask) {
 895 
 896             // check simple port range
 897             if ((that.portrange[0] &lt; this.portrange[0]) ||
 898                     (that.portrange[1] &gt; this.portrange[1])) {
 899 
 900                 // if either includes the ephemeral range, do full check
 901                 if (this.includesEphemerals() || that.includesEphemerals()) {
 902                     if (!inRange(this.portrange[0], this.portrange[1],
 903                                      that.portrange[0], that.portrange[1]))
 904                     {
 905                                 return false;
 906                     }
 907                 } else {
 908                     return false;
 909                 }
 910             }
 911         }
 912 
 913         // allow a &quot;*&quot; wildcard to always match anything
 914         if (this.wildcard &amp;&amp; &quot;&quot;.equals(this.cname))
 915             return true;
 916 
 917         // return if either one of these NetPerm objects are invalid...
 918         if (this.invalid || that.invalid) {
 919             return compareHostnames(that);
 920         }
 921 
 922         try {
 923             if (this.init_with_ip) { // we only check IP addresses
 924                 if (that.wildcard)
 925                     return false;
 926 
 927                 if (that.init_with_ip) {
 928                     return (this.addresses[0].equals(that.addresses[0]));
 929                 } else {
 930                     if (that.addresses == null) {
 931                         that.getIP();
 932                     }
 933                     for (i=0; i &lt; that.addresses.length; i++) {
 934                         if (this.addresses[0].equals(that.addresses[i]))
 935                             return true;
 936                     }
 937                 }
 938                 // since &quot;this&quot; was initialized with an IP address, we
 939                 // don&#39;t check any other cases
 940                 return false;
 941             }
 942 
 943             // check and see if we have any wildcards...
 944             if (this.wildcard || that.wildcard) {
 945                 // if they are both wildcards, return true iff
 946                 // that&#39;s cname ends with this cname (i.e., *.example.com
 947                 // implies *.foo.example.com)
 948                 if (this.wildcard &amp;&amp; that.wildcard)
 949                     return (that.cname.endsWith(this.cname));
 950 
 951                 // a non-wildcard can&#39;t imply a wildcard
 952                 if (that.wildcard)
 953                     return false;
 954 
 955                 // this is a wildcard, lets see if that&#39;s cname ends with
 956                 // it...
 957                 if (that.cname == null) {
 958                     that.getCanonName();
 959                 }
 960                 return (that.cname.endsWith(this.cname));
 961             }
 962 
 963             // compare IP addresses
 964             if (this.addresses == null) {
 965                 this.getIP();
 966             }
 967 
 968             if (that.addresses == null) {
 969                 that.getIP();
 970             }
 971 
 972             if (!(that.init_with_ip &amp;&amp; this.isUntrusted())) {
 973                 for (j = 0; j &lt; this.addresses.length; j++) {
 974                     for (i=0; i &lt; that.addresses.length; i++) {
 975                         if (this.addresses[j].equals(that.addresses[i]))
 976                             return true;
 977                     }
 978                 }
 979 
 980                 // XXX: if all else fails, compare hostnames?
 981                 // Do we really want this?
 982                 if (this.cname == null) {
 983                     this.getCanonName();
 984                 }
 985 
 986                 if (that.cname == null) {
 987                     that.getCanonName();
 988                 }
 989 
 990                 return (this.cname.equalsIgnoreCase(that.cname));
 991             }
 992 
 993         } catch (UnknownHostException uhe) {
 994             return compareHostnames(that);
 995         }
 996 
 997         // make sure the first thing that is done here is to return
 998         // false. If not, uncomment the return false in the above catch.
 999 
1000         return false;
1001     }
1002 
1003     private boolean compareHostnames(SocketPermission that) {
1004         // we see if the original names/IPs passed in were equal.
1005 
1006         String thisHost = hostname;
1007         String thatHost = that.hostname;
1008 
1009         if (thisHost == null) {
1010             return false;
1011         } else if (this.wildcard) {
1012             final int cnameLength = this.cname.length();
1013             return thatHost.regionMatches(true,
1014                                           (thatHost.length() - cnameLength),
1015                                           this.cname, 0, cnameLength);
1016         } else {
1017             return thisHost.equalsIgnoreCase(thatHost);
1018         }
1019     }
1020 
1021     /**
1022      * Checks two SocketPermission objects for equality.
1023      *
1024      * @param obj the object to test for equality with this object.
1025      *
1026      * @return true if &lt;i&gt;obj&lt;/i&gt; is a SocketPermission, and has the
1027      *  same hostname, port range, and actions as this
1028      *  SocketPermission object. However, port range will be ignored
1029      *  in the comparison if &lt;i&gt;obj&lt;/i&gt; only contains the action, &#39;resolve&#39;.
1030      */
1031     @Override
1032     public boolean equals(Object obj) {
1033         if (obj == this)
1034             return true;
1035 
1036         if (! (obj instanceof SocketPermission))
1037             return false;
1038 
1039         SocketPermission that = (SocketPermission) obj;
1040 
1041         //this is (overly?) complex!!!
1042 
1043         // check the mask first
1044         if (this.mask != that.mask) return false;
1045 
1046         if ((that.mask &amp; RESOLVE) != that.mask) {
1047             // now check the port range...
1048             if ((this.portrange[0] != that.portrange[0]) ||
1049                 (this.portrange[1] != that.portrange[1])) {
1050                 return false;
1051             }
1052         }
1053 
1054         // short cut. This catches:
1055         //  &quot;crypto&quot; equal to &quot;crypto&quot;, or
1056         // &quot;1.2.3.4&quot; equal to &quot;1.2.3.4.&quot;, or
1057         //  &quot;*.edu&quot; equal to &quot;*.edu&quot;, but it
1058         //  does not catch &quot;crypto&quot; equal to
1059         // &quot;crypto.foo.example.com&quot;.
1060 
1061         if (this.getName().equalsIgnoreCase(that.getName())) {
1062             return true;
1063         }
1064 
1065         // we now attempt to get the Canonical (FQDN) name and
1066         // compare that. If this fails, about all we can do is return
1067         // false.
1068 
1069         try {
1070             this.getCanonName();
1071             that.getCanonName();
1072         } catch (UnknownHostException uhe) {
1073             return false;
1074         }
1075 
1076         if (this.invalid || that.invalid)
1077             return false;
1078 
1079         if (this.cname != null) {
1080             return this.cname.equalsIgnoreCase(that.cname);
1081         }
1082 
1083         return false;
1084     }
1085 
1086     /**
1087      * Returns the hash code value for this object.
1088      *
1089      * @return a hash code value for this object.
1090      */
1091     @Override
1092     public int hashCode() {
1093         /*
1094          * If this SocketPermission was initialized with an IP address
1095          * or a wildcard, use getName().hashCode(), otherwise use
1096          * the hashCode() of the host name returned from
1097          * java.net.InetAddress.getHostName method.
1098          */
1099 
1100         if (init_with_ip || wildcard) {
1101             return this.getName().hashCode();
1102         }
1103 
1104         try {
1105             getCanonName();
1106         } catch (UnknownHostException uhe) {
1107 
1108         }
1109 
1110         if (invalid || cname == null)
1111             return this.getName().hashCode();
1112         else
1113             return this.cname.hashCode();
1114     }
1115 
1116     /**
1117      * Return the current action mask.
1118      *
1119      * @return the actions mask.
1120      */
1121 
1122     int getMask() {
1123         return mask;
1124     }
1125 
1126     /**
1127      * Returns the &quot;canonical string representation&quot; of the actions in the
1128      * specified mask.
1129      * Always returns present actions in the following order:
1130      * connect, listen, accept, resolve.
1131      *
1132      * @param mask a specific integer action mask to translate into a string
1133      * @return the canonical string representation of the actions
1134      */
1135     private static String getActions(int mask) {
1136         StringJoiner sj = new StringJoiner(&quot;,&quot;);
1137         if ((mask &amp; CONNECT) == CONNECT) {
1138             sj.add(&quot;connect&quot;);
1139         }
1140         if ((mask &amp; LISTEN) == LISTEN) {
1141             sj.add(&quot;listen&quot;);
1142         }
1143         if ((mask &amp; ACCEPT) == ACCEPT) {
1144             sj.add(&quot;accept&quot;);
1145         }
1146         if ((mask &amp; RESOLVE) == RESOLVE) {
1147             sj.add(&quot;resolve&quot;);
1148         }
1149         return sj.toString();
1150     }
1151 
1152     /**
1153      * Returns the canonical string representation of the actions.
1154      * Always returns present actions in the following order:
1155      * connect, listen, accept, resolve.
1156      *
1157      * @return the canonical string representation of the actions.
1158      */
1159     @Override
1160     public String getActions()
1161     {
1162         if (actions == null)
1163             actions = getActions(this.mask);
1164 
1165         return actions;
1166     }
1167 
1168     /**
1169      * Returns a new PermissionCollection object for storing SocketPermission
1170      * objects.
1171      * &lt;p&gt;
1172      * SocketPermission objects must be stored in a manner that allows them
1173      * to be inserted into the collection in any order, but that also enables the
1174      * PermissionCollection {@code implies}
1175      * method to be implemented in an efficient (and consistent) manner.
1176      *
1177      * @return a new PermissionCollection object suitable for storing SocketPermissions.
1178      */
1179     @Override
1180     public PermissionCollection newPermissionCollection() {
1181         return new SocketPermissionCollection();
1182     }
1183 
1184     /**
1185      * WriteObject is called to save the state of the SocketPermission
1186      * to a stream. The actions are serialized, and the superclass
1187      * takes care of the name.
1188      */
<a name="6" id="anc6"></a>
1189     private synchronized void writeObject(java.io.ObjectOutputStream s)
1190         throws IOException
1191     {
1192         // Write out the actions. The superclass takes care of the name
1193         // call getActions to make sure actions field is initialized
1194         if (actions == null)
1195             getActions();
1196         s.defaultWriteObject();
1197     }
1198 
1199     /**
1200      * readObject is called to restore the state of the SocketPermission from
1201      * a stream.
1202      */
<a name="7" id="anc7"></a>
1203     private synchronized void readObject(java.io.ObjectInputStream s)
1204          throws IOException, ClassNotFoundException
1205     {
1206         // Read in the action, then initialize the rest
1207         s.defaultReadObject();
1208         init(getName(),getMask(actions));
1209     }
1210 
1211     /**
1212      * Check the system/security property for the ephemeral port range
1213      * for this system. The suffix is either &quot;high&quot; or &quot;low&quot;
1214      */
1215     private static int initEphemeralPorts(String suffix, int defval) {
1216         return AccessController.doPrivileged(
1217             new PrivilegedAction&lt;&gt;(){
1218                 public Integer run() {
1219                     int val = Integer.getInteger(
1220                             &quot;jdk.net.ephemeralPortRange.&quot;+suffix, -1
1221                     );
1222                     if (val != -1) {
1223                         return val;
1224                     } else {
1225                         return suffix.equals(&quot;low&quot;) ?
1226                             PortConfig.getLower() : PortConfig.getUpper();
1227                     }
1228                 }
1229             }
1230         );
1231     }
1232 
1233     /**
1234      * Check if the target range is within the policy range
1235      * together with the ephemeral range for this platform
1236      * (if policy includes ephemeral range)
1237      */
1238     private static boolean inRange(
1239         int policyLow, int policyHigh, int targetLow, int targetHigh
1240     )
1241     {
1242         final int ephemeralLow = EphemeralRange.low;
1243         final int ephemeralHigh = EphemeralRange.high;
1244 
1245         if (targetLow == 0) {
1246             // check policy includes ephemeral range
1247             if (!inRange(policyLow, policyHigh, ephemeralLow, ephemeralHigh)) {
1248                 return false;
1249             }
1250             if (targetHigh == 0) {
1251                 // nothing left to do
1252                 return true;
1253             }
1254             // continue check with first real port number
1255             targetLow = 1;
1256         }
1257 
1258         if (policyLow == 0 &amp;&amp; policyHigh == 0) {
1259             // ephemeral range only
1260             return targetLow &gt;= ephemeralLow &amp;&amp; targetHigh &lt;= ephemeralHigh;
1261         }
1262 
1263         if (policyLow != 0) {
1264             // simple check of policy only
1265             return targetLow &gt;= policyLow &amp;&amp; targetHigh &lt;= policyHigh;
1266         }
1267 
1268         // policyLow == 0 which means possibly two ranges to check
1269 
1270         // first check if policy and ephem range overlap/contiguous
1271 
1272         if (policyHigh &gt;= ephemeralLow - 1) {
1273             return targetHigh &lt;= ephemeralHigh;
1274         }
1275 
1276         // policy and ephem range do not overlap
1277 
1278         // target range must lie entirely inside policy range or eph range
1279 
1280         return  (targetLow &lt;= policyHigh &amp;&amp; targetHigh &lt;= policyHigh) ||
1281                 (targetLow &gt;= ephemeralLow &amp;&amp; targetHigh &lt;= ephemeralHigh);
1282     }
1283     /*
1284     public String toString()
1285     {
1286         StringBuffer s = new StringBuffer(super.toString() + &quot;\n&quot; +
1287             &quot;cname = &quot; + cname + &quot;\n&quot; +
1288             &quot;wildcard = &quot; + wildcard + &quot;\n&quot; +
1289             &quot;invalid = &quot; + invalid + &quot;\n&quot; +
1290             &quot;portrange = &quot; + portrange[0] + &quot;,&quot; + portrange[1] + &quot;\n&quot;);
1291         if (addresses != null) for (int i=0; i&lt;addresses.length; i++) {
1292             s.append( addresses[i].getHostAddress());
1293             s.append(&quot;\n&quot;);
1294         } else {
1295             s.append(&quot;(no addresses)\n&quot;);
1296         }
1297 
1298         return s.toString();
1299     }
1300 
1301     public static void main(String args[]) throws Exception {
1302         SocketPermission this_ = new SocketPermission(args[0], &quot;connect&quot;);
1303         SocketPermission that_ = new SocketPermission(args[1], &quot;connect&quot;);
1304         System.out.println(&quot;-----\n&quot;);
1305         System.out.println(&quot;this.implies(that) = &quot; + this_.implies(that_));
1306         System.out.println(&quot;-----\n&quot;);
1307         System.out.println(&quot;this = &quot;+this_);
1308         System.out.println(&quot;-----\n&quot;);
1309         System.out.println(&quot;that = &quot;+that_);
1310         System.out.println(&quot;-----\n&quot;);
1311 
1312         SocketPermissionCollection nps = new SocketPermissionCollection();
1313         nps.add(this_);
1314         nps.add(new SocketPermission(&quot;www-leland.stanford.edu&quot;,&quot;connect&quot;));
1315         nps.add(new SocketPermission(&quot;www-example.com&quot;,&quot;connect&quot;));
1316         System.out.println(&quot;nps.implies(that) = &quot; + nps.implies(that_));
1317         System.out.println(&quot;-----\n&quot;);
1318     }
1319     */
1320 }
1321 
1322 /**
1323 
1324 if (init&#39;d with IP, key is IP as string)
1325 if wildcard, its the wild card
1326 else its the cname?
1327 
1328  *
1329  * @see java.security.Permission
1330  * @see java.security.Permissions
1331  * @see java.security.PermissionCollection
1332  *
1333  *
1334  * @author Roland Schemers
1335  *
1336  * @serial include
1337  */
1338 
1339 final class SocketPermissionCollection extends PermissionCollection
1340     implements Serializable
1341 {
1342     // Not serialized; see serialization section at end of class
1343     // A ConcurrentSkipListMap is used to preserve order, so that most
1344     // recently added permissions are checked first (see JDK-4301064).
1345     private transient ConcurrentSkipListMap&lt;String, SocketPermission&gt; perms;
1346 
1347     /**
1348      * Create an empty SocketPermissions object.
1349      *
1350      */
1351     public SocketPermissionCollection() {
1352         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1353     }
1354 
1355     /**
1356      * Adds a permission to the SocketPermissions. The key for the hash is
1357      * the name in the case of wildcards, or all the IP addresses.
1358      *
1359      * @param permission the Permission object to add.
1360      *
<a name="8" id="anc8"></a><span class="line-modified">1361      * @exception IllegalArgumentException - if the permission is not a</span>
1362      *                                       SocketPermission
1363      *
<a name="9" id="anc9"></a><span class="line-modified">1364      * @exception SecurityException - if this SocketPermissionCollection object</span>
1365      *                                has been marked readonly
1366      */
1367     @Override
1368     public void add(Permission permission) {
1369         if (! (permission instanceof SocketPermission))
1370             throw new IllegalArgumentException(&quot;invalid permission: &quot;+
1371                                                permission);
1372         if (isReadOnly())
1373             throw new SecurityException(
1374                 &quot;attempt to add a Permission to a readonly PermissionCollection&quot;);
1375 
1376         SocketPermission sp = (SocketPermission)permission;
1377 
1378         // Add permission to map if it is absent, or replace with new
1379         // permission if applicable. NOTE: cannot use lambda for
1380         // remappingFunction parameter until JDK-8076596 is fixed.
1381         perms.merge(sp.getName(), sp,
1382             new java.util.function.BiFunction&lt;&gt;() {
1383                 @Override
1384                 public SocketPermission apply(SocketPermission existingVal,
1385                                               SocketPermission newVal) {
1386                     int oldMask = existingVal.getMask();
1387                     int newMask = newVal.getMask();
1388                     if (oldMask != newMask) {
1389                         int effective = oldMask | newMask;
1390                         if (effective == newMask) {
1391                             return newVal;
1392                         }
1393                         if (effective != oldMask) {
1394                             return new SocketPermission(sp.getName(),
1395                                                         effective);
1396                         }
1397                     }
1398                     return existingVal;
1399                 }
1400             }
1401         );
1402     }
1403 
1404     /**
1405      * Check and see if this collection of permissions implies the permissions
1406      * expressed in &quot;permission&quot;.
1407      *
1408      * @param permission the Permission object to compare
1409      *
1410      * @return true if &quot;permission&quot; is a proper subset of a permission in
1411      * the collection, false if not.
1412      */
1413     @Override
1414     public boolean implies(Permission permission)
1415     {
1416         if (! (permission instanceof SocketPermission))
1417                 return false;
1418 
1419         SocketPermission np = (SocketPermission) permission;
1420 
1421         int desired = np.getMask();
1422         int effective = 0;
1423         int needed = desired;
1424 
1425         //System.out.println(&quot;implies &quot;+np);
1426         for (SocketPermission x : perms.values()) {
1427             //System.out.println(&quot;  trying &quot;+x);
1428             if (((needed &amp; x.getMask()) != 0) &amp;&amp; x.impliesIgnoreMask(np)) {
1429                 effective |=  x.getMask();
1430                 if ((effective &amp; desired) == desired) {
1431                     return true;
1432                 }
<a name="10" id="anc10"></a><span class="line-modified">1433                 needed = (desired ^ effective);</span>
1434             }
1435         }
1436         return false;
1437     }
1438 
1439     /**
1440      * Returns an enumeration of all the SocketPermission objects in the
1441      * container.
1442      *
1443      * @return an enumeration of all the SocketPermission objects.
1444      */
1445     @Override
1446     @SuppressWarnings(&quot;unchecked&quot;)
1447     public Enumeration&lt;Permission&gt; elements() {
1448         return (Enumeration)Collections.enumeration(perms.values());
1449     }
1450 
<a name="11" id="anc11"></a>
1451     private static final long serialVersionUID = 2787186408602843674L;
1452 
1453     // Need to maintain serialization interoperability with earlier releases,
1454     // which had the serializable field:
1455 
1456     //
1457     // The SocketPermissions for this set.
1458     // @serial
1459     //
1460     // private Vector permissions;
1461 
1462     /**
1463      * @serialField permissions java.util.Vector
1464      *     A list of the SocketPermissions for this set.
1465      */
<a name="12" id="anc12"></a>
1466     private static final ObjectStreamField[] serialPersistentFields = {
1467         new ObjectStreamField(&quot;permissions&quot;, Vector.class),
1468     };
1469 
1470     /**
1471      * @serialData &quot;permissions&quot; field (a Vector containing the SocketPermissions).
1472      */
1473     /*
1474      * Writes the contents of the perms field out as a Vector for
1475      * serialization compatibility with earlier releases.
1476      */
<a name="13" id="anc13"></a>
1477     private void writeObject(ObjectOutputStream out) throws IOException {
1478         // Don&#39;t call out.defaultWriteObject()
1479 
1480         // Write out Vector
1481         Vector&lt;SocketPermission&gt; permissions = new Vector&lt;&gt;(perms.values());
1482 
1483         ObjectOutputStream.PutField pfields = out.putFields();
1484         pfields.put(&quot;permissions&quot;, permissions);
1485         out.writeFields();
1486     }
1487 
1488     /*
1489      * Reads in a Vector of SocketPermissions and saves them in the perms field.
1490      */
<a name="14" id="anc14"></a>
1491     private void readObject(ObjectInputStream in)
1492         throws IOException, ClassNotFoundException
1493     {
1494         // Don&#39;t call in.defaultReadObject()
1495 
1496         // Read in serialized fields
1497         ObjectInputStream.GetField gfields = in.readFields();
1498 
1499         // Get the one we want
1500         @SuppressWarnings(&quot;unchecked&quot;)
1501         Vector&lt;SocketPermission&gt; permissions = (Vector&lt;SocketPermission&gt;)gfields.get(&quot;permissions&quot;, null);
1502         perms = new ConcurrentSkipListMap&lt;&gt;(new SPCComparator());
1503         for (SocketPermission sp : permissions) {
1504             perms.put(sp.getName(), sp);
1505         }
1506     }
1507 
1508     /**
1509      * A simple comparator that orders new non-equal entries at the beginning.
1510      */
1511     private static class SPCComparator implements Comparator&lt;String&gt; {
1512         @Override
1513         public int compare(String s1, String s2) {
1514             if (s1.equals(s2)) {
1515                 return 0;
1516             }
1517             return -1;
1518         }
1519     }
1520 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
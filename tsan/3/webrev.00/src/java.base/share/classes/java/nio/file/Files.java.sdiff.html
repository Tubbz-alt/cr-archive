<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/file/Files.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileSystems.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvalidPathException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/file/Files.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 import java.nio.file.spi.FileTypeDetector;
  61 import java.security.AccessController;
  62 import java.security.PrivilegedAction;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collections;
  66 import java.util.EnumSet;
  67 import java.util.HashSet;
  68 import java.util.Iterator;
  69 import java.util.List;
  70 import java.util.Map;
  71 import java.util.Objects;
  72 import java.util.ServiceLoader;
  73 import java.util.Set;
  74 import java.util.Spliterator;
  75 import java.util.Spliterators;
  76 import java.util.function.BiPredicate;
  77 import java.util.stream.Stream;
  78 import java.util.stream.StreamSupport;
  79 

  80 import sun.nio.ch.FileChannelImpl;

  81 import sun.nio.fs.AbstractFileSystemProvider;
  82 
  83 /**
  84  * This class consists exclusively of static methods that operate on files,
  85  * directories, or other types of files.
  86  *
  87  * &lt;p&gt; In most cases, the methods defined here will delegate to the associated
  88  * file system provider to perform the file operations.
  89  *
  90  * @since 1.7
  91  */
  92 
  93 public final class Files {
  94     // buffer size used for reading and writing
  95     private static final int BUFFER_SIZE = 8192;
  96 
  97     private Files() { }
  98 
  99     /**
 100      * Returns the {@code FileSystemProvider} to delegate to.
</pre>
<hr />
<pre>
2926      * &lt;pre&gt;{@code
2927      * Files.newBufferedReader(path, StandardCharsets.UTF_8)
2928      * }&lt;/pre&gt;
2929      *
2930      * @param   path
2931      *          the path to the file
2932      *
2933      * @return  a new buffered reader, with default buffer size, to read text
2934      *          from the file
2935      *
2936      * @throws  IOException
2937      *          if an I/O error occurs opening the file
2938      * @throws  SecurityException
2939      *          In the case of the default provider, and a security manager is
2940      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
2941      *          method is invoked to check read access to the file.
2942      *
2943      * @since 1.8
2944      */
2945     public static BufferedReader newBufferedReader(Path path) throws IOException {
<span class="line-modified">2946         return newBufferedReader(path, StandardCharsets.UTF_8);</span>
2947     }
2948 
2949     /**
2950      * Opens or creates a file for writing, returning a {@code BufferedWriter}
2951      * that may be used to write text to the file in an efficient manner.
2952      * The {@code options} parameter specifies how the file is created or
2953      * opened. If no options are present then this method works as if the {@link
2954      * StandardOpenOption#CREATE CREATE}, {@link
2955      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
2956      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
2957      * opens the file for writing, creating the file if it doesn&#39;t exist, or
2958      * initially truncating an existing {@link #isRegularFile regular-file} to
2959      * a size of {@code 0} if it exists.
2960      *
2961      * &lt;p&gt; The {@code Writer} methods to write text throw {@code IOException}
2962      * if the text cannot be encoded using the specified charset.
2963      *
2964      * @param   path
2965      *          the path to the file
2966      * @param   cs
</pre>
<hr />
<pre>
3018      *
3019      * @throws  IllegalArgumentException
3020      *          if {@code options} contains an invalid combination of options
3021      * @throws  IOException
3022      *          if an I/O error occurs opening or creating the file
3023      * @throws  UnsupportedOperationException
3024      *          if an unsupported option is specified
3025      * @throws  SecurityException
3026      *          In the case of the default provider, and a security manager is
3027      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3028      *          method is invoked to check write access to the file. The {@link
3029      *          SecurityManager#checkDelete(String) checkDelete} method is
3030      *          invoked to check delete access if the file is opened with the
3031      *          {@code DELETE_ON_CLOSE} option.
3032      *
3033      * @since 1.8
3034      */
3035     public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
3036         throws IOException
3037     {
<span class="line-modified">3038         return newBufferedWriter(path, StandardCharsets.UTF_8, options);</span>
3039     }
3040 
3041     /**
3042      * Copies all bytes from an input stream to a file. On return, the input
3043      * stream will be at end of stream.
3044      *
3045      * &lt;p&gt; By default, the copy fails if the target file already exists or is a
3046      * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING
3047      * REPLACE_EXISTING} option is specified, and the target file already exists,
3048      * then it is replaced if it is not a non-empty directory. If the target
3049      * file exists and is a symbolic link, then the symbolic link is replaced.
3050      * In this release, the {@code REPLACE_EXISTING} option is the only option
3051      * required to be supported by this method. Additional options may be
3052      * supported in future releases.
3053      *
3054      * &lt;p&gt;  If an I/O error occurs reading from the input stream or writing to
3055      * the file, then it may do so after the target file has been created and
3056      * after some bytes have been read or written. Consequently the input
3057      * stream may not be at end of stream and may be in an inconsistent state.
3058      * It is strongly recommended that the input stream be promptly closed if an
</pre>
<hr />
<pre>
3179      *          the output stream to write to
3180      *
3181      * @return  the number of bytes read or written
3182      *
3183      * @throws  IOException
3184      *          if an I/O error occurs when reading or writing
3185      * @throws  SecurityException
3186      *          In the case of the default provider, and a security manager is
3187      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3188      *          method is invoked to check read access to the file.
3189      */
3190     public static long copy(Path source, OutputStream out) throws IOException {
3191         // ensure not null before opening file
3192         Objects.requireNonNull(out);
3193 
3194         try (InputStream in = newInputStream(source)) {
3195             return in.transferTo(out);
3196         }
3197     }
3198 
<span class="line-removed">3199     /**</span>
<span class="line-removed">3200      * The maximum size of array to allocate.</span>
<span class="line-removed">3201      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">3202      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">3203      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">3204      */</span>
<span class="line-removed">3205     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">3206 </span>
3207     private static final jdk.internal.access.JavaLangAccess JLA =
3208             jdk.internal.access.SharedSecrets.getJavaLangAccess();
3209 
3210     /**
3211      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
3212      * about how many bytes the stream will have.
3213      *
3214      * @param   source
3215      *          the input stream to read from
3216      * @param   initialSize
3217      *          the initial size of the byte array to allocate
3218      *
3219      * @return  a byte array containing the bytes read from the file
3220      *
3221      * @throws  IOException
3222      *          if an I/O error occurs reading from the stream
3223      * @throws  OutOfMemoryError
3224      *          if an array of the required size cannot be allocated
3225      */
3226     private static byte[] read(InputStream source, int initialSize) throws IOException {
3227         int capacity = initialSize;
3228         byte[] buf = new byte[capacity];
3229         int nread = 0;
3230         int n;
3231         for (;;) {
3232             // read to EOF which may read more or less than initialSize (eg: file
3233             // is truncated while we are reading)
3234             while ((n = source.read(buf, nread, capacity - nread)) &gt; 0)
3235                 nread += n;
3236 
3237             // if last call to source.read() returned -1, we are done
3238             // otherwise, try to read one more byte; if that failed we&#39;re done too
3239             if (n &lt; 0 || (n = source.read()) &lt; 0)
3240                 break;
3241 
3242             // one more byte was read; need to allocate a larger buffer
<span class="line-modified">3243             if (capacity &lt;= MAX_BUFFER_SIZE - capacity) {</span>
<span class="line-modified">3244                 capacity = Math.max(capacity &lt;&lt; 1, BUFFER_SIZE);</span>
<span class="line-modified">3245             } else {</span>
<span class="line-modified">3246                 if (capacity == MAX_BUFFER_SIZE)</span>
<span class="line-removed">3247                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);</span>
<span class="line-removed">3248                 capacity = MAX_BUFFER_SIZE;</span>
<span class="line-removed">3249             }</span>
3250             buf = Arrays.copyOf(buf, capacity);
3251             buf[nread++] = (byte)n;
3252         }
3253         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
3254     }
3255 
3256     /**
3257      * Reads all the bytes from a file. The method ensures that the file is
3258      * closed when all bytes have been read or an I/O error, or other runtime
3259      * exception, is thrown.
3260      *
3261      * &lt;p&gt; Note that this method is intended for simple cases where it is
3262      * convenient to read all bytes into a byte array. It is not intended for
3263      * reading in large files.
3264      *
3265      * @param   path
3266      *          the path to the file
3267      *
3268      * @return  a byte array containing the bytes read from the file
3269      *
3270      * @throws  IOException
3271      *          if an I/O error occurs reading from the stream
3272      * @throws  OutOfMemoryError
3273      *          if an array of the required size cannot be allocated, for
3274      *          example the file is larger that {@code 2GB}
3275      * @throws  SecurityException
3276      *          In the case of the default provider, and a security manager is
3277      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3278      *          method is invoked to check read access to the file.
3279      */
3280     public static byte[] readAllBytes(Path path) throws IOException {
3281         try (SeekableByteChannel sbc = Files.newByteChannel(path);
3282              InputStream in = Channels.newInputStream(sbc)) {
3283             if (sbc instanceof FileChannelImpl)
3284                 ((FileChannelImpl) sbc).setUninterruptible();
3285             long size = sbc.size();
<span class="line-modified">3286             if (size &gt; (long) MAX_BUFFER_SIZE)</span>
3287                 throw new OutOfMemoryError(&quot;Required array size too large&quot;);
3288             return read(in, (int)size);
3289         }
3290     }
3291 
3292     /**
3293      * Reads all content from a file into a string, decoding from bytes to characters
3294      * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3295      * The method ensures that the file is closed when all content have been read
3296      * or an I/O error, or other runtime exception, is thrown.
3297      *
3298      * &lt;p&gt; This method is equivalent to:
3299      * {@code readString(path, StandardCharsets.UTF_8) }
3300      *
3301      * @param   path the path to the file
3302      *
3303      * @return  a String containing the content read from the file
3304      *
3305      * @throws  IOException
3306      *          if an I/O error occurs reading from the file or a malformed or
3307      *          unmappable byte sequence is read
3308      * @throws  OutOfMemoryError
3309      *          if the file is extremely large, for example larger than {@code 2GB}
3310      * @throws  SecurityException
3311      *          In the case of the default provider, and a security manager is
3312      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3313      *          method is invoked to check read access to the file.
3314      *
3315      * @since 11
3316      */
3317     public static String readString(Path path) throws IOException {
<span class="line-modified">3318         return readString(path, StandardCharsets.UTF_8);</span>
3319     }
3320 
3321     /**
3322      * Reads all characters from a file into a string, decoding from bytes to characters
3323      * using the specified {@linkplain Charset charset}.
3324      * The method ensures that the file is closed when all content have been read
3325      * or an I/O error, or other runtime exception, is thrown.
3326      *
3327      * &lt;p&gt; This method reads all content including the line separators in the middle
3328      * and/or at the end. The resulting string will contain line separators as they
3329      * appear in the file.
3330      *
3331      * @apiNote
3332      * This method is intended for simple cases where it is appropriate and convenient
3333      * to read the content of a file into a String. It is not intended for reading
3334      * very large files.
3335      *
3336      *
3337      *
3338      * @param   path the path to the file
</pre>
<hr />
<pre>
3340      *
3341      * @return  a String containing the content read from the file
3342      *
3343      * @throws  IOException
3344      *          if an I/O error occurs reading from the file or a malformed or
3345      *          unmappable byte sequence is read
3346      * @throws  OutOfMemoryError
3347      *          if the file is extremely large, for example larger than {@code 2GB}
3348      * @throws  SecurityException
3349      *          In the case of the default provider, and a security manager is
3350      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3351      *          method is invoked to check read access to the file.
3352      *
3353      * @since 11
3354      */
3355     public static String readString(Path path, Charset cs) throws IOException {
3356         Objects.requireNonNull(path);
3357         Objects.requireNonNull(cs);
3358 
3359         byte[] ba = readAllBytes(path);


3360         return JLA.newStringNoRepl(ba, cs);
3361     }
3362 
3363     /**
3364      * Read all lines from a file. This method ensures that the file is
3365      * closed when all bytes have been read or an I/O error, or other runtime
3366      * exception, is thrown. Bytes from the file are decoded into characters
3367      * using the specified charset.
3368      *
3369      * &lt;p&gt; This method recognizes the following as line terminators:
3370      * &lt;ul&gt;
3371      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt; followed by &lt;code&gt;&amp;#92;u000A&lt;/code&gt;,
3372      *     CARRIAGE RETURN followed by LINE FEED &lt;/li&gt;
3373      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000A&lt;/code&gt;, LINE FEED &lt;/li&gt;
3374      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt;, CARRIAGE RETURN &lt;/li&gt;
3375      * &lt;/ul&gt;
3376      * &lt;p&gt; Additional Unicode line terminators may be recognized in future
3377      * releases.
3378      *
3379      * &lt;p&gt; Note that this method is intended for simple cases where it is
</pre>
<hr />
<pre>
3423      * }&lt;/pre&gt;
3424      *
3425      * @param   path
3426      *          the path to the file
3427      *
3428      * @return  the lines from the file as a {@code List}; whether the {@code
3429      *          List} is modifiable or not is implementation dependent and
3430      *          therefore not specified
3431      *
3432      * @throws  IOException
3433      *          if an I/O error occurs reading from the file or a malformed or
3434      *          unmappable byte sequence is read
3435      * @throws  SecurityException
3436      *          In the case of the default provider, and a security manager is
3437      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3438      *          method is invoked to check read access to the file.
3439      *
3440      * @since 1.8
3441      */
3442     public static List&lt;String&gt; readAllLines(Path path) throws IOException {
<span class="line-modified">3443         return readAllLines(path, StandardCharsets.UTF_8);</span>
3444     }
3445 
3446     /**
3447      * Writes bytes to a file. The {@code options} parameter specifies how
3448      * the file is created or opened. If no options are present then this method
3449      * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
3450      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3451      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3452      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3453      * initially truncating an existing {@link #isRegularFile regular-file} to
3454      * a size of {@code 0}. All bytes in the byte array are written to the file.
3455      * The method ensures that the file is closed when all bytes have been
3456      * written (or an I/O error or other runtime exception is thrown). If an I/O
3457      * error occurs then it may do so after the file has been created or
3458      * truncated, or after some bytes have been written to the file.
3459      *
3460      * &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: By default the method creates a new file or
3461      * overwrites an existing file. Suppose you instead want to append bytes
3462      * to an existing file:
3463      * &lt;pre&gt;
</pre>
<hr />
<pre>
3543      * @throws  IOException
3544      *          if an I/O error occurs writing to or creating the file, or the
3545      *          text cannot be encoded using the specified charset
3546      * @throws  UnsupportedOperationException
3547      *          if an unsupported option is specified
3548      * @throws  SecurityException
3549      *          In the case of the default provider, and a security manager is
3550      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3551      *          method is invoked to check write access to the file. The {@link
3552      *          SecurityManager#checkDelete(String) checkDelete} method is
3553      *          invoked to check delete access if the file is opened with the
3554      *          {@code DELETE_ON_CLOSE} option.
3555      */
3556     public static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines,
3557                              Charset cs, OpenOption... options)
3558         throws IOException
3559     {
3560         // ensure lines is not null before opening file
3561         Objects.requireNonNull(lines);
3562         CharsetEncoder encoder = cs.newEncoder();
<span class="line-modified">3563         OutputStream out = newOutputStream(path, options);</span>
<span class="line-modified">3564         try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {</span>
3565             for (CharSequence line: lines) {
3566                 writer.append(line);
3567                 writer.newLine();
3568             }
3569         }
3570         return path;
3571     }
3572 
3573     /**
3574      * Write lines of text to a file. Characters are encoded into bytes using
3575      * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3576      *
3577      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3578      * expression:
3579      * &lt;pre&gt;{@code
3580      * Files.write(path, lines, StandardCharsets.UTF_8, options);
3581      * }&lt;/pre&gt;
3582      *
3583      * @param   path
3584      *          the path to the file
</pre>
<hr />
<pre>
3594      * @throws  IOException
3595      *          if an I/O error occurs writing to or creating the file, or the
3596      *          text cannot be encoded as {@code UTF-8}
3597      * @throws  UnsupportedOperationException
3598      *          if an unsupported option is specified
3599      * @throws  SecurityException
3600      *          In the case of the default provider, and a security manager is
3601      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3602      *          method is invoked to check write access to the file. The {@link
3603      *          SecurityManager#checkDelete(String) checkDelete} method is
3604      *          invoked to check delete access if the file is opened with the
3605      *          {@code DELETE_ON_CLOSE} option.
3606      *
3607      * @since 1.8
3608      */
3609     public static Path write(Path path,
3610                              Iterable&lt;? extends CharSequence&gt; lines,
3611                              OpenOption... options)
3612         throws IOException
3613     {
<span class="line-modified">3614         return write(path, lines, StandardCharsets.UTF_8, options);</span>
3615     }
3616 
3617     /**
3618      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3619      * Characters are encoded into bytes using the
3620      * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3621      *
3622      * &lt;p&gt; This method is equivalent to:
3623      * {@code writeString(path, test, StandardCharsets.UTF_8, options) }
3624      *
3625      * @param   path
3626      *          the path to the file
3627      * @param   csq
3628      *          the CharSequence to be written
3629      * @param   options
3630      *          options specifying how the file is opened
3631      *
3632      * @return  the path
3633      *
3634      * @throws  IllegalArgumentException
3635      *          if {@code options} contains an invalid combination of options
3636      * @throws  IOException
3637      *          if an I/O error occurs writing to or creating the file, or the
3638      *          text cannot be encoded using the specified charset
3639      * @throws  UnsupportedOperationException
3640      *          if an unsupported option is specified
3641      * @throws  SecurityException
3642      *          In the case of the default provider, and a security manager is
3643      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3644      *          method is invoked to check write access to the file. The {@link
3645      *          SecurityManager#checkDelete(String) checkDelete} method is
3646      *          invoked to check delete access if the file is opened with the
3647      *          {@code DELETE_ON_CLOSE} option.
3648      *
3649      * @since 11
3650      */
3651     public static Path writeString(Path path, CharSequence csq, OpenOption... options)
3652             throws IOException
3653     {
<span class="line-modified">3654         return writeString(path, csq, StandardCharsets.UTF_8, options);</span>
3655     }
3656 
3657     /**
3658      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3659      * Characters are encoded into bytes using the specified
3660      * {@linkplain java.nio.charset.Charset charset}.
3661      *
3662      * &lt;p&gt; All characters are written as they are, including the line separators in
3663      * the char sequence. No extra characters are added.
3664      *
3665      * &lt;p&gt; The {@code options} parameter specifies how the file is created
3666      * or opened. If no options are present then this method works as if the
3667      * {@link StandardOpenOption#CREATE CREATE}, {@link
3668      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3669      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3670      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3671      * initially truncating an existing {@link #isRegularFile regular-file} to
3672      * a size of {@code 0}.
3673      *
3674      *
</pre>
<hr />
<pre>
4181      * @apiNote
4182      * This method must be used within a try-with-resources statement or similar
4183      * control structure to ensure that the stream&#39;s open file is closed promptly
4184      * after the stream&#39;s operations have completed.
4185      *
4186      * @param   path
4187      *          the path to the file
4188      *
4189      * @return  the lines from the file as a {@code Stream}
4190      *
4191      * @throws  IOException
4192      *          if an I/O error occurs opening the file
4193      * @throws  SecurityException
4194      *          In the case of the default provider, and a security manager is
4195      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
4196      *          method is invoked to check read access to the file.
4197      *
4198      * @since 1.8
4199      */
4200     public static Stream&lt;String&gt; lines(Path path) throws IOException {
<span class="line-modified">4201         return lines(path, StandardCharsets.UTF_8);</span>
4202     }
4203 }
</pre>
</td>
<td>
<hr />
<pre>
  60 import java.nio.file.spi.FileTypeDetector;
  61 import java.security.AccessController;
  62 import java.security.PrivilegedAction;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collections;
  66 import java.util.EnumSet;
  67 import java.util.HashSet;
  68 import java.util.Iterator;
  69 import java.util.List;
  70 import java.util.Map;
  71 import java.util.Objects;
  72 import java.util.ServiceLoader;
  73 import java.util.Set;
  74 import java.util.Spliterator;
  75 import java.util.Spliterators;
  76 import java.util.function.BiPredicate;
  77 import java.util.stream.Stream;
  78 import java.util.stream.StreamSupport;
  79 
<span class="line-added">  80 import jdk.internal.util.ArraysSupport;</span>
  81 import sun.nio.ch.FileChannelImpl;
<span class="line-added">  82 import sun.nio.cs.UTF_8;</span>
  83 import sun.nio.fs.AbstractFileSystemProvider;
  84 
  85 /**
  86  * This class consists exclusively of static methods that operate on files,
  87  * directories, or other types of files.
  88  *
  89  * &lt;p&gt; In most cases, the methods defined here will delegate to the associated
  90  * file system provider to perform the file operations.
  91  *
  92  * @since 1.7
  93  */
  94 
  95 public final class Files {
  96     // buffer size used for reading and writing
  97     private static final int BUFFER_SIZE = 8192;
  98 
  99     private Files() { }
 100 
 101     /**
 102      * Returns the {@code FileSystemProvider} to delegate to.
</pre>
<hr />
<pre>
2928      * &lt;pre&gt;{@code
2929      * Files.newBufferedReader(path, StandardCharsets.UTF_8)
2930      * }&lt;/pre&gt;
2931      *
2932      * @param   path
2933      *          the path to the file
2934      *
2935      * @return  a new buffered reader, with default buffer size, to read text
2936      *          from the file
2937      *
2938      * @throws  IOException
2939      *          if an I/O error occurs opening the file
2940      * @throws  SecurityException
2941      *          In the case of the default provider, and a security manager is
2942      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
2943      *          method is invoked to check read access to the file.
2944      *
2945      * @since 1.8
2946      */
2947     public static BufferedReader newBufferedReader(Path path) throws IOException {
<span class="line-modified">2948         return newBufferedReader(path, UTF_8.INSTANCE);</span>
2949     }
2950 
2951     /**
2952      * Opens or creates a file for writing, returning a {@code BufferedWriter}
2953      * that may be used to write text to the file in an efficient manner.
2954      * The {@code options} parameter specifies how the file is created or
2955      * opened. If no options are present then this method works as if the {@link
2956      * StandardOpenOption#CREATE CREATE}, {@link
2957      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
2958      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
2959      * opens the file for writing, creating the file if it doesn&#39;t exist, or
2960      * initially truncating an existing {@link #isRegularFile regular-file} to
2961      * a size of {@code 0} if it exists.
2962      *
2963      * &lt;p&gt; The {@code Writer} methods to write text throw {@code IOException}
2964      * if the text cannot be encoded using the specified charset.
2965      *
2966      * @param   path
2967      *          the path to the file
2968      * @param   cs
</pre>
<hr />
<pre>
3020      *
3021      * @throws  IllegalArgumentException
3022      *          if {@code options} contains an invalid combination of options
3023      * @throws  IOException
3024      *          if an I/O error occurs opening or creating the file
3025      * @throws  UnsupportedOperationException
3026      *          if an unsupported option is specified
3027      * @throws  SecurityException
3028      *          In the case of the default provider, and a security manager is
3029      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3030      *          method is invoked to check write access to the file. The {@link
3031      *          SecurityManager#checkDelete(String) checkDelete} method is
3032      *          invoked to check delete access if the file is opened with the
3033      *          {@code DELETE_ON_CLOSE} option.
3034      *
3035      * @since 1.8
3036      */
3037     public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
3038         throws IOException
3039     {
<span class="line-modified">3040         return newBufferedWriter(path, UTF_8.INSTANCE, options);</span>
3041     }
3042 
3043     /**
3044      * Copies all bytes from an input stream to a file. On return, the input
3045      * stream will be at end of stream.
3046      *
3047      * &lt;p&gt; By default, the copy fails if the target file already exists or is a
3048      * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING
3049      * REPLACE_EXISTING} option is specified, and the target file already exists,
3050      * then it is replaced if it is not a non-empty directory. If the target
3051      * file exists and is a symbolic link, then the symbolic link is replaced.
3052      * In this release, the {@code REPLACE_EXISTING} option is the only option
3053      * required to be supported by this method. Additional options may be
3054      * supported in future releases.
3055      *
3056      * &lt;p&gt;  If an I/O error occurs reading from the input stream or writing to
3057      * the file, then it may do so after the target file has been created and
3058      * after some bytes have been read or written. Consequently the input
3059      * stream may not be at end of stream and may be in an inconsistent state.
3060      * It is strongly recommended that the input stream be promptly closed if an
</pre>
<hr />
<pre>
3181      *          the output stream to write to
3182      *
3183      * @return  the number of bytes read or written
3184      *
3185      * @throws  IOException
3186      *          if an I/O error occurs when reading or writing
3187      * @throws  SecurityException
3188      *          In the case of the default provider, and a security manager is
3189      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3190      *          method is invoked to check read access to the file.
3191      */
3192     public static long copy(Path source, OutputStream out) throws IOException {
3193         // ensure not null before opening file
3194         Objects.requireNonNull(out);
3195 
3196         try (InputStream in = newInputStream(source)) {
3197             return in.transferTo(out);
3198         }
3199     }
3200 








3201     private static final jdk.internal.access.JavaLangAccess JLA =
3202             jdk.internal.access.SharedSecrets.getJavaLangAccess();
3203 
3204     /**
3205      * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
3206      * about how many bytes the stream will have.
3207      *
3208      * @param   source
3209      *          the input stream to read from
3210      * @param   initialSize
3211      *          the initial size of the byte array to allocate
3212      *
3213      * @return  a byte array containing the bytes read from the file
3214      *
3215      * @throws  IOException
3216      *          if an I/O error occurs reading from the stream
3217      * @throws  OutOfMemoryError
3218      *          if an array of the required size cannot be allocated
3219      */
3220     private static byte[] read(InputStream source, int initialSize) throws IOException {
3221         int capacity = initialSize;
3222         byte[] buf = new byte[capacity];
3223         int nread = 0;
3224         int n;
3225         for (;;) {
3226             // read to EOF which may read more or less than initialSize (eg: file
3227             // is truncated while we are reading)
3228             while ((n = source.read(buf, nread, capacity - nread)) &gt; 0)
3229                 nread += n;
3230 
3231             // if last call to source.read() returned -1, we are done
3232             // otherwise, try to read one more byte; if that failed we&#39;re done too
3233             if (n &lt; 0 || (n = source.read()) &lt; 0)
3234                 break;
3235 
3236             // one more byte was read; need to allocate a larger buffer
<span class="line-modified">3237             capacity = Math.max(ArraysSupport.newLength(capacity,</span>
<span class="line-modified">3238                                                         1,       /* minimum growth */</span>
<span class="line-modified">3239                                                         capacity /* preferred growth */),</span>
<span class="line-modified">3240                                 BUFFER_SIZE);</span>



3241             buf = Arrays.copyOf(buf, capacity);
3242             buf[nread++] = (byte)n;
3243         }
3244         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
3245     }
3246 
3247     /**
3248      * Reads all the bytes from a file. The method ensures that the file is
3249      * closed when all bytes have been read or an I/O error, or other runtime
3250      * exception, is thrown.
3251      *
3252      * &lt;p&gt; Note that this method is intended for simple cases where it is
3253      * convenient to read all bytes into a byte array. It is not intended for
3254      * reading in large files.
3255      *
3256      * @param   path
3257      *          the path to the file
3258      *
3259      * @return  a byte array containing the bytes read from the file
3260      *
3261      * @throws  IOException
3262      *          if an I/O error occurs reading from the stream
3263      * @throws  OutOfMemoryError
3264      *          if an array of the required size cannot be allocated, for
3265      *          example the file is larger that {@code 2GB}
3266      * @throws  SecurityException
3267      *          In the case of the default provider, and a security manager is
3268      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3269      *          method is invoked to check read access to the file.
3270      */
3271     public static byte[] readAllBytes(Path path) throws IOException {
3272         try (SeekableByteChannel sbc = Files.newByteChannel(path);
3273              InputStream in = Channels.newInputStream(sbc)) {
3274             if (sbc instanceof FileChannelImpl)
3275                 ((FileChannelImpl) sbc).setUninterruptible();
3276             long size = sbc.size();
<span class="line-modified">3277             if (size &gt; (long) Integer.MAX_VALUE)</span>
3278                 throw new OutOfMemoryError(&quot;Required array size too large&quot;);
3279             return read(in, (int)size);
3280         }
3281     }
3282 
3283     /**
3284      * Reads all content from a file into a string, decoding from bytes to characters
3285      * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3286      * The method ensures that the file is closed when all content have been read
3287      * or an I/O error, or other runtime exception, is thrown.
3288      *
3289      * &lt;p&gt; This method is equivalent to:
3290      * {@code readString(path, StandardCharsets.UTF_8) }
3291      *
3292      * @param   path the path to the file
3293      *
3294      * @return  a String containing the content read from the file
3295      *
3296      * @throws  IOException
3297      *          if an I/O error occurs reading from the file or a malformed or
3298      *          unmappable byte sequence is read
3299      * @throws  OutOfMemoryError
3300      *          if the file is extremely large, for example larger than {@code 2GB}
3301      * @throws  SecurityException
3302      *          In the case of the default provider, and a security manager is
3303      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3304      *          method is invoked to check read access to the file.
3305      *
3306      * @since 11
3307      */
3308     public static String readString(Path path) throws IOException {
<span class="line-modified">3309         return readString(path, UTF_8.INSTANCE);</span>
3310     }
3311 
3312     /**
3313      * Reads all characters from a file into a string, decoding from bytes to characters
3314      * using the specified {@linkplain Charset charset}.
3315      * The method ensures that the file is closed when all content have been read
3316      * or an I/O error, or other runtime exception, is thrown.
3317      *
3318      * &lt;p&gt; This method reads all content including the line separators in the middle
3319      * and/or at the end. The resulting string will contain line separators as they
3320      * appear in the file.
3321      *
3322      * @apiNote
3323      * This method is intended for simple cases where it is appropriate and convenient
3324      * to read the content of a file into a String. It is not intended for reading
3325      * very large files.
3326      *
3327      *
3328      *
3329      * @param   path the path to the file
</pre>
<hr />
<pre>
3331      *
3332      * @return  a String containing the content read from the file
3333      *
3334      * @throws  IOException
3335      *          if an I/O error occurs reading from the file or a malformed or
3336      *          unmappable byte sequence is read
3337      * @throws  OutOfMemoryError
3338      *          if the file is extremely large, for example larger than {@code 2GB}
3339      * @throws  SecurityException
3340      *          In the case of the default provider, and a security manager is
3341      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3342      *          method is invoked to check read access to the file.
3343      *
3344      * @since 11
3345      */
3346     public static String readString(Path path, Charset cs) throws IOException {
3347         Objects.requireNonNull(path);
3348         Objects.requireNonNull(cs);
3349 
3350         byte[] ba = readAllBytes(path);
<span class="line-added">3351         if (path.getClass().getModule() != Object.class.getModule())</span>
<span class="line-added">3352             ba = ba.clone();</span>
3353         return JLA.newStringNoRepl(ba, cs);
3354     }
3355 
3356     /**
3357      * Read all lines from a file. This method ensures that the file is
3358      * closed when all bytes have been read or an I/O error, or other runtime
3359      * exception, is thrown. Bytes from the file are decoded into characters
3360      * using the specified charset.
3361      *
3362      * &lt;p&gt; This method recognizes the following as line terminators:
3363      * &lt;ul&gt;
3364      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt; followed by &lt;code&gt;&amp;#92;u000A&lt;/code&gt;,
3365      *     CARRIAGE RETURN followed by LINE FEED &lt;/li&gt;
3366      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000A&lt;/code&gt;, LINE FEED &lt;/li&gt;
3367      *   &lt;li&gt; &lt;code&gt;&amp;#92;u000D&lt;/code&gt;, CARRIAGE RETURN &lt;/li&gt;
3368      * &lt;/ul&gt;
3369      * &lt;p&gt; Additional Unicode line terminators may be recognized in future
3370      * releases.
3371      *
3372      * &lt;p&gt; Note that this method is intended for simple cases where it is
</pre>
<hr />
<pre>
3416      * }&lt;/pre&gt;
3417      *
3418      * @param   path
3419      *          the path to the file
3420      *
3421      * @return  the lines from the file as a {@code List}; whether the {@code
3422      *          List} is modifiable or not is implementation dependent and
3423      *          therefore not specified
3424      *
3425      * @throws  IOException
3426      *          if an I/O error occurs reading from the file or a malformed or
3427      *          unmappable byte sequence is read
3428      * @throws  SecurityException
3429      *          In the case of the default provider, and a security manager is
3430      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
3431      *          method is invoked to check read access to the file.
3432      *
3433      * @since 1.8
3434      */
3435     public static List&lt;String&gt; readAllLines(Path path) throws IOException {
<span class="line-modified">3436         return readAllLines(path, UTF_8.INSTANCE);</span>
3437     }
3438 
3439     /**
3440      * Writes bytes to a file. The {@code options} parameter specifies how
3441      * the file is created or opened. If no options are present then this method
3442      * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
3443      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3444      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3445      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3446      * initially truncating an existing {@link #isRegularFile regular-file} to
3447      * a size of {@code 0}. All bytes in the byte array are written to the file.
3448      * The method ensures that the file is closed when all bytes have been
3449      * written (or an I/O error or other runtime exception is thrown). If an I/O
3450      * error occurs then it may do so after the file has been created or
3451      * truncated, or after some bytes have been written to the file.
3452      *
3453      * &lt;p&gt; &lt;b&gt;Usage example&lt;/b&gt;: By default the method creates a new file or
3454      * overwrites an existing file. Suppose you instead want to append bytes
3455      * to an existing file:
3456      * &lt;pre&gt;
</pre>
<hr />
<pre>
3536      * @throws  IOException
3537      *          if an I/O error occurs writing to or creating the file, or the
3538      *          text cannot be encoded using the specified charset
3539      * @throws  UnsupportedOperationException
3540      *          if an unsupported option is specified
3541      * @throws  SecurityException
3542      *          In the case of the default provider, and a security manager is
3543      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3544      *          method is invoked to check write access to the file. The {@link
3545      *          SecurityManager#checkDelete(String) checkDelete} method is
3546      *          invoked to check delete access if the file is opened with the
3547      *          {@code DELETE_ON_CLOSE} option.
3548      */
3549     public static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines,
3550                              Charset cs, OpenOption... options)
3551         throws IOException
3552     {
3553         // ensure lines is not null before opening file
3554         Objects.requireNonNull(lines);
3555         CharsetEncoder encoder = cs.newEncoder();
<span class="line-modified">3556         try (OutputStream out = newOutputStream(path, options);</span>
<span class="line-modified">3557              BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {</span>
3558             for (CharSequence line: lines) {
3559                 writer.append(line);
3560                 writer.newLine();
3561             }
3562         }
3563         return path;
3564     }
3565 
3566     /**
3567      * Write lines of text to a file. Characters are encoded into bytes using
3568      * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3569      *
3570      * &lt;p&gt; This method works as if invoking it were equivalent to evaluating the
3571      * expression:
3572      * &lt;pre&gt;{@code
3573      * Files.write(path, lines, StandardCharsets.UTF_8, options);
3574      * }&lt;/pre&gt;
3575      *
3576      * @param   path
3577      *          the path to the file
</pre>
<hr />
<pre>
3587      * @throws  IOException
3588      *          if an I/O error occurs writing to or creating the file, or the
3589      *          text cannot be encoded as {@code UTF-8}
3590      * @throws  UnsupportedOperationException
3591      *          if an unsupported option is specified
3592      * @throws  SecurityException
3593      *          In the case of the default provider, and a security manager is
3594      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3595      *          method is invoked to check write access to the file. The {@link
3596      *          SecurityManager#checkDelete(String) checkDelete} method is
3597      *          invoked to check delete access if the file is opened with the
3598      *          {@code DELETE_ON_CLOSE} option.
3599      *
3600      * @since 1.8
3601      */
3602     public static Path write(Path path,
3603                              Iterable&lt;? extends CharSequence&gt; lines,
3604                              OpenOption... options)
3605         throws IOException
3606     {
<span class="line-modified">3607         return write(path, lines, UTF_8.INSTANCE, options);</span>
3608     }
3609 
3610     /**
3611      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3612      * Characters are encoded into bytes using the
3613      * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
3614      *
3615      * &lt;p&gt; This method is equivalent to:
3616      * {@code writeString(path, test, StandardCharsets.UTF_8, options) }
3617      *
3618      * @param   path
3619      *          the path to the file
3620      * @param   csq
3621      *          the CharSequence to be written
3622      * @param   options
3623      *          options specifying how the file is opened
3624      *
3625      * @return  the path
3626      *
3627      * @throws  IllegalArgumentException
3628      *          if {@code options} contains an invalid combination of options
3629      * @throws  IOException
3630      *          if an I/O error occurs writing to or creating the file, or the
3631      *          text cannot be encoded using the specified charset
3632      * @throws  UnsupportedOperationException
3633      *          if an unsupported option is specified
3634      * @throws  SecurityException
3635      *          In the case of the default provider, and a security manager is
3636      *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
3637      *          method is invoked to check write access to the file. The {@link
3638      *          SecurityManager#checkDelete(String) checkDelete} method is
3639      *          invoked to check delete access if the file is opened with the
3640      *          {@code DELETE_ON_CLOSE} option.
3641      *
3642      * @since 11
3643      */
3644     public static Path writeString(Path path, CharSequence csq, OpenOption... options)
3645             throws IOException
3646     {
<span class="line-modified">3647         return writeString(path, csq, UTF_8.INSTANCE, options);</span>
3648     }
3649 
3650     /**
3651      * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
3652      * Characters are encoded into bytes using the specified
3653      * {@linkplain java.nio.charset.Charset charset}.
3654      *
3655      * &lt;p&gt; All characters are written as they are, including the line separators in
3656      * the char sequence. No extra characters are added.
3657      *
3658      * &lt;p&gt; The {@code options} parameter specifies how the file is created
3659      * or opened. If no options are present then this method works as if the
3660      * {@link StandardOpenOption#CREATE CREATE}, {@link
3661      * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
3662      * StandardOpenOption#WRITE WRITE} options are present. In other words, it
3663      * opens the file for writing, creating the file if it doesn&#39;t exist, or
3664      * initially truncating an existing {@link #isRegularFile regular-file} to
3665      * a size of {@code 0}.
3666      *
3667      *
</pre>
<hr />
<pre>
4174      * @apiNote
4175      * This method must be used within a try-with-resources statement or similar
4176      * control structure to ensure that the stream&#39;s open file is closed promptly
4177      * after the stream&#39;s operations have completed.
4178      *
4179      * @param   path
4180      *          the path to the file
4181      *
4182      * @return  the lines from the file as a {@code Stream}
4183      *
4184      * @throws  IOException
4185      *          if an I/O error occurs opening the file
4186      * @throws  SecurityException
4187      *          In the case of the default provider, and a security manager is
4188      *          installed, the {@link SecurityManager#checkRead(String) checkRead}
4189      *          method is invoked to check read access to the file.
4190      *
4191      * @since 1.8
4192      */
4193     public static Stream&lt;String&gt; lines(Path path) throws IOException {
<span class="line-modified">4194         return lines(path, UTF_8.INSTANCE);</span>
4195     }
4196 }
</pre>
</td>
</tr>
</table>
<center><a href="FileSystems.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvalidPathException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
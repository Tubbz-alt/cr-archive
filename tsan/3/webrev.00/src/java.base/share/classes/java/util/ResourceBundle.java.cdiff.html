<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/ResourceBundle.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="RegularEnumSet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Scanner.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ResourceBundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
  
  
  /**
   *
   * Resource bundles contain locale-specific objects.  When your program needs a
<span class="line-modified">!  * locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can</span>
   * load it from the resource bundle that is appropriate for the current user&#39;s
   * locale. In this way, you can write program code that is largely independent
   * of the user&#39;s locale isolating most, if not all, of the locale-specific
   * information in resource bundles.
   *
<span class="line-new-header">--- 77,11 ---</span>
  
  
  /**
   *
   * Resource bundles contain locale-specific objects.  When your program needs a
<span class="line-modified">!  * locale-specific resource, a {@code String} for example, your program can</span>
   * load it from the resource bundle that is appropriate for the current user&#39;s
   * locale. In this way, you can write program code that is largely independent
   * of the user&#39;s locale isolating most, if not all, of the locale-specific
   * information in resource bundles.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,12 ***</span>
   *
   * &lt;P&gt;
   * Each resource bundle in a family contains the same items, but the items have
   * been translated for the locale represented by that resource bundle.
   * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
<span class="line-modified">!  * &lt;code&gt;String&lt;/code&gt; that&#39;s used on a button for canceling operations.</span>
<span class="line-modified">!  * In &quot;MyResources&quot; the &lt;code&gt;String&lt;/code&gt; may contain &quot;Cancel&quot; and in</span>
   * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
   *
   * &lt;P&gt;
   * If there are different resources for different countries, you
   * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
<span class="line-new-header">--- 106,12 ---</span>
   *
   * &lt;P&gt;
   * Each resource bundle in a family contains the same items, but the items have
   * been translated for the locale represented by that resource bundle.
   * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
<span class="line-modified">!  * {@code String} that&#39;s used on a button for canceling operations.</span>
<span class="line-modified">!  * In &quot;MyResources&quot; the {@code String} may contain &quot;Cancel&quot; and in</span>
   * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
   *
   * &lt;P&gt;
   * If there are different resources for different countries, you
   * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,11 ***</span>
   * modify some of the resources
   * in the specialization, you can do so.
   *
   * &lt;P&gt;
   * When your program needs a locale-specific object, it loads
<span class="line-modified">!  * the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the</span>
   * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
   * method:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * ResourceBundle myResources =
<span class="line-new-header">--- 119,11 ---</span>
   * modify some of the resources
   * in the specialization, you can do so.
   *
   * &lt;P&gt;
   * When your program needs a locale-specific object, it loads
<span class="line-modified">!  * the {@code ResourceBundle} class using the</span>
   * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
   * method:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * ResourceBundle myResources =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
   * &lt;/blockquote&gt;
   *
   * &lt;P&gt;
   * Resource bundles contain key/value pairs. The keys uniquely
   * identify a locale-specific object in the bundle. Here&#39;s an
<span class="line-modified">!  * example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains</span>
   * two key/value pairs:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * public class MyResources extends ListResourceBundle {
   *     protected Object[][] getContents() {
<span class="line-new-header">--- 132,11 ---</span>
   * &lt;/blockquote&gt;
   *
   * &lt;P&gt;
   * Resource bundles contain key/value pairs. The keys uniquely
   * identify a locale-specific object in the bundle. Here&#39;s an
<span class="line-modified">!  * example of a {@code ListResourceBundle} that contains</span>
   * two key/value pairs:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * public class MyResources extends ListResourceBundle {
   *     protected Object[][] getContents() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,76 ***</span>
   *        };
   *     }
   * }
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * Keys are always &lt;code&gt;String&lt;/code&gt;s.</span>
   * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
   * In the above example, the values
<span class="line-modified">!  * are also &lt;code&gt;String&lt;/code&gt;s--&quot;OK&quot; and &quot;Cancel&quot;--but</span>
   * they don&#39;t have to be. The values can be any type of object.
   *
   * &lt;P&gt;
   * You retrieve an object from resource bundle using the appropriate
   * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
<span class="line-modified">!  * are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
   * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   * The getter methods all require the key as an argument and return
   * the object if found. If the object is not found, the getter method
<span class="line-modified">!  * throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.</span>
   *
   * &lt;P&gt;
<span class="line-modified">!  * Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides</span>
<span class="line-modified">!  * a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,</span>
<span class="line-modified">!  * as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other</span>
<span class="line-modified">!  * type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you&#39;ll</span>
   * have to cast the result to the appropriate type. For example:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
   * &lt;P&gt;
<span class="line-modified">!  * The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,</span>
   * that provide a fairly simple way to create resources.
<span class="line-modified">!  * As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;</span>
   * manages its resource as a list of key/value pairs.
<span class="line-modified">!  * &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage</span>
   * its resources.
   *
   * &lt;p&gt;
<span class="line-modified">!  * If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;</span>
<span class="line-modified">!  * do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified">!  * subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;</span>
<span class="line-modified">!  * and &lt;code&gt;getKeys()&lt;/code&gt;.</span>
   *
   * &lt;p&gt;
   * The implementation of a {@code ResourceBundle} subclass must be thread-safe
   * if it&#39;s simultaneously used by multiple threads. The default implementations
   * of the non-abstract methods in this class, and the methods in the direct
   * known concrete subclasses {@code ListResourceBundle} and
   * {@code PropertyResourceBundle} are thread-safe.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * Resource bundles can be deployed in modules in the following ways:
   *
<span class="line-modified">!  * &lt;h4&gt;Resource bundles together with an application&lt;/h4&gt;</span>
   *
   * Resource bundles can be deployed together with an application in the same
   * module.  In that case, the resource bundles are loaded
   * by code in the module by calling the {@link #getBundle(String)}
   * or {@link #getBundle(String, Locale)} method.
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;service-providers&quot;&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
   * and they can be located using {@link ServiceLoader}.
   * A {@linkplain ResourceBundleProvider service} interface or class must be
   * defined. The caller module declares that it uses the service, the service
<span class="line-new-header">--- 148,76 ---</span>
   *        };
   *     }
   * }
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
<span class="line-modified">!  * Keys are always {@code String}s.</span>
   * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
   * In the above example, the values
<span class="line-modified">!  * are also {@code String}s--&quot;OK&quot; and &quot;Cancel&quot;--but</span>
   * they don&#39;t have to be. The values can be any type of object.
   *
   * &lt;P&gt;
   * You retrieve an object from resource bundle using the appropriate
   * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
<span class="line-modified">!  * are both strings, you would use {@code getString} to retrieve them:</span>
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
   * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   * The getter methods all require the key as an argument and return
   * the object if found. If the object is not found, the getter method
<span class="line-modified">!  * throws a {@code MissingResourceException}.</span>
   *
   * &lt;P&gt;
<span class="line-modified">!  * Besides {@code getString}, {@code ResourceBundle} also provides</span>
<span class="line-modified">!  * a method for getting string arrays, {@code getStringArray},</span>
<span class="line-modified">!  * as well as a generic {@code getObject} method for any other</span>
<span class="line-modified">!  * type of object. When using {@code getObject}, you&#39;ll</span>
   * have to cast the result to the appropriate type. For example:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
   * &lt;P&gt;
<span class="line-modified">!  * The Java Platform provides two subclasses of {@code ResourceBundle},</span>
<span class="line-modified">!  * {@code ListResourceBundle} and {@code PropertyResourceBundle},</span>
   * that provide a fairly simple way to create resources.
<span class="line-modified">!  * As you saw briefly in a previous example, {@code ListResourceBundle}</span>
   * manages its resource as a list of key/value pairs.
<span class="line-modified">!  * {@code PropertyResourceBundle} uses a properties file to manage</span>
   * its resources.
   *
   * &lt;p&gt;
<span class="line-modified">!  * If {@code ListResourceBundle} or {@code PropertyResourceBundle}</span>
<span class="line-modified">!  * do not suit your needs, you can write your own {@code ResourceBundle}</span>
<span class="line-modified">!  * subclass.  Your subclasses must override two methods: {@code handleGetObject}</span>
<span class="line-modified">!  * and {@code getKeys()}.</span>
   *
   * &lt;p&gt;
   * The implementation of a {@code ResourceBundle} subclass must be thread-safe
   * if it&#39;s simultaneously used by multiple threads. The default implementations
   * of the non-abstract methods in this class, and the methods in the direct
   * known concrete subclasses {@code ListResourceBundle} and
   * {@code PropertyResourceBundle} are thread-safe.
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * Resource bundles can be deployed in modules in the following ways:
   *
<span class="line-modified">!  * &lt;h3&gt;Resource bundles together with an application&lt;/h3&gt;</span>
   *
   * Resource bundles can be deployed together with an application in the same
   * module.  In that case, the resource bundles are loaded
   * by code in the module by calling the {@link #getBundle(String)}
   * or {@link #getBundle(String, Locale)} method.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;service-providers&quot;&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
   * and they can be located using {@link ServiceLoader}.
   * A {@linkplain ResourceBundleProvider service} interface or class must be
   * defined. The caller module declares that it uses the service, the service
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
   *
   * &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
   * provide resource bundles in any format such XML which replaces the need
   * of {@link Control ResourceBundle.Control}.
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;other-modules&quot;&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
   * it cannot be located by code in other modules.  Resource bundles
   * in unnamed modules and class path are open for any module to access.
   * Resource bundle follows the resource encapsulation rules as specified
<span class="line-new-header">--- 230,11 ---</span>
   *
   * &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
   * provide resource bundles in any format such XML which replaces the need
   * of {@link Control ResourceBundle.Control}.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;other-modules&quot;&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
   * it cannot be located by code in other modules.  Resource bundles
   * in unnamed modules and class path are open for any module to access.
   * Resource bundle follows the resource encapsulation rules as specified
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
   * &lt;p&gt;If the caller module is a
   * &lt;a href=&quot;{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle&quot;&gt;
   * resource bundle provider&lt;/a&gt;, it does not fall back to the
   * class loader search.
   *
<span class="line-modified">!  * &lt;h4&gt;Resource bundles in automatic modules&lt;/h4&gt;</span>
   *
   * A common format of resource bundles is in {@linkplain PropertyResourceBundle
   * .properties} file format.  Typically {@code .properties} resource bundles
   * are packaged in a JAR file.  Resource bundle only JAR file can be readily
   * deployed as an &lt;a href=&quot;{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules&quot;&gt;
<span class="line-new-header">--- 253,11 ---</span>
   * &lt;p&gt;If the caller module is a
   * &lt;a href=&quot;{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle&quot;&gt;
   * resource bundle provider&lt;/a&gt;, it does not fall back to the
   * class loader search.
   *
<span class="line-modified">!  * &lt;h3&gt;Resource bundles in automatic modules&lt;/h3&gt;</span>
   *
   * A common format of resource bundles is in {@linkplain PropertyResourceBundle
   * .properties} file format.  Typically {@code .properties} resource bundles
   * are packaged in a JAR file.  Resource bundle only JAR file can be readily
   * deployed as an &lt;a href=&quot;{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules&quot;&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,12 ***</span>
   * automatic modules.
   *
   * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
   *
   * The {@link ResourceBundle.Control} class provides information necessary
<span class="line-modified">!  * to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;</span>
<span class="line-modified">!  * factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
   * instance. You can implement your own subclass in order to enable
   * non-standard resource bundle formats, change the search strategy, or
   * define caching parameters. Refer to the descriptions of the class and the
   * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
   * factory method for details.
<span class="line-new-header">--- 270,12 ---</span>
   * automatic modules.
   *
   * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
   *
   * The {@link ResourceBundle.Control} class provides information necessary
<span class="line-modified">!  * to perform the bundle loading process by the {@code getBundle}</span>
<span class="line-modified">!  * factory methods that take a {@code ResourceBundle.Control}</span>
   * instance. You can implement your own subclass in order to enable
   * non-standard resource bundle formats, change the search strategy, or
   * define caching parameters. Refer to the descriptions of the class and the
   * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
   * factory method for details.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,33 ***</span>
   * Control} will be used instead of the default {@link Control}. If there is
   * more than one service provider for supporting the same base name,
   * the first one returned from {@link ServiceLoader} will be used.
   * A custom {@link Control} implementation is ignored by named modules.
   *
<span class="line-modified">!  * &lt;h3&gt;Cache Management&lt;/h3&gt;</span>
   *
<span class="line-modified">!  * Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory</span>
   * methods are cached by default, and the factory methods return the same
   * resource bundle instance multiple times if it has been
<span class="line-modified">!  * cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the</span>
   * lifetime of cached resource bundle instances using time-to-live values,
   * or specify not to cache resource bundle instances. Refer to the
   * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
<span class="line-modified">!  * Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link</span>
   * #clearCache(ClassLoader) clearCache}, {@link
   * Control#getTimeToLive(String, Locale)
   * ResourceBundle.Control.getTimeToLive}, and {@link
   * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
   * long) ResourceBundle.Control.needsReload} for details.
   *
<span class="line-modified">!  * &lt;h3&gt;Example&lt;/h3&gt;</span>
   *
<span class="line-modified">!  * The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified">!  * subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of</span>
<span class="line-modified">!  * resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).</span>
   * Notice that you don&#39;t need to supply a value if
<span class="line-modified">!  * a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same</span>
   * key with the same value (as for the okKey below).
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * // default (English language, United States)
   * public class MyResources extends ResourceBundle {
<span class="line-new-header">--- 298,33 ---</span>
   * Control} will be used instead of the default {@link Control}. If there is
   * more than one service provider for supporting the same base name,
   * the first one returned from {@link ServiceLoader} will be used.
   * A custom {@link Control} implementation is ignored by named modules.
   *
<span class="line-modified">!  * &lt;h2&gt;Cache Management&lt;/h2&gt;</span>
   *
<span class="line-modified">!  * Resource bundle instances created by the {@code getBundle} factory</span>
   * methods are cached by default, and the factory methods return the same
   * resource bundle instance multiple times if it has been
<span class="line-modified">!  * cached. {@code getBundle} clients may clear the cache, manage the</span>
   * lifetime of cached resource bundle instances using time-to-live values,
   * or specify not to cache resource bundle instances. Refer to the
   * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
<span class="line-modified">!  * Control) {@code getBundle} factory method}, {@link</span>
   * #clearCache(ClassLoader) clearCache}, {@link
   * Control#getTimeToLive(String, Locale)
   * ResourceBundle.Control.getTimeToLive}, and {@link
   * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
   * long) ResourceBundle.Control.needsReload} for details.
   *
<span class="line-modified">!  * &lt;h2&gt;Example&lt;/h2&gt;</span>
   *
<span class="line-modified">!  * The following is a very simple example of a {@code ResourceBundle}</span>
<span class="line-modified">!  * subclass, {@code MyResources}, that manages two resources (for a larger number of</span>
<span class="line-modified">!  * resources you would probably use a {@code Map}).</span>
   * Notice that you don&#39;t need to supply a value if
<span class="line-modified">!  * a &quot;parent-level&quot; {@code ResourceBundle} handles the same</span>
   * key with the same value (as for the okKey below).
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * // default (English language, United States)
   * public class MyResources extends ResourceBundle {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,15 ***</span>
   *     }
   * }
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   * You do not have to restrict yourself to using a single family of
<span class="line-modified">!  * &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for</span>
<span class="line-modified">!  * exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;</span>
<span class="line-modified">!  * (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),</span>
<span class="line-modified">!  * and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.</span>
   *
   * @see ListResourceBundle
   * @see PropertyResourceBundle
   * @see MissingResourceException
   * @see ResourceBundleProvider
<span class="line-new-header">--- 358,15 ---</span>
   *     }
   * }
   * &lt;/pre&gt;
   * &lt;/blockquote&gt;
   * You do not have to restrict yourself to using a single family of
<span class="line-modified">!  * {@code ResourceBundle}s. For example, you could have a set of bundles for</span>
<span class="line-modified">!  * exception messages, {@code ExceptionResources}</span>
<span class="line-modified">!  * ({@code ExceptionResources_fr}, {@code ExceptionResources_de}, ...),</span>
<span class="line-modified">!  * and one for widgets, {@code WidgetResource} ({@code WidgetResources_fr},</span>
<span class="line-modified">!  * {@code WidgetResources_de}, ...); breaking up the resources however you like.</span>
   *
   * @see ListResourceBundle
   * @see PropertyResourceBundle
   * @see MissingResourceException
   * @see ResourceBundleProvider
</pre>
<hr />
<pre>
<span class="line-old-header">*** 510,13 ***</span>
       * &lt;blockquote&gt;
       * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
       * &lt;/blockquote&gt;
       *
       * @param key the key for the desired string
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException if no object for the given key can be found</span>
<span class="line-modified">!      * @exception ClassCastException if the object found for the given key is not a string</span>
       * @return the string for the given key
       */
      public final String getString(String key) {
          return (String) getObject(key);
      }
<span class="line-new-header">--- 510,13 ---</span>
       * &lt;blockquote&gt;
       * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
       * &lt;/blockquote&gt;
       *
       * @param key the key for the desired string
<span class="line-modified">!      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException if no object for the given key can be found</span>
<span class="line-modified">!      * @throws    ClassCastException if the object found for the given key is not a string</span>
       * @return the string for the given key
       */
      public final String getString(String key) {
          return (String) getObject(key);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,13 ***</span>
       * &lt;blockquote&gt;
       * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
       * &lt;/blockquote&gt;
       *
       * @param key the key for the desired string array
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException if no object for the given key can be found</span>
<span class="line-modified">!      * @exception ClassCastException if the object found for the given key is not a string array</span>
       * @return the string array for the given key
       */
      public final String[] getStringArray(String key) {
          return (String[]) getObject(key);
      }
<span class="line-new-header">--- 527,13 ---</span>
       * &lt;blockquote&gt;
       * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
       * &lt;/blockquote&gt;
       *
       * @param key the key for the desired string array
<span class="line-modified">!      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException if no object for the given key can be found</span>
<span class="line-modified">!      * @throws    ClassCastException if the object found for the given key is not a string array</span>
       * @return the string array for the given key
       */
      public final String[] getStringArray(String key) {
          return (String[]) getObject(key);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 541,16 ***</span>
      /**
       * Gets an object for the given key from this resource bundle or one of its parents.
       * This method first tries to obtain the object from this resource bundle using
       * {@link #handleGetObject(java.lang.String) handleGetObject}.
       * If not successful, and the parent resource bundle is not null,
<span class="line-modified">!      * it calls the parent&#39;s &lt;code&gt;getObject&lt;/code&gt; method.</span>
       * If still not successful, it throws a MissingResourceException.
       *
       * @param key the key for the desired object
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException if no object for the given key can be found</span>
       * @return the object for the given key
       */
      public final Object getObject(String key) {
          Object obj = handleGetObject(key);
          if (obj == null) {
<span class="line-new-header">--- 541,16 ---</span>
      /**
       * Gets an object for the given key from this resource bundle or one of its parents.
       * This method first tries to obtain the object from this resource bundle using
       * {@link #handleGetObject(java.lang.String) handleGetObject}.
       * If not successful, and the parent resource bundle is not null,
<span class="line-modified">!      * it calls the parent&#39;s {@code getObject} method.</span>
       * If still not successful, it throws a MissingResourceException.
       *
       * @param key the key for the desired object
<span class="line-modified">!      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException if no object for the given key can be found</span>
       * @return the object for the given key
       */
      public final Object getObject(String key) {
          Object obj = handleGetObject(key);
          if (obj == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,17 ***</span>
  
      /**
       * Gets a resource bundle using the specified base name, the default locale,
       * and the caller module. Calling this method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * &lt;code&gt;getBundle(baseName, Locale.getDefault(), callerModule)&lt;/code&gt;,</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName the base name of the resource bundle, a fully qualified class name
<span class="line-modified">!      * @exception java.lang.NullPointerException</span>
<span class="line-modified">!      *     if &lt;code&gt;baseName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException</span>
       *     if no resource bundle for the specified base name can be found
       * @return a resource bundle for the given base name and the default locale
       *
       * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<span class="line-new-header">--- 835,17 ---</span>
  
      /**
       * Gets a resource bundle using the specified base name, the default locale,
       * and the caller module. Calling this method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * {@code getBundle(baseName, Locale.getDefault(), callerModule)},</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName the base name of the resource bundle, a fully qualified class name
<span class="line-modified">!      * @throws    java.lang.NullPointerException</span>
<span class="line-modified">!      *     if {@code baseName} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException</span>
       *     if no resource bundle for the specified base name can be found
       * @return a resource bundle for the given base name and the default locale
       *
       * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,32 ***</span>
       * is equivalent to calling
       * &lt;pre&gt;
       * getBundle(baseName, Locale.getDefault(),
       *           this.getClass().getClassLoader(), control),
       * &lt;/pre&gt;
<span class="line-modified">!      * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security</span>
<span class="line-modified">!      * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link</span>
       * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
       * complete description of the resource bundle loading process with a
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified class
       *        name
       * @param control
       *        the control which gives information for the resource bundle
       *        loading process
       * @return a resource bundle for the given base name and the default locale
       * @throws NullPointerException
<span class="line-modified">!      *         if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;control&lt;/code&gt; is</span>
<span class="line-modified">!      *         &lt;code&gt;null&lt;/code&gt;</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name can be found
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified">!      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
<span class="line-new-header">--- 864,32 ---</span>
       * is equivalent to calling
       * &lt;pre&gt;
       * getBundle(baseName, Locale.getDefault(),
       *           this.getClass().getClassLoader(), control),
       * &lt;/pre&gt;
<span class="line-modified">!      * except that {@code getClassLoader()} is run with the security</span>
<span class="line-modified">!      * privileges of {@code ResourceBundle}.  See {@link</span>
       * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
       * complete description of the resource bundle loading process with a
<span class="line-modified">!      * {@code ResourceBundle.Control}.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified class
       *        name
       * @param control
       *        the control which gives information for the resource bundle
       *        loading process
       * @return a resource bundle for the given base name and the default locale
       * @throws NullPointerException
<span class="line-modified">!      *         if {@code baseName} or {@code control} is</span>
<span class="line-modified">!      *         {@code null}</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name can be found
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified">!      *         Note that validation of {@code control} is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,20 ***</span>
  
      /**
       * Gets a resource bundle using the specified base name and locale,
       * and the caller module. Calling this method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * &lt;code&gt;getBundle(baseName, locale, callerModule)&lt;/code&gt;,</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified class name
       * @param locale
       *        the locale for which a resource bundle is desired
<span class="line-modified">!      * @exception NullPointerException</span>
<span class="line-modified">!      *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException</span>
       *        if no resource bundle for the specified base name can be found
       * @return a resource bundle for the given base name and locale
       *
       * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<span class="line-new-header">--- 906,20 ---</span>
  
      /**
       * Gets a resource bundle using the specified base name and locale,
       * and the caller module. Calling this method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * {@code getBundle(baseName, locale, callerModule)},</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified class name
       * @param locale
       *        the locale for which a resource bundle is desired
<span class="line-modified">!      * @throws    NullPointerException</span>
<span class="line-modified">!      *        if {@code baseName} or {@code locale} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException</span>
       *        if no resource bundle for the specified base name can be found
       * @return a resource bundle for the given base name and locale
       *
       * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,11 ***</span>
  
      /**
       * Gets a resource bundle using the specified base name and the default locale
       * on behalf of the specified module. This method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * &lt;code&gt;getBundle(baseName, Locale.getDefault(), module)&lt;/code&gt;</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName the base name of the resource bundle,
       *                 a fully qualified class name
       * @param module   the module for which the resource bundle is searched
<span class="line-new-header">--- 935,11 ---</span>
  
      /**
       * Gets a resource bundle using the specified base name and the default locale
       * on behalf of the specified module. This method is equivalent to calling
       * &lt;blockquote&gt;
<span class="line-modified">!      * {@code getBundle(baseName, Locale.getDefault(), module)}</span>
       * &lt;/blockquote&gt;
       *
       * @param baseName the base name of the resource bundle,
       *                 a fully qualified class name
       * @param module   the module for which the resource bundle is searched
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,36 ***</span>
       * method is equivalent to calling
       * &lt;pre&gt;
       * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
       *           control),
       * &lt;/pre&gt;
<span class="line-modified">!      * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security</span>
<span class="line-modified">!      * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link</span>
       * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
       * complete description of the resource bundle loading process with a
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified
       *        class name
       * @param targetLocale
       *        the locale for which a resource bundle is desired
       * @param control
       *        the control which gives information for the resource
       *        bundle loading process
       * @return a resource bundle for the given base name and a
<span class="line-modified">!      *         &lt;code&gt;Locale&lt;/code&gt; in &lt;code&gt;locales&lt;/code&gt;</span>
       * @throws NullPointerException
<span class="line-modified">!      *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locales&lt;/code&gt; or</span>
<span class="line-modified">!      *         &lt;code&gt;control&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name in any
<span class="line-modified">!      *         of the &lt;code&gt;locales&lt;/code&gt; can be found.</span>
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified">!      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
<span class="line-new-header">--- 1023,36 ---</span>
       * method is equivalent to calling
       * &lt;pre&gt;
       * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
       *           control),
       * &lt;/pre&gt;
<span class="line-modified">!      * except that {@code getClassLoader()} is run with the security</span>
<span class="line-modified">!      * privileges of {@code ResourceBundle}.  See {@link</span>
       * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
       * complete description of the resource bundle loading process with a
<span class="line-modified">!      * {@code ResourceBundle.Control}.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified
       *        class name
       * @param targetLocale
       *        the locale for which a resource bundle is desired
       * @param control
       *        the control which gives information for the resource
       *        bundle loading process
       * @return a resource bundle for the given base name and a
<span class="line-modified">!      *         {@code Locale} in {@code locales}</span>
       * @throws NullPointerException
<span class="line-modified">!      *         if {@code baseName}, {@code locales} or</span>
<span class="line-modified">!      *         {@code control} is {@code null}</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name in any
<span class="line-modified">!      *         of the {@code locales} can be found.</span>
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified">!      *         Note that validation of {@code control} is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,11 ***</span>
       * behavior&lt;/a&gt;. The following describes the default behavior.
       *
       * &lt;p&gt;
       * &lt;b&gt;&lt;a id=&quot;default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;&lt;/b&gt;
       *
<span class="line-modified">!      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; uses the base name, the specified locale, and</span>
       * the default locale (obtained from {@link java.util.Locale#getDefault()
       * Locale.getDefault}) to generate a sequence of &lt;a
       * id=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
       * locale&#39;s language, script, country, and variant are all empty strings,
       * then the base name is the only candidate bundle name.  Otherwise, a list
<span class="line-new-header">--- 1088,11 ---</span>
       * behavior&lt;/a&gt;. The following describes the default behavior.
       *
       * &lt;p&gt;
       * &lt;b&gt;&lt;a id=&quot;default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;&lt;/b&gt;
       *
<span class="line-modified">!      * &lt;p&gt;{@code getBundle} uses the base name, the specified locale, and</span>
       * the default locale (obtained from {@link java.util.Locale#getDefault()
       * Locale.getDefault}) to generate a sequence of &lt;a
       * id=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
       * locale&#39;s language, script, country, and variant are all empty strings,
       * then the base name is the only candidate bundle name.  Otherwise, a list
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1138,38 ***</span>
       * MyResource_en_US_WINDOWS
       * MyResource_en_US
       * MyResource_en
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some &lt;code&gt;Locale&lt;/code&gt;s, the list of</span>
       * candidate bundle names contains extra names, or the order of bundle names
       * is slightly modified.  See the description of the default implementation
       * of {@link Control#getCandidateLocales(String, Locale)
       * getCandidateLocales} for details.&lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; then iterates over the candidate bundle names</span>
       * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
       * resource bundle. It uses the default controls&#39; {@link Control#getFormats
       * getFormats} method, which generates two bundle names for each generated
       * name, the first a class name and the second a properties file name. For
       * each candidate bundle name, it attempts to create a resource bundle:
       *
       * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
       * If such a class can be found and loaded using the specified class
       * loader, is assignment compatible with ResourceBundle, is accessible from
<span class="line-modified">!      * ResourceBundle, and can be instantiated, &lt;code&gt;getBundle&lt;/code&gt; creates a</span>
       * new instance of this class and uses it as the &lt;em&gt;result resource
       * bundle&lt;/em&gt;.
       *
<span class="line-modified">!      * &lt;li&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; attempts to locate a property</span>
       * resource file using the generated properties file name.  It generates a
       * path name from the candidate bundle name by replacing all &quot;.&quot; characters
       * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
       * &quot;resource&quot; with this name using {@link
       * java.lang.ClassLoader#getResource(java.lang.String)
       * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
<span class="line-modified">!      * &lt;code&gt;getResource&lt;/code&gt; has nothing to do with the contents of a</span>
       * resource bundle, it is just a container of data, such as a file.)  If it
       * finds a &quot;resource&quot;, it attempts to create a new {@link
       * PropertyResourceBundle} instance from its contents.  If successful, this
       * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
       *
<span class="line-new-header">--- 1138,38 ---</span>
       * MyResource_en_US_WINDOWS
       * MyResource_en_US
       * MyResource_en
       * &lt;/pre&gt;
       *
<span class="line-modified">!      * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some {@code Locale}s, the list of</span>
       * candidate bundle names contains extra names, or the order of bundle names
       * is slightly modified.  See the description of the default implementation
       * of {@link Control#getCandidateLocales(String, Locale)
       * getCandidateLocales} for details.&lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt;{@code getBundle} then iterates over the candidate bundle names</span>
       * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
       * resource bundle. It uses the default controls&#39; {@link Control#getFormats
       * getFormats} method, which generates two bundle names for each generated
       * name, the first a class name and the second a properties file name. For
       * each candidate bundle name, it attempts to create a resource bundle:
       *
       * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
       * If such a class can be found and loaded using the specified class
       * loader, is assignment compatible with ResourceBundle, is accessible from
<span class="line-modified">!      * ResourceBundle, and can be instantiated, {@code getBundle} creates a</span>
       * new instance of this class and uses it as the &lt;em&gt;result resource
       * bundle&lt;/em&gt;.
       *
<span class="line-modified">!      * &lt;li&gt;Otherwise, {@code getBundle} attempts to locate a property</span>
       * resource file using the generated properties file name.  It generates a
       * path name from the candidate bundle name by replacing all &quot;.&quot; characters
       * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
       * &quot;resource&quot; with this name using {@link
       * java.lang.ClassLoader#getResource(java.lang.String)
       * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
<span class="line-modified">!      * {@code getResource} has nothing to do with the contents of a</span>
       * resource bundle, it is just a container of data, such as a file.)  If it
       * finds a &quot;resource&quot;, it attempts to create a new {@link
       * PropertyResourceBundle} instance from its contents.  If successful, this
       * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1179,18 ***</span>
       * getFallbackLocale} method is called, which returns the current default
       * locale.  A new sequence of candidate locale names is generated using this
       * locale and searched again, as above.
       *
       * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
<span class="line-modified">!      * this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</span>
       *
       * &lt;p&gt;&lt;a id=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
       * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
       * has a parent (perhaps because it was returned from a cache) the chain is
       * complete.
       *
<span class="line-modified">!      * &lt;p&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; examines the remainder of the</span>
       * candidate locale list that was used during the pass that generated the
       * result resource bundle.  (As before, candidate bundle names where the
       * final component is an empty string are omitted.)  When it comes to the
       * end of the candidate list, it tries the plain bundle name.  With each of the
       * candidate bundle names it attempts to instantiate a resource bundle (first
<span class="line-new-header">--- 1179,18 ---</span>
       * getFallbackLocale} method is called, which returns the current default
       * locale.  A new sequence of candidate locale names is generated using this
       * locale and searched again, as above.
       *
       * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
<span class="line-modified">!      * this still fails, a {@code MissingResourceException} is thrown.</span>
       *
       * &lt;p&gt;&lt;a id=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
       * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
       * has a parent (perhaps because it was returned from a cache) the chain is
       * complete.
       *
<span class="line-modified">!      * &lt;p&gt;Otherwise, {@code getBundle} examines the remainder of the</span>
       * candidate locale list that was used during the pass that generated the
       * result resource bundle.  (As before, candidate bundle names where the
       * final component is an empty string are omitted.)  When it comes to the
       * end of the candidate list, it tries the plain bundle name.  With each of the
       * candidate bundle names it attempts to instantiate a resource bundle (first
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1201,17 ***</span>
       * with the new resource bundle.  This continues until the list of names
       * is exhausted or the current bundle already has a non-null parent.
       *
       * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;getBundle&lt;/code&gt; caches instantiated resource</span>
       * bundles and might return the same resource bundle instance multiple times.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The &lt;code&gt;baseName&lt;/code&gt; argument should be a fully</span>
       * qualified class name. However, for compatibility with earlier versions,
       * Java SE Runtime Environments do not verify this, and so it is
<span class="line-modified">!      * possible to access &lt;code&gt;PropertyResourceBundle&lt;/code&gt;s by specifying a</span>
       * path name (using &quot;/&quot;) instead of a fully qualified class name (using
       * &quot;.&quot;).
       *
       * &lt;p&gt;&lt;a id=&quot;default_behavior_example&quot;&gt;
       * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
<span class="line-new-header">--- 1201,17 ---</span>
       * with the new resource bundle.  This continues until the list of names
       * is exhausted or the current bundle already has a non-null parent.
       *
       * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; {@code getBundle} caches instantiated resource</span>
       * bundles and might return the same resource bundle instance multiple times.
       *
<span class="line-modified">!      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The {@code baseName} argument should be a fully</span>
       * qualified class name. However, for compatibility with earlier versions,
       * Java SE Runtime Environments do not verify this, and so it is
<span class="line-modified">!      * possible to access {@code PropertyResourceBundle}s by specifying a</span>
       * path name (using &quot;/&quot;) instead of a fully qualified class name (using
       * &quot;.&quot;).
       *
       * &lt;p&gt;&lt;a id=&quot;default_behavior_example&quot;&gt;
       * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1226,15 ***</span>
       *     &lt;li&gt;MyResources_en.properties
       *     &lt;li&gt;MyResources_es_ES.class
       * &lt;/ul&gt;
       *
       * The contents of all files are valid (that is, public non-abstract
<span class="line-modified">!      * subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files,</span>
       * syntactically correct &quot;.properties&quot; files).  The default locale is
<span class="line-modified">!      * &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt;Calling &lt;code&gt;getBundle&lt;/code&gt; with the locale arguments below will</span>
       * instantiate resource bundles as follows:
       *
       * &lt;table class=&quot;striped&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;getBundle() locale to resource bundle mapping&lt;/caption&gt;
       * &lt;thead&gt;
<span class="line-new-header">--- 1226,15 ---</span>
       *     &lt;li&gt;MyResources_en.properties
       *     &lt;li&gt;MyResources_es_ES.class
       * &lt;/ul&gt;
       *
       * The contents of all files are valid (that is, public non-abstract
<span class="line-modified">!      * subclasses of {@code ResourceBundle} for the &quot;.class&quot; files,</span>
       * syntactically correct &quot;.properties&quot; files).  The default locale is
<span class="line-modified">!      * {@code Locale(&quot;en&quot;, &quot;GB&quot;)}.</span>
       *
<span class="line-modified">!      * &lt;p&gt;Calling {@code getBundle} with the locale arguments below will</span>
       * instantiate resource bundles as follows:
       *
       * &lt;table class=&quot;striped&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;getBundle() locale to resource bundle mapping&lt;/caption&gt;
       * &lt;thead&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1262,13 ***</span>
       *
       * @param baseName the base name of the resource bundle, a fully qualified class name
       * @param locale the locale for which a resource bundle is desired
       * @param loader the class loader from which to load the resource bundle
       * @return a resource bundle for the given base name and locale
<span class="line-modified">!      * @exception java.lang.NullPointerException</span>
<span class="line-modified">!      *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      * @exception MissingResourceException</span>
       *        if no resource bundle for the specified base name can be found
       * @since 1.2
       * @revised 9
       * @spec JPMS
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<span class="line-new-header">--- 1262,13 ---</span>
       *
       * @param baseName the base name of the resource bundle, a fully qualified class name
       * @param locale the locale for which a resource bundle is desired
       * @param loader the class loader from which to load the resource bundle
       * @return a resource bundle for the given base name and locale
<span class="line-modified">!      * @throws    java.lang.NullPointerException</span>
<span class="line-modified">!      *        if {@code baseName}, {@code locale}, or {@code loader} is {@code null}</span>
<span class="line-modified">!      * @throws    MissingResourceException</span>
       *        if no resource bundle for the specified base name can be found
       * @since 1.2
       * @revised 9
       * @spec JPMS
       * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1287,100 ***</span>
      /**
       * Returns a resource bundle using the specified base name, target
       * locale, class loader and control. Unlike the {@link
       * #getBundle(String, Locale, ClassLoader) getBundle}
       * factory methods with no {@code control} argument, the given
<span class="line-modified">!      * &lt;code&gt;control&lt;/code&gt; specifies how to locate and instantiate resource</span>
       * bundles. Conceptually, the bundle loading process with the given
<span class="line-modified">!      * &lt;code&gt;control&lt;/code&gt; is performed in the following steps.</span>
       *
       * &lt;ol&gt;
       * &lt;li&gt;This factory method looks up the resource bundle in the cache for
<span class="line-modified">!      * the specified &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;loader&lt;/code&gt;.  If the requested resource bundle instance is</span>
       * found in the cache and the time-to-live periods of the instance and
       * all of its parent instances have not expired, the instance is returned
       * to the caller. Otherwise, this factory method proceeds with the
       * loading process below.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)
       * control.getFormats} method is called to get resource bundle formats
       * to produce bundle or resource names. The strings
<span class="line-modified">!      * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;</span>
       * designate class-based and {@linkplain PropertyResourceBundle
       * property}-based resource bundles, respectively. Other strings
<span class="line-modified">!      * starting with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions</span>
       * and must not be used for application-defined formats. Other strings
       * designate application-defined formats.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
       * Locale) control.getCandidateLocales} method is called with the target
<span class="line-modified">!      * locale to get a list of &lt;em&gt;candidate &lt;code&gt;Locale&lt;/code&gt;s&lt;/em&gt; for</span>
       * which resource bundles are searched.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
       * String, ClassLoader, boolean) control.newBundle} method is called to
<span class="line-modified">!      * instantiate a &lt;code&gt;ResourceBundle&lt;/code&gt; for the base bundle name, a</span>
       * candidate locale, and a format. (Refer to the note on the cache
       * lookup below.) This step is iterated over all combinations of the
<span class="line-modified">!      * candidate locales and formats until the &lt;code&gt;newBundle&lt;/code&gt; method</span>
<span class="line-modified">!      * returns a &lt;code&gt;ResourceBundle&lt;/code&gt; instance or the iteration has</span>
       * used up all the combinations. For example, if the candidate locales
<span class="line-modified">!      * are &lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;, &lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; and the formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;</span>
<span class="line-modified">!      * and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, then the following is the</span>
       * sequence of locale-format combinations to be used to call
<span class="line-modified">!      * &lt;code&gt;control.newBundle&lt;/code&gt;.</span>
       *
       * &lt;table class=striped style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;locale-format combinations for newBundle&lt;/caption&gt;
       * &lt;thead&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;col&quot;&gt;Index&lt;/th&gt;
<span class="line-modified">!      * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/th&gt;</span>
<span class="line-modified">!      * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/th&gt;</span>
       * &lt;/tr&gt;
       * &lt;/thead&gt;
       * &lt;tbody&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;6&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;/tbody&gt;
       * &lt;/table&gt;
       * &lt;/li&gt;
       *
       * &lt;li&gt;If the previous step has found no resource bundle, proceed to
       * Step 6. If a bundle has been found that is a base bundle (a bundle
<span class="line-modified">!      * for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained</span>
<span class="line-modified">!      * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle</span>
       * has been found that is a base bundle, but the candidate locale list
       * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
       * proceed to Step 6. If a bundle has been found that is not a base
       * bundle, proceed to Step 7.&lt;/li&gt;
       *
<span class="line-new-header">--- 1287,100 ---</span>
      /**
       * Returns a resource bundle using the specified base name, target
       * locale, class loader and control. Unlike the {@link
       * #getBundle(String, Locale, ClassLoader) getBundle}
       * factory methods with no {@code control} argument, the given
<span class="line-modified">!      * {@code control} specifies how to locate and instantiate resource</span>
       * bundles. Conceptually, the bundle loading process with the given
<span class="line-modified">!      * {@code control} is performed in the following steps.</span>
       *
       * &lt;ol&gt;
       * &lt;li&gt;This factory method looks up the resource bundle in the cache for
<span class="line-modified">!      * the specified {@code baseName}, {@code targetLocale} and</span>
<span class="line-modified">!      * {@code loader}.  If the requested resource bundle instance is</span>
       * found in the cache and the time-to-live periods of the instance and
       * all of its parent instances have not expired, the instance is returned
       * to the caller. Otherwise, this factory method proceeds with the
       * loading process below.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)
       * control.getFormats} method is called to get resource bundle formats
       * to produce bundle or resource names. The strings
<span class="line-modified">!      * {@code &quot;java.class&quot;} and {@code &quot;java.properties&quot;}</span>
       * designate class-based and {@linkplain PropertyResourceBundle
       * property}-based resource bundles, respectively. Other strings
<span class="line-modified">!      * starting with {@code &quot;java.&quot;} are reserved for future extensions</span>
       * and must not be used for application-defined formats. Other strings
       * designate application-defined formats.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
       * Locale) control.getCandidateLocales} method is called with the target
<span class="line-modified">!      * locale to get a list of &lt;em&gt;candidate {@code Locale}s&lt;/em&gt; for</span>
       * which resource bundles are searched.&lt;/li&gt;
       *
       * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
       * String, ClassLoader, boolean) control.newBundle} method is called to
<span class="line-modified">!      * instantiate a {@code ResourceBundle} for the base bundle name, a</span>
       * candidate locale, and a format. (Refer to the note on the cache
       * lookup below.) This step is iterated over all combinations of the
<span class="line-modified">!      * candidate locales and formats until the {@code newBundle} method</span>
<span class="line-modified">!      * returns a {@code ResourceBundle} instance or the iteration has</span>
       * used up all the combinations. For example, if the candidate locales
<span class="line-modified">!      * are {@code Locale(&quot;de&quot;, &quot;DE&quot;)}, {@code Locale(&quot;de&quot;)} and</span>
<span class="line-modified">!      * {@code Locale(&quot;&quot;)} and the formats are {@code &quot;java.class&quot;}</span>
<span class="line-modified">!      * and {@code &quot;java.properties&quot;}, then the following is the</span>
       * sequence of locale-format combinations to be used to call
<span class="line-modified">!      * {@code control.newBundle}.</span>
       *
       * &lt;table class=striped style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;locale-format combinations for newBundle&lt;/caption&gt;
       * &lt;thead&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;col&quot;&gt;Index&lt;/th&gt;
<span class="line-modified">!      * &lt;th scope=&quot;col&quot;&gt;{@code Locale}&lt;/th&gt;</span>
<span class="line-modified">!      * &lt;th scope=&quot;col&quot;&gt;{@code format}&lt;/th&gt;</span>
       * &lt;/tr&gt;
       * &lt;/thead&gt;
       * &lt;tbody&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;de&quot;, &quot;DE&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;de&quot;, &quot;DE&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;de&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;de&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       * &lt;th scope=&quot;row&quot;&gt;6&lt;/th&gt;
<span class="line-modified">!      * &lt;td&gt;{@code Locale(&quot;&quot;)}&lt;/td&gt;</span>
<span class="line-modified">!      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;/tbody&gt;
       * &lt;/table&gt;
       * &lt;/li&gt;
       *
       * &lt;li&gt;If the previous step has found no resource bundle, proceed to
       * Step 6. If a bundle has been found that is a base bundle (a bundle
<span class="line-modified">!      * for {@code Locale(&quot;&quot;)}), and the candidate locale list only contained</span>
<span class="line-modified">!      * {@code Locale(&quot;&quot;)}, return the bundle to the caller. If a bundle</span>
       * has been found that is a base bundle, but the candidate locale list
       * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
       * proceed to Step 6. If a bundle has been found that is not a base
       * bundle, proceed to Step 7.&lt;/li&gt;
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1408,69 ***</span>
       * resource bundle found in the cache has expired, the factory method
       * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
       * String, ClassLoader, ResourceBundle, long) control.needsReload}
       * method to determine whether the resource bundle needs to be reloaded.
       * If reloading is required, the factory method calls
<span class="line-modified">!      * &lt;code&gt;control.newBundle&lt;/code&gt; to reload the resource bundle.  If</span>
<span class="line-modified">!      * &lt;code&gt;control.newBundle&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the factory</span>
       * method puts a dummy resource bundle in the cache as a mark of
       * nonexistent resource bundles in order to avoid lookup overhead for
       * subsequent requests. Such dummy resource bundles are under the same
<span class="line-modified">!      * expiration control as specified by &lt;code&gt;control&lt;/code&gt;.</span>
       *
       * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
       * {@link Control#getTimeToLive(String,Locale)
       * control.getTimeToLive} for details.
       *
       * &lt;p&gt;The following is an example of the bundle loading process with the
<span class="line-modified">!      * default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.</span>
       *
       * &lt;p&gt;Conditions:
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;Base bundle name: &lt;code&gt;foo.bar.Messages&lt;/code&gt;</span>
<span class="line-modified">!      * &lt;li&gt;Requested &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#ITALY}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;Default &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#FRENCH}&lt;/li&gt;</span>
       * &lt;li&gt;Available resource bundles:
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;First, &lt;code&gt;getBundle&lt;/code&gt; tries loading a resource bundle in</span>
       * the following sequence.
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it_IT&lt;/code&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it_IT.properties&lt;/code&gt;</span>
<span class="line-modified">!      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it.properties&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;At this point, &lt;code&gt;getBundle&lt;/code&gt; finds</span>
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold</span>
<span class="line-modified">!      * because it&#39;s the base bundle.  &lt;code&gt;getBundle&lt;/code&gt; calls {@link</span>
       * Control#getFallbackLocale(String, Locale)
       * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
<span class="line-modified">!      * returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt;</span>
       * tries loading a bundle in the following sequence.
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_fr&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; finds</span>
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and creates a</span>
<span class="line-modified">!      * &lt;code&gt;ResourceBundle&lt;/code&gt; instance. Then, &lt;code&gt;getBundle&lt;/code&gt;</span>
       * sets up its parent chain from the list of the candidate locales.  Only
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; is found in the list and</span>
<span class="line-modified">!      * &lt;code&gt;getBundle&lt;/code&gt; creates a &lt;code&gt;ResourceBundle&lt;/code&gt; instance</span>
       * that becomes the parent of the instance for
<span class="line-modified">!      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified
       *        class name
       * @param targetLocale
<span class="line-new-header">--- 1408,69 ---</span>
       * resource bundle found in the cache has expired, the factory method
       * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
       * String, ClassLoader, ResourceBundle, long) control.needsReload}
       * method to determine whether the resource bundle needs to be reloaded.
       * If reloading is required, the factory method calls
<span class="line-modified">!      * {@code control.newBundle} to reload the resource bundle.  If</span>
<span class="line-modified">!      * {@code control.newBundle} returns {@code null}, the factory</span>
       * method puts a dummy resource bundle in the cache as a mark of
       * nonexistent resource bundles in order to avoid lookup overhead for
       * subsequent requests. Such dummy resource bundles are under the same
<span class="line-modified">!      * expiration control as specified by {@code control}.</span>
       *
       * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
       * {@link Control#getTimeToLive(String,Locale)
       * control.getTimeToLive} for details.
       *
       * &lt;p&gt;The following is an example of the bundle loading process with the
<span class="line-modified">!      * default {@code ResourceBundle.Control} implementation.</span>
       *
       * &lt;p&gt;Conditions:
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;Base bundle name: {@code foo.bar.Messages}</span>
<span class="line-modified">!      * &lt;li&gt;Requested {@code Locale}: {@link Locale#ITALY}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;Default {@code Locale}: {@link Locale#FRENCH}&lt;/li&gt;</span>
       * &lt;li&gt;Available resource bundles:
<span class="line-modified">!      * {@code foo/bar/Messages_fr.properties} and</span>
<span class="line-modified">!      * {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;First, {@code getBundle} tries loading a resource bundle in</span>
       * the following sequence.
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;class {@code foo.bar.Messages_it_IT}</span>
<span class="line-modified">!      * &lt;li&gt;file {@code foo/bar/Messages_it_IT.properties}</span>
<span class="line-modified">!      * &lt;li&gt;class {@code foo.bar.Messages_it}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file {@code foo/bar/Messages_it.properties}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;class {@code foo.bar.Messages}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;At this point, {@code getBundle} finds</span>
<span class="line-modified">!      * {@code foo/bar/Messages.properties}, which is put on hold</span>
<span class="line-modified">!      * because it&#39;s the base bundle.  {@code getBundle} calls {@link</span>
       * Control#getFallbackLocale(String, Locale)
       * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
<span class="line-modified">!      * returns {@code Locale.FRENCH}. Next, {@code getBundle}</span>
       * tries loading a bundle in the following sequence.
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt;class {@code foo.bar.Messages_fr}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file {@code foo/bar/Messages_fr.properties}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;class {@code foo.bar.Messages}&lt;/li&gt;</span>
<span class="line-modified">!      * &lt;li&gt;file {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;{@code getBundle} finds</span>
<span class="line-modified">!      * {@code foo/bar/Messages_fr.properties} and creates a</span>
<span class="line-modified">!      * {@code ResourceBundle} instance. Then, {@code getBundle}</span>
       * sets up its parent chain from the list of the candidate locales.  Only
<span class="line-modified">!      * {@code foo/bar/Messages.properties} is found in the list and</span>
<span class="line-modified">!      * {@code getBundle} creates a {@code ResourceBundle} instance</span>
       * that becomes the parent of the instance for
<span class="line-modified">!      * {@code foo/bar/Messages_fr.properties}.</span>
       *
       * @param baseName
       *        the base name of the resource bundle, a fully qualified
       *        class name
       * @param targetLocale
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1480,19 ***</span>
       * @param control
       *        the control which gives information for the resource
       *        bundle loading process
       * @return a resource bundle for the given base name and locale
       * @throws NullPointerException
<span class="line-modified">!      *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt;,</span>
<span class="line-modified">!      *         &lt;code&gt;loader&lt;/code&gt;, or &lt;code&gt;control&lt;/code&gt; is</span>
<span class="line-modified">!      *         &lt;code&gt;null&lt;/code&gt;</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name can be found
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified">!      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
<span class="line-new-header">--- 1480,19 ---</span>
       * @param control
       *        the control which gives information for the resource
       *        bundle loading process
       * @return a resource bundle for the given base name and locale
       * @throws NullPointerException
<span class="line-modified">!      *         if {@code baseName}, {@code targetLocale},</span>
<span class="line-modified">!      *         {@code loader}, or {@code control} is</span>
<span class="line-modified">!      *         {@code null}</span>
       * @throws MissingResourceException
       *         if no resource bundle for the specified base name can be found
       * @throws IllegalArgumentException
<span class="line-modified">!      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified">!      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified">!      *         Note that validation of {@code control} is performed as</span>
       *         needed.
       * @throws UnsupportedOperationException
       *         if this method is called in a named module
       * @since 1.6
       * @revised 9
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1698,11 ***</span>
  
          return bundle;
      }
  
      /**
<span class="line-modified">!      * Checks if the given &lt;code&gt;List&lt;/code&gt; is not null, not empty,</span>
       * not having null in its elements.
       */
      private static boolean checkList(List&lt;?&gt; a) {
          boolean valid = (a != null &amp;&amp; !a.isEmpty());
          if (valid) {
<span class="line-new-header">--- 1698,11 ---</span>
  
          return bundle;
      }
  
      /**
<span class="line-modified">!      * Checks if the given {@code List} is not null, not empty,</span>
       * not having null in its elements.
       */
      private static boolean checkList(List&lt;?&gt; a) {
          boolean valid = (a != null &amp;&amp; !a.isEmpty());
          if (valid) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2064,11 ***</span>
       * `expired&#39; and removed from the cache upon return.
       *
       * @param cacheKey the key to look up the cache
       * @param control the Control to be used for the expiration control
       * @return the cached bundle, or null if the bundle is not found in the
<span class="line-modified">!      * cache or its parent has expired. &lt;code&gt;bundle.expire&lt;/code&gt; is true</span>
       * upon return if the bundle in the cache has expired.
       */
      private static ResourceBundle findBundleInCache(CacheKey cacheKey,
                                                      Control control) {
          BundleReference bundleRef = cacheList.get(cacheKey);
<span class="line-new-header">--- 2064,11 ---</span>
       * `expired&#39; and removed from the cache upon return.
       *
       * @param cacheKey the key to look up the cache
       * @param control the Control to be used for the expiration control
       * @return the cached bundle, or null if the bundle is not found in the
<span class="line-modified">!      * cache or its parent has expired. {@code bundle.expire} is true</span>
       * upon return if the bundle in the cache has expired.
       */
      private static ResourceBundle findBundleInCache(CacheKey cacheKey,
                                                      Control control) {
          BundleReference bundleRef = cacheList.get(cacheKey);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2248,11 ***</span>
      /**
       * Removes all resource bundles from the cache that have been loaded
       * by the given class loader.
       *
       * @param loader the class loader
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;loader&lt;/code&gt; is null</span>
       * @since 1.6
       * @see ResourceBundle.Control#getTimeToLive(String,Locale)
       */
      public static final void clearCache(ClassLoader loader) {
          Objects.requireNonNull(loader);
<span class="line-new-header">--- 2248,11 ---</span>
      /**
       * Removes all resource bundles from the cache that have been loaded
       * by the given class loader.
       *
       * @param loader the class loader
<span class="line-modified">!      * @throws    NullPointerException if {@code loader} is null</span>
       * @since 1.6
       * @see ResourceBundle.Control#getTimeToLive(String,Locale)
       */
      public static final void clearCache(ClassLoader loader) {
          Objects.requireNonNull(loader);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2269,34 ***</span>
       * Gets an object for the given key from this resource bundle.
       * Returns null if this resource bundle does not contain an
       * object for the given key.
       *
       * @param key the key for the desired object
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @return the object for the given key, or null
       */
      protected abstract Object handleGetObject(String key);
  
      /**
       * Returns an enumeration of the keys.
       *
<span class="line-modified">!      * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the keys contained in</span>
<span class="line-modified">!      *         this &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
       */
      public abstract Enumeration&lt;String&gt; getKeys();
  
      /**
<span class="line-modified">!      * Determines whether the given &lt;code&gt;key&lt;/code&gt; is contained in</span>
<span class="line-modified">!      * this &lt;code&gt;ResourceBundle&lt;/code&gt; or its parent bundles.</span>
       *
       * @param key
<span class="line-modified">!      *        the resource &lt;code&gt;key&lt;/code&gt;</span>
<span class="line-modified">!      * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;key&lt;/code&gt; is</span>
<span class="line-modified">!      *        contained in this &lt;code&gt;ResourceBundle&lt;/code&gt; or its</span>
<span class="line-modified">!      *        parent bundles; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">!      * @exception NullPointerException</span>
<span class="line-modified">!      *         if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @since 1.6
       */
      public boolean containsKey(String key) {
          if (key == null) {
              throw new NullPointerException();
<span class="line-new-header">--- 2269,34 ---</span>
       * Gets an object for the given key from this resource bundle.
       * Returns null if this resource bundle does not contain an
       * object for the given key.
       *
       * @param key the key for the desired object
<span class="line-modified">!      * @throws    NullPointerException if {@code key} is {@code null}</span>
       * @return the object for the given key, or null
       */
      protected abstract Object handleGetObject(String key);
  
      /**
       * Returns an enumeration of the keys.
       *
<span class="line-modified">!      * @return an {@code Enumeration} of the keys contained in</span>
<span class="line-modified">!      *         this {@code ResourceBundle} and its parent bundles.</span>
       */
      public abstract Enumeration&lt;String&gt; getKeys();
  
      /**
<span class="line-modified">!      * Determines whether the given {@code key} is contained in</span>
<span class="line-modified">!      * this {@code ResourceBundle} or its parent bundles.</span>
       *
       * @param key
<span class="line-modified">!      *        the resource {@code key}</span>
<span class="line-modified">!      * @return {@code true} if the given {@code key} is</span>
<span class="line-modified">!      *        contained in this {@code ResourceBundle} or its</span>
<span class="line-modified">!      *        parent bundles; {@code false} otherwise.</span>
<span class="line-modified">!      * @throws    NullPointerException</span>
<span class="line-modified">!      *         if {@code key} is {@code null}</span>
       * @since 1.6
       */
      public boolean containsKey(String key) {
          if (key == null) {
              throw new NullPointerException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2308,15 ***</span>
          }
          return false;
      }
  
      /**
<span class="line-modified">!      * Returns a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this</span>
<span class="line-modified">!      * &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
       *
<span class="line-modified">!      * @return a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this</span>
<span class="line-modified">!      *         &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
       * @since 1.6
       */
      public Set&lt;String&gt; keySet() {
          Set&lt;String&gt; keys = new HashSet&lt;&gt;();
          for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
<span class="line-new-header">--- 2308,15 ---</span>
          }
          return false;
      }
  
      /**
<span class="line-modified">!      * Returns a {@code Set} of all keys contained in this</span>
<span class="line-modified">!      * {@code ResourceBundle} and its parent bundles.</span>
       *
<span class="line-modified">!      * @return a {@code Set} of all keys contained in this</span>
<span class="line-modified">!      *         {@code ResourceBundle} and its parent bundles.</span>
       * @since 1.6
       */
      public Set&lt;String&gt; keySet() {
          Set&lt;String&gt; keys = new HashSet&lt;&gt;();
          for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2324,24 ***</span>
          }
          return keys;
      }
  
      /**
<span class="line-modified">!      * Returns a &lt;code&gt;Set&lt;/code&gt; of the keys contained &lt;em&gt;only&lt;/em&gt;</span>
<span class="line-modified">!      * in this &lt;code&gt;ResourceBundle&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the</span>
       * keys returned by the {@link #getKeys() getKeys} method except
       * for the ones for which the {@link #handleGetObject(String)
<span class="line-modified">!      * handleGetObject} method returns &lt;code&gt;null&lt;/code&gt;. Once the</span>
<span class="line-modified">!      * &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this</span>
<span class="line-modified">!      * &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the</span>
<span class="line-modified">!      * same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can</span>
       * override this method for faster handling.
       *
<span class="line-modified">!      * @return a &lt;code&gt;Set&lt;/code&gt; of the keys contained only in this</span>
<span class="line-modified">!      *        &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
       * @since 1.6
       */
      protected Set&lt;String&gt; handleKeySet() {
          if (keySet == null) {
              synchronized (this) {
<span class="line-new-header">--- 2324,24 ---</span>
          }
          return keys;
      }
  
      /**
<span class="line-modified">!      * Returns a {@code Set} of the keys contained &lt;em&gt;only&lt;/em&gt;</span>
<span class="line-modified">!      * in this {@code ResourceBundle}.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The default implementation returns a {@code Set} of the</span>
       * keys returned by the {@link #getKeys() getKeys} method except
       * for the ones for which the {@link #handleGetObject(String)
<span class="line-modified">!      * handleGetObject} method returns {@code null}. Once the</span>
<span class="line-modified">!      * {@code Set} has been created, the value is kept in this</span>
<span class="line-modified">!      * {@code ResourceBundle} in order to avoid producing the</span>
<span class="line-modified">!      * same {@code Set} in subsequent calls. Subclasses can</span>
       * override this method for faster handling.
       *
<span class="line-modified">!      * @return a {@code Set} of the keys contained only in this</span>
<span class="line-modified">!      *        {@code ResourceBundle}</span>
       * @since 1.6
       */
      protected Set&lt;String&gt; handleKeySet() {
          if (keySet == null) {
              synchronized (this) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2362,15 ***</span>
      }
  
  
  
      /**
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; defines a set of callback methods</span>
       * that are invoked by the {@link ResourceBundle#getBundle(String,
       * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
       * methods during the bundle loading process. In other words, a
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; collaborates with the factory</span>
       * methods for loading resource bundles. The default implementation of
       * the callback methods provides the information necessary for the
       * factory methods to perform the &lt;a
       * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
       *
<span class="line-new-header">--- 2362,15 ---</span>
      }
  
  
  
      /**
<span class="line-modified">!      * {@code ResourceBundle.Control} defines a set of callback methods</span>
       * that are invoked by the {@link ResourceBundle#getBundle(String,
       * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
       * methods during the bundle loading process. In other words, a
<span class="line-modified">!      * {@code ResourceBundle.Control} collaborates with the factory</span>
       * methods for loading resource bundles. The default implementation of
       * the callback methods provides the information necessary for the
       * factory methods to perform the &lt;a
       * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2384,49 ***</span>
       *
       * &lt;p&gt;In addition to the callback methods, the {@link
       * #toBundleName(String, Locale) toBundleName} and {@link
       * #toResourceName(String, String) toResourceName} methods are defined
       * primarily for convenience in implementing the callback
<span class="line-modified">!      * methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be</span>
       * overridden to provide different conventions in the organization and
<span class="line-modified">!      * packaging of localized resources.  The &lt;code&gt;toResourceName&lt;/code&gt;</span>
<span class="line-modified">!      * method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class</span>
       * name separators.
       *
       * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link
       * #getNoFallbackControl(List)}, provide
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances that implement common</span>
       * variations of the default bundle loading process.
       *
       * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)
       * getFormats} method and candidate locales returned by the {@link
       * ResourceBundle.Control#getCandidateLocales(String, Locale)
       * getCandidateLocales} method must be consistent in all
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base</span>
<span class="line-modified">!      * bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods</span>
       * may return unintended bundles. For example, if only
<span class="line-modified">!      * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt;</span>
<span class="line-modified">!      * method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
<span class="line-modified">!      * and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the</span>
       * second call will return the class-based one that has been cached
       * during the first call.
       *
<span class="line-modified">!      * &lt;p&gt;A &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instance must be thread-safe</span>
       * if it&#39;s simultaneously used by multiple threads.
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; does not synchronize to call</span>
<span class="line-modified">!      * the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; methods. The default</span>
       * implementations of the methods are thread-safe.
       *
<span class="line-modified">!      * &lt;p&gt;Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
<span class="line-modified">!      * instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or</span>
<span class="line-modified">!      * created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to</span>
       * customize the bundle loading process. The following are examples of
       * changing the default bundle loading process.
       *
       * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
       *
<span class="line-modified">!      * &lt;p&gt;The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look</span>
       * up only properties-based resources.
       *
       * &lt;pre&gt;
       * import java.util.*;
       * import static java.util.ResourceBundle.Control.*;
<span class="line-new-header">--- 2384,49 ---</span>
       *
       * &lt;p&gt;In addition to the callback methods, the {@link
       * #toBundleName(String, Locale) toBundleName} and {@link
       * #toResourceName(String, String) toResourceName} methods are defined
       * primarily for convenience in implementing the callback
<span class="line-modified">!      * methods. However, the {@code toBundleName} method could be</span>
       * overridden to provide different conventions in the organization and
<span class="line-modified">!      * packaging of localized resources.  The {@code toResourceName}</span>
<span class="line-modified">!      * method is {@code final} to avoid use of wrong resource and class</span>
       * name separators.
       *
       * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link
       * #getNoFallbackControl(List)}, provide
<span class="line-modified">!      * {@code ResourceBundle.Control} instances that implement common</span>
       * variations of the default bundle loading process.
       *
       * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)
       * getFormats} method and candidate locales returned by the {@link
       * ResourceBundle.Control#getCandidateLocales(String, Locale)
       * getCandidateLocales} method must be consistent in all
<span class="line-modified">!      * {@code ResourceBundle.getBundle} invocations for the same base</span>
<span class="line-modified">!      * bundle. Otherwise, the {@code ResourceBundle.getBundle} methods</span>
       * may return unintended bundles. For example, if only
<span class="line-modified">!      * {@code &quot;java.class&quot;} is returned by the {@code getFormats}</span>
<span class="line-modified">!      * method for the first call to {@code ResourceBundle.getBundle}</span>
<span class="line-modified">!      * and only {@code &quot;java.properties&quot;} for the second call, then the</span>
       * second call will return the class-based one that has been cached
       * during the first call.
       *
<span class="line-modified">!      * &lt;p&gt;A {@code ResourceBundle.Control} instance must be thread-safe</span>
       * if it&#39;s simultaneously used by multiple threads.
<span class="line-modified">!      * {@code ResourceBundle.getBundle} does not synchronize to call</span>
<span class="line-modified">!      * the {@code ResourceBundle.Control} methods. The default</span>
       * implementations of the methods are thread-safe.
       *
<span class="line-modified">!      * &lt;p&gt;Applications can specify {@code ResourceBundle.Control}</span>
<span class="line-modified">!      * instances returned by the {@code getControl} factory methods or</span>
<span class="line-modified">!      * created from a subclass of {@code ResourceBundle.Control} to</span>
       * customize the bundle loading process. The following are examples of
       * changing the default bundle loading process.
       *
       * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
       *
<span class="line-modified">!      * &lt;p&gt;The following code lets {@code ResourceBundle.getBundle} look</span>
       * up only properties-based resources.
       *
       * &lt;pre&gt;
       * import java.util.*;
       * import static java.util.ResourceBundle.Control.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2436,16 ***</span>
       *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
       * &lt;/pre&gt;
       *
       * Given the resource bundles in the &lt;a
       * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
<span class="line-modified">!      * the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; description, this</span>
<span class="line-modified">!      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; call loads</span>
<span class="line-modified">!      * &lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt; whose parent is</span>
<span class="line-modified">!      * &lt;code&gt;MyResources_fr.properties&lt;/code&gt; whose parent is</span>
<span class="line-modified">!      * &lt;code&gt;MyResources.properties&lt;/code&gt;. (&lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt;</span>
<span class="line-modified">!      * is not hidden, but &lt;code&gt;MyResources_fr_CH.class&lt;/code&gt; is.)</span>
       *
       * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
       *
       * &lt;p&gt;The following is an example of loading XML-based bundles
       * using {@link Properties#loadFromXML(java.io.InputStream)
<span class="line-new-header">--- 2436,16 ---</span>
       *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
       * &lt;/pre&gt;
       *
       * Given the resource bundles in the &lt;a
       * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
<span class="line-modified">!      * the {@code ResourceBundle.getBundle} description, this</span>
<span class="line-modified">!      * {@code ResourceBundle.getBundle} call loads</span>
<span class="line-modified">!      * {@code MyResources_fr_CH.properties} whose parent is</span>
<span class="line-modified">!      * {@code MyResources_fr.properties} whose parent is</span>
<span class="line-modified">!      * {@code MyResources.properties}. ({@code MyResources_fr_CH.properties}</span>
<span class="line-modified">!      * is not hidden, but {@code MyResources_fr_CH.class} is.)</span>
       *
       * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
       *
       * &lt;p&gt;The following is an example of loading XML-based bundles
       * using {@link Properties#loadFromXML(java.io.InputStream)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2527,30 ***</span>
       * @spec JPMS
       * @see java.util.spi.ResourceBundleProvider
       */
      public static class Control {
          /**
<span class="line-modified">!          * The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings</span>
<span class="line-modified">!          * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in</span>
<span class="line-modified">!          * this order. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_DEFAULT
              = List.of(&quot;java.class&quot;, &quot;java.properties&quot;);
  
          /**
<span class="line-modified">!          * The class-only format &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">!          * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_CLASS = List.of(&quot;java.class&quot;);
  
          /**
<span class="line-modified">!          * The properties-only format &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">!          * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_PROPERTIES
              = List.of(&quot;java.properties&quot;);
<span class="line-new-header">--- 2527,30 ---</span>
       * @spec JPMS
       * @see java.util.spi.ResourceBundleProvider
       */
      public static class Control {
          /**
<span class="line-modified">!          * The default format {@code List}, which contains the strings</span>
<span class="line-modified">!          * {@code &quot;java.class&quot;} and {@code &quot;java.properties&quot;}, in</span>
<span class="line-modified">!          * this order. This {@code List} is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_DEFAULT
              = List.of(&quot;java.class&quot;, &quot;java.properties&quot;);
  
          /**
<span class="line-modified">!          * The class-only format {@code List} containing</span>
<span class="line-modified">!          * {@code &quot;java.class&quot;}. This {@code List} is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_CLASS = List.of(&quot;java.class&quot;);
  
          /**
<span class="line-modified">!          * The properties-only format {@code List} containing</span>
<span class="line-modified">!          * {@code &quot;java.properties&quot;}. This {@code List} is unmodifiable.</span>
           *
           * @see #getFormats(String)
           */
          public static final List&lt;String&gt; FORMAT_PROPERTIES
              = List.of(&quot;java.properties&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2579,31 ***</span>
           */
          protected Control() {
          }
  
          /**
<span class="line-modified">!          * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link</span>
           * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">!          * &lt;code&gt;formats&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must be equal to</span>
           * one of {@link Control#FORMAT_PROPERTIES}, {@link
           * Control#FORMAT_CLASS} or {@link
<span class="line-modified">!          * Control#FORMAT_DEFAULT}. &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
           * instances returned by this method are singletons and thread-safe.
           *
           * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
<span class="line-modified">!          * instantiating the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; class,</span>
           * except that this method returns a singleton.
           *
           * @param formats
           *        the formats to be returned by the
<span class="line-modified">!          *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method</span>
<span class="line-modified">!          * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the</span>
<span class="line-modified">!          *        specified &lt;code&gt;formats&lt;/code&gt;</span>
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!          * @exception IllegalArgumentException</span>
<span class="line-modified">!          *        if &lt;code&gt;formats&lt;/code&gt; is unknown</span>
           */
          public static final Control getControl(List&lt;String&gt; formats) {
              if (formats.equals(Control.FORMAT_PROPERTIES)) {
                  return SingleFormatControl.PROPERTIES_ONLY;
              }
<span class="line-new-header">--- 2579,31 ---</span>
           */
          protected Control() {
          }
  
          /**
<span class="line-modified">!          * Returns a {@code ResourceBundle.Control} in which the {@link</span>
           * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">!          * {@code formats}. The {@code formats} must be equal to</span>
           * one of {@link Control#FORMAT_PROPERTIES}, {@link
           * Control#FORMAT_CLASS} or {@link
<span class="line-modified">!          * Control#FORMAT_DEFAULT}. {@code ResourceBundle.Control}</span>
           * instances returned by this method are singletons and thread-safe.
           *
           * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
<span class="line-modified">!          * instantiating the {@code ResourceBundle.Control} class,</span>
           * except that this method returns a singleton.
           *
           * @param formats
           *        the formats to be returned by the
<span class="line-modified">!          *        {@code ResourceBundle.Control.getFormats} method</span>
<span class="line-modified">!          * @return a {@code ResourceBundle.Control} supporting the</span>
<span class="line-modified">!          *        specified {@code formats}</span>
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code formats} is {@code null}</span>
<span class="line-modified">!          * @throws    IllegalArgumentException</span>
<span class="line-modified">!          *        if {@code formats} is unknown</span>
           */
          public static final Control getControl(List&lt;String&gt; formats) {
              if (formats.equals(Control.FORMAT_PROPERTIES)) {
                  return SingleFormatControl.PROPERTIES_ONLY;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2615,30 ***</span>
              }
              throw new IllegalArgumentException();
          }
  
          /**
<span class="line-modified">!          * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link</span>
           * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">!          * &lt;code&gt;formats&lt;/code&gt; and the {@link</span>
           * Control#getFallbackLocale(String, Locale) getFallbackLocale}
<span class="line-modified">!          * method returns &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must</span>
           * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
           * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by this</span>
           * method are singletons and thread-safe.
           *
           * @param formats
           *        the formats to be returned by the
<span class="line-modified">!          *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method</span>
<span class="line-modified">!          * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the</span>
<span class="line-modified">!          *        specified &lt;code&gt;formats&lt;/code&gt; with no fallback</span>
<span class="line-modified">!          *        &lt;code&gt;Locale&lt;/code&gt; support</span>
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!          * @exception IllegalArgumentException</span>
<span class="line-modified">!          *        if &lt;code&gt;formats&lt;/code&gt; is unknown</span>
           */
          public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
              if (formats.equals(Control.FORMAT_DEFAULT)) {
                  return NoFallbackControl.NO_FALLBACK;
              }
<span class="line-new-header">--- 2615,30 ---</span>
              }
              throw new IllegalArgumentException();
          }
  
          /**
<span class="line-modified">!          * Returns a {@code ResourceBundle.Control} in which the {@link</span>
           * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">!          * {@code formats} and the {@link</span>
           * Control#getFallbackLocale(String, Locale) getFallbackLocale}
<span class="line-modified">!          * method returns {@code null}. The {@code formats} must</span>
           * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
           * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
<span class="line-modified">!          * {@code ResourceBundle.Control} instances returned by this</span>
           * method are singletons and thread-safe.
           *
           * @param formats
           *        the formats to be returned by the
<span class="line-modified">!          *        {@code ResourceBundle.Control.getFormats} method</span>
<span class="line-modified">!          * @return a {@code ResourceBundle.Control} supporting the</span>
<span class="line-modified">!          *        specified {@code formats} with no fallback</span>
<span class="line-modified">!          *        {@code Locale} support</span>
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code formats} is {@code null}</span>
<span class="line-modified">!          * @throws    IllegalArgumentException</span>
<span class="line-modified">!          *        if {@code formats} is unknown</span>
           */
          public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
              if (formats.equals(Control.FORMAT_DEFAULT)) {
                  return NoFallbackControl.NO_FALLBACK;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2650,39 ***</span>
              }
              throw new IllegalArgumentException();
          }
  
          /**
<span class="line-modified">!          * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing</span>
           * formats to be used to load resource bundles for the given
<span class="line-modified">!          * &lt;code&gt;baseName&lt;/code&gt;. The &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
           * factory method tries to load resource bundles with formats in the
           * order specified by the list. The list returned by this method
<span class="line-modified">!          * must have at least one &lt;code&gt;String&lt;/code&gt;. The predefined</span>
<span class="line-modified">!          * formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; for class-based resource</span>
<span class="line-modified">!          * bundles and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for {@linkplain</span>
           * PropertyResourceBundle properties-based} ones. Strings starting
<span class="line-modified">!          * with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions and</span>
           * must not be used by application-defined formats.
           *
           * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">!          * &lt;code&gt;List&lt;/code&gt;.  However, the returned &lt;code&gt;List&lt;/code&gt; must</span>
           * not be mutated after it has been returned by
<span class="line-modified">!          * &lt;code&gt;getFormats&lt;/code&gt;.</span>
           *
           * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
<span class="line-modified">!          * that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method</span>
           * looks up first class-based resource bundles, then
           * properties-based ones.
           *
           * @param baseName
           *        the base name of the resource bundle, a fully qualified class
           *        name
<span class="line-modified">!          * @return a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing</span>
           *        formats for loading resource bundles.
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt; is null</span>
           * @see #FORMAT_DEFAULT
           * @see #FORMAT_CLASS
           * @see #FORMAT_PROPERTIES
           */
          public List&lt;String&gt; getFormats(String baseName) {
<span class="line-new-header">--- 2650,39 ---</span>
              }
              throw new IllegalArgumentException();
          }
  
          /**
<span class="line-modified">!          * Returns a {@code List} of {@code String}s containing</span>
           * formats to be used to load resource bundles for the given
<span class="line-modified">!          * {@code baseName}. The {@code ResourceBundle.getBundle}</span>
           * factory method tries to load resource bundles with formats in the
           * order specified by the list. The list returned by this method
<span class="line-modified">!          * must have at least one {@code String}. The predefined</span>
<span class="line-modified">!          * formats are {@code &quot;java.class&quot;} for class-based resource</span>
<span class="line-modified">!          * bundles and {@code &quot;java.properties&quot;} for {@linkplain</span>
           * PropertyResourceBundle properties-based} ones. Strings starting
<span class="line-modified">!          * with {@code &quot;java.&quot;} are reserved for future extensions and</span>
           * must not be used by application-defined formats.
           *
           * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">!          * {@code List}.  However, the returned {@code List} must</span>
           * not be mutated after it has been returned by
<span class="line-modified">!          * {@code getFormats}.</span>
           *
           * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
<span class="line-modified">!          * that the {@code ResourceBundle.getBundle} factory method</span>
           * looks up first class-based resource bundles, then
           * properties-based ones.
           *
           * @param baseName
           *        the base name of the resource bundle, a fully qualified class
           *        name
<span class="line-modified">!          * @return a {@code List} of {@code String}s containing</span>
           *        formats for loading resource bundles.
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName} is null</span>
           * @see #FORMAT_DEFAULT
           * @see #FORMAT_CLASS
           * @see #FORMAT_PROPERTIES
           */
          public List&lt;String&gt; getFormats(String baseName) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2691,75 ***</span>
              }
              return FORMAT_DEFAULT;
          }
  
          /**
<span class="line-modified">!          * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s as candidate</span>
<span class="line-modified">!          * locales for &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;. This</span>
<span class="line-modified">!          * method is called by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
           * factory method each time the factory method tries finding a
<span class="line-modified">!          * resource bundle for a target &lt;code&gt;Locale&lt;/code&gt;.</span>
           *
           * &lt;p&gt;The sequence of the candidate locales also corresponds to the
           * runtime resource lookup path (also known as the &lt;I&gt;parent
           * chain&lt;/I&gt;), if the corresponding resource bundles for the
           * candidate locales exist and their parents are not defined by
           * loaded resource bundles themselves.  The last element of the list
           * must be a {@linkplain Locale#ROOT root locale} if it is desired to
           * have the base bundle as the terminal of the parent chain.
           *
<span class="line-modified">!          * &lt;p&gt;If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the</span>
<span class="line-modified">!          * root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root</span>
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the</span>
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only</span>
           * the base bundle as the resulting resource bundle.
           *
           * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">!          * &lt;code&gt;List&lt;/code&gt;. However, the returned &lt;code&gt;List&lt;/code&gt; must not</span>
           * be mutated after it has been returned by
<span class="line-modified">!          * &lt;code&gt;getCandidateLocales&lt;/code&gt;.</span>
           *
<span class="line-modified">!          * &lt;p&gt;The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt;s using the rules described below.  In the</span>
           * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
           * respectively represent non-empty language, script, country, and
           * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and</span>
           * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
<span class="line-modified">!          * language value is &quot;xx&quot;.  For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose</span>
           * final component values are empty strings are omitted.
           *
<span class="line-modified">!          * &lt;ol&gt;&lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with an empty script value,</span>
<span class="line-modified">!          * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component</span>
           * one by one as below:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a non-empty script value,</span>
<span class="line-modified">!          * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component</span>
           * up to language, then append candidates generated from the
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt; with country and variant restored:</span>
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a variant value consisting</span>
           * of multiple subtags separated by underscore, generate candidate
<span class="line-modified">!          * &lt;code&gt;Locale&lt;/code&gt;s by omitting the variant subtags one by one, then</span>
<span class="line-modified">!          * insert them after every occurrence of &lt;code&gt; Locale&lt;/code&gt;s with the</span>
           * full variant value in the original list.  For example, if
           * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
<span class="line-new-header">--- 2691,75 ---</span>
              }
              return FORMAT_DEFAULT;
          }
  
          /**
<span class="line-modified">!          * Returns a {@code List} of {@code Locale}s as candidate</span>
<span class="line-modified">!          * locales for {@code baseName} and {@code locale}. This</span>
<span class="line-modified">!          * method is called by the {@code ResourceBundle.getBundle}</span>
           * factory method each time the factory method tries finding a
<span class="line-modified">!          * resource bundle for a target {@code Locale}.</span>
           *
           * &lt;p&gt;The sequence of the candidate locales also corresponds to the
           * runtime resource lookup path (also known as the &lt;I&gt;parent
           * chain&lt;/I&gt;), if the corresponding resource bundles for the
           * candidate locales exist and their parents are not defined by
           * loaded resource bundles themselves.  The last element of the list
           * must be a {@linkplain Locale#ROOT root locale} if it is desired to
           * have the base bundle as the terminal of the parent chain.
           *
<span class="line-modified">!          * &lt;p&gt;If the given locale is equal to {@code Locale.ROOT} (the</span>
<span class="line-modified">!          * root locale), a {@code List} containing only the root</span>
<span class="line-modified">!          * {@code Locale} must be returned. In this case, the</span>
<span class="line-modified">!          * {@code ResourceBundle.getBundle} factory method loads only</span>
           * the base bundle as the resulting resource bundle.
           *
           * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">!          * {@code List}. However, the returned {@code List} must not</span>
           * be mutated after it has been returned by
<span class="line-modified">!          * {@code getCandidateLocales}.</span>
           *
<span class="line-modified">!          * &lt;p&gt;The default implementation returns a {@code List} containing</span>
<span class="line-modified">!          * {@code Locale}s using the rules described below.  In the</span>
           * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
           * respectively represent non-empty language, script, country, and
           * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
<span class="line-modified">!          * {@code Locale} that has non-empty values only for language and</span>
           * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
<span class="line-modified">!          * language value is &quot;xx&quot;.  For all cases, {@code Locale}s whose</span>
           * final component values are empty strings are omitted.
           *
<span class="line-modified">!          * &lt;ol&gt;&lt;li&gt;For an input {@code Locale} with an empty script value,</span>
<span class="line-modified">!          * append candidate {@code Locale}s by omitting the final component</span>
           * one by one as below:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT} &lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;For an input {@code Locale} with a non-empty script value,</span>
<span class="line-modified">!          * append candidate {@code Locale}s by omitting the final component</span>
           * up to language, then append candidates generated from the
<span class="line-modified">!          * {@code Locale} with country and variant restored:</span>
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;For an input {@code Locale} with a variant value consisting</span>
           * of multiple subtags separated by underscore, generate candidate
<span class="line-modified">!          * {@code Locale}s by omitting the variant subtags one by one, then</span>
<span class="line-modified">!          * insert them after every occurrence of {@code  Locale}s with the</span>
           * full variant value in the original list.  For example, if
           * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2768,14 ***</span>
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;Special cases for Chinese.  When an input &lt;code&gt;Locale&lt;/code&gt; has the</span>
           * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
           * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
           * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
           * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
           * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
<span class="line-new-header">--- 2768,14 ---</span>
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;Special cases for Chinese.  When an input {@code Locale} has the</span>
           * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
           * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
           * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
           * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
           * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2784,93 ***</span>
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * For &lt;code&gt;Locale(&quot;zh&quot;, &quot;TW&quot;)&lt;/code&gt;, the candidate list will be:</span>
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;Special cases for Norwegian.  Both &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;,</span>
<span class="line-modified">!          * &quot;NY&quot;)&lt;/code&gt; and &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; represent Norwegian</span>
           * Nynorsk.  When a locale&#39;s language is &quot;nn&quot;, the standard candidate
           * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
           * candidates are added:
           *
           * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first</span>
<span class="line-modified">!          * converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is</span>
           * followed.
           *
           * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
<span class="line-modified">!          * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case &lt;code&gt;Locale(&quot;no&quot;,</span>
<span class="line-modified">!          * &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">!          * has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with</span>
           * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
           * requested language, then using its synonym. For example,
<span class="line-modified">!          * &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following</span>
           * candidate list:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; would generate the same list</span>
           * except that locales with &quot;no&quot; would appear before the corresponding
           * locales with &quot;nb&quot;.&lt;/li&gt;
           * &lt;/ol&gt;
           *
           * &lt;p&gt;The default implementation uses an {@link ArrayList} that
           * overriding implementations may modify before returning it to the
           * caller. However, a subclass must not modify it after it has
<span class="line-modified">!          * been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.</span>
           *
<span class="line-modified">!          * &lt;p&gt;For example, if the given &lt;code&gt;baseName&lt;/code&gt; is &quot;Messages&quot;</span>
<span class="line-modified">!          * and the given &lt;code&gt;locale&lt;/code&gt; is</span>
           * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
<span class="line-modified">!          * &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s:</span>
           * &lt;pre&gt;
           *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
           *     Locale(&quot;ja&quot;)
           *     Locale.ROOT
           * &lt;/pre&gt;
           * is returned. And if the resource bundles for the &quot;ja&quot; and
<span class="line-modified">!          * &quot;&quot; &lt;code&gt;Locale&lt;/code&gt;s are found, then the runtime resource</span>
           * lookup path (parent chain) is:
           * &lt;pre&gt;{@code
           *     Messages_ja -&gt; Messages
           * }&lt;/pre&gt;
           *
           * @param baseName
           *        the base name of the resource bundle, a fully
           *        qualified class name
           * @param locale
           *        the locale for which a resource bundle is desired
<span class="line-modified">!          * @return a &lt;code&gt;List&lt;/code&gt; of candidate</span>
<span class="line-modified">!          *        &lt;code&gt;Locale&lt;/code&gt;s for the given &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is</span>
<span class="line-modified">!          *        &lt;code&gt;null&lt;/code&gt;</span>
           */
          public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
              if (baseName == null) {
                  throw new NullPointerException();
              }
<span class="line-new-header">--- 2784,93 ---</span>
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * For {@code Locale(&quot;zh&quot;, &quot;TW&quot;)}, the candidate list will be:</span>
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;Special cases for Norwegian.  Both {@code Locale(&quot;no&quot;, &quot;NO&quot;,</span>
<span class="line-modified">!          * &quot;NY&quot;)} and {@code Locale(&quot;nn&quot;, &quot;NO&quot;)} represent Norwegian</span>
           * Nynorsk.  When a locale&#39;s language is &quot;nn&quot;, the standard candidate
           * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
           * candidates are added:
           *
           * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * If the locale is exactly {@code Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)}, it is first</span>
<span class="line-modified">!          * converted to {@code Locale(&quot;nn&quot;, &quot;NO&quot;)} and then the above procedure is</span>
           * followed.
           *
           * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
<span class="line-modified">!          * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case {@code Locale(&quot;no&quot;,</span>
<span class="line-modified">!          * &quot;NO&quot;, &quot;NY&quot;)} (handled above), when an input {@code Locale}</span>
<span class="line-modified">!          * has language &quot;no&quot; or &quot;nb&quot;, candidate {@code Locale}s with</span>
           * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
           * requested language, then using its synonym. For example,
<span class="line-modified">!          * {@code Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)} generates the following</span>
           * candidate list:
           *
           * &lt;ul&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
           * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">!          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
           * &lt;/ul&gt;
           *
<span class="line-modified">!          * {@code Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)} would generate the same list</span>
           * except that locales with &quot;no&quot; would appear before the corresponding
           * locales with &quot;nb&quot;.&lt;/li&gt;
           * &lt;/ol&gt;
           *
           * &lt;p&gt;The default implementation uses an {@link ArrayList} that
           * overriding implementations may modify before returning it to the
           * caller. However, a subclass must not modify it after it has
<span class="line-modified">!          * been returned by {@code getCandidateLocales}.</span>
           *
<span class="line-modified">!          * &lt;p&gt;For example, if the given {@code baseName} is &quot;Messages&quot;</span>
<span class="line-modified">!          * and the given {@code locale} is</span>
           * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
<span class="line-modified">!          * {@code List} of {@code Locale}s:</span>
           * &lt;pre&gt;
           *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
           *     Locale(&quot;ja&quot;)
           *     Locale.ROOT
           * &lt;/pre&gt;
           * is returned. And if the resource bundles for the &quot;ja&quot; and
<span class="line-modified">!          * &quot;&quot; {@code Locale}s are found, then the runtime resource</span>
           * lookup path (parent chain) is:
           * &lt;pre&gt;{@code
           *     Messages_ja -&gt; Messages
           * }&lt;/pre&gt;
           *
           * @param baseName
           *        the base name of the resource bundle, a fully
           *        qualified class name
           * @param locale
           *        the locale for which a resource bundle is desired
<span class="line-modified">!          * @return a {@code List} of candidate</span>
<span class="line-modified">!          *        {@code Locale}s for the given {@code locale}</span>
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName} or {@code locale} is</span>
<span class="line-modified">!          *        {@code null}</span>
           */
          public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
              if (baseName == null) {
                  throw new NullPointerException();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3001,44 ***</span>
                  return list;
              }
          }
  
          /**
<span class="line-modified">!          * Returns a &lt;code&gt;Locale&lt;/code&gt; to be used as a fallback locale for</span>
           * further resource bundle searches by the
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. This method</span>
           * is called from the factory method every time when no resulting
<span class="line-modified">!          * resource bundle has been found for &lt;code&gt;baseName&lt;/code&gt; and</span>
<span class="line-modified">!          * &lt;code&gt;locale&lt;/code&gt;, where locale is either the parameter for</span>
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; or the previous fallback</span>
           * locale returned by this method.
           *
<span class="line-modified">!          * &lt;p&gt;The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback</span>
           * search is desired.
           *
           * &lt;p&gt;The default implementation returns the {@linkplain
<span class="line-modified">!          * Locale#getDefault() default &lt;code&gt;Locale&lt;/code&gt;} if the given</span>
<span class="line-modified">!          * &lt;code&gt;locale&lt;/code&gt; isn&#39;t the default one.  Otherwise,</span>
<span class="line-modified">!          * &lt;code&gt;null&lt;/code&gt; is returned.</span>
           *
           * @param baseName
           *        the base name of the resource bundle, a fully
           *        qualified class name for which
<span class="line-modified">!          *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been</span>
           *        unable to find any resource bundles (except for the
           *        base bundle)
           * @param locale
<span class="line-modified">!          *        the &lt;code&gt;Locale&lt;/code&gt; for which</span>
<span class="line-modified">!          *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been</span>
           *        unable to find any resource bundles (except for the
           *        base bundle)
<span class="line-modified">!          * @return a &lt;code&gt;Locale&lt;/code&gt; for the fallback search,</span>
<span class="line-modified">!          *        or &lt;code&gt;null&lt;/code&gt; if no further fallback search</span>
           *        is desired.
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">!          *        is &lt;code&gt;null&lt;/code&gt;</span>
           */
          public Locale getFallbackLocale(String baseName, Locale locale) {
              if (baseName == null) {
                  throw new NullPointerException();
              }
<span class="line-new-header">--- 3001,44 ---</span>
                  return list;
              }
          }
  
          /**
<span class="line-modified">!          * Returns a {@code Locale} to be used as a fallback locale for</span>
           * further resource bundle searches by the
<span class="line-modified">!          * {@code ResourceBundle.getBundle} factory method. This method</span>
           * is called from the factory method every time when no resulting
<span class="line-modified">!          * resource bundle has been found for {@code baseName} and</span>
<span class="line-modified">!          * {@code locale}, where locale is either the parameter for</span>
<span class="line-modified">!          * {@code ResourceBundle.getBundle} or the previous fallback</span>
           * locale returned by this method.
           *
<span class="line-modified">!          * &lt;p&gt;The method returns {@code null} if no further fallback</span>
           * search is desired.
           *
           * &lt;p&gt;The default implementation returns the {@linkplain
<span class="line-modified">!          * Locale#getDefault() default {@code Locale}} if the given</span>
<span class="line-modified">!          * {@code locale} isn&#39;t the default one.  Otherwise,</span>
<span class="line-modified">!          * {@code null} is returned.</span>
           *
           * @param baseName
           *        the base name of the resource bundle, a fully
           *        qualified class name for which
<span class="line-modified">!          *        {@code ResourceBundle.getBundle} has been</span>
           *        unable to find any resource bundles (except for the
           *        base bundle)
           * @param locale
<span class="line-modified">!          *        the {@code Locale} for which</span>
<span class="line-modified">!          *        {@code ResourceBundle.getBundle} has been</span>
           *        unable to find any resource bundles (except for the
           *        base bundle)
<span class="line-modified">!          * @return a {@code Locale} for the fallback search,</span>
<span class="line-modified">!          *        or {@code null} if no further fallback search</span>
           *        is desired.
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName} or {@code locale}</span>
<span class="line-modified">!          *        is {@code null}</span>
           */
          public Locale getFallbackLocale(String baseName, Locale locale) {
              if (baseName == null) {
                  throw new NullPointerException();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3047,18 ***</span>
          }
  
          /**
           * Instantiates a resource bundle for the given bundle name of the
           * given format and locale, using the given class loader if
<span class="line-modified">!          * necessary. This method returns &lt;code&gt;null&lt;/code&gt; if there is no</span>
           * resource bundle available for the given parameters. If a resource
           * bundle can&#39;t be instantiated due to an unexpected error, the
<span class="line-modified">!          * error must be reported by throwing an &lt;code&gt;Error&lt;/code&gt; or</span>
<span class="line-modified">!          * &lt;code&gt;Exception&lt;/code&gt; rather than simply returning</span>
<span class="line-modified">!          * &lt;code&gt;null&lt;/code&gt;.</span>
           *
<span class="line-modified">!          * &lt;p&gt;If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it</span>
           * indicates that this method is being called because the previously
           * loaded resource bundle has expired.
           *
           * @implSpec
           *
<span class="line-new-header">--- 3047,18 ---</span>
          }
  
          /**
           * Instantiates a resource bundle for the given bundle name of the
           * given format and locale, using the given class loader if
<span class="line-modified">!          * necessary. This method returns {@code null} if there is no</span>
           * resource bundle available for the given parameters. If a resource
           * bundle can&#39;t be instantiated due to an unexpected error, the
<span class="line-modified">!          * error must be reported by throwing an {@code Error} or</span>
<span class="line-modified">!          * {@code Exception} rather than simply returning</span>
<span class="line-modified">!          * {@code null}.</span>
           *
<span class="line-modified">!          * &lt;p&gt;If the {@code reload} flag is {@code true}, it</span>
           * indicates that this method is being called because the previously
           * loaded resource bundle has expired.
           *
           * @implSpec
           *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3067,49 ***</span>
           * A resource bundle in a named module visible to the given class loader
           * is accessible when the package of the resource file corresponding
           * to the resource bundle is open unconditionally.
           *
           * &lt;p&gt;The default implementation instantiates a
<span class="line-modified">!          * &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.</span>
           *
           * &lt;ul&gt;
           *
           * &lt;li&gt;The bundle name is obtained by calling {@link
           * #toBundleName(String, Locale) toBundleName(baseName,
           * locale)}.&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the</span>
           * {@link Class} specified by the bundle name is loaded with the
           * given class loader. If the {@code Class} is found and accessible
<span class="line-modified">!          * then the &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated.  The</span>
           * resource bundle is accessible if the package of the bundle class file
           * is open unconditionally; otherwise, {@code IllegalAccessException}
           * will be thrown.
<span class="line-modified">!          * Note that the &lt;code&gt;reload&lt;/code&gt; flag is ignored for loading</span>
           * class-based resource bundles in this default implementation.
           * &lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;,</span>
           * {@link #toResourceName(String, String) toResourceName(bundlename,
           * &quot;properties&quot;)} is called to get the resource name.
<span class="line-modified">!          * If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, {@link</span>
           * ClassLoader#getResource(String) load.getResource} is called
           * to get a {@link URL} for creating a {@link
<span class="line-modified">!          * URLConnection}. This &lt;code&gt;URLConnection&lt;/code&gt; is used to</span>
           * {@linkplain URLConnection#setUseCaches(boolean) disable the
           * caches} of the underlying resource loading layers,
           * and to {@linkplain URLConnection#getInputStream() get an
<span class="line-modified">!          * &lt;code&gt;InputStream&lt;/code&gt;}.</span>
           * Otherwise, {@link ClassLoader#getResourceAsStream(String)
           * loader.getResourceAsStream} is called to get an {@link
           * InputStream}. Then, a {@link
           * PropertyResourceBundle} is constructed with the
<span class="line-modified">!          * &lt;code&gt;InputStream&lt;/code&gt;.&lt;/li&gt;</span>
           *
<span class="line-modified">!          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;</span>
<span class="line-modified">!          * nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an</span>
<span class="line-modified">!          * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.&lt;/li&gt;</span>
           *
           * &lt;/ul&gt;
           *
           * @param baseName
           *        the base bundle name of the resource bundle, a fully
<span class="line-new-header">--- 3067,49 ---</span>
           * A resource bundle in a named module visible to the given class loader
           * is accessible when the package of the resource file corresponding
           * to the resource bundle is open unconditionally.
           *
           * &lt;p&gt;The default implementation instantiates a
<span class="line-modified">!          * {@code ResourceBundle} as follows.</span>
           *
           * &lt;ul&gt;
           *
           * &lt;li&gt;The bundle name is obtained by calling {@link
           * #toBundleName(String, Locale) toBundleName(baseName,
           * locale)}.&lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;If {@code format} is {@code &quot;java.class&quot;}, the</span>
           * {@link Class} specified by the bundle name is loaded with the
           * given class loader. If the {@code Class} is found and accessible
<span class="line-modified">!          * then the {@code ResourceBundle} is instantiated.  The</span>
           * resource bundle is accessible if the package of the bundle class file
           * is open unconditionally; otherwise, {@code IllegalAccessException}
           * will be thrown.
<span class="line-modified">!          * Note that the {@code reload} flag is ignored for loading</span>
           * class-based resource bundles in this default implementation.
           * &lt;/li&gt;
           *
<span class="line-modified">!          * &lt;li&gt;If {@code format} is {@code &quot;java.properties&quot;},</span>
           * {@link #toResourceName(String, String) toResourceName(bundlename,
           * &quot;properties&quot;)} is called to get the resource name.
<span class="line-modified">!          * If {@code reload} is {@code true}, {@link</span>
           * ClassLoader#getResource(String) load.getResource} is called
           * to get a {@link URL} for creating a {@link
<span class="line-modified">!          * URLConnection}. This {@code URLConnection} is used to</span>
           * {@linkplain URLConnection#setUseCaches(boolean) disable the
           * caches} of the underlying resource loading layers,
           * and to {@linkplain URLConnection#getInputStream() get an
<span class="line-modified">!          * {@code InputStream}}.</span>
           * Otherwise, {@link ClassLoader#getResourceAsStream(String)
           * loader.getResourceAsStream} is called to get an {@link
           * InputStream}. Then, a {@link
           * PropertyResourceBundle} is constructed with the
<span class="line-modified">!          * {@code InputStream}.&lt;/li&gt;</span>
           *
<span class="line-modified">!          * &lt;li&gt;If {@code format} is neither {@code &quot;java.class&quot;}</span>
<span class="line-modified">!          * nor {@code &quot;java.properties&quot;}, an</span>
<span class="line-modified">!          * {@code IllegalArgumentException} is thrown.&lt;/li&gt;</span>
           *
           * &lt;/ul&gt;
           *
           * @param baseName
           *        the base bundle name of the resource bundle, a fully
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3118,40 ***</span>
           *        the locale for which the resource bundle should be
           *        instantiated
           * @param format
           *        the resource bundle format to be loaded
           * @param loader
<span class="line-modified">!          *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle</span>
           * @param reload
<span class="line-modified">!          *        the flag to indicate bundle reloading; &lt;code&gt;true&lt;/code&gt;</span>
           *        if reloading an expired resource bundle,
<span class="line-modified">!          *        &lt;code&gt;false&lt;/code&gt; otherwise</span>
           * @return the resource bundle instance,
<span class="line-modified">!          *        or &lt;code&gt;null&lt;/code&gt; if none could be found.</span>
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;bundleName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,</span>
<span class="line-modified">!          *        &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is</span>
<span class="line-modified">!          *        &lt;code&gt;null&lt;/code&gt;, or if &lt;code&gt;null&lt;/code&gt; is returned by</span>
           *        {@link #toBundleName(String, Locale) toBundleName}
<span class="line-modified">!          * @exception IllegalArgumentException</span>
<span class="line-modified">!          *        if &lt;code&gt;format&lt;/code&gt; is unknown, or if the resource</span>
           *        found for the given parameters contains malformed data.
<span class="line-modified">!          * @exception ClassCastException</span>
<span class="line-modified">!          *        if the loaded class cannot be cast to &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified">!          * @exception IllegalAccessException</span>
           *        if the class or its nullary constructor is not
           *        accessible.
<span class="line-modified">!          * @exception InstantiationException</span>
           *        if the instantiation of a class fails for some other
           *        reason.
<span class="line-modified">!          * @exception ExceptionInInitializerError</span>
           *        if the initialization provoked by this method fails.
<span class="line-modified">!          * @exception SecurityException</span>
           *        If a security manager is present and creation of new
           *        instances is denied. See {@link Class#newInstance()}
           *        for details.
<span class="line-modified">!          * @exception IOException</span>
           *        if an error occurred when reading resources using
           *        any I/O operations
           * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
           * @revised 9
           * @spec JPMS
<span class="line-new-header">--- 3118,40 ---</span>
           *        the locale for which the resource bundle should be
           *        instantiated
           * @param format
           *        the resource bundle format to be loaded
           * @param loader
<span class="line-modified">!          *        the {@code ClassLoader} to use to load the bundle</span>
           * @param reload
<span class="line-modified">!          *        the flag to indicate bundle reloading; {@code true}</span>
           *        if reloading an expired resource bundle,
<span class="line-modified">!          *        {@code false} otherwise</span>
           * @return the resource bundle instance,
<span class="line-modified">!          *        or {@code null} if none could be found.</span>
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code bundleName}, {@code locale},</span>
<span class="line-modified">!          *        {@code format}, or {@code loader} is</span>
<span class="line-modified">!          *        {@code null}, or if {@code null} is returned by</span>
           *        {@link #toBundleName(String, Locale) toBundleName}
<span class="line-modified">!          * @throws    IllegalArgumentException</span>
<span class="line-modified">!          *        if {@code format} is unknown, or if the resource</span>
           *        found for the given parameters contains malformed data.
<span class="line-modified">!          * @throws    ClassCastException</span>
<span class="line-modified">!          *        if the loaded class cannot be cast to {@code ResourceBundle}</span>
<span class="line-modified">!          * @throws    IllegalAccessException</span>
           *        if the class or its nullary constructor is not
           *        accessible.
<span class="line-modified">!          * @throws    InstantiationException</span>
           *        if the instantiation of a class fails for some other
           *        reason.
<span class="line-modified">!          * @throws    ExceptionInInitializerError</span>
           *        if the initialization provoked by this method fails.
<span class="line-modified">!          * @throws    SecurityException</span>
           *        If a security manager is present and creation of new
           *        instances is denied. See {@link Class#newInstance()}
           *        for details.
<span class="line-modified">!          * @throws    IOException</span>
           *        if an error occurred when reading resources using
           *        any I/O operations
           * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
           * @revised 9
           * @spec JPMS
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3254,28 ***</span>
          }
  
          /**
           * Returns the time-to-live (TTL) value for resource bundles that
           * are loaded under this
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;. Positive time-to-live values</span>
           * specify the number of milliseconds a bundle can remain in the
           * cache without being validated against the source data from which
           * it was constructed. The value 0 indicates that a bundle must be
           * validated each time it is retrieved from the cache. {@link
           * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
           * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
           * that loaded resource bundles are put in the cache with no
           * expiration control.
           *
           * &lt;p&gt;The expiration affects only the bundle loading process by the
<span class="line-modified">!          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method.  That is,</span>
           * if the factory method finds a resource bundle in the cache that
           * has expired, the factory method calls the {@link
           * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
           * long) needsReload} method to determine whether the resource
<span class="line-modified">!          * bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns</span>
<span class="line-modified">!          * &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed</span>
           * from the cache. Otherwise, the instance stays in the cache,
           * updated with the new TTL value returned by this method.
           *
           * &lt;p&gt;All cached resource bundles are subject to removal from the
           * cache due to memory constraints of the runtime environment.
<span class="line-new-header">--- 3254,28 ---</span>
          }
  
          /**
           * Returns the time-to-live (TTL) value for resource bundles that
           * are loaded under this
<span class="line-modified">!          * {@code ResourceBundle.Control}. Positive time-to-live values</span>
           * specify the number of milliseconds a bundle can remain in the
           * cache without being validated against the source data from which
           * it was constructed. The value 0 indicates that a bundle must be
           * validated each time it is retrieved from the cache. {@link
           * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
           * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
           * that loaded resource bundles are put in the cache with no
           * expiration control.
           *
           * &lt;p&gt;The expiration affects only the bundle loading process by the
<span class="line-modified">!          * {@code ResourceBundle.getBundle} factory method.  That is,</span>
           * if the factory method finds a resource bundle in the cache that
           * has expired, the factory method calls the {@link
           * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
           * long) needsReload} method to determine whether the resource
<span class="line-modified">!          * bundle needs to be reloaded. If {@code needsReload} returns</span>
<span class="line-modified">!          * {@code true}, the cached resource bundle instance is removed</span>
           * from the cache. Otherwise, the instance stays in the cache,
           * updated with the new TTL value returned by this method.
           *
           * &lt;p&gt;All cached resource bundles are subject to removal from the
           * cache due to memory constraints of the runtime environment.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3293,69 ***</span>
           * @return the time (0 or a positive millisecond offset from the
           *        cached time) to get loaded bundles expired in the cache,
           *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
           *        expiration control, or {@link #TTL_DONT_CACHE} to disable
           *        caching.
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is</span>
<span class="line-modified">!          *        &lt;code&gt;null&lt;/code&gt;</span>
           */
          public long getTimeToLive(String baseName, Locale locale) {
              if (baseName == null || locale == null) {
                  throw new NullPointerException();
              }
              return TTL_NO_EXPIRATION_CONTROL;
          }
  
          /**
<span class="line-modified">!          * Determines if the expired &lt;code&gt;bundle&lt;/code&gt; in the cache needs</span>
           * to be reloaded based on the loading time given by
<span class="line-modified">!          * &lt;code&gt;loadTime&lt;/code&gt; or some other criteria. The method returns</span>
<span class="line-modified">!          * &lt;code&gt;true&lt;/code&gt; if reloading is required; &lt;code&gt;false&lt;/code&gt;</span>
<span class="line-modified">!          * otherwise. &lt;code&gt;loadTime&lt;/code&gt; is a millisecond offset since</span>
<span class="line-modified">!          * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt;</span>
           * Epoch&lt;/a&gt;.
           *
           * &lt;p&gt;
<span class="line-modified">!          * The calling &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method</span>
<span class="line-modified">!          * calls this method on the &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
           * instance used for its current invocation, not on the instance
           * used in the invocation that originally loaded the resource
           * bundle.
           *
<span class="line-modified">!          * &lt;p&gt;The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and</span>
           * the last modified time of the source data of the resource
           * bundle. If it&#39;s determined that the source data has been modified
<span class="line-modified">!          * since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is</span>
<span class="line-modified">!          * returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This</span>
<span class="line-modified">!          * implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the</span>
           * same string as its file suffix if it&#39;s not one of the default
<span class="line-modified">!          * formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or</span>
<span class="line-modified">!          * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.</span>
           *
           * @param baseName
           *        the base bundle name of the resource bundle, a
           *        fully qualified class name
           * @param locale
           *        the locale for which the resource bundle
           *        should be instantiated
           * @param format
           *        the resource bundle format to be loaded
           * @param loader
<span class="line-modified">!          *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle</span>
           * @param bundle
           *        the resource bundle instance that has been expired
           *        in the cache
           * @param loadTime
<span class="line-modified">!          *        the time when &lt;code&gt;bundle&lt;/code&gt; was loaded and put</span>
           *        in the cache
<span class="line-modified">!          * @return &lt;code&gt;true&lt;/code&gt; if the expired bundle needs to be</span>
<span class="line-modified">!          *        reloaded; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,</span>
<span class="line-modified">!          *        &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;loader&lt;/code&gt;, or</span>
<span class="line-modified">!          *        &lt;code&gt;bundle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
           */
          public boolean needsReload(String baseName, Locale locale,
                                     String format, ClassLoader loader,
                                     ResourceBundle bundle, long loadTime) {
              if (bundle == null) {
<span class="line-new-header">--- 3293,69 ---</span>
           * @return the time (0 or a positive millisecond offset from the
           *        cached time) to get loaded bundles expired in the cache,
           *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
           *        expiration control, or {@link #TTL_DONT_CACHE} to disable
           *        caching.
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName} or {@code locale} is</span>
<span class="line-modified">!          *        {@code null}</span>
           */
          public long getTimeToLive(String baseName, Locale locale) {
              if (baseName == null || locale == null) {
                  throw new NullPointerException();
              }
              return TTL_NO_EXPIRATION_CONTROL;
          }
  
          /**
<span class="line-modified">!          * Determines if the expired {@code bundle} in the cache needs</span>
           * to be reloaded based on the loading time given by
<span class="line-modified">!          * {@code loadTime} or some other criteria. The method returns</span>
<span class="line-modified">!          * {@code true} if reloading is required; {@code false}</span>
<span class="line-modified">!          * otherwise. {@code loadTime} is a millisecond offset since</span>
<span class="line-modified">!          * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; {@code Calendar}</span>
           * Epoch&lt;/a&gt;.
           *
           * &lt;p&gt;
<span class="line-modified">!          * The calling {@code ResourceBundle.getBundle} factory method</span>
<span class="line-modified">!          * calls this method on the {@code ResourceBundle.Control}</span>
           * instance used for its current invocation, not on the instance
           * used in the invocation that originally loaded the resource
           * bundle.
           *
<span class="line-modified">!          * &lt;p&gt;The default implementation compares {@code loadTime} and</span>
           * the last modified time of the source data of the resource
           * bundle. If it&#39;s determined that the source data has been modified
<span class="line-modified">!          * since {@code loadTime}, {@code true} is</span>
<span class="line-modified">!          * returned. Otherwise, {@code false} is returned. This</span>
<span class="line-modified">!          * implementation assumes that the given {@code format} is the</span>
           * same string as its file suffix if it&#39;s not one of the default
<span class="line-modified">!          * formats, {@code &quot;java.class&quot;} or</span>
<span class="line-modified">!          * {@code &quot;java.properties&quot;}.</span>
           *
           * @param baseName
           *        the base bundle name of the resource bundle, a
           *        fully qualified class name
           * @param locale
           *        the locale for which the resource bundle
           *        should be instantiated
           * @param format
           *        the resource bundle format to be loaded
           * @param loader
<span class="line-modified">!          *        the {@code ClassLoader} to use to load the bundle</span>
           * @param bundle
           *        the resource bundle instance that has been expired
           *        in the cache
           * @param loadTime
<span class="line-modified">!          *        the time when {@code bundle} was loaded and put</span>
           *        in the cache
<span class="line-modified">!          * @return {@code true} if the expired bundle needs to be</span>
<span class="line-modified">!          *        reloaded; {@code false} otherwise.</span>
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName}, {@code locale},</span>
<span class="line-modified">!          *        {@code format}, {@code loader}, or</span>
<span class="line-modified">!          *        {@code bundle} is {@code null}</span>
           */
          public boolean needsReload(String baseName, Locale locale,
                                     String format, ClassLoader loader,
                                     ResourceBundle bundle, long loadTime) {
              if (bundle == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3398,35 ***</span>
              }
              return result;
          }
  
          /**
<span class="line-modified">!          * Converts the given &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;</span>
           * to the bundle name. This method is called from the default
           * implementation of the {@link #newBundle(String, Locale, String,
           * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
           * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
           * methods.
           *
           * &lt;p&gt;This implementation returns the following value:
           * &lt;pre&gt;
           *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
           * &lt;/pre&gt;
<span class="line-modified">!          * where &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt;,</span>
<span class="line-modified">!          * and &lt;code&gt;variant&lt;/code&gt; are the language, script, country, and variant</span>
<span class="line-modified">!          * values of &lt;code&gt;locale&lt;/code&gt;, respectively. Final component values that</span>
           * are empty Strings are omitted along with the preceding &#39;_&#39;.  When the
           * script is empty, the script value is omitted along with the preceding &#39;_&#39;.
<span class="line-modified">!          * If all of the values are empty strings, then &lt;code&gt;baseName&lt;/code&gt;</span>
           * is returned.
           *
<span class="line-modified">!          * &lt;p&gt;For example, if &lt;code&gt;baseName&lt;/code&gt; is</span>
<span class="line-modified">!          * &lt;code&gt;&quot;baseName&quot;&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; is</span>
           * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
           * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
<span class="line-modified">!          * locale is &lt;code&gt;Locale(&quot;en&quot;)&lt;/code&gt;, then</span>
<span class="line-modified">!          * &lt;code&gt;&quot;baseName_en&quot;&lt;/code&gt; is returned.</span>
           *
           * &lt;p&gt;Overriding this method allows applications to use different
           * conventions in the organization and packaging of localized
           * resources.
           *
<span class="line-new-header">--- 3398,35 ---</span>
              }
              return result;
          }
  
          /**
<span class="line-modified">!          * Converts the given {@code baseName} and {@code locale}</span>
           * to the bundle name. This method is called from the default
           * implementation of the {@link #newBundle(String, Locale, String,
           * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
           * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
           * methods.
           *
           * &lt;p&gt;This implementation returns the following value:
           * &lt;pre&gt;
           *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
           * &lt;/pre&gt;
<span class="line-modified">!          * where {@code language}, {@code script}, {@code country},</span>
<span class="line-modified">!          * and {@code variant} are the language, script, country, and variant</span>
<span class="line-modified">!          * values of {@code locale}, respectively. Final component values that</span>
           * are empty Strings are omitted along with the preceding &#39;_&#39;.  When the
           * script is empty, the script value is omitted along with the preceding &#39;_&#39;.
<span class="line-modified">!          * If all of the values are empty strings, then {@code baseName}</span>
           * is returned.
           *
<span class="line-modified">!          * &lt;p&gt;For example, if {@code baseName} is</span>
<span class="line-modified">!          * {@code &quot;baseName&quot;} and {@code locale} is</span>
           * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
           * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
<span class="line-modified">!          * locale is {@code Locale(&quot;en&quot;)}, then</span>
<span class="line-modified">!          * {@code &quot;baseName_en&quot;} is returned.</span>
           *
           * &lt;p&gt;Overriding this method allows applications to use different
           * conventions in the organization and packaging of localized
           * resources.
           *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3435,13 ***</span>
           *        qualified class name
           * @param locale
           *        the locale for which a resource bundle should be
           *        loaded
           * @return the bundle name for the resource bundle
<span class="line-modified">!          * @exception NullPointerException</span>
<span class="line-modified">!          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">!          *        is &lt;code&gt;null&lt;/code&gt;</span>
           * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
           */
          public String toBundleName(String baseName, Locale locale) {
              if (locale == Locale.ROOT) {
                  return baseName;
<span class="line-new-header">--- 3435,13 ---</span>
           *        qualified class name
           * @param locale
           *        the locale for which a resource bundle should be
           *        loaded
           * @return the bundle name for the resource bundle
<span class="line-modified">!          * @throws    NullPointerException</span>
<span class="line-modified">!          *        if {@code baseName} or {@code locale}</span>
<span class="line-modified">!          *        is {@code null}</span>
           * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
           */
          public String toBundleName(String baseName, Locale locale) {
              if (locale == Locale.ROOT) {
                  return baseName;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3493,11 ***</span>
           * @param bundleName
           *        the bundle name
           * @param suffix
           *        the file type suffix
           * @return the converted resource name
<span class="line-modified">!          * @exception NullPointerException</span>
           *         if {@code bundleName} or {@code suffix}
           *         is {@code null}
           */
          public final String toResourceName(String bundleName, String suffix) {
              StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
<span class="line-new-header">--- 3493,11 ---</span>
           * @param bundleName
           *        the bundle name
           * @param suffix
           *        the file type suffix
           * @return the converted resource name
<span class="line-modified">!          * @throws    NullPointerException</span>
           *         if {@code bundleName} or {@code suffix}
           *         is {@code null}
           */
          public final String toResourceName(String bundleName, String suffix) {
              StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
</pre>
<center><a href="RegularEnumSet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Scanner.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
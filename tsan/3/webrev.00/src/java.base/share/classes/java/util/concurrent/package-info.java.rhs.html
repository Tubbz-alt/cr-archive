<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/concurrent/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 /**
 37  * Utility classes commonly useful in concurrent programming.  This
 38  * package includes a few small standardized extensible frameworks, as
 39  * well as some classes that provide useful functionality and are
 40  * otherwise tedious or difficult to implement.  Here are brief
 41  * descriptions of the main components.  See also the
 42  * {@link java.util.concurrent.locks} and
 43  * {@link java.util.concurrent.atomic} packages.
 44  *
 45  * &lt;h2&gt;Executors&lt;/h2&gt;
 46  *
 47  * &lt;b&gt;Interfaces.&lt;/b&gt;
 48  *
 49  * {@link java.util.concurrent.Executor} is a simple standardized
 50  * interface for defining custom thread-like subsystems, including
 51  * thread pools, asynchronous I/O, and lightweight task frameworks.
 52  * Depending on which concrete Executor class is being used, tasks may
 53  * execute in a newly created thread, an existing task-execution thread,
 54  * or the thread calling {@link java.util.concurrent.Executor#execute
 55  * execute}, and may execute sequentially or concurrently.
 56  *
 57  * {@link java.util.concurrent.ExecutorService} provides a more
 58  * complete asynchronous task execution framework.  An
 59  * ExecutorService manages queuing and scheduling of tasks,
 60  * and allows controlled shutdown.
 61  *
 62  * The {@link java.util.concurrent.ScheduledExecutorService}
 63  * subinterface and associated interfaces add support for
 64  * delayed and periodic task execution.  ExecutorServices
 65  * provide methods arranging asynchronous execution of any
 66  * function expressed as {@link java.util.concurrent.Callable},
 67  * the result-bearing analog of {@link java.lang.Runnable}.
 68  *
 69  * A {@link java.util.concurrent.Future} returns the results of
 70  * a function, allows determination of whether execution has
 71  * completed, and provides a means to cancel execution.
 72  *
 73  * A {@link java.util.concurrent.RunnableFuture} is a {@code Future}
 74  * that possesses a {@code run} method that upon execution,
 75  * sets its results.
 76  *
 77  * &lt;p&gt;
 78  *
 79  * &lt;b&gt;Implementations.&lt;/b&gt;
 80  *
 81  * Classes {@link java.util.concurrent.ThreadPoolExecutor} and
 82  * {@link java.util.concurrent.ScheduledThreadPoolExecutor}
 83  * provide tunable, flexible thread pools.
 84  *
 85  * The {@link java.util.concurrent.Executors} class provides
 86  * factory methods for the most common kinds and configurations
 87  * of Executors, as well as a few utility methods for using
 88  * them.  Other utilities based on {@code Executors} include the
 89  * concrete class {@link java.util.concurrent.FutureTask}
 90  * providing a common extensible implementation of Futures, and
 91  * {@link java.util.concurrent.ExecutorCompletionService}, that
 92  * assists in coordinating the processing of groups of
 93  * asynchronous tasks.
 94  *
 95  * &lt;p&gt;Class {@link java.util.concurrent.ForkJoinPool} provides an
 96  * Executor primarily designed for processing instances of {@link
 97  * java.util.concurrent.ForkJoinTask} and its subclasses.  These
 98  * classes employ a work-stealing scheduler that attains high
 99  * throughput for tasks conforming to restrictions that often hold in
100  * computation-intensive parallel processing.
101  *
102  * &lt;h2&gt;Queues&lt;/h2&gt;
103  *
104  * The {@link java.util.concurrent.ConcurrentLinkedQueue} class
105  * supplies an efficient scalable thread-safe non-blocking FIFO queue.
106  * The {@link java.util.concurrent.ConcurrentLinkedDeque} class is
107  * similar, but additionally supports the {@link java.util.Deque}
108  * interface.
109  *
110  * &lt;p&gt;Five implementations in {@code java.util.concurrent} support
111  * the extended {@link java.util.concurrent.BlockingQueue}
112  * interface, that defines blocking versions of put and take:
113  * {@link java.util.concurrent.LinkedBlockingQueue},
114  * {@link java.util.concurrent.ArrayBlockingQueue},
115  * {@link java.util.concurrent.SynchronousQueue},
116  * {@link java.util.concurrent.PriorityBlockingQueue}, and
117  * {@link java.util.concurrent.DelayQueue}.
118  * The different classes cover the most common usage contexts
119  * for producer-consumer, messaging, parallel tasking, and
120  * related concurrent designs.
121  *
122  * &lt;p&gt;Extended interface {@link java.util.concurrent.TransferQueue},
123  * and implementation {@link java.util.concurrent.LinkedTransferQueue}
124  * introduce a synchronous {@code transfer} method (along with related
125  * features) in which a producer may optionally block awaiting its
126  * consumer.
127  *
128  * &lt;p&gt;The {@link java.util.concurrent.BlockingDeque} interface
129  * extends {@code BlockingQueue} to support both FIFO and LIFO
130  * (stack-based) operations.
131  * Class {@link java.util.concurrent.LinkedBlockingDeque}
132  * provides an implementation.
133  *
134  * &lt;h2&gt;Timing&lt;/h2&gt;
135  *
136  * The {@link java.util.concurrent.TimeUnit} class provides
137  * multiple granularities (including nanoseconds) for
138  * specifying and controlling time-out based operations.  Most
139  * classes in the package contain operations based on time-outs
140  * in addition to indefinite waits.  In all cases that
141  * time-outs are used, the time-out specifies the minimum time
142  * that the method should wait before indicating that it
143  * timed-out.  Implementations make a &amp;quot;best effort&amp;quot;
144  * to detect time-outs as soon as possible after they occur.
145  * However, an indefinite amount of time may elapse between a
146  * time-out being detected and a thread actually executing
147  * again after that time-out.  All methods that accept timeout
148  * parameters treat values less than or equal to zero to mean
149  * not to wait at all.  To wait &quot;forever&quot;, you can use a value
150  * of {@code Long.MAX_VALUE}.
151  *
152  * &lt;h2&gt;Synchronizers&lt;/h2&gt;
153  *
154  * Five classes aid common special-purpose synchronization idioms.
155  * &lt;ul&gt;
156  *
157  * &lt;li&gt;{@link java.util.concurrent.Semaphore} is a classic concurrency tool.
158  *
159  * &lt;li&gt;{@link java.util.concurrent.CountDownLatch} is a very simple yet
160  * very common utility for blocking until a given number of signals,
161  * events, or conditions hold.
162  *
163  * &lt;li&gt;A {@link java.util.concurrent.CyclicBarrier} is a resettable
164  * multiway synchronization point useful in some styles of parallel
165  * programming.
166  *
167  * &lt;li&gt;A {@link java.util.concurrent.Phaser} provides
168  * a more flexible form of barrier that may be used to control phased
169  * computation among multiple threads.
170  *
171  * &lt;li&gt;An {@link java.util.concurrent.Exchanger} allows two threads to
172  * exchange objects at a rendezvous point, and is useful in several
173  * pipeline designs.
174  *
175  * &lt;/ul&gt;
176  *
177  * &lt;h2&gt;Concurrent Collections&lt;/h2&gt;
178  *
179  * Besides Queues, this package supplies Collection implementations
180  * designed for use in multithreaded contexts:
181  * {@link java.util.concurrent.ConcurrentHashMap},
182  * {@link java.util.concurrent.ConcurrentSkipListMap},
183  * {@link java.util.concurrent.ConcurrentSkipListSet},
184  * {@link java.util.concurrent.CopyOnWriteArrayList}, and
185  * {@link java.util.concurrent.CopyOnWriteArraySet}.
186  * When many threads are expected to access a given collection, a
187  * {@code ConcurrentHashMap} is normally preferable to a synchronized
188  * {@code HashMap}, and a {@code ConcurrentSkipListMap} is normally
189  * preferable to a synchronized {@code TreeMap}.
190  * A {@code CopyOnWriteArrayList} is preferable to a synchronized
191  * {@code ArrayList} when the expected number of reads and traversals
192  * greatly outnumber the number of updates to a list.
193  *
194  * &lt;p&gt;The &quot;Concurrent&quot; prefix used with some classes in this package
195  * is a shorthand indicating several differences from similar
196  * &quot;synchronized&quot; classes.  For example {@code java.util.Hashtable} and
197  * {@code Collections.synchronizedMap(new HashMap())} are
198  * synchronized.  But {@link
199  * java.util.concurrent.ConcurrentHashMap} is &quot;concurrent&quot;.  A
200  * concurrent collection is thread-safe, but not governed by a
201  * single exclusion lock.  In the particular case of
202  * ConcurrentHashMap, it safely permits any number of
203  * concurrent reads as well as a large number of concurrent
204  * writes.  &quot;Synchronized&quot; classes can be useful when you need
205  * to prevent all access to a collection via a single lock, at
206  * the expense of poorer scalability.  In other cases in which
207  * multiple threads are expected to access a common collection,
208  * &quot;concurrent&quot; versions are normally preferable.  And
209  * unsynchronized collections are preferable when either
210  * collections are unshared, or are accessible only when
211  * holding other locks.
212  *
213  * &lt;p id=&quot;Weakly&quot;&gt;Most concurrent Collection implementations
214  * (including most Queues) also differ from the usual {@code java.util}
215  * conventions in that their {@linkplain java.util.Iterator Iterators}
216  * and {@linkplain java.util.Spliterator Spliterators} provide
217  * &lt;em&gt;weakly consistent&lt;/em&gt; rather than fast-fail traversal:
218  * &lt;ul&gt;
219  * &lt;li&gt;they may proceed concurrently with other operations
220  * &lt;li&gt;they will never throw {@link java.util.ConcurrentModificationException
221  * ConcurrentModificationException}
222  * &lt;li&gt;they are guaranteed to traverse elements as they existed upon
223  * construction exactly once, and may (but are not guaranteed to)
224  * reflect any modifications subsequent to construction.
225  * &lt;/ul&gt;
226  *
227  * &lt;h2 id=&quot;MemoryVisibility&quot;&gt;Memory Consistency Properties&lt;/h2&gt;
228  *
<a name="1" id="anc1"></a>
229  * Chapter 17 of
<a name="2" id="anc2"></a><span class="line-modified">230  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt; defines the</span>
231  * &lt;i&gt;happens-before&lt;/i&gt; relation on memory operations such as reads and
232  * writes of shared variables.  The results of a write by one thread are
233  * guaranteed to be visible to a read by another thread only if the write
234  * operation &lt;i&gt;happens-before&lt;/i&gt; the read operation.  The
235  * {@code synchronized} and {@code volatile} constructs, as well as the
236  * {@code Thread.start()} and {@code Thread.join()} methods, can form
237  * &lt;i&gt;happens-before&lt;/i&gt; relationships.  In particular:
238  *
239  * &lt;ul&gt;
240  *   &lt;li&gt;Each action in a thread &lt;i&gt;happens-before&lt;/i&gt; every action in that
241  *   thread that comes later in the program&#39;s order.
242  *
243  *   &lt;li&gt;An unlock ({@code synchronized} block or method exit) of a
244  *   monitor &lt;i&gt;happens-before&lt;/i&gt; every subsequent lock ({@code synchronized}
245  *   block or method entry) of that same monitor.  And because
246  *   the &lt;i&gt;happens-before&lt;/i&gt; relation is transitive, all actions
247  *   of a thread prior to unlocking &lt;i&gt;happen-before&lt;/i&gt; all actions
248  *   subsequent to any thread locking that monitor.
249  *
250  *   &lt;li&gt;A write to a {@code volatile} field &lt;i&gt;happens-before&lt;/i&gt; every
251  *   subsequent read of that same field.  Writes and reads of
252  *   {@code volatile} fields have similar memory consistency effects
253  *   as entering and exiting monitors, but do &lt;em&gt;not&lt;/em&gt; entail
254  *   mutual exclusion locking.
255  *
256  *   &lt;li&gt;A call to {@code start} on a thread &lt;i&gt;happens-before&lt;/i&gt; any
257  *   action in the started thread.
258  *
259  *   &lt;li&gt;All actions in a thread &lt;i&gt;happen-before&lt;/i&gt; any other thread
260  *   successfully returns from a {@code join} on that thread.
261  *
262  * &lt;/ul&gt;
263  *
264  * The methods of all classes in {@code java.util.concurrent} and its
265  * subpackages extend these guarantees to higher-level
266  * synchronization.  In particular:
267  *
268  * &lt;ul&gt;
269  *
270  *   &lt;li&gt;Actions in a thread prior to placing an object into any concurrent
271  *   collection &lt;i&gt;happen-before&lt;/i&gt; actions subsequent to the access or
272  *   removal of that element from the collection in another thread.
273  *
274  *   &lt;li&gt;Actions in a thread prior to the submission of a {@code Runnable}
275  *   to an {@code Executor} &lt;i&gt;happen-before&lt;/i&gt; its execution begins.
276  *   Similarly for {@code Callables} submitted to an {@code ExecutorService}.
277  *
278  *   &lt;li&gt;Actions taken by the asynchronous computation represented by a
279  *   {@code Future} &lt;i&gt;happen-before&lt;/i&gt; actions subsequent to the
280  *   retrieval of the result via {@code Future.get()} in another thread.
281  *
282  *   &lt;li&gt;Actions prior to &quot;releasing&quot; synchronizer methods such as
283  *   {@code Lock.unlock}, {@code Semaphore.release}, and
284  *   {@code CountDownLatch.countDown} &lt;i&gt;happen-before&lt;/i&gt; actions
285  *   subsequent to a successful &quot;acquiring&quot; method such as
286  *   {@code Lock.lock}, {@code Semaphore.acquire},
287  *   {@code Condition.await}, and {@code CountDownLatch.await} on the
288  *   same synchronizer object in another thread.
289  *
290  *   &lt;li&gt;For each pair of threads that successfully exchange objects via
291  *   an {@code Exchanger}, actions prior to the {@code exchange()}
292  *   in each thread &lt;i&gt;happen-before&lt;/i&gt; those subsequent to the
293  *   corresponding {@code exchange()} in another thread.
294  *
295  *   &lt;li&gt;Actions prior to calling {@code CyclicBarrier.await} and
296  *   {@code Phaser.awaitAdvance} (as well as its variants)
297  *   &lt;i&gt;happen-before&lt;/i&gt; actions performed by the barrier action, and
298  *   actions performed by the barrier action &lt;i&gt;happen-before&lt;/i&gt; actions
299  *   subsequent to a successful return from the corresponding {@code await}
300  *   in other threads.
301  *
302  * &lt;/ul&gt;
303  *
<a name="3" id="anc3"></a><span class="line-added">304  * @jls 17.4.5 Happens-before Order</span>
<span class="line-added">305  *</span>
306  * @since 1.5
307  */
308 package java.util.concurrent;
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
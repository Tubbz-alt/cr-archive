diff a/src/java.base/share/classes/java/text/DateFormat.java b/src/java.base/share/classes/java/text/DateFormat.java
--- a/src/java.base/share/classes/java/text/DateFormat.java
+++ b/src/java.base/share/classes/java/text/DateFormat.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -56,11 +56,11 @@
 /**
  * {@code DateFormat} is an abstract class for date/time formatting subclasses which
  * formats and parses dates or time in a language-independent manner.
  * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
  * formatting (i.e., date &rarr; text), parsing (text &rarr; date), and
- * normalization.  The date is represented as a <code>Date</code> object or
+ * normalization.  The date is represented as a {@code Date} object or
  * as the milliseconds since January 1, 1970, 00:00:00 GMT.
  *
  * <p>{@code DateFormat} provides many class methods for obtaining default date/time
  * formatters based on the default or a given locale and a number of formatting
  * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
@@ -138,11 +138,11 @@
  * <ul><li>progressively parse through pieces of a string.
  * <li>align any particular field, or find out where it is for selection
  * on the screen.
  * </ul>
  *
- * <h3><a id="synchronization">Synchronization</a></h3>
+ * <h2><a id="synchronization">Synchronization</a></h2>
  *
  * <p>
  * Date formats are not synchronized.
  * It is recommended to create separate format instances for each thread.
  * If multiple threads access a format concurrently, it must be synchronized
@@ -183,19 +183,19 @@
      * and the instant of time. This field is used for both formatting and
      * parsing.
      *
      * <p>Subclasses should initialize this field to a {@link Calendar}
      * appropriate for the {@link Locale} associated with this
-     * <code>DateFormat</code>.
+     * {@code DateFormat}.
      * @serial
      */
     protected Calendar calendar;
 
     /**
-     * The number formatter that <code>DateFormat</code> uses to format numbers
+     * The number formatter that {@code DateFormat} uses to format numbers
      * in dates and times.  Subclasses should initialize this to a number format
-     * appropriate for the locale associated with this <code>DateFormat</code>.
+     * appropriate for the locale associated with this {@code DateFormat}.
      * @serial
      */
     protected NumberFormat numberFormat;
 
     /**
@@ -296,10 +296,11 @@
      * Used in FieldPosition of date/time formatting.
      */
     public static final int TIMEZONE_FIELD = 17;
 
     // Proclaim serial compatibility with 1.1 FCS
+    @java.io.Serial
     private static final long serialVersionUID = 7218322306649953788L;
 
     /**
      * Formats the given {@code Object} into a date-time string. The formatted
      * string is appended to the given {@code StringBuffer}.
@@ -320,11 +321,11 @@
      * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
      * {@code fieldPosition} will be set to 5 and 8, respectively, for the
      * first occurrence of the timezone pattern character {@code 'z'}.
      * @return the string buffer passed in as {@code toAppendTo},
      *         with formatted text appended.
-     * @exception IllegalArgumentException if the {@code Format} cannot format
+     * @throws    IllegalArgumentException if the {@code Format} cannot format
      *            the given {@code obj}.
      * @see java.text.Format
      */
     public final StringBuffer format(Object obj, StringBuffer toAppendTo,
                                      FieldPosition fieldPosition)
@@ -380,13 +381,13 @@
      * The method may not use the entire text of the given string.
      * <p>
      * See the {@link #parse(String, ParsePosition)} method for more information
      * on date parsing.
      *
-     * @param source A <code>String</code> whose beginning should be parsed.
-     * @return A <code>Date</code> parsed from the string.
-     * @exception ParseException if the beginning of the specified string
+     * @param source A {@code String} whose beginning should be parsed.
+     * @return A {@code Date} parsed from the string.
+     * @throws    ParseException if the beginning of the specified string
      *            cannot be parsed.
      */
     public Date parse(String source) throws ParseException
     {
         ParsePosition pos = new ParsePosition(0);
@@ -424,30 +425,30 @@
      * @return      A {@code Date}, or {@code null} if the input could not be parsed
      */
     public abstract Date parse(String source, ParsePosition pos);
 
     /**
-     * Parses text from a string to produce a <code>Date</code>.
+     * Parses text from a string to produce a {@code Date}.
      * <p>
      * The method attempts to parse text starting at the index given by
-     * <code>pos</code>.
-     * If parsing succeeds, then the index of <code>pos</code> is updated
+     * {@code pos}.
+     * If parsing succeeds, then the index of {@code pos} is updated
      * to the index after the last character used (parsing does not necessarily
      * use all characters up to the end of the string), and the parsed
-     * date is returned. The updated <code>pos</code> can be used to
+     * date is returned. The updated {@code pos} can be used to
      * indicate the starting point for the next call to this method.
-     * If an error occurs, then the index of <code>pos</code> is not
-     * changed, the error index of <code>pos</code> is set to the index of
+     * If an error occurs, then the index of {@code pos} is not
+     * changed, the error index of {@code pos} is set to the index of
      * the character where the error occurred, and null is returned.
      * <p>
      * See the {@link #parse(String, ParsePosition)} method for more information
      * on date parsing.
      *
-     * @param source A <code>String</code>, part of which should be parsed.
-     * @param pos A <code>ParsePosition</code> object with index and error
+     * @param source A {@code String}, part of which should be parsed.
+     * @param pos A {@code ParsePosition} object with index and error
      *            index information as described above.
-     * @return A <code>Date</code> parsed from the string. In case of
+     * @return A {@code Date} parsed from the string. In case of
      *         error, returns null.
      * @throws NullPointerException if {@code source} or {@code pos} is null.
      */
     public Object parseObject(String source, ParsePosition pos) {
         return parse(source, pos);
@@ -625,20 +626,20 @@
         return getDateTimeInstance(SHORT, SHORT);
     }
 
     /**
      * Returns an array of all locales for which the
-     * <code>get*Instance</code> methods of this class can return
+     * {@code get*Instance} methods of this class can return
      * localized instances.
      * The returned array represents the union of locales supported by the Java
      * runtime and by installed
      * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
-     * It must contain at least a <code>Locale</code> instance equal to
+     * It must contain at least a {@code Locale} instance equal to
      * {@link java.util.Locale#US Locale.US}.
      *
      * @return An array of locales for which localized
-     *         <code>DateFormat</code> instances are available.
+     *         {@code DateFormat} instances are available.
      */
     public static Locale[] getAvailableLocales()
     {
         LocaleServiceProviderPool pool =
             LocaleServiceProviderPool.getPool(DateFormatProvider.class);
@@ -851,23 +852,24 @@
      */
     protected DateFormat() {}
 
     /**
      * Defines constants that are used as attribute keys in the
-     * <code>AttributedCharacterIterator</code> returned
-     * from <code>DateFormat.formatToCharacterIterator</code> and as
-     * field identifiers in <code>FieldPosition</code>.
+     * {@code AttributedCharacterIterator} returned
+     * from {@code DateFormat.formatToCharacterIterator} and as
+     * field identifiers in {@code FieldPosition}.
      * <p>
      * The class also provides two methods to map
      * between its constants and the corresponding Calendar constants.
      *
      * @since 1.4
      * @see java.util.Calendar
      */
     public static class Field extends Format.Field {
 
         // Proclaim serial compatibility with 1.4 FCS
+        @java.io.Serial
         private static final long serialVersionUID = 7441350119349544720L;
 
         // table of all instances in this class, used by readResolve
         private static final Map<String, Field> instanceMap = new HashMap<>(18);
         // Maps from Calendar constant (such as Calendar.ERA) to Field
@@ -877,17 +879,17 @@
 
         /** Calendar field. */
         private int calendarField;
 
         /**
-         * Returns the <code>Field</code> constant that corresponds to
-         * the <code>Calendar</code> constant <code>calendarField</code>.
-         * If there is no direct mapping between the <code>Calendar</code>
-         * constant and a <code>Field</code>, null is returned.
+         * Returns the {@code Field} constant that corresponds to
+         * the {@code Calendar} constant {@code calendarField}.
+         * If there is no direct mapping between the {@code Calendar}
+         * constant and a {@code Field}, null is returned.
          *
-         * @throws IllegalArgumentException if <code>calendarField</code> is
-         *         not the value of a <code>Calendar</code> field constant.
+         * @throws IllegalArgumentException if {@code calendarField} is
+         *         not the value of a {@code Calendar} field constant.
          * @param calendarField Calendar field constant
          * @return Field instance representing calendarField.
          * @see java.util.Calendar
          */
         public static Field ofCalendarField(int calendarField) {
@@ -898,18 +900,18 @@
             }
             return calendarToFieldMapping[calendarField];
         }
 
         /**
-         * Creates a <code>Field</code>.
+         * Creates a {@code Field}.
          *
-         * @param name the name of the <code>Field</code>
-         * @param calendarField the <code>Calendar</code> constant this
-         *        <code>Field</code> corresponds to; any value, even one
-         *        outside the range of legal <code>Calendar</code> values may
-         *        be used, but <code>-1</code> should be used for values
-         *        that don't correspond to legal <code>Calendar</code> values
+         * @param name the name of the {@code Field}
+         * @param calendarField the {@code Calendar} constant this
+         *        {@code Field} corresponds to; any value, even one
+         *        outside the range of legal {@code Calendar} values may
+         *        be used, but {@code -1} should be used for values
+         *        that don't correspond to legal {@code Calendar} values
          */
         protected Field(String name, int calendarField) {
             super(name);
             this.calendarField = calendarField;
             if (this.getClass() == DateFormat.Field.class) {
@@ -920,15 +922,15 @@
                 }
             }
         }
 
         /**
-         * Returns the <code>Calendar</code> field associated with this
+         * Returns the {@code Calendar} field associated with this
          * attribute. For example, if this represents the hours field of
-         * a <code>Calendar</code>, this would return
-         * <code>Calendar.HOUR</code>. If there is no corresponding
-         * <code>Calendar</code> constant, this will return -1.
+         * a {@code Calendar}, this would return
+         * {@code Calendar.HOUR}. If there is no corresponding
+         * {@code Calendar} constant, this will return -1.
          *
          * @return Calendar constant for this field
          * @see java.util.Calendar
          */
         public int getCalendarField() {
@@ -941,10 +943,11 @@
          * @throws InvalidObjectException if the constant could not be
          *         resolved.
          * @return resolved DateFormat.Field constant
          */
         @Override
+        @java.io.Serial
         protected Object readResolve() throws InvalidObjectException {
             if (this.getClass() != DateFormat.Field.class) {
                 throw new InvalidObjectException("subclass didn't correctly implement readResolve");
             }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadDeath.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Thread.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 123  * &lt;blockquote&gt;&lt;pre&gt;
 124  *     PrimeRun p = new PrimeRun(143);
 125  *     new Thread(p).start();
 126  * &lt;/pre&gt;&lt;/blockquote&gt;
 127  * &lt;p&gt;
 128  * Every thread has a name for identification purposes. More than
 129  * one thread may have the same name. If a name is not specified when
 130  * a thread is created, a new name is generated for it.
 131  * &lt;p&gt;
 132  * Unless otherwise noted, passing a {@code null} argument to a constructor
 133  * or method in this class will cause a {@link NullPointerException} to be
 134  * thrown.
 135  *
 136  * @author  unascribed
 137  * @see     Runnable
 138  * @see     Runtime#exit(int)
 139  * @see     #run()
 140  * @see     #stop()
 141  * @since   1.0
 142  */
<span class="line-modified"> 143 public</span>
<span class="line-removed"> 144 class Thread implements Runnable {</span>
 145     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 146     private static native void registerNatives();
 147     static {
 148         registerNatives();
 149     }
 150 
 151     private volatile String name;
 152     private int priority;
 153 
 154     /* Whether or not the thread is a daemon thread. */
 155     private boolean daemon = false;
 156 



 157     /* Fields reserved for exclusive use by the JVM */
 158     private boolean stillborn = false;
 159     private long eetop;
 160 
 161     /* What will be run. */
 162     private Runnable target;
 163 
 164     /* The group of this thread */
 165     private ThreadGroup group;
 166 
 167     /* The context ClassLoader for this thread */
 168     private ClassLoader contextClassLoader;
 169 
 170     /* The inherited AccessControlContext of this thread */
 171     private AccessControlContext inheritedAccessControlContext;
 172 
 173     /* For autonumbering anonymous threads. */
 174     private static int threadInitNumber;
 175     private static synchronized int nextThreadNum() {
 176         return threadInitNumber++;
 177     }
 178 
 179     /* ThreadLocal values pertaining to this thread. This map is maintained
 180      * by the ThreadLocal class. */
 181     ThreadLocal.ThreadLocalMap threadLocals = null;
 182 
 183     /*
 184      * InheritableThreadLocal values pertaining to this thread. This map is
 185      * maintained by the InheritableThreadLocal class.
 186      */
 187     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 188 
 189     /*
 190      * The requested stack size for this thread, or 0 if the creator did
 191      * not specify a stack size.  It is up to the VM to do whatever it
 192      * likes with this number; some VMs will ignore it.
 193      */
 194     private final long stackSize;
 195 
<span class="line-removed"> 196     /*</span>
<span class="line-removed"> 197      * JVM-private state that persists after native thread termination.</span>
<span class="line-removed"> 198      */</span>
<span class="line-removed"> 199     private long nativeParkEventPointer;</span>
<span class="line-removed"> 200 </span>
 201     /*
 202      * Thread ID
 203      */
 204     private final long tid;
 205 
 206     /* For generating thread ID */
 207     private static long threadSeqNumber;
 208 
 209     private static synchronized long nextThreadID() {
 210         return ++threadSeqNumber;
 211     }
 212 
 213     /*
 214      * Java thread status for tools, default indicates thread &#39;not yet started&#39;
 215      */
 216     private volatile int threadStatus;
 217 
 218     /**
 219      * The argument supplied to the current call to
 220      * java.util.concurrent.locks.LockSupport.park.
</pre>
<hr />
<pre>
 959      * methods of this class, then its interrupt status will be cleared and it
 960      * will receive an {@link InterruptedException}.
 961      *
 962      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
 963      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
 964      * then the channel will be closed, the thread&#39;s interrupt
 965      * status will be set, and the thread will receive a {@link
 966      * java.nio.channels.ClosedByInterruptException}.
 967      *
 968      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
 969      * then the thread&#39;s interrupt status will be set and it will return
 970      * immediately from the selection operation, possibly with a non-zero
 971      * value, just as if the selector&#39;s {@link
 972      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
 973      *
 974      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
 975      * status will be set. &lt;/p&gt;
 976      *
 977      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
 978      *




 979      * @throws  SecurityException
 980      *          if the current thread cannot modify this thread
 981      *
<span class="line-modified"> 982      * @revised 6.0</span>
 983      * @spec JSR-51
 984      */
 985     public void interrupt() {
 986         if (this != Thread.currentThread()) {
 987             checkAccess();
 988 
 989             // thread may be blocked in an I/O operation
 990             synchronized (blockerLock) {
 991                 Interruptible b = blocker;
 992                 if (b != null) {
<span class="line-modified"> 993                     interrupt0();  // set interrupt status</span>

 994                     b.interrupt(this);
 995                     return;
 996                 }
 997             }
 998         }
<span class="line-modified"> 999 </span>
<span class="line-modified">1000         // set interrupt status</span>
1001         interrupt0();
1002     }
1003 
1004     /**
1005      * Tests whether the current thread has been interrupted.  The
1006      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1007      * other words, if this method were to be called twice in succession, the
1008      * second call would return false (unless the current thread were
1009      * interrupted again, after the first call had cleared its interrupted
1010      * status and before the second call had examined it).
1011      *
<span class="line-removed">1012      * &lt;p&gt;A thread interruption ignored because a thread was not alive</span>
<span class="line-removed">1013      * at the time of the interrupt will be reflected by this method</span>
<span class="line-removed">1014      * returning false.</span>
<span class="line-removed">1015      *</span>
1016      * @return  {@code true} if the current thread has been interrupted;
1017      *          {@code false} otherwise.
1018      * @see #isInterrupted()
<span class="line-modified">1019      * @revised 6.0</span>
1020      */
1021     public static boolean interrupted() {
<span class="line-modified">1022         return currentThread().isInterrupted(true);</span>









1023     }
1024 
1025     /**
1026      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1027      * status&lt;/i&gt; of the thread is unaffected by this method.
1028      *
<span class="line-removed">1029      * &lt;p&gt;A thread interruption ignored because a thread was not alive</span>
<span class="line-removed">1030      * at the time of the interrupt will be reflected by this method</span>
<span class="line-removed">1031      * returning false.</span>
<span class="line-removed">1032      *</span>
1033      * @return  {@code true} if this thread has been interrupted;
1034      *          {@code false} otherwise.
1035      * @see     #interrupted()
<span class="line-modified">1036      * @revised 6.0</span>
1037      */
1038     public boolean isInterrupted() {
<span class="line-modified">1039         return isInterrupted(false);</span>
1040     }
1041 
<span class="line-removed">1042     /**</span>
<span class="line-removed">1043      * Tests if some Thread has been interrupted.  The interrupted state</span>
<span class="line-removed">1044      * is reset or not based on the value of ClearInterrupted that is</span>
<span class="line-removed">1045      * passed.</span>
<span class="line-removed">1046      */</span>
<span class="line-removed">1047     @HotSpotIntrinsicCandidate</span>
<span class="line-removed">1048     private native boolean isInterrupted(boolean ClearInterrupted);</span>
<span class="line-removed">1049 </span>
1050     /**
1051      * Tests if this thread is alive. A thread is alive if it has
1052      * been started and has not yet died.
1053      *
1054      * @return  {@code true} if this thread is alive;
1055      *          {@code false} otherwise.
1056      */
1057     public final native boolean isAlive();
1058 
1059     /**
1060      * Suspends this thread.
1061      * &lt;p&gt;
1062      * First, the {@code checkAccess} method of this thread is called
1063      * with no arguments. This may result in throwing a
1064      * {@code SecurityException }(in the current thread).
1065      * &lt;p&gt;
1066      * If the thread is alive, it is suspended and makes no further
1067      * progress unless and until it is resumed.
1068      *
1069      * @throws     SecurityException  if the current thread cannot modify
1070      *             this thread.
1071      * @see #checkAccess
1072      * @deprecated   This method has been deprecated, as it is
1073      *   inherently deadlock-prone.  If the target thread holds a lock on the
1074      *   monitor protecting a critical system resource when it is suspended, no
1075      *   thread can access this resource until the target thread is resumed. If
1076      *   the thread that would resume the target thread attempts to lock this
1077      *   monitor prior to calling {@code resume}, deadlock results.  Such
1078      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1079      *   For more information, see
1080      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1081      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1082      */
<span class="line-modified">1083     @Deprecated(since=&quot;1.2&quot;)</span>
1084     public final void suspend() {
1085         checkAccess();
1086         suspend0();
1087     }
1088 
1089     /**
1090      * Resumes a suspended thread.
1091      * &lt;p&gt;
1092      * First, the {@code checkAccess} method of this thread is called
1093      * with no arguments. This may result in throwing a
1094      * {@code SecurityException} (in the current thread).
1095      * &lt;p&gt;
1096      * If the thread is alive but suspended, it is resumed and is
1097      * permitted to make progress in its execution.
1098      *
1099      * @throws     SecurityException  if the current thread cannot modify this
1100      *             thread.
1101      * @see        #checkAccess
1102      * @see        #suspend()
1103      * @deprecated This method exists solely for use with {@link #suspend},
1104      *     which has been deprecated because it is deadlock-prone.
1105      *     For more information, see
1106      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1107      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1108      */
<span class="line-modified">1109     @Deprecated(since=&quot;1.2&quot;)</span>
1110     public final void resume() {
1111         checkAccess();
1112         resume0();
1113     }
1114 
1115     /**
1116      * Changes the priority of this thread.
1117      * &lt;p&gt;
1118      * First the {@code checkAccess} method of this thread is called
1119      * with no arguments. This may result in throwing a {@code SecurityException}.
1120      * &lt;p&gt;
1121      * Otherwise, the priority of this thread is set to the smaller of
1122      * the specified {@code newPriority} and the maximum permitted
1123      * priority of the thread&#39;s thread group.
1124      *
1125      * @param newPriority priority to set this thread to
1126      * @throws     IllegalArgumentException  If the priority is not in the
1127      *               range {@code MIN_PRIORITY} to
1128      *               {@code MAX_PRIORITY}.
1129      * @throws     SecurityException  if the current thread cannot modify
</pre>
<hr />
<pre>
1239      * invoker should verify that the returned int value is strictly less
1240      * than the length of {@code tarray}.
1241      *
1242      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
1243      * that the method only be used for debugging and monitoring purposes.
1244      *
1245      * @param  tarray
1246      *         an array into which to put the list of threads
1247      *
1248      * @return  the number of threads put into the array
1249      *
1250      * @throws  SecurityException
1251      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
1252      *          the current thread cannot access its thread group
1253      */
1254     public static int enumerate(Thread tarray[]) {
1255         return currentThread().getThreadGroup().enumerate(tarray);
1256     }
1257 
1258     /**
<span class="line-modified">1259      * Counts the number of stack frames in this thread. The thread must</span>
<span class="line-removed">1260      * be suspended.</span>
1261      *
<span class="line-modified">1262      * @return     the number of stack frames in this thread.</span>
<span class="line-modified">1263      * @throws     IllegalThreadStateException  if this thread is not</span>
<span class="line-modified">1264      *             suspended.</span>
<span class="line-modified">1265      * @deprecated The definition of this call depends on {@link #suspend},</span>
<span class="line-modified">1266      *             which is deprecated.  Further, the results of this call</span>
<span class="line-removed">1267      *             were never well-defined.</span>
1268      *             This method is subject to removal in a future version of Java SE.
1269      * @see        StackWalker
1270      */
1271     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
<span class="line-modified">1272     public native int countStackFrames();</span>


1273 
1274     /**
1275      * Waits at most {@code millis} milliseconds for this thread to
1276      * die. A timeout of {@code 0} means to wait forever.
1277      *
1278      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1279      * conditioned on {@code this.isAlive}. As a thread terminates the
1280      * {@code this.notifyAll} method is invoked. It is recommended that
1281      * applications not use {@code wait}, {@code notify}, or
1282      * {@code notifyAll} on {@code Thread} instances.
1283      *
1284      * @param  millis
1285      *         the time to wait in milliseconds
1286      *
1287      * @throws  IllegalArgumentException
1288      *          if the value of {@code millis} is negative
1289      *
1290      * @throws  InterruptedException
1291      *          if any thread has interrupted the current thread. The
1292      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</pre>
<hr />
<pre>
2068     // Hence, the fields are isolated with @Contended.
2069 
2070     /** The current seed for a ThreadLocalRandom */
2071     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2072     long threadLocalRandomSeed;
2073 
2074     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2075     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2076     int threadLocalRandomProbe;
2077 
2078     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2079     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2080     int threadLocalRandomSecondarySeed;
2081 
2082     /* Some private helper methods */
2083     private native void setPriority0(int newPriority);
2084     private native void stop0(Object o);
2085     private native void suspend0();
2086     private native void resume0();
2087     private native void interrupt0();

2088     private native void setNativeName(String name);
2089 }
</pre>
</td>
<td>
<hr />
<pre>
 123  * &lt;blockquote&gt;&lt;pre&gt;
 124  *     PrimeRun p = new PrimeRun(143);
 125  *     new Thread(p).start();
 126  * &lt;/pre&gt;&lt;/blockquote&gt;
 127  * &lt;p&gt;
 128  * Every thread has a name for identification purposes. More than
 129  * one thread may have the same name. If a name is not specified when
 130  * a thread is created, a new name is generated for it.
 131  * &lt;p&gt;
 132  * Unless otherwise noted, passing a {@code null} argument to a constructor
 133  * or method in this class will cause a {@link NullPointerException} to be
 134  * thrown.
 135  *
 136  * @author  unascribed
 137  * @see     Runnable
 138  * @see     Runtime#exit(int)
 139  * @see     #run()
 140  * @see     #stop()
 141  * @since   1.0
 142  */
<span class="line-modified"> 143 public class Thread implements Runnable {</span>

 144     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 145     private static native void registerNatives();
 146     static {
 147         registerNatives();
 148     }
 149 
 150     private volatile String name;
 151     private int priority;
 152 
 153     /* Whether or not the thread is a daemon thread. */
 154     private boolean daemon = false;
 155 
<span class="line-added"> 156     /* Interrupt state of the thread - read/written directly by JVM */</span>
<span class="line-added"> 157     private volatile boolean interrupted;</span>
<span class="line-added"> 158 </span>
 159     /* Fields reserved for exclusive use by the JVM */
 160     private boolean stillborn = false;
 161     private long eetop;
 162 
 163     /* What will be run. */
 164     private Runnable target;
 165 
 166     /* The group of this thread */
 167     private ThreadGroup group;
 168 
 169     /* The context ClassLoader for this thread */
 170     private ClassLoader contextClassLoader;
 171 
 172     /* The inherited AccessControlContext of this thread */
 173     private AccessControlContext inheritedAccessControlContext;
 174 
 175     /* For autonumbering anonymous threads. */
 176     private static int threadInitNumber;
 177     private static synchronized int nextThreadNum() {
 178         return threadInitNumber++;
 179     }
 180 
 181     /* ThreadLocal values pertaining to this thread. This map is maintained
 182      * by the ThreadLocal class. */
 183     ThreadLocal.ThreadLocalMap threadLocals = null;
 184 
 185     /*
 186      * InheritableThreadLocal values pertaining to this thread. This map is
 187      * maintained by the InheritableThreadLocal class.
 188      */
 189     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 190 
 191     /*
 192      * The requested stack size for this thread, or 0 if the creator did
 193      * not specify a stack size.  It is up to the VM to do whatever it
 194      * likes with this number; some VMs will ignore it.
 195      */
 196     private final long stackSize;
 197 





 198     /*
 199      * Thread ID
 200      */
 201     private final long tid;
 202 
 203     /* For generating thread ID */
 204     private static long threadSeqNumber;
 205 
 206     private static synchronized long nextThreadID() {
 207         return ++threadSeqNumber;
 208     }
 209 
 210     /*
 211      * Java thread status for tools, default indicates thread &#39;not yet started&#39;
 212      */
 213     private volatile int threadStatus;
 214 
 215     /**
 216      * The argument supplied to the current call to
 217      * java.util.concurrent.locks.LockSupport.park.
</pre>
<hr />
<pre>
 956      * methods of this class, then its interrupt status will be cleared and it
 957      * will receive an {@link InterruptedException}.
 958      *
 959      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
 960      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
 961      * then the channel will be closed, the thread&#39;s interrupt
 962      * status will be set, and the thread will receive a {@link
 963      * java.nio.channels.ClosedByInterruptException}.
 964      *
 965      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
 966      * then the thread&#39;s interrupt status will be set and it will return
 967      * immediately from the selection operation, possibly with a non-zero
 968      * value, just as if the selector&#39;s {@link
 969      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
 970      *
 971      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
 972      * status will be set. &lt;/p&gt;
 973      *
 974      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
 975      *
<span class="line-added"> 976      * @implNote In the JDK Reference Implementation, interruption of a thread</span>
<span class="line-added"> 977      * that is not alive still records that the interrupt request was made and</span>
<span class="line-added"> 978      * will report it via {@link #interrupted} and {@link #isInterrupted()}.</span>
<span class="line-added"> 979      *</span>
 980      * @throws  SecurityException
 981      *          if the current thread cannot modify this thread
 982      *
<span class="line-modified"> 983      * @revised 6.0, 14</span>
 984      * @spec JSR-51
 985      */
 986     public void interrupt() {
 987         if (this != Thread.currentThread()) {
 988             checkAccess();
 989 
 990             // thread may be blocked in an I/O operation
 991             synchronized (blockerLock) {
 992                 Interruptible b = blocker;
 993                 if (b != null) {
<span class="line-modified"> 994                     interrupted = true;</span>
<span class="line-added"> 995                     interrupt0();  // inform VM of interrupt</span>
 996                     b.interrupt(this);
 997                     return;
 998                 }
 999             }
1000         }
<span class="line-modified">1001         interrupted = true;</span>
<span class="line-modified">1002         // inform VM of interrupt</span>
1003         interrupt0();
1004     }
1005 
1006     /**
1007      * Tests whether the current thread has been interrupted.  The
1008      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1009      * other words, if this method were to be called twice in succession, the
1010      * second call would return false (unless the current thread were
1011      * interrupted again, after the first call had cleared its interrupted
1012      * status and before the second call had examined it).
1013      *




1014      * @return  {@code true} if the current thread has been interrupted;
1015      *          {@code false} otherwise.
1016      * @see #isInterrupted()
<span class="line-modified">1017      * @revised 6.0, 14</span>
1018      */
1019     public static boolean interrupted() {
<span class="line-modified">1020         Thread t = currentThread();</span>
<span class="line-added">1021         boolean interrupted = t.interrupted;</span>
<span class="line-added">1022         // We may have been interrupted the moment after we read the field,</span>
<span class="line-added">1023         // so only clear the field if we saw that it was set and will return</span>
<span class="line-added">1024         // true; otherwise we could lose an interrupt.</span>
<span class="line-added">1025         if (interrupted) {</span>
<span class="line-added">1026             t.interrupted = false;</span>
<span class="line-added">1027             clearInterruptEvent();</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029         return interrupted;</span>
1030     }
1031 
1032     /**
1033      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1034      * status&lt;/i&gt; of the thread is unaffected by this method.
1035      *




1036      * @return  {@code true} if this thread has been interrupted;
1037      *          {@code false} otherwise.
1038      * @see     #interrupted()
<span class="line-modified">1039      * @revised 6.0, 14</span>
1040      */
1041     public boolean isInterrupted() {
<span class="line-modified">1042         return interrupted;</span>
1043     }
1044 








1045     /**
1046      * Tests if this thread is alive. A thread is alive if it has
1047      * been started and has not yet died.
1048      *
1049      * @return  {@code true} if this thread is alive;
1050      *          {@code false} otherwise.
1051      */
1052     public final native boolean isAlive();
1053 
1054     /**
1055      * Suspends this thread.
1056      * &lt;p&gt;
1057      * First, the {@code checkAccess} method of this thread is called
1058      * with no arguments. This may result in throwing a
1059      * {@code SecurityException }(in the current thread).
1060      * &lt;p&gt;
1061      * If the thread is alive, it is suspended and makes no further
1062      * progress unless and until it is resumed.
1063      *
1064      * @throws     SecurityException  if the current thread cannot modify
1065      *             this thread.
1066      * @see #checkAccess
1067      * @deprecated   This method has been deprecated, as it is
1068      *   inherently deadlock-prone.  If the target thread holds a lock on the
1069      *   monitor protecting a critical system resource when it is suspended, no
1070      *   thread can access this resource until the target thread is resumed. If
1071      *   the thread that would resume the target thread attempts to lock this
1072      *   monitor prior to calling {@code resume}, deadlock results.  Such
1073      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1074      *   For more information, see
1075      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1076      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1077      */
<span class="line-modified">1078     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
1079     public final void suspend() {
1080         checkAccess();
1081         suspend0();
1082     }
1083 
1084     /**
1085      * Resumes a suspended thread.
1086      * &lt;p&gt;
1087      * First, the {@code checkAccess} method of this thread is called
1088      * with no arguments. This may result in throwing a
1089      * {@code SecurityException} (in the current thread).
1090      * &lt;p&gt;
1091      * If the thread is alive but suspended, it is resumed and is
1092      * permitted to make progress in its execution.
1093      *
1094      * @throws     SecurityException  if the current thread cannot modify this
1095      *             thread.
1096      * @see        #checkAccess
1097      * @see        #suspend()
1098      * @deprecated This method exists solely for use with {@link #suspend},
1099      *     which has been deprecated because it is deadlock-prone.
1100      *     For more information, see
1101      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1102      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1103      */
<span class="line-modified">1104     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)</span>
1105     public final void resume() {
1106         checkAccess();
1107         resume0();
1108     }
1109 
1110     /**
1111      * Changes the priority of this thread.
1112      * &lt;p&gt;
1113      * First the {@code checkAccess} method of this thread is called
1114      * with no arguments. This may result in throwing a {@code SecurityException}.
1115      * &lt;p&gt;
1116      * Otherwise, the priority of this thread is set to the smaller of
1117      * the specified {@code newPriority} and the maximum permitted
1118      * priority of the thread&#39;s thread group.
1119      *
1120      * @param newPriority priority to set this thread to
1121      * @throws     IllegalArgumentException  If the priority is not in the
1122      *               range {@code MIN_PRIORITY} to
1123      *               {@code MAX_PRIORITY}.
1124      * @throws     SecurityException  if the current thread cannot modify
</pre>
<hr />
<pre>
1234      * invoker should verify that the returned int value is strictly less
1235      * than the length of {@code tarray}.
1236      *
1237      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
1238      * that the method only be used for debugging and monitoring purposes.
1239      *
1240      * @param  tarray
1241      *         an array into which to put the list of threads
1242      *
1243      * @return  the number of threads put into the array
1244      *
1245      * @throws  SecurityException
1246      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
1247      *          the current thread cannot access its thread group
1248      */
1249     public static int enumerate(Thread tarray[]) {
1250         return currentThread().getThreadGroup().enumerate(tarray);
1251     }
1252 
1253     /**
<span class="line-modified">1254      * Throws {@code UnsupportedOperationException}.</span>

1255      *
<span class="line-modified">1256      * @return     nothing</span>
<span class="line-modified">1257      *</span>
<span class="line-modified">1258      * @deprecated This method was originally designed to count the number of</span>
<span class="line-modified">1259      *             stack frames but the results were never well-defined and it</span>
<span class="line-modified">1260      *             depended on thread-suspension.</span>

1261      *             This method is subject to removal in a future version of Java SE.
1262      * @see        StackWalker
1263      */
1264     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
<span class="line-modified">1265     public int countStackFrames() {</span>
<span class="line-added">1266         throw new UnsupportedOperationException();</span>
<span class="line-added">1267     }</span>
1268 
1269     /**
1270      * Waits at most {@code millis} milliseconds for this thread to
1271      * die. A timeout of {@code 0} means to wait forever.
1272      *
1273      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1274      * conditioned on {@code this.isAlive}. As a thread terminates the
1275      * {@code this.notifyAll} method is invoked. It is recommended that
1276      * applications not use {@code wait}, {@code notify}, or
1277      * {@code notifyAll} on {@code Thread} instances.
1278      *
1279      * @param  millis
1280      *         the time to wait in milliseconds
1281      *
1282      * @throws  IllegalArgumentException
1283      *          if the value of {@code millis} is negative
1284      *
1285      * @throws  InterruptedException
1286      *          if any thread has interrupted the current thread. The
1287      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
</pre>
<hr />
<pre>
2063     // Hence, the fields are isolated with @Contended.
2064 
2065     /** The current seed for a ThreadLocalRandom */
2066     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2067     long threadLocalRandomSeed;
2068 
2069     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2070     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2071     int threadLocalRandomProbe;
2072 
2073     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2074     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2075     int threadLocalRandomSecondarySeed;
2076 
2077     /* Some private helper methods */
2078     private native void setPriority0(int newPriority);
2079     private native void stop0(Object o);
2080     private native void suspend0();
2081     private native void resume0();
2082     private native void interrupt0();
<span class="line-added">2083     private static native void clearInterruptEvent();</span>
2084     private native void setNativeName(String name);
2085 }
</pre>
</td>
</tr>
</table>
<center><a href="System.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadDeath.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
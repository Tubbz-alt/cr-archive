<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectStreamClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 


  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.lang.ref.WeakReference;
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.Field;
  34 import java.lang.reflect.InvocationTargetException;

  35 import java.lang.reflect.UndeclaredThrowableException;
  36 import java.lang.reflect.Member;
  37 import java.lang.reflect.Method;
  38 import java.lang.reflect.Modifier;
  39 import java.lang.reflect.Proxy;
  40 import java.security.AccessControlContext;
  41 import java.security.AccessController;
  42 import java.security.MessageDigest;
  43 import java.security.NoSuchAlgorithmException;
  44 import java.security.PermissionCollection;
  45 import java.security.Permissions;
  46 import java.security.PrivilegedAction;


  47 import java.security.ProtectionDomain;
  48 import java.util.ArrayList;
  49 import java.util.Arrays;
  50 import java.util.Collections;
  51 import java.util.Comparator;
  52 import java.util.HashSet;
  53 import java.util.Set;
  54 import java.util.concurrent.ConcurrentHashMap;
  55 import java.util.concurrent.ConcurrentMap;
  56 import jdk.internal.misc.Unsafe;
  57 import jdk.internal.reflect.CallerSensitive;
  58 import jdk.internal.reflect.Reflection;
  59 import jdk.internal.reflect.ReflectionFactory;
  60 import jdk.internal.access.SharedSecrets;
  61 import jdk.internal.access.JavaSecurityAccess;
  62 import sun.reflect.misc.ReflectUtil;
  63 import static java.io.ObjectStreamField.*;
  64 
  65 /**
  66  * Serialization&#39;s descriptor for classes.  It contains the name and
  67  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  68  * loaded in this Java VM can be found/created using the lookup method.
  69  *
  70  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  71  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  72  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  73  *
  74  * @author      Mike Warres
  75  * @author      Roger Riggs
  76  * @see ObjectStreamField
  77  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  78  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  79  * @since   1.1
  80  */
  81 public class ObjectStreamClass implements Serializable {
  82 
  83     /** serialPersistentFields value indicating no serializable fields */
  84     public static final ObjectStreamField[] NO_FIELDS =
  85         new ObjectStreamField[0];
  86 

  87     private static final long serialVersionUID = -6120832682080437368L;

  88     private static final ObjectStreamField[] serialPersistentFields =
  89         NO_FIELDS;
  90 
  91     /** reflection factory for obtaining serialization constructors */
  92     private static final ReflectionFactory reflFactory =
  93         AccessController.doPrivileged(
  94             new ReflectionFactory.GetReflectionFactoryAction());
  95 
  96     private static class Caches {
  97         /** cache mapping local classes -&gt; descriptors */
  98         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
  99             new ConcurrentHashMap&lt;&gt;();
 100 
 101         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 102         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 103             new ConcurrentHashMap&lt;&gt;();
 104 
 105         /** queue for WeakReferences to local classes */
 106         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 107             new ReferenceQueue&lt;&gt;();
 108         /** queue for WeakReferences to field reflectors keys */
 109         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 110             new ReferenceQueue&lt;&gt;();
 111     }
 112 
 113     /** class associated with this descriptor (if any) */
 114     private Class&lt;?&gt; cl;
 115     /** name of class represented by this descriptor */
 116     private String name;
 117     /** serialVersionUID of represented class (null if not computed yet) */
 118     private volatile Long suid;
 119 
 120     /** true if represents dynamic proxy class */
 121     private boolean isProxy;
 122     /** true if represents enum type */
 123     private boolean isEnum;


 124     /** true if represented class implements Serializable */
 125     private boolean serializable;
 126     /** true if represented class implements Externalizable */
 127     private boolean externalizable;
 128     /** true if desc has data written by class-defined writeObject method */
 129     private boolean hasWriteObjectData;
 130     /**
 131      * true if desc has externalizable data written in block data format; this
 132      * must be true by default to accommodate ObjectInputStream subclasses which
 133      * override readClassDescriptor() to return class descriptors obtained from
 134      * ObjectStreamClass.lookup() (see 4461737)
 135      */
 136     private boolean hasBlockExternalData = true;
 137 
 138     /**
 139      * Contains information about InvalidClassException instances to be thrown
 140      * when attempting operations on an invalid class. Note that instances of
 141      * this class are immutable and are potentially shared among
 142      * ObjectStreamClass instances.
 143      */
</pre>
<hr />
<pre>
 165     /** exception (if any) to throw if non-enum deserialization attempted */
 166     private ExceptionInfo deserializeEx;
 167     /** exception (if any) to throw if non-enum serialization attempted */
 168     private ExceptionInfo serializeEx;
 169     /** exception (if any) to throw if default serialization attempted */
 170     private ExceptionInfo defaultSerializeEx;
 171 
 172     /** serializable fields */
 173     private ObjectStreamField[] fields;
 174     /** aggregate marshalled size of primitive fields */
 175     private int primDataSize;
 176     /** number of non-primitive fields */
 177     private int numObjFields;
 178     /** reflector for setting/getting serializable field values */
 179     private FieldReflector fieldRefl;
 180     /** data layout of serialized objects described by this class desc */
 181     private volatile ClassDataSlot[] dataLayout;
 182 
 183     /** serialization-appropriate constructor, or null if none */
 184     private Constructor&lt;?&gt; cons;


 185     /** protection domains that need to be checked when calling the constructor */
 186     private ProtectionDomain[] domains;
 187 
 188     /** class-defined writeObject method, or null if none */
 189     private Method writeObjectMethod;
 190     /** class-defined readObject method, or null if none */
 191     private Method readObjectMethod;
 192     /** class-defined readObjectNoData method, or null if none */
 193     private Method readObjectNoDataMethod;
 194     /** class-defined writeReplace method, or null if none */
 195     private Method writeReplaceMethod;
 196     /** class-defined readResolve method, or null if none */
 197     private Method readResolveMethod;
 198 
 199     /** local class descriptor for represented class (may point to self) */
 200     private ObjectStreamClass localDesc;
 201     /** superclass descriptor appearing in stream */
 202     private ObjectStreamClass superDesc;
 203 
 204     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 242      * This method returns the name of the class in the format that
 243      * is used by the {@link Class#getName} method.
 244      *
 245      * @return a string representing the name of the class
 246      */
 247     public String getName() {
 248         return name;
 249     }
 250 
 251     /**
 252      * Return the serialVersionUID for this class.  The serialVersionUID
 253      * defines a set of classes all with the same name that have evolved from a
 254      * common root class and agree to be serialized and deserialized using a
 255      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 256      *
 257      * @return  the SUID of the class described by this descriptor
 258      */
 259     public long getSerialVersionUID() {
 260         // REMIND: synchronize instead of relying on volatile?
 261         if (suid == null) {



 262             suid = AccessController.doPrivileged(
 263                 new PrivilegedAction&lt;Long&gt;() {
 264                     public Long run() {
 265                         return computeDefaultSUID(cl);
 266                     }
 267                 }
 268             );
 269         }
 270         return suid.longValue();
 271     }
 272 
 273     /**
 274      * Return the class in the local VM that this version is mapped to.  Null
 275      * is returned if there is no corresponding local class.
 276      *
<span class="line-modified"> 277      * @return  the &lt;code&gt;Class&lt;/code&gt; instance that this descriptor represents</span>
 278      */
 279     @CallerSensitive
 280     public Class&lt;?&gt; forClass() {
 281         if (cl == null) {
 282             return null;
 283         }
 284         requireInitialized();
 285         if (System.getSecurityManager() != null) {
 286             Class&lt;?&gt; caller = Reflection.getCallerClass();
 287             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 288                 ReflectUtil.checkPackageAccess(cl);
 289             }
 290         }
 291         return cl;
 292     }
 293 
 294     /**
 295      * Return an array of the fields of this serializable class.
 296      *
 297      * @return  an array containing an element for each persistent field of
</pre>
<hr />
<pre>
 448                 AccessController.doPrivileged(
 449                     new PrivilegedAction&lt;&gt;() {
 450                         public Void run() {
 451                             Thread.currentThread().interrupt();
 452                             return null;
 453                         }
 454                     }
 455                 );
 456             }
 457             return entry;
 458         }
 459 
 460         /**
 461          * Returns the thread that created this EntryFuture.
 462          */
 463         Thread getOwner() {
 464             return owner;
 465         }
 466     }
 467 





 468     /**
 469      * Creates local class descriptor representing given class.
 470      */
 471     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 472         this.cl = cl;
 473         name = cl.getName();
 474         isProxy = Proxy.isProxyClass(cl);
 475         isEnum = Enum.class.isAssignableFrom(cl);

 476         serializable = Serializable.class.isAssignableFrom(cl);
 477         externalizable = Externalizable.class.isAssignableFrom(cl);
 478 
 479         Class&lt;?&gt; superCl = cl.getSuperclass();
 480         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 481         localDesc = this;
 482 
 483         if (serializable) {
 484             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 485                 public Void run() {
 486                     if (isEnum) {
 487                         suid = Long.valueOf(0);
 488                         fields = NO_FIELDS;
 489                         return null;
 490                     }
 491                     if (cl.isArray()) {
 492                         fields = NO_FIELDS;
 493                         return null;
 494                     }
 495 
 496                     suid = getDeclaredSUID(cl);
 497                     try {
 498                         fields = getSerialFields(cl);
 499                         computeFieldOffsets();
 500                     } catch (InvalidClassException e) {
 501                         serializeEx = deserializeEx =
 502                             new ExceptionInfo(e.classname, e.getMessage());
 503                         fields = NO_FIELDS;
 504                     }
 505 
<span class="line-modified"> 506                     if (externalizable) {</span>


 507                         cons = getExternalizableConstructor(cl);
 508                     } else {
 509                         cons = getSerializableConstructor(cl);
 510                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 511                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 512                             Void.TYPE);
 513                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 514                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 515                             Void.TYPE);
 516                         readObjectNoDataMethod = getPrivateMethod(
 517                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 518                         hasWriteObjectData = (writeObjectMethod != null);
 519                     }
 520                     domains = getProtectionDomains(cons, cl);
 521                     writeReplaceMethod = getInheritableMethod(
 522                         cl, &quot;writeReplace&quot;, null, Object.class);
 523                     readResolveMethod = getInheritableMethod(
 524                         cl, &quot;readResolve&quot;, null, Object.class);
 525                     return null;
 526                 }
 527             });
 528         } else {
 529             suid = Long.valueOf(0);
 530             fields = NO_FIELDS;
 531         }
 532 
 533         try {
 534             fieldRefl = getReflector(fields, this);
 535         } catch (InvalidClassException ex) {
 536             // field mismatches impossible when matching local fields vs. self
 537             throw new InternalError(ex);
 538         }
 539 
 540         if (deserializeEx == null) {
 541             if (isEnum) {
 542                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<span class="line-modified"> 543             } else if (cons == null) {</span>
 544                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 545             }
 546         }
<span class="line-modified"> 547         for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-modified"> 548             if (fields[i].getField() == null) {</span>
<span class="line-modified"> 549                 defaultSerializeEx = new ExceptionInfo(</span>
<span class="line-modified"> 550                     name, &quot;unmatched serializable field(s) declared&quot;);</span>




 551             }
 552         }
 553         initialized = true;
 554     }
 555 
 556     /**
 557      * Creates blank class descriptor which should be initialized via a
 558      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 559      */
 560     ObjectStreamClass() {
 561     }
 562 
 563     /**
 564      * Creates a PermissionDomain that grants no permission.
 565      */
 566     private ProtectionDomain noPermissionsDomain() {
 567         PermissionCollection perms = new Permissions();
 568         perms.setReadOnly();
 569         return new ProtectionDomain(null, perms);
 570     }
</pre>
<hr />
<pre>
 663                       Class&lt;?&gt; cl,
 664                       ClassNotFoundException resolveEx,
 665                       ObjectStreamClass superDesc)
 666         throws InvalidClassException
 667     {
 668         long suid = Long.valueOf(model.getSerialVersionUID());
 669         ObjectStreamClass osc = null;
 670         if (cl != null) {
 671             osc = lookup(cl, true);
 672             if (osc.isProxy) {
 673                 throw new InvalidClassException(
 674                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 675             }
 676             if (model.isEnum != osc.isEnum) {
 677                 throw new InvalidClassException(model.isEnum ?
 678                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 679                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 680             }
 681 
 682             if (model.serializable == osc.serializable &amp;&amp;
<span class="line-modified"> 683                     !cl.isArray() &amp;&amp;</span>
 684                     suid != osc.getSerialVersionUID()) {
 685                 throw new InvalidClassException(osc.name,
 686                         &quot;local class incompatible: &quot; +
 687                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 688                                 &quot;, local class serialVersionUID = &quot; +
 689                                 osc.getSerialVersionUID());
 690             }
 691 
 692             if (!classNamesEqual(model.name, osc.name)) {
 693                 throw new InvalidClassException(osc.name,
 694                         &quot;local class name incompatible with stream class &quot; +
 695                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 696             }
 697 
 698             if (!model.isEnum) {
 699                 if ((model.serializable == osc.serializable) &amp;&amp;
 700                         (model.externalizable != osc.externalizable)) {
 701                     throw new InvalidClassException(osc.name,
 702                             &quot;Serializable incompatible with Externalizable&quot;);
 703                 }
 704 
 705                 if ((model.serializable != osc.serializable) ||
 706                         (model.externalizable != osc.externalizable) ||
 707                         !(model.serializable || model.externalizable)) {
 708                     deserializeEx = new ExceptionInfo(
 709                             osc.name, &quot;class invalid for deserialization&quot;);
 710                 }
 711             }
 712         }
 713 
 714         this.cl = cl;




 715         this.resolveEx = resolveEx;
 716         this.superDesc = superDesc;
 717         name = model.name;
 718         this.suid = suid;
 719         isProxy = false;
 720         isEnum = model.isEnum;
 721         serializable = model.serializable;
 722         externalizable = model.externalizable;
 723         hasBlockExternalData = model.hasBlockExternalData;
 724         hasWriteObjectData = model.hasWriteObjectData;
 725         fields = model.fields;
 726         primDataSize = model.primDataSize;
 727         numObjFields = model.numObjFields;
 728 
 729         if (osc != null) {
 730             localDesc = osc;
 731             writeObjectMethod = localDesc.writeObjectMethod;
 732             readObjectMethod = localDesc.readObjectMethod;
 733             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 734             writeReplaceMethod = localDesc.writeReplaceMethod;
 735             readResolveMethod = localDesc.readResolveMethod;
 736             if (deserializeEx == null) {
 737                 deserializeEx = localDesc.deserializeEx;
 738             }
 739             domains = localDesc.domains;

 740             cons = localDesc.cons;
 741         }
 742 
 743         fieldRefl = getReflector(fields, localDesc);
 744         // reassign to matched fields so as to reflect local unshared settings
 745         fields = fieldRefl.getFields();

 746         initialized = true;
 747     }
 748 
 749     /**
 750      * Reads non-proxy class descriptor information from given input stream.
 751      * The resulting class descriptor is not fully functional; it can only be
 752      * used as input to the ObjectInputStream.resolveClass() and
 753      * ObjectStreamClass.initNonProxy() methods.
 754      */
 755     void readNonProxy(ObjectInputStream in)
 756         throws IOException, ClassNotFoundException
 757     {
 758         name = in.readUTF();
 759         suid = Long.valueOf(in.readLong());
 760         isProxy = false;
 761 
 762         byte flags = in.readByte();
 763         hasWriteObjectData =
 764             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 765         hasBlockExternalData =
</pre>
<hr />
<pre>
 947     }
 948 
 949     /**
 950      * Returns true if class descriptor represents a dynamic proxy class, false
 951      * otherwise.
 952      */
 953     boolean isProxy() {
 954         requireInitialized();
 955         return isProxy;
 956     }
 957 
 958     /**
 959      * Returns true if class descriptor represents an enum type, false
 960      * otherwise.
 961      */
 962     boolean isEnum() {
 963         requireInitialized();
 964         return isEnum;
 965     }
 966 









 967     /**
 968      * Returns true if represented class implements Externalizable, false
 969      * otherwise.
 970      */
 971     boolean isExternalizable() {
 972         requireInitialized();
 973         return externalizable;
 974     }
 975 
 976     /**
 977      * Returns true if represented class implements Serializable, false
 978      * otherwise.
 979      */
 980     boolean isSerializable() {
 981         requireInitialized();
 982         return serializable;
 983     }
 984 
 985     /**
 986      * Returns true if class descriptor represents externalizable class that
</pre>
<hr />
<pre>
1499     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1500         try {
1501             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1502             cons.setAccessible(true);
1503             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1504                 cons : null;
1505         } catch (NoSuchMethodException ex) {
1506             return null;
1507         }
1508     }
1509 
1510     /**
1511      * Returns subclass-accessible no-arg constructor of first non-serializable
1512      * superclass, or null if none found.  Access checks are disabled on the
1513      * returned constructor (if any).
1514      */
1515     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1516         return reflFactory.newConstructorForSerialization(cl);
1517     }
1518 































1519     /**
1520      * Returns non-static, non-abstract method with given signature provided it
1521      * is defined by or accessible (via inheritance) by the given class, or
1522      * null if no match found.  Access checks are disabled on the returned
1523      * method (if any).
1524      */
1525     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1526                                                Class&lt;?&gt;[] argTypes,
1527                                                Class&lt;?&gt; returnType)
1528     {
1529         Method meth = null;
1530         Class&lt;?&gt; defCl = cl;
1531         while (defCl != null) {
1532             try {
1533                 meth = defCl.getDeclaredMethod(name, argTypes);
1534                 break;
1535             } catch (NoSuchMethodException ex) {
1536                 defCl = defCl.getSuperclass();
1537             }
1538         }
</pre>
<hr />
<pre>
1622             throw (RuntimeException) th;
1623         } else if (th instanceof Error) {
1624             throw (Error) th;
1625         } else {
1626             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1627             ex.initCause(th);
1628             throw ex;
1629         }
1630     }
1631 
1632     /**
1633      * Returns ObjectStreamField array describing the serializable fields of
1634      * the given class.  Serializable fields backed by an actual field of the
1635      * class are represented by ObjectStreamFields with corresponding non-null
1636      * Field objects.  Throws InvalidClassException if the (explicitly
1637      * declared) serializable fields are invalid.
1638      */
1639     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1640         throws InvalidClassException
1641     {



1642         ObjectStreamField[] fields;
<span class="line-modified">1643         if (Serializable.class.isAssignableFrom(cl) &amp;&amp;</span>
<span class="line-modified">1644             !Externalizable.class.isAssignableFrom(cl) &amp;&amp;</span>


1645             !Proxy.isProxyClass(cl) &amp;&amp;
<span class="line-modified">1646             !cl.isInterface())</span>
<span class="line-removed">1647         {</span>
1648             if ((fields = getDeclaredSerialFields(cl)) == null) {
1649                 fields = getDefaultSerialFields(cl);
1650             }
1651             Arrays.sort(fields);
1652         } else {
1653             fields = NO_FIELDS;
1654         }
1655         return fields;
1656     }
1657 
1658     /**
1659      * Returns serializable fields of given class as defined explicitly by a
1660      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1661      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1662      * by an actual field of the class are represented by ObjectStreamFields
1663      * with corresponding non-null Field objects.  For compatibility with past
1664      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1665      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1666      * InvalidClassException if the declared serializable fields are
1667      * invalid--e.g., if multiple fields share the same name.
</pre>
<hr />
<pre>
2419         /**
2420          * Returns true if the given object is this identical
2421          * WeakClassKey instance, or, if this object&#39;s referent has not
2422          * been cleared, if the given object is another WeakClassKey
2423          * instance with the identical non-null referent as this one.
2424          */
2425         public boolean equals(Object obj) {
2426             if (obj == this) {
2427                 return true;
2428             }
2429 
2430             if (obj instanceof WeakClassKey) {
2431                 Object referent = get();
2432                 return (referent != null) &amp;&amp;
2433                        (referent == ((WeakClassKey) obj).get());
2434             } else {
2435                 return false;
2436             }
2437         }
2438     }















































































































2439 }
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
<span class="line-added">  28 import java.lang.invoke.MethodHandle;</span>
<span class="line-added">  29 import java.lang.invoke.MethodHandles;</span>
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InvocationTargetException;
<span class="line-added">  37 import java.lang.reflect.RecordComponent;</span>
  38 import java.lang.reflect.UndeclaredThrowableException;
  39 import java.lang.reflect.Member;
  40 import java.lang.reflect.Method;
  41 import java.lang.reflect.Modifier;
  42 import java.lang.reflect.Proxy;
  43 import java.security.AccessControlContext;
  44 import java.security.AccessController;
  45 import java.security.MessageDigest;
  46 import java.security.NoSuchAlgorithmException;
  47 import java.security.PermissionCollection;
  48 import java.security.Permissions;
  49 import java.security.PrivilegedAction;
<span class="line-added">  50 import java.security.PrivilegedActionException;</span>
<span class="line-added">  51 import java.security.PrivilegedExceptionAction;</span>
  52 import java.security.ProtectionDomain;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.HashSet;
  58 import java.util.Set;
  59 import java.util.concurrent.ConcurrentHashMap;
  60 import java.util.concurrent.ConcurrentMap;
  61 import jdk.internal.misc.Unsafe;
  62 import jdk.internal.reflect.CallerSensitive;
  63 import jdk.internal.reflect.Reflection;
  64 import jdk.internal.reflect.ReflectionFactory;
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.access.JavaSecurityAccess;
  67 import sun.reflect.misc.ReflectUtil;
  68 import static java.io.ObjectStreamField.*;
  69 
  70 /**
  71  * Serialization&#39;s descriptor for classes.  It contains the name and
  72  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  73  * loaded in this Java VM can be found/created using the lookup method.
  74  *
  75  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  76  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  77  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
  78  *
  79  * @author      Mike Warres
  80  * @author      Roger Riggs
  81  * @see ObjectStreamField
  82  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html&quot;&gt;
  83  *     Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;
  84  * @since   1.1
  85  */
  86 public class ObjectStreamClass implements Serializable {
  87 
  88     /** serialPersistentFields value indicating no serializable fields */
  89     public static final ObjectStreamField[] NO_FIELDS =
  90         new ObjectStreamField[0];
  91 
<span class="line-added">  92     @java.io.Serial</span>
  93     private static final long serialVersionUID = -6120832682080437368L;
<span class="line-added">  94     @java.io.Serial</span>
  95     private static final ObjectStreamField[] serialPersistentFields =
  96         NO_FIELDS;
  97 
  98     /** reflection factory for obtaining serialization constructors */
  99     private static final ReflectionFactory reflFactory =
 100         AccessController.doPrivileged(
 101             new ReflectionFactory.GetReflectionFactoryAction());
 102 
 103     private static class Caches {
 104         /** cache mapping local classes -&gt; descriptors */
 105         static final ConcurrentMap&lt;WeakClassKey,Reference&lt;?&gt;&gt; localDescs =
 106             new ConcurrentHashMap&lt;&gt;();
 107 
 108         /** cache mapping field group/local desc pairs -&gt; field reflectors */
 109         static final ConcurrentMap&lt;FieldReflectorKey,Reference&lt;?&gt;&gt; reflectors =
 110             new ConcurrentHashMap&lt;&gt;();
 111 
 112         /** queue for WeakReferences to local classes */
 113         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; localDescsQueue =
 114             new ReferenceQueue&lt;&gt;();
 115         /** queue for WeakReferences to field reflectors keys */
 116         private static final ReferenceQueue&lt;Class&lt;?&gt;&gt; reflectorsQueue =
 117             new ReferenceQueue&lt;&gt;();
 118     }
 119 
 120     /** class associated with this descriptor (if any) */
 121     private Class&lt;?&gt; cl;
 122     /** name of class represented by this descriptor */
 123     private String name;
 124     /** serialVersionUID of represented class (null if not computed yet) */
 125     private volatile Long suid;
 126 
 127     /** true if represents dynamic proxy class */
 128     private boolean isProxy;
 129     /** true if represents enum type */
 130     private boolean isEnum;
<span class="line-added"> 131     /** true if represents record type */</span>
<span class="line-added"> 132     private boolean isRecord;</span>
 133     /** true if represented class implements Serializable */
 134     private boolean serializable;
 135     /** true if represented class implements Externalizable */
 136     private boolean externalizable;
 137     /** true if desc has data written by class-defined writeObject method */
 138     private boolean hasWriteObjectData;
 139     /**
 140      * true if desc has externalizable data written in block data format; this
 141      * must be true by default to accommodate ObjectInputStream subclasses which
 142      * override readClassDescriptor() to return class descriptors obtained from
 143      * ObjectStreamClass.lookup() (see 4461737)
 144      */
 145     private boolean hasBlockExternalData = true;
 146 
 147     /**
 148      * Contains information about InvalidClassException instances to be thrown
 149      * when attempting operations on an invalid class. Note that instances of
 150      * this class are immutable and are potentially shared among
 151      * ObjectStreamClass instances.
 152      */
</pre>
<hr />
<pre>
 174     /** exception (if any) to throw if non-enum deserialization attempted */
 175     private ExceptionInfo deserializeEx;
 176     /** exception (if any) to throw if non-enum serialization attempted */
 177     private ExceptionInfo serializeEx;
 178     /** exception (if any) to throw if default serialization attempted */
 179     private ExceptionInfo defaultSerializeEx;
 180 
 181     /** serializable fields */
 182     private ObjectStreamField[] fields;
 183     /** aggregate marshalled size of primitive fields */
 184     private int primDataSize;
 185     /** number of non-primitive fields */
 186     private int numObjFields;
 187     /** reflector for setting/getting serializable field values */
 188     private FieldReflector fieldRefl;
 189     /** data layout of serialized objects described by this class desc */
 190     private volatile ClassDataSlot[] dataLayout;
 191 
 192     /** serialization-appropriate constructor, or null if none */
 193     private Constructor&lt;?&gt; cons;
<span class="line-added"> 194     /** record canonical constructor, or null */</span>
<span class="line-added"> 195     private MethodHandle canonicalCtr;</span>
 196     /** protection domains that need to be checked when calling the constructor */
 197     private ProtectionDomain[] domains;
 198 
 199     /** class-defined writeObject method, or null if none */
 200     private Method writeObjectMethod;
 201     /** class-defined readObject method, or null if none */
 202     private Method readObjectMethod;
 203     /** class-defined readObjectNoData method, or null if none */
 204     private Method readObjectNoDataMethod;
 205     /** class-defined writeReplace method, or null if none */
 206     private Method writeReplaceMethod;
 207     /** class-defined readResolve method, or null if none */
 208     private Method readResolveMethod;
 209 
 210     /** local class descriptor for represented class (may point to self) */
 211     private ObjectStreamClass localDesc;
 212     /** superclass descriptor appearing in stream */
 213     private ObjectStreamClass superDesc;
 214 
 215     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 253      * This method returns the name of the class in the format that
 254      * is used by the {@link Class#getName} method.
 255      *
 256      * @return a string representing the name of the class
 257      */
 258     public String getName() {
 259         return name;
 260     }
 261 
 262     /**
 263      * Return the serialVersionUID for this class.  The serialVersionUID
 264      * defines a set of classes all with the same name that have evolved from a
 265      * common root class and agree to be serialized and deserialized using a
 266      * common format.  NonSerializable classes have a serialVersionUID of 0L.
 267      *
 268      * @return  the SUID of the class described by this descriptor
 269      */
 270     public long getSerialVersionUID() {
 271         // REMIND: synchronize instead of relying on volatile?
 272         if (suid == null) {
<span class="line-added"> 273             if (isRecord)</span>
<span class="line-added"> 274                 return 0L;</span>
<span class="line-added"> 275 </span>
 276             suid = AccessController.doPrivileged(
 277                 new PrivilegedAction&lt;Long&gt;() {
 278                     public Long run() {
 279                         return computeDefaultSUID(cl);
 280                     }
 281                 }
 282             );
 283         }
 284         return suid.longValue();
 285     }
 286 
 287     /**
 288      * Return the class in the local VM that this version is mapped to.  Null
 289      * is returned if there is no corresponding local class.
 290      *
<span class="line-modified"> 291      * @return  the {@code Class} instance that this descriptor represents</span>
 292      */
 293     @CallerSensitive
 294     public Class&lt;?&gt; forClass() {
 295         if (cl == null) {
 296             return null;
 297         }
 298         requireInitialized();
 299         if (System.getSecurityManager() != null) {
 300             Class&lt;?&gt; caller = Reflection.getCallerClass();
 301             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(), cl.getClassLoader())) {
 302                 ReflectUtil.checkPackageAccess(cl);
 303             }
 304         }
 305         return cl;
 306     }
 307 
 308     /**
 309      * Return an array of the fields of this serializable class.
 310      *
 311      * @return  an array containing an element for each persistent field of
</pre>
<hr />
<pre>
 462                 AccessController.doPrivileged(
 463                     new PrivilegedAction&lt;&gt;() {
 464                         public Void run() {
 465                             Thread.currentThread().interrupt();
 466                             return null;
 467                         }
 468                     }
 469                 );
 470             }
 471             return entry;
 472         }
 473 
 474         /**
 475          * Returns the thread that created this EntryFuture.
 476          */
 477         Thread getOwner() {
 478             return owner;
 479         }
 480     }
 481 
<span class="line-added"> 482     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 483     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-added"> 484         return cls.isRecord();</span>
<span class="line-added"> 485     }</span>
<span class="line-added"> 486 </span>
 487     /**
 488      * Creates local class descriptor representing given class.
 489      */
 490     private ObjectStreamClass(final Class&lt;?&gt; cl) {
 491         this.cl = cl;
 492         name = cl.getName();
 493         isProxy = Proxy.isProxyClass(cl);
 494         isEnum = Enum.class.isAssignableFrom(cl);
<span class="line-added"> 495         isRecord = isRecord(cl);</span>
 496         serializable = Serializable.class.isAssignableFrom(cl);
 497         externalizable = Externalizable.class.isAssignableFrom(cl);
 498 
 499         Class&lt;?&gt; superCl = cl.getSuperclass();
 500         superDesc = (superCl != null) ? lookup(superCl, false) : null;
 501         localDesc = this;
 502 
 503         if (serializable) {
 504             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 505                 public Void run() {
 506                     if (isEnum) {
 507                         suid = Long.valueOf(0);
 508                         fields = NO_FIELDS;
 509                         return null;
 510                     }
 511                     if (cl.isArray()) {
 512                         fields = NO_FIELDS;
 513                         return null;
 514                     }
 515 
 516                     suid = getDeclaredSUID(cl);
 517                     try {
 518                         fields = getSerialFields(cl);
 519                         computeFieldOffsets();
 520                     } catch (InvalidClassException e) {
 521                         serializeEx = deserializeEx =
 522                             new ExceptionInfo(e.classname, e.getMessage());
 523                         fields = NO_FIELDS;
 524                     }
 525 
<span class="line-modified"> 526                     if (isRecord) {</span>
<span class="line-added"> 527                         canonicalCtr = canonicalRecordCtr(cl);</span>
<span class="line-added"> 528                     } else if (externalizable) {</span>
 529                         cons = getExternalizableConstructor(cl);
 530                     } else {
 531                         cons = getSerializableConstructor(cl);
 532                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 533                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 534                             Void.TYPE);
 535                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 536                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 537                             Void.TYPE);
 538                         readObjectNoDataMethod = getPrivateMethod(
 539                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 540                         hasWriteObjectData = (writeObjectMethod != null);
 541                     }
 542                     domains = getProtectionDomains(cons, cl);
 543                     writeReplaceMethod = getInheritableMethod(
 544                         cl, &quot;writeReplace&quot;, null, Object.class);
 545                     readResolveMethod = getInheritableMethod(
 546                         cl, &quot;readResolve&quot;, null, Object.class);
 547                     return null;
 548                 }
 549             });
 550         } else {
 551             suid = Long.valueOf(0);
 552             fields = NO_FIELDS;
 553         }
 554 
 555         try {
 556             fieldRefl = getReflector(fields, this);
 557         } catch (InvalidClassException ex) {
 558             // field mismatches impossible when matching local fields vs. self
 559             throw new InternalError(ex);
 560         }
 561 
 562         if (deserializeEx == null) {
 563             if (isEnum) {
 564                 deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<span class="line-modified"> 565             } else if (cons == null &amp;&amp; !isRecord) {</span>
 566                 deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
 567             }
 568         }
<span class="line-modified"> 569         if (isRecord &amp;&amp; canonicalCtr == null) {</span>
<span class="line-modified"> 570             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);</span>
<span class="line-modified"> 571         } else {</span>
<span class="line-modified"> 572             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added"> 573                 if (fields[i].getField() == null) {</span>
<span class="line-added"> 574                     defaultSerializeEx = new ExceptionInfo(</span>
<span class="line-added"> 575                         name, &quot;unmatched serializable field(s) declared&quot;);</span>
<span class="line-added"> 576                 }</span>
 577             }
 578         }
 579         initialized = true;
 580     }
 581 
 582     /**
 583      * Creates blank class descriptor which should be initialized via a
 584      * subsequent call to initProxy(), initNonProxy() or readNonProxy().
 585      */
 586     ObjectStreamClass() {
 587     }
 588 
 589     /**
 590      * Creates a PermissionDomain that grants no permission.
 591      */
 592     private ProtectionDomain noPermissionsDomain() {
 593         PermissionCollection perms = new Permissions();
 594         perms.setReadOnly();
 595         return new ProtectionDomain(null, perms);
 596     }
</pre>
<hr />
<pre>
 689                       Class&lt;?&gt; cl,
 690                       ClassNotFoundException resolveEx,
 691                       ObjectStreamClass superDesc)
 692         throws InvalidClassException
 693     {
 694         long suid = Long.valueOf(model.getSerialVersionUID());
 695         ObjectStreamClass osc = null;
 696         if (cl != null) {
 697             osc = lookup(cl, true);
 698             if (osc.isProxy) {
 699                 throw new InvalidClassException(
 700                         &quot;cannot bind non-proxy descriptor to a proxy class&quot;);
 701             }
 702             if (model.isEnum != osc.isEnum) {
 703                 throw new InvalidClassException(model.isEnum ?
 704                         &quot;cannot bind enum descriptor to a non-enum class&quot; :
 705                         &quot;cannot bind non-enum descriptor to an enum class&quot;);
 706             }
 707 
 708             if (model.serializable == osc.serializable &amp;&amp;
<span class="line-modified"> 709                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;</span>
 710                     suid != osc.getSerialVersionUID()) {
 711                 throw new InvalidClassException(osc.name,
 712                         &quot;local class incompatible: &quot; +
 713                                 &quot;stream classdesc serialVersionUID = &quot; + suid +
 714                                 &quot;, local class serialVersionUID = &quot; +
 715                                 osc.getSerialVersionUID());
 716             }
 717 
 718             if (!classNamesEqual(model.name, osc.name)) {
 719                 throw new InvalidClassException(osc.name,
 720                         &quot;local class name incompatible with stream class &quot; +
 721                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 722             }
 723 
 724             if (!model.isEnum) {
 725                 if ((model.serializable == osc.serializable) &amp;&amp;
 726                         (model.externalizable != osc.externalizable)) {
 727                     throw new InvalidClassException(osc.name,
 728                             &quot;Serializable incompatible with Externalizable&quot;);
 729                 }
 730 
 731                 if ((model.serializable != osc.serializable) ||
 732                         (model.externalizable != osc.externalizable) ||
 733                         !(model.serializable || model.externalizable)) {
 734                     deserializeEx = new ExceptionInfo(
 735                             osc.name, &quot;class invalid for deserialization&quot;);
 736                 }
 737             }
 738         }
 739 
 740         this.cl = cl;
<span class="line-added"> 741         if (cl != null) {</span>
<span class="line-added"> 742             this.isRecord = isRecord(cl);</span>
<span class="line-added"> 743             this.canonicalCtr = osc.canonicalCtr;</span>
<span class="line-added"> 744         }</span>
 745         this.resolveEx = resolveEx;
 746         this.superDesc = superDesc;
 747         name = model.name;
 748         this.suid = suid;
 749         isProxy = false;
 750         isEnum = model.isEnum;
 751         serializable = model.serializable;
 752         externalizable = model.externalizable;
 753         hasBlockExternalData = model.hasBlockExternalData;
 754         hasWriteObjectData = model.hasWriteObjectData;
 755         fields = model.fields;
 756         primDataSize = model.primDataSize;
 757         numObjFields = model.numObjFields;
 758 
 759         if (osc != null) {
 760             localDesc = osc;
 761             writeObjectMethod = localDesc.writeObjectMethod;
 762             readObjectMethod = localDesc.readObjectMethod;
 763             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 764             writeReplaceMethod = localDesc.writeReplaceMethod;
 765             readResolveMethod = localDesc.readResolveMethod;
 766             if (deserializeEx == null) {
 767                 deserializeEx = localDesc.deserializeEx;
 768             }
 769             domains = localDesc.domains;
<span class="line-added"> 770             assert isRecord(cl) ? localDesc.cons == null : true;</span>
 771             cons = localDesc.cons;
 772         }
 773 
 774         fieldRefl = getReflector(fields, localDesc);
 775         // reassign to matched fields so as to reflect local unshared settings
 776         fields = fieldRefl.getFields();
<span class="line-added"> 777 </span>
 778         initialized = true;
 779     }
 780 
 781     /**
 782      * Reads non-proxy class descriptor information from given input stream.
 783      * The resulting class descriptor is not fully functional; it can only be
 784      * used as input to the ObjectInputStream.resolveClass() and
 785      * ObjectStreamClass.initNonProxy() methods.
 786      */
 787     void readNonProxy(ObjectInputStream in)
 788         throws IOException, ClassNotFoundException
 789     {
 790         name = in.readUTF();
 791         suid = Long.valueOf(in.readLong());
 792         isProxy = false;
 793 
 794         byte flags = in.readByte();
 795         hasWriteObjectData =
 796             ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
 797         hasBlockExternalData =
</pre>
<hr />
<pre>
 979     }
 980 
 981     /**
 982      * Returns true if class descriptor represents a dynamic proxy class, false
 983      * otherwise.
 984      */
 985     boolean isProxy() {
 986         requireInitialized();
 987         return isProxy;
 988     }
 989 
 990     /**
 991      * Returns true if class descriptor represents an enum type, false
 992      * otherwise.
 993      */
 994     boolean isEnum() {
 995         requireInitialized();
 996         return isEnum;
 997     }
 998 
<span class="line-added"> 999     /**</span>
<span class="line-added">1000      * Returns true if class descriptor represents a record type, false</span>
<span class="line-added">1001      * otherwise.</span>
<span class="line-added">1002      */</span>
<span class="line-added">1003     boolean isRecord() {</span>
<span class="line-added">1004         requireInitialized();</span>
<span class="line-added">1005         return isRecord;</span>
<span class="line-added">1006     }</span>
<span class="line-added">1007 </span>
1008     /**
1009      * Returns true if represented class implements Externalizable, false
1010      * otherwise.
1011      */
1012     boolean isExternalizable() {
1013         requireInitialized();
1014         return externalizable;
1015     }
1016 
1017     /**
1018      * Returns true if represented class implements Serializable, false
1019      * otherwise.
1020      */
1021     boolean isSerializable() {
1022         requireInitialized();
1023         return serializable;
1024     }
1025 
1026     /**
1027      * Returns true if class descriptor represents externalizable class that
</pre>
<hr />
<pre>
1540     private static Constructor&lt;?&gt; getExternalizableConstructor(Class&lt;?&gt; cl) {
1541         try {
1542             Constructor&lt;?&gt; cons = cl.getDeclaredConstructor((Class&lt;?&gt;[]) null);
1543             cons.setAccessible(true);
1544             return ((cons.getModifiers() &amp; Modifier.PUBLIC) != 0) ?
1545                 cons : null;
1546         } catch (NoSuchMethodException ex) {
1547             return null;
1548         }
1549     }
1550 
1551     /**
1552      * Returns subclass-accessible no-arg constructor of first non-serializable
1553      * superclass, or null if none found.  Access checks are disabled on the
1554      * returned constructor (if any).
1555      */
1556     private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
1557         return reflFactory.newConstructorForSerialization(cl);
1558     }
1559 
<span class="line-added">1560     /**</span>
<span class="line-added">1561      * Returns the canonical constructor for the given record class, or null if</span>
<span class="line-added">1562      * the not found ( which should never happen for correctly generated record</span>
<span class="line-added">1563      * classes ).</span>
<span class="line-added">1564      */</span>
<span class="line-added">1565     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1566     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {</span>
<span class="line-added">1567         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;</span>
<span class="line-added">1568         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {</span>
<span class="line-added">1569             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())</span>
<span class="line-added">1570                                           .map(RecordComponent::getType)</span>
<span class="line-added">1571                                           .toArray(Class&lt;?&gt;[]::new);</span>
<span class="line-added">1572             try {</span>
<span class="line-added">1573                 Constructor&lt;?&gt; ctr = cls.getConstructor(paramTypes);</span>
<span class="line-added">1574                 ctr.setAccessible(true);</span>
<span class="line-added">1575                 return MethodHandles.lookup().unreflectConstructor(ctr);</span>
<span class="line-added">1576             } catch (IllegalAccessException | NoSuchMethodException e) {</span>
<span class="line-added">1577                 return null;</span>
<span class="line-added">1578             }</span>
<span class="line-added">1579         };</span>
<span class="line-added">1580         return AccessController.doPrivileged(pa);</span>
<span class="line-added">1581     }</span>
<span class="line-added">1582 </span>
<span class="line-added">1583     /**</span>
<span class="line-added">1584      * Returns the canonical constructor, if the local class equivalent of this</span>
<span class="line-added">1585      * stream class descriptor is a record class, otherwise null.</span>
<span class="line-added">1586      */</span>
<span class="line-added">1587     MethodHandle getRecordConstructor() {</span>
<span class="line-added">1588         return canonicalCtr;</span>
<span class="line-added">1589     }</span>
<span class="line-added">1590 </span>
1591     /**
1592      * Returns non-static, non-abstract method with given signature provided it
1593      * is defined by or accessible (via inheritance) by the given class, or
1594      * null if no match found.  Access checks are disabled on the returned
1595      * method (if any).
1596      */
1597     private static Method getInheritableMethod(Class&lt;?&gt; cl, String name,
1598                                                Class&lt;?&gt;[] argTypes,
1599                                                Class&lt;?&gt; returnType)
1600     {
1601         Method meth = null;
1602         Class&lt;?&gt; defCl = cl;
1603         while (defCl != null) {
1604             try {
1605                 meth = defCl.getDeclaredMethod(name, argTypes);
1606                 break;
1607             } catch (NoSuchMethodException ex) {
1608                 defCl = defCl.getSuperclass();
1609             }
1610         }
</pre>
<hr />
<pre>
1694             throw (RuntimeException) th;
1695         } else if (th instanceof Error) {
1696             throw (Error) th;
1697         } else {
1698             IOException ex = new IOException(&quot;unexpected exception type&quot;);
1699             ex.initCause(th);
1700             throw ex;
1701         }
1702     }
1703 
1704     /**
1705      * Returns ObjectStreamField array describing the serializable fields of
1706      * the given class.  Serializable fields backed by an actual field of the
1707      * class are represented by ObjectStreamFields with corresponding non-null
1708      * Field objects.  Throws InvalidClassException if the (explicitly
1709      * declared) serializable fields are invalid.
1710      */
1711     private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
1712         throws InvalidClassException
1713     {
<span class="line-added">1714         if (!Serializable.class.isAssignableFrom(cl))</span>
<span class="line-added">1715             return NO_FIELDS;</span>
<span class="line-added">1716 </span>
1717         ObjectStreamField[] fields;
<span class="line-modified">1718         if (isRecord(cl)) {</span>
<span class="line-modified">1719             fields = getDefaultSerialFields(cl);</span>
<span class="line-added">1720             Arrays.sort(fields);</span>
<span class="line-added">1721         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;</span>
1722             !Proxy.isProxyClass(cl) &amp;&amp;
<span class="line-modified">1723                    !cl.isInterface()) {</span>

1724             if ((fields = getDeclaredSerialFields(cl)) == null) {
1725                 fields = getDefaultSerialFields(cl);
1726             }
1727             Arrays.sort(fields);
1728         } else {
1729             fields = NO_FIELDS;
1730         }
1731         return fields;
1732     }
1733 
1734     /**
1735      * Returns serializable fields of given class as defined explicitly by a
1736      * &quot;serialPersistentFields&quot; field, or null if no appropriate
1737      * &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
1738      * by an actual field of the class are represented by ObjectStreamFields
1739      * with corresponding non-null Field objects.  For compatibility with past
1740      * releases, a &quot;serialPersistentFields&quot; field with a null value is
1741      * considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
1742      * InvalidClassException if the declared serializable fields are
1743      * invalid--e.g., if multiple fields share the same name.
</pre>
<hr />
<pre>
2495         /**
2496          * Returns true if the given object is this identical
2497          * WeakClassKey instance, or, if this object&#39;s referent has not
2498          * been cleared, if the given object is another WeakClassKey
2499          * instance with the identical non-null referent as this one.
2500          */
2501         public boolean equals(Object obj) {
2502             if (obj == this) {
2503                 return true;
2504             }
2505 
2506             if (obj instanceof WeakClassKey) {
2507                 Object referent = get();
2508                 return (referent != null) &amp;&amp;
2509                        (referent == ((WeakClassKey) obj).get());
2510             } else {
2511                 return false;
2512             }
2513         }
2514     }
<span class="line-added">2515 </span>
<span class="line-added">2516     /** Record specific support for retrieving and binding stream field values. */</span>
<span class="line-added">2517     static final class RecordSupport {</span>
<span class="line-added">2518 </span>
<span class="line-added">2519         /** Binds the given stream field values to the given method handle. */</span>
<span class="line-added">2520         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2521         static MethodHandle bindCtrValues(MethodHandle ctrMH,</span>
<span class="line-added">2522                                           ObjectStreamClass desc,</span>
<span class="line-added">2523                                           ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">2524             RecordComponent[] recordComponents;</span>
<span class="line-added">2525             try {</span>
<span class="line-added">2526                 Class&lt;?&gt; cls = desc.forClass();</span>
<span class="line-added">2527                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;</span>
<span class="line-added">2528                 recordComponents = AccessController.doPrivileged(pa);</span>
<span class="line-added">2529             } catch (PrivilegedActionException e) {</span>
<span class="line-added">2530                 throw new InternalError(e.getCause());</span>
<span class="line-added">2531             }</span>
<span class="line-added">2532 </span>
<span class="line-added">2533             Object[] args = new Object[recordComponents.length];</span>
<span class="line-added">2534             for (int i = 0; i &lt; recordComponents.length; i++) {</span>
<span class="line-added">2535                 String name = recordComponents[i].getName();</span>
<span class="line-added">2536                 Class&lt;?&gt; type= recordComponents[i].getType();</span>
<span class="line-added">2537                 Object o = streamFieldValue(name, type, desc, fieldValues);</span>
<span class="line-added">2538                 args[i] = o;</span>
<span class="line-added">2539             }</span>
<span class="line-added">2540 </span>
<span class="line-added">2541             return MethodHandles.insertArguments(ctrMH, 0, args);</span>
<span class="line-added">2542         }</span>
<span class="line-added">2543 </span>
<span class="line-added">2544         /** Returns the number of primitive fields for the given descriptor. */</span>
<span class="line-added">2545         private static int numberPrimValues(ObjectStreamClass desc) {</span>
<span class="line-added">2546             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">2547             int primValueCount = 0;</span>
<span class="line-added">2548             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2549                 if (fields[i].isPrimitive())</span>
<span class="line-added">2550                     primValueCount++;</span>
<span class="line-added">2551                 else</span>
<span class="line-added">2552                     break;  // can be no more</span>
<span class="line-added">2553             }</span>
<span class="line-added">2554             return primValueCount;</span>
<span class="line-added">2555         }</span>
<span class="line-added">2556 </span>
<span class="line-added">2557         /** Returns the default value for the given type. */</span>
<span class="line-added">2558         private static Object defaultValueFor(Class&lt;?&gt; pType) {</span>
<span class="line-added">2559             if (pType == Integer.TYPE)</span>
<span class="line-added">2560                 return 0;</span>
<span class="line-added">2561             else if (pType == Byte.TYPE)</span>
<span class="line-added">2562                 return (byte)0;</span>
<span class="line-added">2563             else if (pType == Long.TYPE)</span>
<span class="line-added">2564                 return 0L;</span>
<span class="line-added">2565             else if (pType == Float.TYPE)</span>
<span class="line-added">2566                 return 0.0f;</span>
<span class="line-added">2567             else if (pType == Double.TYPE)</span>
<span class="line-added">2568                 return 0.0d;</span>
<span class="line-added">2569             else if (pType == Short.TYPE)</span>
<span class="line-added">2570                 return (short)0;</span>
<span class="line-added">2571             else if (pType == Character.TYPE)</span>
<span class="line-added">2572                 return &#39;\u0000&#39;;</span>
<span class="line-added">2573             else if (pType == Boolean.TYPE)</span>
<span class="line-added">2574                 return false;</span>
<span class="line-added">2575             else</span>
<span class="line-added">2576                 return null;</span>
<span class="line-added">2577         }</span>
<span class="line-added">2578 </span>
<span class="line-added">2579         /**</span>
<span class="line-added">2580          * Returns the stream field value for the given name. The default value</span>
<span class="line-added">2581          * for the given type is returned if the field value is absent.</span>
<span class="line-added">2582          */</span>
<span class="line-added">2583         private static Object streamFieldValue(String pName,</span>
<span class="line-added">2584                                                Class&lt;?&gt; pType,</span>
<span class="line-added">2585                                                ObjectStreamClass desc,</span>
<span class="line-added">2586                                                ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">2587             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">2588 </span>
<span class="line-added">2589             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2590                 ObjectStreamField f = fields[i];</span>
<span class="line-added">2591                 String fName = f.getName();</span>
<span class="line-added">2592                 if (!fName.equals(pName))</span>
<span class="line-added">2593                     continue;</span>
<span class="line-added">2594 </span>
<span class="line-added">2595                 Class&lt;?&gt; fType = f.getField().getType();</span>
<span class="line-added">2596                 if (!pType.isAssignableFrom(fType))</span>
<span class="line-added">2597                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);</span>
<span class="line-added">2598 </span>
<span class="line-added">2599                 if (f.isPrimitive()) {</span>
<span class="line-added">2600                     if (pType == Integer.TYPE)</span>
<span class="line-added">2601                         return Bits.getInt(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2602                     else if (fType == Byte.TYPE)</span>
<span class="line-added">2603                         return fieldValues.primValues[f.getOffset()];</span>
<span class="line-added">2604                     else if (fType == Long.TYPE)</span>
<span class="line-added">2605                         return Bits.getLong(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2606                     else if (fType == Float.TYPE)</span>
<span class="line-added">2607                         return Bits.getFloat(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2608                     else if (fType == Double.TYPE)</span>
<span class="line-added">2609                         return Bits.getDouble(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2610                     else if (fType == Short.TYPE)</span>
<span class="line-added">2611                         return Bits.getShort(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2612                     else if (fType == Character.TYPE)</span>
<span class="line-added">2613                         return Bits.getChar(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2614                     else if (fType == Boolean.TYPE)</span>
<span class="line-added">2615                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">2616                     else</span>
<span class="line-added">2617                         throw new InternalError(&quot;Unexpected type: &quot; + fType);</span>
<span class="line-added">2618                 } else { // reference</span>
<span class="line-added">2619                     return fieldValues.objValues[i - numberPrimValues(desc)];</span>
<span class="line-added">2620                 }</span>
<span class="line-added">2621             }</span>
<span class="line-added">2622 </span>
<span class="line-added">2623             return defaultValueFor(pType);</span>
<span class="line-added">2624         }</span>
<span class="line-added">2625     }</span>
2626 }
</pre>
</td>
</tr>
</table>
<center><a href="ObjectOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
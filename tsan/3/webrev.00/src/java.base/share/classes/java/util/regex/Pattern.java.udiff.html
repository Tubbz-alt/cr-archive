<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/regex/Pattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Matcher.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PatternSyntaxException.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Pattern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,10 +41,11 @@</span>
  import java.util.Spliterators;
  import java.util.function.Predicate;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  
<span class="udiff-line-added">+ import jdk.internal.util.ArraysSupport;</span>
  
  /**
   * A compiled representation of a regular expression.
   *
   * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,11 +76,11 @@</span>
   * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
   * concurrent threads.  Instances of the {@link Matcher} class are not safe for
   * such use.
   *
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;table class=&quot;borderless&quot;&gt;
   * &lt;caption style=&quot;display:none&quot;&gt;Regular expression constructs, and what they match&lt;/caption&gt;
   * &lt;thead style=&quot;text-align:left&quot;&gt;
   * &lt;tr&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,15 +355,15 @@</span>
   * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;flags&quot;&gt;&lt;code&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
   *     &lt;td headers=&quot;matches special flags&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
   * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
   * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
   * on - off&lt;/td&gt;&lt;/tr&gt;
<span class="udiff-line-modified-removed">-  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;&lt;code&gt;(?idmsux-idmsux:&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;{@code (?idmsuxU-idmsuxU:}&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;</span>
   *     &lt;td headers=&quot;matches special non_capture_group_flags&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
   *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
   * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
<span class="udiff-line-modified-removed">-  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;</span>
   * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookahead&quot;&gt;{@code (?=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
   *     &lt;td headers=&quot;matches special pos_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
   * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookahead&quot;&gt;{@code (?!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
   *     &lt;td headers=&quot;matches special neg_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
   * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookbehind&quot;&gt;{@code (?&lt;=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,11 +377,11 @@</span>
   * &lt;/table&gt;
   *
   * &lt;hr&gt;
   *
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt; The backslash character ({@code &#39;\&#39;}) serves to introduce escaped
   * constructs, as defined in the table above, as well as to quote characters
   * that otherwise would be interpreted as unescaped constructs.  Thus the
   * expression {@code \\} matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -404,11 +405,11 @@</span>
   * word boundary.  The string literal {@code &quot;\(hello\)&quot;} is illegal
   * and leads to a compile-time error; in order to match the string
   * {@code (hello)} the string literal {@code &quot;\\(hello\\)&quot;}
   * must be used.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h2&gt;</span>
   *
   *    &lt;p&gt; Character classes may appear within other character classes, and
   *    may be composed by the union operator (implicit) and the intersection
   *    operator ({@code &amp;&amp;}).
   *    The union operator denotes a class that contains every character that is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,11 +448,11 @@</span>
   *    a character class than outside a character class. For instance, the
   *    regular expression {@code .} loses its special meaning inside a
   *    character class, while the expression {@code -} becomes a range
   *    forming metacharacter.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
   * the end of a line of the input character sequence.  The following are
   * recognized as line terminators:
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -482,13 +483,13 @@</span>
   * of the entire input sequence. If {@link #MULTILINE} mode is activated then
   * {@code ^} matches at the beginning of input and after any line terminator
   * except at the end of input. When in {@link #MULTILINE} mode {@code $}
   * matches just before a line terminator or the end of the input sequence.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h2&gt;</span>
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h3&gt;</span>
   * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
   * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
   * are four such groups: &lt;/p&gt;
   *
   * &lt;ol style=&quot;margin-left:2em;&quot;&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -503,11 +504,11 @@</span>
   * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
   * of the input sequence that matches such a group is saved.  The captured
   * subsequence may be used later in the expression, via a back reference, and
   * may also be retrieved from the matcher once the match operation is complete.
   *
<span class="udiff-line-modified-removed">-  * &lt;h4&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h4&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h3&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h3&gt;</span>
   * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a {@code named-capturing group},
   * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
   * the following characters. The first character must be a {@code letter}.
   *
   * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,16 +533,16 @@</span>
   *
   * &lt;p&gt; Groups beginning with {@code (?} are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
   * that do not capture text and do not count towards the group total, or
   * &lt;i&gt;named-capturing&lt;/i&gt; group.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt; Unicode support &lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt; Unicode support &lt;/h2&gt;</span>
   *
   * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
   * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
   * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
<span class="udiff-line-modified-removed">-  * Canonical Equivalents.</span>
<span class="udiff-line-modified-added">+  * Canonical Equivalents and RL2.2 Extended Grapheme Clusters.</span>
   * &lt;p&gt;
   * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;code&gt;&amp;#92;u2014&lt;/code&gt; in Java source code
   * are processed as described in section 3.3 of
   * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
   * Such escape sequences are also implemented directly by the regular-expression
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -686,11 +687,11 @@</span>
   * Categories that behave like the java.lang.Character
   * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
   * available through the same &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; syntax where
   * the specified property has the name &lt;code&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/code&gt;&lt;/a&gt;.
   *
<span class="udiff-line-modified-removed">-  * &lt;h3&gt; Comparison to Perl 5 &lt;/h3&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt; Comparison to Perl 5 &lt;/h2&gt;</span>
   *
   * &lt;p&gt;The {@code Pattern} engine performs traditional NFA-based matching
   * with ordered alternation as occurs in Perl 5.
   *
   * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -932,10 +933,11 @@</span>
       * and the flags, which are all that is needed to recompile the pattern
       * when it is deserialized.
       */
  
      /** use serialVersionUID from Merlin b59 for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 5073258162644648461L;
  
      /**
       * The original regular-expression pattern string.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1373,10 +1375,11 @@</span>
  
      /**
       * Recompile the Pattern instance from a stream.  The original pattern
       * string is read in and the object tree is recompiled from it.
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
  
          // Read in all fields
          s.defaultReadObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1422,11 +1425,15 @@</span>
          capturingGroupCount = 1;
          localCount = 0;
          localTCNCount = 0;
  
          if (!pattern.isEmpty()) {
<span class="udiff-line-modified-removed">-             compile();</span>
<span class="udiff-line-modified-added">+             try {</span>
<span class="udiff-line-added">+                 compile();</span>
<span class="udiff-line-added">+             } catch (StackOverflowError soe) {</span>
<span class="udiff-line-added">+                 throw error(&quot;Stack overflow during pattern compilation&quot;);</span>
<span class="udiff-line-added">+             }</span>
          } else {
              root = new Start(lastAccept);
              matchRoot = lastAccept;
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1498,23 +1505,16 @@</span>
              if (&quot;.$|()[]{}^?*+\\&quot;.indexOf(ch0) != -1) {
                  dst.append((char)ch0);
                  off++;
                  continue;
              }
<span class="udiff-line-modified-removed">-             int j = off + Character.charCount(ch0);</span>
<span class="udiff-line-modified-added">+             int j = Grapheme.nextBoundary(src, off, limit);</span>
              int ch1;
<span class="udiff-line-removed">-             while (j &lt; limit) {</span>
<span class="udiff-line-removed">-                 ch1 = src.codePointAt(j);</span>
<span class="udiff-line-removed">-                 if (Grapheme.isBoundary(ch0, ch1))</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 ch0 = ch1;</span>
<span class="udiff-line-removed">-                 j += Character.charCount(ch1);</span>
<span class="udiff-line-removed">-             }</span>
              String seq = src.substring(off, j);
              String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
              off = j;
<span class="udiff-line-modified-removed">-             if (nfd.length() &gt; 1) {</span>
<span class="udiff-line-modified-added">+             if (nfd.codePointCount(0, nfd.length()) &gt; 1) {</span>
                  ch0 = nfd.codePointAt(0);
                  ch1 = nfd.codePointAt(Character.charCount(ch0));
                  if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
                      Set&lt;String&gt; altns = new LinkedHashSet&lt;&gt;();
                      altns.add(seq);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1676,11 +1676,17 @@</span>
          }
          if (i &gt;= pLen - 1)    // No \Q sequence found
              return;
          int j = i;
          i += 2;
<span class="udiff-line-modified-removed">-         int[] newtemp = new int[j + 3*(pLen-i) + 2];</span>
<span class="udiff-line-modified-added">+         int newTempLen;</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));</span>
<span class="udiff-line-added">+         } catch (ArithmeticException ae) {</span>
<span class="udiff-line-added">+             throw new OutOfMemoryError();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int[] newtemp = new int[newTempLen];</span>
          System.arraycopy(temp, 0, newtemp, 0, j);
  
          boolean inQuote = true;
          boolean beginQuote = true;
          while (i &lt; pLen) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1961,20 +1967,28 @@</span>
       */
      private int parsePastLine() {
          int ch = temp[cursor++];
          while (ch != 0 &amp;&amp; !isLineSeparator(ch))
              ch = temp[cursor++];
<span class="udiff-line-added">+         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {</span>
<span class="udiff-line-added">+             cursor = patternLength;</span>
<span class="udiff-line-added">+             ch = temp[cursor++];</span>
<span class="udiff-line-added">+         }</span>
          return ch;
      }
  
      /**
       * xmode peek past comment to end of line.
       */
      private int peekPastLine() {
          int ch = temp[++cursor];
          while (ch != 0 &amp;&amp; !isLineSeparator(ch))
              ch = temp[++cursor];
<span class="udiff-line-added">+         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {</span>
<span class="udiff-line-added">+             cursor = patternLength;</span>
<span class="udiff-line-added">+             ch = temp[cursor];</span>
<span class="udiff-line-added">+         }</span>
          return ch;
      }
  
      /**
       * Determines if character is a line separator in the current mode
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2048,11 +2062,11 @@</span>
       */
      private Node expr(Node end) {
          Node prev = null;
          Node firstTail = null;
          Branch branch = null;
<span class="udiff-line-modified-removed">-         Node branchConn = null;</span>
<span class="udiff-line-modified-added">+         BranchConn branchConn = null;</span>
  
          for (;;) {
              Node node = sequence(end);
              Node nodeTail = root;      //double return
              if (prev == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2098,11 +2112,11 @@</span>
       * Parsing of sequences between alternations.
       */
      private Node sequence(Node end) {
          Node head = null;
          Node tail = null;
<span class="udiff-line-modified-removed">-         Node node = null;</span>
<span class="udiff-line-modified-added">+         Node node;</span>
      LOOP:
          for (;;) {
              int ch = peek();
              switch (ch) {
              case &#39;(&#39;:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2196,11 +2210,28 @@</span>
              default:
                  node = atom();
                  break;
              }
  
<span class="udiff-line-modified-removed">-             node = closure(node);</span>
<span class="udiff-line-modified-added">+             if (node instanceof LineEnding) {</span>
<span class="udiff-line-added">+                 LineEnding le = (LineEnding)node;</span>
<span class="udiff-line-added">+                 node = closureOfLineEnding(le);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (node != le) {</span>
<span class="udiff-line-added">+                     // LineEnding was replaced with an anonymous group</span>
<span class="udiff-line-added">+                     if (head == null)</span>
<span class="udiff-line-added">+                         head = node;</span>
<span class="udiff-line-added">+                     else</span>
<span class="udiff-line-added">+                         tail.next = node;</span>
<span class="udiff-line-added">+                     // Double return: Tail was returned in root</span>
<span class="udiff-line-added">+                     tail = root;</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 node = closure(node);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              /* save the top dot-greedy nodes (.*, .+) as well
              if (node instanceof GreedyCharProperty &amp;&amp;
                  ((GreedyCharProperty)node).cp instanceof Dot) {
                  topClosureNodes.add(node);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2307,17 +2338,19 @@</span>
          } else {
              return newSlice(buffer, first, hasSupplementary);
          }
      }
  
<span class="udiff-line-modified-removed">-     private void append(int ch, int len) {</span>
<span class="udiff-line-modified-removed">-         if (len &gt;= buffer.length) {</span>
<span class="udiff-line-modified-removed">-             int[] tmp = new int[len+len];</span>
<span class="udiff-line-modified-removed">-             System.arraycopy(buffer, 0, tmp, 0, len);</span>
<span class="udiff-line-modified-removed">-             buffer = tmp;</span>
<span class="udiff-line-modified-added">+     private void append(int ch, int index) {</span>
<span class="udiff-line-modified-added">+         int len = buffer.length;</span>
<span class="udiff-line-modified-added">+         if (index - len &gt;= 0) {</span>
<span class="udiff-line-modified-added">+             len = ArraysSupport.newLength(len,</span>
<span class="udiff-line-modified-added">+                     1 + index - len, /* minimum growth */</span>
<span class="udiff-line-added">+                     len              /* preferred growth */);</span>
<span class="udiff-line-added">+             buffer = Arrays.copyOf(buffer, len);</span>
          }
<span class="udiff-line-modified-removed">-         buffer[len] = ch;</span>
<span class="udiff-line-modified-added">+         buffer[index] = ch;</span>
      }
  
      /**
       * Parses a backref greedily, taking as many numbers as it
       * can. The first digit is always treated as a backref, but
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2613,11 +2646,10 @@</span>
       */
      private CharPredicate clazz(boolean consume) {
          CharPredicate prev = null;
          CharPredicate curr = null;
          BitClass bits = new BitClass();
<span class="udiff-line-removed">-         BmpCharPredicate bitsP = ch -&gt; ch &lt; 256 &amp;&amp; bits.bits[ch];</span>
  
          boolean isNeg = false;
          boolean hasBits = false;
          int ch = next();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2654,13 +2686,13 @@</span>
                              ch = peek();
                          }
                          if (hasBits) {
                              // bits used, union has high precedence
                              if (prev == null) {
<span class="udiff-line-modified-removed">-                                 prev = curr = bitsP;</span>
<span class="udiff-line-modified-added">+                                 prev = curr = bits;</span>
                              } else {
<span class="udiff-line-modified-removed">-                                 prev = prev.union(bitsP);</span>
<span class="udiff-line-modified-added">+                                 prev = prev.union(bits);</span>
                              }
                              hasBits = false;
                          }
                          if (right != null)
                              curr = right;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2685,13 +2717,13 @@</span>
                  case &#39;]&#39;:
                      if (prev != null || hasBits) {
                          if (consume)
                              next();
                          if (prev == null)
<span class="udiff-line-modified-removed">-                             prev = bitsP;</span>
<span class="udiff-line-modified-added">+                             prev = bits;</span>
                          else if (hasBits)
<span class="udiff-line-modified-removed">-                             prev = prev.union(bitsP);</span>
<span class="udiff-line-modified-added">+                             prev = prev.union(bits);</span>
                          if (isNeg)
                              return prev.negate();
                          return prev;
                      }
                      break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2885,25 +2917,25 @@</span>
              if (name.startsWith(&quot;In&quot;)) {
                  // \p{InBlockName}
                  p = CharPredicates.forUnicodeBlock(name.substring(2));
              } else if (name.startsWith(&quot;Is&quot;)) {
                  // \p{IsGeneralCategory} and \p{IsScriptName}
<span class="udiff-line-modified-removed">-                 name = name.substring(2);</span>
<span class="udiff-line-modified-removed">-                 p = CharPredicates.forUnicodeProperty(name);</span>
<span class="udiff-line-modified-added">+                 String shortName = name.substring(2);</span>
<span class="udiff-line-modified-added">+                 p = CharPredicates.forUnicodeProperty(shortName);</span>
                  if (p == null)
<span class="udiff-line-modified-removed">-                     p = CharPredicates.forProperty(name);</span>
<span class="udiff-line-modified-added">+                     p = CharPredicates.forProperty(shortName);</span>
                  if (p == null)
<span class="udiff-line-modified-removed">-                     p = CharPredicates.forUnicodeScript(name);</span>
<span class="udiff-line-modified-added">+                     p = CharPredicates.forUnicodeScript(shortName);</span>
              } else {
                  if (has(UNICODE_CHARACTER_CLASS)) {
                      p = CharPredicates.forPOSIXName(name);
                  }
                  if (p == null)
                      p = CharPredicates.forProperty(name);
              }
              if (p == null)
<span class="udiff-line-modified-removed">-                 throw error(&quot;Unknown character property name {In/Is&quot; + name + &quot;}&quot;);</span>
<span class="udiff-line-modified-added">+                 throw error(&quot;Unknown character property name {&quot; + name + &quot;}&quot;);</span>
          }
          if (isComplement) {
              // it might be too expensive to detect if a complement of
              // CharProperty can match &quot;certain&quot; supplementary. So just
              // go with StartS.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2943,12 +2975,12 @@</span>
       * the group. Sometimes a double return system is used where the tail is
       * returned in root.
       */
      private Node group0() {
          boolean capturingGroup = false;
<span class="udiff-line-modified-removed">-         Node head = null;</span>
<span class="udiff-line-modified-removed">-         Node tail = null;</span>
<span class="udiff-line-modified-added">+         Node head;</span>
<span class="udiff-line-modified-added">+         Node tail;</span>
          int save = flags0;
          int saveTCNCount = topClosureNodes.size();
          root = null;
          int ch = next();
          if (ch == &#39;?&#39;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2993,11 +3025,11 @@</span>
                  }
                  int start = cursor;
                  head = createGroup(true);
                  tail = root;
                  head.next = expr(tail);
<span class="udiff-line-modified-removed">-                 tail.next = lookbehindEnd;</span>
<span class="udiff-line-modified-added">+                 tail.next = LookBehindEndNode.INSTANCE;</span>
                  TreeInfo info = new TreeInfo();
                  head.study(info);
                  if (info.maxValid == false) {
                      throw error(&quot;Look-behind group does not have &quot;
                                  + &quot;an obvious maximum length&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3062,22 +3094,35 @@</span>
          // have group closure, clear all inner closure nodes from the
          // top list (no backtracking stopper optimization for inner
          if (saveTCNCount &lt; topClosureNodes.size())
              topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
  
<span class="udiff-line-added">+         return groupWithClosure(node, head, tail, capturingGroup);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Transforms a Group with quantifiers into some special constructs</span>
<span class="udiff-line-added">+      * (such as Branch or Loop/GroupCurly), if necessary.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * This method is applied either to actual groups or to the Unicode</span>
<span class="udiff-line-added">+      * linebreak (aka \\R) represented as an anonymous group.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private Node groupWithClosure(Node node, Node head, Node tail,</span>
<span class="udiff-line-added">+                                   boolean capturingGroup)</span>
<span class="udiff-line-added">+     {</span>
          if (node instanceof Ques) {
              Ques ques = (Ques) node;
              if (ques.type == Qtype.POSSESSIVE) {
                  root = node;
                  return node;
              }
<span class="udiff-line-modified-removed">-             tail.next = new BranchConn();</span>
<span class="udiff-line-modified-removed">-             tail = tail.next;</span>
<span class="udiff-line-modified-added">+             BranchConn branchConn = new BranchConn();</span>
<span class="udiff-line-modified-added">+             tail = tail.next = branchConn;</span>
              if (ques.type == Qtype.GREEDY) {
<span class="udiff-line-modified-removed">-                 head = new Branch(head, null, tail);</span>
<span class="udiff-line-modified-added">+                 head = new Branch(head, null, branchConn);</span>
              } else { // Reluctant quantifier
<span class="udiff-line-modified-removed">-                 head = new Branch(null, head, tail);</span>
<span class="udiff-line-modified-added">+                 head = new Branch(null, head, branchConn);</span>
              }
              root = tail;
              return head;
          } else if (node instanceof Curly) {
              Curly curly = (Curly) node;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3226,86 +3271,109 @@</span>
  
      static enum Qtype {
          GREEDY, LAZY, POSSESSIVE, INDEPENDENT
      }
  
<span class="udiff-line-modified-removed">-     private Node curly(Node prev, int cmin) {</span>
<span class="udiff-line-modified-added">+     private Qtype qtype() {</span>
          int ch = next();
          if (ch == &#39;?&#39;) {
              next();
<span class="udiff-line-modified-removed">-             return new Curly(prev, cmin, MAX_REPS, Qtype.LAZY);</span>
<span class="udiff-line-modified-added">+             return Qtype.LAZY;</span>
          } else if (ch == &#39;+&#39;) {
              next();
<span class="udiff-line-modified-removed">-             return new Curly(prev, cmin, MAX_REPS, Qtype.POSSESSIVE);</span>
<span class="udiff-line-modified-added">+             return Qtype.POSSESSIVE;</span>
          }
<span class="udiff-line-modified-removed">-         if (prev instanceof BmpCharProperty) {</span>
<span class="udiff-line-modified-removed">-             return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);</span>
<span class="udiff-line-modified-removed">-         } else if (prev instanceof CharProperty) {</span>
<span class="udiff-line-modified-removed">-             return new CharPropertyGreedy((CharProperty)prev, cmin);</span>
<span class="udiff-line-modified-added">+         return Qtype.GREEDY;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     private Node curly(Node prev, int cmin) {</span>
<span class="udiff-line-added">+         Qtype qtype = qtype();</span>
<span class="udiff-line-added">+         if (qtype == Qtype.GREEDY) {</span>
<span class="udiff-line-added">+             if (prev instanceof BmpCharProperty) {</span>
<span class="udiff-line-added">+                 return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);</span>
<span class="udiff-line-added">+             } else if (prev instanceof CharProperty) {</span>
<span class="udiff-line-added">+                 return new CharPropertyGreedy((CharProperty)prev, cmin);</span>
<span class="udiff-line-added">+             }</span>
          }
<span class="udiff-line-modified-removed">-         return new Curly(prev, cmin, MAX_REPS, Qtype.GREEDY);</span>
<span class="udiff-line-modified-added">+         return new Curly(prev, cmin, MAX_REPS, qtype);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Processing repetition of a Unicode linebreak \\R.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private Node closureOfLineEnding(LineEnding le) {</span>
<span class="udiff-line-added">+         int ch = peek();</span>
<span class="udiff-line-added">+         if (ch != &#39;?&#39; &amp;&amp; ch != &#39;*&#39; &amp;&amp; ch != &#39;+&#39; &amp;&amp; ch != &#39;{&#39;) {</span>
<span class="udiff-line-added">+             return le;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Replace the LineEnding with an anonymous group</span>
<span class="udiff-line-added">+         // (?:\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029])</span>
<span class="udiff-line-added">+         Node grHead = createGroup(true);</span>
<span class="udiff-line-added">+         Node grTail = root;</span>
<span class="udiff-line-added">+         BranchConn branchConn = new BranchConn();</span>
<span class="udiff-line-added">+         branchConn.next = grTail;</span>
<span class="udiff-line-added">+         Node slice = new Slice(new int[] {0x0D, 0x0A});</span>
<span class="udiff-line-added">+         slice.next = branchConn;</span>
<span class="udiff-line-added">+         Node chClass = newCharProperty(x -&gt; x == 0x0A || x == 0x0B ||</span>
<span class="udiff-line-added">+                 x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||</span>
<span class="udiff-line-added">+                 x == 0x2029);</span>
<span class="udiff-line-added">+         chClass.next = branchConn;</span>
<span class="udiff-line-added">+         grHead.next = new Branch(slice, chClass, branchConn);</span>
<span class="udiff-line-added">+         return groupWithClosure(closure(grHead), grHead, grTail, false);</span>
      }
  
      /**
       * Processes repetition. If the next character peeked is a quantifier
       * then new nodes must be appended to handle the repetition.
       * Prev could be a single or a group, so it could be a chain of nodes.
       */
      private Node closure(Node prev) {
<span class="udiff-line-removed">-         Node atom;</span>
          int ch = peek();
          switch (ch) {
          case &#39;?&#39;:
<span class="udiff-line-modified-removed">-             ch = next();</span>
<span class="udiff-line-removed">-             if (ch == &#39;?&#39;) {</span>
<span class="udiff-line-removed">-                 next();</span>
<span class="udiff-line-removed">-                 return new Ques(prev, Qtype.LAZY);</span>
<span class="udiff-line-removed">-             } else if (ch == &#39;+&#39;) {</span>
<span class="udiff-line-removed">-                 next();</span>
<span class="udiff-line-removed">-                 return new Ques(prev, Qtype.POSSESSIVE);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return new Ques(prev, Qtype.GREEDY);</span>
<span class="udiff-line-modified-added">+             return new Ques(prev, qtype());</span>
          case &#39;*&#39;:
              return curly(prev, 0);
          case &#39;+&#39;:
              return curly(prev, 1);
          case &#39;{&#39;:
<span class="udiff-line-modified-removed">-             ch = temp[cursor+1];</span>
<span class="udiff-line-modified-added">+             ch = skip();</span>
              if (ASCII.isDigit(ch)) {
<span class="udiff-line-modified-removed">-                 skip();</span>
<span class="udiff-line-modified-removed">-                 int cmin = 0;</span>
<span class="udiff-line-modified-removed">-                 do {</span>
<span class="udiff-line-modified-removed">-                     cmin = cmin * 10 + (ch - &#39;0&#39;);</span>
<span class="udiff-line-modified-removed">-                 } while (ASCII.isDigit(ch = read()));</span>
<span class="udiff-line-modified-removed">-                 int cmax = cmin;</span>
<span class="udiff-line-modified-removed">-                 if (ch == &#39;,&#39;) {</span>
<span class="udiff-line-modified-removed">-                     ch = read();</span>
<span class="udiff-line-modified-removed">-                     cmax = MAX_REPS;</span>
<span class="udiff-line-modified-removed">-                     if (ch != &#39;}&#39;) {</span>
<span class="udiff-line-modified-removed">-                         cmax = 0;</span>
<span class="udiff-line-modified-removed">-                         while (ASCII.isDigit(ch)) {</span>
<span class="udiff-line-modified-removed">-                             cmax = cmax * 10 + (ch - &#39;0&#39;);</span>
<span class="udiff-line-modified-removed">-                             ch = read();</span>
<span class="udiff-line-modified-added">+                 int cmin = 0, cmax;</span>
<span class="udiff-line-modified-added">+                 try {</span>
<span class="udiff-line-modified-added">+                     do {</span>
<span class="udiff-line-modified-added">+                         cmin = Math.addExact(Math.multiplyExact(cmin, 10),</span>
<span class="udiff-line-modified-added">+                                              ch - &#39;0&#39;);</span>
<span class="udiff-line-modified-added">+                     } while (ASCII.isDigit(ch = read()));</span>
<span class="udiff-line-modified-added">+                     if (ch == &#39;,&#39;) {</span>
<span class="udiff-line-modified-added">+                         ch = read();</span>
<span class="udiff-line-modified-added">+                         if (ch == &#39;}&#39;) {</span>
<span class="udiff-line-modified-added">+                             unread();</span>
<span class="udiff-line-modified-added">+                             return curly(prev, cmin);</span>
<span class="udiff-line-modified-added">+                         } else {</span>
<span class="udiff-line-modified-added">+                             cmax = 0;</span>
<span class="udiff-line-modified-added">+                             while (ASCII.isDigit(ch)) {</span>
<span class="udiff-line-added">+                                 cmax = Math.addExact(Math.multiplyExact(cmax, 10),</span>
<span class="udiff-line-added">+                                                      ch - &#39;0&#39;);</span>
<span class="udiff-line-added">+                                 ch = read();</span>
<span class="udiff-line-added">+                             }</span>
                          }
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         cmax = cmin;</span>
                      }
<span class="udiff-line-added">+                 } catch (ArithmeticException ae) {</span>
<span class="udiff-line-added">+                     throw error(&quot;Illegal repetition range&quot;);</span>
                  }
                  if (ch != &#39;}&#39;)
                      throw error(&quot;Unclosed counted closure&quot;);
<span class="udiff-line-modified-removed">-                 if (((cmin) | (cmax) | (cmax - cmin)) &lt; 0)</span>
<span class="udiff-line-modified-added">+                 if (cmax &lt; cmin)</span>
                      throw error(&quot;Illegal repetition range&quot;);
<span class="udiff-line-modified-removed">-                 Curly curly;</span>
<span class="udiff-line-modified-removed">-                 ch = peek();</span>
<span class="udiff-line-modified-removed">-                 if (ch == &#39;?&#39;) {</span>
<span class="udiff-line-modified-removed">-                     next();</span>
<span class="udiff-line-removed">-                     curly = new Curly(prev, cmin, cmax, Qtype.LAZY);</span>
<span class="udiff-line-removed">-                 } else if (ch == &#39;+&#39;) {</span>
<span class="udiff-line-removed">-                     next();</span>
<span class="udiff-line-removed">-                     curly = new Curly(prev, cmin, cmax, Qtype.POSSESSIVE);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     curly = new Curly(prev, cmin, cmax, Qtype.GREEDY);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 return curly;</span>
<span class="udiff-line-modified-added">+                 unread();</span>
<span class="udiff-line-modified-added">+                 return (cmin == 0 &amp;&amp; cmax == 1)</span>
<span class="udiff-line-modified-added">+                         ? new Ques(prev, qtype())</span>
<span class="udiff-line-modified-added">+                         : new Curly(prev, cmin, cmax, qtype());</span>
              } else {
                  throw error(&quot;Illegal repetition&quot;);
              }
          default:
              return prev;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3405,13 +3473,14 @@</span>
      }
  
      private int N() {
          if (read() == &#39;{&#39;) {
              int i = cursor;
<span class="udiff-line-modified-removed">-             while (cursor &lt; patternLength &amp;&amp; read() != &#39;}&#39;) {}</span>
<span class="udiff-line-modified-removed">-             if (cursor &gt; patternLength)</span>
<span class="udiff-line-modified-removed">-                 throw error(&quot;Unclosed character name escape sequence&quot;);</span>
<span class="udiff-line-modified-added">+             while (read() != &#39;}&#39;) {</span>
<span class="udiff-line-modified-added">+                 if (cursor &gt;= patternLength)</span>
<span class="udiff-line-modified-added">+                     throw error(&quot;Unclosed character name escape sequence&quot;);</span>
<span class="udiff-line-added">+             }</span>
              String name = new String(temp, i, cursor - i - 1);
              try {
                  return Character.codePointOf(name);
              } catch (IllegalArgumentException x) {
                  throw error(&quot;Unknown character name [&quot; + name + &quot;]&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3476,18 +3545,14 @@</span>
      /**
       *  Creates a bit vector for matching Latin-1 values. A normal BitClass
       *  never matches values above Latin-1, and a complemented BitClass always
       *  matches values above Latin-1.
       */
<span class="udiff-line-modified-removed">-     static final class BitClass extends BmpCharProperty {</span>
<span class="udiff-line-modified-added">+     static final class BitClass implements BmpCharPredicate {</span>
          final boolean[] bits;
          BitClass() {
<span class="udiff-line-modified-removed">-             this(new boolean[256]);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private BitClass(boolean[] bits) {</span>
<span class="udiff-line-removed">-             super( ch -&gt; ch &lt; 256 &amp;&amp; bits[ch]);</span>
<span class="udiff-line-removed">-             this.bits = bits;</span>
<span class="udiff-line-modified-added">+             bits = new boolean[256];</span>
          }
          BitClass add(int c, int flags) {
              assert c &gt;= 0 &amp;&amp; c &lt;= 255;
              if ((flags &amp; CASE_INSENSITIVE) != 0) {
                  if (ASCII.isAscii(c)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3499,12 +3564,16 @@</span>
                  }
              }
              bits[c] = true;
              return this;
          }
<span class="udiff-line-added">+         public boolean is(int ch) {</span>
<span class="udiff-line-added">+             return ch &lt; 256 &amp;&amp; bits[ch];</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-added">+ </span>
      /**
       *  Utility method for creating a string slice matcher.
       */
      private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
          int[] tmp = new int[count];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3913,24 +3982,26 @@</span>
      /**
       * Abstract node class to match one character satisfying some
       * boolean property.
       */
      static class CharProperty extends Node {
<span class="udiff-line-modified-removed">-         CharPredicate predicate;</span>
<span class="udiff-line-modified-added">+         final CharPredicate predicate;</span>
  
          CharProperty (CharPredicate predicate) {
              this.predicate = predicate;
          }
          boolean match(Matcher matcher, int i, CharSequence seq) {
              if (i &lt; matcher.to) {
                  int ch = Character.codePointAt(seq, i);
<span class="udiff-line-modified-removed">-                 return predicate.is(ch) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                        next.match(matcher, i + Character.charCount(ch), seq);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 matcher.hitEnd = true;</span>
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+                 i += Character.charCount(ch);</span>
<span class="udiff-line-modified-added">+                 if (i &lt;= matcher.to) {</span>
<span class="udiff-line-modified-added">+                     return predicate.is(ch) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                            next.match(matcher, i, seq);</span>
<span class="udiff-line-modified-added">+                 }</span>
              }
<span class="udiff-line-added">+             matcher.hitEnd = true;</span>
<span class="udiff-line-added">+             return false;</span>
          }
          boolean study(TreeInfo info) {
              info.minLength++;
              info.maxLength++;
              return next.study(info);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3965,10 +4036,12 @@</span>
          boolean match(Matcher matcher, int i, CharSequence seq) {
              if (i &lt; matcher.to) {
                  int ch0 = Character.codePointAt(seq, i);
                  int n = Character.charCount(ch0);
                  int j = i + n;
<span class="udiff-line-added">+                 // Fast check if it&#39;s necessary to call Normalizer;</span>
<span class="udiff-line-added">+                 // testing Grapheme.isBoundary is enough for this case</span>
                  while (j &lt; matcher.to) {
                      int ch1 = Character.codePointAt(seq, j);
                      if (Grapheme.isBoundary(ch0, ch1))
                          break;
                      ch0 = ch1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4010,19 +4083,11 @@</span>
       * Node class that matches an unicode extended grapheme cluster
       */
      static class XGrapheme extends Node {
          boolean match(Matcher matcher, int i, CharSequence seq) {
              if (i &lt; matcher.to) {
<span class="udiff-line-modified-removed">-                 int ch0 = Character.codePointAt(seq, i);</span>
<span class="udiff-line-removed">-                     i += Character.charCount(ch0);</span>
<span class="udiff-line-removed">-                 while (i &lt; matcher.to) {</span>
<span class="udiff-line-removed">-                     int ch1 = Character.codePointAt(seq, i);</span>
<span class="udiff-line-removed">-                     if (Grapheme.isBoundary(ch0, ch1))</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     ch0 = ch1;</span>
<span class="udiff-line-removed">-                     i += Character.charCount(ch1);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 i = Grapheme.nextBoundary(seq, i, matcher.to);</span>
                  return next.match(matcher, i, seq);
              }
              matcher.hitEnd = true;
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4048,12 +4113,13 @@</span>
              if (i == startIndex) {
                  return next.match(matcher, i, seq);
              }
              if (i &lt; endIndex) {
                  if (Character.isSurrogatePair(seq.charAt(i-1), seq.charAt(i)) ||
<span class="udiff-line-modified-removed">-                     !Grapheme.isBoundary(Character.codePointBefore(seq, i),</span>
<span class="udiff-line-modified-removed">-                                          Character.codePointAt(seq, i))) {</span>
<span class="udiff-line-modified-added">+                     Grapheme.nextBoundary(seq,</span>
<span class="udiff-line-modified-added">+                         i - Character.charCount(Character.codePointBefore(seq, i)),</span>
<span class="udiff-line-added">+                         i + Character.charCount(Character.codePointAt(seq, i))) &gt; i) {</span>
                      return false;
                  }
              } else {
                  matcher.hitEnd = true;
                  matcher.requireEnd = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4262,22 +4328,22 @@</span>
              }
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Handles the greedy style repetition with the minimum either be</span>
<span class="udiff-line-modified-removed">-      * 0 or 1 and the maximum be MAX_REPS, for * and + quantifier.</span>
<span class="udiff-line-modified-added">+      * Handles the greedy style repetition with the specified minimum</span>
<span class="udiff-line-modified-added">+      * and the maximum equal to MAX_REPS, for *, + and {N,} quantifiers.</span>
       */
      static class CharPropertyGreedy extends Node {
          final CharPredicate predicate;
          final int cmin;
  
          CharPropertyGreedy(CharProperty cp, int cmin) {
              this.predicate = cp.predicate;
              this.cmin = cmin;
          }
<span class="udiff-line-modified-removed">-         boolean match(Matcher matcher, int i,  CharSequence seq) {</span>
<span class="udiff-line-modified-added">+         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
              int n = 0;
              int to = matcher.to;
              // greedy, all the way down
              while (i &lt; to) {
                  int ch = Character.codePointAt(seq, i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4316,11 +4382,11 @@</span>
  
          BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
              super(bcp, cmin);
          }
  
<span class="udiff-line-modified-removed">-         boolean match(Matcher matcher, int i,  CharSequence seq) {</span>
<span class="udiff-line-modified-added">+         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
              int n = 0;
              int to = matcher.to;
              while (i &lt; to &amp;&amp; predicate.is(seq.charAt(i))) {
                  i++; n++;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4693,11 +4759,11 @@</span>
       * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
       * of each atom node without including the TreeInfo of the
       * &quot;next&quot;.
       */
      static final class BranchConn extends Node {
<span class="udiff-line-modified-removed">-         BranchConn() {};</span>
<span class="udiff-line-modified-added">+         BranchConn() {}</span>
          boolean match(Matcher matcher, int i, CharSequence seq) {
              return next.match(matcher, i, seq);
          }
          boolean study(TreeInfo info) {
              return info.deterministic;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4710,22 +4776,23 @@</span>
       * and where it does not occur.
       */
      static final class Branch extends Node {
          Node[] atoms = new Node[2];
          int size = 2;
<span class="udiff-line-modified-removed">-         Node conn;</span>
<span class="udiff-line-modified-removed">-         Branch(Node first, Node second, Node branchConn) {</span>
<span class="udiff-line-modified-added">+         BranchConn conn;</span>
<span class="udiff-line-modified-added">+         Branch(Node first, Node second, BranchConn branchConn) {</span>
              conn = branchConn;
              atoms[0] = first;
              atoms[1] = second;
          }
  
          void add(Node node) {
              if (size &gt;= atoms.length) {
<span class="udiff-line-modified-removed">-                 Node[] tmp = new Node[atoms.length*2];</span>
<span class="udiff-line-modified-removed">-                 System.arraycopy(atoms, 0, tmp, 0, atoms.length);</span>
<span class="udiff-line-modified-removed">-                 atoms = tmp;</span>
<span class="udiff-line-modified-added">+                 int len = ArraysSupport.newLength(size,</span>
<span class="udiff-line-modified-added">+                         1,    /* minimum growth */</span>
<span class="udiff-line-modified-added">+                         size  /* preferred growth */);</span>
<span class="udiff-line-added">+                 atoms = Arrays.copyOf(atoms, len);</span>
              }
              atoms[size++] = node;
          }
  
          boolean match(Matcher matcher, int i, CharSequence seq) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4790,38 +4857,10 @@</span>
              matcher.locals[localIndex] = i;
              boolean ret = next.match(matcher, i, seq);
              matcher.locals[localIndex] = save;
              return ret;
          }
<span class="udiff-line-removed">-         boolean matchRef(Matcher matcher, int i, CharSequence seq) {</span>
<span class="udiff-line-removed">-             int save = matcher.locals[localIndex];</span>
<span class="udiff-line-removed">-             matcher.locals[localIndex] = ~i; // HACK</span>
<span class="udiff-line-removed">-             boolean ret = next.match(matcher, i, seq);</span>
<span class="udiff-line-removed">-             matcher.locals[localIndex] = save;</span>
<span class="udiff-line-removed">-             return ret;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Recursive reference to a group in the regular expression. It calls</span>
<span class="udiff-line-removed">-      * matchRef because if the reference fails to match we would not unset</span>
<span class="udiff-line-removed">-      * the group.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static final class GroupRef extends Node {</span>
<span class="udiff-line-removed">-         GroupHead head;</span>
<span class="udiff-line-removed">-         GroupRef(GroupHead head) {</span>
<span class="udiff-line-removed">-             this.head = head;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
<span class="udiff-line-removed">-             return head.matchRef(matcher, i, seq)</span>
<span class="udiff-line-removed">-                 &amp;&amp; next.match(matcher, matcher.last, seq);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         boolean study(TreeInfo info) {</span>
<span class="udiff-line-removed">-             info.maxValid = false;</span>
<span class="udiff-line-removed">-             info.deterministic = false;</span>
<span class="udiff-line-removed">-             return next.study(info);</span>
<span class="udiff-line-removed">-         }</span>
      }
  
      /**
       * The GroupTail handles the setting of group beginning and ending
       * locations when groups are successfully matched. It must also be able to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4939,11 +4978,11 @@</span>
              }
              return next.match(matcher, i, seq);
          }
          boolean matchInit(Matcher matcher, int i, CharSequence seq) {
              int save = matcher.locals[countIndex];
<span class="udiff-line-modified-removed">-             boolean ret = false;</span>
<span class="udiff-line-modified-added">+             boolean ret;</span>
              if (posIndex != -1 &amp;&amp; matcher.localsPos[posIndex] == null) {
                  matcher.localsPos[posIndex] = new IntHashSet();
              }
              if (0 &lt; cmin) {
                  matcher.locals[countIndex] = 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5153,56 +5192,21 @@</span>
              info.deterministic = false;
              return next.study(info);
          }
      }
  
<span class="udiff-line-removed">-     static final class Conditional extends Node {</span>
<span class="udiff-line-removed">-         Node cond, yes, not;</span>
<span class="udiff-line-removed">-         Conditional(Node cond, Node yes, Node not) {</span>
<span class="udiff-line-removed">-             this.cond = cond;</span>
<span class="udiff-line-removed">-             this.yes = yes;</span>
<span class="udiff-line-removed">-             this.not = not;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
<span class="udiff-line-removed">-             if (cond.match(matcher, i, seq)) {</span>
<span class="udiff-line-removed">-                 return yes.match(matcher, i, seq);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return not.match(matcher, i, seq);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         boolean study(TreeInfo info) {</span>
<span class="udiff-line-removed">-             int minL = info.minLength;</span>
<span class="udiff-line-removed">-             int maxL = info.maxLength;</span>
<span class="udiff-line-removed">-             boolean maxV = info.maxValid;</span>
<span class="udiff-line-removed">-             info.reset();</span>
<span class="udiff-line-removed">-             yes.study(info);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             int minL2 = info.minLength;</span>
<span class="udiff-line-removed">-             int maxL2 = info.maxLength;</span>
<span class="udiff-line-removed">-             boolean maxV2 = info.maxValid;</span>
<span class="udiff-line-removed">-             info.reset();</span>
<span class="udiff-line-removed">-             not.study(info);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             info.minLength = minL + Math.min(minL2, info.minLength);</span>
<span class="udiff-line-removed">-             info.maxLength = maxL + Math.max(maxL2, info.maxLength);</span>
<span class="udiff-line-removed">-             info.maxValid = (maxV &amp; maxV2 &amp; info.maxValid);</span>
<span class="udiff-line-removed">-             info.deterministic = false;</span>
<span class="udiff-line-removed">-             return next.study(info);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Zero width positive lookahead.
       */
      static final class Pos extends Node {
          Node cond;
          Pos(Node cond) {
              this.cond = cond;
          }
          boolean match(Matcher matcher, int i, CharSequence seq) {
              int savedTo = matcher.to;
<span class="udiff-line-modified-removed">-             boolean conditionMatched = false;</span>
<span class="udiff-line-modified-added">+             boolean conditionMatched;</span>
  
              // Relax transparent region boundaries for lookahead
              if (matcher.transparentBounds)
                  matcher.to = matcher.getTextLength();
              try {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5223,11 +5227,11 @@</span>
          Neg(Node cond) {
              this.cond = cond;
          }
          boolean match(Matcher matcher, int i, CharSequence seq) {
              int savedTo = matcher.to;
<span class="udiff-line-modified-removed">-             boolean conditionMatched = false;</span>
<span class="udiff-line-modified-added">+             boolean conditionMatched;</span>
  
              // Relax transparent region boundaries for lookahead
              if (matcher.transparentBounds)
                  matcher.to = matcher.getTextLength();
              try {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5249,15 +5253,19 @@</span>
  
      /**
       * For use with lookbehinds; matches the position where the lookbehind
       * was encountered.
       */
<span class="udiff-line-modified-removed">-     static Node lookbehindEnd = new Node() {</span>
<span class="udiff-line-modified-added">+     static class LookBehindEndNode extends Node {</span>
<span class="udiff-line-added">+         private LookBehindEndNode() {} // Singleton</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static LookBehindEndNode INSTANCE = new LookBehindEndNode();</span>
<span class="udiff-line-added">+ </span>
          boolean match(Matcher matcher, int i, CharSequence seq) {
              return i == matcher.lookbehindTo;
          }
<span class="udiff-line-modified-removed">-     };</span>
<span class="udiff-line-modified-added">+     }</span>
  
      /**
       * Zero width positive lookbehind.
       */
      static class Behind extends Node {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5521,11 +5529,11 @@</span>
              // a shift larger than the pattern length cannot
              // be used anyway.
              if (patternLength &lt; 4) {
                  return node;
              }
<span class="udiff-line-modified-removed">-             int i, j, k;</span>
<span class="udiff-line-modified-added">+             int i, j;</span>
              int[] lastOcc = new int[128];
              int[] optoSft = new int[patternLength];
              // Precalculate part of the bad character shift
              // It is a table for where in the pattern each
              // lower 7-bit value occurs
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5676,11 +5684,11 @@</span>
      }
  
      static interface BmpCharPredicate extends CharPredicate {
  
          default CharPredicate and(CharPredicate p) {
<span class="udiff-line-modified-removed">-             if(p instanceof BmpCharPredicate)</span>
<span class="udiff-line-modified-added">+             if (p instanceof BmpCharPredicate)</span>
                  return (BmpCharPredicate)(ch -&gt; is(ch) &amp;&amp; p.is(ch));
              return ch -&gt; is(ch) &amp;&amp; p.is(ch);
          }
          default CharPredicate union(CharPredicate p) {
              if (p instanceof BmpCharPredicate)
</pre>
<center><a href="Matcher.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PatternSyntaxException.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
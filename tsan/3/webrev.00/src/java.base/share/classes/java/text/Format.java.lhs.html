<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/Format.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.Serializable;
 42 
 43 /**
<a name="2" id="anc2"></a><span class="line-modified"> 44  * &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive</span>
 45  * information such as dates, messages, and numbers.
 46  *
 47  * &lt;p&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 48  * &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting</span>
<span class="line-modified"> 49  * locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the</span>
<span class="line-modified"> 50  * &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back</span>
<span class="line-modified"> 51  * into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).</span>
 52  *
 53  * &lt;p&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 54  * Generally, a format&#39;s &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse</span>
<span class="line-modified"> 55  * any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may</span>
 56  * be exceptional cases where this is not possible. For example, a
<a name="5" id="anc5"></a><span class="line-modified"> 57  * &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with</span>
<span class="line-modified"> 58  * no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could</span>
 59  * not tell which digits belong to which number.
 60  *
<a name="6" id="anc6"></a><span class="line-modified"> 61  * &lt;h3&gt;Subclassing&lt;/h3&gt;</span>
 62  *
 63  * &lt;p&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 64  * The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--</span>
<span class="line-modified"> 65  * &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and</span>
<span class="line-modified"> 66  * &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,</span>
 67  * respectively.
 68  * &lt;p&gt;
 69  * Concrete subclasses must implement three methods:
 70  * &lt;ol&gt;
<a name="8" id="anc8"></a><span class="line-modified"> 71  * &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;</span>
<span class="line-modified"> 72  * &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;</span>
<span class="line-modified"> 73  * &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;</span>
 74  * &lt;/ol&gt;
 75  * These general methods allow polymorphic parsing and formatting of objects
<a name="9" id="anc9"></a><span class="line-modified"> 76  * and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.</span>
<span class="line-modified"> 77  * Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for</span>
<span class="line-modified"> 78  * specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific</span>
<span class="line-modified"> 79  * result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a</span>
<span class="line-modified"> 80  * &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;</span>
 81  * when no text in the required format is at the beginning of the input text.
 82  *
 83  * &lt;p&gt;
 84  * Most subclasses will also implement the following factory methods:
 85  * &lt;ol&gt;
 86  * &lt;li&gt;
<a name="10" id="anc10"></a><span class="line-modified"> 87  * &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate</span>
 88  * for the current locale
 89  * &lt;li&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 90  * &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format</span>
 91  * object appropriate for the specified locale
 92  * &lt;/ol&gt;
 93  * In addition, some subclasses may also implement other
<a name="12" id="anc12"></a><span class="line-modified"> 94  * &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For</span>
<span class="line-modified"> 95  * example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides</span>
<span class="line-modified"> 96  * &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;</span>
 97  * methods for getting specialized number formatters.
 98  *
 99  * &lt;p&gt;
<a name="13" id="anc13"></a><span class="line-modified">100  * Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects</span>
<span class="line-modified">101  * for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)</span>
102  * must also implement the following class method:
103  * &lt;blockquote&gt;
104  * &lt;pre&gt;
105  * public static Locale[] getAvailableLocales()
106  * &lt;/pre&gt;
107  * &lt;/blockquote&gt;
108  *
109  * &lt;p&gt;
110  * And finally subclasses may define a set of constants to identify the various
111  * fields in the formatted output. These constants are used to create a FieldPosition
112  * object which identifies what information is contained in the field and its
113  * position in the formatted result. These constants should be named
114  * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
<a name="14" id="anc14"></a><span class="line-modified">115  * the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its</span>
116  * friends in {@link DateFormat}.
117  *
<a name="15" id="anc15"></a><span class="line-modified">118  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
119  *
120  * &lt;p&gt;
121  * Formats are generally not synchronized.
122  * It is recommended to create separate format instances for each thread.
123  * If multiple threads access a format concurrently, it must be synchronized
124  * externally.
125  *
126  * @see          java.text.ParsePosition
127  * @see          java.text.FieldPosition
128  * @see          java.text.NumberFormat
129  * @see          java.text.DateFormat
130  * @see          java.text.MessageFormat
131  * @author       Mark Davis
132  * @since 1.1
133  */
134 public abstract class Format implements Serializable, Cloneable {
135 
<a name="16" id="anc16"></a>
136     private static final long serialVersionUID = -299282585814624189L;
137 
138     /**
139      * Sole constructor.  (For invocation by subclass constructors, typically
140      * implicit.)
141      */
142     protected Format() {
143     }
144 
145     /**
146      * Formats an object to produce a string. This is equivalent to
147      * &lt;blockquote&gt;
148      * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
149      *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
150      * &lt;/blockquote&gt;
151      *
152      * @param obj    The object to format
153      * @return       Formatted string.
<a name="17" id="anc17"></a><span class="line-modified">154      * @exception IllegalArgumentException if the Format cannot format the given</span>
155      *            object
156      */
157     public final String format (Object obj) {
158         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
159     }
160 
161     /**
162      * Formats an object and appends the resulting text to a given string
163      * buffer.
<a name="18" id="anc18"></a><span class="line-modified">164      * If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,</span>
165      * then its indices are set to the beginning and end of the first such
166      * field encountered.
167      *
168      * @param obj    The object to format
169      * @param toAppendTo    where the text is to be appended
<a name="19" id="anc19"></a><span class="line-modified">170      * @param pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field</span>
171      *               in the formatted text
<a name="20" id="anc20"></a><span class="line-modified">172      * @return       the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,</span>
173      *               with formatted text appended
<a name="21" id="anc21"></a><span class="line-modified">174      * @exception NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or</span>
<span class="line-modified">175      *            &lt;code&gt;pos&lt;/code&gt; is null</span>
<span class="line-modified">176      * @exception IllegalArgumentException if the Format cannot format the given</span>
177      *            object
178      */
179     public abstract StringBuffer format(Object obj,
180                     StringBuffer toAppendTo,
181                     FieldPosition pos);
182 
183     /**
<a name="22" id="anc22"></a><span class="line-modified">184      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">185      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
186      * to build the resulting String, as well as to determine information
187      * about the resulting String.
188      * &lt;p&gt;
189      * Each attribute key of the AttributedCharacterIterator will be of type
<a name="23" id="anc23"></a><span class="line-modified">190      * &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation</span>
191      * to define what the legal values are for each attribute in the
<a name="24" id="anc24"></a><span class="line-modified">192      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute</span>
193      * key is also used as the attribute value.
194      * &lt;p&gt;The default implementation creates an
<a name="25" id="anc25"></a><span class="line-modified">195      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses</span>
196      * that support fields should override this and create an
<a name="26" id="anc26"></a><span class="line-modified">197      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.</span>
198      *
<a name="27" id="anc27"></a><span class="line-modified">199      * @exception NullPointerException if obj is null.</span>
<span class="line-modified">200      * @exception IllegalArgumentException when the Format cannot format the</span>
201      *            given object.
202      * @param obj The object to format
203      * @return AttributedCharacterIterator describing the formatted value.
204      * @since 1.4
205      */
206     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
207         return createAttributedCharacterIterator(format(obj));
208     }
209 
210     /**
211      * Parses text from a string to produce an object.
212      * &lt;p&gt;
213      * The method attempts to parse text starting at the index given by
<a name="28" id="anc28"></a><span class="line-modified">214      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">215      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
216      * to the index after the last character used (parsing does not necessarily
217      * use all characters up to the end of the string), and the parsed
<a name="29" id="anc29"></a><span class="line-modified">218      * object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
219      * indicate the starting point for the next call to this method.
<a name="30" id="anc30"></a><span class="line-modified">220      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">221      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
222      * the character where the error occurred, and null is returned.
223      *
<a name="31" id="anc31"></a><span class="line-modified">224      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">225      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
226      *            index information as described above.
<a name="32" id="anc32"></a><span class="line-modified">227      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of</span>
228      *         error, returns null.
229      * @throws NullPointerException if {@code source} or {@code pos} is null.
230      */
231     public abstract Object parseObject (String source, ParsePosition pos);
232 
233     /**
234      * Parses text from the beginning of the given string to produce an object.
235      * The method may not use the entire text of the given string.
236      *
<a name="33" id="anc33"></a><span class="line-modified">237      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">238      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string.</span>
<span class="line-modified">239      * @exception ParseException if the beginning of the specified string</span>
240      *            cannot be parsed.
241      * @throws NullPointerException if {@code source} is null.
242      */
243     public Object parseObject(String source) throws ParseException {
244         ParsePosition pos = new ParsePosition(0);
245         Object result = parseObject(source, pos);
246         if (pos.index == 0) {
247             throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
248                 pos.errorIndex);
249         }
250         return result;
251     }
252 
253     /**
254      * Creates and returns a copy of this object.
255      *
256      * @return a clone of this instance.
257      */
258     public Object clone() {
259         try {
260             return super.clone();
261         } catch (CloneNotSupportedException e) {
262             // will never happen
263             throw new InternalError(e);
264         }
265     }
266 
267     //
268     // Convenience methods for creating AttributedCharacterIterators from
269     // different parameters.
270     //
271 
272     /**
<a name="34" id="anc34"></a><span class="line-modified">273      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String</span>
<span class="line-modified">274      * &lt;code&gt;s&lt;/code&gt;.</span>
275      *
276      * @param s String to create AttributedCharacterIterator from
277      * @return AttributedCharacterIterator wrapping s
278      */
279     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
280         AttributedString as = new AttributedString(s);
281 
282         return as.getIterator();
283     }
284 
285     /**
<a name="35" id="anc35"></a><span class="line-modified">286      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containing the</span>
287      * concatenated contents of the passed in
<a name="36" id="anc36"></a><span class="line-modified">288      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.</span>
289      *
290      * @param iterators AttributedCharacterIterators used to create resulting
291      *                  AttributedCharacterIterators
292      * @return AttributedCharacterIterator wrapping passed in
293      *         AttributedCharacterIterators
294      */
295     AttributedCharacterIterator createAttributedCharacterIterator(
296                        AttributedCharacterIterator[] iterators) {
297         AttributedString as = new AttributedString(iterators);
298 
299         return as.getIterator();
300     }
301 
302     /**
303      * Returns an AttributedCharacterIterator with the String
<a name="37" id="anc37"></a><span class="line-modified">304      * &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,</span>
<span class="line-modified">305      * &lt;code&gt;value&lt;/code&gt;.</span>
306      *
307      * @param string String to create AttributedCharacterIterator from
308      * @param key Key for AttributedCharacterIterator
309      * @param value Value associated with key in AttributedCharacterIterator
310      * @return AttributedCharacterIterator wrapping args
311      */
312     AttributedCharacterIterator createAttributedCharacterIterator(
313                       String string, AttributedCharacterIterator.Attribute key,
314                       Object value) {
315         AttributedString as = new AttributedString(string);
316 
317         as.addAttribute(key, value);
318         return as.getIterator();
319     }
320 
321     /**
322      * Creates an AttributedCharacterIterator with the contents of
<a name="38" id="anc38"></a><span class="line-modified">323      * &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;</span>
<span class="line-modified">324      * &lt;code&gt;value&lt;/code&gt;.</span>
325      *
326      * @param iterator Initial AttributedCharacterIterator to add arg to
327      * @param key Key for AttributedCharacterIterator
328      * @param value Value associated with key in AttributedCharacterIterator
329      * @return AttributedCharacterIterator wrapping args
330      */
331     AttributedCharacterIterator createAttributedCharacterIterator(
332               AttributedCharacterIterator iterator,
333               AttributedCharacterIterator.Attribute key, Object value) {
334         AttributedString as = new AttributedString(iterator);
335 
336         as.addAttribute(key, value);
337         return as.getIterator();
338     }
339 
340 
341     /**
342      * Defines constants that are used as attribute keys in the
<a name="39" id="anc39"></a><span class="line-modified">343      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">344      * from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">345      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
346      *
347      * @since 1.4
348      */
349     public static class Field extends AttributedCharacterIterator.Attribute {
350 
351         // Proclaim serial compatibility with 1.4 FCS
<a name="40" id="anc40"></a>
352         private static final long serialVersionUID = 276966692217360283L;
353 
354         /**
355          * Creates a Field with the specified name.
356          *
357          * @param name Name of the attribute
358          */
359         protected Field(String name) {
360             super(name);
361         }
362     }
363 
364 
365     /**
<a name="41" id="anc41"></a><span class="line-modified">366      * FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;</span>
367      * implementations as they are formatting the Objects. This allows for
368      * storage of the individual sections of the formatted String for
<a name="42" id="anc42"></a><span class="line-modified">369      * later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an</span>
<span class="line-modified">370      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
371      * &lt;p&gt;
<a name="43" id="anc43"></a><span class="line-modified">372      * Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify</span>
373      * the delegate of fields in any particular order.
374      *
375      * @see FieldPosition#getFieldDelegate
376      * @see CharacterIteratorFieldDelegate
377      */
378     interface FieldDelegate {
379         /**
380          * Notified when a particular region of the String is formatted. This
381          * method will be invoked if there is no corresponding integer field id
<a name="44" id="anc44"></a><span class="line-modified">382          * matching &lt;code&gt;attr&lt;/code&gt;.</span>
383          *
384          * @param attr Identifies the field matched
385          * @param value Value associated with the field
386          * @param start Beginning location of the field, will be &gt;= 0
387          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
388          * @param buffer Contains current formatted value, receiver should
389          *        NOT modify it.
390          */
391         public void formatted(Format.Field attr, Object value, int start,
392                               int end, StringBuffer buffer);
393 
394         /**
395          * Notified when a particular region of the String is formatted.
396          *
397          * @param fieldID Identifies the field by integer
398          * @param attr Identifies the field matched
399          * @param value Value associated with the field
400          * @param start Beginning location of the field, will be &gt;= 0
401          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
402          * @param buffer Contains current formatted value, receiver should
403          *        NOT modify it.
404          */
405         public void formatted(int fieldID, Format.Field attr, Object value,
406                               int start, int end, StringBuffer buffer);
407     }
408 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
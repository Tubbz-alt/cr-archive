<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/nio/MappedByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Heap-X-Buffer.java.template.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringCharBuffer.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/MappedByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,13 @@</span>
  
  package java.nio;
  
  import java.io.FileDescriptor;
  import java.lang.ref.Reference;
<span class="udiff-line-added">+ import java.util.Objects;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  import jdk.internal.misc.Unsafe;
  
  
  /**
   * A direct byte buffer whose content is a memory-mapped region of a file.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75,38 +78,108 @@</span>
  
      // For mapped buffers, a FileDescriptor that may be used for mapping
      // operations if valid; null if the buffer is not mapped.
      private final FileDescriptor fd;
  
<span class="udiff-line-added">+     // A flag true if this buffer is mapped against non-volatile</span>
<span class="udiff-line-added">+     // memory using one of the extended FileChannel.MapMode modes,</span>
<span class="udiff-line-added">+     // MapMode.READ_ONLY_SYNC or MapMode.READ_WRITE_SYNC and false if</span>
<span class="udiff-line-added">+     // it is mapped using any of the other modes. This flag only</span>
<span class="udiff-line-added">+     // determines the behavior of force operations.</span>
<span class="udiff-line-added">+     private final boolean isSync;</span>
<span class="udiff-line-added">+ </span>
      // This should only be invoked by the DirectByteBuffer constructors
      //
      MappedByteBuffer(int mark, int pos, int lim, int cap, // package-private
<span class="udiff-line-modified-removed">-                      FileDescriptor fd)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-removed">-         super(mark, pos, lim, cap);</span>
<span class="udiff-line-modified-added">+                      FileDescriptor fd, boolean isSync, MemorySegmentProxy segment) {</span>
<span class="udiff-line-modified-added">+         super(mark, pos, lim, cap, segment);</span>
          this.fd = fd;
<span class="udiff-line-added">+         this.isSync = isSync;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MappedByteBuffer(int mark, int pos, int lim, int cap, // package-private</span>
<span class="udiff-line-added">+                      boolean isSync, MemorySegmentProxy segment) {</span>
<span class="udiff-line-added">+         super(mark, pos, lim, cap, segment);</span>
<span class="udiff-line-added">+         this.fd = null;</span>
<span class="udiff-line-added">+         this.isSync = isSync;</span>
      }
  
<span class="udiff-line-modified-removed">-     MappedByteBuffer(int mark, int pos, int lim, int cap) { // package-private</span>
<span class="udiff-line-modified-removed">-         super(mark, pos, lim, cap);</span>
<span class="udiff-line-modified-added">+     MappedByteBuffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { // package-private</span>
<span class="udiff-line-modified-added">+         super(mark, pos, lim, cap, segment);</span>
          this.fd = null;
<span class="udiff-line-added">+         this.isSync = false;</span>
      }
  
<span class="udiff-line-modified-removed">-     // Returns the distance (in bytes) of the buffer from the page aligned address</span>
<span class="udiff-line-modified-removed">-     // of the mapping. Computed each time to avoid storing in every direct buffer.</span>
<span class="udiff-line-modified-added">+     // Returns the distance (in bytes) of the buffer start from the</span>
<span class="udiff-line-modified-added">+     // largest page aligned address of the mapping less than or equal</span>
<span class="udiff-line-added">+     // to the start address.</span>
      private long mappingOffset() {
<span class="udiff-line-added">+         return mappingOffset(0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Returns the distance (in bytes) of the buffer element</span>
<span class="udiff-line-added">+     // identified by index from the largest page aligned address of</span>
<span class="udiff-line-added">+     // the mapping less than or equal to the element address. Computed</span>
<span class="udiff-line-added">+     // each time to avoid storing in every direct buffer.</span>
<span class="udiff-line-added">+     private long mappingOffset(int index) {</span>
          int ps = Bits.pageSize();
<span class="udiff-line-modified-removed">-         long offset = address % ps;</span>
<span class="udiff-line-modified-removed">-         return (offset &gt;= 0) ? offset : (ps + offset);</span>
<span class="udiff-line-modified-added">+         long indexAddress = address + index;</span>
<span class="udiff-line-modified-added">+         long baseAddress = alignDown(indexAddress, ps);</span>
<span class="udiff-line-added">+         return indexAddress - baseAddress;</span>
      }
  
<span class="udiff-line-added">+     // Given an offset previously obtained from calling</span>
<span class="udiff-line-added">+     // mappingOffset() returns the largest page aligned address of the</span>
<span class="udiff-line-added">+     // mapping less than or equal to the buffer start address.</span>
      private long mappingAddress(long mappingOffset) {
<span class="udiff-line-modified-removed">-         return address - mappingOffset;</span>
<span class="udiff-line-modified-added">+         return mappingAddress(mappingOffset, 0);</span>
      }
  
<span class="udiff-line-added">+     // Given an offset previously otained from calling</span>
<span class="udiff-line-added">+     // mappingOffset(index) returns the largest page aligned address</span>
<span class="udiff-line-added">+     // of the mapping less than or equal to the address of the buffer</span>
<span class="udiff-line-added">+     // element identified by index.</span>
<span class="udiff-line-added">+     private long mappingAddress(long mappingOffset, long index) {</span>
<span class="udiff-line-added">+         long indexAddress = address + index;</span>
<span class="udiff-line-added">+         return indexAddress - mappingOffset;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // given a mappingOffset previously otained from calling</span>
<span class="udiff-line-added">+     // mappingOffset() return that offset added to the buffer</span>
<span class="udiff-line-added">+     // capacity.</span>
      private long mappingLength(long mappingOffset) {
<span class="udiff-line-modified-removed">-         return (long)capacity() + mappingOffset;</span>
<span class="udiff-line-modified-added">+         return mappingLength(mappingOffset, (long)capacity());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // given a mappingOffset previously otained from calling</span>
<span class="udiff-line-added">+     // mappingOffset(index) return that offset added to the supplied</span>
<span class="udiff-line-added">+     // length.</span>
<span class="udiff-line-added">+     private long mappingLength(long mappingOffset, long length) {</span>
<span class="udiff-line-added">+         return length + mappingOffset;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // align address down to page size</span>
<span class="udiff-line-added">+     private static long alignDown(long address, int pageSize) {</span>
<span class="udiff-line-added">+         // pageSize must be a power of 2</span>
<span class="udiff-line-added">+         return address &amp; ~(pageSize - 1);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Tells whether this buffer was mapped against a non-volatile</span>
<span class="udiff-line-added">+      * memory device by passing one of the sync map modes {@link</span>
<span class="udiff-line-added">+      * jdk.nio.mapmode.ExtendedMapMode#READ_ONLY_SYNC</span>
<span class="udiff-line-added">+      * ExtendedMapModeMapMode#READ_ONLY_SYNC} or {@link</span>
<span class="udiff-line-added">+      * jdk.nio.mapmode.ExtendedMapMode#READ_ONLY_SYNC</span>
<span class="udiff-line-added">+      * ExtendedMapMode#READ_WRITE_SYNC} in the call to {@link</span>
<span class="udiff-line-added">+      * java.nio.channels.FileChannel#map FileChannel.map} or was</span>
<span class="udiff-line-added">+      * mapped by passing one of the other map modes.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return true if the file was mapped using one of the sync map</span>
<span class="udiff-line-added">+      * modes, otherwise false.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean isSync() {</span>
<span class="udiff-line-added">+         return isSync;</span>
      }
  
      /**
       * Tells whether or not this buffer&#39;s content is resident in physical
       * memory.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,10 +200,14 @@</span>
       */
      public final boolean isLoaded() {
          if (fd == null) {
              return true;
          }
<span class="udiff-line-added">+         // a sync mapped buffer is always loaded</span>
<span class="udiff-line-added">+         if (isSync()) {</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
          if ((address == 0) || (capacity() == 0))
              return true;
          long offset = mappingOffset();
          long length = mappingLength(offset);
          return isLoaded0(mappingAddress(offset), length, Bits.pageCount(length));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151,10 +228,14 @@</span>
       */
      public final MappedByteBuffer load() {
          if (fd == null) {
              return this;
          }
<span class="udiff-line-added">+         // no need to load a sync mapped buffer</span>
<span class="udiff-line-added">+         if (isSync()) {</span>
<span class="udiff-line-added">+             return this;</span>
<span class="udiff-line-added">+         }</span>
          if ((address == 0) || (capacity() == 0))
              return this;
          long offset = mappingOffset();
          long length = mappingLength(offset);
          load0(mappingAddress(offset), length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -194,26 +275,93 @@</span>
       *
       * &lt;p&gt; If the file does not reside on a local device then no such guarantee
       * is made.
       *
       * &lt;p&gt; If this buffer was not mapped in read/write mode ({@link
<span class="udiff-line-modified-removed">-      * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this</span>
<span class="udiff-line-modified-removed">-      * method has no effect. &lt;/p&gt;</span>
<span class="udiff-line-modified-added">+      * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then</span>
<span class="udiff-line-modified-added">+      * invoking this method may have no effect. In particular, the</span>
<span class="udiff-line-added">+      * method has no effect for buffers mapped in read-only or private</span>
<span class="udiff-line-added">+      * mapping modes. This method may or may not have an effect for</span>
<span class="udiff-line-added">+      * implementation-specific mapping modes. &lt;/p&gt;</span>
       *
       * @return  This buffer
       */
      public final MappedByteBuffer force() {
          if (fd == null) {
              return this;
          }
<span class="udiff-line-added">+         if (isSync) {</span>
<span class="udiff-line-added">+             return force(0, limit());</span>
<span class="udiff-line-added">+         }</span>
          if ((address != 0) &amp;&amp; (capacity() != 0)) {
              long offset = mappingOffset();
              force0(fd, mappingAddress(offset), mappingLength(offset));
          }
          return this;
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Forces any changes made to a region of this buffer&#39;s content to</span>
<span class="udiff-line-added">+      * be written to the storage device containing the mapped</span>
<span class="udiff-line-added">+      * file. The region starts at the given {@code index} in this</span>
<span class="udiff-line-added">+      * buffer and is {@code length} bytes.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; If the file mapped into this buffer resides on a local</span>
<span class="udiff-line-added">+      * storage device then when this method returns it is guaranteed</span>
<span class="udiff-line-added">+      * that all changes made to the selected region buffer since it</span>
<span class="udiff-line-added">+      * was created, or since this method was last invoked, will have</span>
<span class="udiff-line-added">+      * been written to that device. The force operation is free to</span>
<span class="udiff-line-added">+      * write bytes that lie outside the specified region, for example</span>
<span class="udiff-line-added">+      * to ensure that data blocks of some device-specific granularity</span>
<span class="udiff-line-added">+      * are transferred in their entirety.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; If the file does not reside on a local device then no such</span>
<span class="udiff-line-added">+      * guarantee is made.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; If this buffer was not mapped in read/write mode ({@link</span>
<span class="udiff-line-added">+      * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then</span>
<span class="udiff-line-added">+      * invoking this method may have no effect. In particular, the</span>
<span class="udiff-line-added">+      * method has no effect for buffers mapped in read-only or private</span>
<span class="udiff-line-added">+      * mapping modes. This method may or may not have an effect for</span>
<span class="udiff-line-added">+      * implementation-specific mapping modes. &lt;/p&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param  index</span>
<span class="udiff-line-added">+      *         The index of the first byte in the buffer region that is</span>
<span class="udiff-line-added">+      *         to be written back to storage; must be non-negative</span>
<span class="udiff-line-added">+      *         and less than limit()</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param  length</span>
<span class="udiff-line-added">+      *         The length of the region in bytes; must be non-negative</span>
<span class="udiff-line-added">+      *         and no larger than limit() - index</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @throws IndexOutOfBoundsException</span>
<span class="udiff-line-added">+      *         if the preconditions on the index and length do not</span>
<span class="udiff-line-added">+      *         hold.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return  This buffer</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @since 13</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public final MappedByteBuffer force(int index, int length) {</span>
<span class="udiff-line-added">+         if (fd == null) {</span>
<span class="udiff-line-added">+             return this;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if ((address != 0) &amp;&amp; (limit() != 0)) {</span>
<span class="udiff-line-added">+             // check inputs</span>
<span class="udiff-line-added">+             Objects.checkFromIndexSize(index, length, limit());</span>
<span class="udiff-line-added">+             if (isSync) {</span>
<span class="udiff-line-added">+                 // simply force writeback of associated cache lines</span>
<span class="udiff-line-added">+                 Unsafe.getUnsafe().writebackMemory(address + index, length);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // force writeback via file descriptor</span>
<span class="udiff-line-added">+                 long offset = mappingOffset(index);</span>
<span class="udiff-line-added">+                 force0(fd, mappingAddress(offset, index), mappingLength(offset, length));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return this;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private native boolean isLoaded0(long address, long length, int pageCount);
      private native void load0(long address, long length);
      private native void force0(FileDescriptor fd, long address, long length);
  
      // -- Covariant return type overrides
</pre>
<center><a href="Heap-X-Buffer.java.template.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringCharBuffer.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
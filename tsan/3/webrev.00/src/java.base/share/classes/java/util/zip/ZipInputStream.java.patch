diff a/src/java.base/share/classes/java/util/zip/ZipInputStream.java b/src/java.base/share/classes/java/util/zip/ZipInputStream.java
--- a/src/java.base/share/classes/java/util/zip/ZipInputStream.java
+++ b/src/java.base/share/classes/java/util/zip/ZipInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,11 +28,13 @@
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.EOFException;
 import java.io.PushbackInputStream;
 import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
+
+import sun.nio.cs.UTF_8;
+
 import static java.util.zip.ZipConstants64.*;
 import static java.util.zip.ZipUtils.*;
 
 /**
  * This class implements an input stream filter for reading files in the
@@ -40,12 +42,11 @@
  * entries.
  *
  * @author      David Connelly
  * @since 1.1
  */
-public
-class ZipInputStream extends InflaterInputStream implements ZipConstants {
+public class ZipInputStream extends InflaterInputStream implements ZipConstants {
     private ZipEntry entry;
     private int flag;
     private CRC32 crc = new CRC32();
     private long remaining;
     private byte[] tmpbuf = new byte[512];
@@ -76,11 +77,11 @@
      * decode the entry names.
      *
      * @param in the actual input stream
      */
     public ZipInputStream(InputStream in) {
-        this(in, StandardCharsets.UTF_8);
+        this(in, UTF_8.INSTANCE);
     }
 
     /**
      * Creates a new ZIP input stream.
      *
@@ -108,12 +109,12 @@
 
     /**
      * Reads the next ZIP file entry and positions the stream at the
      * beginning of the entry data.
      * @return the next ZIP file entry, or null if there are no more entries
-     * @exception ZipException if a ZIP file error has occurred
-     * @exception IOException if an I/O error has occurred
+     * @throws    ZipException if a ZIP file error has occurred
+     * @throws    IOException if an I/O error has occurred
      */
     public ZipEntry getNextEntry() throws IOException {
         ensureOpen();
         if (entry != null) {
             closeEntry();
@@ -131,12 +132,12 @@
     }
 
     /**
      * Closes the current ZIP entry and positions the stream for reading the
      * next entry.
-     * @exception ZipException if a ZIP file error has occurred
-     * @exception IOException if an I/O error has occurred
+     * @throws    ZipException if a ZIP file error has occurred
+     * @throws    IOException if an I/O error has occurred
      */
     public void closeEntry() throws IOException {
         ensureOpen();
         while (read(tmpbuf, 0, tmpbuf.length) != -1) ;
         entryEOF = true;
@@ -148,11 +149,11 @@
      * <p>
      * Programs should not count on this method to return the actual number
      * of bytes that could be read without blocking.
      *
      * @return     1 before EOF and 0 after EOF has reached for current entry.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      *
      */
     public int available() throws IOException {
         ensureOpen();
         if (entryEOF) {
@@ -162,24 +163,24 @@
         }
     }
 
     /**
      * Reads from the current ZIP entry into an array of bytes.
-     * If <code>len</code> is not zero, the method
+     * If {@code len} is not zero, the method
      * blocks until some input is available; otherwise, no
-     * bytes are read and <code>0</code> is returned.
+     * bytes are read and {@code 0} is returned.
      * @param b the buffer into which the data is read
-     * @param off the start offset in the destination array <code>b</code>
+     * @param off the start offset in the destination array {@code b}
      * @param len the maximum number of bytes read
      * @return the actual number of bytes read, or -1 if the end of the
      *         entry is reached
-     * @exception  NullPointerException if <code>b</code> is <code>null</code>.
-     * @exception  IndexOutOfBoundsException if <code>off</code> is negative,
-     * <code>len</code> is negative, or <code>len</code> is greater than
-     * <code>b.length - off</code>
-     * @exception ZipException if a ZIP file error has occurred
-     * @exception IOException if an I/O error has occurred
+     * @throws     NullPointerException if {@code b} is {@code null}.
+     * @throws     IndexOutOfBoundsException if {@code off} is negative,
+     * {@code len} is negative, or {@code len} is greater than
+     * {@code b.length - off}
+     * @throws    ZipException if a ZIP file error has occurred
+     * @throws    IOException if an I/O error has occurred
      */
     public int read(byte[] b, int off, int len) throws IOException {
         ensureOpen();
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new IndexOutOfBoundsException();
@@ -229,13 +230,13 @@
 
     /**
      * Skips specified number of bytes in the current ZIP entry.
      * @param n the number of bytes to skip
      * @return the actual number of bytes skipped
-     * @exception ZipException if a ZIP file error has occurred
-     * @exception IOException if an I/O error has occurred
-     * @exception IllegalArgumentException if {@code n < 0}
+     * @throws    ZipException if a ZIP file error has occurred
+     * @throws    IOException if an I/O error has occurred
+     * @throws    IllegalArgumentException if {@code n < 0}
      */
     public long skip(long n) throws IOException {
         if (n < 0) {
             throw new IllegalArgumentException("negative skip length");
         }
@@ -258,11 +259,11 @@
     }
 
     /**
      * Closes this input stream and releases any system resources associated
      * with the stream.
-     * @exception IOException if an I/O error has occurred
+     * @throws    IOException if an I/O error has occurred
      */
     public void close() throws IOException {
         if (!closed) {
             super.close();
             closed = true;
@@ -319,17 +320,17 @@
         len = get16(tmpbuf, LOCEXT);
         if (len > 0) {
             byte[] extra = new byte[len];
             readFully(extra, 0, len);
             e.setExtra0(extra,
-                        e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL);
+                        e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL, true);
         }
         return e;
     }
 
     /**
-     * Creates a new <code>ZipEntry</code> object for the specified
+     * Creates a new {@code ZipEntry} object for the specified
      * entry name.
      *
      * @param name the ZIP file entry name
      * @return the ZipEntry just created
      */

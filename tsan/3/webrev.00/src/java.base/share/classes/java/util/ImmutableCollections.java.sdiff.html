<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/ImmutableCollections.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="IllformedLocaleException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputMismatchException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ImmutableCollections.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import java.util.function.UnaryOperator;
  39 import jdk.internal.access.SharedSecrets;
  40 import jdk.internal.misc.VM;
  41 import jdk.internal.vm.annotation.Stable;
  42 
  43 /**
  44  * Container class for immutable collections. Not part of the public API.
  45  * Mainly for namespace management and shared infrastructure.
  46  *
  47  * Serial warnings are suppressed throughout because all implementation
  48  * classes use a serial proxy and thus have no need to declare serialVersionUID.
  49  */
  50 @SuppressWarnings(&quot;serial&quot;)
  51 class ImmutableCollections {
  52     /**
  53      * A &quot;salt&quot; value used for randomizing iteration order. This is initialized once
  54      * and stays constant for the lifetime of the JVM. It need not be truly random, but
  55      * it needs to vary sufficiently from one run to the next so that iteration order
  56      * will vary between JVM runs.
  57      */
<span class="line-modified">  58     static final int SALT;</span>



































  59     static {
<span class="line-modified">  60         long nt = System.nanoTime();</span>
<span class="line-modified">  61         SALT = (int)((nt &gt;&gt;&gt; 32) ^ nt);</span>











  62     }
  63 
  64     /** No instances. */
  65     private ImmutableCollections() { }
  66 
  67     /**
  68      * The reciprocal of load factor. Given a number of elements
  69      * to store, multiply by this factor to get the table size.
  70      */
  71     static final int EXPAND_FACTOR = 2;
  72 
  73     static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }
  74 
  75     static abstract class AbstractImmutableCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; {
  76         // all mutating methods throw UnsupportedOperationException
  77         @Override public boolean add(E e) { throw uoe(); }
  78         @Override public boolean addAll(Collection&lt;? extends E&gt; c) { throw uoe(); }
  79         @Override public void    clear() { throw uoe(); }
  80         @Override public boolean remove(Object o) { throw uoe(); }
  81         @Override public boolean removeAll(Collection&lt;?&gt; c) { throw uoe(); }
  82         @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) { throw uoe(); }
  83         @Override public boolean retainAll(Collection&lt;?&gt; c) { throw uoe(); }
  84     }
  85 
  86     // ---------- List Implementations ----------
  87 
  88     // make a copy, short-circuiting based on implementation class
  89     @SuppressWarnings(&quot;unchecked&quot;)
  90     static &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) {
  91         if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) {
  92             return (List&lt;E&gt;)coll;
  93         } else {
  94             return (List&lt;E&gt;)List.of(coll.toArray());
  95         }
  96     }
  97 
<span class="line-removed">  98     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">  99     static &lt;E&gt; List&lt;E&gt; emptyList() {</span>
<span class="line-removed"> 100         return (List&lt;E&gt;) ListN.EMPTY_LIST;</span>
<span class="line-removed"> 101     }</span>
<span class="line-removed"> 102 </span>
 103     static abstract class AbstractImmutableList&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;
 104             implements List&lt;E&gt;, RandomAccess {
 105 
 106         // all mutating methods throw UnsupportedOperationException
 107         @Override public void    add(int index, E element) { throw uoe(); }
 108         @Override public boolean addAll(int index, Collection&lt;? extends E&gt; c) { throw uoe(); }
 109         @Override public E       remove(int index) { throw uoe(); }
 110         @Override public void    replaceAll(UnaryOperator&lt;E&gt; operator) { throw uoe(); }
 111         @Override public E       set(int index, E element) { throw uoe(); }
 112         @Override public void    sort(Comparator&lt;? super E&gt; c) { throw uoe(); }
 113 
 114         @Override
 115         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 116             int size = size();
 117             subListRangeCheck(fromIndex, toIndex, size);
 118             return SubList.fromList(this, fromIndex, toIndex);
 119         }
 120 
 121         static void subListRangeCheck(int fromIndex, int toIndex, int size) {
 122             if (fromIndex &lt; 0)
</pre>
<hr />
<pre>
 374             T[] array = a.length &gt;= size ? a :
 375                     (T[])java.lang.reflect.Array
 376                             .newInstance(a.getClass().getComponentType(), size);
 377             for (int i = 0; i &lt; size; i++) {
 378                 array[i] = (T)get(i);
 379             }
 380             if (array.length &gt; size) {
 381                 array[size] = null; // null-terminate
 382             }
 383             return array;
 384         }
 385     }
 386 
 387     static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 388             implements Serializable {
 389 
 390         @Stable
 391         private final E e0;
 392 
 393         @Stable
<span class="line-modified"> 394         private final E e1;</span>
 395 
 396         List12(E e0) {
 397             this.e0 = Objects.requireNonNull(e0);
<span class="line-modified"> 398             this.e1 = null;</span>


 399         }
 400 
 401         List12(E e0, E e1) {
 402             this.e0 = Objects.requireNonNull(e0);
 403             this.e1 = Objects.requireNonNull(e1);
 404         }
 405 
 406         @Override
 407         public int size() {
<span class="line-modified"> 408             return e1 != null ? 2 : 1;</span>
 409         }
 410 
 411         @Override






 412         public E get(int index) {
 413             if (index == 0) {
 414                 return e0;
<span class="line-modified"> 415             } else if (index == 1 &amp;&amp; e1 != null) {</span>
<span class="line-modified"> 416                 return e1;</span>
 417             }
 418             throw outOfBounds(index);
 419         }
 420 

 421         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 422             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 423         }
 424 

 425         private Object writeReplace() {
<span class="line-modified"> 426             if (e1 == null) {</span>
 427                 return new CollSer(CollSer.IMM_LIST, e0);
 428             } else {
 429                 return new CollSer(CollSer.IMM_LIST, e0, e1);
 430             }
 431         }
 432 
 433         @Override
 434         public Object[] toArray() {
<span class="line-modified"> 435             if (e1 == null) {</span>
 436                 return new Object[] { e0 };
 437             } else {
 438                 return new Object[] { e0, e1 };
 439             }
 440         }
 441 
 442         @Override
 443         @SuppressWarnings(&quot;unchecked&quot;)
 444         public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified"> 445             int size = e1 == null ? 1 : 2;</span>
 446             T[] array = a.length &gt;= size ? a :
 447                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 448             array[0] = (T)e0;
 449             if (size == 2) {
 450                 array[1] = (T)e1;
 451             }
 452             if (array.length &gt; size) {
 453                 array[size] = null; // null-terminate
 454             }
 455             return array;
 456         }
 457     }
 458 
 459     static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 460             implements Serializable {
 461 
<span class="line-removed"> 462         // EMPTY_LIST may be initialized from the CDS archive.</span>
<span class="line-removed"> 463         static @Stable List&lt;?&gt; EMPTY_LIST;</span>
<span class="line-removed"> 464 </span>
<span class="line-removed"> 465         static {</span>
<span class="line-removed"> 466             VM.initializeFromArchive(ListN.class);</span>
<span class="line-removed"> 467             if (EMPTY_LIST == null) {</span>
<span class="line-removed"> 468                 EMPTY_LIST = new ListN&lt;&gt;();</span>
<span class="line-removed"> 469             }</span>
<span class="line-removed"> 470         }</span>
<span class="line-removed"> 471 </span>
 472         @Stable
 473         private final E[] elements;
 474 
 475         @SafeVarargs
 476         ListN(E... input) {
 477             // copy and check manually to avoid TOCTOU
 478             @SuppressWarnings(&quot;unchecked&quot;)
 479             E[] tmp = (E[])new Object[input.length]; // implicit nullcheck of input
 480             for (int i = 0; i &lt; input.length; i++) {
 481                 tmp[i] = Objects.requireNonNull(input[i]);
 482             }
 483             elements = tmp;
 484         }
 485 
 486         @Override
 487         public boolean isEmpty() {
<span class="line-modified"> 488             return size() == 0;</span>
 489         }
 490 
 491         @Override
 492         public int size() {
 493             return elements.length;
 494         }
 495 
 496         @Override
 497         public E get(int index) {
 498             return elements[index];
 499         }
 500 

 501         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 502             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 503         }
 504 

 505         private Object writeReplace() {
 506             return new CollSer(CollSer.IMM_LIST, elements);
 507         }
 508 
 509         @Override
 510         public Object[] toArray() {
 511             return Arrays.copyOf(elements, elements.length);
 512         }
 513 
 514         @Override
 515         @SuppressWarnings(&quot;unchecked&quot;)
 516         public &lt;T&gt; T[] toArray(T[] a) {
 517             int size = elements.length;
 518             if (a.length &lt; size) {
 519                 // Make a new array of a&#39;s runtime type, but my contents:
 520                 return (T[]) Arrays.copyOf(elements, size, a.getClass());
 521             }
 522             System.arraycopy(elements, 0, a, 0, size);
 523             if (a.length &gt; size) {
 524                 a[size] = null; // null-terminate
</pre>
<hr />
<pre>
 539             } else if (!(o instanceof Set)) {
 540                 return false;
 541             }
 542 
 543             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
 544             if (c.size() != size()) {
 545                 return false;
 546             }
 547             for (Object e : c) {
 548                 if (e == null || !contains(e)) {
 549                     return false;
 550                 }
 551             }
 552             return true;
 553         }
 554 
 555         @Override
 556         public abstract int hashCode();
 557     }
 558 
<span class="line-removed"> 559     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed"> 560     static &lt;E&gt; Set&lt;E&gt; emptySet() {</span>
<span class="line-removed"> 561         return (Set&lt;E&gt;) SetN.EMPTY_SET;</span>
<span class="line-removed"> 562     }</span>
<span class="line-removed"> 563 </span>
 564     static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 565             implements Serializable {
 566 
 567         @Stable
<span class="line-modified"> 568         final E e0;</span>

 569         @Stable
<span class="line-modified"> 570         final E e1;</span>
 571 
 572         Set12(E e0) {
 573             this.e0 = Objects.requireNonNull(e0);
<span class="line-modified"> 574             this.e1 = null;</span>


 575         }
 576 
 577         Set12(E e0, E e1) {
 578             if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
 579                 throw new IllegalArgumentException(&quot;duplicate element: &quot; + e0);
 580             }
 581 
 582             this.e0 = e0;
 583             this.e1 = e1;
 584         }
 585 
 586         @Override
 587         public int size() {
<span class="line-modified"> 588             return (e1 == null) ? 1 : 2;</span>





 589         }
 590 
 591         @Override
 592         public boolean contains(Object o) {
<span class="line-modified"> 593             return o.equals(e0) || o.equals(e1); // implicit nullcheck of o</span>
 594         }
 595 
 596         @Override
 597         public int hashCode() {
<span class="line-modified"> 598             return e0.hashCode() + (e1 == null ? 0 : e1.hashCode());</span>
 599         }
 600 
 601         @Override
 602         public Iterator&lt;E&gt; iterator() {
 603             return new Iterator&lt;&gt;() {
<span class="line-modified"> 604                 private int idx = size();</span>
 605 
 606                 @Override
 607                 public boolean hasNext() {
 608                     return idx &gt; 0;
 609                 }
 610 
 611                 @Override

 612                 public E next() {
 613                     if (idx == 1) {
 614                         idx = 0;
<span class="line-modified"> 615                         return SALT &gt;= 0 || e1 == null ? e0 : e1;</span>
 616                     } else if (idx == 2) {
 617                         idx = 1;
<span class="line-modified"> 618                         return SALT &gt;= 0 ? e1 : e0;</span>
 619                     } else {
 620                         throw new NoSuchElementException();
 621                     }
 622                 }
 623             };
 624         }
 625 

 626         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 627             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 628         }
 629 

 630         private Object writeReplace() {
<span class="line-modified"> 631             if (e1 == null) {</span>
 632                 return new CollSer(CollSer.IMM_SET, e0);
 633             } else {
 634                 return new CollSer(CollSer.IMM_SET, e0, e1);
 635             }
 636         }
 637 
 638         @Override
 639         public Object[] toArray() {
<span class="line-modified"> 640             if (e1 == null) {</span>
 641                 return new Object[] { e0 };
<span class="line-modified"> 642             } else if (SALT &gt;= 0) {</span>
 643                 return new Object[] { e1, e0 };
 644             } else {
 645                 return new Object[] { e0, e1 };
 646             }
 647         }
 648 
 649         @Override
 650         @SuppressWarnings(&quot;unchecked&quot;)
 651         public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified"> 652             int size = e1 == null ? 1 : 2;</span>
 653             T[] array = a.length &gt;= size ? a :
 654                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 655             if (size == 1) {
 656                 array[0] = (T)e0;
<span class="line-modified"> 657             } else if (SALT &gt;= 0) {</span>
 658                 array[0] = (T)e1;
 659                 array[1] = (T)e0;
 660             } else {
 661                 array[0] = (T)e0;
 662                 array[1] = (T)e1;
 663             }
 664             if (array.length &gt; size) {
 665                 array[size] = null; // null-terminate
 666             }
 667             return array;
 668         }
 669     }
 670 
 671 
 672     /**
 673      * An array-based Set implementation. The element array must be strictly
 674      * larger than the size (the number of contained elements) so that at
 675      * least one null is always present.
 676      * @param &lt;E&gt; the element type
 677      */
 678     static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 679             implements Serializable {
 680 
<span class="line-removed"> 681         // EMPTY_SET may be initialized from the CDS archive.</span>
<span class="line-removed"> 682         static @Stable Set&lt;?&gt; EMPTY_SET;</span>
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684         static {</span>
<span class="line-removed"> 685             VM.initializeFromArchive(SetN.class);</span>
<span class="line-removed"> 686             if (EMPTY_SET == null) {</span>
<span class="line-removed"> 687                 EMPTY_SET = new SetN&lt;&gt;();</span>
<span class="line-removed"> 688             }</span>
<span class="line-removed"> 689         }</span>
<span class="line-removed"> 690 </span>
 691         @Stable
 692         final E[] elements;

 693         @Stable
 694         final int size;
 695 
 696         @SafeVarargs
 697         @SuppressWarnings(&quot;unchecked&quot;)
 698         SetN(E... input) {
 699             size = input.length; // implicit nullcheck of input
 700 
 701             elements = (E[])new Object[EXPAND_FACTOR * input.length];
 702             for (int i = 0; i &lt; input.length; i++) {
 703                 E e = input[i];
 704                 int idx = probe(e); // implicit nullcheck of e
 705                 if (idx &gt;= 0) {
 706                     throw new IllegalArgumentException(&quot;duplicate element: &quot; + e);
 707                 } else {
 708                     elements[-(idx + 1)] = e;
 709                 }
 710             }
 711         }
 712 
 713         @Override
 714         public int size() {
 715             return size;
 716         }
 717 





 718         @Override
 719         public boolean contains(Object o) {
 720             Objects.requireNonNull(o);
 721             return size &gt; 0 &amp;&amp; probe(o) &gt;= 0;
 722         }
 723 
 724         private final class SetNIterator implements Iterator&lt;E&gt; {
 725 
 726             private int remaining;
 727 
 728             private int idx;
 729 
 730             SetNIterator() {
<span class="line-modified"> 731                 remaining = size();</span>
<span class="line-modified"> 732                 if (remaining &gt; 0) {</span>
<span class="line-modified"> 733                     idx = Math.floorMod(SALT, elements.length);</span>
<span class="line-modified"> 734                 }</span>
 735             }
 736 
 737             @Override
 738             public boolean hasNext() {
 739                 return remaining &gt; 0;
 740             }
 741 
<span class="line-removed"> 742             private int nextIndex() {</span>
<span class="line-removed"> 743                 int idx = this.idx;</span>
<span class="line-removed"> 744                 if (SALT &gt;= 0) {</span>
<span class="line-removed"> 745                     if (++idx &gt;= elements.length) {</span>
<span class="line-removed"> 746                         idx = 0;</span>
<span class="line-removed"> 747                     }</span>
<span class="line-removed"> 748                 } else {</span>
<span class="line-removed"> 749                     if (--idx &lt; 0) {</span>
<span class="line-removed"> 750                         idx = elements.length - 1;</span>
<span class="line-removed"> 751                     }</span>
<span class="line-removed"> 752                 }</span>
<span class="line-removed"> 753                 return this.idx = idx;</span>
<span class="line-removed"> 754             }</span>
<span class="line-removed"> 755 </span>
 756             @Override
 757             public E next() {
 758                 if (remaining &gt; 0) {
 759                     E element;
<span class="line-modified"> 760                     // skip null elements</span>
<span class="line-modified"> 761                     while ((element = elements[nextIndex()]) == null) {}</span>













 762                     remaining--;
 763                     return element;
 764                 } else {
 765                     throw new NoSuchElementException();
 766                 }
 767             }
 768         }
 769 
 770         @Override
 771         public Iterator&lt;E&gt; iterator() {
 772             return new SetNIterator();
 773         }
 774 
 775         @Override
 776         public int hashCode() {
 777             int h = 0;
 778             for (E e : elements) {
 779                 if (e != null) {
 780                     h += e.hashCode();
 781                 }
</pre>
<hr />
<pre>
 784         }
 785 
 786         // returns index at which element is present; or if absent,
 787         // (-i - 1) where i is location where element should be inserted.
 788         // Callers are relying on this method to perform an implicit nullcheck
 789         // of pe
 790         private int probe(Object pe) {
 791             int idx = Math.floorMod(pe.hashCode(), elements.length);
 792             while (true) {
 793                 E ee = elements[idx];
 794                 if (ee == null) {
 795                     return -idx - 1;
 796                 } else if (pe.equals(ee)) {
 797                     return idx;
 798                 } else if (++idx == elements.length) {
 799                     idx = 0;
 800                 }
 801             }
 802         }
 803 

 804         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 805             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 806         }
 807 

 808         private Object writeReplace() {
 809             Object[] array = new Object[size];
 810             int dest = 0;
 811             for (Object o : elements) {
 812                 if (o != null) {
 813                     array[dest++] = o;
 814                 }
 815             }
 816             return new CollSer(CollSer.IMM_SET, array);
 817         }
 818 
 819         @Override
 820         public Object[] toArray() {
 821             Object[] array = new Object[size];
 822             Iterator&lt;E&gt; it = iterator();
 823             for (int i = 0; i &lt; size; i++) {
 824                 array[i] = it.next();
 825             }
 826             return array;
 827         }
 828 
 829         @Override
 830         @SuppressWarnings(&quot;unchecked&quot;)
 831         public &lt;T&gt; T[] toArray(T[] a) {
 832             T[] array = a.length &gt;= size ? a :
 833                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 834             Iterator&lt;E&gt; it = iterator();
 835             for (int i = 0; i &lt; size; i++) {
 836                 array[i] = (T)it.next();
 837             }
 838             if (array.length &gt; size) {
 839                 array[size] = null; // null-terminate
 840             }
 841             return array;
 842         }
 843     }
 844 
 845     // ---------- Map Implementations ----------
 846 
<span class="line-removed"> 847     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed"> 848     static &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() {</span>
<span class="line-removed"> 849         return (Map&lt;K,V&gt;) MapN.EMPTY_MAP;</span>
<span class="line-removed"> 850     }</span>
<span class="line-removed"> 851 </span>
 852     abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable {
 853         @Override public void clear() { throw uoe(); }
 854         @Override public V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 855         @Override public V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mf) { throw uoe(); }
 856         @Override public V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 857         @Override public V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; rf) { throw uoe(); }
 858         @Override public V put(K key, V value) { throw uoe(); }
 859         @Override public void putAll(Map&lt;? extends K,? extends V&gt; m) { throw uoe(); }
 860         @Override public V putIfAbsent(K key, V value) { throw uoe(); }
 861         @Override public V remove(Object key) { throw uoe(); }
 862         @Override public boolean remove(Object key, Object value) { throw uoe(); }
 863         @Override public V replace(K key, V value) { throw uoe(); }
 864         @Override public boolean replace(K key, V oldValue, V newValue) { throw uoe(); }
 865         @Override public void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; f) { throw uoe(); }














 866     }
 867 
 868     static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 869         @Stable
 870         private final K k0;
 871         @Stable
 872         private final V v0;
 873 
 874         Map1(K k0, V v0) {
 875             this.k0 = Objects.requireNonNull(k0);
 876             this.v0 = Objects.requireNonNull(v0);
 877         }
 878 
 879         @Override
 880         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
 881             return Set.of(new KeyValueHolder&lt;&gt;(k0, v0));
 882         }
 883 





 884         @Override
 885         public boolean containsKey(Object o) {
 886             return o.equals(k0); // implicit nullcheck of o
 887         }
 888 
 889         @Override
 890         public boolean containsValue(Object o) {
 891             return o.equals(v0); // implicit nullcheck of o
 892         }
 893 











 894         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 895             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 896         }
 897 

 898         private Object writeReplace() {
 899             return new CollSer(CollSer.IMM_MAP, k0, v0);
 900         }
 901 
 902         @Override
 903         public int hashCode() {
 904             return k0.hashCode() ^ v0.hashCode();
 905         }
 906     }
 907 
 908     /**
 909      * An array-based Map implementation. There is a single array &quot;table&quot; that
 910      * contains keys and values interleaved: table[0] is kA, table[1] is vA,
 911      * table[2] is kB, table[3] is vB, etc. The table size must be even. It must
 912      * also be strictly larger than the size (the number of key-value pairs contained
 913      * in the map) so that at least one null key is always present.
 914      * @param &lt;K&gt; the key type
 915      * @param &lt;V&gt; the value type
 916      */
 917     static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 918 
<span class="line-removed"> 919         // EMPTY_MAP may be initialized from the CDS archive.</span>
<span class="line-removed"> 920         static @Stable Map&lt;?,?&gt; EMPTY_MAP;</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922         static {</span>
<span class="line-removed"> 923             VM.initializeFromArchive(MapN.class);</span>
<span class="line-removed"> 924             if (EMPTY_MAP == null) {</span>
<span class="line-removed"> 925                 EMPTY_MAP = new MapN&lt;&gt;();</span>
<span class="line-removed"> 926             }</span>
<span class="line-removed"> 927         }</span>
<span class="line-removed"> 928 </span>
 929         @Stable
 930         final Object[] table; // pairs of key, value
 931 
 932         @Stable
 933         final int size; // number of pairs
 934 
 935         MapN(Object... input) {
 936             if ((input.length &amp; 1) != 0) { // implicit nullcheck of input
 937                 throw new InternalError(&quot;length is odd&quot;);
 938             }
 939             size = input.length &gt;&gt; 1;
 940 
 941             int len = EXPAND_FACTOR * input.length;
 942             len = (len + 1) &amp; ~1; // ensure table is even length
 943             table = new Object[len];
 944 
 945             for (int i = 0; i &lt; input.length; i += 2) {
 946                 @SuppressWarnings(&quot;unchecked&quot;)
 947                     K k = Objects.requireNonNull((K)input[i]);
 948                 @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
 991         @Override
 992         @SuppressWarnings(&quot;unchecked&quot;)
 993         public V get(Object o) {
 994             if (size == 0) {
 995                 Objects.requireNonNull(o);
 996                 return null;
 997             }
 998             int i = probe(o);
 999             if (i &gt;= 0) {
1000                 return (V)table[i+1];
1001             } else {
1002                 return null;
1003             }
1004         }
1005 
1006         @Override
1007         public int size() {
1008             return size;
1009         }
1010 





1011         class MapNIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1012 
1013             private int remaining;
1014 
1015             private int idx;
1016 
1017             MapNIterator() {
<span class="line-modified">1018                 remaining = size();</span>
<span class="line-modified">1019                 if (remaining &gt; 0) {</span>
<span class="line-modified">1020                     idx = Math.floorMod(SALT, table.length &gt;&gt; 1) &lt;&lt; 1;</span>
<span class="line-modified">1021                 }</span>
1022             }
1023 
1024             @Override
1025             public boolean hasNext() {
1026                 return remaining &gt; 0;
1027             }
1028 
1029             private int nextIndex() {
1030                 int idx = this.idx;
<span class="line-modified">1031                 if (SALT &gt;= 0) {</span>
1032                     if ((idx += 2) &gt;= table.length) {
1033                         idx = 0;
1034                     }
1035                 } else {
1036                     if ((idx -= 2) &lt; 0) {
1037                         idx = table.length - 2;
1038                     }
1039                 }
1040                 return this.idx = idx;
1041             }
1042 
1043             @Override
1044             public Map.Entry&lt;K,V&gt; next() {
1045                 if (remaining &gt; 0) {
1046                     int idx;
1047                     while (table[idx = nextIndex()] == null) {}
1048                     @SuppressWarnings(&quot;unchecked&quot;)
1049                     Map.Entry&lt;K,V&gt; e =
1050                             new KeyValueHolder&lt;&gt;((K)table[idx], (V)table[idx+1]);
1051                     remaining--;
</pre>
<hr />
<pre>
1073 
1074         // returns index at which the probe key is present; or if absent,
1075         // (-i - 1) where i is location where element should be inserted.
1076         // Callers are relying on this method to perform an implicit nullcheck
1077         // of pk.
1078         private int probe(Object pk) {
1079             int idx = Math.floorMod(pk.hashCode(), table.length &gt;&gt; 1) &lt;&lt; 1;
1080             while (true) {
1081                 @SuppressWarnings(&quot;unchecked&quot;)
1082                 K ek = (K)table[idx];
1083                 if (ek == null) {
1084                     return -idx - 1;
1085                 } else if (pk.equals(ek)) {
1086                     return idx;
1087                 } else if ((idx += 2) == table.length) {
1088                     idx = 0;
1089                 }
1090             }
1091         }
1092 

1093         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1094             throw new InvalidObjectException(&quot;not serial proxy&quot;);
1095         }
1096 

1097         private Object writeReplace() {
1098             Object[] array = new Object[2 * size];
1099             int len = table.length;
1100             int dest = 0;
1101             for (int i = 0; i &lt; len; i += 2) {
1102                 if (table[i] != null) {
1103                     array[dest++] = table[i];
1104                     array[dest++] = table[i+1];
1105                 }
1106             }
1107             return new CollSer(CollSer.IMM_MAP, array);
1108         }
1109     }
1110 }
1111 
1112 // ---------- Serialization Proxy ----------
1113 
1114 /**
1115  * A unified serialization proxy class for the immutable collections.
1116  *
1117  * @serial
1118  * @since 9
1119  */
1120 final class CollSer implements Serializable {

1121     private static final long serialVersionUID = 6309168927139932177L;
1122 
1123     static final int IMM_LIST = 1;
1124     static final int IMM_SET = 2;
1125     static final int IMM_MAP = 3;
1126 
1127     /**
1128      * Indicates the type of collection that is serialized.
1129      * The low order 8 bits have the value 1 for an immutable
1130      * {@code List}, 2 for an immutable {@code Set}, and 3 for
1131      * an immutable {@code Map}. Any other value causes an
1132      * {@link InvalidObjectException} to be thrown. The high
1133      * order 24 bits are zero when an instance is serialized,
1134      * and they are ignored when an instance is deserialized.
1135      * They can thus be used by future implementations without
1136      * causing compatibility issues.
1137      *
1138      * &lt;p&gt;The tag value also determines the interpretation of the
1139      * transient {@code Object[] array} field.
1140      * For {@code List} and {@code Set}, the array&#39;s length is the size
</pre>
<hr />
<pre>
1161 
1162     CollSer(int t, Object... a) {
1163         tag = t;
1164         array = a;
1165     }
1166 
1167     /**
1168      * Reads objects from the stream and stores them
1169      * in the transient {@code Object[] array} field.
1170      *
1171      * @serialData
1172      * A nonnegative int, indicating the count of objects,
1173      * followed by that many objects.
1174      *
1175      * @param ois the ObjectInputStream from which data is read
1176      * @throws IOException if an I/O error occurs
1177      * @throws ClassNotFoundException if a serialized class cannot be loaded
1178      * @throws InvalidObjectException if the count is negative
1179      * @since 9
1180      */

1181     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
1182         ois.defaultReadObject();
1183         int len = ois.readInt();
1184 
1185         if (len &lt; 0) {
1186             throw new InvalidObjectException(&quot;negative length &quot; + len);
1187         }
1188 
1189         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, len);
1190         Object[] a = new Object[len];
1191         for (int i = 0; i &lt; len; i++) {
1192             a[i] = ois.readObject();
1193         }
1194 
1195         array = a;
1196     }
1197 
1198     /**
1199      * Writes objects to the stream from
1200      * the transient {@code Object[] array} field.
1201      *
1202      * @serialData
1203      * A nonnegative int, indicating the count of objects,
1204      * followed by that many objects.
1205      *
1206      * @param oos the ObjectOutputStream to which data is written
1207      * @throws IOException if an I/O error occurs
1208      * @since 9
1209      */

1210     private void writeObject(ObjectOutputStream oos) throws IOException {
1211         oos.defaultWriteObject();
1212         oos.writeInt(array.length);
1213         for (int i = 0; i &lt; array.length; i++) {
1214             oos.writeObject(array[i]);
1215         }
1216     }
1217 
1218     /**
1219      * Creates and returns an immutable collection from this proxy class.
1220      * The instance returned is created as if by calling one of the
1221      * static factory methods for
1222      * &lt;a href=&quot;List.html#unmodifiable&quot;&gt;List&lt;/a&gt;,
1223      * &lt;a href=&quot;Map.html#unmodifiable&quot;&gt;Map&lt;/a&gt;, or
1224      * &lt;a href=&quot;Set.html#unmodifiable&quot;&gt;Set&lt;/a&gt;.
1225      * This proxy class is the serial form for all immutable collection instances,
1226      * regardless of implementation type. This is necessary to ensure that the
1227      * existence of any particular implementation type is kept out of the
1228      * serialized form.
1229      *
1230      * @return a collection created from this proxy object
1231      * @throws InvalidObjectException if the tag value is illegal or if an exception
1232      *         is thrown during creation of the collection
1233      * @throws ObjectStreamException if another serialization error has occurred
1234      * @since 9
1235      */

1236     private Object readResolve() throws ObjectStreamException {
1237         try {
1238             if (array == null) {
1239                 throw new InvalidObjectException(&quot;null array&quot;);
1240             }
1241 
1242             // use low order 8 bits to indicate &quot;kind&quot;
1243             // ignore high order 24 bits
1244             switch (tag &amp; 0xff) {
1245                 case IMM_LIST:
1246                     return List.of(array);
1247                 case IMM_SET:
1248                     return Set.of(array);
1249                 case IMM_MAP:
1250                     if (array.length == 0) {
<span class="line-modified">1251                         return ImmutableCollections.emptyMap();</span>
1252                     } else if (array.length == 2) {
1253                         return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]);
1254                     } else {
1255                         return new ImmutableCollections.MapN&lt;&gt;(array);
1256                     }
1257                 default:
1258                     throw new InvalidObjectException(String.format(&quot;invalid flags 0x%x&quot;, tag));
1259             }
1260         } catch (NullPointerException|IllegalArgumentException ex) {
1261             InvalidObjectException ioe = new InvalidObjectException(&quot;invalid object&quot;);
1262             ioe.initCause(ex);
1263             throw ioe;
1264         }
1265     }
1266 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import java.util.function.UnaryOperator;
  39 import jdk.internal.access.SharedSecrets;
  40 import jdk.internal.misc.VM;
  41 import jdk.internal.vm.annotation.Stable;
  42 
  43 /**
  44  * Container class for immutable collections. Not part of the public API.
  45  * Mainly for namespace management and shared infrastructure.
  46  *
  47  * Serial warnings are suppressed throughout because all implementation
  48  * classes use a serial proxy and thus have no need to declare serialVersionUID.
  49  */
  50 @SuppressWarnings(&quot;serial&quot;)
  51 class ImmutableCollections {
  52     /**
  53      * A &quot;salt&quot; value used for randomizing iteration order. This is initialized once
  54      * and stays constant for the lifetime of the JVM. It need not be truly random, but
  55      * it needs to vary sufficiently from one run to the next so that iteration order
  56      * will vary between JVM runs.
  57      */
<span class="line-modified">  58     private static final long SALT32L;</span>
<span class="line-added">  59 </span>
<span class="line-added">  60     /**</span>
<span class="line-added">  61      * For set and map iteration, we will iterate in &quot;reverse&quot; stochastically,</span>
<span class="line-added">  62      * decided at bootstrap time.</span>
<span class="line-added">  63      */</span>
<span class="line-added">  64     private static final boolean REVERSE;</span>
<span class="line-added">  65     static {</span>
<span class="line-added">  66         // to generate a reasonably random and well-mixed SALT, use an arbitrary</span>
<span class="line-added">  67         // value (a slice of pi), multiply with the System.nanoTime, then pick</span>
<span class="line-added">  68         // the mid 32-bits from the product. By picking a SALT value in the</span>
<span class="line-added">  69         // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive</span>
<span class="line-added">  70         // int N, (SALT32L * N) &gt;&gt; 32 is a number in the [0 ... N-1] range. This</span>
<span class="line-added">  71         // property will be used to avoid more expensive modulo-based</span>
<span class="line-added">  72         // calculations.</span>
<span class="line-added">  73         long color = 0x243F_6A88_85A3_08D3L; // slice of pi</span>
<span class="line-added">  74         long seed = System.nanoTime();</span>
<span class="line-added">  75         SALT32L = (int)((color * seed) &gt;&gt; 16) &amp; 0xFFFF_FFFFL;</span>
<span class="line-added">  76         // use the lowest bit to determine if we should reverse iteration</span>
<span class="line-added">  77         REVERSE = (SALT32L &amp; 1) == 0;</span>
<span class="line-added">  78     }</span>
<span class="line-added">  79 </span>
<span class="line-added">  80     /**</span>
<span class="line-added">  81      * Constants following this might be initialized from the CDS archive via</span>
<span class="line-added">  82      * this array.</span>
<span class="line-added">  83      */</span>
<span class="line-added">  84     private static Object[] archivedObjects;</span>
<span class="line-added">  85 </span>
<span class="line-added">  86     private static final Object EMPTY;</span>
<span class="line-added">  87 </span>
<span class="line-added">  88     static final ListN&lt;?&gt; EMPTY_LIST;</span>
<span class="line-added">  89 </span>
<span class="line-added">  90     static final SetN&lt;?&gt; EMPTY_SET;</span>
<span class="line-added">  91 </span>
<span class="line-added">  92     static final MapN&lt;?,?&gt; EMPTY_MAP;</span>
<span class="line-added">  93 </span>
  94     static {
<span class="line-modified">  95         VM.initializeFromArchive(ImmutableCollections.class);</span>
<span class="line-modified">  96         if (archivedObjects == null) {</span>
<span class="line-added">  97             EMPTY = new Object();</span>
<span class="line-added">  98             EMPTY_LIST = new ListN&lt;&gt;();</span>
<span class="line-added">  99             EMPTY_SET = new SetN&lt;&gt;();</span>
<span class="line-added"> 100             EMPTY_MAP = new MapN&lt;&gt;();</span>
<span class="line-added"> 101             archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };</span>
<span class="line-added"> 102         } else {</span>
<span class="line-added"> 103             EMPTY = archivedObjects[0];</span>
<span class="line-added"> 104             EMPTY_LIST = (ListN)archivedObjects[1];</span>
<span class="line-added"> 105             EMPTY_SET = (SetN)archivedObjects[2];</span>
<span class="line-added"> 106             EMPTY_MAP = (MapN)archivedObjects[3];</span>
<span class="line-added"> 107         }</span>
 108     }
 109 
 110     /** No instances. */
 111     private ImmutableCollections() { }
 112 
 113     /**
 114      * The reciprocal of load factor. Given a number of elements
 115      * to store, multiply by this factor to get the table size.
 116      */
 117     static final int EXPAND_FACTOR = 2;
 118 
 119     static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }
 120 
 121     static abstract class AbstractImmutableCollection&lt;E&gt; extends AbstractCollection&lt;E&gt; {
 122         // all mutating methods throw UnsupportedOperationException
 123         @Override public boolean add(E e) { throw uoe(); }
 124         @Override public boolean addAll(Collection&lt;? extends E&gt; c) { throw uoe(); }
 125         @Override public void    clear() { throw uoe(); }
 126         @Override public boolean remove(Object o) { throw uoe(); }
 127         @Override public boolean removeAll(Collection&lt;?&gt; c) { throw uoe(); }
 128         @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) { throw uoe(); }
 129         @Override public boolean retainAll(Collection&lt;?&gt; c) { throw uoe(); }
 130     }
 131 
 132     // ---------- List Implementations ----------
 133 
 134     // make a copy, short-circuiting based on implementation class
 135     @SuppressWarnings(&quot;unchecked&quot;)
 136     static &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) {
 137         if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) {
 138             return (List&lt;E&gt;)coll;
 139         } else {
 140             return (List&lt;E&gt;)List.of(coll.toArray());
 141         }
 142     }
 143 





 144     static abstract class AbstractImmutableList&lt;E&gt; extends AbstractImmutableCollection&lt;E&gt;
 145             implements List&lt;E&gt;, RandomAccess {
 146 
 147         // all mutating methods throw UnsupportedOperationException
 148         @Override public void    add(int index, E element) { throw uoe(); }
 149         @Override public boolean addAll(int index, Collection&lt;? extends E&gt; c) { throw uoe(); }
 150         @Override public E       remove(int index) { throw uoe(); }
 151         @Override public void    replaceAll(UnaryOperator&lt;E&gt; operator) { throw uoe(); }
 152         @Override public E       set(int index, E element) { throw uoe(); }
 153         @Override public void    sort(Comparator&lt;? super E&gt; c) { throw uoe(); }
 154 
 155         @Override
 156         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
 157             int size = size();
 158             subListRangeCheck(fromIndex, toIndex, size);
 159             return SubList.fromList(this, fromIndex, toIndex);
 160         }
 161 
 162         static void subListRangeCheck(int fromIndex, int toIndex, int size) {
 163             if (fromIndex &lt; 0)
</pre>
<hr />
<pre>
 415             T[] array = a.length &gt;= size ? a :
 416                     (T[])java.lang.reflect.Array
 417                             .newInstance(a.getClass().getComponentType(), size);
 418             for (int i = 0; i &lt; size; i++) {
 419                 array[i] = (T)get(i);
 420             }
 421             if (array.length &gt; size) {
 422                 array[size] = null; // null-terminate
 423             }
 424             return array;
 425         }
 426     }
 427 
 428     static final class List12&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 429             implements Serializable {
 430 
 431         @Stable
 432         private final E e0;
 433 
 434         @Stable
<span class="line-modified"> 435         private final Object e1;</span>
 436 
 437         List12(E e0) {
 438             this.e0 = Objects.requireNonNull(e0);
<span class="line-modified"> 439             // Use EMPTY as a sentinel for an unused element: not using null</span>
<span class="line-added"> 440             // enable constant folding optimizations over single-element lists</span>
<span class="line-added"> 441             this.e1 = EMPTY;</span>
 442         }
 443 
 444         List12(E e0, E e1) {
 445             this.e0 = Objects.requireNonNull(e0);
 446             this.e1 = Objects.requireNonNull(e1);
 447         }
 448 
 449         @Override
 450         public int size() {
<span class="line-modified"> 451             return e1 != EMPTY ? 2 : 1;</span>
 452         }
 453 
 454         @Override
<span class="line-added"> 455         public boolean isEmpty() {</span>
<span class="line-added"> 456             return false;</span>
<span class="line-added"> 457         }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459         @Override</span>
<span class="line-added"> 460         @SuppressWarnings(&quot;unchecked&quot;)</span>
 461         public E get(int index) {
 462             if (index == 0) {
 463                 return e0;
<span class="line-modified"> 464             } else if (index == 1 &amp;&amp; e1 != EMPTY) {</span>
<span class="line-modified"> 465                 return (E)e1;</span>
 466             }
 467             throw outOfBounds(index);
 468         }
 469 
<span class="line-added"> 470         @java.io.Serial</span>
 471         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 472             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 473         }
 474 
<span class="line-added"> 475         @java.io.Serial</span>
 476         private Object writeReplace() {
<span class="line-modified"> 477             if (e1 == EMPTY) {</span>
 478                 return new CollSer(CollSer.IMM_LIST, e0);
 479             } else {
 480                 return new CollSer(CollSer.IMM_LIST, e0, e1);
 481             }
 482         }
 483 
 484         @Override
 485         public Object[] toArray() {
<span class="line-modified"> 486             if (e1 == EMPTY) {</span>
 487                 return new Object[] { e0 };
 488             } else {
 489                 return new Object[] { e0, e1 };
 490             }
 491         }
 492 
 493         @Override
 494         @SuppressWarnings(&quot;unchecked&quot;)
 495         public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified"> 496             int size = size();</span>
 497             T[] array = a.length &gt;= size ? a :
 498                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 499             array[0] = (T)e0;
 500             if (size == 2) {
 501                 array[1] = (T)e1;
 502             }
 503             if (array.length &gt; size) {
 504                 array[size] = null; // null-terminate
 505             }
 506             return array;
 507         }
 508     }
 509 
 510     static final class ListN&lt;E&gt; extends AbstractImmutableList&lt;E&gt;
 511             implements Serializable {
 512 










 513         @Stable
 514         private final E[] elements;
 515 
 516         @SafeVarargs
 517         ListN(E... input) {
 518             // copy and check manually to avoid TOCTOU
 519             @SuppressWarnings(&quot;unchecked&quot;)
 520             E[] tmp = (E[])new Object[input.length]; // implicit nullcheck of input
 521             for (int i = 0; i &lt; input.length; i++) {
 522                 tmp[i] = Objects.requireNonNull(input[i]);
 523             }
 524             elements = tmp;
 525         }
 526 
 527         @Override
 528         public boolean isEmpty() {
<span class="line-modified"> 529             return elements.length == 0;</span>
 530         }
 531 
 532         @Override
 533         public int size() {
 534             return elements.length;
 535         }
 536 
 537         @Override
 538         public E get(int index) {
 539             return elements[index];
 540         }
 541 
<span class="line-added"> 542         @java.io.Serial</span>
 543         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 544             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 545         }
 546 
<span class="line-added"> 547         @java.io.Serial</span>
 548         private Object writeReplace() {
 549             return new CollSer(CollSer.IMM_LIST, elements);
 550         }
 551 
 552         @Override
 553         public Object[] toArray() {
 554             return Arrays.copyOf(elements, elements.length);
 555         }
 556 
 557         @Override
 558         @SuppressWarnings(&quot;unchecked&quot;)
 559         public &lt;T&gt; T[] toArray(T[] a) {
 560             int size = elements.length;
 561             if (a.length &lt; size) {
 562                 // Make a new array of a&#39;s runtime type, but my contents:
 563                 return (T[]) Arrays.copyOf(elements, size, a.getClass());
 564             }
 565             System.arraycopy(elements, 0, a, 0, size);
 566             if (a.length &gt; size) {
 567                 a[size] = null; // null-terminate
</pre>
<hr />
<pre>
 582             } else if (!(o instanceof Set)) {
 583                 return false;
 584             }
 585 
 586             Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
 587             if (c.size() != size()) {
 588                 return false;
 589             }
 590             for (Object e : c) {
 591                 if (e == null || !contains(e)) {
 592                     return false;
 593                 }
 594             }
 595             return true;
 596         }
 597 
 598         @Override
 599         public abstract int hashCode();
 600     }
 601 





 602     static final class Set12&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 603             implements Serializable {
 604 
 605         @Stable
<span class="line-modified"> 606         private final E e0;</span>
<span class="line-added"> 607 </span>
 608         @Stable
<span class="line-modified"> 609         private final Object e1;</span>
 610 
 611         Set12(E e0) {
 612             this.e0 = Objects.requireNonNull(e0);
<span class="line-modified"> 613             // Use EMPTY as a sentinel for an unused element: not using null</span>
<span class="line-added"> 614             // enable constant folding optimizations over single-element sets</span>
<span class="line-added"> 615             this.e1 = EMPTY;</span>
 616         }
 617 
 618         Set12(E e0, E e1) {
 619             if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
 620                 throw new IllegalArgumentException(&quot;duplicate element: &quot; + e0);
 621             }
 622 
 623             this.e0 = e0;
 624             this.e1 = e1;
 625         }
 626 
 627         @Override
 628         public int size() {
<span class="line-modified"> 629             return (e1 == EMPTY) ? 1 : 2;</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         @Override</span>
<span class="line-added"> 633         public boolean isEmpty() {</span>
<span class="line-added"> 634             return false;</span>
 635         }
 636 
 637         @Override
 638         public boolean contains(Object o) {
<span class="line-modified"> 639             return o.equals(e0) || e1.equals(o); // implicit nullcheck of o</span>
 640         }
 641 
 642         @Override
 643         public int hashCode() {
<span class="line-modified"> 644             return e0.hashCode() + (e1 == EMPTY ? 0 : e1.hashCode());</span>
 645         }
 646 
 647         @Override
 648         public Iterator&lt;E&gt; iterator() {
 649             return new Iterator&lt;&gt;() {
<span class="line-modified"> 650                 private int idx = (e1 == EMPTY) ? 1 : 2;</span>
 651 
 652                 @Override
 653                 public boolean hasNext() {
 654                     return idx &gt; 0;
 655                 }
 656 
 657                 @Override
<span class="line-added"> 658                 @SuppressWarnings(&quot;unchecked&quot;)</span>
 659                 public E next() {
 660                     if (idx == 1) {
 661                         idx = 0;
<span class="line-modified"> 662                         return (REVERSE || e1 == EMPTY) ? e0 : (E)e1;</span>
 663                     } else if (idx == 2) {
 664                         idx = 1;
<span class="line-modified"> 665                         return REVERSE ? (E)e1 : e0;</span>
 666                     } else {
 667                         throw new NoSuchElementException();
 668                     }
 669                 }
 670             };
 671         }
 672 
<span class="line-added"> 673         @java.io.Serial</span>
 674         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 675             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 676         }
 677 
<span class="line-added"> 678         @java.io.Serial</span>
 679         private Object writeReplace() {
<span class="line-modified"> 680             if (e1 == EMPTY) {</span>
 681                 return new CollSer(CollSer.IMM_SET, e0);
 682             } else {
 683                 return new CollSer(CollSer.IMM_SET, e0, e1);
 684             }
 685         }
 686 
 687         @Override
 688         public Object[] toArray() {
<span class="line-modified"> 689             if (e1 == EMPTY) {</span>
 690                 return new Object[] { e0 };
<span class="line-modified"> 691             } else if (REVERSE) {</span>
 692                 return new Object[] { e1, e0 };
 693             } else {
 694                 return new Object[] { e0, e1 };
 695             }
 696         }
 697 
 698         @Override
 699         @SuppressWarnings(&quot;unchecked&quot;)
 700         public &lt;T&gt; T[] toArray(T[] a) {
<span class="line-modified"> 701             int size = size();</span>
 702             T[] array = a.length &gt;= size ? a :
 703                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 704             if (size == 1) {
 705                 array[0] = (T)e0;
<span class="line-modified"> 706             } else if (REVERSE) {</span>
 707                 array[0] = (T)e1;
 708                 array[1] = (T)e0;
 709             } else {
 710                 array[0] = (T)e0;
 711                 array[1] = (T)e1;
 712             }
 713             if (array.length &gt; size) {
 714                 array[size] = null; // null-terminate
 715             }
 716             return array;
 717         }
 718     }
 719 
 720 
 721     /**
 722      * An array-based Set implementation. The element array must be strictly
 723      * larger than the size (the number of contained elements) so that at
 724      * least one null is always present.
 725      * @param &lt;E&gt; the element type
 726      */
 727     static final class SetN&lt;E&gt; extends AbstractImmutableSet&lt;E&gt;
 728             implements Serializable {
 729 










 730         @Stable
 731         final E[] elements;
<span class="line-added"> 732 </span>
 733         @Stable
 734         final int size;
 735 
 736         @SafeVarargs
 737         @SuppressWarnings(&quot;unchecked&quot;)
 738         SetN(E... input) {
 739             size = input.length; // implicit nullcheck of input
 740 
 741             elements = (E[])new Object[EXPAND_FACTOR * input.length];
 742             for (int i = 0; i &lt; input.length; i++) {
 743                 E e = input[i];
 744                 int idx = probe(e); // implicit nullcheck of e
 745                 if (idx &gt;= 0) {
 746                     throw new IllegalArgumentException(&quot;duplicate element: &quot; + e);
 747                 } else {
 748                     elements[-(idx + 1)] = e;
 749                 }
 750             }
 751         }
 752 
 753         @Override
 754         public int size() {
 755             return size;
 756         }
 757 
<span class="line-added"> 758         @Override</span>
<span class="line-added"> 759         public boolean isEmpty() {</span>
<span class="line-added"> 760             return size == 0;</span>
<span class="line-added"> 761         }</span>
<span class="line-added"> 762 </span>
 763         @Override
 764         public boolean contains(Object o) {
 765             Objects.requireNonNull(o);
 766             return size &gt; 0 &amp;&amp; probe(o) &gt;= 0;
 767         }
 768 
 769         private final class SetNIterator implements Iterator&lt;E&gt; {
 770 
 771             private int remaining;
 772 
 773             private int idx;
 774 
 775             SetNIterator() {
<span class="line-modified"> 776                 remaining = size;</span>
<span class="line-modified"> 777                 // pick a starting index in the [0 .. element.length-1] range</span>
<span class="line-modified"> 778                 // randomly based on SALT32L</span>
<span class="line-modified"> 779                 idx = (int) ((SALT32L * elements.length) &gt;&gt;&gt; 32);</span>
 780             }
 781 
 782             @Override
 783             public boolean hasNext() {
 784                 return remaining &gt; 0;
 785             }
 786 














 787             @Override
 788             public E next() {
 789                 if (remaining &gt; 0) {
 790                     E element;
<span class="line-modified"> 791                     int idx = this.idx;</span>
<span class="line-modified"> 792                     int len = elements.length;</span>
<span class="line-added"> 793                     // step to the next element; skip null elements</span>
<span class="line-added"> 794                     do {</span>
<span class="line-added"> 795                         if (REVERSE) {</span>
<span class="line-added"> 796                             if (++idx &gt;= len) {</span>
<span class="line-added"> 797                                 idx = 0;</span>
<span class="line-added"> 798                             }</span>
<span class="line-added"> 799                         } else {</span>
<span class="line-added"> 800                             if (--idx &lt; 0) {</span>
<span class="line-added"> 801                                 idx = len - 1;</span>
<span class="line-added"> 802                             }</span>
<span class="line-added"> 803                         }</span>
<span class="line-added"> 804                     } while ((element = elements[idx]) == null);</span>
<span class="line-added"> 805                     this.idx = idx;</span>
 806                     remaining--;
 807                     return element;
 808                 } else {
 809                     throw new NoSuchElementException();
 810                 }
 811             }
 812         }
 813 
 814         @Override
 815         public Iterator&lt;E&gt; iterator() {
 816             return new SetNIterator();
 817         }
 818 
 819         @Override
 820         public int hashCode() {
 821             int h = 0;
 822             for (E e : elements) {
 823                 if (e != null) {
 824                     h += e.hashCode();
 825                 }
</pre>
<hr />
<pre>
 828         }
 829 
 830         // returns index at which element is present; or if absent,
 831         // (-i - 1) where i is location where element should be inserted.
 832         // Callers are relying on this method to perform an implicit nullcheck
 833         // of pe
 834         private int probe(Object pe) {
 835             int idx = Math.floorMod(pe.hashCode(), elements.length);
 836             while (true) {
 837                 E ee = elements[idx];
 838                 if (ee == null) {
 839                     return -idx - 1;
 840                 } else if (pe.equals(ee)) {
 841                     return idx;
 842                 } else if (++idx == elements.length) {
 843                     idx = 0;
 844                 }
 845             }
 846         }
 847 
<span class="line-added"> 848         @java.io.Serial</span>
 849         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 850             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 851         }
 852 
<span class="line-added"> 853         @java.io.Serial</span>
 854         private Object writeReplace() {
 855             Object[] array = new Object[size];
 856             int dest = 0;
 857             for (Object o : elements) {
 858                 if (o != null) {
 859                     array[dest++] = o;
 860                 }
 861             }
 862             return new CollSer(CollSer.IMM_SET, array);
 863         }
 864 
 865         @Override
 866         public Object[] toArray() {
 867             Object[] array = new Object[size];
 868             Iterator&lt;E&gt; it = iterator();
 869             for (int i = 0; i &lt; size; i++) {
 870                 array[i] = it.next();
 871             }
 872             return array;
 873         }
 874 
 875         @Override
 876         @SuppressWarnings(&quot;unchecked&quot;)
 877         public &lt;T&gt; T[] toArray(T[] a) {
 878             T[] array = a.length &gt;= size ? a :
 879                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
 880             Iterator&lt;E&gt; it = iterator();
 881             for (int i = 0; i &lt; size; i++) {
 882                 array[i] = (T)it.next();
 883             }
 884             if (array.length &gt; size) {
 885                 array[size] = null; // null-terminate
 886             }
 887             return array;
 888         }
 889     }
 890 
 891     // ---------- Map Implementations ----------
 892 





 893     abstract static class AbstractImmutableMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Serializable {
 894         @Override public void clear() { throw uoe(); }
 895         @Override public V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 896         @Override public V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mf) { throw uoe(); }
 897         @Override public V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; rf) { throw uoe(); }
 898         @Override public V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; rf) { throw uoe(); }
 899         @Override public V put(K key, V value) { throw uoe(); }
 900         @Override public void putAll(Map&lt;? extends K,? extends V&gt; m) { throw uoe(); }
 901         @Override public V putIfAbsent(K key, V value) { throw uoe(); }
 902         @Override public V remove(Object key) { throw uoe(); }
 903         @Override public boolean remove(Object key, Object value) { throw uoe(); }
 904         @Override public V replace(K key, V value) { throw uoe(); }
 905         @Override public boolean replace(K key, V oldValue, V newValue) { throw uoe(); }
 906         @Override public void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; f) { throw uoe(); }
<span class="line-added"> 907 </span>
<span class="line-added"> 908         /**</span>
<span class="line-added"> 909          * @implNote {@code null} values are disallowed in these immutable maps,</span>
<span class="line-added"> 910          * so we can improve upon the default implementation since a</span>
<span class="line-added"> 911          * {@code null} return from {@code get(key)} always means the default</span>
<span class="line-added"> 912          * value should be returned.</span>
<span class="line-added"> 913          */</span>
<span class="line-added"> 914         @Override</span>
<span class="line-added"> 915         public V getOrDefault(Object key, V defaultValue) {</span>
<span class="line-added"> 916             V v;</span>
<span class="line-added"> 917             return ((v = get(key)) != null)</span>
<span class="line-added"> 918                     ? v</span>
<span class="line-added"> 919                     : defaultValue;</span>
<span class="line-added"> 920         }</span>
 921     }
 922 
 923     static final class Map1&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 924         @Stable
 925         private final K k0;
 926         @Stable
 927         private final V v0;
 928 
 929         Map1(K k0, V v0) {
 930             this.k0 = Objects.requireNonNull(k0);
 931             this.v0 = Objects.requireNonNull(v0);
 932         }
 933 
 934         @Override
 935         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
 936             return Set.of(new KeyValueHolder&lt;&gt;(k0, v0));
 937         }
 938 
<span class="line-added"> 939         @Override</span>
<span class="line-added"> 940         public V get(Object o) {</span>
<span class="line-added"> 941             return o.equals(k0) ? v0 : null; // implicit nullcheck of o</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943 </span>
 944         @Override
 945         public boolean containsKey(Object o) {
 946             return o.equals(k0); // implicit nullcheck of o
 947         }
 948 
 949         @Override
 950         public boolean containsValue(Object o) {
 951             return o.equals(v0); // implicit nullcheck of o
 952         }
 953 
<span class="line-added"> 954         @Override</span>
<span class="line-added"> 955         public int size() {</span>
<span class="line-added"> 956             return 1;</span>
<span class="line-added"> 957         }</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959         @Override</span>
<span class="line-added"> 960         public boolean isEmpty() {</span>
<span class="line-added"> 961             return false;</span>
<span class="line-added"> 962         }</span>
<span class="line-added"> 963 </span>
<span class="line-added"> 964         @java.io.Serial</span>
 965         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
 966             throw new InvalidObjectException(&quot;not serial proxy&quot;);
 967         }
 968 
<span class="line-added"> 969         @java.io.Serial</span>
 970         private Object writeReplace() {
 971             return new CollSer(CollSer.IMM_MAP, k0, v0);
 972         }
 973 
 974         @Override
 975         public int hashCode() {
 976             return k0.hashCode() ^ v0.hashCode();
 977         }
 978     }
 979 
 980     /**
 981      * An array-based Map implementation. There is a single array &quot;table&quot; that
 982      * contains keys and values interleaved: table[0] is kA, table[1] is vA,
 983      * table[2] is kB, table[3] is vB, etc. The table size must be even. It must
 984      * also be strictly larger than the size (the number of key-value pairs contained
 985      * in the map) so that at least one null key is always present.
 986      * @param &lt;K&gt; the key type
 987      * @param &lt;V&gt; the value type
 988      */
 989     static final class MapN&lt;K,V&gt; extends AbstractImmutableMap&lt;K,V&gt; {
 990 










 991         @Stable
 992         final Object[] table; // pairs of key, value
 993 
 994         @Stable
 995         final int size; // number of pairs
 996 
 997         MapN(Object... input) {
 998             if ((input.length &amp; 1) != 0) { // implicit nullcheck of input
 999                 throw new InternalError(&quot;length is odd&quot;);
1000             }
1001             size = input.length &gt;&gt; 1;
1002 
1003             int len = EXPAND_FACTOR * input.length;
1004             len = (len + 1) &amp; ~1; // ensure table is even length
1005             table = new Object[len];
1006 
1007             for (int i = 0; i &lt; input.length; i += 2) {
1008                 @SuppressWarnings(&quot;unchecked&quot;)
1009                     K k = Objects.requireNonNull((K)input[i]);
1010                 @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
1053         @Override
1054         @SuppressWarnings(&quot;unchecked&quot;)
1055         public V get(Object o) {
1056             if (size == 0) {
1057                 Objects.requireNonNull(o);
1058                 return null;
1059             }
1060             int i = probe(o);
1061             if (i &gt;= 0) {
1062                 return (V)table[i+1];
1063             } else {
1064                 return null;
1065             }
1066         }
1067 
1068         @Override
1069         public int size() {
1070             return size;
1071         }
1072 
<span class="line-added">1073         @Override</span>
<span class="line-added">1074         public boolean isEmpty() {</span>
<span class="line-added">1075             return size == 0;</span>
<span class="line-added">1076         }</span>
<span class="line-added">1077 </span>
1078         class MapNIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1079 
1080             private int remaining;
1081 
1082             private int idx;
1083 
1084             MapNIterator() {
<span class="line-modified">1085                 remaining = size;</span>
<span class="line-modified">1086                 // pick an even starting index in the [0 .. table.length-1]</span>
<span class="line-modified">1087                 // range randomly based on SALT32L</span>
<span class="line-modified">1088                 idx = (int) ((SALT32L * (table.length &gt;&gt; 1)) &gt;&gt;&gt; 32) &lt;&lt; 1;</span>
1089             }
1090 
1091             @Override
1092             public boolean hasNext() {
1093                 return remaining &gt; 0;
1094             }
1095 
1096             private int nextIndex() {
1097                 int idx = this.idx;
<span class="line-modified">1098                 if (REVERSE) {</span>
1099                     if ((idx += 2) &gt;= table.length) {
1100                         idx = 0;
1101                     }
1102                 } else {
1103                     if ((idx -= 2) &lt; 0) {
1104                         idx = table.length - 2;
1105                     }
1106                 }
1107                 return this.idx = idx;
1108             }
1109 
1110             @Override
1111             public Map.Entry&lt;K,V&gt; next() {
1112                 if (remaining &gt; 0) {
1113                     int idx;
1114                     while (table[idx = nextIndex()] == null) {}
1115                     @SuppressWarnings(&quot;unchecked&quot;)
1116                     Map.Entry&lt;K,V&gt; e =
1117                             new KeyValueHolder&lt;&gt;((K)table[idx], (V)table[idx+1]);
1118                     remaining--;
</pre>
<hr />
<pre>
1140 
1141         // returns index at which the probe key is present; or if absent,
1142         // (-i - 1) where i is location where element should be inserted.
1143         // Callers are relying on this method to perform an implicit nullcheck
1144         // of pk.
1145         private int probe(Object pk) {
1146             int idx = Math.floorMod(pk.hashCode(), table.length &gt;&gt; 1) &lt;&lt; 1;
1147             while (true) {
1148                 @SuppressWarnings(&quot;unchecked&quot;)
1149                 K ek = (K)table[idx];
1150                 if (ek == null) {
1151                     return -idx - 1;
1152                 } else if (pk.equals(ek)) {
1153                     return idx;
1154                 } else if ((idx += 2) == table.length) {
1155                     idx = 0;
1156                 }
1157             }
1158         }
1159 
<span class="line-added">1160         @java.io.Serial</span>
1161         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1162             throw new InvalidObjectException(&quot;not serial proxy&quot;);
1163         }
1164 
<span class="line-added">1165         @java.io.Serial</span>
1166         private Object writeReplace() {
1167             Object[] array = new Object[2 * size];
1168             int len = table.length;
1169             int dest = 0;
1170             for (int i = 0; i &lt; len; i += 2) {
1171                 if (table[i] != null) {
1172                     array[dest++] = table[i];
1173                     array[dest++] = table[i+1];
1174                 }
1175             }
1176             return new CollSer(CollSer.IMM_MAP, array);
1177         }
1178     }
1179 }
1180 
1181 // ---------- Serialization Proxy ----------
1182 
1183 /**
1184  * A unified serialization proxy class for the immutable collections.
1185  *
1186  * @serial
1187  * @since 9
1188  */
1189 final class CollSer implements Serializable {
<span class="line-added">1190     @java.io.Serial</span>
1191     private static final long serialVersionUID = 6309168927139932177L;
1192 
1193     static final int IMM_LIST = 1;
1194     static final int IMM_SET = 2;
1195     static final int IMM_MAP = 3;
1196 
1197     /**
1198      * Indicates the type of collection that is serialized.
1199      * The low order 8 bits have the value 1 for an immutable
1200      * {@code List}, 2 for an immutable {@code Set}, and 3 for
1201      * an immutable {@code Map}. Any other value causes an
1202      * {@link InvalidObjectException} to be thrown. The high
1203      * order 24 bits are zero when an instance is serialized,
1204      * and they are ignored when an instance is deserialized.
1205      * They can thus be used by future implementations without
1206      * causing compatibility issues.
1207      *
1208      * &lt;p&gt;The tag value also determines the interpretation of the
1209      * transient {@code Object[] array} field.
1210      * For {@code List} and {@code Set}, the array&#39;s length is the size
</pre>
<hr />
<pre>
1231 
1232     CollSer(int t, Object... a) {
1233         tag = t;
1234         array = a;
1235     }
1236 
1237     /**
1238      * Reads objects from the stream and stores them
1239      * in the transient {@code Object[] array} field.
1240      *
1241      * @serialData
1242      * A nonnegative int, indicating the count of objects,
1243      * followed by that many objects.
1244      *
1245      * @param ois the ObjectInputStream from which data is read
1246      * @throws IOException if an I/O error occurs
1247      * @throws ClassNotFoundException if a serialized class cannot be loaded
1248      * @throws InvalidObjectException if the count is negative
1249      * @since 9
1250      */
<span class="line-added">1251     @java.io.Serial</span>
1252     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
1253         ois.defaultReadObject();
1254         int len = ois.readInt();
1255 
1256         if (len &lt; 0) {
1257             throw new InvalidObjectException(&quot;negative length &quot; + len);
1258         }
1259 
1260         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, len);
1261         Object[] a = new Object[len];
1262         for (int i = 0; i &lt; len; i++) {
1263             a[i] = ois.readObject();
1264         }
1265 
1266         array = a;
1267     }
1268 
1269     /**
1270      * Writes objects to the stream from
1271      * the transient {@code Object[] array} field.
1272      *
1273      * @serialData
1274      * A nonnegative int, indicating the count of objects,
1275      * followed by that many objects.
1276      *
1277      * @param oos the ObjectOutputStream to which data is written
1278      * @throws IOException if an I/O error occurs
1279      * @since 9
1280      */
<span class="line-added">1281     @java.io.Serial</span>
1282     private void writeObject(ObjectOutputStream oos) throws IOException {
1283         oos.defaultWriteObject();
1284         oos.writeInt(array.length);
1285         for (int i = 0; i &lt; array.length; i++) {
1286             oos.writeObject(array[i]);
1287         }
1288     }
1289 
1290     /**
1291      * Creates and returns an immutable collection from this proxy class.
1292      * The instance returned is created as if by calling one of the
1293      * static factory methods for
1294      * &lt;a href=&quot;List.html#unmodifiable&quot;&gt;List&lt;/a&gt;,
1295      * &lt;a href=&quot;Map.html#unmodifiable&quot;&gt;Map&lt;/a&gt;, or
1296      * &lt;a href=&quot;Set.html#unmodifiable&quot;&gt;Set&lt;/a&gt;.
1297      * This proxy class is the serial form for all immutable collection instances,
1298      * regardless of implementation type. This is necessary to ensure that the
1299      * existence of any particular implementation type is kept out of the
1300      * serialized form.
1301      *
1302      * @return a collection created from this proxy object
1303      * @throws InvalidObjectException if the tag value is illegal or if an exception
1304      *         is thrown during creation of the collection
1305      * @throws ObjectStreamException if another serialization error has occurred
1306      * @since 9
1307      */
<span class="line-added">1308    @java.io.Serial</span>
1309     private Object readResolve() throws ObjectStreamException {
1310         try {
1311             if (array == null) {
1312                 throw new InvalidObjectException(&quot;null array&quot;);
1313             }
1314 
1315             // use low order 8 bits to indicate &quot;kind&quot;
1316             // ignore high order 24 bits
1317             switch (tag &amp; 0xff) {
1318                 case IMM_LIST:
1319                     return List.of(array);
1320                 case IMM_SET:
1321                     return Set.of(array);
1322                 case IMM_MAP:
1323                     if (array.length == 0) {
<span class="line-modified">1324                         return ImmutableCollections.EMPTY_MAP;</span>
1325                     } else if (array.length == 2) {
1326                         return new ImmutableCollections.Map1&lt;&gt;(array[0], array[1]);
1327                     } else {
1328                         return new ImmutableCollections.MapN&lt;&gt;(array);
1329                     }
1330                 default:
1331                     throw new InvalidObjectException(String.format(&quot;invalid flags 0x%x&quot;, tag));
1332             }
1333         } catch (NullPointerException|IllegalArgumentException ex) {
1334             InvalidObjectException ioe = new InvalidObjectException(&quot;invalid object&quot;);
1335             ioe.initCause(ex);
1336             throw ioe;
1337         }
1338     }
1339 }
</pre>
</td>
</tr>
</table>
<center><a href="IllformedLocaleException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InputMismatchException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
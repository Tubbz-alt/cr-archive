<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/Socket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/Socket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 


  28 import java.io.InputStream;
  29 import java.io.OutputStream;
  30 import java.io.IOException;


  31 import java.nio.channels.SocketChannel;
  32 import java.security.AccessController;
<span class="line-removed">  33 import java.security.PrivilegedExceptionAction;</span>
  34 import java.security.PrivilegedAction;

  35 import java.util.Set;
  36 import java.util.Collections;
  37 
  38 /**
  39  * This class implements client sockets (also called just
  40  * &quot;sockets&quot;). A socket is an endpoint for communication
  41  * between two machines.
  42  * &lt;p&gt;
  43  * The actual work of the socket is performed by an instance of the
  44  * {@code SocketImpl} class. An application, by changing
  45  * the socket factory that creates the socket implementation,
  46  * can configure itself to create sockets appropriate to the local
  47  * firewall.
  48  *














































  49  * @author  unascribed
  50  * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
  51  * @see     java.net.SocketImpl
  52  * @see     java.nio.channels.SocketChannel
  53  * @since   1.0
  54  */
<span class="line-modified">  55 public</span>
<span class="line-removed">  56 class Socket implements java.io.Closeable {</span>
  57     /**
  58      * Various states of this socket.
  59      */
  60     private boolean created = false;
  61     private boolean bound = false;
  62     private boolean connected = false;
  63     private boolean closed = false;
  64     private Object closeLock = new Object();
  65     private boolean shutIn = false;
  66     private boolean shutOut = false;
  67 
  68     /**
  69      * The implementation of this Socket.
  70      */
  71     SocketImpl impl;
  72 
  73     /**
<span class="line-modified">  74      * Are we using an older SocketImpl?</span>
  75      */
<span class="line-modified">  76     private boolean oldImpl = false;</span>











  77 
  78     /**
<span class="line-modified">  79      * Creates an unconnected socket, with the</span>
<span class="line-modified">  80      * system-default type of SocketImpl.</span>




  81      *
  82      * @since   1.1
  83      * @revised 1.4
  84      */
  85     public Socket() {
  86         setImpl();
  87     }
  88 
  89     /**
  90      * Creates an unconnected socket, specifying the type of proxy, if any,
  91      * that should be used regardless of any other settings.
  92      * &lt;P&gt;
  93      * If there is a security manager, its {@code checkConnect} method
  94      * is called with the proxy host address and port number
  95      * as its arguments. This could result in a SecurityException.
  96      * &lt;P&gt;
  97      * Examples:
  98      * &lt;UL&gt; &lt;LI&gt;{@code Socket s = new Socket(Proxy.NO_PROXY);} will create
  99      * a plain socket ignoring any other proxy configuration.&lt;/LI&gt;
 100      * &lt;LI&gt;{@code Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;socks.mydom.com&quot;, 1080)));}
</pre>
<hr />
<pre>
 120             throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
 121         }
 122         Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY
 123                                           : sun.net.ApplicationProxy.create(proxy);
 124         Proxy.Type type = p.type();
 125         if (type == Proxy.Type.SOCKS || type == Proxy.Type.HTTP) {
 126             SecurityManager security = System.getSecurityManager();
 127             InetSocketAddress epoint = (InetSocketAddress) p.address();
 128             if (epoint.getAddress() != null) {
 129                 checkAddress (epoint.getAddress(), &quot;Socket&quot;);
 130             }
 131             if (security != null) {
 132                 if (epoint.isUnresolved())
 133                     epoint = new InetSocketAddress(epoint.getHostName(), epoint.getPort());
 134                 if (epoint.isUnresolved())
 135                     security.checkConnect(epoint.getHostName(), epoint.getPort());
 136                 else
 137                     security.checkConnect(epoint.getAddress().getHostAddress(),
 138                                   epoint.getPort());
 139             }
<span class="line-modified"> 140             impl = type == Proxy.Type.SOCKS ? new SocksSocketImpl(p)</span>
<span class="line-modified"> 141                                             : new HttpConnectSocketImpl(p);</span>
<span class="line-modified"> 142             impl.setSocket(this);</span>


 143         } else {
 144             if (p == Proxy.NO_PROXY) {


 145                 if (factory == null) {
<span class="line-modified"> 146                     impl = new PlainSocketImpl();</span>
<span class="line-modified"> 147                     impl.setSocket(this);</span>
<span class="line-modified"> 148                 } else</span>
<span class="line-modified"> 149                     setImpl();</span>
 150             } else
 151                 throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
 152         }
 153     }
 154 
 155     /**
 156      * Creates an unconnected Socket with a user-specified
 157      * SocketImpl.
 158      *
 159      * @param impl an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
 160      * the subclass wishes to use on the Socket.
 161      *
<span class="line-modified"> 162      * @exception SocketException if there is an error in the underlying protocol,</span>
 163      * such as a TCP error.




 164      * @since   1.1
 165      */
 166     protected Socket(SocketImpl impl) throws SocketException {

 167         this.impl = impl;
<span class="line-modified"> 168         if (impl != null) {</span>
<span class="line-modified"> 169             checkOldImpl();</span>
<span class="line-modified"> 170             this.impl.setSocket(this);</span>






 171         }

 172     }
 173 
 174     /**
 175      * Creates a stream socket and connects it to the specified port
 176      * number on the named host.
 177      * &lt;p&gt;
 178      * If the specified host is {@code null} it is the equivalent of
 179      * specifying the address as
 180      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 181      * In other words, it is equivalent to specifying an address of the
 182      * loopback interface. &lt;/p&gt;
 183      * &lt;p&gt;
<span class="line-modified"> 184      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 185      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 186      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 187      * &lt;p&gt;
 188      * If there is a security manager, its
 189      * {@code checkConnect} method is called
 190      * with the host address and {@code port}
 191      * as its arguments. This could result in a SecurityException.
 192      *
 193      * @param      host   the host name, or {@code null} for the loopback address.
 194      * @param      port   the port number.
 195      *
<span class="line-modified"> 196      * @exception  UnknownHostException if the IP address of</span>
 197      * the host could not be determined.
 198      *
<span class="line-modified"> 199      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 200      * @exception  SecurityException  if a security manager exists and its</span>
 201      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 202      * @exception  IllegalArgumentException if the port parameter is outside</span>
 203      *             the specified range of valid port values, which is between
 204      *             0 and 65535, inclusive.
 205      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 206      * @see        java.net.SocketImpl
 207      * @see        java.net.SocketImplFactory#createSocketImpl()
 208      * @see        SecurityManager#checkConnect
 209      */
 210     public Socket(String host, int port)
 211         throws UnknownHostException, IOException
 212     {
 213         this(host != null ? new InetSocketAddress(host, port) :
 214              new InetSocketAddress(InetAddress.getByName(null), port),
 215              (SocketAddress) null, true);
 216     }
 217 
 218     /**
 219      * Creates a stream socket and connects it to the specified port
 220      * number at the specified IP address.
 221      * &lt;p&gt;
<span class="line-modified"> 222      * If the application has specified a socket factory, that factory&#39;s</span>
<span class="line-modified"> 223      * {@code createSocketImpl} method is called to create the</span>
<span class="line-modified"> 224      * actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 225      * &lt;p&gt;
 226      * If there is a security manager, its
 227      * {@code checkConnect} method is called
 228      * with the host address and {@code port}
 229      * as its arguments. This could result in a SecurityException.
 230      *
 231      * @param      address   the IP address.
 232      * @param      port      the port number.
<span class="line-modified"> 233      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 234      * @exception  SecurityException  if a security manager exists and its</span>
 235      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 236      * @exception  IllegalArgumentException if the port parameter is outside</span>
 237      *             the specified range of valid port values, which is between
 238      *             0 and 65535, inclusive.
<span class="line-modified"> 239      * @exception  NullPointerException if {@code address} is null.</span>
 240      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 241      * @see        java.net.SocketImpl
 242      * @see        java.net.SocketImplFactory#createSocketImpl()
 243      * @see        SecurityManager#checkConnect
 244      */
 245     public Socket(InetAddress address, int port) throws IOException {
 246         this(address != null ? new InetSocketAddress(address, port) : null,
 247              (SocketAddress) null, true);
 248     }
 249 
 250     /**
 251      * Creates a socket and connects it to the specified remote host on
 252      * the specified remote port. The Socket will also bind() to the local
 253      * address and port supplied.
 254      * &lt;p&gt;
 255      * If the specified host is {@code null} it is the equivalent of
 256      * specifying the address as
 257      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 258      * In other words, it is equivalent to specifying an address of the
 259      * loopback interface. &lt;/p&gt;
 260      * &lt;p&gt;
 261      * A local port number of {@code zero} will let the system pick up a
 262      * free port in the {@code bind} operation.&lt;/p&gt;
 263      * &lt;p&gt;
 264      * If there is a security manager, its
 265      * {@code checkConnect} method is called
 266      * with the host address and {@code port}
 267      * as its arguments. This could result in a SecurityException.
 268      *
 269      * @param host the name of the remote host, or {@code null} for the loopback address.
 270      * @param port the remote port
 271      * @param localAddr the local address the socket is bound to, or
 272      *        {@code null} for the {@code anyLocal} address.
 273      * @param localPort the local port the socket is bound to, or
 274      *        {@code zero} for a system selected free port.
<span class="line-modified"> 275      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 276      * @exception  SecurityException  if a security manager exists and its</span>
 277      *             {@code checkConnect} method doesn&#39;t allow the connection
 278      *             to the destination, or if its {@code checkListen} method
 279      *             doesn&#39;t allow the bind to the local port.
<span class="line-modified"> 280      * @exception  IllegalArgumentException if the port parameter or localPort</span>
 281      *             parameter is outside the specified range of valid port values,
 282      *             which is between 0 and 65535, inclusive.
 283      * @see        SecurityManager#checkConnect
 284      * @since   1.1
 285      */
 286     public Socket(String host, int port, InetAddress localAddr,
 287                   int localPort) throws IOException {
 288         this(host != null ? new InetSocketAddress(host, port) :
 289                new InetSocketAddress(InetAddress.getByName(null), port),
 290              new InetSocketAddress(localAddr, localPort), true);
 291     }
 292 
 293     /**
 294      * Creates a socket and connects it to the specified remote address on
 295      * the specified remote port. The Socket will also bind() to the local
 296      * address and port supplied.
 297      * &lt;p&gt;
 298      * If the specified local address is {@code null} it is the equivalent of
 299      * specifying the address as the AnyLocal address
 300      * (see {@link java.net.InetAddress#isAnyLocalAddress InetAddress.isAnyLocalAddress}{@code ()}).
 301      * &lt;p&gt;
 302      * A local port number of {@code zero} will let the system pick up a
 303      * free port in the {@code bind} operation.&lt;/p&gt;
 304      * &lt;p&gt;
 305      * If there is a security manager, its
 306      * {@code checkConnect} method is called
 307      * with the host address and {@code port}
 308      * as its arguments. This could result in a SecurityException.
 309      *
 310      * @param address the remote address
 311      * @param port the remote port
 312      * @param localAddr the local address the socket is bound to, or
 313      *        {@code null} for the {@code anyLocal} address.
 314      * @param localPort the local port the socket is bound to or
 315      *        {@code zero} for a system selected free port.
<span class="line-modified"> 316      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 317      * @exception  SecurityException  if a security manager exists and its</span>
 318      *             {@code checkConnect} method doesn&#39;t allow the connection
 319      *             to the destination, or if its {@code checkListen} method
 320      *             doesn&#39;t allow the bind to the local port.
<span class="line-modified"> 321      * @exception  IllegalArgumentException if the port parameter or localPort</span>
 322      *             parameter is outside the specified range of valid port values,
 323      *             which is between 0 and 65535, inclusive.
<span class="line-modified"> 324      * @exception  NullPointerException if {@code address} is null.</span>
 325      * @see        SecurityManager#checkConnect
 326      * @since   1.1
 327      */
 328     public Socket(InetAddress address, int port, InetAddress localAddr,
 329                   int localPort) throws IOException {
 330         this(address != null ? new InetSocketAddress(address, port) : null,
 331              new InetSocketAddress(localAddr, localPort), true);
 332     }
 333 
 334     /**
 335      * Creates a stream socket and connects it to the specified port
 336      * number on the named host.
 337      * &lt;p&gt;
 338      * If the specified host is {@code null} it is the equivalent of
 339      * specifying the address as
 340      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 341      * In other words, it is equivalent to specifying an address of the
 342      * loopback interface. &lt;/p&gt;
 343      * &lt;p&gt;
 344      * If the stream argument is {@code true}, this creates a
 345      * stream socket. If the stream argument is {@code false}, it
 346      * creates a datagram socket.
 347      * &lt;p&gt;
<span class="line-modified"> 348      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 349      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 350      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 351      * &lt;p&gt;
 352      * If there is a security manager, its
 353      * {@code checkConnect} method is called
 354      * with the host address and {@code port}
 355      * as its arguments. This could result in a SecurityException.
 356      * &lt;p&gt;
 357      * If a UDP socket is used, TCP/IP related socket options will not apply.
 358      *
 359      * @param      host     the host name, or {@code null} for the loopback address.
 360      * @param      port     the port number.
 361      * @param      stream   a {@code boolean} indicating whether this is
 362      *                      a stream socket or a datagram socket.
<span class="line-modified"> 363      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 364      * @exception  SecurityException  if a security manager exists and its</span>
 365      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 366      * @exception  IllegalArgumentException if the port parameter is outside</span>
 367      *             the specified range of valid port values, which is between
 368      *             0 and 65535, inclusive.
 369      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 370      * @see        java.net.SocketImpl
 371      * @see        java.net.SocketImplFactory#createSocketImpl()
 372      * @see        SecurityManager#checkConnect
 373      * @deprecated Use DatagramSocket instead for UDP transport.
 374      */
 375     @Deprecated
 376     public Socket(String host, int port, boolean stream) throws IOException {
 377         this(host != null ? new InetSocketAddress(host, port) :
 378                new InetSocketAddress(InetAddress.getByName(null), port),
 379              (SocketAddress) null, stream);
 380     }
 381 
 382     /**
 383      * Creates a socket and connects it to the specified port number at
 384      * the specified IP address.
 385      * &lt;p&gt;
 386      * If the stream argument is {@code true}, this creates a
 387      * stream socket. If the stream argument is {@code false}, it
 388      * creates a datagram socket.
 389      * &lt;p&gt;
<span class="line-modified"> 390      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 391      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 392      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 393      *
 394      * &lt;p&gt;If there is a security manager, its
 395      * {@code checkConnect} method is called
 396      * with {@code host.getHostAddress()} and {@code port}
 397      * as its arguments. This could result in a SecurityException.
 398      * &lt;p&gt;
 399      * If UDP socket is used, TCP/IP related socket options will not apply.
 400      *
 401      * @param      host     the IP address.
 402      * @param      port      the port number.
 403      * @param      stream    if {@code true}, create a stream socket;
 404      *                       otherwise, create a datagram socket.
<span class="line-modified"> 405      * @exception  IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 406      * @exception  SecurityException  if a security manager exists and its</span>
 407      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 408      * @exception  IllegalArgumentException if the port parameter is outside</span>
 409      *             the specified range of valid port values, which is between
 410      *             0 and 65535, inclusive.
<span class="line-modified"> 411      * @exception  NullPointerException if {@code host} is null.</span>
 412      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 413      * @see        java.net.SocketImpl
 414      * @see        java.net.SocketImplFactory#createSocketImpl()
 415      * @see        SecurityManager#checkConnect
 416      * @deprecated Use DatagramSocket instead for UDP transport.
 417      */
 418     @Deprecated
 419     public Socket(InetAddress host, int port, boolean stream) throws IOException {
 420         this(host != null ? new InetSocketAddress(host, port) : null,
 421              new InetSocketAddress(0), stream);
 422     }
 423 
 424     private Socket(SocketAddress address, SocketAddress localAddr,
 425                    boolean stream) throws IOException {
 426         setImpl();
 427 
 428         // backward compatibility
 429         if (address == null)
 430             throw new NullPointerException();
 431 
</pre>
<hr />
<pre>
 446 
 447     /**
 448      * Creates the socket implementation.
 449      *
 450      * @param stream a {@code boolean} value : {@code true} for a TCP socket,
 451      *               {@code false} for UDP.
 452      * @throws IOException if creation fails
 453      * @since 1.4
 454      */
 455      void createImpl(boolean stream) throws SocketException {
 456         if (impl == null)
 457             setImpl();
 458         try {
 459             impl.create(stream);
 460             created = true;
 461         } catch (IOException e) {
 462             throw new SocketException(e.getMessage());
 463         }
 464     }
 465 
<span class="line-modified"> 466     private void checkOldImpl() {</span>
<span class="line-modified"> 467         if (impl == null)</span>
<span class="line-removed"> 468             return;</span>
<span class="line-removed"> 469         // SocketImpl.connect() is a protected method, therefore we need to use</span>
<span class="line-removed"> 470         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed"> 471 </span>
<span class="line-removed"> 472         oldImpl = AccessController.doPrivileged</span>
<span class="line-removed"> 473                                 (new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed"> 474             public Boolean run() {</span>
<span class="line-removed"> 475                 Class&lt;?&gt; clazz = impl.getClass();</span>
<span class="line-removed"> 476                 while (true) {</span>
<span class="line-removed"> 477                     try {</span>
<span class="line-removed"> 478                         clazz.getDeclaredMethod(&quot;connect&quot;, SocketAddress.class, int.class);</span>
<span class="line-removed"> 479                         return Boolean.FALSE;</span>
<span class="line-removed"> 480                     } catch (NoSuchMethodException e) {</span>
<span class="line-removed"> 481                         clazz = clazz.getSuperclass();</span>
<span class="line-removed"> 482                         // java.net.SocketImpl class will always have this abstract method.</span>
<span class="line-removed"> 483                         // If we have not found it by now in the hierarchy then it does not</span>
<span class="line-removed"> 484                         // exist, we are an old style impl.</span>
<span class="line-removed"> 485                         if (clazz.equals(java.net.SocketImpl.class)) {</span>
<span class="line-removed"> 486                             return Boolean.TRUE;</span>
<span class="line-removed"> 487                         }</span>
<span class="line-removed"> 488                     }</span>
<span class="line-removed"> 489                 }</span>
<span class="line-removed"> 490             }</span>
<span class="line-removed"> 491         });</span>
 492     }
 493 
 494     /**
 495      * Sets impl to the system-default type of SocketImpl.
 496      * @since 1.4
 497      */
 498     void setImpl() {

 499         if (factory != null) {
 500             impl = factory.createSocketImpl();
<span class="line-removed"> 501             checkOldImpl();</span>
 502         } else {
<span class="line-modified"> 503             // No need to do a checkOldImpl() here, we know it&#39;s an up to date</span>
<span class="line-modified"> 504             // SocketImpl!</span>
<span class="line-modified"> 505             impl = new SocksSocketImpl();</span>
 506         }
<span class="line-removed"> 507         if (impl != null)</span>
<span class="line-removed"> 508             impl.setSocket(this);</span>
 509     }
 510 
<span class="line-removed"> 511 </span>
 512     /**
 513      * Get the {@code SocketImpl} attached to this socket, creating
 514      * it if necessary.
 515      *
 516      * @return  the {@code SocketImpl} attached to that ServerSocket.
 517      * @throws SocketException if creation fails
 518      * @since 1.4
 519      */
 520     SocketImpl getImpl() throws SocketException {
 521         if (!created)
 522             createImpl(true);
 523         return impl;
 524     }
 525 
 526     /**
 527      * Connects this socket to the server.
 528      *
 529      * @param   endpoint the {@code SocketAddress}
 530      * @throws  IOException if an error occurs during the connection
 531      * @throws  java.nio.channels.IllegalBlockingModeException
</pre>
<hr />
<pre>
 536      * @since 1.4
 537      * @spec JSR-51
 538      */
 539     public void connect(SocketAddress endpoint) throws IOException {
 540         connect(endpoint, 0);
 541     }
 542 
 543     /**
 544      * Connects this socket to the server with a specified timeout value.
 545      * A timeout of zero is interpreted as an infinite timeout. The connection
 546      * will then block until established or an error occurs.
 547      *
 548      * @param   endpoint the {@code SocketAddress}
 549      * @param   timeout  the timeout value to be used in milliseconds.
 550      * @throws  IOException if an error occurs during the connection
 551      * @throws  SocketTimeoutException if timeout expires before connecting
 552      * @throws  java.nio.channels.IllegalBlockingModeException
 553      *          if this socket has an associated channel,
 554      *          and the channel is in non-blocking mode
 555      * @throws  IllegalArgumentException if endpoint is null or is a
<span class="line-modified"> 556      *          SocketAddress subclass not supported by this socket</span>

 557      * @since 1.4
 558      * @spec JSR-51
 559      */
 560     public void connect(SocketAddress endpoint, int timeout) throws IOException {
 561         if (endpoint == null)
 562             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 563 
 564         if (timeout &lt; 0)
 565           throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
 566 
 567         if (isClosed())
 568             throw new SocketException(&quot;Socket is closed&quot;);
 569 
<span class="line-modified"> 570         if (!oldImpl &amp;&amp; isConnected())</span>
 571             throw new SocketException(&quot;already connected&quot;);
 572 
 573         if (!(endpoint instanceof InetSocketAddress))
 574             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 575 
 576         InetSocketAddress epoint = (InetSocketAddress) endpoint;
 577         InetAddress addr = epoint.getAddress ();
 578         int port = epoint.getPort();
 579         checkAddress(addr, &quot;connect&quot;);
 580 
 581         SecurityManager security = System.getSecurityManager();
 582         if (security != null) {
 583             if (epoint.isUnresolved())
 584                 security.checkConnect(epoint.getHostName(), port);
 585             else
 586                 security.checkConnect(addr.getHostAddress(), port);
 587         }
 588         if (!created)
 589             createImpl(true);
<span class="line-modified"> 590         if (!oldImpl)</span>
<span class="line-removed"> 591             impl.connect(epoint, timeout);</span>
<span class="line-removed"> 592         else if (timeout == 0) {</span>
<span class="line-removed"> 593             if (epoint.isUnresolved())</span>
<span class="line-removed"> 594                 impl.connect(addr.getHostName(), port);</span>
<span class="line-removed"> 595             else</span>
<span class="line-removed"> 596                 impl.connect(addr, port);</span>
<span class="line-removed"> 597         } else</span>
<span class="line-removed"> 598             throw new UnsupportedOperationException(&quot;SocketImpl.connect(addr, timeout)&quot;);</span>
 599         connected = true;
 600         /*
 601          * If the socket was not bound before the connect, it is now because
 602          * the kernel will have picked an ephemeral port &amp; a local address
 603          */
 604         bound = true;
 605     }
 606 
 607     /**
 608      * Binds the socket to a local address.
 609      * &lt;P&gt;
 610      * If the address is {@code null}, then the system will pick up
 611      * an ephemeral port and a valid local address to bind the socket.
 612      *
 613      * @param   bindpoint the {@code SocketAddress} to bind to
 614      * @throws  IOException if the bind operation fails, or if the socket
 615      *                     is already bound.
 616      * @throws  IllegalArgumentException if bindpoint is a
 617      *          SocketAddress subclass not supported by this socket
 618      * @throws  SecurityException  if a security manager exists and its
 619      *          {@code checkListen} method doesn&#39;t allow the bind
 620      *          to the local port.
 621      *
 622      * @since   1.4
 623      * @see #isBound
 624      */
 625     public void bind(SocketAddress bindpoint) throws IOException {
 626         if (isClosed())
 627             throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified"> 628         if (!oldImpl &amp;&amp; isBound())</span>
 629             throw new SocketException(&quot;Already bound&quot;);
 630 
 631         if (bindpoint != null &amp;&amp; (!(bindpoint instanceof InetSocketAddress)))
 632             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 633         InetSocketAddress epoint = (InetSocketAddress) bindpoint;
 634         if (epoint != null &amp;&amp; epoint.isUnresolved())
 635             throw new SocketException(&quot;Unresolved address&quot;);
 636         if (epoint == null) {
 637             epoint = new InetSocketAddress(0);
 638         }
 639         InetAddress addr = epoint.getAddress();
 640         int port = epoint.getPort();
 641         checkAddress (addr, &quot;bind&quot;);
 642         SecurityManager security = System.getSecurityManager();
 643         if (security != null) {
 644             security.checkListen(port);
 645         }
 646         getImpl().bind (addr, port);
 647         bound = true;
 648     }
 649 
 650     private void checkAddress (InetAddress addr, String op) {
 651         if (addr == null) {
 652             return;
 653         }
 654         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
 655             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);
 656         }
 657     }
 658 
 659     /**
 660      * set the flags after an accept() call.
 661      */
 662     final void postAccept() {
 663         connected = true;
 664         created = true;
 665         bound = true;
 666     }
 667 
<span class="line-removed"> 668     void setCreated() {</span>
<span class="line-removed"> 669         created = true;</span>
<span class="line-removed"> 670     }</span>
<span class="line-removed"> 671 </span>
<span class="line-removed"> 672     void setBound() {</span>
<span class="line-removed"> 673         bound = true;</span>
<span class="line-removed"> 674     }</span>
<span class="line-removed"> 675 </span>
<span class="line-removed"> 676     void setConnected() {</span>
<span class="line-removed"> 677         connected = true;</span>
<span class="line-removed"> 678     }</span>
<span class="line-removed"> 679 </span>
 680     /**
 681      * Returns the address to which the socket is connected.
 682      * &lt;p&gt;
 683      * If the socket was connected prior to being {@link #close closed},
 684      * then this method will continue to return the connected address
 685      * after the socket is closed.
 686      *
 687      * @return  the remote IP address to which this socket is connected,
 688      *          or {@code null} if the socket is not connected.
 689      */
 690     public InetAddress getInetAddress() {
 691         if (!isConnected())
 692             return null;
 693         try {
 694             return getImpl().getInetAddress();
 695         } catch (SocketException e) {
 696         }
 697         return null;
 698     }
 699 
</pre>
<hr />
<pre>
 875      *   by the socket. Bytes that aren&#39;t discarded by the network
 876      *   software can be read using {@link java.io.InputStream#read read}.
 877      *
 878      *   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, or all
 879      *   buffered bytes have been consumed by
 880      *   {@link java.io.InputStream#read read}, then all subsequent
 881      *   calls to {@link java.io.InputStream#read read} will throw an
 882      *   {@link java.io.IOException IOException}.
 883      *
 884      *   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, and the
 885      *   socket has not been closed using {@link #close close}, then
 886      *   {@link java.io.InputStream#available available} will
 887      *   return {@code 0}.
 888      *
 889      * &lt;/ul&gt;
 890      *
 891      * &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}
 892      * will close the associated socket.
 893      *
 894      * @return     an input stream for reading bytes from this socket.
<span class="line-modified"> 895      * @exception  IOException  if an I/O error occurs when creating the</span>
 896      *             input stream, the socket is closed, the socket is
 897      *             not connected, or the socket input has been shutdown
 898      *             using {@link #shutdownInput()}
 899      *
 900      * @revised 1.4
 901      * @spec JSR-51
 902      */
 903     public InputStream getInputStream() throws IOException {
 904         if (isClosed())
 905             throw new SocketException(&quot;Socket is closed&quot;);
 906         if (!isConnected())
 907             throw new SocketException(&quot;Socket is not connected&quot;);
 908         if (isInputShutdown())
 909             throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified"> 910         InputStream is = null;</span>
<span class="line-modified"> 911         try {</span>
<span class="line-modified"> 912             is = AccessController.doPrivileged(</span>
<span class="line-modified"> 913                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-modified"> 914                     public InputStream run() throws IOException {</span>
<span class="line-modified"> 915                         return impl.getInputStream();</span>
<span class="line-modified"> 916                     }</span>
<span class="line-modified"> 917                 });</span>
<span class="line-modified"> 918         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified"> 919             throw (IOException) e.getException();</span>


































 920         }
<span class="line-removed"> 921         return is;</span>
 922     }
 923 
 924     /**
 925      * Returns an output stream for this socket.
 926      *
 927      * &lt;p&gt; If this socket has an associated channel then the resulting output
 928      * stream delegates all of its operations to the channel.  If the channel
 929      * is in non-blocking mode then the output stream&#39;s {@code write}
 930      * operations will throw an {@link
 931      * java.nio.channels.IllegalBlockingModeException}.
 932      *
 933      * &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}
 934      * will close the associated socket.
 935      *
 936      * @return     an output stream for writing bytes to this socket.
<span class="line-modified"> 937      * @exception  IOException  if an I/O error occurs when creating the</span>
 938      *               output stream or if the socket is not connected.
 939      * @revised 1.4
 940      * @spec JSR-51
 941      */
 942     public OutputStream getOutputStream() throws IOException {
 943         if (isClosed())
 944             throw new SocketException(&quot;Socket is closed&quot;);
 945         if (!isConnected())
 946             throw new SocketException(&quot;Socket is not connected&quot;);
 947         if (isOutputShutdown())
 948             throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified"> 949         OutputStream os = null;</span>
<span class="line-modified"> 950         try {</span>
<span class="line-modified"> 951             os = AccessController.doPrivileged(</span>
<span class="line-modified"> 952                 new PrivilegedExceptionAction&lt;&gt;() {</span>
<span class="line-modified"> 953                     public OutputStream run() throws IOException {</span>
<span class="line-modified"> 954                         return impl.getOutputStream();</span>
<span class="line-modified"> 955                     }</span>
<span class="line-modified"> 956                 });</span>
<span class="line-modified"> 957         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified"> 958             throw (IOException) e.getException();</span>




























 959         }
<span class="line-removed"> 960         return os;</span>
 961     }
 962 
 963     /**
 964      * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}
 965      * (disable/enable Nagle&#39;s algorithm).
 966      *
 967      * @param on {@code true} to enable TCP_NODELAY,
 968      * {@code false} to disable.
 969      *
<span class="line-modified"> 970      * @exception SocketException if there is an error</span>
 971      * in the underlying protocol, such as a TCP error.
 972      *
 973      * @since   1.1
 974      *
 975      * @see #getTcpNoDelay()
 976      */
 977     public void setTcpNoDelay(boolean on) throws SocketException {
 978         if (isClosed())
 979             throw new SocketException(&quot;Socket is closed&quot;);
 980         getImpl().setOption(SocketOptions.TCP_NODELAY, Boolean.valueOf(on));
 981     }
 982 
 983     /**
 984      * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
 985      *
 986      * @return a {@code boolean} indicating whether or not
 987      *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
<span class="line-modified"> 988      * @exception SocketException if there is an error</span>
 989      * in the underlying protocol, such as a TCP error.
 990      * @since   1.1
 991      * @see #setTcpNoDelay(boolean)
 992      */
 993     public boolean getTcpNoDelay() throws SocketException {
 994         if (isClosed())
 995             throw new SocketException(&quot;Socket is closed&quot;);
 996         return ((Boolean) getImpl().getOption(SocketOptions.TCP_NODELAY)).booleanValue();
 997     }
 998 
 999     /**
1000      * Enable/disable {@link SocketOptions#SO_LINGER SO_LINGER} with the
1001      * specified linger time in seconds. The maximum timeout value is platform
1002      * specific.
1003      *
1004      * The setting only affects socket close.
1005      *
1006      * @param on     whether or not to linger on.
1007      * @param linger how long to linger for, if on is true.
<span class="line-modified">1008      * @exception SocketException if there is an error</span>
1009      * in the underlying protocol, such as a TCP error.
<span class="line-modified">1010      * @exception IllegalArgumentException if the linger value is negative.</span>
1011      * @since 1.1
1012      * @see #getSoLinger()
1013      */
1014     public void setSoLinger(boolean on, int linger) throws SocketException {
1015         if (isClosed())
1016             throw new SocketException(&quot;Socket is closed&quot;);
1017         if (!on) {
1018             getImpl().setOption(SocketOptions.SO_LINGER, on);
1019         } else {
1020             if (linger &lt; 0) {
1021                 throw new IllegalArgumentException(&quot;invalid value for SO_LINGER&quot;);
1022             }
1023             if (linger &gt; 65535)
1024                 linger = 65535;
1025             getImpl().setOption(SocketOptions.SO_LINGER, linger);
1026         }
1027     }
1028 
1029     /**
1030      * Returns setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
1031      * -1 returns implies that the
1032      * option is disabled.
1033      *
1034      * The setting only affects socket close.
1035      *
1036      * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
<span class="line-modified">1037      * @exception SocketException if there is an error</span>
1038      * in the underlying protocol, such as a TCP error.
1039      * @since   1.1
1040      * @see #setSoLinger(boolean, int)
1041      */
1042     public int getSoLinger() throws SocketException {
1043         if (isClosed())
1044             throw new SocketException(&quot;Socket is closed&quot;);
1045         Object o = getImpl().getOption(SocketOptions.SO_LINGER);
1046         if (o instanceof Integer) {
1047             return ((Integer) o).intValue();
1048         } else {
1049             return -1;
1050         }
1051     }
1052 
1053     /**
1054      * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
1055      * bits of the data parameter. The urgent byte is
1056      * sent after any preceding writes to the socket OutputStream
1057      * and before any future writes to the OutputStream.
1058      * @param data The byte of data to send
<span class="line-modified">1059      * @exception IOException if there is an error</span>
1060      *  sending the data.
1061      * @since 1.4
1062      */
1063     public void sendUrgentData (int data) throws IOException  {
1064         if (!getImpl().supportsUrgentData ()) {
1065             throw new SocketException (&quot;Urgent data not supported&quot;);
1066         }
1067         getImpl().sendUrgentData (data);
1068     }
1069 
1070     /**
1071      * Enable/disable {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}
1072      * (receipt of TCP urgent data)
1073      *
1074      * By default, this option is disabled and TCP urgent data received on a
1075      * socket is silently discarded. If the user wishes to receive urgent data, then
1076      * this option must be enabled. When enabled, urgent data is received
1077      * inline with normal data.
1078      * &lt;p&gt;
1079      * Note, only limited support is provided for handling incoming urgent
1080      * data. In particular, no notification of incoming urgent data is provided
1081      * and there is no capability to distinguish between normal data and urgent
1082      * data unless provided by a higher level protocol.
1083      *
1084      * @param on {@code true} to enable
1085      *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},
1086      *           {@code false} to disable.
1087      *
<span class="line-modified">1088      * @exception SocketException if there is an error</span>
1089      * in the underlying protocol, such as a TCP error.
1090      *
1091      * @since   1.4
1092      *
1093      * @see #getOOBInline()
1094      */
1095     public void setOOBInline(boolean on) throws SocketException {
1096         if (isClosed())
1097             throw new SocketException(&quot;Socket is closed&quot;);
1098         getImpl().setOption(SocketOptions.SO_OOBINLINE, Boolean.valueOf(on));
1099     }
1100 
1101     /**
1102      * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
1103      *
1104      * @return a {@code boolean} indicating whether or not
1105      *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
1106      *
<span class="line-modified">1107      * @exception SocketException if there is an error</span>
1108      * in the underlying protocol, such as a TCP error.
1109      * @since   1.4
1110      * @see #setOOBInline(boolean)
1111      */
1112     public boolean getOOBInline() throws SocketException {
1113         if (isClosed())
1114             throw new SocketException(&quot;Socket is closed&quot;);
1115         return ((Boolean) getImpl().getOption(SocketOptions.SO_OOBINLINE)).booleanValue();
1116     }
1117 
1118     /**
1119      *  Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
1120      *  with the specified timeout, in milliseconds. With this option set
<span class="line-modified">1121      *  to a non-zero timeout, a read() call on the InputStream associated with</span>
1122      *  this Socket will block for only this amount of time.  If the timeout
1123      *  expires, a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified">1124      *  Socket is still valid. The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="line-modified">1125      *  prior to entering the blocking operation to have effect. The</span>
<span class="line-modified">1126      *  timeout must be {@code &gt; 0}.</span>
<span class="line-removed">1127      *  A timeout of zero is interpreted as an infinite timeout.</span>
1128      *
1129      * @param timeout the specified timeout, in milliseconds.
<span class="line-modified">1130      * @exception SocketException if there is an error</span>
<span class="line-modified">1131      * in the underlying protocol, such as a TCP error.</span>

1132      * @since   1.1
1133      * @see #getSoTimeout()
1134      */
1135     public synchronized void setSoTimeout(int timeout) throws SocketException {
1136         if (isClosed())
1137             throw new SocketException(&quot;Socket is closed&quot;);
1138         if (timeout &lt; 0)
1139           throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);
1140 
1141         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
1142     }
1143 
1144     /**
1145      * Returns setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
1146      * 0 returns implies that the option is disabled (i.e., timeout of infinity).
1147      *
1148      * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
<span class="line-modified">1149      * @exception SocketException if there is an error</span>
1150      * in the underlying protocol, such as a TCP error.
1151      *
1152      * @since   1.1
1153      * @see #setSoTimeout(int)
1154      */
1155     public synchronized int getSoTimeout() throws SocketException {
1156         if (isClosed())
1157             throw new SocketException(&quot;Socket is closed&quot;);
1158         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
1159         /* extra type safety */
1160         if (o instanceof Integer) {
1161             return ((Integer) o).intValue();
1162         } else {
1163             return 0;
1164         }
1165     }
1166 
1167     /**
1168      * Sets the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option to the
1169      * specified value for this {@code Socket}.
1170      * The {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option is used by the
1171      * platform&#39;s networking code as a hint for the size to set the underlying
1172      * network I/O buffers.
1173      *
1174      * &lt;p&gt;Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,
1175      * applications that want to verify what size the buffers were set to
1176      * should call {@link #getSendBufferSize()}.
1177      *
<span class="line-modified">1178      * @exception SocketException if there is an error</span>
1179      * in the underlying protocol, such as a TCP error.
1180      *
1181      * @param size the size to which to set the send buffer
1182      * size. This value must be greater than 0.
1183      *
<span class="line-modified">1184      * @exception IllegalArgumentException if the</span>
1185      * value is 0 or is negative.
1186      *
1187      * @see #getSendBufferSize()
1188      * @since 1.2
1189      */
1190     public synchronized void setSendBufferSize(int size)
1191     throws SocketException{
1192         if (!(size &gt; 0)) {
1193             throw new IllegalArgumentException(&quot;negative send size&quot;);
1194         }
1195         if (isClosed())
1196             throw new SocketException(&quot;Socket is closed&quot;);
1197         getImpl().setOption(SocketOptions.SO_SNDBUF, size);
1198     }
1199 
1200     /**
1201      * Get value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option
1202      * for this {@code Socket}, that is the buffer size used by the platform
1203      * for output on this {@code Socket}.
1204      * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}
1205      *         option for this {@code Socket}.
1206      *
<span class="line-modified">1207      * @exception SocketException if there is an error</span>
1208      * in the underlying protocol, such as a TCP error.
1209      *
1210      * @see #setSendBufferSize(int)
1211      * @since 1.2
1212      */
1213     public synchronized int getSendBufferSize() throws SocketException {
1214         if (isClosed())
1215             throw new SocketException(&quot;Socket is closed&quot;);
1216         int result = 0;
1217         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
1218         if (o instanceof Integer) {
1219             result = ((Integer)o).intValue();
1220         }
1221         return result;
1222     }
1223 
1224     /**
1225      * Sets the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option to the
1226      * specified value for this {@code Socket}. The
1227      * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option is
</pre>
<hr />
<pre>
1234      *
1235      * &lt;p&gt;Because {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is a hint,
1236      * applications that want to verify what size the buffers were set to
1237      * should call {@link #getReceiveBufferSize()}.
1238      *
1239      * &lt;p&gt;The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is also used
1240      * to set the TCP receive window that is advertised to the remote peer.
1241      * Generally, the window size can be modified at any time when a socket is
1242      * connected. However, if a receive window larger than 64K is required then
1243      * this must be requested &lt;B&gt;before&lt;/B&gt; the socket is connected to the
1244      * remote peer. There are two cases to be aware of:
1245      * &lt;ol&gt;
1246      * &lt;li&gt;For sockets accepted from a ServerSocket, this must be done by calling
1247      * {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket
1248      * is bound to a local address.&lt;/li&gt;
1249      * &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
1250      * connecting the socket to its remote peer.&lt;/li&gt;&lt;/ol&gt;
1251      * @param size the size to which to set the receive buffer
1252      * size. This value must be greater than 0.
1253      *
<span class="line-modified">1254      * @exception IllegalArgumentException if the value is 0 or is</span>
1255      * negative.
1256      *
<span class="line-modified">1257      * @exception SocketException if there is an error</span>
1258      * in the underlying protocol, such as a TCP error.
1259      *
1260      * @see #getReceiveBufferSize()
1261      * @see ServerSocket#setReceiveBufferSize(int)
1262      * @since 1.2
1263      */
1264     public synchronized void setReceiveBufferSize(int size)
1265     throws SocketException{
1266         if (size &lt;= 0) {
1267             throw new IllegalArgumentException(&quot;invalid receive size&quot;);
1268         }
1269         if (isClosed())
1270             throw new SocketException(&quot;Socket is closed&quot;);
1271         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
1272     }
1273 
1274     /**
1275      * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
1276      * for this {@code Socket}, that is the buffer size used by the platform
1277      * for input on this {@code Socket}.
1278      *
1279      * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
1280      *         option for this {@code Socket}.
<span class="line-modified">1281      * @exception SocketException if there is an error</span>
1282      * in the underlying protocol, such as a TCP error.
1283      * @see #setReceiveBufferSize(int)
1284      * @since 1.2
1285      */
1286     public synchronized int getReceiveBufferSize()
1287     throws SocketException{
1288         if (isClosed())
1289             throw new SocketException(&quot;Socket is closed&quot;);
1290         int result = 0;
1291         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
1292         if (o instanceof Integer) {
1293             result = ((Integer)o).intValue();
1294         }
1295         return result;
1296     }
1297 
1298     /**
1299      * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.
1300      *
1301      * @param on  whether or not to have socket keep alive turned on.
<span class="line-modified">1302      * @exception SocketException if there is an error</span>
1303      * in the underlying protocol, such as a TCP error.
1304      * @since 1.3
1305      * @see #getKeepAlive()
1306      */
1307     public void setKeepAlive(boolean on) throws SocketException {
1308         if (isClosed())
1309             throw new SocketException(&quot;Socket is closed&quot;);
1310         getImpl().setOption(SocketOptions.SO_KEEPALIVE, Boolean.valueOf(on));
1311     }
1312 
1313     /**
1314      * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
1315      *
1316      * @return a {@code boolean} indicating whether or not
1317      *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
<span class="line-modified">1318      * @exception SocketException if there is an error</span>
1319      * in the underlying protocol, such as a TCP error.
1320      * @since   1.3
1321      * @see #setKeepAlive(boolean)
1322      */
1323     public boolean getKeepAlive() throws SocketException {
1324         if (isClosed())
1325             throw new SocketException(&quot;Socket is closed&quot;);
1326         return ((Boolean) getImpl().getOption(SocketOptions.SO_KEEPALIVE)).booleanValue();
1327     }
1328 
1329     /**
1330      * Sets traffic class or type-of-service octet in the IP
1331      * header for packets sent from this Socket.
1332      * As the underlying network implementation may ignore this
1333      * value applications should consider it a hint.
1334      *
1335      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
1336      * 255} or an IllegalArgumentException will be thrown.
1337      * &lt;p&gt;Notes:
1338      * &lt;p&gt;For Internet Protocol v4 the value consists of an
</pre>
<hr />
<pre>
1417      * is closed (typically known as the {@code TIME_WAIT} state
1418      * or {@code 2MSL} wait state).
1419      * For applications using a well known socket address or port
1420      * it may not be possible to bind a socket to the required
1421      * {@code SocketAddress} if there is a connection in the
1422      * timeout state involving the socket address or port.
1423      * &lt;p&gt;
1424      * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
1425      * prior to binding the socket using {@link #bind(SocketAddress)} allows
1426      * the socket to be bound even though a previous connection is in a timeout
1427      * state.
1428      * &lt;p&gt;
1429      * When a {@code Socket} is created the initial setting
1430      * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is disabled.
1431      * &lt;p&gt;
1432      * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
1433      * enabled or disabled after a socket is bound (See {@link #isBound()})
1434      * is not defined.
1435      *
1436      * @param on  whether to enable or disable the socket option
<span class="line-modified">1437      * @exception SocketException if an error occurs enabling or</span>
1438      *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
1439      *            socket option, or the socket is closed.
1440      * @since 1.4
1441      * @see #getReuseAddress()
1442      * @see #bind(SocketAddress)
1443      * @see #isClosed()
1444      * @see #isBound()
1445      */
1446     public void setReuseAddress(boolean on) throws SocketException {
1447         if (isClosed())
1448             throw new SocketException(&quot;Socket is closed&quot;);
1449         getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
1450     }
1451 
1452     /**
1453      * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
1454      *
1455      * @return a {@code boolean} indicating whether or not
1456      *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified">1457      * @exception SocketException if there is an error</span>
1458      * in the underlying protocol, such as a TCP error.
1459      * @since   1.4
1460      * @see #setReuseAddress(boolean)
1461      */
1462     public boolean getReuseAddress() throws SocketException {
1463         if (isClosed())
1464             throw new SocketException(&quot;Socket is closed&quot;);
1465         return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();
1466     }
1467 
1468     /**
1469      * Closes this socket.
1470      * &lt;p&gt;
1471      * Any thread currently blocked in an I/O operation upon this socket
1472      * will throw a {@link SocketException}.
1473      * &lt;p&gt;
1474      * Once a socket has been closed, it is not available for further networking
1475      * use (i.e. can&#39;t be reconnected or rebound). A new socket needs to be
1476      * created.
1477      *
1478      * &lt;p&gt; Closing this socket will also close the socket&#39;s
1479      * {@link java.io.InputStream InputStream} and
1480      * {@link java.io.OutputStream OutputStream}.
1481      *
1482      * &lt;p&gt; If this socket has an associated channel then the channel is closed
1483      * as well.
1484      *
<span class="line-modified">1485      * @exception  IOException  if an I/O error occurs when closing this socket.</span>
1486      * @revised 1.4
1487      * @spec JSR-51
1488      * @see #isClosed
1489      */
1490     public synchronized void close() throws IOException {
1491         synchronized(closeLock) {
1492             if (isClosed())
1493                 return;
1494             if (created)
1495                 impl.close();
1496             closed = true;
1497         }
1498     }
1499 
1500     /**
1501      * Places the input stream for this socket at &quot;end of stream&quot;.
1502      * Any data sent to the input stream side of the socket is acknowledged
1503      * and then silently discarded.
1504      * &lt;p&gt;
1505      * If you read from a socket input stream after invoking this method on the
1506      * socket, the stream&#39;s {@code available} method will return 0, and its
1507      * {@code read} methods will return {@code -1} (end of stream).
1508      *
<span class="line-modified">1509      * @exception IOException if an I/O error occurs when shutting down this</span>
1510      * socket.
1511      *
1512      * @since 1.3
1513      * @see java.net.Socket#shutdownOutput()
1514      * @see java.net.Socket#close()
1515      * @see java.net.Socket#setSoLinger(boolean, int)
1516      * @see #isInputShutdown
1517      */
1518     public void shutdownInput() throws IOException
1519     {
1520         if (isClosed())
1521             throw new SocketException(&quot;Socket is closed&quot;);
1522         if (!isConnected())
1523             throw new SocketException(&quot;Socket is not connected&quot;);
1524         if (isInputShutdown())
1525             throw new SocketException(&quot;Socket input is already shutdown&quot;);
1526         getImpl().shutdownInput();
1527         shutIn = true;
1528     }
1529 
1530     /**
1531      * Disables the output stream for this socket.
1532      * For a TCP socket, any previously written data will be sent
1533      * followed by TCP&#39;s normal connection termination sequence.
1534      *
1535      * If you write to a socket output stream after invoking
1536      * shutdownOutput() on the socket, the stream will throw
1537      * an IOException.
1538      *
<span class="line-modified">1539      * @exception IOException if an I/O error occurs when shutting down this</span>
1540      * socket.
1541      *
1542      * @since 1.3
1543      * @see java.net.Socket#shutdownInput()
1544      * @see java.net.Socket#close()
1545      * @see java.net.Socket#setSoLinger(boolean, int)
1546      * @see #isOutputShutdown
1547      */
1548     public void shutdownOutput() throws IOException
1549     {
1550         if (isClosed())
1551             throw new SocketException(&quot;Socket is closed&quot;);
1552         if (!isConnected())
1553             throw new SocketException(&quot;Socket is not connected&quot;);
1554         if (isOutputShutdown())
1555             throw new SocketException(&quot;Socket output is already shutdown&quot;);
1556         getImpl().shutdownOutput();
1557         shutOut = true;
1558     }
1559 
</pre>
<hr />
<pre>
1568                 return &quot;Socket[addr=&quot; + getImpl().getInetAddress() +
1569                     &quot;,port=&quot; + getImpl().getPort() +
1570                     &quot;,localport=&quot; + getImpl().getLocalPort() + &quot;]&quot;;
1571         } catch (SocketException e) {
1572         }
1573         return &quot;Socket[unconnected]&quot;;
1574     }
1575 
1576     /**
1577      * Returns the connection state of the socket.
1578      * &lt;p&gt;
1579      * Note: Closing a socket doesn&#39;t clear its connection state, which means
1580      * this method will return {@code true} for a closed socket
1581      * (see {@link #isClosed()}) if it was successfully connected prior
1582      * to being closed.
1583      *
1584      * @return true if the socket was successfully connected to a server
1585      * @since 1.4
1586      */
1587     public boolean isConnected() {
<span class="line-modified">1588         // Before 1.3 Sockets were always connected during creation</span>
<span class="line-removed">1589         return connected || oldImpl;</span>
1590     }
1591 
1592     /**
1593      * Returns the binding state of the socket.
1594      * &lt;p&gt;
1595      * Note: Closing a socket doesn&#39;t clear its binding state, which means
1596      * this method will return {@code true} for a closed socket
1597      * (see {@link #isClosed()}) if it was successfully bound prior
1598      * to being closed.
1599      *
1600      * @return true if the socket was successfully bound to an address
1601      * @since 1.4
1602      * @see #bind
1603      */
1604     public boolean isBound() {
<span class="line-modified">1605         // Before 1.3 Sockets were always bound during creation</span>
<span class="line-removed">1606         return bound || oldImpl;</span>
1607     }
1608 
1609     /**
1610      * Returns the closed state of the socket.
1611      *
1612      * @return true if the socket has been closed
1613      * @since 1.4
1614      * @see #close
1615      */
1616     public boolean isClosed() {
1617         synchronized(closeLock) {
1618             return closed;
1619         }
1620     }
1621 
1622     /**
1623      * Returns whether the read-half of the socket connection is closed.
1624      *
1625      * @return true if the input of the socket has been shutdown
1626      * @since 1.4
1627      * @see #shutdownInput
1628      */
1629     public boolean isInputShutdown() {
1630         return shutIn;
1631     }
1632 
1633     /**
1634      * Returns whether the write-half of the socket connection is closed.
1635      *
1636      * @return true if the output of the socket has been shutdown
1637      * @since 1.4
1638      * @see #shutdownOutput
1639      */
1640     public boolean isOutputShutdown() {
1641         return shutOut;
1642     }
1643 
1644     /**
1645      * The factory for all client sockets.
1646      */
<span class="line-modified">1647     private static SocketImplFactory factory = null;</span>




1648 
1649     /**
1650      * Sets the client socket implementation factory for the
1651      * application. The factory can be specified only once.
1652      * &lt;p&gt;
1653      * When an application creates a new client socket, the socket
1654      * implementation factory&#39;s {@code createSocketImpl} method is
1655      * called to create the actual socket implementation.
1656      * &lt;p&gt;
1657      * Passing {@code null} to the method is a no-op unless the factory
1658      * was already set.
1659      * &lt;p&gt;If there is a security manager, this method first calls
1660      * the security manager&#39;s {@code checkSetFactory} method
1661      * to ensure the operation is allowed.
1662      * This could result in a SecurityException.
1663      *
1664      * @param      fac   the desired factory.
<span class="line-modified">1665      * @exception  IOException  if an I/O error occurs when setting the</span>
1666      *               socket factory.
<span class="line-modified">1667      * @exception  SocketException  if the factory is already defined.</span>
<span class="line-modified">1668      * @exception  SecurityException  if a security manager exists and its</span>
1669      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1670      * @see        java.net.SocketImplFactory#createSocketImpl()
1671      * @see        SecurityManager#checkSetFactory
1672      */
1673     public static synchronized void setSocketImplFactory(SocketImplFactory fac)
1674         throws IOException
1675     {
1676         if (factory != null) {
1677             throw new SocketException(&quot;factory already defined&quot;);
1678         }
1679         SecurityManager security = System.getSecurityManager();
1680         if (security != null) {
1681             security.checkSetFactory();
1682         }
1683         factory = fac;
1684     }
1685 
1686     /**
1687      * Sets performance preferences for this socket.
1688      *
</pre>
<hr />
<pre>
1740      *
1741      * @throws UnsupportedOperationException if the socket does not support
1742      *         the option.
1743      *
1744      * @throws IllegalArgumentException if the value is not valid for
1745      *         the option.
1746      *
1747      * @throws IOException if an I/O error occurs, or if the socket is closed.
1748      *
1749      * @throws NullPointerException if name is {@code null}
1750      *
1751      * @throws SecurityException if a security manager is set and if the socket
1752      *         option requires a security permission and if the caller does
1753      *         not have the required permission.
1754      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1755      *         do not require any security permission.
1756      *
1757      * @since 9
1758      */
1759     public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {



1760         getImpl().setOption(name, value);
1761         return this;
1762     }
1763 
1764     /**
1765      * Returns the value of a socket option.
1766      *
1767      * @param &lt;T&gt; The type of the socket option value
1768      * @param name The socket option
1769      *
1770      * @return The value of the socket option.
1771      *
1772      * @throws UnsupportedOperationException if the socket does not support
1773      *         the option.
1774      *
1775      * @throws IOException if an I/O error occurs, or if the socket is closed.
1776      *
1777      * @throws NullPointerException if name is {@code null}
1778      *
1779      * @throws SecurityException if a security manager is set and if the socket
1780      *         option requires a security permission and if the caller does
1781      *         not have the required permission.
1782      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1783      *         do not require any security permission.
1784      *
1785      * @since 9
1786      */
1787     @SuppressWarnings(&quot;unchecked&quot;)
1788     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {



1789         return getImpl().getOption(name);
1790     }
1791 
1792     // cache of unmodifiable impl options. Possibly set racy, in impl we trust
1793     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
1794 
1795     /**
1796      * Returns a set of the socket options supported by this socket.
1797      *
1798      * This method will continue to return the set of options even after
1799      * the socket has been closed.
1800      *
1801      * @return A set of the socket options supported by this socket. This set
1802      *         may be empty if the socket&#39;s SocketImpl cannot be created.
1803      *
1804      * @since 9
1805      */
1806     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1807         Set&lt;SocketOption&lt;?&gt;&gt; so = options;
1808         if (so != null)
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
<span class="line-added">  28 import sun.security.util.SecurityConstants;</span>
<span class="line-added">  29 </span>
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.io.IOException;
<span class="line-added">  33 import java.lang.invoke.MethodHandles;</span>
<span class="line-added">  34 import java.lang.invoke.VarHandle;</span>
  35 import java.nio.channels.SocketChannel;
  36 import java.security.AccessController;

  37 import java.security.PrivilegedAction;
<span class="line-added">  38 import java.util.Objects;</span>
  39 import java.util.Set;
  40 import java.util.Collections;
  41 
  42 /**
  43  * This class implements client sockets (also called just
  44  * &quot;sockets&quot;). A socket is an endpoint for communication
  45  * between two machines.
  46  * &lt;p&gt;
  47  * The actual work of the socket is performed by an instance of the
  48  * {@code SocketImpl} class. An application, by changing
  49  * the socket factory that creates the socket implementation,
  50  * can configure itself to create sockets appropriate to the local
  51  * firewall.
  52  *
<span class="line-added">  53  * &lt;p&gt; The {@code Socket} class defines convenience</span>
<span class="line-added">  54  * methods to set and get several socket options. This class also</span>
<span class="line-added">  55  * defines the {@link #setOption(SocketOption, Object) setOption}</span>
<span class="line-added">  56  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">  57  * and query socket options.</span>
<span class="line-added">  58  * A {@code Socket} support the following options:</span>
<span class="line-added">  59  * &lt;blockquote&gt;</span>
<span class="line-added">  60  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">  61  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">  62  * &lt;thead&gt;</span>
<span class="line-added">  63  *   &lt;tr&gt;</span>
<span class="line-added">  64  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">  65  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">  66  *   &lt;/tr&gt;</span>
<span class="line-added">  67  * &lt;/thead&gt;</span>
<span class="line-added">  68  * &lt;tbody&gt;</span>
<span class="line-added">  69  *   &lt;tr&gt;</span>
<span class="line-added">  70  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;</span>
<span class="line-added">  71  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;</span>
<span class="line-added">  72  *   &lt;/tr&gt;</span>
<span class="line-added">  73  *   &lt;tr&gt;</span>
<span class="line-added">  74  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="line-added">  75  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="line-added">  76  *   &lt;/tr&gt;</span>
<span class="line-added">  77  *   &lt;tr&gt;</span>
<span class="line-added">  78  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} &lt;/th&gt;</span>
<span class="line-added">  79  *     &lt;td&gt; Keep connection alive &lt;/td&gt;</span>
<span class="line-added">  80  *   &lt;/tr&gt;</span>
<span class="line-added">  81  *   &lt;tr&gt;</span>
<span class="line-added">  82  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="line-added">  83  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="line-added">  84  *   &lt;/tr&gt;</span>
<span class="line-added">  85  *   &lt;tr&gt;</span>
<span class="line-added">  86  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} &lt;/th&gt;</span>
<span class="line-added">  87  *     &lt;td&gt; Linger on close if data is present (when configured in blocking mode</span>
<span class="line-added">  88  *          only) &lt;/td&gt;</span>
<span class="line-added">  89  *   &lt;/tr&gt;</span>
<span class="line-added">  90  *   &lt;tr&gt;</span>
<span class="line-added">  91  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#TCP_NODELAY TCP_NODELAY} &lt;/th&gt;</span>
<span class="line-added">  92  *     &lt;td&gt; Disable the Nagle algorithm &lt;/td&gt;</span>
<span class="line-added">  93  *   &lt;/tr&gt;</span>
<span class="line-added">  94  * &lt;/tbody&gt;</span>
<span class="line-added">  95  * &lt;/table&gt;</span>
<span class="line-added">  96  * &lt;/blockquote&gt;</span>
<span class="line-added">  97  * Additional (implementation specific) options may also be supported.</span>
<span class="line-added">  98  *</span>
  99  * @author  unascribed
 100  * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 101  * @see     java.net.SocketImpl
 102  * @see     java.nio.channels.SocketChannel
 103  * @since   1.0
 104  */
<span class="line-modified"> 105 public class Socket implements java.io.Closeable {</span>

 106     /**
 107      * Various states of this socket.
 108      */
 109     private boolean created = false;
 110     private boolean bound = false;
 111     private boolean connected = false;
 112     private boolean closed = false;
 113     private Object closeLock = new Object();
 114     private boolean shutIn = false;
 115     private boolean shutOut = false;
 116 
 117     /**
 118      * The implementation of this Socket.
 119      */
 120     SocketImpl impl;
 121 
 122     /**
<span class="line-modified"> 123      * Socket input/output streams</span>
 124      */
<span class="line-modified"> 125     private volatile InputStream in;</span>
<span class="line-added"> 126     private volatile OutputStream out;</span>
<span class="line-added"> 127     private static final VarHandle IN, OUT;</span>
<span class="line-added"> 128     static {</span>
<span class="line-added"> 129         try {</span>
<span class="line-added"> 130             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-added"> 131             IN = l.findVarHandle(Socket.class, &quot;in&quot;, InputStream.class);</span>
<span class="line-added"> 132             OUT = l.findVarHandle(Socket.class, &quot;out&quot;, OutputStream.class);</span>
<span class="line-added"> 133         } catch (Exception e) {</span>
<span class="line-added"> 134             throw new InternalError(e);</span>
<span class="line-added"> 135         }</span>
<span class="line-added"> 136     }</span>
 137 
 138     /**
<span class="line-modified"> 139      * Creates an unconnected Socket.</span>
<span class="line-modified"> 140      * &lt;p&gt;</span>
<span class="line-added"> 141      * If the application has specified a client socket implementation</span>
<span class="line-added"> 142      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-added"> 143      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 144      * socket implementation is created.</span>
 145      *
 146      * @since   1.1
 147      * @revised 1.4
 148      */
 149     public Socket() {
 150         setImpl();
 151     }
 152 
 153     /**
 154      * Creates an unconnected socket, specifying the type of proxy, if any,
 155      * that should be used regardless of any other settings.
 156      * &lt;P&gt;
 157      * If there is a security manager, its {@code checkConnect} method
 158      * is called with the proxy host address and port number
 159      * as its arguments. This could result in a SecurityException.
 160      * &lt;P&gt;
 161      * Examples:
 162      * &lt;UL&gt; &lt;LI&gt;{@code Socket s = new Socket(Proxy.NO_PROXY);} will create
 163      * a plain socket ignoring any other proxy configuration.&lt;/LI&gt;
 164      * &lt;LI&gt;{@code Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;socks.mydom.com&quot;, 1080)));}
</pre>
<hr />
<pre>
 184             throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
 185         }
 186         Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY
 187                                           : sun.net.ApplicationProxy.create(proxy);
 188         Proxy.Type type = p.type();
 189         if (type == Proxy.Type.SOCKS || type == Proxy.Type.HTTP) {
 190             SecurityManager security = System.getSecurityManager();
 191             InetSocketAddress epoint = (InetSocketAddress) p.address();
 192             if (epoint.getAddress() != null) {
 193                 checkAddress (epoint.getAddress(), &quot;Socket&quot;);
 194             }
 195             if (security != null) {
 196                 if (epoint.isUnresolved())
 197                     epoint = new InetSocketAddress(epoint.getHostName(), epoint.getPort());
 198                 if (epoint.isUnresolved())
 199                     security.checkConnect(epoint.getHostName(), epoint.getPort());
 200                 else
 201                     security.checkConnect(epoint.getAddress().getHostAddress(),
 202                                   epoint.getPort());
 203             }
<span class="line-modified"> 204 </span>
<span class="line-modified"> 205             // create a SOCKS or HTTP SocketImpl that delegates to a platform SocketImpl</span>
<span class="line-modified"> 206             SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-added"> 207             impl = (type == Proxy.Type.SOCKS) ? new SocksSocketImpl(p, delegate)</span>
<span class="line-added"> 208                                               : new HttpConnectSocketImpl(p, delegate, this);</span>
 209         } else {
 210             if (p == Proxy.NO_PROXY) {
<span class="line-added"> 211                 // create a platform or custom SocketImpl for the DIRECT case</span>
<span class="line-added"> 212                 SocketImplFactory factory = Socket.factory;</span>
 213                 if (factory == null) {
<span class="line-modified"> 214                     impl = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-modified"> 215                 } else {</span>
<span class="line-modified"> 216                     impl = factory.createSocketImpl();</span>
<span class="line-modified"> 217                 }</span>
 218             } else
 219                 throw new IllegalArgumentException(&quot;Invalid Proxy&quot;);
 220         }
 221     }
 222 
 223     /**
 224      * Creates an unconnected Socket with a user-specified
 225      * SocketImpl.
 226      *
 227      * @param impl an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
 228      * the subclass wishes to use on the Socket.
 229      *
<span class="line-modified"> 230      * @throws    SocketException if there is an error in the underlying protocol,</span>
 231      * such as a TCP error.
<span class="line-added"> 232      *</span>
<span class="line-added"> 233      * @throws SecurityException if {@code impl} is non-null and a security manager is set</span>
<span class="line-added"> 234      * and its {@code checkPermission} method doesn&#39;t allow {@code NetPermission(&quot;setSocketImpl&quot;)}.</span>
<span class="line-added"> 235      *</span>
 236      * @since   1.1
 237      */
 238     protected Socket(SocketImpl impl) throws SocketException {
<span class="line-added"> 239         checkPermission(impl);</span>
 240         this.impl = impl;
<span class="line-modified"> 241     }</span>
<span class="line-modified"> 242 </span>
<span class="line-modified"> 243     private static Void checkPermission(SocketImpl impl) {</span>
<span class="line-added"> 244         if (impl == null) {</span>
<span class="line-added"> 245             return null;</span>
<span class="line-added"> 246         }</span>
<span class="line-added"> 247         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added"> 248         if (sm != null) {</span>
<span class="line-added"> 249             sm.checkPermission(SecurityConstants.SET_SOCKETIMPL_PERMISSION);</span>
 250         }
<span class="line-added"> 251         return null;</span>
 252     }
 253 
 254     /**
 255      * Creates a stream socket and connects it to the specified port
 256      * number on the named host.
 257      * &lt;p&gt;
 258      * If the specified host is {@code null} it is the equivalent of
 259      * specifying the address as
 260      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 261      * In other words, it is equivalent to specifying an address of the
 262      * loopback interface. &lt;/p&gt;
 263      * &lt;p&gt;
<span class="line-modified"> 264      * If the application has specified a client socket implementation</span>
<span class="line-modified"> 265      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 266      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 267      * socket implementation is created.</span>
 268      * &lt;p&gt;
 269      * If there is a security manager, its
 270      * {@code checkConnect} method is called
 271      * with the host address and {@code port}
 272      * as its arguments. This could result in a SecurityException.
 273      *
 274      * @param      host   the host name, or {@code null} for the loopback address.
 275      * @param      port   the port number.
 276      *
<span class="line-modified"> 277      * @throws     UnknownHostException if the IP address of</span>
 278      * the host could not be determined.
 279      *
<span class="line-modified"> 280      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 281      * @throws     SecurityException  if a security manager exists and its</span>
 282      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 283      * @throws     IllegalArgumentException if the port parameter is outside</span>
 284      *             the specified range of valid port values, which is between
 285      *             0 and 65535, inclusive.
 286      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 287      * @see        java.net.SocketImpl
 288      * @see        java.net.SocketImplFactory#createSocketImpl()
 289      * @see        SecurityManager#checkConnect
 290      */
 291     public Socket(String host, int port)
 292         throws UnknownHostException, IOException
 293     {
 294         this(host != null ? new InetSocketAddress(host, port) :
 295              new InetSocketAddress(InetAddress.getByName(null), port),
 296              (SocketAddress) null, true);
 297     }
 298 
 299     /**
 300      * Creates a stream socket and connects it to the specified port
 301      * number at the specified IP address.
 302      * &lt;p&gt;
<span class="line-modified"> 303      * If the application has specified a client socket implementation</span>
<span class="line-modified"> 304      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 305      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 306      * socket implementation is created.</span>
 307      * &lt;p&gt;
 308      * If there is a security manager, its
 309      * {@code checkConnect} method is called
 310      * with the host address and {@code port}
 311      * as its arguments. This could result in a SecurityException.
 312      *
 313      * @param      address   the IP address.
 314      * @param      port      the port number.
<span class="line-modified"> 315      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 316      * @throws     SecurityException  if a security manager exists and its</span>
 317      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 318      * @throws     IllegalArgumentException if the port parameter is outside</span>
 319      *             the specified range of valid port values, which is between
 320      *             0 and 65535, inclusive.
<span class="line-modified"> 321      * @throws     NullPointerException if {@code address} is null.</span>
 322      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 323      * @see        java.net.SocketImpl
 324      * @see        java.net.SocketImplFactory#createSocketImpl()
 325      * @see        SecurityManager#checkConnect
 326      */
 327     public Socket(InetAddress address, int port) throws IOException {
 328         this(address != null ? new InetSocketAddress(address, port) : null,
 329              (SocketAddress) null, true);
 330     }
 331 
 332     /**
 333      * Creates a socket and connects it to the specified remote host on
 334      * the specified remote port. The Socket will also bind() to the local
 335      * address and port supplied.
 336      * &lt;p&gt;
 337      * If the specified host is {@code null} it is the equivalent of
 338      * specifying the address as
 339      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 340      * In other words, it is equivalent to specifying an address of the
 341      * loopback interface. &lt;/p&gt;
 342      * &lt;p&gt;
 343      * A local port number of {@code zero} will let the system pick up a
 344      * free port in the {@code bind} operation.&lt;/p&gt;
 345      * &lt;p&gt;
 346      * If there is a security manager, its
 347      * {@code checkConnect} method is called
 348      * with the host address and {@code port}
 349      * as its arguments. This could result in a SecurityException.
 350      *
 351      * @param host the name of the remote host, or {@code null} for the loopback address.
 352      * @param port the remote port
 353      * @param localAddr the local address the socket is bound to, or
 354      *        {@code null} for the {@code anyLocal} address.
 355      * @param localPort the local port the socket is bound to, or
 356      *        {@code zero} for a system selected free port.
<span class="line-modified"> 357      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 358      * @throws     SecurityException  if a security manager exists and its</span>
 359      *             {@code checkConnect} method doesn&#39;t allow the connection
 360      *             to the destination, or if its {@code checkListen} method
 361      *             doesn&#39;t allow the bind to the local port.
<span class="line-modified"> 362      * @throws     IllegalArgumentException if the port parameter or localPort</span>
 363      *             parameter is outside the specified range of valid port values,
 364      *             which is between 0 and 65535, inclusive.
 365      * @see        SecurityManager#checkConnect
 366      * @since   1.1
 367      */
 368     public Socket(String host, int port, InetAddress localAddr,
 369                   int localPort) throws IOException {
 370         this(host != null ? new InetSocketAddress(host, port) :
 371                new InetSocketAddress(InetAddress.getByName(null), port),
 372              new InetSocketAddress(localAddr, localPort), true);
 373     }
 374 
 375     /**
 376      * Creates a socket and connects it to the specified remote address on
 377      * the specified remote port. The Socket will also bind() to the local
 378      * address and port supplied.
 379      * &lt;p&gt;
 380      * If the specified local address is {@code null} it is the equivalent of
 381      * specifying the address as the AnyLocal address
 382      * (see {@link java.net.InetAddress#isAnyLocalAddress InetAddress.isAnyLocalAddress}{@code ()}).
 383      * &lt;p&gt;
 384      * A local port number of {@code zero} will let the system pick up a
 385      * free port in the {@code bind} operation.&lt;/p&gt;
 386      * &lt;p&gt;
 387      * If there is a security manager, its
 388      * {@code checkConnect} method is called
 389      * with the host address and {@code port}
 390      * as its arguments. This could result in a SecurityException.
 391      *
 392      * @param address the remote address
 393      * @param port the remote port
 394      * @param localAddr the local address the socket is bound to, or
 395      *        {@code null} for the {@code anyLocal} address.
 396      * @param localPort the local port the socket is bound to or
 397      *        {@code zero} for a system selected free port.
<span class="line-modified"> 398      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 399      * @throws     SecurityException  if a security manager exists and its</span>
 400      *             {@code checkConnect} method doesn&#39;t allow the connection
 401      *             to the destination, or if its {@code checkListen} method
 402      *             doesn&#39;t allow the bind to the local port.
<span class="line-modified"> 403      * @throws     IllegalArgumentException if the port parameter or localPort</span>
 404      *             parameter is outside the specified range of valid port values,
 405      *             which is between 0 and 65535, inclusive.
<span class="line-modified"> 406      * @throws     NullPointerException if {@code address} is null.</span>
 407      * @see        SecurityManager#checkConnect
 408      * @since   1.1
 409      */
 410     public Socket(InetAddress address, int port, InetAddress localAddr,
 411                   int localPort) throws IOException {
 412         this(address != null ? new InetSocketAddress(address, port) : null,
 413              new InetSocketAddress(localAddr, localPort), true);
 414     }
 415 
 416     /**
 417      * Creates a stream socket and connects it to the specified port
 418      * number on the named host.
 419      * &lt;p&gt;
 420      * If the specified host is {@code null} it is the equivalent of
 421      * specifying the address as
 422      * {@link java.net.InetAddress#getByName InetAddress.getByName}{@code (null)}.
 423      * In other words, it is equivalent to specifying an address of the
 424      * loopback interface. &lt;/p&gt;
 425      * &lt;p&gt;
 426      * If the stream argument is {@code true}, this creates a
 427      * stream socket. If the stream argument is {@code false}, it
 428      * creates a datagram socket.
 429      * &lt;p&gt;
<span class="line-modified"> 430      * If the application has specified a client socket implementation</span>
<span class="line-modified"> 431      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 432      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 433      * socket implementation is created.</span>
 434      * &lt;p&gt;
 435      * If there is a security manager, its
 436      * {@code checkConnect} method is called
 437      * with the host address and {@code port}
 438      * as its arguments. This could result in a SecurityException.
 439      * &lt;p&gt;
 440      * If a UDP socket is used, TCP/IP related socket options will not apply.
 441      *
 442      * @param      host     the host name, or {@code null} for the loopback address.
 443      * @param      port     the port number.
 444      * @param      stream   a {@code boolean} indicating whether this is
 445      *                      a stream socket or a datagram socket.
<span class="line-modified"> 446      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 447      * @throws     SecurityException  if a security manager exists and its</span>
 448      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 449      * @throws     IllegalArgumentException if the port parameter is outside</span>
 450      *             the specified range of valid port values, which is between
 451      *             0 and 65535, inclusive.
 452      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 453      * @see        java.net.SocketImpl
 454      * @see        java.net.SocketImplFactory#createSocketImpl()
 455      * @see        SecurityManager#checkConnect
 456      * @deprecated Use DatagramSocket instead for UDP transport.
 457      */
 458     @Deprecated
 459     public Socket(String host, int port, boolean stream) throws IOException {
 460         this(host != null ? new InetSocketAddress(host, port) :
 461                new InetSocketAddress(InetAddress.getByName(null), port),
 462              (SocketAddress) null, stream);
 463     }
 464 
 465     /**
 466      * Creates a socket and connects it to the specified port number at
 467      * the specified IP address.
 468      * &lt;p&gt;
 469      * If the stream argument is {@code true}, this creates a
 470      * stream socket. If the stream argument is {@code false}, it
 471      * creates a datagram socket.
 472      * &lt;p&gt;
<span class="line-modified"> 473      * If the application has specified a client socket implementation</span>
<span class="line-modified"> 474      * factory, that factory&#39;s {@code createSocketImpl} method is called to</span>
<span class="line-modified"> 475      * create the actual socket implementation. Otherwise a system-default</span>
<span class="line-added"> 476      * socket implementation is created.</span>
 477      *
 478      * &lt;p&gt;If there is a security manager, its
 479      * {@code checkConnect} method is called
 480      * with {@code host.getHostAddress()} and {@code port}
 481      * as its arguments. This could result in a SecurityException.
 482      * &lt;p&gt;
 483      * If UDP socket is used, TCP/IP related socket options will not apply.
 484      *
 485      * @param      host     the IP address.
 486      * @param      port      the port number.
 487      * @param      stream    if {@code true}, create a stream socket;
 488      *                       otherwise, create a datagram socket.
<span class="line-modified"> 489      * @throws     IOException  if an I/O error occurs when creating the socket.</span>
<span class="line-modified"> 490      * @throws     SecurityException  if a security manager exists and its</span>
 491      *             {@code checkConnect} method doesn&#39;t allow the operation.
<span class="line-modified"> 492      * @throws     IllegalArgumentException if the port parameter is outside</span>
 493      *             the specified range of valid port values, which is between
 494      *             0 and 65535, inclusive.
<span class="line-modified"> 495      * @throws     NullPointerException if {@code host} is null.</span>
 496      * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)
 497      * @see        java.net.SocketImpl
 498      * @see        java.net.SocketImplFactory#createSocketImpl()
 499      * @see        SecurityManager#checkConnect
 500      * @deprecated Use DatagramSocket instead for UDP transport.
 501      */
 502     @Deprecated
 503     public Socket(InetAddress host, int port, boolean stream) throws IOException {
 504         this(host != null ? new InetSocketAddress(host, port) : null,
 505              new InetSocketAddress(0), stream);
 506     }
 507 
 508     private Socket(SocketAddress address, SocketAddress localAddr,
 509                    boolean stream) throws IOException {
 510         setImpl();
 511 
 512         // backward compatibility
 513         if (address == null)
 514             throw new NullPointerException();
 515 
</pre>
<hr />
<pre>
 530 
 531     /**
 532      * Creates the socket implementation.
 533      *
 534      * @param stream a {@code boolean} value : {@code true} for a TCP socket,
 535      *               {@code false} for UDP.
 536      * @throws IOException if creation fails
 537      * @since 1.4
 538      */
 539      void createImpl(boolean stream) throws SocketException {
 540         if (impl == null)
 541             setImpl();
 542         try {
 543             impl.create(stream);
 544             created = true;
 545         } catch (IOException e) {
 546             throw new SocketException(e.getMessage());
 547         }
 548     }
 549 
<span class="line-modified"> 550     void setImpl(SocketImpl si) {</span>
<span class="line-modified"> 551          impl = si;</span>
























 552     }
 553 
 554     /**
 555      * Sets impl to the system-default type of SocketImpl.
 556      * @since 1.4
 557      */
 558     void setImpl() {
<span class="line-added"> 559         SocketImplFactory factory = Socket.factory;</span>
 560         if (factory != null) {
 561             impl = factory.createSocketImpl();

 562         } else {
<span class="line-modified"> 563             // create a SOCKS SocketImpl that delegates to a platform SocketImpl</span>
<span class="line-modified"> 564             SocketImpl delegate = SocketImpl.createPlatformSocketImpl(false);</span>
<span class="line-modified"> 565             impl = new SocksSocketImpl(delegate);</span>
 566         }


 567     }
 568 

 569     /**
 570      * Get the {@code SocketImpl} attached to this socket, creating
 571      * it if necessary.
 572      *
 573      * @return  the {@code SocketImpl} attached to that ServerSocket.
 574      * @throws SocketException if creation fails
 575      * @since 1.4
 576      */
 577     SocketImpl getImpl() throws SocketException {
 578         if (!created)
 579             createImpl(true);
 580         return impl;
 581     }
 582 
 583     /**
 584      * Connects this socket to the server.
 585      *
 586      * @param   endpoint the {@code SocketAddress}
 587      * @throws  IOException if an error occurs during the connection
 588      * @throws  java.nio.channels.IllegalBlockingModeException
</pre>
<hr />
<pre>
 593      * @since 1.4
 594      * @spec JSR-51
 595      */
 596     public void connect(SocketAddress endpoint) throws IOException {
 597         connect(endpoint, 0);
 598     }
 599 
 600     /**
 601      * Connects this socket to the server with a specified timeout value.
 602      * A timeout of zero is interpreted as an infinite timeout. The connection
 603      * will then block until established or an error occurs.
 604      *
 605      * @param   endpoint the {@code SocketAddress}
 606      * @param   timeout  the timeout value to be used in milliseconds.
 607      * @throws  IOException if an error occurs during the connection
 608      * @throws  SocketTimeoutException if timeout expires before connecting
 609      * @throws  java.nio.channels.IllegalBlockingModeException
 610      *          if this socket has an associated channel,
 611      *          and the channel is in non-blocking mode
 612      * @throws  IllegalArgumentException if endpoint is null or is a
<span class="line-modified"> 613      *          SocketAddress subclass not supported by this socket, or</span>
<span class="line-added"> 614      *          if {@code timeout} is negative</span>
 615      * @since 1.4
 616      * @spec JSR-51
 617      */
 618     public void connect(SocketAddress endpoint, int timeout) throws IOException {
 619         if (endpoint == null)
 620             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 621 
 622         if (timeout &lt; 0)
 623           throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
 624 
 625         if (isClosed())
 626             throw new SocketException(&quot;Socket is closed&quot;);
 627 
<span class="line-modified"> 628         if (isConnected())</span>
 629             throw new SocketException(&quot;already connected&quot;);
 630 
 631         if (!(endpoint instanceof InetSocketAddress))
 632             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 633 
 634         InetSocketAddress epoint = (InetSocketAddress) endpoint;
 635         InetAddress addr = epoint.getAddress ();
 636         int port = epoint.getPort();
 637         checkAddress(addr, &quot;connect&quot;);
 638 
 639         SecurityManager security = System.getSecurityManager();
 640         if (security != null) {
 641             if (epoint.isUnresolved())
 642                 security.checkConnect(epoint.getHostName(), port);
 643             else
 644                 security.checkConnect(addr.getHostAddress(), port);
 645         }
 646         if (!created)
 647             createImpl(true);
<span class="line-modified"> 648         impl.connect(epoint, timeout);</span>








 649         connected = true;
 650         /*
 651          * If the socket was not bound before the connect, it is now because
 652          * the kernel will have picked an ephemeral port &amp; a local address
 653          */
 654         bound = true;
 655     }
 656 
 657     /**
 658      * Binds the socket to a local address.
 659      * &lt;P&gt;
 660      * If the address is {@code null}, then the system will pick up
 661      * an ephemeral port and a valid local address to bind the socket.
 662      *
 663      * @param   bindpoint the {@code SocketAddress} to bind to
 664      * @throws  IOException if the bind operation fails, or if the socket
 665      *                     is already bound.
 666      * @throws  IllegalArgumentException if bindpoint is a
 667      *          SocketAddress subclass not supported by this socket
 668      * @throws  SecurityException  if a security manager exists and its
 669      *          {@code checkListen} method doesn&#39;t allow the bind
 670      *          to the local port.
 671      *
 672      * @since   1.4
 673      * @see #isBound
 674      */
 675     public void bind(SocketAddress bindpoint) throws IOException {
 676         if (isClosed())
 677             throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified"> 678         if (isBound())</span>
 679             throw new SocketException(&quot;Already bound&quot;);
 680 
 681         if (bindpoint != null &amp;&amp; (!(bindpoint instanceof InetSocketAddress)))
 682             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 683         InetSocketAddress epoint = (InetSocketAddress) bindpoint;
 684         if (epoint != null &amp;&amp; epoint.isUnresolved())
 685             throw new SocketException(&quot;Unresolved address&quot;);
 686         if (epoint == null) {
 687             epoint = new InetSocketAddress(0);
 688         }
 689         InetAddress addr = epoint.getAddress();
 690         int port = epoint.getPort();
 691         checkAddress (addr, &quot;bind&quot;);
 692         SecurityManager security = System.getSecurityManager();
 693         if (security != null) {
 694             security.checkListen(port);
 695         }
 696         getImpl().bind (addr, port);
 697         bound = true;
 698     }
 699 
 700     private void checkAddress (InetAddress addr, String op) {
 701         if (addr == null) {
 702             return;
 703         }
 704         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
 705             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);
 706         }
 707     }
 708 
 709     /**
 710      * set the flags after an accept() call.
 711      */
 712     final void postAccept() {
 713         connected = true;
 714         created = true;
 715         bound = true;
 716     }
 717 












 718     /**
 719      * Returns the address to which the socket is connected.
 720      * &lt;p&gt;
 721      * If the socket was connected prior to being {@link #close closed},
 722      * then this method will continue to return the connected address
 723      * after the socket is closed.
 724      *
 725      * @return  the remote IP address to which this socket is connected,
 726      *          or {@code null} if the socket is not connected.
 727      */
 728     public InetAddress getInetAddress() {
 729         if (!isConnected())
 730             return null;
 731         try {
 732             return getImpl().getInetAddress();
 733         } catch (SocketException e) {
 734         }
 735         return null;
 736     }
 737 
</pre>
<hr />
<pre>
 913      *   by the socket. Bytes that aren&#39;t discarded by the network
 914      *   software can be read using {@link java.io.InputStream#read read}.
 915      *
 916      *   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, or all
 917      *   buffered bytes have been consumed by
 918      *   {@link java.io.InputStream#read read}, then all subsequent
 919      *   calls to {@link java.io.InputStream#read read} will throw an
 920      *   {@link java.io.IOException IOException}.
 921      *
 922      *   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, and the
 923      *   socket has not been closed using {@link #close close}, then
 924      *   {@link java.io.InputStream#available available} will
 925      *   return {@code 0}.
 926      *
 927      * &lt;/ul&gt;
 928      *
 929      * &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}
 930      * will close the associated socket.
 931      *
 932      * @return     an input stream for reading bytes from this socket.
<span class="line-modified"> 933      * @throws     IOException  if an I/O error occurs when creating the</span>
 934      *             input stream, the socket is closed, the socket is
 935      *             not connected, or the socket input has been shutdown
 936      *             using {@link #shutdownInput()}
 937      *
 938      * @revised 1.4
 939      * @spec JSR-51
 940      */
 941     public InputStream getInputStream() throws IOException {
 942         if (isClosed())
 943             throw new SocketException(&quot;Socket is closed&quot;);
 944         if (!isConnected())
 945             throw new SocketException(&quot;Socket is not connected&quot;);
 946         if (isInputShutdown())
 947             throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified"> 948         InputStream in = this.in;</span>
<span class="line-modified"> 949         if (in == null) {</span>
<span class="line-modified"> 950             // wrap the input stream so that the close method closes this socket</span>
<span class="line-modified"> 951             in = new SocketInputStream(this, impl.getInputStream());</span>
<span class="line-modified"> 952             if (!IN.compareAndSet(this, null, in)) {</span>
<span class="line-modified"> 953                 in = this.in;</span>
<span class="line-modified"> 954             }</span>
<span class="line-modified"> 955         }</span>
<span class="line-modified"> 956         return in;</span>
<span class="line-modified"> 957     }</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959     /**</span>
<span class="line-added"> 960      * An InputStream that delegates read/available operations to an underlying</span>
<span class="line-added"> 961      * input stream. The close method is overridden to close the Socket.</span>
<span class="line-added"> 962      *</span>
<span class="line-added"> 963      * This class is instrumented by Java Flight Recorder (JFR) to get socket</span>
<span class="line-added"> 964      * I/O events.</span>
<span class="line-added"> 965      */</span>
<span class="line-added"> 966     private static class SocketInputStream extends InputStream {</span>
<span class="line-added"> 967         private final Socket parent;</span>
<span class="line-added"> 968         private final InputStream in;</span>
<span class="line-added"> 969 </span>
<span class="line-added"> 970         SocketInputStream(Socket parent, InputStream in) {</span>
<span class="line-added"> 971             this.parent = parent;</span>
<span class="line-added"> 972             this.in = in;</span>
<span class="line-added"> 973         }</span>
<span class="line-added"> 974         @Override</span>
<span class="line-added"> 975         public int read() throws IOException {</span>
<span class="line-added"> 976             byte[] a = new byte[1];</span>
<span class="line-added"> 977             int n = read(a, 0, 1);</span>
<span class="line-added"> 978             return (n &gt; 0) ? (a[0] &amp; 0xff) : -1;</span>
<span class="line-added"> 979         }</span>
<span class="line-added"> 980         @Override</span>
<span class="line-added"> 981         public int read(byte b[], int off, int len) throws IOException {</span>
<span class="line-added"> 982             return in.read(b, off, len);</span>
<span class="line-added"> 983         }</span>
<span class="line-added"> 984         @Override</span>
<span class="line-added"> 985         public int available() throws IOException {</span>
<span class="line-added"> 986             return in.available();</span>
<span class="line-added"> 987         }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989         @Override</span>
<span class="line-added"> 990         public void close() throws IOException {</span>
<span class="line-added"> 991             parent.close();</span>
 992         }

 993     }
 994 
 995     /**
 996      * Returns an output stream for this socket.
 997      *
 998      * &lt;p&gt; If this socket has an associated channel then the resulting output
 999      * stream delegates all of its operations to the channel.  If the channel
1000      * is in non-blocking mode then the output stream&#39;s {@code write}
1001      * operations will throw an {@link
1002      * java.nio.channels.IllegalBlockingModeException}.
1003      *
1004      * &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}
1005      * will close the associated socket.
1006      *
1007      * @return     an output stream for writing bytes to this socket.
<span class="line-modified">1008      * @throws     IOException  if an I/O error occurs when creating the</span>
1009      *               output stream or if the socket is not connected.
1010      * @revised 1.4
1011      * @spec JSR-51
1012      */
1013     public OutputStream getOutputStream() throws IOException {
1014         if (isClosed())
1015             throw new SocketException(&quot;Socket is closed&quot;);
1016         if (!isConnected())
1017             throw new SocketException(&quot;Socket is not connected&quot;);
1018         if (isOutputShutdown())
1019             throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">1020         OutputStream out = this.out;</span>
<span class="line-modified">1021         if (out == null) {</span>
<span class="line-modified">1022             // wrap the output stream so that the close method closes this socket</span>
<span class="line-modified">1023             out = new SocketOutputStream(this, impl.getOutputStream());</span>
<span class="line-modified">1024             if (!OUT.compareAndSet(this, null, out)) {</span>
<span class="line-modified">1025                 out = this.out;</span>
<span class="line-modified">1026             }</span>
<span class="line-modified">1027         }</span>
<span class="line-modified">1028         return out;</span>
<span class="line-modified">1029     }</span>
<span class="line-added">1030 </span>
<span class="line-added">1031     /**</span>
<span class="line-added">1032      * An OutputStream that delegates write operations to an underlying output</span>
<span class="line-added">1033      * stream. The close method is overridden to close the Socket.</span>
<span class="line-added">1034      *</span>
<span class="line-added">1035      * This class is instrumented by Java Flight Recorder (JFR) to get socket</span>
<span class="line-added">1036      * I/O events.</span>
<span class="line-added">1037      */</span>
<span class="line-added">1038     private static class SocketOutputStream extends OutputStream {</span>
<span class="line-added">1039         private final Socket parent;</span>
<span class="line-added">1040         private final OutputStream out;</span>
<span class="line-added">1041         SocketOutputStream(Socket parent, OutputStream out) {</span>
<span class="line-added">1042             this.parent = parent;</span>
<span class="line-added">1043             this.out = out;</span>
<span class="line-added">1044         }</span>
<span class="line-added">1045         @Override</span>
<span class="line-added">1046         public void write(int b) throws IOException {</span>
<span class="line-added">1047             byte[] a = new byte[] { (byte) b };</span>
<span class="line-added">1048             write(a, 0, 1);</span>
<span class="line-added">1049         }</span>
<span class="line-added">1050         @Override</span>
<span class="line-added">1051         public void write(byte b[], int off, int len) throws IOException {</span>
<span class="line-added">1052             out.write(b, off, len);</span>
<span class="line-added">1053         }</span>
<span class="line-added">1054 </span>
<span class="line-added">1055         @Override</span>
<span class="line-added">1056         public void close() throws IOException {</span>
<span class="line-added">1057             parent.close();</span>
1058         }

1059     }
1060 
1061     /**
1062      * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}
1063      * (disable/enable Nagle&#39;s algorithm).
1064      *
1065      * @param on {@code true} to enable TCP_NODELAY,
1066      * {@code false} to disable.
1067      *
<span class="line-modified">1068      * @throws    SocketException if there is an error</span>
1069      * in the underlying protocol, such as a TCP error.
1070      *
1071      * @since   1.1
1072      *
1073      * @see #getTcpNoDelay()
1074      */
1075     public void setTcpNoDelay(boolean on) throws SocketException {
1076         if (isClosed())
1077             throw new SocketException(&quot;Socket is closed&quot;);
1078         getImpl().setOption(SocketOptions.TCP_NODELAY, Boolean.valueOf(on));
1079     }
1080 
1081     /**
1082      * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
1083      *
1084      * @return a {@code boolean} indicating whether or not
1085      *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.
<span class="line-modified">1086      * @throws    SocketException if there is an error</span>
1087      * in the underlying protocol, such as a TCP error.
1088      * @since   1.1
1089      * @see #setTcpNoDelay(boolean)
1090      */
1091     public boolean getTcpNoDelay() throws SocketException {
1092         if (isClosed())
1093             throw new SocketException(&quot;Socket is closed&quot;);
1094         return ((Boolean) getImpl().getOption(SocketOptions.TCP_NODELAY)).booleanValue();
1095     }
1096 
1097     /**
1098      * Enable/disable {@link SocketOptions#SO_LINGER SO_LINGER} with the
1099      * specified linger time in seconds. The maximum timeout value is platform
1100      * specific.
1101      *
1102      * The setting only affects socket close.
1103      *
1104      * @param on     whether or not to linger on.
1105      * @param linger how long to linger for, if on is true.
<span class="line-modified">1106      * @throws    SocketException if there is an error</span>
1107      * in the underlying protocol, such as a TCP error.
<span class="line-modified">1108      * @throws    IllegalArgumentException if the linger value is negative.</span>
1109      * @since 1.1
1110      * @see #getSoLinger()
1111      */
1112     public void setSoLinger(boolean on, int linger) throws SocketException {
1113         if (isClosed())
1114             throw new SocketException(&quot;Socket is closed&quot;);
1115         if (!on) {
1116             getImpl().setOption(SocketOptions.SO_LINGER, on);
1117         } else {
1118             if (linger &lt; 0) {
1119                 throw new IllegalArgumentException(&quot;invalid value for SO_LINGER&quot;);
1120             }
1121             if (linger &gt; 65535)
1122                 linger = 65535;
1123             getImpl().setOption(SocketOptions.SO_LINGER, linger);
1124         }
1125     }
1126 
1127     /**
1128      * Returns setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
1129      * -1 returns implies that the
1130      * option is disabled.
1131      *
1132      * The setting only affects socket close.
1133      *
1134      * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.
<span class="line-modified">1135      * @throws    SocketException if there is an error</span>
1136      * in the underlying protocol, such as a TCP error.
1137      * @since   1.1
1138      * @see #setSoLinger(boolean, int)
1139      */
1140     public int getSoLinger() throws SocketException {
1141         if (isClosed())
1142             throw new SocketException(&quot;Socket is closed&quot;);
1143         Object o = getImpl().getOption(SocketOptions.SO_LINGER);
1144         if (o instanceof Integer) {
1145             return ((Integer) o).intValue();
1146         } else {
1147             return -1;
1148         }
1149     }
1150 
1151     /**
1152      * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
1153      * bits of the data parameter. The urgent byte is
1154      * sent after any preceding writes to the socket OutputStream
1155      * and before any future writes to the OutputStream.
1156      * @param data The byte of data to send
<span class="line-modified">1157      * @throws    IOException if there is an error</span>
1158      *  sending the data.
1159      * @since 1.4
1160      */
1161     public void sendUrgentData (int data) throws IOException  {
1162         if (!getImpl().supportsUrgentData ()) {
1163             throw new SocketException (&quot;Urgent data not supported&quot;);
1164         }
1165         getImpl().sendUrgentData (data);
1166     }
1167 
1168     /**
1169      * Enable/disable {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}
1170      * (receipt of TCP urgent data)
1171      *
1172      * By default, this option is disabled and TCP urgent data received on a
1173      * socket is silently discarded. If the user wishes to receive urgent data, then
1174      * this option must be enabled. When enabled, urgent data is received
1175      * inline with normal data.
1176      * &lt;p&gt;
1177      * Note, only limited support is provided for handling incoming urgent
1178      * data. In particular, no notification of incoming urgent data is provided
1179      * and there is no capability to distinguish between normal data and urgent
1180      * data unless provided by a higher level protocol.
1181      *
1182      * @param on {@code true} to enable
1183      *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},
1184      *           {@code false} to disable.
1185      *
<span class="line-modified">1186      * @throws    SocketException if there is an error</span>
1187      * in the underlying protocol, such as a TCP error.
1188      *
1189      * @since   1.4
1190      *
1191      * @see #getOOBInline()
1192      */
1193     public void setOOBInline(boolean on) throws SocketException {
1194         if (isClosed())
1195             throw new SocketException(&quot;Socket is closed&quot;);
1196         getImpl().setOption(SocketOptions.SO_OOBINLINE, Boolean.valueOf(on));
1197     }
1198 
1199     /**
1200      * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
1201      *
1202      * @return a {@code boolean} indicating whether or not
1203      *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.
1204      *
<span class="line-modified">1205      * @throws    SocketException if there is an error</span>
1206      * in the underlying protocol, such as a TCP error.
1207      * @since   1.4
1208      * @see #setOOBInline(boolean)
1209      */
1210     public boolean getOOBInline() throws SocketException {
1211         if (isClosed())
1212             throw new SocketException(&quot;Socket is closed&quot;);
1213         return ((Boolean) getImpl().getOption(SocketOptions.SO_OOBINLINE)).booleanValue();
1214     }
1215 
1216     /**
1217      *  Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
1218      *  with the specified timeout, in milliseconds. With this option set
<span class="line-modified">1219      *  to a positive timeout value, a read() call on the InputStream associated with</span>
1220      *  this Socket will block for only this amount of time.  If the timeout
1221      *  expires, a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<span class="line-modified">1222      *  Socket is still valid. A timeout of zero is interpreted as an infinite timeout.</span>
<span class="line-modified">1223      *  The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking operation</span>
<span class="line-modified">1224      *  to have effect.</span>

1225      *
1226      * @param timeout the specified timeout, in milliseconds.
<span class="line-modified">1227      * @throws  SocketException if there is an error in the underlying protocol,</span>
<span class="line-modified">1228      *          such as a TCP error</span>
<span class="line-added">1229      * @throws  IllegalArgumentException if {@code timeout} is negative</span>
1230      * @since   1.1
1231      * @see #getSoTimeout()
1232      */
1233     public synchronized void setSoTimeout(int timeout) throws SocketException {
1234         if (isClosed())
1235             throw new SocketException(&quot;Socket is closed&quot;);
1236         if (timeout &lt; 0)
1237           throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);
1238 
1239         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
1240     }
1241 
1242     /**
1243      * Returns setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
1244      * 0 returns implies that the option is disabled (i.e., timeout of infinity).
1245      *
1246      * @return the setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}
<span class="line-modified">1247      * @throws    SocketException if there is an error</span>
1248      * in the underlying protocol, such as a TCP error.
1249      *
1250      * @since   1.1
1251      * @see #setSoTimeout(int)
1252      */
1253     public synchronized int getSoTimeout() throws SocketException {
1254         if (isClosed())
1255             throw new SocketException(&quot;Socket is closed&quot;);
1256         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
1257         /* extra type safety */
1258         if (o instanceof Integer) {
1259             return ((Integer) o).intValue();
1260         } else {
1261             return 0;
1262         }
1263     }
1264 
1265     /**
1266      * Sets the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option to the
1267      * specified value for this {@code Socket}.
1268      * The {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option is used by the
1269      * platform&#39;s networking code as a hint for the size to set the underlying
1270      * network I/O buffers.
1271      *
1272      * &lt;p&gt;Because {@link SocketOptions#SO_SNDBUF SO_SNDBUF} is a hint,
1273      * applications that want to verify what size the buffers were set to
1274      * should call {@link #getSendBufferSize()}.
1275      *
<span class="line-modified">1276      * @throws    SocketException if there is an error</span>
1277      * in the underlying protocol, such as a TCP error.
1278      *
1279      * @param size the size to which to set the send buffer
1280      * size. This value must be greater than 0.
1281      *
<span class="line-modified">1282      * @throws    IllegalArgumentException if the</span>
1283      * value is 0 or is negative.
1284      *
1285      * @see #getSendBufferSize()
1286      * @since 1.2
1287      */
1288     public synchronized void setSendBufferSize(int size)
1289     throws SocketException{
1290         if (!(size &gt; 0)) {
1291             throw new IllegalArgumentException(&quot;negative send size&quot;);
1292         }
1293         if (isClosed())
1294             throw new SocketException(&quot;Socket is closed&quot;);
1295         getImpl().setOption(SocketOptions.SO_SNDBUF, size);
1296     }
1297 
1298     /**
1299      * Get value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF} option
1300      * for this {@code Socket}, that is the buffer size used by the platform
1301      * for output on this {@code Socket}.
1302      * @return the value of the {@link SocketOptions#SO_SNDBUF SO_SNDBUF}
1303      *         option for this {@code Socket}.
1304      *
<span class="line-modified">1305      * @throws    SocketException if there is an error</span>
1306      * in the underlying protocol, such as a TCP error.
1307      *
1308      * @see #setSendBufferSize(int)
1309      * @since 1.2
1310      */
1311     public synchronized int getSendBufferSize() throws SocketException {
1312         if (isClosed())
1313             throw new SocketException(&quot;Socket is closed&quot;);
1314         int result = 0;
1315         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
1316         if (o instanceof Integer) {
1317             result = ((Integer)o).intValue();
1318         }
1319         return result;
1320     }
1321 
1322     /**
1323      * Sets the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option to the
1324      * specified value for this {@code Socket}. The
1325      * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option is
</pre>
<hr />
<pre>
1332      *
1333      * &lt;p&gt;Because {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is a hint,
1334      * applications that want to verify what size the buffers were set to
1335      * should call {@link #getReceiveBufferSize()}.
1336      *
1337      * &lt;p&gt;The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is also used
1338      * to set the TCP receive window that is advertised to the remote peer.
1339      * Generally, the window size can be modified at any time when a socket is
1340      * connected. However, if a receive window larger than 64K is required then
1341      * this must be requested &lt;B&gt;before&lt;/B&gt; the socket is connected to the
1342      * remote peer. There are two cases to be aware of:
1343      * &lt;ol&gt;
1344      * &lt;li&gt;For sockets accepted from a ServerSocket, this must be done by calling
1345      * {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket
1346      * is bound to a local address.&lt;/li&gt;
1347      * &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
1348      * connecting the socket to its remote peer.&lt;/li&gt;&lt;/ol&gt;
1349      * @param size the size to which to set the receive buffer
1350      * size. This value must be greater than 0.
1351      *
<span class="line-modified">1352      * @throws    IllegalArgumentException if the value is 0 or is</span>
1353      * negative.
1354      *
<span class="line-modified">1355      * @throws    SocketException if there is an error</span>
1356      * in the underlying protocol, such as a TCP error.
1357      *
1358      * @see #getReceiveBufferSize()
1359      * @see ServerSocket#setReceiveBufferSize(int)
1360      * @since 1.2
1361      */
1362     public synchronized void setReceiveBufferSize(int size)
1363     throws SocketException{
1364         if (size &lt;= 0) {
1365             throw new IllegalArgumentException(&quot;invalid receive size&quot;);
1366         }
1367         if (isClosed())
1368             throw new SocketException(&quot;Socket is closed&quot;);
1369         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
1370     }
1371 
1372     /**
1373      * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
1374      * for this {@code Socket}, that is the buffer size used by the platform
1375      * for input on this {@code Socket}.
1376      *
1377      * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
1378      *         option for this {@code Socket}.
<span class="line-modified">1379      * @throws    SocketException if there is an error</span>
1380      * in the underlying protocol, such as a TCP error.
1381      * @see #setReceiveBufferSize(int)
1382      * @since 1.2
1383      */
1384     public synchronized int getReceiveBufferSize()
1385     throws SocketException{
1386         if (isClosed())
1387             throw new SocketException(&quot;Socket is closed&quot;);
1388         int result = 0;
1389         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
1390         if (o instanceof Integer) {
1391             result = ((Integer)o).intValue();
1392         }
1393         return result;
1394     }
1395 
1396     /**
1397      * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.
1398      *
1399      * @param on  whether or not to have socket keep alive turned on.
<span class="line-modified">1400      * @throws    SocketException if there is an error</span>
1401      * in the underlying protocol, such as a TCP error.
1402      * @since 1.3
1403      * @see #getKeepAlive()
1404      */
1405     public void setKeepAlive(boolean on) throws SocketException {
1406         if (isClosed())
1407             throw new SocketException(&quot;Socket is closed&quot;);
1408         getImpl().setOption(SocketOptions.SO_KEEPALIVE, Boolean.valueOf(on));
1409     }
1410 
1411     /**
1412      * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
1413      *
1414      * @return a {@code boolean} indicating whether or not
1415      *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.
<span class="line-modified">1416      * @throws    SocketException if there is an error</span>
1417      * in the underlying protocol, such as a TCP error.
1418      * @since   1.3
1419      * @see #setKeepAlive(boolean)
1420      */
1421     public boolean getKeepAlive() throws SocketException {
1422         if (isClosed())
1423             throw new SocketException(&quot;Socket is closed&quot;);
1424         return ((Boolean) getImpl().getOption(SocketOptions.SO_KEEPALIVE)).booleanValue();
1425     }
1426 
1427     /**
1428      * Sets traffic class or type-of-service octet in the IP
1429      * header for packets sent from this Socket.
1430      * As the underlying network implementation may ignore this
1431      * value applications should consider it a hint.
1432      *
1433      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
1434      * 255} or an IllegalArgumentException will be thrown.
1435      * &lt;p&gt;Notes:
1436      * &lt;p&gt;For Internet Protocol v4 the value consists of an
</pre>
<hr />
<pre>
1515      * is closed (typically known as the {@code TIME_WAIT} state
1516      * or {@code 2MSL} wait state).
1517      * For applications using a well known socket address or port
1518      * it may not be possible to bind a socket to the required
1519      * {@code SocketAddress} if there is a connection in the
1520      * timeout state involving the socket address or port.
1521      * &lt;p&gt;
1522      * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
1523      * prior to binding the socket using {@link #bind(SocketAddress)} allows
1524      * the socket to be bound even though a previous connection is in a timeout
1525      * state.
1526      * &lt;p&gt;
1527      * When a {@code Socket} is created the initial setting
1528      * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is disabled.
1529      * &lt;p&gt;
1530      * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
1531      * enabled or disabled after a socket is bound (See {@link #isBound()})
1532      * is not defined.
1533      *
1534      * @param on  whether to enable or disable the socket option
<span class="line-modified">1535      * @throws    SocketException if an error occurs enabling or</span>
1536      *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
1537      *            socket option, or the socket is closed.
1538      * @since 1.4
1539      * @see #getReuseAddress()
1540      * @see #bind(SocketAddress)
1541      * @see #isClosed()
1542      * @see #isBound()
1543      */
1544     public void setReuseAddress(boolean on) throws SocketException {
1545         if (isClosed())
1546             throw new SocketException(&quot;Socket is closed&quot;);
1547         getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
1548     }
1549 
1550     /**
1551      * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
1552      *
1553      * @return a {@code boolean} indicating whether or not
1554      *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<span class="line-modified">1555      * @throws    SocketException if there is an error</span>
1556      * in the underlying protocol, such as a TCP error.
1557      * @since   1.4
1558      * @see #setReuseAddress(boolean)
1559      */
1560     public boolean getReuseAddress() throws SocketException {
1561         if (isClosed())
1562             throw new SocketException(&quot;Socket is closed&quot;);
1563         return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();
1564     }
1565 
1566     /**
1567      * Closes this socket.
1568      * &lt;p&gt;
1569      * Any thread currently blocked in an I/O operation upon this socket
1570      * will throw a {@link SocketException}.
1571      * &lt;p&gt;
1572      * Once a socket has been closed, it is not available for further networking
1573      * use (i.e. can&#39;t be reconnected or rebound). A new socket needs to be
1574      * created.
1575      *
1576      * &lt;p&gt; Closing this socket will also close the socket&#39;s
1577      * {@link java.io.InputStream InputStream} and
1578      * {@link java.io.OutputStream OutputStream}.
1579      *
1580      * &lt;p&gt; If this socket has an associated channel then the channel is closed
1581      * as well.
1582      *
<span class="line-modified">1583      * @throws     IOException  if an I/O error occurs when closing this socket.</span>
1584      * @revised 1.4
1585      * @spec JSR-51
1586      * @see #isClosed
1587      */
1588     public synchronized void close() throws IOException {
1589         synchronized(closeLock) {
1590             if (isClosed())
1591                 return;
1592             if (created)
1593                 impl.close();
1594             closed = true;
1595         }
1596     }
1597 
1598     /**
1599      * Places the input stream for this socket at &quot;end of stream&quot;.
1600      * Any data sent to the input stream side of the socket is acknowledged
1601      * and then silently discarded.
1602      * &lt;p&gt;
1603      * If you read from a socket input stream after invoking this method on the
1604      * socket, the stream&#39;s {@code available} method will return 0, and its
1605      * {@code read} methods will return {@code -1} (end of stream).
1606      *
<span class="line-modified">1607      * @throws    IOException if an I/O error occurs when shutting down this</span>
1608      * socket.
1609      *
1610      * @since 1.3
1611      * @see java.net.Socket#shutdownOutput()
1612      * @see java.net.Socket#close()
1613      * @see java.net.Socket#setSoLinger(boolean, int)
1614      * @see #isInputShutdown
1615      */
1616     public void shutdownInput() throws IOException
1617     {
1618         if (isClosed())
1619             throw new SocketException(&quot;Socket is closed&quot;);
1620         if (!isConnected())
1621             throw new SocketException(&quot;Socket is not connected&quot;);
1622         if (isInputShutdown())
1623             throw new SocketException(&quot;Socket input is already shutdown&quot;);
1624         getImpl().shutdownInput();
1625         shutIn = true;
1626     }
1627 
1628     /**
1629      * Disables the output stream for this socket.
1630      * For a TCP socket, any previously written data will be sent
1631      * followed by TCP&#39;s normal connection termination sequence.
1632      *
1633      * If you write to a socket output stream after invoking
1634      * shutdownOutput() on the socket, the stream will throw
1635      * an IOException.
1636      *
<span class="line-modified">1637      * @throws    IOException if an I/O error occurs when shutting down this</span>
1638      * socket.
1639      *
1640      * @since 1.3
1641      * @see java.net.Socket#shutdownInput()
1642      * @see java.net.Socket#close()
1643      * @see java.net.Socket#setSoLinger(boolean, int)
1644      * @see #isOutputShutdown
1645      */
1646     public void shutdownOutput() throws IOException
1647     {
1648         if (isClosed())
1649             throw new SocketException(&quot;Socket is closed&quot;);
1650         if (!isConnected())
1651             throw new SocketException(&quot;Socket is not connected&quot;);
1652         if (isOutputShutdown())
1653             throw new SocketException(&quot;Socket output is already shutdown&quot;);
1654         getImpl().shutdownOutput();
1655         shutOut = true;
1656     }
1657 
</pre>
<hr />
<pre>
1666                 return &quot;Socket[addr=&quot; + getImpl().getInetAddress() +
1667                     &quot;,port=&quot; + getImpl().getPort() +
1668                     &quot;,localport=&quot; + getImpl().getLocalPort() + &quot;]&quot;;
1669         } catch (SocketException e) {
1670         }
1671         return &quot;Socket[unconnected]&quot;;
1672     }
1673 
1674     /**
1675      * Returns the connection state of the socket.
1676      * &lt;p&gt;
1677      * Note: Closing a socket doesn&#39;t clear its connection state, which means
1678      * this method will return {@code true} for a closed socket
1679      * (see {@link #isClosed()}) if it was successfully connected prior
1680      * to being closed.
1681      *
1682      * @return true if the socket was successfully connected to a server
1683      * @since 1.4
1684      */
1685     public boolean isConnected() {
<span class="line-modified">1686         return connected;</span>

1687     }
1688 
1689     /**
1690      * Returns the binding state of the socket.
1691      * &lt;p&gt;
1692      * Note: Closing a socket doesn&#39;t clear its binding state, which means
1693      * this method will return {@code true} for a closed socket
1694      * (see {@link #isClosed()}) if it was successfully bound prior
1695      * to being closed.
1696      *
1697      * @return true if the socket was successfully bound to an address
1698      * @since 1.4
1699      * @see #bind
1700      */
1701     public boolean isBound() {
<span class="line-modified">1702         return bound;</span>

1703     }
1704 
1705     /**
1706      * Returns the closed state of the socket.
1707      *
1708      * @return true if the socket has been closed
1709      * @since 1.4
1710      * @see #close
1711      */
1712     public boolean isClosed() {
1713         synchronized(closeLock) {
1714             return closed;
1715         }
1716     }
1717 
1718     /**
1719      * Returns whether the read-half of the socket connection is closed.
1720      *
1721      * @return true if the input of the socket has been shutdown
1722      * @since 1.4
1723      * @see #shutdownInput
1724      */
1725     public boolean isInputShutdown() {
1726         return shutIn;
1727     }
1728 
1729     /**
1730      * Returns whether the write-half of the socket connection is closed.
1731      *
1732      * @return true if the output of the socket has been shutdown
1733      * @since 1.4
1734      * @see #shutdownOutput
1735      */
1736     public boolean isOutputShutdown() {
1737         return shutOut;
1738     }
1739 
1740     /**
1741      * The factory for all client sockets.
1742      */
<span class="line-modified">1743     private static volatile SocketImplFactory factory;</span>
<span class="line-added">1744 </span>
<span class="line-added">1745     static SocketImplFactory socketImplFactory() {</span>
<span class="line-added">1746         return factory;</span>
<span class="line-added">1747     }</span>
1748 
1749     /**
1750      * Sets the client socket implementation factory for the
1751      * application. The factory can be specified only once.
1752      * &lt;p&gt;
1753      * When an application creates a new client socket, the socket
1754      * implementation factory&#39;s {@code createSocketImpl} method is
1755      * called to create the actual socket implementation.
1756      * &lt;p&gt;
1757      * Passing {@code null} to the method is a no-op unless the factory
1758      * was already set.
1759      * &lt;p&gt;If there is a security manager, this method first calls
1760      * the security manager&#39;s {@code checkSetFactory} method
1761      * to ensure the operation is allowed.
1762      * This could result in a SecurityException.
1763      *
1764      * @param      fac   the desired factory.
<span class="line-modified">1765      * @throws     IOException  if an I/O error occurs when setting the</span>
1766      *               socket factory.
<span class="line-modified">1767      * @throws     SocketException  if the factory is already defined.</span>
<span class="line-modified">1768      * @throws     SecurityException  if a security manager exists and its</span>
1769      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1770      * @see        java.net.SocketImplFactory#createSocketImpl()
1771      * @see        SecurityManager#checkSetFactory
1772      */
1773     public static synchronized void setSocketImplFactory(SocketImplFactory fac)
1774         throws IOException
1775     {
1776         if (factory != null) {
1777             throw new SocketException(&quot;factory already defined&quot;);
1778         }
1779         SecurityManager security = System.getSecurityManager();
1780         if (security != null) {
1781             security.checkSetFactory();
1782         }
1783         factory = fac;
1784     }
1785 
1786     /**
1787      * Sets performance preferences for this socket.
1788      *
</pre>
<hr />
<pre>
1840      *
1841      * @throws UnsupportedOperationException if the socket does not support
1842      *         the option.
1843      *
1844      * @throws IllegalArgumentException if the value is not valid for
1845      *         the option.
1846      *
1847      * @throws IOException if an I/O error occurs, or if the socket is closed.
1848      *
1849      * @throws NullPointerException if name is {@code null}
1850      *
1851      * @throws SecurityException if a security manager is set and if the socket
1852      *         option requires a security permission and if the caller does
1853      *         not have the required permission.
1854      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1855      *         do not require any security permission.
1856      *
1857      * @since 9
1858      */
1859     public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="line-added">1860         Objects.requireNonNull(name);</span>
<span class="line-added">1861         if (isClosed())</span>
<span class="line-added">1862             throw new SocketException(&quot;Socket is closed&quot;);</span>
1863         getImpl().setOption(name, value);
1864         return this;
1865     }
1866 
1867     /**
1868      * Returns the value of a socket option.
1869      *
1870      * @param &lt;T&gt; The type of the socket option value
1871      * @param name The socket option
1872      *
1873      * @return The value of the socket option.
1874      *
1875      * @throws UnsupportedOperationException if the socket does not support
1876      *         the option.
1877      *
1878      * @throws IOException if an I/O error occurs, or if the socket is closed.
1879      *
1880      * @throws NullPointerException if name is {@code null}
1881      *
1882      * @throws SecurityException if a security manager is set and if the socket
1883      *         option requires a security permission and if the caller does
1884      *         not have the required permission.
1885      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1886      *         do not require any security permission.
1887      *
1888      * @since 9
1889      */
1890     @SuppressWarnings(&quot;unchecked&quot;)
1891     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-added">1892         Objects.requireNonNull(name);</span>
<span class="line-added">1893         if (isClosed())</span>
<span class="line-added">1894             throw new SocketException(&quot;Socket is closed&quot;);</span>
1895         return getImpl().getOption(name);
1896     }
1897 
1898     // cache of unmodifiable impl options. Possibly set racy, in impl we trust
1899     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
1900 
1901     /**
1902      * Returns a set of the socket options supported by this socket.
1903      *
1904      * This method will continue to return the set of options even after
1905      * the socket has been closed.
1906      *
1907      * @return A set of the socket options supported by this socket. This set
1908      *         may be empty if the socket&#39;s SocketImpl cannot be created.
1909      *
1910      * @since 9
1911      */
1912     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1913         Set&lt;SocketOption&lt;?&gt;&gt; so = options;
1914         if (so != null)
</pre>
</td>
</tr>
</table>
<center><a href="ServerSocket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
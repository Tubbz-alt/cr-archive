<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/RecursiveTask.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PriorityBlockingQueue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorService.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/RecursiveTask.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
54  *   }
55  * }}&lt;/pre&gt;
56  *
57  * However, besides being a dumb way to compute Fibonacci functions
58  * (there is a simple fast linear algorithm that you&#39;d use in
59  * practice), this is likely to perform poorly because the smallest
60  * subtasks are too small to be worthwhile splitting up. Instead, as
61  * is the case for nearly all fork/join applications, you&#39;d pick some
62  * minimum granularity size (for example 10 here) for which you always
63  * sequentially solve rather than subdividing.
64  *
65  * @since 1.7
66  * @author Doug Lea
67  */
68 public abstract class RecursiveTask&lt;V&gt; extends ForkJoinTask&lt;V&gt; {
69     private static final long serialVersionUID = 5232453952276485270L;
70 
71     /**
72      * The result of the computation.
73      */

74     V result;
75 
76     /**
77      * The main computation performed by this task.
78      * @return the result of the computation
79      */
80     protected abstract V compute();
81 
82     public final V getRawResult() {
83         return result;
84     }
85 
86     protected final void setRawResult(V value) {
87         result = value;
88     }
89 
90     /**
91      * Implements execution conventions for RecursiveTask.
92      */
93     protected final boolean exec() {
</pre>
</td>
<td>
<hr />
<pre>
54  *   }
55  * }}&lt;/pre&gt;
56  *
57  * However, besides being a dumb way to compute Fibonacci functions
58  * (there is a simple fast linear algorithm that you&#39;d use in
59  * practice), this is likely to perform poorly because the smallest
60  * subtasks are too small to be worthwhile splitting up. Instead, as
61  * is the case for nearly all fork/join applications, you&#39;d pick some
62  * minimum granularity size (for example 10 here) for which you always
63  * sequentially solve rather than subdividing.
64  *
65  * @since 1.7
66  * @author Doug Lea
67  */
68 public abstract class RecursiveTask&lt;V&gt; extends ForkJoinTask&lt;V&gt; {
69     private static final long serialVersionUID = 5232453952276485270L;
70 
71     /**
72      * The result of the computation.
73      */
<span class="line-added">74     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
75     V result;
76 
77     /**
78      * The main computation performed by this task.
79      * @return the result of the computation
80      */
81     protected abstract V compute();
82 
83     public final V getRawResult() {
84         return result;
85     }
86 
87     protected final void setRawResult(V value) {
88         result = value;
89     }
90 
91     /**
92      * Implements execution conventions for RecursiveTask.
93      */
94     protected final boolean exec() {
</pre>
</td>
</tr>
</table>
<center><a href="PriorityBlockingQueue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ScheduledExecutorService.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/SecurityManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Short.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/SecurityManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,26 ***</span>
   * sensitive operation, what the operation is and whether
   * it is being attempted in a security context that allows the
   * operation to be performed. The
   * application can allow or disallow the operation.
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;SecurityManager&lt;/code&gt; class contains many methods with</span>
<span class="line-modified">!  * names that begin with the word &lt;code&gt;check&lt;/code&gt;. These methods</span>
   * are called by various methods in the Java libraries before those
   * methods perform certain potentially sensitive operations. The
<span class="line-modified">!  * invocation of such a &lt;code&gt;check&lt;/code&gt; method typically looks like this:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   *     SecurityManager security = System.getSecurityManager();
   *     if (security != null) {
   *         security.check&lt;i&gt;XXX&lt;/i&gt;(argument, &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.&amp;nbsp;);
   *     }
   * &lt;/pre&gt;&lt;/blockquote&gt;
   * &lt;p&gt;
   * The security manager is thereby given an opportunity to prevent
   * completion of the operation by throwing an exception. A security
   * manager routine simply returns if the operation is permitted, but
<span class="line-modified">!  * throws a &lt;code&gt;SecurityException&lt;/code&gt; if the operation is not</span>
   * permitted.
   * &lt;p&gt;
   * Environments using a security manager will typically set the security
   * manager at startup. In the JDK implementation, this is done by setting
   * the system property {@code java.security.manager} on the command line to
<span class="line-new-header">--- 58,26 ---</span>
   * sensitive operation, what the operation is and whether
   * it is being attempted in a security context that allows the
   * operation to be performed. The
   * application can allow or disallow the operation.
   * &lt;p&gt;
<span class="line-modified">!  * The {@code SecurityManager} class contains many methods with</span>
<span class="line-modified">!  * names that begin with the word {@code check}. These methods</span>
   * are called by various methods in the Java libraries before those
   * methods perform certain potentially sensitive operations. The
<span class="line-modified">!  * invocation of such a {@code check} method typically looks like this:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   *     SecurityManager security = System.getSecurityManager();
   *     if (security != null) {
   *         security.check&lt;i&gt;XXX&lt;/i&gt;(argument, &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.&amp;nbsp;);
   *     }
   * &lt;/pre&gt;&lt;/blockquote&gt;
   * &lt;p&gt;
   * The security manager is thereby given an opportunity to prevent
   * completion of the operation by throwing an exception. A security
   * manager routine simply returns if the operation is permitted, but
<span class="line-modified">!  * throws a {@code SecurityException} if the operation is not</span>
   * permitted.
   * &lt;p&gt;
   * Environments using a security manager will typically set the security
   * manager at startup. In the JDK implementation, this is done by setting
   * the system property {@code java.security.manager} on the command line to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,31 ***</span>
   *   AccessController.checkPermission(perm);
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * If a requested access is allowed,
<span class="line-modified">!  * &lt;code&gt;checkPermission&lt;/code&gt; returns quietly. If denied, a</span>
<span class="line-modified">!  * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</span>
   * &lt;p&gt;
   * The default implementation of each of the other
<span class="line-modified">!  * &lt;code&gt;check&lt;/code&gt; methods in &lt;code&gt;SecurityManager&lt;/code&gt; is to</span>
<span class="line-modified">!  * call the &lt;code&gt;SecurityManager checkPermission&lt;/code&gt; method</span>
   * to determine if the calling thread has permission to perform the requested
   * operation.
   * &lt;p&gt;
<span class="line-modified">!  * Note that the &lt;code&gt;checkPermission&lt;/code&gt; method with</span>
   * just a single permission argument always performs security checks
   * within the context of the currently executing thread.
   * Sometimes a security check that should be made within a given context
   * will actually need to be done from within a
   * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
   * The {@link SecurityManager#getSecurityContext getSecurityContext} method
   * and the {@link SecurityManager#checkPermission(java.security.Permission,
   * java.lang.Object) checkPermission}
   * method that includes a context argument are provided
   * for this situation. The
<span class="line-modified">!  * &lt;code&gt;getSecurityContext&lt;/code&gt; method returns a &quot;snapshot&quot;</span>
   * of the current calling context. (The default implementation
   * returns an AccessControlContext object.) A sample call is
   * the following:
   *
   * &lt;pre&gt;
<span class="line-new-header">--- 183,31 ---</span>
   *   AccessController.checkPermission(perm);
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
   * If a requested access is allowed,
<span class="line-modified">!  * {@code checkPermission} returns quietly. If denied, a</span>
<span class="line-modified">!  * {@code SecurityException} is thrown.</span>
   * &lt;p&gt;
   * The default implementation of each of the other
<span class="line-modified">!  * {@code check} methods in {@code SecurityManager} is to</span>
<span class="line-modified">!  * call the {@code SecurityManager checkPermission} method</span>
   * to determine if the calling thread has permission to perform the requested
   * operation.
   * &lt;p&gt;
<span class="line-modified">!  * Note that the {@code checkPermission} method with</span>
   * just a single permission argument always performs security checks
   * within the context of the currently executing thread.
   * Sometimes a security check that should be made within a given context
   * will actually need to be done from within a
   * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
   * The {@link SecurityManager#getSecurityContext getSecurityContext} method
   * and the {@link SecurityManager#checkPermission(java.security.Permission,
   * java.lang.Object) checkPermission}
   * method that includes a context argument are provided
   * for this situation. The
<span class="line-modified">!  * {@code getSecurityContext} method returns a &quot;snapshot&quot;</span>
   * of the current calling context. (The default implementation
   * returns an AccessControlContext object.) A sample call is
   * the following:
   *
   * &lt;pre&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,79 ***</span>
   *   SecurityManager sm = System.getSecurityManager();
   *   if (sm != null) context = sm.getSecurityContext();
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;checkPermission&lt;/code&gt; method</span>
   * that takes a context object in addition to a permission
   * makes access decisions based on that context,
   * rather than on that of the current execution thread.
   * Code within a different context can thus call that method,
   * passing the permission and the
   * previously-saved context object. A sample call, using the
<span class="line-modified">!  * SecurityManager &lt;code&gt;sm&lt;/code&gt; obtained as in the previous example,</span>
   * is the following:
   *
   * &lt;pre&gt;
   *   if (sm != null) sm.checkPermission(permission, context);
   * &lt;/pre&gt;
   *
   * &lt;p&gt;Permissions fall into these categories: File, Socket, Net,
   * Security, Runtime, Property, AWT, Reflect, and Serializable.
   * The classes managing these various
<span class="line-modified">!  * permission categories are &lt;code&gt;java.io.FilePermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.net.SocketPermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.net.NetPermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.security.SecurityPermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.util.PropertyPermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.awt.AWTPermission&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;java.lang.reflect.ReflectPermission&lt;/code&gt;, and</span>
<span class="line-modified">!  * &lt;code&gt;java.io.SerializablePermission&lt;/code&gt;.</span>
   *
   * &lt;p&gt;All but the first two (FilePermission and SocketPermission) are
<span class="line-modified">!  * subclasses of &lt;code&gt;java.security.BasicPermission&lt;/code&gt;, which itself</span>
   * is an abstract subclass of the
   * top-level class for permissions, which is
<span class="line-modified">!  * &lt;code&gt;java.security.Permission&lt;/code&gt;. BasicPermission defines the</span>
   * functionality needed for all permissions that contain a name
   * that follows the hierarchical property naming convention
   * (for example, &quot;exitVM&quot;, &quot;setFactory&quot;, &quot;queuePrintJob&quot;, etc).
   * An asterisk
   * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
   * signify a wildcard match. For example: &quot;a.*&quot; or &quot;*&quot; is valid,
   * &quot;*a&quot; or &quot;a*b&quot; is not valid.
   *
   * &lt;p&gt;FilePermission and SocketPermission are subclasses of the
   * top-level class for permissions
<span class="line-modified">!  * (&lt;code&gt;java.security.Permission&lt;/code&gt;). Classes like these</span>
   * that have a more complicated name syntax than that used by
   * BasicPermission subclass directly from Permission rather than from
   * BasicPermission. For example,
<span class="line-modified">!  * for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the permission name is</span>
   * the path name of a file (or directory).
   *
   * &lt;p&gt;Some of the permission classes have an &quot;actions&quot; list that tells
   * the actions that are permitted for the object.  For example,
<span class="line-modified">!  * for a &lt;code&gt;java.io.FilePermission&lt;/code&gt; object, the actions list</span>
   * (such as &quot;read, write&quot;) specifies which actions are granted for the
   * specified file (or for files in the specified directory).
   *
   * &lt;p&gt;Other permission classes are for &quot;named&quot; permissions -
   * ones that contain a name but no actions list; you either have the
   * named permission or you don&#39;t.
   *
<span class="line-modified">!  * &lt;p&gt;Note: There is also a &lt;code&gt;java.security.AllPermission&lt;/code&gt;</span>
   * permission that implies all permissions. It exists to simplify the work
   * of system administrators who might need to perform multiple
   * tasks that require all (or numerous) permissions.
   * &lt;p&gt;
   * See {@extLink security_guide_permissions
   * Permissions in the Java Development Kit (JDK)}
   * for permission-related information.
   * This document includes a table listing the various SecurityManager
<span class="line-modified">!  * &lt;code&gt;check&lt;/code&gt; methods and the permission(s) the default</span>
   * implementation of each such method requires.
   * It also contains a table of the methods
   * that require permissions, and for each such method tells
   * which permission it requires.
   *
<span class="line-new-header">--- 215,79 ---</span>
   *   SecurityManager sm = System.getSecurityManager();
   *   if (sm != null) context = sm.getSecurityContext();
   * &lt;/pre&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * The {@code checkPermission} method</span>
   * that takes a context object in addition to a permission
   * makes access decisions based on that context,
   * rather than on that of the current execution thread.
   * Code within a different context can thus call that method,
   * passing the permission and the
   * previously-saved context object. A sample call, using the
<span class="line-modified">!  * SecurityManager {@code sm} obtained as in the previous example,</span>
   * is the following:
   *
   * &lt;pre&gt;
   *   if (sm != null) sm.checkPermission(permission, context);
   * &lt;/pre&gt;
   *
   * &lt;p&gt;Permissions fall into these categories: File, Socket, Net,
   * Security, Runtime, Property, AWT, Reflect, and Serializable.
   * The classes managing these various
<span class="line-modified">!  * permission categories are {@code java.io.FilePermission},</span>
<span class="line-modified">!  * {@code java.net.SocketPermission},</span>
<span class="line-modified">!  * {@code java.net.NetPermission},</span>
<span class="line-modified">!  * {@code java.security.SecurityPermission},</span>
<span class="line-modified">!  * {@code java.lang.RuntimePermission},</span>
<span class="line-modified">!  * {@code java.util.PropertyPermission},</span>
<span class="line-modified">!  * {@code java.awt.AWTPermission},</span>
<span class="line-modified">!  * {@code java.lang.reflect.ReflectPermission}, and</span>
<span class="line-modified">!  * {@code java.io.SerializablePermission}.</span>
   *
   * &lt;p&gt;All but the first two (FilePermission and SocketPermission) are
<span class="line-modified">!  * subclasses of {@code java.security.BasicPermission}, which itself</span>
   * is an abstract subclass of the
   * top-level class for permissions, which is
<span class="line-modified">!  * {@code java.security.Permission}. BasicPermission defines the</span>
   * functionality needed for all permissions that contain a name
   * that follows the hierarchical property naming convention
   * (for example, &quot;exitVM&quot;, &quot;setFactory&quot;, &quot;queuePrintJob&quot;, etc).
   * An asterisk
   * may appear at the end of the name, following a &quot;.&quot;, or by itself, to
   * signify a wildcard match. For example: &quot;a.*&quot; or &quot;*&quot; is valid,
   * &quot;*a&quot; or &quot;a*b&quot; is not valid.
   *
   * &lt;p&gt;FilePermission and SocketPermission are subclasses of the
   * top-level class for permissions
<span class="line-modified">!  * ({@code java.security.Permission}). Classes like these</span>
   * that have a more complicated name syntax than that used by
   * BasicPermission subclass directly from Permission rather than from
   * BasicPermission. For example,
<span class="line-modified">!  * for a {@code java.io.FilePermission} object, the permission name is</span>
   * the path name of a file (or directory).
   *
   * &lt;p&gt;Some of the permission classes have an &quot;actions&quot; list that tells
   * the actions that are permitted for the object.  For example,
<span class="line-modified">!  * for a {@code java.io.FilePermission} object, the actions list</span>
   * (such as &quot;read, write&quot;) specifies which actions are granted for the
   * specified file (or for files in the specified directory).
   *
   * &lt;p&gt;Other permission classes are for &quot;named&quot; permissions -
   * ones that contain a name but no actions list; you either have the
   * named permission or you don&#39;t.
   *
<span class="line-modified">!  * &lt;p&gt;Note: There is also a {@code java.security.AllPermission}</span>
   * permission that implies all permissions. It exists to simplify the work
   * of system administrators who might need to perform multiple
   * tasks that require all (or numerous) permissions.
   * &lt;p&gt;
   * See {@extLink security_guide_permissions
   * Permissions in the Java Development Kit (JDK)}
   * for permission-related information.
   * This document includes a table listing the various SecurityManager
<span class="line-modified">!  * {@code check} methods and the permission(s) the default</span>
   * implementation of each such method requires.
   * It also contains a table of the methods
   * that require permissions, and for each such method tells
   * which permission it requires.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,21 ***</span>
       * Have we been initialized. Effective against finalizer attacks.
       */
      private boolean initialized = false;
  
      /**
<span class="line-modified">!      * Constructs a new &lt;code&gt;SecurityManager&lt;/code&gt;.</span>
       *
       * &lt;p&gt; If there is a security manager already installed, this method first
<span class="line-modified">!      * calls the security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method</span>
<span class="line-modified">!      * with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt;</span>
       * permission to ensure the calling thread has permission to create a new
       * security manager.
<span class="line-modified">!      * This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception  java.lang.SecurityException if a security manager already</span>
<span class="line-modified">!      *             exists and its &lt;code&gt;checkPermission&lt;/code&gt; method</span>
       *             doesn&#39;t allow creation of a new security manager.
       * @see        java.lang.System#getSecurityManager()
       * @see        #checkPermission(java.security.Permission) checkPermission
       * @see java.lang.RuntimePermission
       */
<span class="line-new-header">--- 320,21 ---</span>
       * Have we been initialized. Effective against finalizer attacks.
       */
      private boolean initialized = false;
  
      /**
<span class="line-modified">!      * Constructs a new {@code SecurityManager}.</span>
       *
       * &lt;p&gt; If there is a security manager already installed, this method first
<span class="line-modified">!      * calls the security manager&#39;s {@code checkPermission} method</span>
<span class="line-modified">!      * with the {@code RuntimePermission(&quot;createSecurityManager&quot;)}</span>
       * permission to ensure the calling thread has permission to create a new
       * security manager.
<span class="line-modified">!      * This may result in throwing a {@code SecurityException}.</span>
       *
<span class="line-modified">!      * @throws     java.lang.SecurityException if a security manager already</span>
<span class="line-modified">!      *             exists and its {@code checkPermission} method</span>
       *             doesn&#39;t allow creation of a new security manager.
       * @see        java.lang.System#getSecurityManager()
       * @see        #checkPermission(java.security.Permission) checkPermission
       * @see java.lang.RuntimePermission
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,30 ***</span>
  
      /**
       * Returns the current execution stack as an array of classes.
       * &lt;p&gt;
       * The length of the array is the number of methods on the execution
<span class="line-modified">!      * stack. The element at index &lt;code&gt;0&lt;/code&gt; is the class of the</span>
<span class="line-modified">!      * currently executing method, the element at index &lt;code&gt;1&lt;/code&gt; is</span>
       * the class of that method&#39;s caller, and so on.
       *
       * @return  the execution stack.
       */
      protected native Class&lt;?&gt;[] getClassContext();
  
      /**
       * Creates an object that encapsulates the current execution
       * environment. The result of this method is used, for example, by the
<span class="line-modified">!      * three-argument &lt;code&gt;checkConnect&lt;/code&gt; method and by the</span>
<span class="line-modified">!      * two-argument &lt;code&gt;checkRead&lt;/code&gt; method.</span>
       * These methods are needed because a trusted method may be called
       * on to read a file or open a socket on behalf of another method.
       * The trusted method needs to determine if the other (possibly
       * untrusted) method would be allowed to perform the operation on its
       * own.
       * &lt;p&gt; The default implementation of this method is to return
<span class="line-modified">!      * an &lt;code&gt;AccessControlContext&lt;/code&gt; object.</span>
       *
       * @return  an implementation-dependent object that encapsulates
       *          sufficient information about the current execution environment
       *          to perform some security checks later.
       * @see     java.lang.SecurityManager#checkConnect(java.lang.String, int,
<span class="line-new-header">--- 353,30 ---</span>
  
      /**
       * Returns the current execution stack as an array of classes.
       * &lt;p&gt;
       * The length of the array is the number of methods on the execution
<span class="line-modified">!      * stack. The element at index {@code 0} is the class of the</span>
<span class="line-modified">!      * currently executing method, the element at index {@code 1} is</span>
       * the class of that method&#39;s caller, and so on.
       *
       * @return  the execution stack.
       */
      protected native Class&lt;?&gt;[] getClassContext();
  
      /**
       * Creates an object that encapsulates the current execution
       * environment. The result of this method is used, for example, by the
<span class="line-modified">!      * three-argument {@code checkConnect} method and by the</span>
<span class="line-modified">!      * two-argument {@code checkRead} method.</span>
       * These methods are needed because a trusted method may be called
       * on to read a file or open a socket on behalf of another method.
       * The trusted method needs to determine if the other (possibly
       * untrusted) method would be allowed to perform the operation on its
       * own.
       * &lt;p&gt; The default implementation of this method is to return
<span class="line-modified">!      * an {@code AccessControlContext} object.</span>
       *
       * @return  an implementation-dependent object that encapsulates
       *          sufficient information about the current execution environment
       *          to perform some security checks later.
       * @see     java.lang.SecurityManager#checkConnect(java.lang.String, int,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,55 ***</span>
      public Object getSecurityContext() {
          return AccessController.getContext();
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the requested</span>
       * access, specified by the given permission, is not permitted based
       * on the security policy currently in effect.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;AccessController.checkPermission&lt;/code&gt;</span>
       * with the given permission.
       *
       * @param     perm   the requested permission.
<span class="line-modified">!      * @exception SecurityException if access is not permitted based on</span>
       *            the current security policy.
<span class="line-modified">!      * @exception NullPointerException if the permission argument is</span>
<span class="line-modified">!      *            &lt;code&gt;null&lt;/code&gt;.</span>
       * @since     1.2
       */
      public void checkPermission(Permission perm) {
          java.security.AccessController.checkPermission(perm);
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * specified security context is denied access to the resource
       * specified by the given permission.
       * The context must be a security
       * context returned by a previous call to
<span class="line-modified">!      * &lt;code&gt;getSecurityContext&lt;/code&gt; and the access control</span>
       * decision is based upon the configured security policy for
       * that security context.
       * &lt;p&gt;
<span class="line-modified">!      * If &lt;code&gt;context&lt;/code&gt; is an instance of</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext&lt;/code&gt; then the</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method is</span>
       * invoked with the specified permission.
       * &lt;p&gt;
<span class="line-modified">!      * If &lt;code&gt;context&lt;/code&gt; is not an instance of</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext&lt;/code&gt; then a</span>
<span class="line-modified">!      * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</span>
       *
       * @param      perm      the specified permission
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @exception  SecurityException  if the specified security context</span>
<span class="line-modified">!      *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;</span>
<span class="line-modified">!      *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or is denied access to the</span>
       *             resource specified by the given permission.
<span class="line-modified">!      * @exception  NullPointerException if the permission argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see java.security.AccessControlContext#checkPermission(java.security.Permission)
       * @since      1.2
       */
      public void checkPermission(Permission perm, Object context) {
<span class="line-new-header">--- 388,55 ---</span>
      public Object getSecurityContext() {
          return AccessController.getContext();
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the requested</span>
       * access, specified by the given permission, is not permitted based
       * on the security policy currently in effect.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code AccessController.checkPermission}</span>
       * with the given permission.
       *
       * @param     perm   the requested permission.
<span class="line-modified">!      * @throws    SecurityException if access is not permitted based on</span>
       *            the current security policy.
<span class="line-modified">!      * @throws    NullPointerException if the permission argument is</span>
<span class="line-modified">!      *            {@code null}.</span>
       * @since     1.2
       */
      public void checkPermission(Permission perm) {
          java.security.AccessController.checkPermission(perm);
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * specified security context is denied access to the resource
       * specified by the given permission.
       * The context must be a security
       * context returned by a previous call to
<span class="line-modified">!      * {@code getSecurityContext} and the access control</span>
       * decision is based upon the configured security policy for
       * that security context.
       * &lt;p&gt;
<span class="line-modified">!      * If {@code context} is an instance of</span>
<span class="line-modified">!      * {@code AccessControlContext} then the</span>
<span class="line-modified">!      * {@code AccessControlContext.checkPermission} method is</span>
       * invoked with the specified permission.
       * &lt;p&gt;
<span class="line-modified">!      * If {@code context} is not an instance of</span>
<span class="line-modified">!      * {@code AccessControlContext} then a</span>
<span class="line-modified">!      * {@code SecurityException} is thrown.</span>
       *
       * @param      perm      the specified permission
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @throws     SecurityException  if the specified security context</span>
<span class="line-modified">!      *             is not an instance of {@code AccessControlContext}</span>
<span class="line-modified">!      *             (e.g., is {@code null}), or is denied access to the</span>
       *             resource specified by the given permission.
<span class="line-modified">!      * @throws     NullPointerException if the permission argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see java.security.AccessControlContext#checkPermission(java.security.Permission)
       * @since      1.2
       */
      public void checkPermission(Permission perm, Object context) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,23 ***</span>
              throw new SecurityException();
          }
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to create a new class loader.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;createClassLoader&quot;)&lt;/code&gt;</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkCreateClassLoader&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @exception SecurityException if the calling thread does not</span>
       *             have permission
       *             to create a new class loader.
       * @see        java.lang.ClassLoader#ClassLoader()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
<span class="line-new-header">--- 446,23 ---</span>
              throw new SecurityException();
          }
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to create a new class loader.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;createClassLoader&quot;)}</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkCreateClassLoader}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @throws    SecurityException if the calling thread does not</span>
       *             have permission
       *             to create a new class loader.
       * @see        java.lang.ClassLoader#ClassLoader()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,43 ***</span>
          }
          return root;
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to modify the thread argument.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;,</span>
<span class="line-modified">!      * &lt;code&gt;setPriority&lt;/code&gt;, &lt;code&gt;setName&lt;/code&gt;, and</span>
<span class="line-modified">!      * &lt;code&gt;setDaemon&lt;/code&gt; methods of class &lt;code&gt;Thread&lt;/code&gt;.</span>
       * &lt;p&gt;
       * If the thread argument is a system thread (belongs to
<span class="line-modified">!      * the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then</span>
<span class="line-modified">!      * this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission.</span>
       * If the thread argument is &lt;i&gt;not&lt;/i&gt; a system thread,
       * this method just returns silently.
       * &lt;p&gt;
       * Applications that want a stricter policy should override this
       * method. If this method is overridden, the method that overrides
       * it should additionally check to see if the calling thread has the
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission, and</span>
       * if so, return silently. This is to ensure that code granted
       * that permission (such as the JDK itself) is allowed to
       * manipulate any thread.
       * &lt;p&gt;
       * If this method is overridden, then
<span class="line-modified">!      * &lt;code&gt;super.checkAccess&lt;/code&gt; should</span>
       * be called by the first statement in the overridden method, or the
       * equivalent security check should be placed in the overridden method.
       *
       * @param      t   the thread to be checked.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to modify the thread.
<span class="line-modified">!      * @exception  NullPointerException if the thread argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.Thread#resume() resume
       * @see        java.lang.Thread#setDaemon(boolean) setDaemon
       * @see        java.lang.Thread#setName(java.lang.String) setName
       * @see        java.lang.Thread#setPriority(int) setPriority
       * @see        java.lang.Thread#stop() stop
<span class="line-new-header">--- 484,43 ---</span>
          }
          return root;
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to modify the thread argument.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * {@code stop}, {@code suspend}, {@code resume},</span>
<span class="line-modified">!      * {@code setPriority}, {@code setName}, and</span>
<span class="line-modified">!      * {@code setDaemon} methods of class {@code Thread}.</span>
       * &lt;p&gt;
       * If the thread argument is a system thread (belongs to
<span class="line-modified">!      * the thread group with a {@code null} parent) then</span>
<span class="line-modified">!      * this method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;modifyThread&quot;)} permission.</span>
       * If the thread argument is &lt;i&gt;not&lt;/i&gt; a system thread,
       * this method just returns silently.
       * &lt;p&gt;
       * Applications that want a stricter policy should override this
       * method. If this method is overridden, the method that overrides
       * it should additionally check to see if the calling thread has the
<span class="line-modified">!      * {@code RuntimePermission(&quot;modifyThread&quot;)} permission, and</span>
       * if so, return silently. This is to ensure that code granted
       * that permission (such as the JDK itself) is allowed to
       * manipulate any thread.
       * &lt;p&gt;
       * If this method is overridden, then
<span class="line-modified">!      * {@code super.checkAccess} should</span>
       * be called by the first statement in the overridden method, or the
       * equivalent security check should be placed in the overridden method.
       *
       * @param      t   the thread to be checked.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to modify the thread.
<span class="line-modified">!      * @throws     NullPointerException if the thread argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.Thread#resume() resume
       * @see        java.lang.Thread#setDaemon(boolean) setDaemon
       * @see        java.lang.Thread#setName(java.lang.String) setName
       * @see        java.lang.Thread#setPriority(int) setPriority
       * @see        java.lang.Thread#stop() stop
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,44 ***</span>
          } else {
              // just return
          }
      }
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to modify the thread group argument.
       * &lt;p&gt;
       * This method is invoked for the current security manager when a
       * new child thread or child thread group is created, and by the
<span class="line-modified">!      * &lt;code&gt;setDaemon&lt;/code&gt;, &lt;code&gt;setMaxPriority&lt;/code&gt;,</span>
<span class="line-modified">!      * &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;suspend&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;, and</span>
<span class="line-modified">!      * &lt;code&gt;destroy&lt;/code&gt; methods of class &lt;code&gt;ThreadGroup&lt;/code&gt;.</span>
       * &lt;p&gt;
       * If the thread group argument is the system thread group (
<span class="line-modified">!      * has a &lt;code&gt;null&lt;/code&gt; parent) then</span>
<span class="line-modified">!      * this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission.</span>
       * If the thread group argument is &lt;i&gt;not&lt;/i&gt; the system thread group,
       * this method just returns silently.
       * &lt;p&gt;
       * Applications that want a stricter policy should override this
       * method. If this method is overridden, the method that overrides
       * it should additionally check to see if the calling thread has the
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission, and</span>
       * if so, return silently. This is to ensure that code granted
       * that permission (such as the JDK itself) is allowed to
       * manipulate any thread.
       * &lt;p&gt;
       * If this method is overridden, then
<span class="line-modified">!      * &lt;code&gt;super.checkAccess&lt;/code&gt; should</span>
       * be called by the first statement in the overridden method, or the
       * equivalent security check should be placed in the overridden method.
       *
       * @param      g   the thread group to be checked.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to modify the thread group.
<span class="line-modified">!      * @exception  NullPointerException if the thread group argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.ThreadGroup#destroy() destroy
       * @see        java.lang.ThreadGroup#resume() resume
       * @see        java.lang.ThreadGroup#setDaemon(boolean) setDaemon
       * @see        java.lang.ThreadGroup#setMaxPriority(int) setMaxPriority
       * @see        java.lang.ThreadGroup#stop() stop
<span class="line-new-header">--- 536,44 ---</span>
          } else {
              // just return
          }
      }
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to modify the thread group argument.
       * &lt;p&gt;
       * This method is invoked for the current security manager when a
       * new child thread or child thread group is created, and by the
<span class="line-modified">!      * {@code setDaemon}, {@code setMaxPriority},</span>
<span class="line-modified">!      * {@code stop}, {@code suspend}, {@code resume}, and</span>
<span class="line-modified">!      * {@code destroy} methods of class {@code ThreadGroup}.</span>
       * &lt;p&gt;
       * If the thread group argument is the system thread group (
<span class="line-modified">!      * has a {@code null} parent) then</span>
<span class="line-modified">!      * this method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission.</span>
       * If the thread group argument is &lt;i&gt;not&lt;/i&gt; the system thread group,
       * this method just returns silently.
       * &lt;p&gt;
       * Applications that want a stricter policy should override this
       * method. If this method is overridden, the method that overrides
       * it should additionally check to see if the calling thread has the
<span class="line-modified">!      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission, and</span>
       * if so, return silently. This is to ensure that code granted
       * that permission (such as the JDK itself) is allowed to
       * manipulate any thread.
       * &lt;p&gt;
       * If this method is overridden, then
<span class="line-modified">!      * {@code super.checkAccess} should</span>
       * be called by the first statement in the overridden method, or the
       * equivalent security check should be placed in the overridden method.
       *
       * @param      g   the thread group to be checked.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to modify the thread group.
<span class="line-modified">!      * @throws     NullPointerException if the thread group argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.ThreadGroup#destroy() destroy
       * @see        java.lang.ThreadGroup#resume() resume
       * @see        java.lang.ThreadGroup#setDaemon(boolean) setDaemon
       * @see        java.lang.ThreadGroup#setMaxPriority(int) setMaxPriority
       * @see        java.lang.ThreadGroup#stop() stop
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,61 ***</span>
              // just return
          }
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to cause the Java Virtual Machine to
       * halt with the specified status code.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt;. A status</span>
<span class="line-modified">!      * of &lt;code&gt;0&lt;/code&gt; indicates success; other values indicate various</span>
       * errors.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;exitVM.&quot;+status)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkExit&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      status   the exit status.
<span class="line-modified">!      * @exception SecurityException if the calling thread does not have</span>
       *              permission to halt the Java Virtual Machine with
       *              the specified status.
       * @see        java.lang.Runtime#exit(int) exit
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkExit(int status) {
          checkPermission(new RuntimePermission(&quot;exitVM.&quot;+status));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to create a subprocess.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * &lt;code&gt;exec&lt;/code&gt; methods of class &lt;code&gt;Runtime&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;FilePermission(cmd,&quot;execute&quot;)&lt;/code&gt; permission</span>
       * if cmd is an absolute path, otherwise it calls
<span class="line-modified">!      * &lt;code&gt;checkPermission&lt;/code&gt; with</span>
       * &lt;code&gt;FilePermission(&quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot;,&quot;execute&quot;)&lt;/code&gt;.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkExec&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      cmd   the specified system command.
<span class="line-modified">!      * @exception  SecurityException if the calling thread does not have</span>
       *             permission to create a subprocess.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;cmd&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see     java.lang.Runtime#exec(java.lang.String)
       * @see     java.lang.Runtime#exec(java.lang.String, java.lang.String[])
       * @see     java.lang.Runtime#exec(java.lang.String[])
       * @see     java.lang.Runtime#exec(java.lang.String[], java.lang.String[])
       * @see     #checkPermission(java.security.Permission) checkPermission
<span class="line-new-header">--- 590,61 ---</span>
              // just return
          }
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to cause the Java Virtual Machine to
       * halt with the specified status code.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * {@code exit} method of class {@code Runtime}. A status</span>
<span class="line-modified">!      * of {@code 0} indicates success; other values indicate various</span>
       * errors.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;exitVM.&quot;+status)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkExit}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      status   the exit status.
<span class="line-modified">!      * @throws    SecurityException if the calling thread does not have</span>
       *              permission to halt the Java Virtual Machine with
       *              the specified status.
       * @see        java.lang.Runtime#exit(int) exit
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkExit(int status) {
          checkPermission(new RuntimePermission(&quot;exitVM.&quot;+status));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to create a subprocess.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * {@code exec} methods of class {@code Runtime}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code FilePermission(cmd,&quot;execute&quot;)} permission</span>
       * if cmd is an absolute path, otherwise it calls
<span class="line-modified">!      * {@code checkPermission} with</span>
       * &lt;code&gt;FilePermission(&quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot;,&quot;execute&quot;)&lt;/code&gt;.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkExec}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      cmd   the specified system command.
<span class="line-modified">!      * @throws     SecurityException if the calling thread does not have</span>
       *             permission to create a subprocess.
<span class="line-modified">!      * @throws     NullPointerException if the {@code cmd} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see     java.lang.Runtime#exec(java.lang.String)
       * @see     java.lang.Runtime#exec(java.lang.String, java.lang.String[])
       * @see     java.lang.Runtime#exec(java.lang.String[])
       * @see     java.lang.Runtime#exec(java.lang.String[], java.lang.String[])
       * @see     #checkPermission(java.security.Permission) checkPermission
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,32 ***</span>
                  SecurityConstants.FILE_EXECUTE_ACTION));
          }
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to dynamic link the library code
       * specified by the string argument file. The argument is either a
       * simple library name or a complete filename.
       * &lt;p&gt;
       * This method is invoked for the current security manager by
<span class="line-modified">!      * methods &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;loadLibrary&lt;/code&gt; of class</span>
<span class="line-modified">!      * &lt;code&gt;Runtime&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;loadLibrary.&quot;+lib)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkLink&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      lib   the name of the library.
<span class="line-modified">!      * @exception  SecurityException if the calling thread does not have</span>
       *             permission to dynamically link the library.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;lib&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.Runtime#load(java.lang.String)
       * @see        java.lang.Runtime#loadLibrary(java.lang.String)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkLink(String lib) {
<span class="line-new-header">--- 659,32 ---</span>
                  SecurityConstants.FILE_EXECUTE_ACTION));
          }
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to dynamic link the library code
       * specified by the string argument file. The argument is either a
       * simple library name or a complete filename.
       * &lt;p&gt;
       * This method is invoked for the current security manager by
<span class="line-modified">!      * methods {@code load} and {@code loadLibrary} of class</span>
<span class="line-modified">!      * {@code Runtime}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;loadLibrary.&quot;+lib)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkLink}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      lib   the name of the library.
<span class="line-modified">!      * @throws     SecurityException if the calling thread does not have</span>
       *             permission to dynamically link the library.
<span class="line-modified">!      * @throws     NullPointerException if the {@code lib} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.Runtime#load(java.lang.String)
       * @see        java.lang.Runtime#loadLibrary(java.lang.String)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkLink(String lib) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,28 ***</span>
          }
          checkPermission(new RuntimePermission(&quot;loadLibrary.&quot;+lib));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to read from the specified file
       * descriptor.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;readFileDescriptor&quot;)&lt;/code&gt;</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkRead&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      fd   the system-dependent file descriptor.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to access the specified file descriptor.
<span class="line-modified">!      * @exception  NullPointerException if the file descriptor argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.io.FileDescriptor
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkRead(FileDescriptor fd) {
          if (fd == null) {
<span class="line-new-header">--- 693,28 ---</span>
          }
          checkPermission(new RuntimePermission(&quot;loadLibrary.&quot;+lib));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to read from the specified file
       * descriptor.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;readFileDescriptor&quot;)}</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkRead}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      fd   the system-dependent file descriptor.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to access the specified file descriptor.
<span class="line-modified">!      * @throws     NullPointerException if the file descriptor argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.io.FileDescriptor
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkRead(FileDescriptor fd) {
          if (fd == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 722,89 ***</span>
          }
          checkPermission(new RuntimePermission(&quot;readFileDescriptor&quot;));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to read the file specified by the
       * string argument.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkRead&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent file name.
<span class="line-modified">!      * @exception  SecurityException if the calling thread does not have</span>
       *             permission to access the specified file.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkRead(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_READ_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * specified security context is not allowed to read the file
       * specified by the string argument. The context must be a security
       * context returned by a previous call to
<span class="line-modified">!      * &lt;code&gt;getSecurityContext&lt;/code&gt;.</span>
<span class="line-modified">!      * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is an instance of</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext&lt;/code&gt; then the</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext.checkPermission&lt;/code&gt; method will</span>
<span class="line-modified">!      * be invoked with the &lt;code&gt;FilePermission(file,&quot;read&quot;)&lt;/code&gt; permission.</span>
<span class="line-modified">!      * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is not an instance of</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext&lt;/code&gt; then a</span>
<span class="line-modified">!      * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkRead&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file      the system-dependent filename.
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @exception  SecurityException  if the specified security context</span>
<span class="line-modified">!      *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;</span>
<span class="line-modified">!      *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or does not have permission</span>
       *             to read the specified file.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
       */
      public void checkRead(String file, Object context) {
          checkPermission(
              new FilePermission(file, SecurityConstants.FILE_READ_ACTION),
              context);
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to write to the specified file
       * descriptor.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;writeFileDescriptor&quot;)&lt;/code&gt;</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkWrite&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      fd   the system-dependent file descriptor.
<span class="line-modified">!      * @exception SecurityException  if the calling thread does not have</span>
       *             permission to access the specified file descriptor.
<span class="line-modified">!      * @exception  NullPointerException if the file descriptor argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.io.FileDescriptor
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkWrite(FileDescriptor fd) {
          if (fd == null) {
<span class="line-new-header">--- 722,89 ---</span>
          }
          checkPermission(new RuntimePermission(&quot;readFileDescriptor&quot;));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to read the file specified by the
       * string argument.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code FilePermission(file,&quot;read&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkRead}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent file name.
<span class="line-modified">!      * @throws     SecurityException if the calling thread does not have</span>
       *             permission to access the specified file.
<span class="line-modified">!      * @throws     NullPointerException if the {@code file} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkRead(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_READ_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * specified security context is not allowed to read the file
       * specified by the string argument. The context must be a security
       * context returned by a previous call to
<span class="line-modified">!      * {@code getSecurityContext}.</span>
<span class="line-modified">!      * &lt;p&gt; If {@code context} is an instance of</span>
<span class="line-modified">!      * {@code AccessControlContext} then the</span>
<span class="line-modified">!      * {@code AccessControlContext.checkPermission} method will</span>
<span class="line-modified">!      * be invoked with the {@code FilePermission(file,&quot;read&quot;)} permission.</span>
<span class="line-modified">!      * &lt;p&gt; If {@code context} is not an instance of</span>
<span class="line-modified">!      * {@code AccessControlContext} then a</span>
<span class="line-modified">!      * {@code SecurityException} is thrown.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkRead}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file      the system-dependent filename.
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @throws     SecurityException  if the specified security context</span>
<span class="line-modified">!      *             is not an instance of {@code AccessControlContext}</span>
<span class="line-modified">!      *             (e.g., is {@code null}), or does not have permission</span>
       *             to read the specified file.
<span class="line-modified">!      * @throws     NullPointerException if the {@code file} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
       */
      public void checkRead(String file, Object context) {
          checkPermission(
              new FilePermission(file, SecurityConstants.FILE_READ_ACTION),
              context);
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to write to the specified file
       * descriptor.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;writeFileDescriptor&quot;)}</span>
       * permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkWrite}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      fd   the system-dependent file descriptor.
<span class="line-modified">!      * @throws    SecurityException  if the calling thread does not have</span>
       *             permission to access the specified file descriptor.
<span class="line-modified">!      * @throws     NullPointerException if the file descriptor argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.io.FileDescriptor
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkWrite(FileDescriptor fd) {
          if (fd == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 813,89 ***</span>
          checkPermission(new RuntimePermission(&quot;writeFileDescriptor&quot;));
  
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to write to the file specified by
       * the string argument.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;FilePermission(file,&quot;write&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkWrite&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent filename.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not</span>
       *             have permission to access the specified file.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkWrite(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_WRITE_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to delete the specified file.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * &lt;code&gt;delete&lt;/code&gt; method of class &lt;code&gt;File&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;FilePermission(file,&quot;delete&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkDelete&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent filename.
<span class="line-modified">!      * @exception  SecurityException if the calling thread does not</span>
       *             have permission to delete the file.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;file&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.io.File#delete()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkDelete(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_DELETE_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to open a socket connection to the
       * specified host and port number.
       * &lt;p&gt;
<span class="line-modified">!      * A port number of &lt;code&gt;-1&lt;/code&gt; indicates that the calling</span>
       * method is attempting to determine the IP address of the specified
       * host name.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; permission if</span>
       * the port is not equal to -1. If the port is equal to -1, then
<span class="line-modified">!      * it calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkConnect&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host   the host name port to connect to.
       * @param      port   the protocol port to connect to.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to open a socket connection to the specified
<span class="line-modified">!      *               &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkConnect(String host, int port) {
          if (host == null) {
              throw new NullPointerException(&quot;host can&#39;t be null&quot;);
<span class="line-new-header">--- 813,89 ---</span>
          checkPermission(new RuntimePermission(&quot;writeFileDescriptor&quot;));
  
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to write to the file specified by
       * the string argument.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code FilePermission(file,&quot;write&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkWrite}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent filename.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not</span>
       *             have permission to access the specified file.
<span class="line-modified">!      * @throws     NullPointerException if the {@code file} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkWrite(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_WRITE_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to delete the specified file.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * {@code delete} method of class {@code File}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code FilePermission(file,&quot;delete&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkDelete}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      file   the system-dependent filename.
<span class="line-modified">!      * @throws     SecurityException if the calling thread does not</span>
       *             have permission to delete the file.
<span class="line-modified">!      * @throws     NullPointerException if the {@code file} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.io.File#delete()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkDelete(String file) {
          checkPermission(new FilePermission(file,
              SecurityConstants.FILE_DELETE_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to open a socket connection to the
       * specified host and port number.
       * &lt;p&gt;
<span class="line-modified">!      * A port number of {@code -1} indicates that the calling</span>
       * method is attempting to determine the IP address of the specified
       * host name.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)} permission if</span>
       * the port is not equal to -1. If the port is equal to -1, then
<span class="line-modified">!      * it calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code SocketPermission(host,&quot;resolve&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkConnect}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host   the host name port to connect to.
       * @param      port   the protocol port to connect to.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to open a socket connection to the specified
<span class="line-modified">!      *               {@code host} and {@code port}.</span>
<span class="line-modified">!      * @throws     NullPointerException if the {@code host} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkConnect(String host, int port) {
          if (host == null) {
              throw new NullPointerException(&quot;host can&#39;t be null&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,45 ***</span>
                  SecurityConstants.SOCKET_CONNECT_ACTION));
          }
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * specified security context is not allowed to open a socket
       * connection to the specified host and port number.
       * &lt;p&gt;
<span class="line-modified">!      * A port number of &lt;code&gt;-1&lt;/code&gt; indicates that the calling</span>
       * method is attempting to determine the IP address of the specified
       * host name.
<span class="line-modified">!      * &lt;p&gt; If &lt;code&gt;context&lt;/code&gt; is not an instance of</span>
<span class="line-modified">!      * &lt;code&gt;AccessControlContext&lt;/code&gt; then a</span>
<span class="line-modified">!      * &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</span>
       * &lt;p&gt;
       * Otherwise, the port number is checked. If it is not equal
<span class="line-modified">!      * to -1, the &lt;code&gt;context&lt;/code&gt;&#39;s &lt;code&gt;checkPermission&lt;/code&gt;</span>
       * method is called with a
<span class="line-modified">!      * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)&lt;/code&gt; permission.</span>
       * If the port is equal to -1, then
<span class="line-modified">!      * the &lt;code&gt;context&lt;/code&gt;&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method</span>
       * is called with a
<span class="line-modified">!      * &lt;code&gt;SocketPermission(host,&quot;resolve&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkConnect&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host      the host name port to connect to.
       * @param      port      the protocol port to connect to.
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @exception  SecurityException if the specified security context</span>
<span class="line-modified">!      *             is not an instance of &lt;code&gt;AccessControlContext&lt;/code&gt;</span>
<span class="line-modified">!      *             (e.g., is &lt;code&gt;null&lt;/code&gt;), or does not have permission</span>
       *             to open a socket connection to the specified
<span class="line-modified">!      *             &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
       */
      public void checkConnect(String host, int port, Object context) {
          if (host == null) {
<span class="line-new-header">--- 911,45 ---</span>
                  SecurityConstants.SOCKET_CONNECT_ACTION));
          }
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * specified security context is not allowed to open a socket
       * connection to the specified host and port number.
       * &lt;p&gt;
<span class="line-modified">!      * A port number of {@code -1} indicates that the calling</span>
       * method is attempting to determine the IP address of the specified
       * host name.
<span class="line-modified">!      * &lt;p&gt; If {@code context} is not an instance of</span>
<span class="line-modified">!      * {@code AccessControlContext} then a</span>
<span class="line-modified">!      * {@code SecurityException} is thrown.</span>
       * &lt;p&gt;
       * Otherwise, the port number is checked. If it is not equal
<span class="line-modified">!      * to -1, the {@code context}&#39;s {@code checkPermission}</span>
       * method is called with a
<span class="line-modified">!      * {@code SocketPermission(host+&quot;:&quot;+port,&quot;connect&quot;)} permission.</span>
       * If the port is equal to -1, then
<span class="line-modified">!      * the {@code context}&#39;s {@code checkPermission} method</span>
       * is called with a
<span class="line-modified">!      * {@code SocketPermission(host,&quot;resolve&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkConnect}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host      the host name port to connect to.
       * @param      port      the protocol port to connect to.
       * @param      context   a system-dependent security context.
<span class="line-modified">!      * @throws     SecurityException if the specified security context</span>
<span class="line-modified">!      *             is not an instance of {@code AccessControlContext}</span>
<span class="line-modified">!      *             (e.g., is {@code null}), or does not have permission</span>
       *             to open a socket connection to the specified
<span class="line-modified">!      *             {@code host} and {@code port}.</span>
<span class="line-modified">!      * @throws     NullPointerException if the {@code host} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.lang.SecurityManager#getSecurityContext()
       * @see        java.security.AccessControlContext#checkPermission(java.security.Permission)
       */
      public void checkConnect(String host, int port, Object context) {
          if (host == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 967,54 ***</span>
                  SecurityConstants.SOCKET_CONNECT_ACTION),
                  context);
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to wait for a connection request on
       * the specified local port number.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)&lt;/code&gt;.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkListen&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      port   the local port.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to listen on the specified port.
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkListen(int port) {
          checkPermission(new SocketPermission(&quot;localhost:&quot;+port,
              SecurityConstants.SOCKET_LISTEN_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not permitted to accept a socket connection from
       * the specified host and port number.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * &lt;code&gt;accept&lt;/code&gt; method of class &lt;code&gt;ServerSocket&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkAccept&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host   the host name of the socket connection.
       * @param      port   the port number of the socket connection.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to accept the connection.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;host&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @see        java.net.ServerSocket#accept()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkAccept(String host, int port) {
          if (host == null) {
<span class="line-new-header">--- 967,54 ---</span>
                  SecurityConstants.SOCKET_CONNECT_ACTION),
                  context);
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to wait for a connection request on
       * the specified local port number.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code SocketPermission(&quot;localhost:&quot;+port,&quot;listen&quot;)}.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkListen}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      port   the local port.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to listen on the specified port.
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkListen(int port) {
          checkPermission(new SocketPermission(&quot;localhost:&quot;+port,
              SecurityConstants.SOCKET_LISTEN_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not permitted to accept a socket connection from
       * the specified host and port number.
       * &lt;p&gt;
       * This method is invoked for the current security manager by the
<span class="line-modified">!      * {@code accept} method of class {@code ServerSocket}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code SocketPermission(host+&quot;:&quot;+port,&quot;accept&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkAccept}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      host   the host name of the socket connection.
       * @param      port   the port number of the socket connection.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to accept the connection.
<span class="line-modified">!      * @throws     NullPointerException if the {@code host} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @see        java.net.ServerSocket#accept()
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkAccept(String host, int port) {
          if (host == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,28 ***</span>
          checkPermission(new SocketPermission(host+&quot;:&quot;+port,
              SecurityConstants.SOCKET_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to use
       * (join/leave/send/receive) IP multicast.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
       * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
       * &quot;accept,connect&quot;)&lt;/code&gt; permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkMulticast&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      maddr  Internet group address to be used.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread is not allowed to</span>
       *  use (join/leave/send/receive) IP multicast.
<span class="line-modified">!      * @exception  NullPointerException if the address argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @since      1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkMulticast(InetAddress maddr) {
          String host = maddr.getHostAddress();
<span class="line-new-header">--- 1026,28 ---</span>
          checkPermission(new SocketPermission(host+&quot;:&quot;+port,
              SecurityConstants.SOCKET_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to use
       * (join/leave/send/receive) IP multicast.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
       * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
       * &quot;accept,connect&quot;)&lt;/code&gt; permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkMulticast}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      maddr  Internet group address to be used.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread is not allowed to</span>
       *  use (join/leave/send/receive) IP multicast.
<span class="line-modified">!      * @throws     NullPointerException if the address argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @since      1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkMulticast(InetAddress maddr) {
          String host = maddr.getHostAddress();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,31 ***</span>
          checkPermission(new SocketPermission(host,
              SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to use
       * (join/leave/send/receive) IP multicast.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
       * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
       * &quot;accept,connect&quot;)&lt;/code&gt; permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkMulticast&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      maddr  Internet group address to be used.
       * @param      ttl        value in use, if it is multicast send.
       * Note: this particular implementation does not use the ttl
       * parameter.
<span class="line-modified">!      * @exception  SecurityException  if the calling thread is not allowed to</span>
       *  use (join/leave/send/receive) IP multicast.
<span class="line-modified">!      * @exception  NullPointerException if the address argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
       * @since      1.1
       * @deprecated Use #checkPermission(java.security.Permission) instead
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      @Deprecated(since=&quot;1.4&quot;)
<span class="line-new-header">--- 1057,31 ---</span>
          checkPermission(new SocketPermission(host,
              SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to use
       * (join/leave/send/receive) IP multicast.
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
       * &lt;code&gt;java.net.SocketPermission(maddr.getHostAddress(),
       * &quot;accept,connect&quot;)&lt;/code&gt; permission.
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkMulticast}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      maddr  Internet group address to be used.
       * @param      ttl        value in use, if it is multicast send.
       * Note: this particular implementation does not use the ttl
       * parameter.
<span class="line-modified">!      * @throws     SecurityException  if the calling thread is not allowed to</span>
       *  use (join/leave/send/receive) IP multicast.
<span class="line-modified">!      * @throws     NullPointerException if the address argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
       * @since      1.1
       * @deprecated Use #checkPermission(java.security.Permission) instead
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      @Deprecated(since=&quot;1.4&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,26 ***</span>
          checkPermission(new SocketPermission(host,
              SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to access or modify the system
       * properties.
       * &lt;p&gt;
<span class="line-modified">!      * This method is used by the &lt;code&gt;getProperties&lt;/code&gt; and</span>
<span class="line-modified">!      * &lt;code&gt;setProperties&lt;/code&gt; methods of class &lt;code&gt;System&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkPropertiesAccess&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to access or modify the system properties.
       * @see        java.lang.System#getProperties()
       * @see        java.lang.System#setProperties(java.util.Properties)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
<span class="line-new-header">--- 1093,26 ---</span>
          checkPermission(new SocketPermission(host,
              SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to access or modify the system
       * properties.
       * &lt;p&gt;
<span class="line-modified">!      * This method is used by the {@code getProperties} and</span>
<span class="line-modified">!      * {@code setProperties} methods of class {@code System}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code PropertyPermission(&quot;*&quot;, &quot;read,write&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkPropertiesAccess}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to access or modify the system properties.
       * @see        java.lang.System#getProperties()
       * @see        java.lang.System#setProperties(java.util.Properties)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1120,55 ***</span>
          checkPermission(new PropertyPermission(&quot;*&quot;,
              SecurityConstants.PROPERTY_RW_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to access the system property with
<span class="line-modified">!      * the specified &lt;code&gt;key&lt;/code&gt; name.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method is used by the &lt;code&gt;getProperty&lt;/code&gt; method of</span>
<span class="line-modified">!      * class &lt;code&gt;System&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;PropertyPermission(key, &quot;read&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkPropertyAccess&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      key   a system property key.
       *
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to access the specified system property.
<span class="line-modified">!      * @exception  NullPointerException if the &lt;code&gt;key&lt;/code&gt; argument is</span>
<span class="line-modified">!      *             &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IllegalArgumentException if &lt;code&gt;key&lt;/code&gt; is empty.</span>
       *
       * @see        java.lang.System#getProperty(java.lang.String)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkPropertyAccess(String key) {
          checkPermission(new PropertyPermission(key,
              SecurityConstants.PROPERTY_READ_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to initiate a print job request.
       * &lt;p&gt;
       * This method calls
<span class="line-modified">!      * &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;queuePrintJob&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkPrintJobAccess&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to initiate a print job request.
       * @since   1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkPrintJobAccess() {
<span class="line-new-header">--- 1120,55 ---</span>
          checkPermission(new PropertyPermission(&quot;*&quot;,
              SecurityConstants.PROPERTY_RW_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to access the system property with
<span class="line-modified">!      * the specified {@code key} name.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method is used by the {@code getProperty} method of</span>
<span class="line-modified">!      * class {@code System}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code PropertyPermission(key, &quot;read&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkPropertyAccess}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
       * @param      key   a system property key.
       *
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to access the specified system property.
<span class="line-modified">!      * @throws     NullPointerException if the {@code key} argument is</span>
<span class="line-modified">!      *             {@code null}.</span>
<span class="line-modified">!      * @throws     IllegalArgumentException if {@code key} is empty.</span>
       *
       * @see        java.lang.System#getProperty(java.lang.String)
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkPropertyAccess(String key) {
          checkPermission(new PropertyPermission(key,
              SecurityConstants.PROPERTY_READ_ACTION));
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to initiate a print job request.
       * &lt;p&gt;
       * This method calls
<span class="line-modified">!      * {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;queuePrintJob&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkPrintJobAccess}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to initiate a print job request.
       * @since   1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkPrintJobAccess() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1459,24 ***</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Throws a &lt;code&gt;SecurityException&lt;/code&gt; if the</span>
       * calling thread is not allowed to set the socket factory used by
<span class="line-modified">!      * &lt;code&gt;ServerSocket&lt;/code&gt; or &lt;code&gt;Socket&lt;/code&gt;, or the stream</span>
<span class="line-modified">!      * handler factory used by &lt;code&gt;URL&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls &lt;code&gt;checkPermission&lt;/code&gt; with the</span>
<span class="line-modified">!      * &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkSetFactory&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @exception  SecurityException  if the calling thread does not have</span>
       *             permission to specify a socket factory or a stream
       *             handler factory.
       *
       * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory) setSocketFactory
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory) setSocketImplFactory
<span class="line-new-header">--- 1459,24 ---</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Throws a {@code SecurityException} if the</span>
       * calling thread is not allowed to set the socket factory used by
<span class="line-modified">!      * {@code ServerSocket} or {@code Socket}, or the stream</span>
<span class="line-modified">!      * handler factory used by {@code URL}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method calls {@code checkPermission} with the</span>
<span class="line-modified">!      * {@code RuntimePermission(&quot;setFactory&quot;)} permission.</span>
       * &lt;p&gt;
       * If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkSetFactory}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @throws     SecurityException  if the calling thread does not have</span>
       *             permission to specify a socket factory or a stream
       *             handler factory.
       *
       * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory) setSocketFactory
       * @see        java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory) setSocketImplFactory
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1492,29 ***</span>
       * name should be granted or denied.
       *
       * &lt;p&gt; If the requested permission is allowed, this method returns
       * quietly. If denied, a SecurityException is raised.
       *
<span class="line-modified">!      * &lt;p&gt; This method creates a &lt;code&gt;SecurityPermission&lt;/code&gt; object for</span>
<span class="line-modified">!      * the given permission target name and calls &lt;code&gt;checkPermission&lt;/code&gt;</span>
       * with it.
       *
       * &lt;p&gt; See the documentation for
       * &lt;code&gt;{@link java.security.SecurityPermission}&lt;/code&gt; for
       * a list of possible permission target names.
       *
       * &lt;p&gt; If you override this method, then you should make a call to
<span class="line-modified">!      * &lt;code&gt;super.checkSecurityAccess&lt;/code&gt;</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @param target the target name of the &lt;code&gt;SecurityPermission&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception SecurityException if the calling thread does not have</span>
       * permission for the requested access.
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;target&lt;/code&gt; is null.</span>
<span class="line-modified">!      * @exception IllegalArgumentException if &lt;code&gt;target&lt;/code&gt; is empty.</span>
       *
       * @since   1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkSecurityAccess(String target) {
<span class="line-new-header">--- 1492,29 ---</span>
       * name should be granted or denied.
       *
       * &lt;p&gt; If the requested permission is allowed, this method returns
       * quietly. If denied, a SecurityException is raised.
       *
<span class="line-modified">!      * &lt;p&gt; This method creates a {@code SecurityPermission} object for</span>
<span class="line-modified">!      * the given permission target name and calls {@code checkPermission}</span>
       * with it.
       *
       * &lt;p&gt; See the documentation for
       * &lt;code&gt;{@link java.security.SecurityPermission}&lt;/code&gt; for
       * a list of possible permission target names.
       *
       * &lt;p&gt; If you override this method, then you should make a call to
<span class="line-modified">!      * {@code super.checkSecurityAccess}</span>
       * at the point the overridden method would normally throw an
       * exception.
       *
<span class="line-modified">!      * @param target the target name of the {@code SecurityPermission}.</span>
       *
<span class="line-modified">!      * @throws    SecurityException if the calling thread does not have</span>
       * permission for the requested access.
<span class="line-modified">!      * @throws    NullPointerException if {@code target} is null.</span>
<span class="line-modified">!      * @throws    IllegalArgumentException if {@code target} is empty.</span>
       *
       * @since   1.1
       * @see        #checkPermission(java.security.Permission) checkPermission
       */
      public void checkSecurityAccess(String target) {
</pre>
<center><a href="SecurityException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Short.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/time/ZoneOffset.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file:
 31  *
 32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 33  *
 34  * All rights reserved.
 35  *
 36  * Redistribution and use in source and binary forms, with or without
 37  * modification, are permitted provided that the following conditions are met:
 38  *
 39  *  * Redistributions of source code must retain the above copyright notice,
 40  *    this list of conditions and the following disclaimer.
 41  *
 42  *  * Redistributions in binary form must reproduce the above copyright notice,
 43  *    this list of conditions and the following disclaimer in the documentation
 44  *    and/or other materials provided with the distribution.
 45  *
 46  *  * Neither the name of JSR-310 nor the names of its contributors
 47  *    may be used to endorse or promote products derived from this software
 48  *    without specific prior written permission.
 49  *
 50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 61  */
 62 package java.time;
 63 
 64 import static java.time.LocalTime.MINUTES_PER_HOUR;
 65 import static java.time.LocalTime.SECONDS_PER_HOUR;
 66 import static java.time.LocalTime.SECONDS_PER_MINUTE;
 67 import static java.time.temporal.ChronoField.OFFSET_SECONDS;
 68 
 69 import java.io.DataInput;
 70 import java.io.DataOutput;
 71 import java.io.IOException;
 72 import java.io.InvalidObjectException;
 73 import java.io.ObjectInputStream;
 74 import java.io.Serializable;
 75 import java.time.temporal.ChronoField;
 76 import java.time.temporal.Temporal;
 77 import java.time.temporal.TemporalAccessor;
 78 import java.time.temporal.TemporalAdjuster;
 79 import java.time.temporal.TemporalField;
 80 import java.time.temporal.TemporalQueries;
 81 import java.time.temporal.TemporalQuery;
 82 import java.time.temporal.UnsupportedTemporalTypeException;
 83 import java.time.temporal.ValueRange;
 84 import java.time.zone.ZoneRules;
 85 import java.util.Objects;
 86 import java.util.concurrent.ConcurrentHashMap;
 87 import java.util.concurrent.ConcurrentMap;
 88 
 89 /**
 90  * A time-zone offset from Greenwich/UTC, such as {@code +02:00}.
 91  * &lt;p&gt;
 92  * A time-zone offset is the amount of time that a time-zone differs from Greenwich/UTC.
 93  * This is usually a fixed number of hours and minutes.
 94  * &lt;p&gt;
 95  * Different parts of the world have different time-zone offsets.
 96  * The rules for how offsets vary by place and time of year are captured in the
 97  * {@link ZoneId} class.
 98  * &lt;p&gt;
 99  * For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours
100  * ahead in summer. The {@code ZoneId} instance for Paris will reference two
101  * {@code ZoneOffset} instances - a {@code +01:00} instance for winter,
102  * and a {@code +02:00} instance for summer.
103  * &lt;p&gt;
104  * In 2008, time-zone offsets around the world extended from -12:00 to +14:00.
105  * To prevent any problems with that range being extended, yet still provide
106  * validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.
107  * &lt;p&gt;
108  * This class is designed for use with the ISO calendar system.
109  * The fields of hours, minutes and seconds make assumptions that are valid for the
110  * standard ISO definitions of those fields. This class may be used with other
111  * calendar systems providing the definition of the time fields matches those
112  * of the ISO calendar system.
113  * &lt;p&gt;
114  * Instances of {@code ZoneOffset} must be compared using {@link #equals}.
115  * Implementations may choose to cache certain common offsets, however
116  * applications must not rely on such caching.
117  *
118  * &lt;p&gt;
119  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
120  * class; use of identity-sensitive operations (including reference equality
121  * ({@code ==}), identity hash code, or synchronization) on instances of
122  * {@code ZoneOffset} may have unpredictable results and should be avoided.
123  * The {@code equals} method should be used for comparisons.
124  *
125  * @implSpec
126  * This class is immutable and thread-safe.
127  *
128  * @since 1.8
129  */
130 public final class ZoneOffset
131         extends ZoneId
132         implements TemporalAccessor, TemporalAdjuster, Comparable&lt;ZoneOffset&gt;, Serializable {
133 
134     /** Cache of time-zone offset by offset in seconds. */
135     private static final ConcurrentMap&lt;Integer, ZoneOffset&gt; SECONDS_CACHE = new ConcurrentHashMap&lt;&gt;(16, 0.75f, 4);
136     /** Cache of time-zone offset by ID. */
137     private static final ConcurrentMap&lt;String, ZoneOffset&gt; ID_CACHE = new ConcurrentHashMap&lt;&gt;(16, 0.75f, 4);
138 
139     /**
140      * The abs maximum seconds.
141      */
142     private static final int MAX_SECONDS = 18 * SECONDS_PER_HOUR;
143     /**
144      * Serialization version.
145      */
146     private static final long serialVersionUID = 2357656521762053153L;
147 
148     /**
149      * The time-zone offset for UTC, with an ID of &#39;Z&#39;.
150      */
151     public static final ZoneOffset UTC = ZoneOffset.ofTotalSeconds(0);
152     /**
153      * Constant for the minimum supported offset.
154      */
155     public static final ZoneOffset MIN = ZoneOffset.ofTotalSeconds(-MAX_SECONDS);
156     /**
157      * Constant for the maximum supported offset.
158      */
159     public static final ZoneOffset MAX = ZoneOffset.ofTotalSeconds(MAX_SECONDS);
160 
161     /**
162      * The total offset in seconds.
163      */
164     private final int totalSeconds;
165     /**
166      * The string form of the time-zone offset.
167      */
168     private final transient String id;
169 
170     //-----------------------------------------------------------------------
171     /**
172      * Obtains an instance of {@code ZoneOffset} using the ID.
173      * &lt;p&gt;
174      * This method parses the string ID of a {@code ZoneOffset} to
175      * return an instance. The parsing accepts all the formats generated by
176      * {@link #getId()}, plus some additional formats:
177      * &lt;ul&gt;
178      * &lt;li&gt;{@code Z} - for UTC
179      * &lt;li&gt;{@code +h}
180      * &lt;li&gt;{@code +hh}
181      * &lt;li&gt;{@code +hh:mm}
182      * &lt;li&gt;{@code -hh:mm}
183      * &lt;li&gt;{@code +hhmm}
184      * &lt;li&gt;{@code -hhmm}
185      * &lt;li&gt;{@code +hh:mm:ss}
186      * &lt;li&gt;{@code -hh:mm:ss}
187      * &lt;li&gt;{@code +hhmmss}
188      * &lt;li&gt;{@code -hhmmss}
189      * &lt;/ul&gt;
190      * Note that &amp;plusmn; means either the plus or minus symbol.
191      * &lt;p&gt;
192      * The ID of the returned offset will be normalized to one of the formats
193      * described by {@link #getId()}.
194      * &lt;p&gt;
195      * The maximum supported range is from +18:00 to -18:00 inclusive.
196      *
197      * @param offsetId  the offset ID, not null
198      * @return the zone-offset, not null
199      * @throws DateTimeException if the offset ID is invalid
200      */
201     @SuppressWarnings(&quot;fallthrough&quot;)
202     public static ZoneOffset of(String offsetId) {
203         Objects.requireNonNull(offsetId, &quot;offsetId&quot;);
204         // &quot;Z&quot; is always in the cache
205         ZoneOffset offset = ID_CACHE.get(offsetId);
206         if (offset != null) {
207             return offset;
208         }
209 
210         // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss
211         final int hours, minutes, seconds;
212         switch (offsetId.length()) {
213             case 2:
214                 offsetId = offsetId.charAt(0) + &quot;0&quot; + offsetId.charAt(1);  // fallthru
215             case 3:
216                 hours = parseNumber(offsetId, 1, false);
217                 minutes = 0;
218                 seconds = 0;
219                 break;
220             case 5:
221                 hours = parseNumber(offsetId, 1, false);
222                 minutes = parseNumber(offsetId, 3, false);
223                 seconds = 0;
224                 break;
225             case 6:
226                 hours = parseNumber(offsetId, 1, false);
227                 minutes = parseNumber(offsetId, 4, true);
228                 seconds = 0;
229                 break;
230             case 7:
231                 hours = parseNumber(offsetId, 1, false);
232                 minutes = parseNumber(offsetId, 3, false);
233                 seconds = parseNumber(offsetId, 5, false);
234                 break;
235             case 9:
236                 hours = parseNumber(offsetId, 1, false);
237                 minutes = parseNumber(offsetId, 4, true);
238                 seconds = parseNumber(offsetId, 7, true);
239                 break;
240             default:
241                 throw new DateTimeException(&quot;Invalid ID for ZoneOffset, invalid format: &quot; + offsetId);
242         }
243         char first = offsetId.charAt(0);
244         if (first != &#39;+&#39; &amp;&amp; first != &#39;-&#39;) {
245             throw new DateTimeException(&quot;Invalid ID for ZoneOffset, plus/minus not found when expected: &quot; + offsetId);
246         }
247         if (first == &#39;-&#39;) {
248             return ofHoursMinutesSeconds(-hours, -minutes, -seconds);
249         } else {
250             return ofHoursMinutesSeconds(hours, minutes, seconds);
251         }
252     }
253 
254     /**
255      * Parse a two digit zero-prefixed number.
256      *
257      * @param offsetId  the offset ID, not null
258      * @param pos  the position to parse, valid
259      * @param precededByColon  should this number be prefixed by a precededByColon
260      * @return the parsed number, from 0 to 99
261      */
262     private static int parseNumber(CharSequence offsetId, int pos, boolean precededByColon) {
263         if (precededByColon &amp;&amp; offsetId.charAt(pos - 1) != &#39;:&#39;) {
264             throw new DateTimeException(&quot;Invalid ID for ZoneOffset, colon not found when expected: &quot; + offsetId);
265         }
266         char ch1 = offsetId.charAt(pos);
267         char ch2 = offsetId.charAt(pos + 1);
268         if (ch1 &lt; &#39;0&#39; || ch1 &gt; &#39;9&#39; || ch2 &lt; &#39;0&#39; || ch2 &gt; &#39;9&#39;) {
269             throw new DateTimeException(&quot;Invalid ID for ZoneOffset, non numeric characters found: &quot; + offsetId);
270         }
271         return (ch1 - 48) * 10 + (ch2 - 48);
272     }
273 
274     //-----------------------------------------------------------------------
275     /**
276      * Obtains an instance of {@code ZoneOffset} using an offset in hours.
277      *
278      * @param hours  the time-zone offset in hours, from -18 to +18
279      * @return the zone-offset, not null
280      * @throws DateTimeException if the offset is not in the required range
281      */
282     public static ZoneOffset ofHours(int hours) {
283         return ofHoursMinutesSeconds(hours, 0, 0);
284     }
285 
286     /**
287      * Obtains an instance of {@code ZoneOffset} using an offset in
288      * hours and minutes.
289      * &lt;p&gt;
290      * The sign of the hours and minutes components must match.
291      * Thus, if the hours is negative, the minutes must be negative or zero.
292      * If the hours is zero, the minutes may be positive, negative or zero.
293      *
294      * @param hours  the time-zone offset in hours, from -18 to +18
295      * @param minutes  the time-zone offset in minutes, from 0 to &amp;plusmn;59, sign matches hours
296      * @return the zone-offset, not null
297      * @throws DateTimeException if the offset is not in the required range
298      */
299     public static ZoneOffset ofHoursMinutes(int hours, int minutes) {
300         return ofHoursMinutesSeconds(hours, minutes, 0);
301     }
302 
303     /**
304      * Obtains an instance of {@code ZoneOffset} using an offset in
305      * hours, minutes and seconds.
306      * &lt;p&gt;
307      * The sign of the hours, minutes and seconds components must match.
308      * Thus, if the hours is negative, the minutes and seconds must be negative or zero.
309      *
310      * @param hours  the time-zone offset in hours, from -18 to +18
311      * @param minutes  the time-zone offset in minutes, from 0 to &amp;plusmn;59, sign matches hours and seconds
312      * @param seconds  the time-zone offset in seconds, from 0 to &amp;plusmn;59, sign matches hours and minutes
313      * @return the zone-offset, not null
314      * @throws DateTimeException if the offset is not in the required range
315      */
316     public static ZoneOffset ofHoursMinutesSeconds(int hours, int minutes, int seconds) {
317         validate(hours, minutes, seconds);
318         int totalSeconds = totalSeconds(hours, minutes, seconds);
319         return ofTotalSeconds(totalSeconds);
320     }
321 
322     //-----------------------------------------------------------------------
323     /**
324      * Obtains an instance of {@code ZoneOffset} from a temporal object.
325      * &lt;p&gt;
326      * This obtains an offset based on the specified temporal.
327      * A {@code TemporalAccessor} represents an arbitrary set of date and time information,
328      * which this factory converts to an instance of {@code ZoneOffset}.
329      * &lt;p&gt;
330      * A {@code TemporalAccessor} represents some form of date and time information.
331      * This factory converts the arbitrary temporal object to an instance of {@code ZoneOffset}.
332      * &lt;p&gt;
333      * The conversion uses the {@link TemporalQueries#offset()} query, which relies
334      * on extracting the {@link ChronoField#OFFSET_SECONDS OFFSET_SECONDS} field.
335      * &lt;p&gt;
336      * This method matches the signature of the functional interface {@link TemporalQuery}
337      * allowing it to be used as a query via method reference, {@code ZoneOffset::from}.
338      *
339      * @param temporal  the temporal object to convert, not null
340      * @return the zone-offset, not null
341      * @throws DateTimeException if unable to convert to an {@code ZoneOffset}
342      */
343     public static ZoneOffset from(TemporalAccessor temporal) {
344         Objects.requireNonNull(temporal, &quot;temporal&quot;);
345         ZoneOffset offset = temporal.query(TemporalQueries.offset());
346         if (offset == null) {
347             throw new DateTimeException(&quot;Unable to obtain ZoneOffset from TemporalAccessor: &quot; +
348                     temporal + &quot; of type &quot; + temporal.getClass().getName());
349         }
350         return offset;
351     }
352 
353     //-----------------------------------------------------------------------
354     /**
355      * Validates the offset fields.
356      *
357      * @param hours  the time-zone offset in hours, from -18 to +18
358      * @param minutes  the time-zone offset in minutes, from 0 to &amp;plusmn;59
359      * @param seconds  the time-zone offset in seconds, from 0 to &amp;plusmn;59
360      * @throws DateTimeException if the offset is not in the required range
361      */
362     private static void validate(int hours, int minutes, int seconds) {
363         if (hours &lt; -18 || hours &gt; 18) {
364             throw new DateTimeException(&quot;Zone offset hours not in valid range: value &quot; + hours +
365                     &quot; is not in the range -18 to 18&quot;);
366         }
367         if (hours &gt; 0) {
368             if (minutes &lt; 0 || seconds &lt; 0) {
369                 throw new DateTimeException(&quot;Zone offset minutes and seconds must be positive because hours is positive&quot;);
370             }
371         } else if (hours &lt; 0) {
372             if (minutes &gt; 0 || seconds &gt; 0) {
373                 throw new DateTimeException(&quot;Zone offset minutes and seconds must be negative because hours is negative&quot;);
374             }
375         } else if ((minutes &gt; 0 &amp;&amp; seconds &lt; 0) || (minutes &lt; 0 &amp;&amp; seconds &gt; 0)) {
376             throw new DateTimeException(&quot;Zone offset minutes and seconds must have the same sign&quot;);
377         }
378         if (minutes &lt; -59 || minutes &gt; 59) {
379             throw new DateTimeException(&quot;Zone offset minutes not in valid range: value &quot; +
380                     minutes + &quot; is not in the range -59 to 59&quot;);
381         }
382         if (seconds &lt; -59 || seconds &gt; 59) {
383             throw new DateTimeException(&quot;Zone offset seconds not in valid range: value &quot; +
384                     seconds + &quot; is not in the range -59 to 59&quot;);
385         }
386         if (Math.abs(hours) == 18 &amp;&amp; (minutes | seconds) != 0) {
387             throw new DateTimeException(&quot;Zone offset not in valid range: -18:00 to +18:00&quot;);
388         }
389     }
390 
391     /**
392      * Calculates the total offset in seconds.
393      *
394      * @param hours  the time-zone offset in hours, from -18 to +18
395      * @param minutes  the time-zone offset in minutes, from 0 to &amp;plusmn;59, sign matches hours and seconds
396      * @param seconds  the time-zone offset in seconds, from 0 to &amp;plusmn;59, sign matches hours and minutes
397      * @return the total in seconds
398      */
399     private static int totalSeconds(int hours, int minutes, int seconds) {
400         return hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;
401     }
402 
403     //-----------------------------------------------------------------------
404     /**
405      * Obtains an instance of {@code ZoneOffset} specifying the total offset in seconds
406      * &lt;p&gt;
407      * The offset must be in the range {@code -18:00} to {@code +18:00}, which corresponds to -64800 to +64800.
408      *
409      * @param totalSeconds  the total time-zone offset in seconds, from -64800 to +64800
410      * @return the ZoneOffset, not null
411      * @throws DateTimeException if the offset is not in the required range
412      */
413     public static ZoneOffset ofTotalSeconds(int totalSeconds) {
414         if (totalSeconds &lt; -MAX_SECONDS || totalSeconds &gt; MAX_SECONDS) {
415             throw new DateTimeException(&quot;Zone offset not in valid range: -18:00 to +18:00&quot;);
416         }
417         if (totalSeconds % (15 * SECONDS_PER_MINUTE) == 0) {
418             Integer totalSecs = totalSeconds;
419             ZoneOffset result = SECONDS_CACHE.get(totalSecs);
420             if (result == null) {
421                 result = new ZoneOffset(totalSeconds);
422                 SECONDS_CACHE.putIfAbsent(totalSecs, result);
423                 result = SECONDS_CACHE.get(totalSecs);
424                 ID_CACHE.putIfAbsent(result.getId(), result);
425             }
426             return result;
427         } else {
428             return new ZoneOffset(totalSeconds);
429         }
430     }
431 
432     //-----------------------------------------------------------------------
433     /**
434      * Constructor.
435      *
436      * @param totalSeconds  the total time-zone offset in seconds, from -64800 to +64800
437      */
438     private ZoneOffset(int totalSeconds) {
439         super();
440         this.totalSeconds = totalSeconds;
441         id = buildId(totalSeconds);
442     }
443 
444     private static String buildId(int totalSeconds) {
445         if (totalSeconds == 0) {
446             return &quot;Z&quot;;
447         } else {
448             int absTotalSeconds = Math.abs(totalSeconds);
449             StringBuilder buf = new StringBuilder();
450             int absHours = absTotalSeconds / SECONDS_PER_HOUR;
451             int absMinutes = (absTotalSeconds / SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;
452             buf.append(totalSeconds &lt; 0 ? &quot;-&quot; : &quot;+&quot;)
453                 .append(absHours &lt; 10 ? &quot;0&quot; : &quot;&quot;).append(absHours)
454                 .append(absMinutes &lt; 10 ? &quot;:0&quot; : &quot;:&quot;).append(absMinutes);
455             int absSeconds = absTotalSeconds % SECONDS_PER_MINUTE;
456             if (absSeconds != 0) {
457                 buf.append(absSeconds &lt; 10 ? &quot;:0&quot; : &quot;:&quot;).append(absSeconds);
458             }
459             return buf.toString();
460         }
461     }
462 
463     //-----------------------------------------------------------------------
464     /**
465      * Gets the total zone offset in seconds.
466      * &lt;p&gt;
467      * This is the primary way to access the offset amount.
468      * It returns the total of the hours, minutes and seconds fields as a
469      * single offset that can be added to a time.
470      *
471      * @return the total zone offset amount in seconds
472      */
473     public int getTotalSeconds() {
474         return totalSeconds;
475     }
476 
477     /**
478      * Gets the normalized zone offset ID.
479      * &lt;p&gt;
480      * The ID is minor variation to the standard ISO-8601 formatted string
481      * for the offset. There are three formats:
482      * &lt;ul&gt;
483      * &lt;li&gt;{@code Z} - for UTC (ISO-8601)
484      * &lt;li&gt;{@code +hh:mm} or {@code -hh:mm} - if the seconds are zero (ISO-8601)
485      * &lt;li&gt;{@code +hh:mm:ss} or {@code -hh:mm:ss} - if the seconds are non-zero (not ISO-8601)
486      * &lt;/ul&gt;
487      *
488      * @return the zone offset ID, not null
489      */
490     @Override
491     public String getId() {
492         return id;
493     }
494 
495     /**
496      * Gets the associated time-zone rules.
497      * &lt;p&gt;
498      * The rules will always return this offset when queried.
499      * The implementation class is immutable, thread-safe and serializable.
500      *
501      * @return the rules, not null
502      */
503     @Override
504     public ZoneRules getRules() {
505         return ZoneRules.of(this);
506     }
507 
508     //-----------------------------------------------------------------------
509     /**
510      * Checks if the specified field is supported.
511      * &lt;p&gt;
512      * This checks if this offset can be queried for the specified field.
513      * If false, then calling the {@link #range(TemporalField) range} and
514      * {@link #get(TemporalField) get} methods will throw an exception.
515      * &lt;p&gt;
516      * If the field is a {@link ChronoField} then the query is implemented here.
517      * The {@code OFFSET_SECONDS} field returns true.
518      * All other {@code ChronoField} instances will return false.
519      * &lt;p&gt;
520      * If the field is not a {@code ChronoField}, then the result of this method
521      * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
522      * passing {@code this} as the argument.
523      * Whether the field is supported is determined by the field.
524      *
525      * @param field  the field to check, null returns false
526      * @return true if the field is supported on this offset, false if not
527      */
528     @Override
529     public boolean isSupported(TemporalField field) {
530         if (field instanceof ChronoField) {
531             return field == OFFSET_SECONDS;
532         }
533         return field != null &amp;&amp; field.isSupportedBy(this);
534     }
535 
536     /**
537      * Gets the range of valid values for the specified field.
538      * &lt;p&gt;
539      * The range object expresses the minimum and maximum valid values for a field.
540      * This offset is used to enhance the accuracy of the returned range.
541      * If it is not possible to return the range, because the field is not supported
542      * or for some other reason, an exception is thrown.
543      * &lt;p&gt;
544      * If the field is a {@link ChronoField} then the query is implemented here.
545      * The {@link #isSupported(TemporalField) supported fields} will return
546      * appropriate range instances.
547      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
548      * &lt;p&gt;
549      * If the field is not a {@code ChronoField}, then the result of this method
550      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
551      * passing {@code this} as the argument.
552      * Whether the range can be obtained is determined by the field.
553      *
554      * @param field  the field to query the range for, not null
555      * @return the range of valid values for the field, not null
556      * @throws DateTimeException if the range for the field cannot be obtained
557      * @throws UnsupportedTemporalTypeException if the field is not supported
558      */
559     @Override  // override for Javadoc
560     public ValueRange range(TemporalField field) {
561         return TemporalAccessor.super.range(field);
562     }
563 
564     /**
565      * Gets the value of the specified field from this offset as an {@code int}.
566      * &lt;p&gt;
567      * This queries this offset for the value of the specified field.
568      * The returned value will always be within the valid range of values for the field.
569      * If it is not possible to return the value, because the field is not supported
570      * or for some other reason, an exception is thrown.
571      * &lt;p&gt;
572      * If the field is a {@link ChronoField} then the query is implemented here.
573      * The {@code OFFSET_SECONDS} field returns the value of the offset.
574      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
575      * &lt;p&gt;
576      * If the field is not a {@code ChronoField}, then the result of this method
577      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
578      * passing {@code this} as the argument. Whether the value can be obtained,
579      * and what the value represents, is determined by the field.
580      *
581      * @param field  the field to get, not null
582      * @return the value for the field
583      * @throws DateTimeException if a value for the field cannot be obtained or
584      *         the value is outside the range of valid values for the field
585      * @throws UnsupportedTemporalTypeException if the field is not supported or
586      *         the range of values exceeds an {@code int}
587      * @throws ArithmeticException if numeric overflow occurs
588      */
589     @Override  // override for Javadoc and performance
590     public int get(TemporalField field) {
591         if (field == OFFSET_SECONDS) {
592             return totalSeconds;
593         } else if (field instanceof ChronoField) {
594             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
595         }
596         return range(field).checkValidIntValue(getLong(field), field);
597     }
598 
599     /**
600      * Gets the value of the specified field from this offset as a {@code long}.
601      * &lt;p&gt;
602      * This queries this offset for the value of the specified field.
603      * If it is not possible to return the value, because the field is not supported
604      * or for some other reason, an exception is thrown.
605      * &lt;p&gt;
606      * If the field is a {@link ChronoField} then the query is implemented here.
607      * The {@code OFFSET_SECONDS} field returns the value of the offset.
608      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
609      * &lt;p&gt;
610      * If the field is not a {@code ChronoField}, then the result of this method
611      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
612      * passing {@code this} as the argument. Whether the value can be obtained,
613      * and what the value represents, is determined by the field.
614      *
615      * @param field  the field to get, not null
616      * @return the value for the field
617      * @throws DateTimeException if a value for the field cannot be obtained
618      * @throws UnsupportedTemporalTypeException if the field is not supported
619      * @throws ArithmeticException if numeric overflow occurs
620      */
621     @Override
622     public long getLong(TemporalField field) {
623         if (field == OFFSET_SECONDS) {
624             return totalSeconds;
625         } else if (field instanceof ChronoField) {
626             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
627         }
628         return field.getFrom(this);
629     }
630 
631     //-----------------------------------------------------------------------
632     /**
633      * Queries this offset using the specified query.
634      * &lt;p&gt;
635      * This queries this offset using the specified query strategy object.
636      * The {@code TemporalQuery} object defines the logic to be used to
637      * obtain the result. Read the documentation of the query to understand
638      * what the result of this method will be.
639      * &lt;p&gt;
640      * The result of this method is obtained by invoking the
641      * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
642      * specified query passing {@code this} as the argument.
643      *
644      * @param &lt;R&gt; the type of the result
645      * @param query  the query to invoke, not null
646      * @return the query result, null may be returned (defined by the query)
647      * @throws DateTimeException if unable to query (defined by the query)
648      * @throws ArithmeticException if numeric overflow occurs (defined by the query)
649      */
650     @SuppressWarnings(&quot;unchecked&quot;)
651     @Override
652     public &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) {
653         if (query == TemporalQueries.offset() || query == TemporalQueries.zone()) {
654             return (R) this;
655         }
656         return TemporalAccessor.super.query(query);
657     }
658 
659     /**
660      * Adjusts the specified temporal object to have the same offset as this object.
661      * &lt;p&gt;
662      * This returns a temporal object of the same observable type as the input
663      * with the offset changed to be the same as this.
664      * &lt;p&gt;
665      * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
666      * passing {@link ChronoField#OFFSET_SECONDS} as the field.
667      * &lt;p&gt;
668      * In most cases, it is clearer to reverse the calling pattern by using
669      * {@link Temporal#with(TemporalAdjuster)}:
670      * &lt;pre&gt;
671      *   // these two lines are equivalent, but the second approach is recommended
672      *   temporal = thisOffset.adjustInto(temporal);
673      *   temporal = temporal.with(thisOffset);
674      * &lt;/pre&gt;
675      * &lt;p&gt;
676      * This instance is immutable and unaffected by this method call.
677      *
678      * @param temporal  the target object to be adjusted, not null
679      * @return the adjusted object, not null
680      * @throws DateTimeException if unable to make the adjustment
681      * @throws ArithmeticException if numeric overflow occurs
682      */
683     @Override
684     public Temporal adjustInto(Temporal temporal) {
685         return temporal.with(OFFSET_SECONDS, totalSeconds);
686     }
687 
688     //-----------------------------------------------------------------------
689     /**
690      * Compares this offset to another offset in descending order.
691      * &lt;p&gt;
692      * The offsets are compared in the order that they occur for the same time
693      * of day around the world. Thus, an offset of {@code +10:00} comes before an
694      * offset of {@code +09:00} and so on down to {@code -18:00}.
695      * &lt;p&gt;
696      * The comparison is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
697      *
698      * @param other  the other date to compare to, not null
699      * @return the comparator value, negative if less, positive if greater
700      * @throws NullPointerException if {@code other} is null
701      */
702     @Override
703     public int compareTo(ZoneOffset other) {
704         // abs(totalSeconds) &lt;= MAX_SECONDS, so no overflow can happen here
705         return other.totalSeconds - totalSeconds;
706     }
707 
708     //-----------------------------------------------------------------------
709     /**
710      * Checks if this offset is equal to another offset.
711      * &lt;p&gt;
712      * The comparison is based on the amount of the offset in seconds.
713      * This is equivalent to a comparison by ID.
714      *
715      * @param obj  the object to check, null returns false
716      * @return true if this is equal to the other offset
717      */
718     @Override
719     public boolean equals(Object obj) {
720         if (this == obj) {
721            return true;
722         }
723         if (obj instanceof ZoneOffset) {
724             return totalSeconds == ((ZoneOffset) obj).totalSeconds;
725         }
726         return false;
727     }
728 
729     /**
730      * A hash code for this offset.
731      *
732      * @return a suitable hash code
733      */
734     @Override
735     public int hashCode() {
736         return totalSeconds;
737     }
738 
739     //-----------------------------------------------------------------------
740     /**
741      * Outputs this offset as a {@code String}, using the normalized ID.
742      *
743      * @return a string representation of this offset, not null
744      */
745     @Override
746     public String toString() {
747         return id;
748     }
749 
750     // -----------------------------------------------------------------------
751     /**
752      * Writes the object using a
753      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
754      * @serialData
755      * &lt;pre&gt;
756      *  out.writeByte(8);                  // identifies a ZoneOffset
757      *  int offsetByte = totalSeconds % 900 == 0 ? totalSeconds / 900 : 127;
758      *  out.writeByte(offsetByte);
759      *  if (offsetByte == 127) {
760      *      out.writeInt(totalSeconds);
761      *  }
762      * &lt;/pre&gt;
763      *
764      * @return the instance of {@code Ser}, not null
765      */
766     private Object writeReplace() {
767         return new Ser(Ser.ZONE_OFFSET_TYPE, this);
768     }
769 
770     /**
771      * Defend against malicious streams.
772      *
773      * @param s the stream to read
774      * @throws InvalidObjectException always
775      */
776     private void readObject(ObjectInputStream s) throws InvalidObjectException {
777         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
778     }
779 
780     @Override
781     void write(DataOutput out) throws IOException {
782         out.writeByte(Ser.ZONE_OFFSET_TYPE);
783         writeExternal(out);
784     }
785 
786     void writeExternal(DataOutput out) throws IOException {
787         final int offsetSecs = totalSeconds;
788         int offsetByte = offsetSecs % 900 == 0 ? offsetSecs / 900 : 127;  // compress to -72 to +72
789         out.writeByte(offsetByte);
790         if (offsetByte == 127) {
791             out.writeInt(offsetSecs);
792         }
793     }
794 
795     static ZoneOffset readExternal(DataInput in) throws IOException {
796         int offsetByte = in.readByte();
797         return (offsetByte == 127 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(offsetByte * 900));
798     }
799 
800 }
    </pre>
  </body>
</html>
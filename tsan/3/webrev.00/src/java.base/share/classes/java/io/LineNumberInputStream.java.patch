diff a/src/java.base/share/classes/java/io/LineNumberInputStream.java b/src/java.base/share/classes/java/io/LineNumberInputStream.java
--- a/src/java.base/share/classes/java/io/LineNumberInputStream.java
+++ b/src/java.base/share/classes/java/io/LineNumberInputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -45,12 +45,11 @@
  *             characters.  As of JDK&nbsp;1.1, the preferred way to operate on
  *             character streams is via the new character-stream classes, which
  *             include a class for counting line numbers.
  */
 @Deprecated
-public
-class LineNumberInputStream extends FilterInputStream {
+public class LineNumberInputStream extends FilterInputStream {
     int pushBack = -1;
     int lineNumber;
     int markLineNumber;
     int markPushBack = -1;
 
@@ -81,11 +80,11 @@
      * a carriage return followed by a newline character are both
      * converted into a single newline character.
      *
      * @return     the next byte of data, or {@code -1} if the end of this
      *             stream is reached.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.FilterInputStream#in
      * @see        java.io.LineNumberInputStream#getLineNumber()
      */
     @SuppressWarnings("fallthrough")
     public int read() throws IOException {
@@ -122,11 +121,11 @@
      * @param      off   the start offset of the data.
      * @param      len   the maximum number of bytes read.
      * @return     the total number of bytes read into the buffer, or
      *             {@code -1} if there is no more data because the end of
      *             this stream has been reached.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.LineNumberInputStream#read()
      */
     public int read(byte b[], int off, int len) throws IOException {
         if (b == null) {
             throw new NullPointerException();
@@ -171,11 +170,11 @@
      * {@code n} bytes have been read or the end of the stream has
      * been reached.
      *
      * @param      n   the number of bytes to be skipped.
      * @return     the actual number of bytes skipped.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.FilterInputStream#in
      */
     public long skip(long n) throws IOException {
         int chunk = 2048;
         long remaining = n;
@@ -232,11 +231,11 @@
      * {@code '\u005Cn'}, which are converted to just
      * <i>k</i>/2 {@code '\u005Cn'} characters.
      *
      * @return     the number of bytes that can be read from this input stream
      *             without blocking.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.FilterInputStream#in
      */
     public int available() throws IOException {
         return (pushBack == -1) ? super.available()/2 : super.available()/2 + 1;
     }
@@ -279,11 +278,11 @@
      * parser, it just chugs along happily. If the stream is not of
      * that type, the parser should toss an exception when it fails,
      * which, if it happens within readlimit bytes, allows the outer
      * code to reset the stream and try another parser.
      *
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      * @see        java.io.FilterInputStream#in
      * @see        java.io.LineNumberInputStream#mark(int)
      */
     public void reset() throws IOException {
         lineNumber = markLineNumber;

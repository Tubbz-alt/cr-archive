<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/URL.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="URISyntaxException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/URL.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.net.spi.URLStreamHandlerProvider;
  32 import java.nio.file.Path;
  33 import java.security.AccessController;
  34 import java.security.PrivilegedAction;
  35 import java.util.Hashtable;
  36 import java.io.InvalidObjectException;
  37 import java.io.ObjectStreamException;
  38 import java.io.ObjectStreamField;
  39 import java.io.ObjectInputStream.GetField;
  40 import java.util.Iterator;
  41 import java.util.Locale;
  42 import java.util.NoSuchElementException;
  43 import java.util.ServiceConfigurationError;
  44 import java.util.ServiceLoader;
  45 
  46 import jdk.internal.access.JavaNetURLAccess;
  47 import jdk.internal.access.SharedSecrets;


  48 import sun.security.util.SecurityConstants;
  49 import sun.security.action.GetPropertyAction;
  50 
  51 /**
  52  * Class {@code URL} represents a Uniform Resource
  53  * Locator, a pointer to a &quot;resource&quot; on the World
  54  * Wide Web. A resource can be something as simple as a file or a
  55  * directory, or it can be a reference to a more complicated object,
  56  * such as a query to a database or to a search engine. More
  57  * information on the types of URLs and their formats can be found at:
  58  * &lt;a href=
  59  * &quot;http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html&quot;&gt;
  60  * &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
  61  * &lt;p&gt;
  62  * In general, a URL can be broken into several parts. Consider the
  63  * following example:
  64  * &lt;blockquote&gt;&lt;pre&gt;
  65  *     http://www.example.com/docs/resource1.html
  66  * &lt;/pre&gt;&lt;/blockquote&gt;
  67  * &lt;p&gt;
</pre>
<hr />
<pre>
 157  * can be used to create a {@link URI} from a file path, which can be
 158  * converted to URL using {@link URI#toURL()}.
 159  * Applications should never try to {@linkplain #URL(String, String, String)
 160  * construct} or {@linkplain #URL(String) parse} a {@code URL}
 161  * from the direct string representation of a {@code File} or {@code Path}
 162  * instance.
 163  * &lt;p&gt;
 164  * Some components of a URL or URI, such as &lt;i&gt;userinfo&lt;/i&gt;, may
 165  * be abused to construct misleading URLs or URIs. Applications
 166  * that deal with URLs or URIs should take into account
 167  * the recommendations advised in &lt;a
 168  * href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;RFC3986,
 169  * Section 7, Security Considerations&lt;/a&gt;.
 170  *
 171  * @author  James Gosling
 172  * @since 1.0
 173  */
 174 public final class URL implements java.io.Serializable {
 175 
 176     static final String BUILTIN_HANDLERS_PREFIX = &quot;sun.net.www.protocol&quot;;

 177     static final long serialVersionUID = -7627629688361524110L;
 178 
 179     /**
 180      * The property which specifies the package prefix list to be scanned
 181      * for protocol handlers.  The value of this property (if any) should
 182      * be a vertical bar delimited list of package names to search through
 183      * for a protocol handler to load.  The policy of this class is that
 184      * all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
 185      * and each package in the list is examined in turn for a matching
 186      * handler.  If none are found (or the property is not specified), the
 187      * default package prefix, sun.net.www.protocol, is used.  The search
 188      * proceeds from the first package in the list to the last and stops
 189      * when a match is found.
 190      */
 191     private static final String protocolPathProp = &quot;java.protocol.handler.pkgs&quot;;
 192 
 193     /**
 194      * The protocol to use (ftp, http, nntp, ... etc.) .
 195      * @serial
 196      */
</pre>
<hr />
<pre>
 310      *     If the value of that system property is not {@code null},
 311      *     it is interpreted as a list of packages separated by a vertical
 312      *     slash character &#39;{@code |}&#39;. The constructor tries to load
 313      *     the class named:
 314      *     &lt;blockquote&gt;{@code
 315      *         &lt;package&gt;.&lt;protocol&gt;.Handler
 316      *     }&lt;/blockquote&gt;
 317      *     where {@code &lt;package&gt;} is replaced by the name of the package
 318      *     and {@code &lt;protocol&gt;} is replaced by the name of the protocol.
 319      *     If this class does not exist, or if the class exists but it is not
 320      *     a subclass of {@code URLStreamHandler}, then the next package
 321      *     in the list is tried.
 322      * &lt;li&gt;If the previous step fails to find a protocol handler, then the
 323      *     constructor tries to load a built-in protocol handler.
 324      *     If this class does not exist, or if the class exists but it is not a
 325      *     subclass of {@code URLStreamHandler}, then a
 326      *     {@code MalformedURLException} is thrown.
 327      * &lt;/ol&gt;
 328      *
 329      * &lt;p&gt;Protocol handlers for the following protocols are guaranteed
<span class="line-modified"> 330      * to exist on the search path :-</span>
<span class="line-modified"> 331      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-modified"> 332      *     http, https, file, and jar</span>
<span class="line-modified"> 333      * &lt;/pre&gt;&lt;/blockquote&gt;</span>



 334      * Protocol handlers for additional protocols may also be  available.
 335      * Some protocol handlers, for example those used for loading platform
 336      * classes or classes on the class path, may not be overridden. The details
 337      * of such restrictions, and when those restrictions apply (during
 338      * initialization of the runtime for example), are implementation specific
 339      * and therefore not specified
 340      *
 341      * &lt;p&gt;No validation of the inputs is performed by this constructor.
 342      *
 343      * @param      protocol   the name of the protocol to use.
 344      * @param      host       the name of the host.
 345      * @param      port       the port number on the host.
 346      * @param      file       the file on the host
<span class="line-modified"> 347      * @exception  MalformedURLException  if an unknown protocol or the port</span>
 348      *                  is a negative number other than -1
 349      * @see        java.lang.System#getProperty(java.lang.String)
 350      * @see        java.net.URL#setURLStreamHandlerFactory(
 351      *                  java.net.URLStreamHandlerFactory)
 352      * @see        java.net.URLStreamHandler
 353      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 354      *                  java.lang.String)
 355      */
 356     public URL(String protocol, String host, int port, String file)
 357         throws MalformedURLException
 358     {
 359         this(protocol, host, port, file, null);
 360     }
 361 
 362     /**
 363      * Creates a URL from the specified {@code protocol}
 364      * name, {@code host} name, and {@code file} name. The
 365      * default port for the specified protocol is used.
 366      * &lt;p&gt;
 367      * This constructor is equivalent to the four-argument
 368      * constructor with the only difference of using the
 369      * default port for the specified protocol.
 370      *
 371      * No validation of the inputs is performed by this constructor.
 372      *
 373      * @param      protocol   the name of the protocol to use.
 374      * @param      host       the name of the host.
 375      * @param      file       the file on the host.
<span class="line-modified"> 376      * @exception  MalformedURLException  if an unknown protocol is specified.</span>
 377      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 378      *                  int, java.lang.String)
 379      */
 380     public URL(String protocol, String host, String file)
 381             throws MalformedURLException {
 382         this(protocol, host, -1, file);
 383     }
 384 
 385     /**
 386      * Creates a {@code URL} object from the specified
 387      * {@code protocol}, {@code host}, {@code port}
 388      * number, {@code file}, and {@code handler}. Specifying
 389      * a {@code port} number of {@code -1} indicates that
 390      * the URL should use the default port for the protocol. Specifying
 391      * a {@code handler} of {@code null} indicates that the URL
 392      * should use a default stream handler for the protocol, as outlined
 393      * for:
 394      *     java.net.URL#URL(java.lang.String, java.lang.String, int,
 395      *                      java.lang.String)
 396      *
 397      * &lt;p&gt;If the handler is not null and there is a security manager,
 398      * the security manager&#39;s {@code checkPermission}
 399      * method is called with a
 400      * {@code NetPermission(&quot;specifyStreamHandler&quot;)} permission.
 401      * This may result in a SecurityException.
 402      *
 403      * No validation of the inputs is performed by this constructor.
 404      *
 405      * @param      protocol   the name of the protocol to use.
 406      * @param      host       the name of the host.
 407      * @param      port       the port number on the host.
 408      * @param      file       the file on the host
 409      * @param      handler    the stream handler for the URL.
<span class="line-modified"> 410      * @exception  MalformedURLException  if an unknown protocol or the port</span>
 411                         is a negative number other than -1
<span class="line-modified"> 412      * @exception  SecurityException</span>
 413      *        if a security manager exists and its
 414      *        {@code checkPermission} method doesn&#39;t allow
 415      *        specifying a stream handler explicitly.
 416      * @see        java.lang.System#getProperty(java.lang.String)
 417      * @see        java.net.URL#setURLStreamHandlerFactory(
 418      *                  java.net.URLStreamHandlerFactory)
 419      * @see        java.net.URLStreamHandler
 420      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 421      *                  java.lang.String)
 422      * @see        SecurityManager#checkPermission
 423      * @see        java.net.NetPermission
 424      */
 425     public URL(String protocol, String host, int port, String file,
 426                URLStreamHandler handler) throws MalformedURLException {
 427         if (handler != null) {
 428             SecurityManager sm = System.getSecurityManager();
 429             if (sm != null) {
 430                 // check for permission to specify a handler
 431                 checkSpecifyHandler(sm);
 432             }
</pre>
<hr />
<pre>
 449                 throw new MalformedURLException(&quot;Invalid port number :&quot; +
 450                                                     port);
 451             }
 452             this.port = port;
 453             authority = (port == -1) ? host : host + &quot;:&quot; + port;
 454         }
 455 
 456         int index = file.indexOf(&#39;#&#39;);
 457         this.ref = index &lt; 0 ? null : file.substring(index + 1);
 458         file = index &lt; 0 ? file : file.substring(0, index);
 459         int q = file.lastIndexOf(&#39;?&#39;);
 460         if (q != -1) {
 461             this.query = file.substring(q + 1);
 462             this.path = file.substring(0, q);
 463             this.file = path + &quot;?&quot; + query;
 464         } else {
 465             this.path = file;
 466             this.file = path;
 467         }
 468 
<span class="line-modified"> 469         // Note: we don&#39;t do validation of the URL here. Too risky to change</span>
 470         // right now, but worth considering for future reference. -br
 471         if (handler == null &amp;&amp;
 472             (handler = getURLStreamHandler(protocol)) == null) {
 473             throw new MalformedURLException(&quot;unknown protocol: &quot; + protocol);
 474         }
 475         this.handler = handler;
















 476     }
 477 
 478     /**
 479      * Creates a {@code URL} object from the {@code String}
 480      * representation.
 481      * &lt;p&gt;
 482      * This constructor is equivalent to a call to the two-argument
 483      * constructor with a {@code null} first argument.
 484      *
 485      * @param      spec   the {@code String} to parse as a URL.
<span class="line-modified"> 486      * @exception  MalformedURLException  if no protocol is specified, or an</span>
 487      *               unknown protocol is found, or {@code spec} is {@code null},
 488      *               or the parsed URL fails to comply with the specific syntax
 489      *               of the associated protocol.
 490      * @see        java.net.URL#URL(java.net.URL, java.lang.String)
 491      */
 492     public URL(String spec) throws MalformedURLException {
 493         this(null, spec);
 494     }
 495 
 496     /**
 497      * Creates a URL by parsing the given spec within a specified context.
 498      *
 499      * The new URL is created from the given context URL and the spec
 500      * argument as described in
 501      * RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
 502      * &lt;blockquote&gt;&lt;pre&gt;
 503      *          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
 504      * &lt;/pre&gt;&lt;/blockquote&gt;
 505      * The reference is parsed into the scheme, authority, path, query and
 506      * fragment parts. If the path component is empty and the scheme,
</pre>
<hr />
<pre>
 515      * &lt;p&gt;
 516      * If the authority component is present in the spec then the spec is
 517      * treated as absolute and the spec authority and path will replace the
 518      * context authority and path. If the authority component is absent in the
 519      * spec then the authority of the new URL will be inherited from the
 520      * context.
 521      * &lt;p&gt;
 522      * If the spec&#39;s path component begins with a slash character
 523      * &amp;quot;/&amp;quot; then the
 524      * path is treated as absolute and the spec path replaces the context path.
 525      * &lt;p&gt;
 526      * Otherwise, the path is treated as a relative path and is appended to the
 527      * context path, as described in RFC2396. Also, in this case,
 528      * the path is canonicalized through the removal of directory
 529      * changes made by occurrences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
 530      * &lt;p&gt;
 531      * For a more detailed description of URL parsing, refer to RFC2396.
 532      *
 533      * @param      context   the context in which to parse the specification.
 534      * @param      spec      the {@code String} to parse as a URL.
<span class="line-modified"> 535      * @exception  MalformedURLException  if no protocol is specified, or an</span>
 536      *               unknown protocol is found, or {@code spec} is {@code null},
 537      *               or the parsed URL fails to comply with the specific syntax
 538      *               of the associated protocol.
 539      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 540      *                  int, java.lang.String)
 541      * @see        java.net.URLStreamHandler
 542      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 543      *                  java.lang.String, int, int)
 544      */
 545     public URL(URL context, String spec) throws MalformedURLException {
 546         this(context, spec, null);
 547     }
 548 
 549     /**
 550      * Creates a URL by parsing the given spec with the specified handler
 551      * within a specified context. If the handler is null, the parsing
 552      * occurs as with the two argument constructor.
 553      *
 554      * @param      context   the context in which to parse the specification.
 555      * @param      spec      the {@code String} to parse as a URL.
 556      * @param      handler   the stream handler for the URL.
<span class="line-modified"> 557      * @exception  MalformedURLException  if no protocol is specified, or an</span>
 558      *               unknown protocol is found, or {@code spec} is {@code null},
 559      *               or the parsed URL fails to comply with the specific syntax
 560      *               of the associated protocol.
<span class="line-modified"> 561      * @exception  SecurityException</span>
 562      *        if a security manager exists and its
 563      *        {@code checkPermission} method doesn&#39;t allow
 564      *        specifying a stream handler.
 565      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 566      *                  int, java.lang.String)
 567      * @see        java.net.URLStreamHandler
 568      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 569      *                  java.lang.String, int, int)
 570      */
 571     public URL(URL context, String spec, URLStreamHandler handler)
 572         throws MalformedURLException
 573     {
 574         String original = spec;
 575         int i, limit, c;
 576         int start = 0;
 577         String newProtocol = null;
 578         boolean aRef=false;
 579         boolean isRelative = false;
 580 
 581         // Check for permission to specify a handler
</pre>
<hr />
<pre>
1014      * Constructs a string representation of this {@code URL}. The
1015      * string is created by calling the {@code toExternalForm}
1016      * method of the stream protocol handler for this object.
1017      *
1018      * @return  a string representation of this object.
1019      * @see     java.net.URL#URL(java.lang.String, java.lang.String,
1020      *                  int, java.lang.String)
1021      * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
1022      */
1023     public String toExternalForm() {
1024         return handler.toExternalForm(this);
1025     }
1026 
1027     /**
1028      * Returns a {@link java.net.URI} equivalent to this URL.
1029      * This method functions in the same way as {@code new URI (this.toString())}.
1030      * &lt;p&gt;Note, any URL instance that complies with RFC 2396 can be converted
1031      * to a URI. However, some URLs that are not strictly in compliance
1032      * can not be converted to a URI.
1033      *
<span class="line-modified">1034      * @exception URISyntaxException if this URL is not formatted strictly according to</span>
1035      *            RFC2396 and cannot be converted to a URI.
1036      *
1037      * @return    a URI instance equivalent to this URL.
1038      * @since 1.5
1039      */
1040     public URI toURI() throws URISyntaxException {
<span class="line-modified">1041         return new URI (toString());</span>





1042     }
1043 
1044     /**
1045      * Returns a {@link java.net.URLConnection URLConnection} instance that
1046      * represents a connection to the remote object referred to by the
1047      * {@code URL}.
1048      *
1049      * &lt;P&gt;A new instance of {@linkplain java.net.URLConnection URLConnection} is
1050      * created every time when invoking the
1051      * {@linkplain java.net.URLStreamHandler#openConnection(URL)
1052      * URLStreamHandler.openConnection(URL)} method of the protocol handler for
1053      * this URL.&lt;/P&gt;
1054      *
1055      * &lt;P&gt;It should be noted that a URLConnection instance does not establish
1056      * the actual network connection on creation. This will happen only when
1057      * calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.&lt;/P&gt;
1058      *
1059      * &lt;P&gt;If for the URL&#39;s protocol (such as HTTP or JAR), there
1060      * exists a public, specialized URLConnection subclass belonging
1061      * to one of the following packages or one of their subpackages:
1062      * java.lang, java.io, java.util, java.net, the connection
1063      * returned will be of that subclass. For example, for HTTP an
1064      * HttpURLConnection will be returned, and for JAR a
1065      * JarURLConnection will be returned.&lt;/P&gt;
1066      *
1067      * @return     a {@link java.net.URLConnection URLConnection} linking
1068      *             to the URL.
<span class="line-modified">1069      * @exception  IOException  if an I/O exception occurs.</span>
1070      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1071      *             int, java.lang.String)
1072      */
1073     public URLConnection openConnection() throws java.io.IOException {
1074         return handler.openConnection(this);
1075     }
1076 
1077     /**
1078      * Same as {@link #openConnection()}, except that the connection will be
1079      * made through the specified proxy; Protocol handlers that do not
1080      * support proxying will ignore the proxy parameter and make a
1081      * normal connection.
1082      *
1083      * Invoking this method preempts the system&#39;s default
1084      * {@link java.net.ProxySelector ProxySelector} settings.
1085      *
1086      * @param      proxy the Proxy through which this connection
1087      *             will be made. If direct connection is desired,
1088      *             Proxy.NO_PROXY should be specified.
1089      * @return     a {@code URLConnection} to the URL.
<span class="line-modified">1090      * @exception  IOException  if an I/O exception occurs.</span>
<span class="line-modified">1091      * @exception  SecurityException if a security manager is present</span>
1092      *             and the caller doesn&#39;t have permission to connect
1093      *             to the proxy.
<span class="line-modified">1094      * @exception  IllegalArgumentException will be thrown if proxy is null,</span>
1095      *             or proxy has the wrong type
<span class="line-modified">1096      * @exception  UnsupportedOperationException if the subclass that</span>
1097      *             implements the protocol handler doesn&#39;t support
1098      *             this method.
1099      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1100      *             int, java.lang.String)
1101      * @see        java.net.URLConnection
1102      * @see        java.net.URLStreamHandler#openConnection(java.net.URL,
1103      *             java.net.Proxy)
1104      * @since      1.5
1105      */
1106     public URLConnection openConnection(Proxy proxy)
1107         throws java.io.IOException {
1108         if (proxy == null) {
1109             throw new IllegalArgumentException(&quot;proxy can not be null&quot;);
1110         }
1111 
1112         // Create a copy of Proxy as a security measure
1113         Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY : sun.net.ApplicationProxy.create(proxy);
1114         SecurityManager sm = System.getSecurityManager();
1115         if (p.type() != Proxy.Type.DIRECT &amp;&amp; sm != null) {
1116             InetSocketAddress epoint = (InetSocketAddress) p.address();
1117             if (epoint.isUnresolved())
1118                 sm.checkConnect(epoint.getHostName(), epoint.getPort());
1119             else
1120                 sm.checkConnect(epoint.getAddress().getHostAddress(),
1121                                 epoint.getPort());
1122         }
1123         return handler.openConnection(this, p);
1124     }
1125 
1126     /**
1127      * Opens a connection to this {@code URL} and returns an
1128      * {@code InputStream} for reading from that connection. This
1129      * method is a shorthand for:
1130      * &lt;blockquote&gt;&lt;pre&gt;
1131      *     openConnection().getInputStream()
1132      * &lt;/pre&gt;&lt;/blockquote&gt;
1133      *
1134      * @return     an input stream for reading from the URL connection.
<span class="line-modified">1135      * @exception  IOException  if an I/O exception occurs.</span>
1136      * @see        java.net.URL#openConnection()
1137      * @see        java.net.URLConnection#getInputStream()
1138      */
1139     public final InputStream openStream() throws java.io.IOException {
1140         return openConnection().getInputStream();
1141     }
1142 
1143     /**
1144      * Gets the contents of this URL. This method is a shorthand for:
1145      * &lt;blockquote&gt;&lt;pre&gt;
1146      *     openConnection().getContent()
1147      * &lt;/pre&gt;&lt;/blockquote&gt;
1148      *
1149      * @return     the contents of this URL.
<span class="line-modified">1150      * @exception  IOException  if an I/O exception occurs.</span>
1151      * @see        java.net.URLConnection#getContent()
1152      */
1153     public final Object getContent() throws java.io.IOException {
1154         return openConnection().getContent();
1155     }
1156 
1157     /**
1158      * Gets the contents of this URL. This method is a shorthand for:
1159      * &lt;blockquote&gt;&lt;pre&gt;
1160      *     openConnection().getContent(classes)
1161      * &lt;/pre&gt;&lt;/blockquote&gt;
1162      *
1163      * @param classes an array of Java types
1164      * @return     the content object of this URL that is the first match of
1165      *               the types specified in the classes array.
1166      *               null if none of the requested types are supported.
<span class="line-modified">1167      * @exception  IOException  if an I/O exception occurs.</span>
1168      * @see        java.net.URLConnection#getContent(Class[])
1169      * @since 1.3
1170      */
1171     public final Object getContent(Class&lt;?&gt;[] classes)
1172     throws java.io.IOException {
1173         return openConnection().getContent(classes);
1174     }
1175 
1176     /**
1177      * The URLStreamHandler factory.
1178      */
1179     private static volatile URLStreamHandlerFactory factory;
1180 
1181     /**
1182      * Sets an application&#39;s {@code URLStreamHandlerFactory}.
1183      * This method can be called at most once in a given Java Virtual
1184      * Machine.
1185      *
1186      *&lt;p&gt; The {@code URLStreamHandlerFactory} instance is used to
1187      *construct a stream protocol handler from a protocol name.
1188      *
1189      * &lt;p&gt; If there is a security manager, this method first calls
1190      * the security manager&#39;s {@code checkSetFactory} method
1191      * to ensure the operation is allowed.
1192      * This could result in a SecurityException.
1193      *
1194      * @param      fac   the desired factory.
<span class="line-modified">1195      * @exception  Error  if the application has already set a factory.</span>
<span class="line-modified">1196      * @exception  SecurityException  if a security manager exists and its</span>
1197      *             {@code checkSetFactory} method doesn&#39;t allow
1198      *             the operation.
1199      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1200      *             int, java.lang.String)
1201      * @see        java.net.URLStreamHandlerFactory
1202      * @see        SecurityManager#checkSetFactory
1203      */
1204     public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac) {
1205         synchronized (streamHandlerLock) {
1206             if (factory != null) {
1207                 throw new Error(&quot;factory already defined&quot;);
1208             }
1209             SecurityManager security = System.getSecurityManager();
1210             if (security != null) {
1211                 security.checkSetFactory();
1212             }
1213             handlers.clear();
1214 
1215             // safe publication of URLStreamHandlerFactory with volatile write
1216             factory = fac;
</pre>
<hr />
<pre>
1386     /**
1387      * A table of protocol handlers.
1388      */
1389     static Hashtable&lt;String,URLStreamHandler&gt; handlers = new Hashtable&lt;&gt;();
1390     private static final Object streamHandlerLock = new Object();
1391 
1392     /**
1393      * Returns the Stream Handler.
1394      * @param protocol the protocol to use
1395      */
1396     static URLStreamHandler getURLStreamHandler(String protocol) {
1397 
1398         URLStreamHandler handler = handlers.get(protocol);
1399 
1400         if (handler != null) {
1401             return handler;
1402         }
1403 
1404         URLStreamHandlerFactory fac;
1405         boolean checkedWithFactory = false;

1406 
<span class="line-modified">1407         if (isOverrideable(protocol) &amp;&amp; jdk.internal.misc.VM.isBooted()) {</span>
1408             // Use the factory (if any). Volatile read makes
1409             // URLStreamHandlerFactory appear fully initialized to current thread.
1410             fac = factory;
1411             if (fac != null) {
1412                 handler = fac.createURLStreamHandler(protocol);
1413                 checkedWithFactory = true;
1414             }
1415 
1416             if (handler == null &amp;&amp; !protocol.equalsIgnoreCase(&quot;jar&quot;)) {
1417                 handler = lookupViaProviders(protocol);
1418             }
1419 
1420             if (handler == null) {
1421                 handler = lookupViaProperty(protocol);
1422             }
1423         }
1424 
1425         if (handler == null) {
1426             // Try the built-in protocol handler
1427             handler = defaultFactory.createURLStreamHandler(protocol);
1428         }
1429 
1430         synchronized (streamHandlerLock) {
1431             URLStreamHandler handler2 = null;
1432 
1433             // Check again with hashtable just in case another
1434             // thread created a handler since we last checked
1435             handler2 = handlers.get(protocol);
1436 
1437             if (handler2 != null) {
1438                 return handler2;
1439             }
1440 
1441             // Check with factory if another thread set a
1442             // factory since our last check
<span class="line-modified">1443             if (!checkedWithFactory &amp;&amp; (fac = factory) != null) {</span>

1444                 handler2 = fac.createURLStreamHandler(protocol);
1445             }
1446 
1447             if (handler2 != null) {
1448                 // The handler from the factory must be given more
1449                 // importance. Discard the default handler that
1450                 // this thread created.
1451                 handler = handler2;
1452             }
1453 
1454             // Insert this handler into the hashtable
1455             if (handler != null) {
1456                 handlers.put(protocol, handler);
1457             }
1458         }
1459         return handler;
1460     }
1461 
1462     /**
1463      * @serialField    protocol String
1464      *
1465      * @serialField    host String
1466      *
1467      * @serialField    port int
1468      *
1469      * @serialField    authority String
1470      *
1471      * @serialField    file String
1472      *
1473      * @serialField    ref String
1474      *
1475      * @serialField    hashCode int
1476      *
1477      */

1478     private static final ObjectStreamField[] serialPersistentFields = {
1479         new ObjectStreamField(&quot;protocol&quot;, String.class),
1480         new ObjectStreamField(&quot;host&quot;, String.class),
1481         new ObjectStreamField(&quot;port&quot;, int.class),
1482         new ObjectStreamField(&quot;authority&quot;, String.class),
1483         new ObjectStreamField(&quot;file&quot;, String.class),
1484         new ObjectStreamField(&quot;ref&quot;, String.class),
1485         new ObjectStreamField(&quot;hashCode&quot;, int.class), };
1486 
1487     /**
1488      * WriteObject is called to save the state of the URL to an
1489      * ObjectOutputStream. The handler is not saved since it is
1490      * specific to this system.
1491      *
1492      * @serialData the default write object value. When read back in,
1493      * the reader must ensure that calling getURLStreamHandler with
1494      * the protocol variable returns a valid URLStreamHandler and
1495      * throw an IOException if it does not.
1496      */

1497     private synchronized void writeObject(java.io.ObjectOutputStream s)
1498         throws IOException
1499     {
1500         s.defaultWriteObject(); // write the fields
1501     }
1502 
1503     /**
1504      * readObject is called to restore the state of the URL from the
1505      * stream.  It reads the components of the URL and finds the local
1506      * stream handler.
1507      */

1508     private synchronized void readObject(java.io.ObjectInputStream s)
1509             throws IOException, ClassNotFoundException {
1510         GetField gf = s.readFields();
1511         String protocol = (String)gf.get(&quot;protocol&quot;, null);
1512         if (getURLStreamHandler(protocol) == null) {
1513             throw new IOException(&quot;unknown protocol: &quot; + protocol);
1514         }
1515         String host = (String)gf.get(&quot;host&quot;, null);
1516         int port = gf.get(&quot;port&quot;, -1);
1517         String authority = (String)gf.get(&quot;authority&quot;, null);
1518         String file = (String)gf.get(&quot;file&quot;, null);
1519         String ref = (String)gf.get(&quot;ref&quot;, null);
1520         int hashCode = gf.get(&quot;hashCode&quot;, -1);
1521         if (authority == null
1522                 &amp;&amp; ((host != null &amp;&amp; !host.isEmpty()) || port != -1)) {
1523             if (host == null)
1524                 host = &quot;&quot;;
1525             authority = (port == -1) ? host : host + &quot;:&quot; + port;
1526         }
1527         tempState = new UrlDeserializedState(protocol, host, port, authority,
1528                file, ref, hashCode);
1529     }
1530 
1531     /**
1532      * Replaces the de-serialized object with an URL object.
1533      *
1534      * @return a newly created object from deserialized data
1535      *
1536      * @throws ObjectStreamException if a new object replacing this
1537      * object could not be created
1538      */
<span class="line-modified">1539 </span>
1540    private Object readResolve() throws ObjectStreamException {
1541 
1542         URLStreamHandler handler = null;
1543         // already been checked in readObject
1544         handler = getURLStreamHandler(tempState.getProtocol());
1545 
1546         URL replacementURL = null;
1547         if (isBuiltinStreamHandler(handler.getClass().getName())) {
1548             replacementURL = fabricateNewURL();
1549         } else {
1550             replacementURL = setDeserializedFields(handler);
1551         }
1552         return replacementURL;
1553     }
1554 
1555     private URL setDeserializedFields(URLStreamHandler handler) {
1556         URL replacementURL;
1557         String userInfo = null;
1558         String protocol = tempState.getProtocol();
1559         String host = tempState.getHost();
</pre>
<hr />
<pre>
1616     private URL fabricateNewURL()
1617                 throws InvalidObjectException {
1618         // create URL string from deserialized object
1619         URL replacementURL = null;
1620         String urlString = tempState.reconstituteUrlString();
1621 
1622         try {
1623             replacementURL = new URL(urlString);
1624         } catch (MalformedURLException mEx) {
1625             resetState();
1626             InvalidObjectException invoEx = new InvalidObjectException(
1627                     &quot;Malformed URL:  &quot; + urlString);
1628             invoEx.initCause(mEx);
1629             throw invoEx;
1630         }
1631         replacementURL.setSerializedHashCode(tempState.getHashCode());
1632         resetState();
1633         return replacementURL;
1634     }
1635 






1636     private boolean isBuiltinStreamHandler(String handlerClassName) {
1637         return (handlerClassName.startsWith(BUILTIN_HANDLERS_PREFIX));
1638     }
1639 
1640     private void resetState() {
1641         this.protocol = null;
1642         this.host = null;
1643         this.port = -1;
1644         this.file = null;
1645         this.authority = null;
1646         this.ref = null;
1647         this.hashCode = -1;
1648         this.handler = null;
1649         this.query = null;
1650         this.path = null;
1651         this.userInfo = null;
1652         this.tempState = null;
1653     }
1654 
1655     private void setSerializedHashCode(int hc) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.net.spi.URLStreamHandlerProvider;
  32 import java.nio.file.Path;
  33 import java.security.AccessController;
  34 import java.security.PrivilegedAction;
  35 import java.util.Hashtable;
  36 import java.io.InvalidObjectException;
  37 import java.io.ObjectStreamException;
  38 import java.io.ObjectStreamField;
  39 import java.io.ObjectInputStream.GetField;
  40 import java.util.Iterator;
  41 import java.util.Locale;
  42 import java.util.NoSuchElementException;
  43 import java.util.ServiceConfigurationError;
  44 import java.util.ServiceLoader;
  45 
  46 import jdk.internal.access.JavaNetURLAccess;
  47 import jdk.internal.access.SharedSecrets;
<span class="line-added">  48 import jdk.internal.misc.VM;</span>
<span class="line-added">  49 import sun.net.util.IPAddressUtil;</span>
  50 import sun.security.util.SecurityConstants;
  51 import sun.security.action.GetPropertyAction;
  52 
  53 /**
  54  * Class {@code URL} represents a Uniform Resource
  55  * Locator, a pointer to a &quot;resource&quot; on the World
  56  * Wide Web. A resource can be something as simple as a file or a
  57  * directory, or it can be a reference to a more complicated object,
  58  * such as a query to a database or to a search engine. More
  59  * information on the types of URLs and their formats can be found at:
  60  * &lt;a href=
  61  * &quot;http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html&quot;&gt;
  62  * &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
  63  * &lt;p&gt;
  64  * In general, a URL can be broken into several parts. Consider the
  65  * following example:
  66  * &lt;blockquote&gt;&lt;pre&gt;
  67  *     http://www.example.com/docs/resource1.html
  68  * &lt;/pre&gt;&lt;/blockquote&gt;
  69  * &lt;p&gt;
</pre>
<hr />
<pre>
 159  * can be used to create a {@link URI} from a file path, which can be
 160  * converted to URL using {@link URI#toURL()}.
 161  * Applications should never try to {@linkplain #URL(String, String, String)
 162  * construct} or {@linkplain #URL(String) parse} a {@code URL}
 163  * from the direct string representation of a {@code File} or {@code Path}
 164  * instance.
 165  * &lt;p&gt;
 166  * Some components of a URL or URI, such as &lt;i&gt;userinfo&lt;/i&gt;, may
 167  * be abused to construct misleading URLs or URIs. Applications
 168  * that deal with URLs or URIs should take into account
 169  * the recommendations advised in &lt;a
 170  * href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;RFC3986,
 171  * Section 7, Security Considerations&lt;/a&gt;.
 172  *
 173  * @author  James Gosling
 174  * @since 1.0
 175  */
 176 public final class URL implements java.io.Serializable {
 177 
 178     static final String BUILTIN_HANDLERS_PREFIX = &quot;sun.net.www.protocol&quot;;
<span class="line-added"> 179     @java.io.Serial</span>
 180     static final long serialVersionUID = -7627629688361524110L;
 181 
 182     /**
 183      * The property which specifies the package prefix list to be scanned
 184      * for protocol handlers.  The value of this property (if any) should
 185      * be a vertical bar delimited list of package names to search through
 186      * for a protocol handler to load.  The policy of this class is that
 187      * all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
 188      * and each package in the list is examined in turn for a matching
 189      * handler.  If none are found (or the property is not specified), the
 190      * default package prefix, sun.net.www.protocol, is used.  The search
 191      * proceeds from the first package in the list to the last and stops
 192      * when a match is found.
 193      */
 194     private static final String protocolPathProp = &quot;java.protocol.handler.pkgs&quot;;
 195 
 196     /**
 197      * The protocol to use (ftp, http, nntp, ... etc.) .
 198      * @serial
 199      */
</pre>
<hr />
<pre>
 313      *     If the value of that system property is not {@code null},
 314      *     it is interpreted as a list of packages separated by a vertical
 315      *     slash character &#39;{@code |}&#39;. The constructor tries to load
 316      *     the class named:
 317      *     &lt;blockquote&gt;{@code
 318      *         &lt;package&gt;.&lt;protocol&gt;.Handler
 319      *     }&lt;/blockquote&gt;
 320      *     where {@code &lt;package&gt;} is replaced by the name of the package
 321      *     and {@code &lt;protocol&gt;} is replaced by the name of the protocol.
 322      *     If this class does not exist, or if the class exists but it is not
 323      *     a subclass of {@code URLStreamHandler}, then the next package
 324      *     in the list is tried.
 325      * &lt;li&gt;If the previous step fails to find a protocol handler, then the
 326      *     constructor tries to load a built-in protocol handler.
 327      *     If this class does not exist, or if the class exists but it is not a
 328      *     subclass of {@code URLStreamHandler}, then a
 329      *     {@code MalformedURLException} is thrown.
 330      * &lt;/ol&gt;
 331      *
 332      * &lt;p&gt;Protocol handlers for the following protocols are guaranteed
<span class="line-modified"> 333      * to exist on the search path:</span>
<span class="line-modified"> 334      * &lt;ul&gt;</span>
<span class="line-modified"> 335      * &lt;li&gt;{@code http}&lt;/li&gt;</span>
<span class="line-modified"> 336      * &lt;li&gt;{@code https}&lt;/li&gt;</span>
<span class="line-added"> 337      * &lt;li&gt;{@code file}&lt;/li&gt;</span>
<span class="line-added"> 338      * &lt;li&gt;{@code jar}&lt;/li&gt;</span>
<span class="line-added"> 339      * &lt;/ul&gt;</span>
 340      * Protocol handlers for additional protocols may also be  available.
 341      * Some protocol handlers, for example those used for loading platform
 342      * classes or classes on the class path, may not be overridden. The details
 343      * of such restrictions, and when those restrictions apply (during
 344      * initialization of the runtime for example), are implementation specific
 345      * and therefore not specified
 346      *
 347      * &lt;p&gt;No validation of the inputs is performed by this constructor.
 348      *
 349      * @param      protocol   the name of the protocol to use.
 350      * @param      host       the name of the host.
 351      * @param      port       the port number on the host.
 352      * @param      file       the file on the host
<span class="line-modified"> 353      * @throws     MalformedURLException  if an unknown protocol or the port</span>
 354      *                  is a negative number other than -1
 355      * @see        java.lang.System#getProperty(java.lang.String)
 356      * @see        java.net.URL#setURLStreamHandlerFactory(
 357      *                  java.net.URLStreamHandlerFactory)
 358      * @see        java.net.URLStreamHandler
 359      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 360      *                  java.lang.String)
 361      */
 362     public URL(String protocol, String host, int port, String file)
 363         throws MalformedURLException
 364     {
 365         this(protocol, host, port, file, null);
 366     }
 367 
 368     /**
 369      * Creates a URL from the specified {@code protocol}
 370      * name, {@code host} name, and {@code file} name. The
 371      * default port for the specified protocol is used.
 372      * &lt;p&gt;
 373      * This constructor is equivalent to the four-argument
 374      * constructor with the only difference of using the
 375      * default port for the specified protocol.
 376      *
 377      * No validation of the inputs is performed by this constructor.
 378      *
 379      * @param      protocol   the name of the protocol to use.
 380      * @param      host       the name of the host.
 381      * @param      file       the file on the host.
<span class="line-modified"> 382      * @throws     MalformedURLException  if an unknown protocol is specified.</span>
 383      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 384      *                  int, java.lang.String)
 385      */
 386     public URL(String protocol, String host, String file)
 387             throws MalformedURLException {
 388         this(protocol, host, -1, file);
 389     }
 390 
 391     /**
 392      * Creates a {@code URL} object from the specified
 393      * {@code protocol}, {@code host}, {@code port}
 394      * number, {@code file}, and {@code handler}. Specifying
 395      * a {@code port} number of {@code -1} indicates that
 396      * the URL should use the default port for the protocol. Specifying
 397      * a {@code handler} of {@code null} indicates that the URL
 398      * should use a default stream handler for the protocol, as outlined
 399      * for:
 400      *     java.net.URL#URL(java.lang.String, java.lang.String, int,
 401      *                      java.lang.String)
 402      *
 403      * &lt;p&gt;If the handler is not null and there is a security manager,
 404      * the security manager&#39;s {@code checkPermission}
 405      * method is called with a
 406      * {@code NetPermission(&quot;specifyStreamHandler&quot;)} permission.
 407      * This may result in a SecurityException.
 408      *
 409      * No validation of the inputs is performed by this constructor.
 410      *
 411      * @param      protocol   the name of the protocol to use.
 412      * @param      host       the name of the host.
 413      * @param      port       the port number on the host.
 414      * @param      file       the file on the host
 415      * @param      handler    the stream handler for the URL.
<span class="line-modified"> 416      * @throws     MalformedURLException  if an unknown protocol or the port</span>
 417                         is a negative number other than -1
<span class="line-modified"> 418      * @throws     SecurityException</span>
 419      *        if a security manager exists and its
 420      *        {@code checkPermission} method doesn&#39;t allow
 421      *        specifying a stream handler explicitly.
 422      * @see        java.lang.System#getProperty(java.lang.String)
 423      * @see        java.net.URL#setURLStreamHandlerFactory(
 424      *                  java.net.URLStreamHandlerFactory)
 425      * @see        java.net.URLStreamHandler
 426      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 427      *                  java.lang.String)
 428      * @see        SecurityManager#checkPermission
 429      * @see        java.net.NetPermission
 430      */
 431     public URL(String protocol, String host, int port, String file,
 432                URLStreamHandler handler) throws MalformedURLException {
 433         if (handler != null) {
 434             SecurityManager sm = System.getSecurityManager();
 435             if (sm != null) {
 436                 // check for permission to specify a handler
 437                 checkSpecifyHandler(sm);
 438             }
</pre>
<hr />
<pre>
 455                 throw new MalformedURLException(&quot;Invalid port number :&quot; +
 456                                                     port);
 457             }
 458             this.port = port;
 459             authority = (port == -1) ? host : host + &quot;:&quot; + port;
 460         }
 461 
 462         int index = file.indexOf(&#39;#&#39;);
 463         this.ref = index &lt; 0 ? null : file.substring(index + 1);
 464         file = index &lt; 0 ? file : file.substring(0, index);
 465         int q = file.lastIndexOf(&#39;?&#39;);
 466         if (q != -1) {
 467             this.query = file.substring(q + 1);
 468             this.path = file.substring(0, q);
 469             this.file = path + &quot;?&quot; + query;
 470         } else {
 471             this.path = file;
 472             this.file = path;
 473         }
 474 
<span class="line-modified"> 475         // Note: we don&#39;t do full validation of the URL here. Too risky to change</span>
 476         // right now, but worth considering for future reference. -br
 477         if (handler == null &amp;&amp;
 478             (handler = getURLStreamHandler(protocol)) == null) {
 479             throw new MalformedURLException(&quot;unknown protocol: &quot; + protocol);
 480         }
 481         this.handler = handler;
<span class="line-added"> 482         if (host != null &amp;&amp; isBuiltinStreamHandler(handler)) {</span>
<span class="line-added"> 483             String s = IPAddressUtil.checkExternalForm(this);</span>
<span class="line-added"> 484             if (s != null) {</span>
<span class="line-added"> 485                 throw new MalformedURLException(s);</span>
<span class="line-added"> 486             }</span>
<span class="line-added"> 487         }</span>
<span class="line-added"> 488         if (&quot;jar&quot;.equalsIgnoreCase(protocol)) {</span>
<span class="line-added"> 489             if (handler instanceof sun.net.www.protocol.jar.Handler) {</span>
<span class="line-added"> 490                 // URL.openConnection() would throw a confusing exception</span>
<span class="line-added"> 491                 // so generate a better exception here instead.</span>
<span class="line-added"> 492                 String s = ((sun.net.www.protocol.jar.Handler) handler).checkNestedProtocol(file);</span>
<span class="line-added"> 493                 if (s != null) {</span>
<span class="line-added"> 494                     throw new MalformedURLException(s);</span>
<span class="line-added"> 495                 }</span>
<span class="line-added"> 496             }</span>
<span class="line-added"> 497         }</span>
 498     }
 499 
 500     /**
 501      * Creates a {@code URL} object from the {@code String}
 502      * representation.
 503      * &lt;p&gt;
 504      * This constructor is equivalent to a call to the two-argument
 505      * constructor with a {@code null} first argument.
 506      *
 507      * @param      spec   the {@code String} to parse as a URL.
<span class="line-modified"> 508      * @throws     MalformedURLException  if no protocol is specified, or an</span>
 509      *               unknown protocol is found, or {@code spec} is {@code null},
 510      *               or the parsed URL fails to comply with the specific syntax
 511      *               of the associated protocol.
 512      * @see        java.net.URL#URL(java.net.URL, java.lang.String)
 513      */
 514     public URL(String spec) throws MalformedURLException {
 515         this(null, spec);
 516     }
 517 
 518     /**
 519      * Creates a URL by parsing the given spec within a specified context.
 520      *
 521      * The new URL is created from the given context URL and the spec
 522      * argument as described in
 523      * RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
 524      * &lt;blockquote&gt;&lt;pre&gt;
 525      *          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
 526      * &lt;/pre&gt;&lt;/blockquote&gt;
 527      * The reference is parsed into the scheme, authority, path, query and
 528      * fragment parts. If the path component is empty and the scheme,
</pre>
<hr />
<pre>
 537      * &lt;p&gt;
 538      * If the authority component is present in the spec then the spec is
 539      * treated as absolute and the spec authority and path will replace the
 540      * context authority and path. If the authority component is absent in the
 541      * spec then the authority of the new URL will be inherited from the
 542      * context.
 543      * &lt;p&gt;
 544      * If the spec&#39;s path component begins with a slash character
 545      * &amp;quot;/&amp;quot; then the
 546      * path is treated as absolute and the spec path replaces the context path.
 547      * &lt;p&gt;
 548      * Otherwise, the path is treated as a relative path and is appended to the
 549      * context path, as described in RFC2396. Also, in this case,
 550      * the path is canonicalized through the removal of directory
 551      * changes made by occurrences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
 552      * &lt;p&gt;
 553      * For a more detailed description of URL parsing, refer to RFC2396.
 554      *
 555      * @param      context   the context in which to parse the specification.
 556      * @param      spec      the {@code String} to parse as a URL.
<span class="line-modified"> 557      * @throws     MalformedURLException  if no protocol is specified, or an</span>
 558      *               unknown protocol is found, or {@code spec} is {@code null},
 559      *               or the parsed URL fails to comply with the specific syntax
 560      *               of the associated protocol.
 561      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 562      *                  int, java.lang.String)
 563      * @see        java.net.URLStreamHandler
 564      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 565      *                  java.lang.String, int, int)
 566      */
 567     public URL(URL context, String spec) throws MalformedURLException {
 568         this(context, spec, null);
 569     }
 570 
 571     /**
 572      * Creates a URL by parsing the given spec with the specified handler
 573      * within a specified context. If the handler is null, the parsing
 574      * occurs as with the two argument constructor.
 575      *
 576      * @param      context   the context in which to parse the specification.
 577      * @param      spec      the {@code String} to parse as a URL.
 578      * @param      handler   the stream handler for the URL.
<span class="line-modified"> 579      * @throws     MalformedURLException  if no protocol is specified, or an</span>
 580      *               unknown protocol is found, or {@code spec} is {@code null},
 581      *               or the parsed URL fails to comply with the specific syntax
 582      *               of the associated protocol.
<span class="line-modified"> 583      * @throws     SecurityException</span>
 584      *        if a security manager exists and its
 585      *        {@code checkPermission} method doesn&#39;t allow
 586      *        specifying a stream handler.
 587      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 588      *                  int, java.lang.String)
 589      * @see        java.net.URLStreamHandler
 590      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 591      *                  java.lang.String, int, int)
 592      */
 593     public URL(URL context, String spec, URLStreamHandler handler)
 594         throws MalformedURLException
 595     {
 596         String original = spec;
 597         int i, limit, c;
 598         int start = 0;
 599         String newProtocol = null;
 600         boolean aRef=false;
 601         boolean isRelative = false;
 602 
 603         // Check for permission to specify a handler
</pre>
<hr />
<pre>
1036      * Constructs a string representation of this {@code URL}. The
1037      * string is created by calling the {@code toExternalForm}
1038      * method of the stream protocol handler for this object.
1039      *
1040      * @return  a string representation of this object.
1041      * @see     java.net.URL#URL(java.lang.String, java.lang.String,
1042      *                  int, java.lang.String)
1043      * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
1044      */
1045     public String toExternalForm() {
1046         return handler.toExternalForm(this);
1047     }
1048 
1049     /**
1050      * Returns a {@link java.net.URI} equivalent to this URL.
1051      * This method functions in the same way as {@code new URI (this.toString())}.
1052      * &lt;p&gt;Note, any URL instance that complies with RFC 2396 can be converted
1053      * to a URI. However, some URLs that are not strictly in compliance
1054      * can not be converted to a URI.
1055      *
<span class="line-modified">1056      * @throws    URISyntaxException if this URL is not formatted strictly according to</span>
1057      *            RFC2396 and cannot be converted to a URI.
1058      *
1059      * @return    a URI instance equivalent to this URL.
1060      * @since 1.5
1061      */
1062     public URI toURI() throws URISyntaxException {
<span class="line-modified">1063         URI uri = new URI(toString());</span>
<span class="line-added">1064         if (authority != null &amp;&amp; isBuiltinStreamHandler(handler)) {</span>
<span class="line-added">1065             String s = IPAddressUtil.checkAuthority(this);</span>
<span class="line-added">1066             if (s != null) throw new URISyntaxException(authority, s);</span>
<span class="line-added">1067         }</span>
<span class="line-added">1068         return uri;</span>
1069     }
1070 
1071     /**
1072      * Returns a {@link java.net.URLConnection URLConnection} instance that
1073      * represents a connection to the remote object referred to by the
1074      * {@code URL}.
1075      *
1076      * &lt;P&gt;A new instance of {@linkplain java.net.URLConnection URLConnection} is
1077      * created every time when invoking the
1078      * {@linkplain java.net.URLStreamHandler#openConnection(URL)
1079      * URLStreamHandler.openConnection(URL)} method of the protocol handler for
1080      * this URL.&lt;/P&gt;
1081      *
1082      * &lt;P&gt;It should be noted that a URLConnection instance does not establish
1083      * the actual network connection on creation. This will happen only when
1084      * calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.&lt;/P&gt;
1085      *
1086      * &lt;P&gt;If for the URL&#39;s protocol (such as HTTP or JAR), there
1087      * exists a public, specialized URLConnection subclass belonging
1088      * to one of the following packages or one of their subpackages:
1089      * java.lang, java.io, java.util, java.net, the connection
1090      * returned will be of that subclass. For example, for HTTP an
1091      * HttpURLConnection will be returned, and for JAR a
1092      * JarURLConnection will be returned.&lt;/P&gt;
1093      *
1094      * @return     a {@link java.net.URLConnection URLConnection} linking
1095      *             to the URL.
<span class="line-modified">1096      * @throws     IOException  if an I/O exception occurs.</span>
1097      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1098      *             int, java.lang.String)
1099      */
1100     public URLConnection openConnection() throws java.io.IOException {
1101         return handler.openConnection(this);
1102     }
1103 
1104     /**
1105      * Same as {@link #openConnection()}, except that the connection will be
1106      * made through the specified proxy; Protocol handlers that do not
1107      * support proxying will ignore the proxy parameter and make a
1108      * normal connection.
1109      *
1110      * Invoking this method preempts the system&#39;s default
1111      * {@link java.net.ProxySelector ProxySelector} settings.
1112      *
1113      * @param      proxy the Proxy through which this connection
1114      *             will be made. If direct connection is desired,
1115      *             Proxy.NO_PROXY should be specified.
1116      * @return     a {@code URLConnection} to the URL.
<span class="line-modified">1117      * @throws     IOException  if an I/O exception occurs.</span>
<span class="line-modified">1118      * @throws     SecurityException if a security manager is present</span>
1119      *             and the caller doesn&#39;t have permission to connect
1120      *             to the proxy.
<span class="line-modified">1121      * @throws     IllegalArgumentException will be thrown if proxy is null,</span>
1122      *             or proxy has the wrong type
<span class="line-modified">1123      * @throws     UnsupportedOperationException if the subclass that</span>
1124      *             implements the protocol handler doesn&#39;t support
1125      *             this method.
1126      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1127      *             int, java.lang.String)
1128      * @see        java.net.URLConnection
1129      * @see        java.net.URLStreamHandler#openConnection(java.net.URL,
1130      *             java.net.Proxy)
1131      * @since      1.5
1132      */
1133     public URLConnection openConnection(Proxy proxy)
1134         throws java.io.IOException {
1135         if (proxy == null) {
1136             throw new IllegalArgumentException(&quot;proxy can not be null&quot;);
1137         }
1138 
1139         // Create a copy of Proxy as a security measure
1140         Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY : sun.net.ApplicationProxy.create(proxy);
1141         SecurityManager sm = System.getSecurityManager();
1142         if (p.type() != Proxy.Type.DIRECT &amp;&amp; sm != null) {
1143             InetSocketAddress epoint = (InetSocketAddress) p.address();
1144             if (epoint.isUnresolved())
1145                 sm.checkConnect(epoint.getHostName(), epoint.getPort());
1146             else
1147                 sm.checkConnect(epoint.getAddress().getHostAddress(),
1148                                 epoint.getPort());
1149         }
1150         return handler.openConnection(this, p);
1151     }
1152 
1153     /**
1154      * Opens a connection to this {@code URL} and returns an
1155      * {@code InputStream} for reading from that connection. This
1156      * method is a shorthand for:
1157      * &lt;blockquote&gt;&lt;pre&gt;
1158      *     openConnection().getInputStream()
1159      * &lt;/pre&gt;&lt;/blockquote&gt;
1160      *
1161      * @return     an input stream for reading from the URL connection.
<span class="line-modified">1162      * @throws     IOException  if an I/O exception occurs.</span>
1163      * @see        java.net.URL#openConnection()
1164      * @see        java.net.URLConnection#getInputStream()
1165      */
1166     public final InputStream openStream() throws java.io.IOException {
1167         return openConnection().getInputStream();
1168     }
1169 
1170     /**
1171      * Gets the contents of this URL. This method is a shorthand for:
1172      * &lt;blockquote&gt;&lt;pre&gt;
1173      *     openConnection().getContent()
1174      * &lt;/pre&gt;&lt;/blockquote&gt;
1175      *
1176      * @return     the contents of this URL.
<span class="line-modified">1177      * @throws     IOException  if an I/O exception occurs.</span>
1178      * @see        java.net.URLConnection#getContent()
1179      */
1180     public final Object getContent() throws java.io.IOException {
1181         return openConnection().getContent();
1182     }
1183 
1184     /**
1185      * Gets the contents of this URL. This method is a shorthand for:
1186      * &lt;blockquote&gt;&lt;pre&gt;
1187      *     openConnection().getContent(classes)
1188      * &lt;/pre&gt;&lt;/blockquote&gt;
1189      *
1190      * @param classes an array of Java types
1191      * @return     the content object of this URL that is the first match of
1192      *               the types specified in the classes array.
1193      *               null if none of the requested types are supported.
<span class="line-modified">1194      * @throws     IOException  if an I/O exception occurs.</span>
1195      * @see        java.net.URLConnection#getContent(Class[])
1196      * @since 1.3
1197      */
1198     public final Object getContent(Class&lt;?&gt;[] classes)
1199     throws java.io.IOException {
1200         return openConnection().getContent(classes);
1201     }
1202 
1203     /**
1204      * The URLStreamHandler factory.
1205      */
1206     private static volatile URLStreamHandlerFactory factory;
1207 
1208     /**
1209      * Sets an application&#39;s {@code URLStreamHandlerFactory}.
1210      * This method can be called at most once in a given Java Virtual
1211      * Machine.
1212      *
1213      *&lt;p&gt; The {@code URLStreamHandlerFactory} instance is used to
1214      *construct a stream protocol handler from a protocol name.
1215      *
1216      * &lt;p&gt; If there is a security manager, this method first calls
1217      * the security manager&#39;s {@code checkSetFactory} method
1218      * to ensure the operation is allowed.
1219      * This could result in a SecurityException.
1220      *
1221      * @param      fac   the desired factory.
<span class="line-modified">1222      * @throws     Error  if the application has already set a factory.</span>
<span class="line-modified">1223      * @throws     SecurityException  if a security manager exists and its</span>
1224      *             {@code checkSetFactory} method doesn&#39;t allow
1225      *             the operation.
1226      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1227      *             int, java.lang.String)
1228      * @see        java.net.URLStreamHandlerFactory
1229      * @see        SecurityManager#checkSetFactory
1230      */
1231     public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac) {
1232         synchronized (streamHandlerLock) {
1233             if (factory != null) {
1234                 throw new Error(&quot;factory already defined&quot;);
1235             }
1236             SecurityManager security = System.getSecurityManager();
1237             if (security != null) {
1238                 security.checkSetFactory();
1239             }
1240             handlers.clear();
1241 
1242             // safe publication of URLStreamHandlerFactory with volatile write
1243             factory = fac;
</pre>
<hr />
<pre>
1413     /**
1414      * A table of protocol handlers.
1415      */
1416     static Hashtable&lt;String,URLStreamHandler&gt; handlers = new Hashtable&lt;&gt;();
1417     private static final Object streamHandlerLock = new Object();
1418 
1419     /**
1420      * Returns the Stream Handler.
1421      * @param protocol the protocol to use
1422      */
1423     static URLStreamHandler getURLStreamHandler(String protocol) {
1424 
1425         URLStreamHandler handler = handlers.get(protocol);
1426 
1427         if (handler != null) {
1428             return handler;
1429         }
1430 
1431         URLStreamHandlerFactory fac;
1432         boolean checkedWithFactory = false;
<span class="line-added">1433         boolean overrideableProtocol = isOverrideable(protocol);</span>
1434 
<span class="line-modified">1435         if (overrideableProtocol &amp;&amp; VM.isBooted()) {</span>
1436             // Use the factory (if any). Volatile read makes
1437             // URLStreamHandlerFactory appear fully initialized to current thread.
1438             fac = factory;
1439             if (fac != null) {
1440                 handler = fac.createURLStreamHandler(protocol);
1441                 checkedWithFactory = true;
1442             }
1443 
1444             if (handler == null &amp;&amp; !protocol.equalsIgnoreCase(&quot;jar&quot;)) {
1445                 handler = lookupViaProviders(protocol);
1446             }
1447 
1448             if (handler == null) {
1449                 handler = lookupViaProperty(protocol);
1450             }
1451         }
1452 
1453         if (handler == null) {
1454             // Try the built-in protocol handler
1455             handler = defaultFactory.createURLStreamHandler(protocol);
1456         }
1457 
1458         synchronized (streamHandlerLock) {
1459             URLStreamHandler handler2 = null;
1460 
1461             // Check again with hashtable just in case another
1462             // thread created a handler since we last checked
1463             handler2 = handlers.get(protocol);
1464 
1465             if (handler2 != null) {
1466                 return handler2;
1467             }
1468 
1469             // Check with factory if another thread set a
1470             // factory since our last check
<span class="line-modified">1471             if (overrideableProtocol &amp;&amp; !checkedWithFactory &amp;&amp;</span>
<span class="line-added">1472                 (fac = factory) != null) {</span>
1473                 handler2 = fac.createURLStreamHandler(protocol);
1474             }
1475 
1476             if (handler2 != null) {
1477                 // The handler from the factory must be given more
1478                 // importance. Discard the default handler that
1479                 // this thread created.
1480                 handler = handler2;
1481             }
1482 
1483             // Insert this handler into the hashtable
1484             if (handler != null) {
1485                 handlers.put(protocol, handler);
1486             }
1487         }
1488         return handler;
1489     }
1490 
1491     /**
1492      * @serialField    protocol String
1493      *
1494      * @serialField    host String
1495      *
1496      * @serialField    port int
1497      *
1498      * @serialField    authority String
1499      *
1500      * @serialField    file String
1501      *
1502      * @serialField    ref String
1503      *
1504      * @serialField    hashCode int
1505      *
1506      */
<span class="line-added">1507     @java.io.Serial</span>
1508     private static final ObjectStreamField[] serialPersistentFields = {
1509         new ObjectStreamField(&quot;protocol&quot;, String.class),
1510         new ObjectStreamField(&quot;host&quot;, String.class),
1511         new ObjectStreamField(&quot;port&quot;, int.class),
1512         new ObjectStreamField(&quot;authority&quot;, String.class),
1513         new ObjectStreamField(&quot;file&quot;, String.class),
1514         new ObjectStreamField(&quot;ref&quot;, String.class),
1515         new ObjectStreamField(&quot;hashCode&quot;, int.class), };
1516 
1517     /**
1518      * WriteObject is called to save the state of the URL to an
1519      * ObjectOutputStream. The handler is not saved since it is
1520      * specific to this system.
1521      *
1522      * @serialData the default write object value. When read back in,
1523      * the reader must ensure that calling getURLStreamHandler with
1524      * the protocol variable returns a valid URLStreamHandler and
1525      * throw an IOException if it does not.
1526      */
<span class="line-added">1527     @java.io.Serial</span>
1528     private synchronized void writeObject(java.io.ObjectOutputStream s)
1529         throws IOException
1530     {
1531         s.defaultWriteObject(); // write the fields
1532     }
1533 
1534     /**
1535      * readObject is called to restore the state of the URL from the
1536      * stream.  It reads the components of the URL and finds the local
1537      * stream handler.
1538      */
<span class="line-added">1539     @java.io.Serial</span>
1540     private synchronized void readObject(java.io.ObjectInputStream s)
1541             throws IOException, ClassNotFoundException {
1542         GetField gf = s.readFields();
1543         String protocol = (String)gf.get(&quot;protocol&quot;, null);
1544         if (getURLStreamHandler(protocol) == null) {
1545             throw new IOException(&quot;unknown protocol: &quot; + protocol);
1546         }
1547         String host = (String)gf.get(&quot;host&quot;, null);
1548         int port = gf.get(&quot;port&quot;, -1);
1549         String authority = (String)gf.get(&quot;authority&quot;, null);
1550         String file = (String)gf.get(&quot;file&quot;, null);
1551         String ref = (String)gf.get(&quot;ref&quot;, null);
1552         int hashCode = gf.get(&quot;hashCode&quot;, -1);
1553         if (authority == null
1554                 &amp;&amp; ((host != null &amp;&amp; !host.isEmpty()) || port != -1)) {
1555             if (host == null)
1556                 host = &quot;&quot;;
1557             authority = (port == -1) ? host : host + &quot;:&quot; + port;
1558         }
1559         tempState = new UrlDeserializedState(protocol, host, port, authority,
1560                file, ref, hashCode);
1561     }
1562 
1563     /**
1564      * Replaces the de-serialized object with an URL object.
1565      *
1566      * @return a newly created object from deserialized data
1567      *
1568      * @throws ObjectStreamException if a new object replacing this
1569      * object could not be created
1570      */
<span class="line-modified">1571    @java.io.Serial</span>
1572    private Object readResolve() throws ObjectStreamException {
1573 
1574         URLStreamHandler handler = null;
1575         // already been checked in readObject
1576         handler = getURLStreamHandler(tempState.getProtocol());
1577 
1578         URL replacementURL = null;
1579         if (isBuiltinStreamHandler(handler.getClass().getName())) {
1580             replacementURL = fabricateNewURL();
1581         } else {
1582             replacementURL = setDeserializedFields(handler);
1583         }
1584         return replacementURL;
1585     }
1586 
1587     private URL setDeserializedFields(URLStreamHandler handler) {
1588         URL replacementURL;
1589         String userInfo = null;
1590         String protocol = tempState.getProtocol();
1591         String host = tempState.getHost();
</pre>
<hr />
<pre>
1648     private URL fabricateNewURL()
1649                 throws InvalidObjectException {
1650         // create URL string from deserialized object
1651         URL replacementURL = null;
1652         String urlString = tempState.reconstituteUrlString();
1653 
1654         try {
1655             replacementURL = new URL(urlString);
1656         } catch (MalformedURLException mEx) {
1657             resetState();
1658             InvalidObjectException invoEx = new InvalidObjectException(
1659                     &quot;Malformed URL:  &quot; + urlString);
1660             invoEx.initCause(mEx);
1661             throw invoEx;
1662         }
1663         replacementURL.setSerializedHashCode(tempState.getHashCode());
1664         resetState();
1665         return replacementURL;
1666     }
1667 
<span class="line-added">1668     boolean isBuiltinStreamHandler(URLStreamHandler handler) {</span>
<span class="line-added">1669        Class&lt;?&gt; handlerClass = handler.getClass();</span>
<span class="line-added">1670        return isBuiltinStreamHandler(handlerClass.getName())</span>
<span class="line-added">1671                  || VM.isSystemDomainLoader(handlerClass.getClassLoader());</span>
<span class="line-added">1672     }</span>
<span class="line-added">1673 </span>
1674     private boolean isBuiltinStreamHandler(String handlerClassName) {
1675         return (handlerClassName.startsWith(BUILTIN_HANDLERS_PREFIX));
1676     }
1677 
1678     private void resetState() {
1679         this.protocol = null;
1680         this.host = null;
1681         this.port = -1;
1682         this.file = null;
1683         this.authority = null;
1684         this.ref = null;
1685         this.hashCode = -1;
1686         this.handler = null;
1687         this.query = null;
1688         this.path = null;
1689         this.userInfo = null;
1690         this.tempState = null;
1691     }
1692 
1693     private void setSerializedHashCode(int hc) {
</pre>
</td>
</tr>
</table>
<center><a href="URISyntaxException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/jar/Attributes.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.jar;
 27 
 28 import java.io.DataOutputStream;
 29 import java.io.IOException;
 30 import java.util.Collection;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 import java.util.Objects;
 35 import java.util.Set;
 36 
 37 import sun.util.logging.PlatformLogger;
 38 
 39 import static java.nio.charset.StandardCharsets.UTF_8;
 40 
 41 /**
 42  * The Attributes class maps Manifest attribute names to associated string
 43  * values. Valid attribute names are case-insensitive, are restricted to
 44  * the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70
 45  * characters in length. There must be a colon and a SPACE after the name;
 46  * the combined length will not exceed 72 characters.
 47  * Attribute values can contain any characters and
 48  * will be UTF8-encoded when written to the output stream.  See the
 49  * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
 50  * for more information about valid attribute names and values.
 51  *
 52  * &lt;p&gt;This map and its views have a predictable iteration order, namely the
 53  * order that keys were inserted into the map, as with {@link LinkedHashMap}.
 54  *
 55  * @author  David Connelly
 56  * @see     Manifest
 57  * @since   1.2
 58  */
 59 public class Attributes implements Map&lt;Object,Object&gt;, Cloneable {
 60     /**
 61      * The attribute name-value mappings.
 62      */
 63     protected Map&lt;Object,Object&gt; map;
 64 
 65     /**
 66      * Constructs a new, empty Attributes object with default size.
 67      */
 68     public Attributes() {
 69         this(11);
 70     }
 71 
 72     /**
 73      * Constructs a new, empty Attributes object with the specified
 74      * initial size.
 75      *
 76      * @param size the initial number of attributes
 77      */
 78     public Attributes(int size) {
 79         map = new LinkedHashMap&lt;&gt;(size);
 80     }
 81 
 82     /**
 83      * Constructs a new Attributes object with the same attribute name-value
 84      * mappings as in the specified Attributes.
 85      *
 86      * @param attr the specified Attributes
 87      */
 88     public Attributes(Attributes attr) {
 89         map = new LinkedHashMap&lt;&gt;(attr);
 90     }
 91 
 92 
 93     /**
 94      * Returns the value of the specified attribute name, or null if the
 95      * attribute name was not found.
 96      *
 97      * @param name the attribute name
 98      * @return the value of the specified attribute name, or null if
 99      *         not found.
100      */
101     public Object get(Object name) {
102         return map.get(name);
103     }
104 
105     /**
106      * Returns the value of the specified attribute name, specified as
107      * a string, or null if the attribute was not found. The attribute
108      * name is case-insensitive.
109      * &lt;p&gt;
110      * This method is defined as:
111      * &lt;pre&gt;
112      *      return (String)get(new Attributes.Name((String)name));
113      * &lt;/pre&gt;
114      *
115      * @param name the attribute name as a string
116      * @return the String value of the specified attribute name, or null if
117      *         not found.
118      * @throws IllegalArgumentException if the attribute name is invalid
119      */
120     public String getValue(String name) {
121         return (String)get(Name.of(name));
122     }
123 
124     /**
125      * Returns the value of the specified Attributes.Name, or null if the
126      * attribute was not found.
127      * &lt;p&gt;
128      * This method is defined as:
129      * &lt;pre&gt;
130      *     return (String)get(name);
131      * &lt;/pre&gt;
132      *
133      * @param name the Attributes.Name object
134      * @return the String value of the specified Attribute.Name, or null if
135      *         not found.
136      */
137     public String getValue(Name name) {
138         return (String)get(name);
139     }
140 
141     /**
142      * Associates the specified value with the specified attribute name
143      * (key) in this Map. If the Map previously contained a mapping for
144      * the attribute name, the old value is replaced.
145      *
146      * @param name the attribute name
147      * @param value the attribute value
148      * @return the previous value of the attribute, or null if none
149      * @exception ClassCastException if the name is not a Attributes.Name
150      *            or the value is not a String
151      */
152     public Object put(Object name, Object value) {
153         return map.put((Attributes.Name)name, (String)value);
154     }
155 
156     /**
157      * Associates the specified value with the specified attribute name,
158      * specified as a String. The attributes name is case-insensitive.
159      * If the Map previously contained a mapping for the attribute name,
160      * the old value is replaced.
161      * &lt;p&gt;
162      * This method is defined as:
163      * &lt;pre&gt;
164      *      return (String)put(new Attributes.Name(name), value);
165      * &lt;/pre&gt;
166      *
167      * @param name the attribute name as a string
168      * @param value the attribute value
169      * @return the previous value of the attribute, or null if none
170      * @exception IllegalArgumentException if the attribute name is invalid
171      */
172     public String putValue(String name, String value) {
173         return (String)put(Name.of(name), value);
174     }
175 
176     /**
177      * Removes the attribute with the specified name (key) from this Map.
178      * Returns the previous attribute value, or null if none.
179      *
180      * @param name attribute name
181      * @return the previous value of the attribute, or null if none
182      */
183     public Object remove(Object name) {
184         return map.remove(name);
185     }
186 
187     /**
188      * Returns true if this Map maps one or more attribute names (keys)
189      * to the specified value.
190      *
191      * @param value the attribute value
192      * @return true if this Map maps one or more attribute names to
193      *         the specified value
194      */
195     public boolean containsValue(Object value) {
196         return map.containsValue(value);
197     }
198 
199     /**
200      * Returns true if this Map contains the specified attribute name (key).
201      *
202      * @param name the attribute name
203      * @return true if this Map contains the specified attribute name
204      */
205     public boolean containsKey(Object name) {
206         return map.containsKey(name);
207     }
208 
209     /**
210      * Copies all of the attribute name-value mappings from the specified
211      * Attributes to this Map. Duplicate mappings will be replaced.
212      *
213      * @param attr the Attributes to be stored in this map
214      * @exception ClassCastException if attr is not an Attributes
215      */
216     public void putAll(Map&lt;?,?&gt; attr) {
217         // ## javac bug?
218         if (!Attributes.class.isInstance(attr))
219             throw new ClassCastException();
220         for (Map.Entry&lt;?,?&gt; me : (attr).entrySet())
221             put(me.getKey(), me.getValue());
222     }
223 
224     /**
225      * Removes all attributes from this Map.
226      */
227     public void clear() {
228         map.clear();
229     }
230 
231     /**
232      * Returns the number of attributes in this Map.
233      */
234     public int size() {
235         return map.size();
236     }
237 
238     /**
239      * Returns true if this Map contains no attributes.
240      */
241     public boolean isEmpty() {
242         return map.isEmpty();
243     }
244 
245     /**
246      * Returns a Set view of the attribute names (keys) contained in this Map.
247      */
248     public Set&lt;Object&gt; keySet() {
249         return map.keySet();
250     }
251 
252     /**
253      * Returns a Collection view of the attribute values contained in this Map.
254      */
255     public Collection&lt;Object&gt; values() {
256         return map.values();
257     }
258 
259     /**
260      * Returns a Collection view of the attribute name-value mappings
261      * contained in this Map.
262      */
263     public Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
264         return map.entrySet();
265     }
266 
267     /**
268      * Compares the specified object to the underlying
269      * {@linkplain Attributes#map map} for equality.
270      * Returns true if the given object is also a Map
271      * and the two maps represent the same mappings.
272      *
273      * @param o the Object to be compared
274      * @return true if the specified Object is equal to this Map
275      */
276     public boolean equals(Object o) {
277         return map.equals(o);
278     }
279 
280     /**
281      * Returns the hash code value for this Map.
282      */
283     public int hashCode() {
284         return map.hashCode();
285     }
286 
287     /**
288      * Returns a copy of the Attributes, implemented as follows:
289      * &lt;pre&gt;
290      *     public Object clone() { return new Attributes(this); }
291      * &lt;/pre&gt;
292      * Since the attribute names and values are themselves immutable,
293      * the Attributes returned can be safely modified without affecting
294      * the original.
295      */
296     public Object clone() {
297         return new Attributes(this);
298     }
299 
300     /*
301      * Writes the current attributes to the specified data output stream.
302      * XXX Need to handle UTF8 values and break up lines longer than 72 bytes
303      */
304     void write(DataOutputStream out) throws IOException {
305         StringBuilder buffer = new StringBuilder(72);
306         for (Entry&lt;Object, Object&gt; e : entrySet()) {
307             buffer.setLength(0);
308             buffer.append(e.getKey().toString());
309             buffer.append(&quot;: &quot;);
310             buffer.append(e.getValue());
311             Manifest.println72(out, buffer.toString());
312         }
313         Manifest.println(out); // empty line after individual section
314     }
315 
316     /*
317      * Writes the current attributes to the specified data output stream,
318      * make sure to write out the MANIFEST_VERSION or SIGNATURE_VERSION
319      * attributes first.
320      *
321      * XXX Need to handle UTF8 values and break up lines longer than 72 bytes
322      */
323     void writeMain(DataOutputStream out) throws IOException {
324         StringBuilder buffer = new StringBuilder(72);
325 
326         // write out the *-Version header first, if it exists
327         String vername = Name.MANIFEST_VERSION.toString();
328         String version = getValue(vername);
329         if (version == null) {
330             vername = Name.SIGNATURE_VERSION.toString();
331             version = getValue(vername);
332         }
333 
334         if (version != null) {
335             buffer.append(vername);
336             buffer.append(&quot;: &quot;);
337             buffer.append(version);
338             out.write(buffer.toString().getBytes(UTF_8));
339             Manifest.println(out);
340         }
341 
342         // write out all attributes except for the version
343         // we wrote out earlier
344         for (Entry&lt;Object, Object&gt; e : entrySet()) {
345             String name = ((Name) e.getKey()).toString();
346             if ((version != null) &amp;&amp; !(name.equalsIgnoreCase(vername))) {
347                 buffer.setLength(0);
348                 buffer.append(name);
349                 buffer.append(&quot;: &quot;);
350                 buffer.append(e.getValue());
351                 Manifest.println72(out, buffer.toString());
352             }
353         }
354 
355         Manifest.println(out); // empty line after main attributes section
356     }
357 
358     /*
359      * Reads attributes from the specified input stream.
360      */
361     void read(Manifest.FastInputStream is, byte[] lbuf) throws IOException {
362         read(is, lbuf, null, 0);
363     }
364 
365     int read(Manifest.FastInputStream is, byte[] lbuf, String filename, int lineNumber) throws IOException {
366         String name = null, value;
367         byte[] lastline = null;
368 
369         int len;
370         while ((len = is.readLine(lbuf)) != -1) {
371             boolean lineContinued = false;
372             byte c = lbuf[--len];
373             lineNumber++;
374 
375             if (c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
376                 throw new IOException(&quot;line too long (&quot;
377                             + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
378             }
379             if (len &gt; 0 &amp;&amp; lbuf[len-1] == &#39;\r&#39;) {
380                 --len;
381             }
382             if (len == 0) {
383                 break;
384             }
385             int i = 0;
386             if (lbuf[0] == &#39; &#39;) {
387                 // continuation of previous line
388                 if (name == null) {
389                     throw new IOException(&quot;misplaced continuation line (&quot;
390                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
391                 }
392                 lineContinued = true;
393                 byte[] buf = new byte[lastline.length + len - 1];
394                 System.arraycopy(lastline, 0, buf, 0, lastline.length);
395                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
396                 if (is.peek() == &#39; &#39;) {
397                     lastline = buf;
398                     continue;
399                 }
400                 value = new String(buf, 0, buf.length, UTF_8);
401                 lastline = null;
402             } else {
403                 while (lbuf[i++] != &#39;:&#39;) {
404                     if (i &gt;= len) {
405                         throw new IOException(&quot;invalid header field (&quot;
406                                     + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
407                     }
408                 }
409                 if (lbuf[i++] != &#39; &#39;) {
410                     throw new IOException(&quot;invalid header field (&quot;
411                                 + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
412                 }
413                 name = new String(lbuf, 0, i - 2, UTF_8);
414                 if (is.peek() == &#39; &#39;) {
415                     lastline = new byte[len - i];
416                     System.arraycopy(lbuf, i, lastline, 0, len - i);
417                     continue;
418                 }
419                 value = new String(lbuf, i, len - i, UTF_8);
420             }
421             try {
422                 if ((putValue(name, value) != null) &amp;&amp; (!lineContinued)) {
423                     PlatformLogger.getLogger(&quot;java.util.jar&quot;).warning(
424                                      &quot;Duplicate name in Manifest: &quot; + name
425                                      + &quot;.\n&quot;
426                                      + &quot;Ensure that the manifest does not &quot;
427                                      + &quot;have duplicate entries, and\n&quot;
428                                      + &quot;that blank lines separate &quot;
429                                      + &quot;individual sections in both your\n&quot;
430                                      + &quot;manifest and in the META-INF/MANIFEST.MF &quot;
431                                      + &quot;entry in the jar file.&quot;);
432                 }
433             } catch (IllegalArgumentException e) {
434                 throw new IOException(&quot;invalid header field name: &quot; + name
435                             + &quot; (&quot; + Manifest.getErrorPosition(filename, lineNumber) + &quot;)&quot;);
436             }
437         }
438         return lineNumber;
439     }
440 
441     /**
442      * The Attributes.Name class represents an attribute name stored in
443      * this Map. Valid attribute names are case-insensitive, are restricted
444      * to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed
445      * 70 characters in length. Attribute values can contain any characters
446      * and will be UTF8-encoded when written to the output stream.  See the
447      * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt;
448      * for more information about valid attribute names and values.
449      */
450     public static class Name {
451         private final String name;
452         private final int hashCode;
453 
454         /**
455          * Avoid allocation for common Names
456          */
457         private static final Map&lt;String, Name&gt; KNOWN_NAMES;
458 
459         static final Name of(String name) {
460             Name n = KNOWN_NAMES.get(name);
461             if (n != null) {
462                 return n;
463             }
464             return new Name(name);
465         }
466 
467         /**
468          * Constructs a new attribute name using the given string name.
469          *
470          * @param name the attribute string name
471          * @exception IllegalArgumentException if the attribute name was
472          *            invalid
473          * @exception NullPointerException if the attribute name was null
474          */
475         public Name(String name) {
476             this.hashCode = hash(name);
477             this.name = name.intern();
478         }
479 
480         // Checks the string is valid
481         private final int hash(String name) {
482             Objects.requireNonNull(name, &quot;name&quot;);
483             int len = name.length();
484             if (len &gt; 70 || len == 0) {
485                 throw new IllegalArgumentException(name);
486             }
487             // Calculate hash code case insensitively
488             int h = 0;
489             for (int i = 0; i &lt; len; i++) {
490                 char c = name.charAt(i);
491                 if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
492                     // hashcode must be identical for upper and lower case
493                     h = h * 31 + (c - 0x20);
494                 } else if ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39; ||
495                         c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; ||
496                         c == &#39;_&#39; || c == &#39;-&#39;)) {
497                     h = h * 31 + c;
498                 } else {
499                     throw new IllegalArgumentException(name);
500                 }
501             }
502             return h;
503         }
504 
505         /**
506          * Compares this attribute name to another for equality.
507          * @param o the object to compare
508          * @return true if this attribute name is equal to the
509          *         specified attribute object
510          */
511         public boolean equals(Object o) {
512             if (this == o) {
513                 return true;
514             }
515             if (o instanceof Name) {
516                 Name other = (Name)o;
517                 return other.name.equalsIgnoreCase(name);
518             } else {
519                 return false;
520             }
521         }
522 
523         /**
524          * Computes the hash value for this attribute name.
525          */
526         public int hashCode() {
527             return hashCode;
528         }
529 
530         /**
531          * Returns the attribute name as a String.
532          */
533         public String toString() {
534             return name;
535         }
536 
537         /**
538          * {@code Name} object for {@code Manifest-Version}
539          * manifest attribute. This attribute indicates the version number
540          * of the manifest standard to which a JAR file&#39;s manifest conforms.
541          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
542          *      Manifest and Signature Specification&lt;/a&gt;
543          */
544         public static final Name MANIFEST_VERSION = new Name(&quot;Manifest-Version&quot;);
545 
546         /**
547          * {@code Name} object for {@code Signature-Version}
548          * manifest attribute used when signing JAR files.
549          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#jar-manifest&quot;&gt;
550          *      Manifest and Signature Specification&lt;/a&gt;
551          */
552         public static final Name SIGNATURE_VERSION = new Name(&quot;Signature-Version&quot;);
553 
554         /**
555          * {@code Name} object for {@code Content-Type}
556          * manifest attribute.
557          */
558         public static final Name CONTENT_TYPE = new Name(&quot;Content-Type&quot;);
559 
560         /**
561          * {@code Name} object for {@code Class-Path}
562          * manifest attribute.
563          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#class-path-attribute&quot;&gt;
564          *      JAR file specification&lt;/a&gt;
565          */
566         public static final Name CLASS_PATH = new Name(&quot;Class-Path&quot;);
567 
568         /**
569          * {@code Name} object for {@code Main-Class} manifest
570          * attribute used for launching applications packaged in JAR files.
571          * The {@code Main-Class} attribute is used in conjunction
572          * with the {@code -jar} command-line option of the
573          * {@code java} application launcher.
574          */
575         public static final Name MAIN_CLASS = new Name(&quot;Main-Class&quot;);
576 
577         /**
578          * {@code Name} object for {@code Sealed} manifest attribute
579          * used for sealing.
580          * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#package-sealing&quot;&gt;
581          *      Package Sealing&lt;/a&gt;
582          */
583         public static final Name SEALED = new Name(&quot;Sealed&quot;);
584 
585         /**
586          * {@code Name} object for {@code Extension-List} manifest attribute
587          * used for the extension mechanism that is no longer supported.
588          */
589         public static final Name EXTENSION_LIST = new Name(&quot;Extension-List&quot;);
590 
591         /**
592          * {@code Name} object for {@code Extension-Name} manifest attribute.
593          * used for the extension mechanism that is no longer supported.
594          */
595         public static final Name EXTENSION_NAME = new Name(&quot;Extension-Name&quot;);
596 
597         /**
598          * {@code Name} object for {@code Extension-Installation} manifest attribute.
599          *
600          * @deprecated Extension mechanism is no longer supported.
601          */
602         @Deprecated
603         public static final Name EXTENSION_INSTALLATION = new Name(&quot;Extension-Installation&quot;);
604 
605         /**
606          * {@code Name} object for {@code Implementation-Title}
607          * manifest attribute used for package versioning.
608          */
609         public static final Name IMPLEMENTATION_TITLE = new Name(&quot;Implementation-Title&quot;);
610 
611         /**
612          * {@code Name} object for {@code Implementation-Version}
613          * manifest attribute used for package versioning.
614          */
615         public static final Name IMPLEMENTATION_VERSION = new Name(&quot;Implementation-Version&quot;);
616 
617         /**
618          * {@code Name} object for {@code Implementation-Vendor}
619          * manifest attribute used for package versioning.
620          */
621         public static final Name IMPLEMENTATION_VENDOR = new Name(&quot;Implementation-Vendor&quot;);
622 
623         /**
624          * {@code Name} object for {@code Implementation-Vendor-Id}
625          * manifest attribute.
626          *
627          * @deprecated Extension mechanism is no longer supported.
628          */
629         @Deprecated
630         public static final Name IMPLEMENTATION_VENDOR_ID = new Name(&quot;Implementation-Vendor-Id&quot;);
631 
632         /**
633          * {@code Name} object for {@code Implementation-URL}
634          * manifest attribute.
635          *
636          * @deprecated Extension mechanism is no longer supported.
637          */
638         @Deprecated
639         public static final Name IMPLEMENTATION_URL = new Name(&quot;Implementation-URL&quot;);
640 
641         /**
642          * {@code Name} object for {@code Specification-Title}
643          * manifest attribute used for package versioning.
644          */
645         public static final Name SPECIFICATION_TITLE = new Name(&quot;Specification-Title&quot;);
646 
647         /**
648          * {@code Name} object for {@code Specification-Version}
649          * manifest attribute used for package versioning.
650          */
651         public static final Name SPECIFICATION_VERSION = new Name(&quot;Specification-Version&quot;);
652 
653         /**
654          * {@code Name} object for {@code Specification-Vendor}
655          * manifest attribute used for package versioning.
656          */
657         public static final Name SPECIFICATION_VENDOR = new Name(&quot;Specification-Vendor&quot;);
658 
659         /**
660          * {@code Name} object for {@code Multi-Release}
661          * manifest attribute that indicates this is a multi-release JAR file.
662          *
663          * @since   9
664          */
665         public static final Name MULTI_RELEASE = new Name(&quot;Multi-Release&quot;);
666 
667         private static void addName(Map&lt;String, Name&gt; names, Name name) {
668             names.put(name.name, name);
669         }
670 
671         static {
672             var names = new HashMap&lt;String, Name&gt;(64);
673             addName(names, MANIFEST_VERSION);
674             addName(names, SIGNATURE_VERSION);
675             addName(names, CONTENT_TYPE);
676             addName(names, CLASS_PATH);
677             addName(names, MAIN_CLASS);
678             addName(names, SEALED);
679             addName(names, EXTENSION_LIST);
680             addName(names, EXTENSION_NAME);
681             addName(names, IMPLEMENTATION_TITLE);
682             addName(names, IMPLEMENTATION_VERSION);
683             addName(names, IMPLEMENTATION_VENDOR);
684             addName(names, SPECIFICATION_TITLE);
685             addName(names, SPECIFICATION_VERSION);
686             addName(names, SPECIFICATION_VENDOR);
687             addName(names, MULTI_RELEASE);
688 
689             // Common attributes used in MANIFEST.MF et.al; adding these has a
690             // small footprint cost, but is likely to be quickly paid for by
691             // reducing allocation when reading and parsing typical manifests
692             addName(names, new Name(&quot;Add-Exports&quot;));
693             addName(names, new Name(&quot;Add-Opens&quot;));
694             addName(names, new Name(&quot;Ant-Version&quot;));
695             addName(names, new Name(&quot;Archiver-Version&quot;));
696             addName(names, new Name(&quot;Build-Jdk&quot;));
697             addName(names, new Name(&quot;Built-By&quot;));
698             addName(names, new Name(&quot;Bnd-LastModified&quot;));
699             addName(names, new Name(&quot;Bundle-Description&quot;));
700             addName(names, new Name(&quot;Bundle-DocURL&quot;));
701             addName(names, new Name(&quot;Bundle-License&quot;));
702             addName(names, new Name(&quot;Bundle-ManifestVersion&quot;));
703             addName(names, new Name(&quot;Bundle-Name&quot;));
704             addName(names, new Name(&quot;Bundle-Vendor&quot;));
705             addName(names, new Name(&quot;Bundle-Version&quot;));
706             addName(names, new Name(&quot;Bundle-SymbolicName&quot;));
707             addName(names, new Name(&quot;Created-By&quot;));
708             addName(names, new Name(&quot;Export-Package&quot;));
709             addName(names, new Name(&quot;Import-Package&quot;));
710             addName(names, new Name(&quot;Name&quot;));
711             addName(names, new Name(&quot;SHA1-Digest&quot;));
712             addName(names, new Name(&quot;X-Compile-Source-JDK&quot;));
713             addName(names, new Name(&quot;X-Compile-Target-JDK&quot;));
714             KNOWN_NAMES = names;
715         }
716     }
717 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/DecimalFormatSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
<a name="2" id="anc2"></a><span class="line-added">  41 import java.io.InvalidObjectException;</span>
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.io.Serializable;
  45 import java.text.spi.DecimalFormatSymbolsProvider;
  46 import java.util.Currency;
  47 import java.util.Locale;
<a name="3" id="anc3"></a><span class="line-added">  48 import java.util.Objects;</span>
  49 import sun.util.locale.provider.CalendarDataUtility;
  50 import sun.util.locale.provider.LocaleProviderAdapter;
  51 import sun.util.locale.provider.LocaleServiceProviderPool;
  52 import sun.util.locale.provider.ResourceBundleBasedAdapter;
  53 
  54 /**
  55  * This class represents the set of symbols (such as the decimal separator,
<a name="4" id="anc4"></a><span class="line-modified">  56  * the grouping separator, and so on) needed by {@code DecimalFormat}</span>
<span class="line-modified">  57  * to format numbers. {@code DecimalFormat} creates for itself an instance of</span>
<span class="line-modified">  58  * {@code DecimalFormatSymbols} from its locale data.  If you need to change any</span>
<span class="line-modified">  59  * of these symbols, you can get the {@code DecimalFormatSymbols} object from</span>
<span class="line-modified">  60  * your {@code DecimalFormat} and modify it.</span>
  61  *
  62  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
  63  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
  64  * the symbols are overridden for the designated region.
  65  *
  66  * @see          java.util.Locale
  67  * @see          DecimalFormat
  68  * @author       Mark Davis
  69  * @author       Alan Liu
  70  * @since 1.1
  71  */
  72 
  73 public class DecimalFormatSymbols implements Cloneable, Serializable {
  74 
  75     /**
  76      * Create a DecimalFormatSymbols object for the default
  77      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
  78      * This constructor can only construct instances for the locales
  79      * supported by the Java runtime environment, not for those
  80      * supported by installed
  81      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
  82      * implementations. For full locale coverage, use the
  83      * {@link #getInstance(Locale) getInstance} method.
  84      * &lt;p&gt;This is equivalent to calling
  85      * {@link #DecimalFormatSymbols(Locale)
  86      *     DecimalFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
  87      * @see java.util.Locale#getDefault(java.util.Locale.Category)
  88      * @see java.util.Locale.Category#FORMAT
  89      */
  90     public DecimalFormatSymbols() {
  91         initialize( Locale.getDefault(Locale.Category.FORMAT) );
  92     }
  93 
  94     /**
  95      * Create a DecimalFormatSymbols object for the given locale.
  96      * This constructor can only construct instances for the locales
  97      * supported by the Java runtime environment, not for those
  98      * supported by installed
  99      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
 100      * implementations. For full locale coverage, use the
 101      * {@link #getInstance(Locale) getInstance} method.
 102      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 103      * for the numbering system, the instance is initialized with the specified numbering
 104      * system if the JRE implementation supports it. For example,
 105      * &lt;pre&gt;
 106      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 107      * &lt;/pre&gt;
 108      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 109      * instead of the Latin numbering system.
 110      *
 111      * @param locale the desired locale
<a name="5" id="anc5"></a><span class="line-modified"> 112      * @throws    NullPointerException if {@code locale} is null</span>
 113      */
 114     public DecimalFormatSymbols( Locale locale ) {
 115         initialize( locale );
 116     }
 117 
 118     /**
 119      * Returns an array of all locales for which the
<a name="6" id="anc6"></a><span class="line-modified"> 120      * {@code getInstance} methods of this class can return</span>
 121      * localized instances.
 122      * The returned array represents the union of locales supported by the Java
 123      * runtime and by installed
 124      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
<a name="7" id="anc7"></a><span class="line-modified"> 125      * implementations.  It must contain at least a {@code Locale}</span>
 126      * instance equal to {@link java.util.Locale#US Locale.US}.
 127      *
 128      * @return an array of locales for which localized
<a name="8" id="anc8"></a><span class="line-modified"> 129      *         {@code DecimalFormatSymbols} instances are available.</span>
 130      * @since 1.6
 131      */
 132     public static Locale[] getAvailableLocales() {
 133         LocaleServiceProviderPool pool =
 134             LocaleServiceProviderPool.getPool(DecimalFormatSymbolsProvider.class);
 135         return pool.getAvailableLocales();
 136     }
 137 
 138     /**
<a name="9" id="anc9"></a><span class="line-modified"> 139      * Gets the {@code DecimalFormatSymbols} instance for the default</span>
<span class="line-modified"> 140      * locale.  This method provides access to {@code DecimalFormatSymbols}</span>
 141      * instances for locales supported by the Java runtime itself as well
 142      * as for those supported by installed
 143      * {@link java.text.spi.DecimalFormatSymbolsProvider
 144      * DecimalFormatSymbolsProvider} implementations.
 145      * &lt;p&gt;This is equivalent to calling
 146      * {@link #getInstance(Locale)
 147      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 148      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 149      * @see java.util.Locale.Category#FORMAT
<a name="10" id="anc10"></a><span class="line-modified"> 150      * @return a {@code DecimalFormatSymbols} instance.</span>
 151      * @since 1.6
 152      */
 153     public static final DecimalFormatSymbols getInstance() {
 154         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
 155     }
 156 
 157     /**
<a name="11" id="anc11"></a><span class="line-modified"> 158      * Gets the {@code DecimalFormatSymbols} instance for the specified</span>
<span class="line-modified"> 159      * locale.  This method provides access to {@code DecimalFormatSymbols}</span>
 160      * instances for locales supported by the Java runtime itself as well
 161      * as for those supported by installed
 162      * {@link java.text.spi.DecimalFormatSymbolsProvider
 163      * DecimalFormatSymbolsProvider} implementations.
 164      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 165      * for the numbering system, the instance is initialized with the specified numbering
 166      * system if the JRE implementation supports it. For example,
 167      * &lt;pre&gt;
 168      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 169      * &lt;/pre&gt;
 170      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 171      * instead of the Latin numbering system.
 172      *
 173      * @param locale the desired locale.
<a name="12" id="anc12"></a><span class="line-modified"> 174      * @return a {@code DecimalFormatSymbols} instance.</span>
<span class="line-modified"> 175      * @throws    NullPointerException if {@code locale} is null</span>
 176      * @since 1.6
 177      */
 178     public static final DecimalFormatSymbols getInstance(Locale locale) {
 179         LocaleProviderAdapter adapter;
 180         adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);
 181         DecimalFormatSymbolsProvider provider = adapter.getDecimalFormatSymbolsProvider();
 182         DecimalFormatSymbols dfsyms = provider.getInstance(locale);
 183         if (dfsyms == null) {
 184             provider = LocaleProviderAdapter.forJRE().getDecimalFormatSymbolsProvider();
 185             dfsyms = provider.getInstance(locale);
 186         }
 187         return dfsyms;
 188     }
 189 
 190     /**
 191      * Gets the character used for zero. Different for Arabic, etc.
 192      *
 193      * @return the character used for zero
 194      */
 195     public char getZeroDigit() {
 196         return zeroDigit;
 197     }
 198 
 199     /**
 200      * Sets the character used for zero. Different for Arabic, etc.
 201      *
 202      * @param zeroDigit the character used for zero
 203      */
 204     public void setZeroDigit(char zeroDigit) {
<a name="13" id="anc13"></a><span class="line-added"> 205         hashCode = 0;</span>
 206         this.zeroDigit = zeroDigit;
 207     }
 208 
 209     /**
<a name="14" id="anc14"></a><span class="line-modified"> 210      * Gets the character used for grouping separator. Different for French, etc.</span>
 211      *
 212      * @return the grouping separator
 213      */
 214     public char getGroupingSeparator() {
 215         return groupingSeparator;
 216     }
 217 
 218     /**
<a name="15" id="anc15"></a><span class="line-modified"> 219      * Sets the character used for grouping separator. Different for French, etc.</span>
 220      *
 221      * @param groupingSeparator the grouping separator
 222      */
 223     public void setGroupingSeparator(char groupingSeparator) {
<a name="16" id="anc16"></a><span class="line-added"> 224         hashCode = 0;</span>
 225         this.groupingSeparator = groupingSeparator;
 226     }
 227 
 228     /**
 229      * Gets the character used for decimal sign. Different for French, etc.
 230      *
 231      * @return the character used for decimal sign
 232      */
 233     public char getDecimalSeparator() {
 234         return decimalSeparator;
 235     }
 236 
 237     /**
 238      * Sets the character used for decimal sign. Different for French, etc.
 239      *
 240      * @param decimalSeparator the character used for decimal sign
 241      */
 242     public void setDecimalSeparator(char decimalSeparator) {
<a name="17" id="anc17"></a><span class="line-added"> 243         hashCode = 0;</span>
 244         this.decimalSeparator = decimalSeparator;
 245     }
 246 
 247     /**
 248      * Gets the character used for per mille sign. Different for Arabic, etc.
 249      *
 250      * @return the character used for per mille sign
 251      */
 252     public char getPerMill() {
 253         return perMill;
 254     }
 255 
 256     /**
 257      * Sets the character used for per mille sign. Different for Arabic, etc.
 258      *
 259      * @param perMill the character used for per mille sign
 260      */
 261     public void setPerMill(char perMill) {
<a name="18" id="anc18"></a><span class="line-added"> 262         hashCode = 0;</span>
 263         this.perMill = perMill;
<a name="19" id="anc19"></a><span class="line-added"> 264         this.perMillText = Character.toString(perMill);</span>
 265     }
 266 
 267     /**
 268      * Gets the character used for percent sign. Different for Arabic, etc.
 269      *
 270      * @return the character used for percent sign
 271      */
 272     public char getPercent() {
 273         return percent;
 274     }
 275 
 276     /**
 277      * Sets the character used for percent sign. Different for Arabic, etc.
 278      *
 279      * @param percent the character used for percent sign
 280      */
 281     public void setPercent(char percent) {
<a name="20" id="anc20"></a><span class="line-added"> 282         hashCode = 0;</span>
 283         this.percent = percent;
<a name="21" id="anc21"></a><span class="line-added"> 284         this.percentText = Character.toString(percent);</span>
 285     }
 286 
 287     /**
 288      * Gets the character used for a digit in a pattern.
 289      *
 290      * @return the character used for a digit in a pattern
 291      */
 292     public char getDigit() {
 293         return digit;
 294     }
 295 
 296     /**
 297      * Sets the character used for a digit in a pattern.
 298      *
 299      * @param digit the character used for a digit in a pattern
 300      */
 301     public void setDigit(char digit) {
<a name="22" id="anc22"></a><span class="line-added"> 302         hashCode = 0;</span>
 303         this.digit = digit;
 304     }
 305 
 306     /**
 307      * Gets the character used to separate positive and negative subpatterns
 308      * in a pattern.
 309      *
 310      * @return the pattern separator
 311      */
 312     public char getPatternSeparator() {
 313         return patternSeparator;
 314     }
 315 
 316     /**
 317      * Sets the character used to separate positive and negative subpatterns
 318      * in a pattern.
 319      *
 320      * @param patternSeparator the pattern separator
 321      */
 322     public void setPatternSeparator(char patternSeparator) {
<a name="23" id="anc23"></a><span class="line-added"> 323         hashCode = 0;</span>
 324         this.patternSeparator = patternSeparator;
 325     }
 326 
 327     /**
 328      * Gets the string used to represent infinity. Almost always left
 329      * unchanged.
 330      *
 331      * @return the string representing infinity
 332      */
 333     public String getInfinity() {
 334         return infinity;
 335     }
 336 
 337     /**
 338      * Sets the string used to represent infinity. Almost always left
 339      * unchanged.
 340      *
 341      * @param infinity the string representing infinity
 342      */
 343     public void setInfinity(String infinity) {
<a name="24" id="anc24"></a><span class="line-added"> 344         hashCode = 0;</span>
 345         this.infinity = infinity;
 346     }
 347 
 348     /**
 349      * Gets the string used to represent &quot;not a number&quot;. Almost always left
 350      * unchanged.
 351      *
 352      * @return the string representing &quot;not a number&quot;
 353      */
 354     public String getNaN() {
 355         return NaN;
 356     }
 357 
 358     /**
 359      * Sets the string used to represent &quot;not a number&quot;. Almost always left
 360      * unchanged.
 361      *
 362      * @param NaN the string representing &quot;not a number&quot;
 363      */
 364     public void setNaN(String NaN) {
<a name="25" id="anc25"></a><span class="line-added"> 365         hashCode = 0;</span>
 366         this.NaN = NaN;
 367     }
 368 
 369     /**
 370      * Gets the character used to represent minus sign. If no explicit
 371      * negative format is specified, one is formed by prefixing
 372      * minusSign to the positive format.
 373      *
 374      * @return the character representing minus sign
 375      */
 376     public char getMinusSign() {
 377         return minusSign;
 378     }
 379 
 380     /**
 381      * Sets the character used to represent minus sign. If no explicit
 382      * negative format is specified, one is formed by prefixing
 383      * minusSign to the positive format.
 384      *
 385      * @param minusSign the character representing minus sign
 386      */
 387     public void setMinusSign(char minusSign) {
<a name="26" id="anc26"></a><span class="line-added"> 388         hashCode = 0;</span>
 389         this.minusSign = minusSign;
<a name="27" id="anc27"></a><span class="line-added"> 390         this.minusSignText = Character.toString(minusSign);</span>
 391     }
 392 
 393     /**
 394      * Returns the currency symbol for the currency of these
 395      * DecimalFormatSymbols in their locale.
 396      *
 397      * @return the currency symbol
 398      * @since 1.2
 399      */
 400     public String getCurrencySymbol()
 401     {
 402         initializeCurrency(locale);
 403         return currencySymbol;
 404     }
 405 
 406     /**
 407      * Sets the currency symbol for the currency of these
 408      * DecimalFormatSymbols in their locale.
 409      *
 410      * @param currency the currency symbol
 411      * @since 1.2
 412      */
 413     public void setCurrencySymbol(String currency)
 414     {
 415         initializeCurrency(locale);
<a name="28" id="anc28"></a><span class="line-added"> 416         hashCode = 0;</span>
 417         currencySymbol = currency;
 418     }
 419 
 420     /**
 421      * Returns the ISO 4217 currency code of the currency of these
 422      * DecimalFormatSymbols.
 423      *
 424      * @return the currency code
 425      * @since 1.2
 426      */
 427     public String getInternationalCurrencySymbol()
 428     {
 429         initializeCurrency(locale);
 430         return intlCurrencySymbol;
 431     }
 432 
 433     /**
 434      * Sets the ISO 4217 currency code of the currency of these
 435      * DecimalFormatSymbols.
 436      * If the currency code is valid (as defined by
 437      * {@link java.util.Currency#getInstance(java.lang.String) Currency.getInstance}),
 438      * this also sets the currency attribute to the corresponding Currency
 439      * instance and the currency symbol attribute to the currency&#39;s symbol
 440      * in the DecimalFormatSymbols&#39; locale. If the currency code is not valid,
 441      * then the currency attribute is set to null and the currency symbol
 442      * attribute is not modified.
 443      *
 444      * @param currencyCode the currency code
 445      * @see #setCurrency
 446      * @see #setCurrencySymbol
 447      * @since 1.2
 448      */
 449     public void setInternationalCurrencySymbol(String currencyCode)
 450     {
 451         initializeCurrency(locale);
<a name="29" id="anc29"></a><span class="line-added"> 452         hashCode = 0;</span>
 453         intlCurrencySymbol = currencyCode;
 454         currency = null;
 455         if (currencyCode != null) {
 456             try {
 457                 currency = Currency.getInstance(currencyCode);
 458                 currencySymbol = currency.getSymbol();
 459             } catch (IllegalArgumentException e) {
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * Gets the currency of these DecimalFormatSymbols. May be null if the
 466      * currency symbol attribute was previously set to a value that&#39;s not
 467      * a valid ISO 4217 currency code.
 468      *
 469      * @return the currency used, or null
 470      * @since 1.4
 471      */
 472     public Currency getCurrency() {
 473         initializeCurrency(locale);
 474         return currency;
 475     }
 476 
 477     /**
 478      * Sets the currency of these DecimalFormatSymbols.
 479      * This also sets the currency symbol attribute to the currency&#39;s symbol
 480      * in the DecimalFormatSymbols&#39; locale, and the international currency
 481      * symbol attribute to the currency&#39;s ISO 4217 currency code.
 482      *
 483      * @param currency the new currency to be used
<a name="30" id="anc30"></a><span class="line-modified"> 484      * @throws    NullPointerException if {@code currency} is null</span>
 485      * @since 1.4
 486      * @see #setCurrencySymbol
 487      * @see #setInternationalCurrencySymbol
 488      */
 489     public void setCurrency(Currency currency) {
 490         if (currency == null) {
 491             throw new NullPointerException();
 492         }
 493         initializeCurrency(locale);
<a name="31" id="anc31"></a><span class="line-added"> 494         hashCode = 0;</span>
 495         this.currency = currency;
 496         intlCurrencySymbol = currency.getCurrencyCode();
 497         currencySymbol = currency.getSymbol(locale);
 498     }
 499 
 500 
 501     /**
 502      * Returns the monetary decimal separator.
 503      *
 504      * @return the monetary decimal separator
 505      * @since 1.2
 506      */
 507     public char getMonetaryDecimalSeparator()
 508     {
 509         return monetarySeparator;
 510     }
 511 
 512     /**
 513      * Sets the monetary decimal separator.
 514      *
 515      * @param sep the monetary decimal separator
 516      * @since 1.2
 517      */
 518     public void setMonetaryDecimalSeparator(char sep)
 519     {
<a name="32" id="anc32"></a><span class="line-added"> 520         hashCode = 0;</span>
 521         monetarySeparator = sep;
 522     }
 523 
<a name="33" id="anc33"></a>











 524     /**
 525      * Returns the string used to separate the mantissa from the exponent.
 526      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 527      *
 528      * @return the exponent separator string
 529      * @see #setExponentSeparator(java.lang.String)
 530      * @since 1.6
 531      */
 532     public String getExponentSeparator()
 533     {
 534         return exponentialSeparator;
 535     }
 536 
<a name="34" id="anc34"></a>







 537     /**
 538      * Sets the string used to separate the mantissa from the exponent.
 539      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 540      *
 541      * @param exp the exponent separator string
<a name="35" id="anc35"></a><span class="line-modified"> 542      * @throws    NullPointerException if {@code exp} is null</span>
 543      * @see #getExponentSeparator()
 544      * @since 1.6
 545      */
 546     public void setExponentSeparator(String exp)
 547     {
 548         if (exp == null) {
 549             throw new NullPointerException();
 550         }
<a name="36" id="anc36"></a><span class="line-added"> 551         hashCode = 0;</span>
 552         exponentialSeparator = exp;
 553     }
 554 
<a name="37" id="anc37"></a><span class="line-added"> 555     /**</span>
<span class="line-added"> 556      * Gets the character used for grouping separator for currencies.</span>
<span class="line-added"> 557      * May be different from {@code grouping separator} in some locales,</span>
<span class="line-added"> 558      * e.g, German in Austria.</span>
<span class="line-added"> 559      *</span>
<span class="line-added"> 560      * @return the monetary grouping separator</span>
<span class="line-added"> 561      * @since 15</span>
<span class="line-added"> 562      */</span>
<span class="line-added"> 563     public char getMonetaryGroupingSeparator() {</span>
<span class="line-added"> 564         return monetaryGroupingSeparator;</span>
<span class="line-added"> 565     }</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567     /**</span>
<span class="line-added"> 568      * Sets the character used for grouping separator for currencies.</span>
<span class="line-added"> 569      * Invocation of this method will not affect the normal</span>
<span class="line-added"> 570      * {@code grouping separator}.</span>
<span class="line-added"> 571      *</span>
<span class="line-added"> 572      * @param monetaryGroupingSeparator the monetary grouping separator</span>
<span class="line-added"> 573      * @see #setGroupingSeparator(char)</span>
<span class="line-added"> 574      * @since 15</span>
<span class="line-added"> 575      */</span>
<span class="line-added"> 576     public void setMonetaryGroupingSeparator(char monetaryGroupingSeparator)</span>
<span class="line-added"> 577     {</span>
<span class="line-added"> 578         hashCode = 0;</span>
<span class="line-added"> 579         this.monetaryGroupingSeparator = monetaryGroupingSeparator;</span>
<span class="line-added"> 580     }</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582     //------------------------------------------------------------</span>
<span class="line-added"> 583     // BEGIN   Package Private methods ... to be made public later</span>
<span class="line-added"> 584     //------------------------------------------------------------</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Returns the character used to separate the mantissa from the exponent.</span>
<span class="line-added"> 588      */</span>
<span class="line-added"> 589     char getExponentialSymbol()</span>
<span class="line-added"> 590     {</span>
<span class="line-added"> 591         return exponential;</span>
<span class="line-added"> 592     }</span>
<span class="line-added"> 593 </span>
<span class="line-added"> 594     /**</span>
<span class="line-added"> 595      * Sets the character used to separate the mantissa from the exponent.</span>
<span class="line-added"> 596      */</span>
<span class="line-added"> 597     void setExponentialSymbol(char exp)</span>
<span class="line-added"> 598     {</span>
<span class="line-added"> 599         exponential = exp;</span>
<span class="line-added"> 600     }</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602     /**</span>
<span class="line-added"> 603      * Gets the string used for per mille sign. Different for Arabic, etc.</span>
<span class="line-added"> 604      *</span>
<span class="line-added"> 605      * @return the string used for per mille sign</span>
<span class="line-added"> 606      * @since 13</span>
<span class="line-added"> 607      */</span>
<span class="line-added"> 608     String getPerMillText() {</span>
<span class="line-added"> 609         return perMillText;</span>
<span class="line-added"> 610     }</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612     /**</span>
<span class="line-added"> 613      * Sets the string used for per mille sign. Different for Arabic, etc.</span>
<span class="line-added"> 614      *</span>
<span class="line-added"> 615      * Setting the {@code perMillText} affects the return value of</span>
<span class="line-added"> 616      * {@link #getPerMill()}, in which the first non-format character of</span>
<span class="line-added"> 617      * {@code perMillText} is returned.</span>
<span class="line-added"> 618      *</span>
<span class="line-added"> 619      * @param perMillText the string used for per mille sign</span>
<span class="line-added"> 620      * @throws NullPointerException if {@code perMillText} is null</span>
<span class="line-added"> 621      * @throws IllegalArgumentException if {@code perMillText} is an empty string</span>
<span class="line-added"> 622      * @see #getPerMill()</span>
<span class="line-added"> 623      * @see #getPerMillText()</span>
<span class="line-added"> 624      * @since 13</span>
<span class="line-added"> 625      */</span>
<span class="line-added"> 626     void setPerMillText(String perMillText) {</span>
<span class="line-added"> 627         Objects.requireNonNull(perMillText);</span>
<span class="line-added"> 628         if (perMillText.isEmpty()) {</span>
<span class="line-added"> 629             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         hashCode = 0;</span>
<span class="line-added"> 633         this.perMillText = perMillText;</span>
<span class="line-added"> 634         this.perMill = findNonFormatChar(perMillText, &#39;\u2030&#39;);</span>
<span class="line-added"> 635     }</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637     /**</span>
<span class="line-added"> 638      * Gets the string used for percent sign. Different for Arabic, etc.</span>
<span class="line-added"> 639      *</span>
<span class="line-added"> 640      * @return the string used for percent sign</span>
<span class="line-added"> 641      * @since 13</span>
<span class="line-added"> 642      */</span>
<span class="line-added"> 643     String getPercentText() {</span>
<span class="line-added"> 644         return percentText;</span>
<span class="line-added"> 645     }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647     /**</span>
<span class="line-added"> 648      * Sets the string used for percent sign. Different for Arabic, etc.</span>
<span class="line-added"> 649      *</span>
<span class="line-added"> 650      * Setting the {@code percentText} affects the return value of</span>
<span class="line-added"> 651      * {@link #getPercent()}, in which the first non-format character of</span>
<span class="line-added"> 652      * {@code percentText} is returned.</span>
<span class="line-added"> 653      *</span>
<span class="line-added"> 654      * @param percentText the string used for percent sign</span>
<span class="line-added"> 655      * @throws NullPointerException if {@code percentText} is null</span>
<span class="line-added"> 656      * @throws IllegalArgumentException if {@code percentText} is an empty string</span>
<span class="line-added"> 657      * @see #getPercent()</span>
<span class="line-added"> 658      * @see #getPercentText()</span>
<span class="line-added"> 659      * @since 13</span>
<span class="line-added"> 660      */</span>
<span class="line-added"> 661     void setPercentText(String percentText) {</span>
<span class="line-added"> 662         Objects.requireNonNull(percentText);</span>
<span class="line-added"> 663         if (percentText.isEmpty()) {</span>
<span class="line-added"> 664             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 665         }</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         hashCode = 0;</span>
<span class="line-added"> 668         this.percentText = percentText;</span>
<span class="line-added"> 669         this.percent = findNonFormatChar(percentText, &#39;%&#39;);</span>
<span class="line-added"> 670     }</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     /**</span>
<span class="line-added"> 673      * Gets the string used to represent minus sign. If no explicit</span>
<span class="line-added"> 674      * negative format is specified, one is formed by prefixing</span>
<span class="line-added"> 675      * minusSignText to the positive format.</span>
<span class="line-added"> 676      *</span>
<span class="line-added"> 677      * @return the string representing minus sign</span>
<span class="line-added"> 678      * @since 13</span>
<span class="line-added"> 679      */</span>
<span class="line-added"> 680     String getMinusSignText() {</span>
<span class="line-added"> 681         return minusSignText;</span>
<span class="line-added"> 682     }</span>
<span class="line-added"> 683 </span>
<span class="line-added"> 684     /**</span>
<span class="line-added"> 685      * Sets the string used to represent minus sign. If no explicit</span>
<span class="line-added"> 686      * negative format is specified, one is formed by prefixing</span>
<span class="line-added"> 687      * minusSignText to the positive format.</span>
<span class="line-added"> 688      *</span>
<span class="line-added"> 689      * Setting the {@code minusSignText} affects the return value of</span>
<span class="line-added"> 690      * {@link #getMinusSign()}, in which the first non-format character of</span>
<span class="line-added"> 691      * {@code minusSignText} is returned.</span>
<span class="line-added"> 692      *</span>
<span class="line-added"> 693      * @param minusSignText the character representing minus sign</span>
<span class="line-added"> 694      * @throws NullPointerException if {@code minusSignText} is null</span>
<span class="line-added"> 695      * @throws IllegalArgumentException if {@code minusSignText} is an</span>
<span class="line-added"> 696      *  empty string</span>
<span class="line-added"> 697      * @see #getMinusSign()</span>
<span class="line-added"> 698      * @see #getMinusSignText()</span>
<span class="line-added"> 699      * @since 13</span>
<span class="line-added"> 700      */</span>
<span class="line-added"> 701     void setMinusSignText(String minusSignText) {</span>
<span class="line-added"> 702         Objects.requireNonNull(minusSignText);</span>
<span class="line-added"> 703         if (minusSignText.isEmpty()) {</span>
<span class="line-added"> 704             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 705         }</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         hashCode = 0;</span>
<span class="line-added"> 708         this.minusSignText = minusSignText;</span>
<span class="line-added"> 709         this.minusSign = findNonFormatChar(minusSignText, &#39;-&#39;);</span>
<span class="line-added"> 710     }</span>
 711 
 712     //------------------------------------------------------------
 713     // END     Package Private methods ... to be made public later
 714     //------------------------------------------------------------
 715 
 716     /**
 717      * Standard override.
 718      */
 719     @Override
 720     public Object clone() {
 721         try {
 722             return (DecimalFormatSymbols)super.clone();
 723             // other fields are bit-copied
 724         } catch (CloneNotSupportedException e) {
 725             throw new InternalError(e);
 726         }
 727     }
 728 
 729     /**
 730      * Override equals.
 731      */
 732     @Override
 733     public boolean equals(Object obj) {
 734         if (obj == null) return false;
 735         if (this == obj) return true;
 736         if (getClass() != obj.getClass()) return false;
 737         DecimalFormatSymbols other = (DecimalFormatSymbols) obj;
 738         return (zeroDigit == other.zeroDigit &amp;&amp;
<a name="38" id="anc38"></a><span class="line-modified"> 739             groupingSeparator == other.groupingSeparator &amp;&amp;</span>
<span class="line-modified"> 740             decimalSeparator == other.decimalSeparator &amp;&amp;</span>
<span class="line-modified"> 741             percent == other.percent &amp;&amp;</span>
<span class="line-modified"> 742             percentText.equals(other.percentText) &amp;&amp;</span>
<span class="line-modified"> 743             perMill == other.perMill &amp;&amp;</span>
<span class="line-modified"> 744             perMillText.equals(other.perMillText) &amp;&amp;</span>
<span class="line-modified"> 745             digit == other.digit &amp;&amp;</span>
<span class="line-modified"> 746             minusSign == other.minusSign &amp;&amp;</span>
<span class="line-modified"> 747             minusSignText.equals(other.minusSignText) &amp;&amp;</span>
<span class="line-modified"> 748             patternSeparator == other.patternSeparator &amp;&amp;</span>
<span class="line-modified"> 749             infinity.equals(other.infinity) &amp;&amp;</span>
<span class="line-modified"> 750             NaN.equals(other.NaN) &amp;&amp;</span>
<span class="line-modified"> 751             getCurrencySymbol().equals(other.getCurrencySymbol()) &amp;&amp; // possible currency init occurs here</span>
<span class="line-modified"> 752             intlCurrencySymbol.equals(other.intlCurrencySymbol) &amp;&amp;</span>
<span class="line-modified"> 753             currency == other.currency &amp;&amp;</span>
<span class="line-added"> 754             monetarySeparator == other.monetarySeparator &amp;&amp;</span>
<span class="line-added"> 755             monetaryGroupingSeparator == other.monetaryGroupingSeparator &amp;&amp;</span>
<span class="line-added"> 756             exponentialSeparator.equals(other.exponentialSeparator) &amp;&amp;</span>
<span class="line-added"> 757             locale.equals(other.locale));</span>
 758     }
 759 
 760     /**
 761      * Override hashCode.
 762      */
<a name="39" id="anc39"></a><span class="line-added"> 763     private volatile int hashCode;</span>
 764     @Override
 765     public int hashCode() {
<a name="40" id="anc40"></a><span class="line-modified"> 766         if (hashCode == 0) {</span>
<span class="line-modified"> 767             hashCode = Objects.hash(</span>
<span class="line-modified"> 768                 zeroDigit,</span>
<span class="line-modified"> 769                 groupingSeparator,</span>
<span class="line-added"> 770                 decimalSeparator,</span>
<span class="line-added"> 771                 percent,</span>
<span class="line-added"> 772                 percentText,</span>
<span class="line-added"> 773                 perMill,</span>
<span class="line-added"> 774                 perMillText,</span>
<span class="line-added"> 775                 digit,</span>
<span class="line-added"> 776                 minusSign,</span>
<span class="line-added"> 777                 minusSignText,</span>
<span class="line-added"> 778                 patternSeparator,</span>
<span class="line-added"> 779                 infinity,</span>
<span class="line-added"> 780                 NaN,</span>
<span class="line-added"> 781                 getCurrencySymbol(), // possible currency init occurs here</span>
<span class="line-added"> 782                 intlCurrencySymbol,</span>
<span class="line-added"> 783                 currency,</span>
<span class="line-added"> 784                 monetarySeparator,</span>
<span class="line-added"> 785                 monetaryGroupingSeparator,</span>
<span class="line-added"> 786                 exponentialSeparator,</span>
<span class="line-added"> 787                 locale);</span>
<span class="line-added"> 788         }</span>
<span class="line-added"> 789         return hashCode;</span>
 790     }
 791 
 792     /**
 793      * Initializes the symbols from the FormatData resource bundle.
 794      */
 795     private void initialize( Locale locale ) {
 796         this.locale = locale;
 797 
 798         // check for region override
 799         Locale override = locale.getUnicodeLocaleType(&quot;nu&quot;) == null ?
 800             CalendarDataUtility.findRegionOverride(locale) :
 801             locale;
 802 
 803         // get resource bundle data
 804         LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);
 805         // Avoid potential recursions
 806         if (!(adapter instanceof ResourceBundleBasedAdapter)) {
 807             adapter = LocaleProviderAdapter.getResourceBundleBased();
 808         }
 809         Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();
 810         String[] numberElements = (String[]) data[0];
 811 
 812         decimalSeparator = numberElements[0].charAt(0);
 813         groupingSeparator = numberElements[1].charAt(0);
 814         patternSeparator = numberElements[2].charAt(0);
<a name="41" id="anc41"></a><span class="line-modified"> 815         percentText = numberElements[3];</span>
<span class="line-added"> 816         percent = findNonFormatChar(percentText, &#39;%&#39;);</span>
 817         zeroDigit = numberElements[4].charAt(0); //different for Arabic,etc.
 818         digit = numberElements[5].charAt(0);
<a name="42" id="anc42"></a><span class="line-modified"> 819         minusSignText = numberElements[6];</span>
<span class="line-added"> 820         minusSign = findNonFormatChar(minusSignText, &#39;-&#39;);</span>
 821         exponential = numberElements[7].charAt(0);
 822         exponentialSeparator = numberElements[7]; //string representation new since 1.6
<a name="43" id="anc43"></a><span class="line-modified"> 823         perMillText = numberElements[8];</span>
<span class="line-added"> 824         perMill = findNonFormatChar(perMillText, &#39;\u2030&#39;);</span>
 825         infinity  = numberElements[9];
 826         NaN = numberElements[10];
 827 
<a name="44" id="anc44"></a><span class="line-added"> 828         // monetary decimal/grouping separators may be missing in resource bundles</span>
<span class="line-added"> 829         monetarySeparator = numberElements.length &lt; 12 || numberElements[11].isEmpty() ?</span>
<span class="line-added"> 830             decimalSeparator : numberElements[11].charAt(0);</span>
<span class="line-added"> 831         monetaryGroupingSeparator = numberElements.length &lt; 13 || numberElements[12].isEmpty() ?</span>
<span class="line-added"> 832             groupingSeparator : numberElements[12].charAt(0);</span>
<span class="line-added"> 833 </span>
 834         // maybe filled with previously cached values, or null.
 835         intlCurrencySymbol = (String) data[1];
 836         currencySymbol = (String) data[2];
<a name="45" id="anc45"></a><span class="line-added"> 837     }</span>
 838 
<a name="46" id="anc46"></a><span class="line-modified"> 839     /**</span>
<span class="line-modified"> 840      * Obtains non-format single character from String</span>
<span class="line-modified"> 841      */</span>
<span class="line-modified"> 842     private char findNonFormatChar(String src, char defChar) {</span>
<span class="line-added"> 843         return (char)src.chars()</span>
<span class="line-added"> 844             .filter(c -&gt; Character.getType(c) != Character.FORMAT)</span>
<span class="line-added"> 845             .findFirst()</span>
<span class="line-added"> 846             .orElse(defChar);</span>
 847     }
 848 
 849     /**
 850      * Lazy initialization for currency related fields
 851      */
 852     private void initializeCurrency(Locale locale) {
 853         if (currencyInitialized) {
 854             return;
 855         }
 856 
 857         // Try to obtain the currency used in the locale&#39;s country.
 858         // Check for empty country string separately because it&#39;s a valid
 859         // country ID for Locale (and used for the C locale), but not a valid
 860         // ISO 3166 country code, and exceptions are expensive.
 861         if (!locale.getCountry().isEmpty()) {
 862             try {
 863                 currency = Currency.getInstance(locale);
 864             } catch (IllegalArgumentException e) {
 865                 // use default values below for compatibility
 866             }
 867         }
 868 
 869         if (currency != null) {
 870             // get resource bundle data
 871             LocaleProviderAdapter adapter =
 872                 LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);
 873             // Avoid potential recursions
 874             if (!(adapter instanceof ResourceBundleBasedAdapter)) {
 875                 adapter = LocaleProviderAdapter.getResourceBundleBased();
 876             }
 877             Object[] data = adapter.getLocaleResources(locale).getDecimalFormatSymbolsData();
 878             intlCurrencySymbol = currency.getCurrencyCode();
 879             if (data[1] != null &amp;&amp; data[1] == intlCurrencySymbol) {
 880                 currencySymbol = (String) data[2];
 881             } else {
 882                 currencySymbol = currency.getSymbol(locale);
 883                 data[1] = intlCurrencySymbol;
 884                 data[2] = currencySymbol;
 885             }
 886         } else {
 887             // default values
 888             intlCurrencySymbol = &quot;XXX&quot;;
 889             try {
 890                 currency = Currency.getInstance(intlCurrencySymbol);
 891             } catch (IllegalArgumentException e) {
 892             }
 893             currencySymbol = &quot;\u00A4&quot;;
 894         }
 895 
 896         currencyInitialized = true;
 897     }
 898 
 899     /**
 900      * Reads the default serializable fields, provides default values for objects
 901      * in older serial versions, and initializes non-serializable fields.
<a name="47" id="anc47"></a><span class="line-modified"> 902      * If {@code serialVersionOnStream}</span>
<span class="line-modified"> 903      * is less than 1, initializes {@code monetarySeparator} to be</span>
<span class="line-modified"> 904      * the same as {@code decimalSeparator} and {@code exponential}</span>
 905      * to be &#39;E&#39;.
<a name="48" id="anc48"></a><span class="line-modified"> 906      * If {@code serialVersionOnStream} is less than 2,</span>
<span class="line-modified"> 907      * initializes {@code locale}to the root locale, and initializes</span>
<span class="line-modified"> 908      * If {@code serialVersionOnStream} is less than 3, it initializes</span>
<span class="line-modified"> 909      * {@code exponentialSeparator} using {@code exponential}.</span>
<span class="line-modified"> 910      * If {@code serialVersionOnStream} is less than 4, it initializes</span>
<span class="line-added"> 911      * {@code perMillText}, {@code percentText}, and</span>
<span class="line-added"> 912      * {@code minusSignText} using {@code perMill}, {@code percent}, and</span>
<span class="line-added"> 913      * {@code minusSign} respectively.</span>
<span class="line-added"> 914      * If {@code serialVersionOnStream} is less than 5, it initializes</span>
<span class="line-added"> 915      * {@code monetaryGroupingSeparator} using {@code groupingSeparator}.</span>
<span class="line-added"> 916      * Sets {@code serialVersionOnStream} back to the maximum allowed value so that</span>
 917      * default serialization will work properly if this object is streamed out again.
 918      * Initializes the currency from the intlCurrencySymbol field.
 919      *
<a name="49" id="anc49"></a><span class="line-added"> 920      * @throws InvalidObjectException if {@code char} and {@code String}</span>
<span class="line-added"> 921      *      representations of either percent, per mille, and/or minus sign disagree.</span>
 922      * @since  1.1.6
 923      */
<a name="50" id="anc50"></a><span class="line-added"> 924     @java.io.Serial</span>
 925     private void readObject(ObjectInputStream stream)
 926             throws IOException, ClassNotFoundException {
 927         stream.defaultReadObject();
 928         if (serialVersionOnStream &lt; 1) {
 929             // Didn&#39;t have monetarySeparator or exponential field;
 930             // use defaults.
 931             monetarySeparator = decimalSeparator;
 932             exponential       = &#39;E&#39;;
 933         }
 934         if (serialVersionOnStream &lt; 2) {
 935             // didn&#39;t have locale; use root locale
 936             locale = Locale.ROOT;
 937         }
 938         if (serialVersionOnStream &lt; 3) {
 939             // didn&#39;t have exponentialSeparator. Create one using exponential
 940             exponentialSeparator = Character.toString(exponential);
 941         }
<a name="51" id="anc51"></a><span class="line-added"> 942         if (serialVersionOnStream &lt; 4) {</span>
<span class="line-added"> 943             // didn&#39;t have perMillText, percentText, and minusSignText.</span>
<span class="line-added"> 944             // Create one using corresponding char variations.</span>
<span class="line-added"> 945             perMillText = Character.toString(perMill);</span>
<span class="line-added"> 946             percentText = Character.toString(percent);</span>
<span class="line-added"> 947             minusSignText = Character.toString(minusSign);</span>
<span class="line-added"> 948         } else {</span>
<span class="line-added"> 949             // Check whether char and text fields agree</span>
<span class="line-added"> 950             if (findNonFormatChar(perMillText, &#39;\uFFFF&#39;) != perMill ||</span>
<span class="line-added"> 951                 findNonFormatChar(percentText, &#39;\uFFFF&#39;) != percent ||</span>
<span class="line-added"> 952                 findNonFormatChar(minusSignText, &#39;\uFFFF&#39;) != minusSign) {</span>
<span class="line-added"> 953                 throw new InvalidObjectException(</span>
<span class="line-added"> 954                     &quot;&#39;char&#39; and &#39;String&#39; representations of either percent, &quot; +</span>
<span class="line-added"> 955                     &quot;per mille, and/or minus sign disagree.&quot;);</span>
<span class="line-added"> 956             }</span>
<span class="line-added"> 957         }</span>
<span class="line-added"> 958         if (serialVersionOnStream &lt; 5) {</span>
<span class="line-added"> 959             // didn&#39;t have monetaryGroupingSeparator. Create one using groupingSeparator</span>
<span class="line-added"> 960             monetaryGroupingSeparator = groupingSeparator;</span>
<span class="line-added"> 961         }</span>
<span class="line-added"> 962 </span>
 963         serialVersionOnStream = currentSerialVersion;
 964 
 965         if (intlCurrencySymbol != null) {
 966             try {
 967                  currency = Currency.getInstance(intlCurrencySymbol);
 968             } catch (IllegalArgumentException e) {
 969             }
 970             currencyInitialized = true;
 971         }
 972     }
 973 
 974     /**
 975      * Character used for zero.
 976      *
 977      * @serial
 978      * @see #getZeroDigit
 979      */
 980     private  char    zeroDigit;
 981 
 982     /**
<a name="52" id="anc52"></a><span class="line-modified"> 983      * Character used for grouping separator.</span>
 984      *
 985      * @serial
 986      * @see #getGroupingSeparator
 987      */
 988     private  char    groupingSeparator;
 989 
 990     /**
 991      * Character used for decimal sign.
 992      *
 993      * @serial
 994      * @see #getDecimalSeparator
 995      */
 996     private  char    decimalSeparator;
 997 
 998     /**
 999      * Character used for per mille sign.
1000      *
1001      * @serial
1002      * @see #getPerMill
1003      */
1004     private  char    perMill;
1005 
1006     /**
1007      * Character used for percent sign.
1008      * @serial
1009      * @see #getPercent
1010      */
1011     private  char    percent;
1012 
1013     /**
1014      * Character used for a digit in a pattern.
1015      *
1016      * @serial
1017      * @see #getDigit
1018      */
1019     private  char    digit;
1020 
1021     /**
1022      * Character used to separate positive and negative subpatterns
1023      * in a pattern.
1024      *
1025      * @serial
1026      * @see #getPatternSeparator
1027      */
1028     private  char    patternSeparator;
1029 
1030     /**
1031      * String used to represent infinity.
1032      * @serial
1033      * @see #getInfinity
1034      */
1035     private  String  infinity;
1036 
1037     /**
1038      * String used to represent &quot;not a number&quot;.
1039      * @serial
1040      * @see #getNaN
1041      */
1042     private  String  NaN;
1043 
1044     /**
1045      * Character used to represent minus sign.
1046      * @serial
1047      * @see #getMinusSign
1048      */
1049     private  char    minusSign;
1050 
1051     /**
1052      * String denoting the local currency, e.g. &quot;$&quot;.
1053      * @serial
1054      * @see #getCurrencySymbol
1055      */
1056     private  String  currencySymbol;
1057 
1058     /**
1059      * ISO 4217 currency code denoting the local currency, e.g. &quot;USD&quot;.
1060      * @serial
1061      * @see #getInternationalCurrencySymbol
1062      */
1063     private  String  intlCurrencySymbol;
1064 
1065     /**
1066      * The decimal separator used when formatting currency values.
1067      * @serial
1068      * @since  1.1.6
1069      * @see #getMonetaryDecimalSeparator
1070      */
1071     private  char    monetarySeparator; // Field new in JDK 1.1.6
1072 
1073     /**
1074      * The character used to distinguish the exponent in a number formatted
1075      * in exponential notation, e.g. &#39;E&#39; for a number such as &quot;1.23E45&quot;.
1076      * &lt;p&gt;
1077      * Note that the public API provides no way to set this field,
1078      * even though it is supported by the implementation and the stream format.
1079      * The intent is that this will be added to the API in the future.
1080      *
1081      * @serial
1082      * @since  1.1.6
1083      */
1084     private  char    exponential;       // Field new in JDK 1.1.6
1085 
1086     /**
1087      * The string used to separate the mantissa from the exponent.
1088      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
1089      * &lt;p&gt;
<a name="53" id="anc53"></a><span class="line-modified">1090      * If both {@code exponential} and {@code exponentialSeparator}</span>
<span class="line-modified">1091      * exist, this {@code exponentialSeparator} has the precedence.</span>
1092      *
1093      * @serial
1094      * @since 1.6
1095      */
1096     private  String    exponentialSeparator;       // Field new in JDK 1.6
1097 
1098     /**
1099      * The locale of these currency format symbols.
1100      *
1101      * @serial
1102      * @since 1.4
1103      */
1104     private Locale locale;
1105 
<a name="54" id="anc54"></a><span class="line-added">1106     /**</span>
<span class="line-added">1107      * String representation of per mille sign, which may include</span>
<span class="line-added">1108      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1109      * The first non-format character of this string is the same as</span>
<span class="line-added">1110      * {@code perMill}.</span>
<span class="line-added">1111      *</span>
<span class="line-added">1112      * @serial</span>
<span class="line-added">1113      * @since 13</span>
<span class="line-added">1114      */</span>
<span class="line-added">1115     private  String perMillText;</span>
<span class="line-added">1116 </span>
<span class="line-added">1117     /**</span>
<span class="line-added">1118      * String representation of percent sign, which may include</span>
<span class="line-added">1119      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1120      * The first non-format character of this string is the same as</span>
<span class="line-added">1121      * {@code percent}.</span>
<span class="line-added">1122      *</span>
<span class="line-added">1123      * @serial</span>
<span class="line-added">1124      * @since 13</span>
<span class="line-added">1125      */</span>
<span class="line-added">1126     private  String percentText;</span>
<span class="line-added">1127 </span>
<span class="line-added">1128     /**</span>
<span class="line-added">1129      * String representation of minus sign, which may include</span>
<span class="line-added">1130      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1131      * The first non-format character of this string is the same as</span>
<span class="line-added">1132      * {@code minusSign}.</span>
<span class="line-added">1133      *</span>
<span class="line-added">1134      * @serial</span>
<span class="line-added">1135      * @since 13</span>
<span class="line-added">1136      */</span>
<span class="line-added">1137     private  String minusSignText;</span>
<span class="line-added">1138 </span>
<span class="line-added">1139     /**</span>
<span class="line-added">1140      * The grouping separator used when formatting currency values.</span>
<span class="line-added">1141      *</span>
<span class="line-added">1142      * @serial</span>
<span class="line-added">1143      * @since 15</span>
<span class="line-added">1144      */</span>
<span class="line-added">1145     private  char    monetaryGroupingSeparator;</span>
<span class="line-added">1146 </span>
1147     // currency; only the ISO code is serialized.
1148     private transient Currency currency;
1149     private transient volatile boolean currencyInitialized;
1150 
1151     // Proclaim JDK 1.1 FCS compatibility
<a name="55" id="anc55"></a><span class="line-added">1152     @java.io.Serial</span>
1153     static final long serialVersionUID = 5772796243397350300L;
1154 
1155     // The internal serial version which says which version was written
1156     // - 0 (default) for version up to JDK 1.1.5
1157     // - 1 for version from JDK 1.1.6, which includes two new fields:
1158     //     monetarySeparator and exponential.
1159     // - 2 for version from J2SE 1.4, which includes locale field.
1160     // - 3 for version from J2SE 1.6, which includes exponentialSeparator field.
<a name="56" id="anc56"></a><span class="line-modified">1161     // - 4 for version from Java SE 13, which includes perMillText, percentText,</span>
<span class="line-added">1162     //      and minusSignText field.</span>
<span class="line-added">1163     // - 5 for version from Java SE 15, which includes monetaryGroupingSeparator.</span>
<span class="line-added">1164     private static final int currentSerialVersion = 5;</span>
1165 
1166     /**
<a name="57" id="anc57"></a><span class="line-modified">1167      * Describes the version of {@code DecimalFormatSymbols} present on the stream.</span>
1168      * Possible values are:
1169      * &lt;ul&gt;
1170      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): versions prior to JDK 1.1.6.
1171      *
1172      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: Versions written by JDK 1.1.6 or later, which include
<a name="58" id="anc58"></a><span class="line-modified">1173      *      two new fields: {@code monetarySeparator} and {@code exponential}.</span>
1174      * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: Versions written by J2SE 1.4 or later, which include a
<a name="59" id="anc59"></a><span class="line-modified">1175      *      new {@code locale} field.</span>
1176      * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: Versions written by J2SE 1.6 or later, which include a
<a name="60" id="anc60"></a><span class="line-modified">1177      *      new {@code exponentialSeparator} field.</span>
<span class="line-modified">1178      * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: Versions written by Java SE 13 or later, which include</span>
<span class="line-modified">1179      *      new {@code perMillText}, {@code percentText}, and</span>
<span class="line-modified">1180      *      {@code minusSignText} field.</span>
<span class="line-added">1181      * &lt;li&gt;&lt;b&gt;5&lt;/b&gt;: Versions written by Java SE 15 or later, which include</span>
<span class="line-added">1182      *      new {@code monetaryGroupingSeparator} field.</span>
<span class="line-added">1183      * * &lt;/ul&gt;</span>
<span class="line-added">1184      * When streaming out a {@code DecimalFormatSymbols}, the most recent format</span>
<span class="line-added">1185      * (corresponding to the highest allowable {@code serialVersionOnStream})</span>
1186      * is always written.
1187      *
1188      * @serial
1189      * @since  1.1.6
1190      */
1191     private int serialVersionOnStream = currentSerialVersion;
1192 }
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="61" type="hidden" />
</body>
</html>
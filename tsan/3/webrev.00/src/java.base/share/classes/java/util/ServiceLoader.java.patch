diff a/src/java.base/share/classes/java/util/ServiceLoader.java b/src/java.base/share/classes/java/util/ServiceLoader.java
--- a/src/java.base/share/classes/java/util/ServiceLoader.java
+++ b/src/java.base/share/classes/java/util/ServiceLoader.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -43,21 +43,22 @@
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import sun.nio.cs.UTF_8;
+
 import jdk.internal.loader.BootLoader;
 import jdk.internal.loader.ClassLoaders;
 import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.VM;
 import jdk.internal.module.ServicesCatalog;
 import jdk.internal.module.ServicesCatalog.ServiceProvider;
 import jdk.internal.reflect.CallerSensitive;
 import jdk.internal.reflect.Reflection;
 
-
 /**
  * A facility to load implementations of a service.
  *
  * <p> A <i>service</i> is a well-known interface or class for which zero, one,
  * or many service providers exist. A <i>service provider</i> (or just
@@ -67,11 +68,11 @@
  * application's choosing. Application code refers only to the service, not to
  * service providers, and is assumed to be capable of choosing between multiple
  * service providers (based on the functionality they expose through the service),
  * and handling the possibility that no service providers are located.
  *
- * <h3> Obtaining a service loader </h3>
+ * <h2> Obtaining a service loader </h2>
  *
  * <p> An application obtains a service loader for a given service by invoking
  * one of the static {@code load} methods of {@code ServiceLoader}. If the
  * application is a module, then its module declaration must have a <i>uses</i>
  * directive that specifies the service; this helps to locate providers and ensure
@@ -139,11 +140,11 @@
  *   <li> A stream of {@code Provider<CodecFactory>} objects </li>
  *   <li> {@code p.type()} yields a {@code Class<CodecFactory>} </li>
  *   <li> {@code get()} yields an instance of {@code CodecFactory} </li>
  * </ol>
  *
- * <h3> Designing services </h3>
+ * <h2> Designing services </h2>
  *
  * <p> A service is a single type, usually an interface or abstract class. A
  * concrete class can be used, but this is not recommended. The type may have
  * any accessibility. The methods of a service are highly domain-specific, so
  * this API specification cannot give concrete advice about their form or
@@ -165,11 +166,11 @@
  *   expresses through its name that its service providers are factories
  *   for codecs, rather than codecs themselves, because it may be expensive
  *   or complicated to produce certain codecs. </p></li>
  * </ol>
  *
- * <h3> <a id="developing-service-providers">Developing service providers</a> </h3>
+ * <h2> <a id="developing-service-providers">Developing service providers</a> </h2>
  *
  * <p> A service provider is a single type, usually a concrete class. An
  * interface or abstract class is permitted because it may declare a static
  * provider method, discussed later. The type must be public and must not be
  * an inner class.
@@ -186,11 +187,11 @@
  * packaged as JAR files. The application instantiates service providers via
  * the service loader's iterator, or via {@link Provider Provider} objects in
  * the service loader's stream, without knowledge of the service providers'
  * locations.
  *
- * <h3> Deploying service providers as modules </h3>
+ * <h2> Deploying service providers as modules </h2>
  *
  * <p> A service provider that is developed in a module must be specified in a
  * <i>provides</i> directive in the module declaration. The provides directive
  * specifies both the service and the service provider; this helps to locate the
  * provider when another module, with a <i>uses</i> directive for the service,
@@ -251,11 +252,11 @@
  * its {@code provider} method. The requirement that the provider constructor or
  * provider method is public helps to document the intent that the class (that is,
  * the service provider) will be instantiated by an entity (that is, a service
  * loader) which is outside the class's package.
  *
- * <h3> Deploying service providers on the class path </h3>
+ * <h2> Deploying service providers on the class path </h2>
  *
  * A service provider that is packaged as a JAR file for the class path is
  * identified by placing a <i>provider-configuration file</i> in the resource
  * directory {@code META-INF/services}. The name of the provider-configuration
  * file is the fully qualified binary name of the service. The provider-configuration
@@ -291,11 +292,11 @@
  * different JAR file. The service provider must be visible from the class loader
  * that is initially queried to locate the provider-configuration file; this is
  * not necessarily the class loader which ultimately locates the
  * provider-configuration file.
  *
- * <h3> Timing of provider discovery </h3>
+ * <h2> Timing of provider discovery </h2>
  *
  * <p> Service providers are loaded and instantiated lazily, that is, on demand.
  * A service loader maintains a cache of the providers that have been loaded so
  * far. Each invocation of the {@code iterator} method returns an {@code Iterator}
  * that first yields all of the elements cached from previous iteration, in
@@ -304,11 +305,11 @@
  * of the stream method returns a {@code Stream} that first processes all
  * providers loaded by previous stream operations, in load order, and then lazily
  * locates any remaining providers. Caches are cleared via the {@link #reload
  * reload} method.
  *
- * <h3> <a id="errors">Errors</a> </h3>
+ * <h2> <a id="errors">Errors</a> </h2>
  *
  * <p> When using the service loader's {@code iterator}, the {@link
  * Iterator#hasNext() hasNext} and {@link Iterator#next() next} methods will
  * fail with {@link ServiceConfigurationError} if an error occurs locating,
  * loading or instantiating a service provider. When processing the service
@@ -359,20 +360,20 @@
  *   class, or does not define a provider constructor, or cannot be
  *   instantiated. </li>
  *
  * </ul>
  *
- * <h3> Security </h3>
+ * <h2> Security </h2>
  *
  * <p> Service loaders always execute in the security context of the caller
  * of the iterator or stream methods and may also be restricted by the security
  * context of the caller that created the service loader.
  * Trusted system code should typically invoke the methods in this class, and
  * the methods of the iterators which they return, from within a privileged
  * security context.
  *
- * <h3> Concurrency </h3>
+ * <h2> Concurrency </h2>
  *
  * <p> Instances of this class are not safe for use by multiple concurrent
  * threads.
  *
  * <h3> Null handling </h3>
@@ -1162,11 +1163,11 @@
             try {
                 URLConnection uc = u.openConnection();
                 uc.setUseCaches(false);
                 try (InputStream in = uc.getInputStream();
                      BufferedReader r
-                         = new BufferedReader(new InputStreamReader(in, "utf-8")))
+                         = new BufferedReader(new InputStreamReader(in, UTF_8.INSTANCE)))
                 {
                     int lc = 1;
                     while ((lc = parseLine(u, r, lc, names)) >= 0);
                 }
             } catch (IOException x) {

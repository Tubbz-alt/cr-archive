<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/DataOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DataOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EOFException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/DataOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data output stream lets an application write primitive Java data
 30  * types to an output stream in a portable way. An application can
 31  * then use a data input stream to read the data back in.
 32  *
 33  * @author  unascribed
 34  * @see     java.io.DataInputStream
 35  * @since   1.0
 36  */
<span class="line-modified"> 37 public</span>
<span class="line-removed"> 38 class DataOutputStream extends FilterOutputStream implements DataOutput {</span>
 39     /**
 40      * The number of bytes written to the data output stream so far.
 41      * If this counter overflows, it will be wrapped to Integer.MAX_VALUE.
 42      */
 43     protected int written;
 44 
 45     /**
 46      * bytearr is initialized on demand by writeUTF
 47      */
 48     private byte[] bytearr = null;
 49 
 50     /**
 51      * Creates a new data output stream to write data to the specified
<span class="line-modified"> 52      * underlying output stream. The counter &lt;code&gt;written&lt;/code&gt; is</span>
 53      * set to zero.
 54      *
 55      * @param   out   the underlying output stream, to be saved for later
 56      *                use.
 57      * @see     java.io.FilterOutputStream#out
 58      */
 59     public DataOutputStream(OutputStream out) {
 60         super(out);
 61     }
 62 
 63     /**
 64      * Increases the written counter by the specified value
 65      * until it reaches Integer.MAX_VALUE.
 66      */
 67     private void incCount(int value) {
 68         int temp = written + value;
 69         if (temp &lt; 0) {
 70             temp = Integer.MAX_VALUE;
 71         }
 72         written = temp;
 73     }
 74 
 75     /**
 76      * Writes the specified byte (the low eight bits of the argument
<span class="line-modified"> 77      * &lt;code&gt;b&lt;/code&gt;) to the underlying output stream. If no exception</span>
<span class="line-modified"> 78      * is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by</span>
<span class="line-modified"> 79      * &lt;code&gt;1&lt;/code&gt;.</span>
 80      * &lt;p&gt;
<span class="line-modified"> 81      * Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</span>
 82      *
<span class="line-modified"> 83      * @param      b   the &lt;code&gt;byte&lt;/code&gt; to be written.</span>
<span class="line-modified"> 84      * @exception  IOException  if an I/O error occurs.</span>
 85      * @see        java.io.FilterOutputStream#out
 86      */
 87     public synchronized void write(int b) throws IOException {
 88         out.write(b);
 89         incCount(1);
 90     }
 91 
 92     /**
<span class="line-modified"> 93      * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span>
<span class="line-modified"> 94      * starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.</span>
<span class="line-modified"> 95      * If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified"> 96      * incremented by &lt;code&gt;len&lt;/code&gt;.</span>
 97      *
 98      * @param      b     the data.
 99      * @param      off   the start offset in the data.
100      * @param      len   the number of bytes to write.
<span class="line-modified">101      * @exception  IOException  if an I/O error occurs.</span>
102      * @see        java.io.FilterOutputStream#out
103      */
104     public synchronized void write(byte b[], int off, int len)
105         throws IOException
106     {
107         out.write(b, off, len);
108         incCount(len);
109     }
110 
111     /**
112      * Flushes this data output stream. This forces any buffered output
113      * bytes to be written out to the stream.
114      * &lt;p&gt;
<span class="line-modified">115      * The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;DataOutputStream&lt;/code&gt;</span>
<span class="line-modified">116      * calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</span>
117      *
<span class="line-modified">118      * @exception  IOException  if an I/O error occurs.</span>
119      * @see        java.io.FilterOutputStream#out
120      * @see        java.io.OutputStream#flush()
121      */
122     public void flush() throws IOException {
123         out.flush();
124     }
125 
126     /**
<span class="line-modified">127      * Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as</span>
<span class="line-modified">128      * a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the</span>
<span class="line-modified">129      * value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is</span>
<span class="line-modified">130      * written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is</span>
<span class="line-modified">131      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by</span>
<span class="line-modified">132      * &lt;code&gt;1&lt;/code&gt;.</span>
133      *
<span class="line-modified">134      * @param      v   a &lt;code&gt;boolean&lt;/code&gt; value to be written.</span>
<span class="line-modified">135      * @exception  IOException  if an I/O error occurs.</span>
136      * @see        java.io.FilterOutputStream#out
137      */
138     public final void writeBoolean(boolean v) throws IOException {
139         out.write(v ? 1 : 0);
140         incCount(1);
141     }
142 
143     /**
<span class="line-modified">144      * Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as</span>
145      * a 1-byte value. If no exception is thrown, the counter
<span class="line-modified">146      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</span>
147      *
<span class="line-modified">148      * @param      v   a &lt;code&gt;byte&lt;/code&gt; value to be written.</span>
<span class="line-modified">149      * @exception  IOException  if an I/O error occurs.</span>
150      * @see        java.io.FilterOutputStream#out
151      */
152     public final void writeByte(int v) throws IOException {
153         out.write(v);
154         incCount(1);
155     }
156 
157     /**
<span class="line-modified">158      * Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two</span>
159      * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">160      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</span>
161      *
<span class="line-modified">162      * @param      v   a &lt;code&gt;short&lt;/code&gt; to be written.</span>
<span class="line-modified">163      * @exception  IOException  if an I/O error occurs.</span>
164      * @see        java.io.FilterOutputStream#out
165      */
166     public final void writeShort(int v) throws IOException {
167         out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
168         out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
169         incCount(2);
170     }
171 
172     /**
<span class="line-modified">173      * Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a</span>
174      * 2-byte value, high byte first. If no exception is thrown, the
<span class="line-modified">175      * counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</span>
176      *
<span class="line-modified">177      * @param      v   a &lt;code&gt;char&lt;/code&gt; value to be written.</span>
<span class="line-modified">178      * @exception  IOException  if an I/O error occurs.</span>
179      * @see        java.io.FilterOutputStream#out
180      */
181     public final void writeChar(int v) throws IOException {
182         out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
183         out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
184         incCount(2);
185     }
186 
187     /**
<span class="line-modified">188      * Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four</span>
189      * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">190      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</span>
191      *
<span class="line-modified">192      * @param      v   an &lt;code&gt;int&lt;/code&gt; to be written.</span>
<span class="line-modified">193      * @exception  IOException  if an I/O error occurs.</span>
194      * @see        java.io.FilterOutputStream#out
195      */
196     public final void writeInt(int v) throws IOException {
197         out.write((v &gt;&gt;&gt; 24) &amp; 0xFF);
198         out.write((v &gt;&gt;&gt; 16) &amp; 0xFF);
199         out.write((v &gt;&gt;&gt;  8) &amp; 0xFF);
200         out.write((v &gt;&gt;&gt;  0) &amp; 0xFF);
201         incCount(4);
202     }
203 
204     private byte writeBuffer[] = new byte[8];
205 
206     /**
<span class="line-modified">207      * Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight</span>
208      * bytes, high byte first. In no exception is thrown, the counter
<span class="line-modified">209      * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</span>
210      *
<span class="line-modified">211      * @param      v   a &lt;code&gt;long&lt;/code&gt; to be written.</span>
<span class="line-modified">212      * @exception  IOException  if an I/O error occurs.</span>
213      * @see        java.io.FilterOutputStream#out
214      */
215     public final void writeLong(long v) throws IOException {
216         writeBuffer[0] = (byte)(v &gt;&gt;&gt; 56);
217         writeBuffer[1] = (byte)(v &gt;&gt;&gt; 48);
218         writeBuffer[2] = (byte)(v &gt;&gt;&gt; 40);
219         writeBuffer[3] = (byte)(v &gt;&gt;&gt; 32);
220         writeBuffer[4] = (byte)(v &gt;&gt;&gt; 24);
221         writeBuffer[5] = (byte)(v &gt;&gt;&gt; 16);
222         writeBuffer[6] = (byte)(v &gt;&gt;&gt;  8);
223         writeBuffer[7] = (byte)(v &gt;&gt;&gt;  0);
224         out.write(writeBuffer, 0, 8);
225         incCount(8);
226     }
227 
228     /**
<span class="line-modified">229      * Converts the float argument to an &lt;code&gt;int&lt;/code&gt; using the</span>
<span class="line-modified">230      * &lt;code&gt;floatToIntBits&lt;/code&gt; method in class &lt;code&gt;Float&lt;/code&gt;,</span>
<span class="line-modified">231      * and then writes that &lt;code&gt;int&lt;/code&gt; value to the underlying</span>
232      * output stream as a 4-byte quantity, high byte first. If no
<span class="line-modified">233      * exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified">234      * incremented by &lt;code&gt;4&lt;/code&gt;.</span>
235      *
<span class="line-modified">236      * @param      v   a &lt;code&gt;float&lt;/code&gt; value to be written.</span>
<span class="line-modified">237      * @exception  IOException  if an I/O error occurs.</span>
238      * @see        java.io.FilterOutputStream#out
239      * @see        java.lang.Float#floatToIntBits(float)
240      */
241     public final void writeFloat(float v) throws IOException {
242         writeInt(Float.floatToIntBits(v));
243     }
244 
245     /**
<span class="line-modified">246      * Converts the double argument to a &lt;code&gt;long&lt;/code&gt; using the</span>
<span class="line-modified">247      * &lt;code&gt;doubleToLongBits&lt;/code&gt; method in class &lt;code&gt;Double&lt;/code&gt;,</span>
<span class="line-modified">248      * and then writes that &lt;code&gt;long&lt;/code&gt; value to the underlying</span>
249      * output stream as an 8-byte quantity, high byte first. If no
<span class="line-modified">250      * exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is</span>
<span class="line-modified">251      * incremented by &lt;code&gt;8&lt;/code&gt;.</span>
252      *
<span class="line-modified">253      * @param      v   a &lt;code&gt;double&lt;/code&gt; value to be written.</span>
<span class="line-modified">254      * @exception  IOException  if an I/O error occurs.</span>
255      * @see        java.io.FilterOutputStream#out
256      * @see        java.lang.Double#doubleToLongBits(double)
257      */
258     public final void writeDouble(double v) throws IOException {
259         writeLong(Double.doubleToLongBits(v));
260     }
261 
262     /**
263      * Writes out the string to the underlying output stream as a
264      * sequence of bytes. Each character in the string is written out, in
265      * sequence, by discarding its high eight bits. If no exception is
<span class="line-modified">266      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by the</span>
<span class="line-modified">267      * length of &lt;code&gt;s&lt;/code&gt;.</span>
268      *
269      * @param      s   a string of bytes to be written.
<span class="line-modified">270      * @exception  IOException  if an I/O error occurs.</span>
271      * @see        java.io.FilterOutputStream#out
272      */
273     public final void writeBytes(String s) throws IOException {
274         int len = s.length();
275         for (int i = 0 ; i &lt; len ; i++) {
276             out.write((byte)s.charAt(i));
277         }
278         incCount(len);
279     }
280 
281     /**
282      * Writes a string to the underlying output stream as a sequence of
283      * characters. Each character is written to the data output stream as
<span class="line-modified">284      * if by the &lt;code&gt;writeChar&lt;/code&gt; method. If no exception is</span>
<span class="line-modified">285      * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by twice</span>
<span class="line-modified">286      * the length of &lt;code&gt;s&lt;/code&gt;.</span>
287      *
<span class="line-modified">288      * @param      s   a &lt;code&gt;String&lt;/code&gt; value to be written.</span>
<span class="line-modified">289      * @exception  IOException  if an I/O error occurs.</span>
290      * @see        java.io.DataOutputStream#writeChar(int)
291      * @see        java.io.FilterOutputStream#out
292      */
293     public final void writeChars(String s) throws IOException {
294         int len = s.length();
295         for (int i = 0 ; i &lt; len ; i++) {
296             int v = s.charAt(i);
297             out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
298             out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
299         }
300         incCount(len * 2);
301     }
302 
303     /**
304      * Writes a string to the underlying output stream using
305      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
306      * encoding in a machine-independent manner.
307      * &lt;p&gt;
308      * First, two bytes are written to the output stream as if by the
<span class="line-modified">309      * &lt;code&gt;writeShort&lt;/code&gt; method giving the number of bytes to</span>
310      * follow. This value is the number of bytes actually written out,
311      * not the length of the string. Following the length, each character
312      * of the string is output, in sequence, using the modified UTF-8 encoding
313      * for the character. If no exception is thrown, the counter
<span class="line-modified">314      * &lt;code&gt;written&lt;/code&gt; is incremented by the total number of</span>
315      * bytes written to the output stream. This will be at least two
<span class="line-modified">316      * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus</span>
<span class="line-modified">317      * thrice the length of &lt;code&gt;str&lt;/code&gt;.</span>
318      *
319      * @param      str   a string to be written.
<span class="line-modified">320      * @exception  IOException  if an I/O error occurs.</span>



321      */
322     public final void writeUTF(String str) throws IOException {
323         writeUTF(str, this);
324     }
325 
326     /**
327      * Writes a string to the specified DataOutput using
328      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
329      * encoding in a machine-independent manner.
330      * &lt;p&gt;
<span class="line-modified">331      * First, two bytes are written to out as if by the &lt;code&gt;writeShort&lt;/code&gt;</span>
332      * method giving the number of bytes to follow. This value is the number of
333      * bytes actually written out, not the length of the string. Following the
334      * length, each character of the string is output, in sequence, using the
335      * modified UTF-8 encoding for the character. If no exception is thrown, the
<span class="line-modified">336      * counter &lt;code&gt;written&lt;/code&gt; is incremented by the total number of</span>
337      * bytes written to the output stream. This will be at least two
<span class="line-modified">338      * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus</span>
<span class="line-modified">339      * thrice the length of &lt;code&gt;str&lt;/code&gt;.</span>
340      *
341      * @param      str   a string to be written.
342      * @param      out   destination to write to
343      * @return     The number of bytes written out.
<span class="line-modified">344      * @exception  IOException  if an I/O error occurs.</span>


345      */
346     static int writeUTF(String str, DataOutput out) throws IOException {
<span class="line-modified">347         int strlen = str.length();</span>
<span class="line-modified">348         int utflen = 0;</span>
<span class="line-removed">349         int c, count = 0;</span>
350 
<span class="line-removed">351         /* use charAt instead of copying String to char array */</span>
352         for (int i = 0; i &lt; strlen; i++) {
<span class="line-modified">353             c = str.charAt(i);</span>
<span class="line-modified">354             if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) {</span>
<span class="line-modified">355                 utflen++;</span>
<span class="line-removed">356             } else if (c &gt; 0x07FF) {</span>
<span class="line-removed">357                 utflen += 3;</span>
<span class="line-removed">358             } else {</span>
<span class="line-removed">359                 utflen += 2;</span>
<span class="line-removed">360             }</span>
361         }
362 
<span class="line-modified">363         if (utflen &gt; 65535)</span>
<span class="line-modified">364             throw new UTFDataFormatException(</span>
<span class="line-removed">365                 &quot;encoded string too long: &quot; + utflen + &quot; bytes&quot;);</span>
366 
<span class="line-modified">367         byte[] bytearr = null;</span>
368         if (out instanceof DataOutputStream) {
369             DataOutputStream dos = (DataOutputStream)out;
<span class="line-modified">370             if(dos.bytearr == null || (dos.bytearr.length &lt; (utflen+2)))</span>
371                 dos.bytearr = new byte[(utflen*2) + 2];
372             bytearr = dos.bytearr;
373         } else {
<span class="line-modified">374             bytearr = new byte[utflen+2];</span>
375         }
376 

377         bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 8) &amp; 0xFF);
378         bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 0) &amp; 0xFF);
379 
<span class="line-modified">380         int i=0;</span>
<span class="line-modified">381         for (i=0; i&lt;strlen; i++) {</span>
<span class="line-modified">382            c = str.charAt(i);</span>
<span class="line-modified">383            if (!((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F))) break;</span>
<span class="line-modified">384            bytearr[count++] = (byte) c;</span>
385         }
386 
<span class="line-modified">387         for (;i &lt; strlen; i++){</span>
<span class="line-modified">388             c = str.charAt(i);</span>
<span class="line-modified">389             if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) {</span>
390                 bytearr[count++] = (byte) c;
<span class="line-modified">391 </span>
<span class="line-removed">392             } else if (c &gt; 0x07FF) {</span>
393                 bytearr[count++] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
394                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  6) &amp; 0x3F));
395                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
396             } else {
397                 bytearr[count++] = (byte) (0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));
398                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
399             }
400         }
<span class="line-modified">401         out.write(bytearr, 0, utflen+2);</span>
402         return utflen + 2;
403     }
404 










405     /**
<span class="line-modified">406      * Returns the current value of the counter &lt;code&gt;written&lt;/code&gt;,</span>
407      * the number of bytes written to this data output stream so far.
408      * If the counter overflows, it will be wrapped to Integer.MAX_VALUE.
409      *
<span class="line-modified">410      * @return  the value of the &lt;code&gt;written&lt;/code&gt; field.</span>
411      * @see     java.io.DataOutputStream#written
412      */
413     public final int size() {
414         return written;
415     }
416 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * A data output stream lets an application write primitive Java data
 30  * types to an output stream in a portable way. An application can
 31  * then use a data input stream to read the data back in.
 32  *
 33  * @author  unascribed
 34  * @see     java.io.DataInputStream
 35  * @since   1.0
 36  */
<span class="line-modified"> 37 public class DataOutputStream extends FilterOutputStream implements DataOutput {</span>

 38     /**
 39      * The number of bytes written to the data output stream so far.
 40      * If this counter overflows, it will be wrapped to Integer.MAX_VALUE.
 41      */
 42     protected int written;
 43 
 44     /**
 45      * bytearr is initialized on demand by writeUTF
 46      */
 47     private byte[] bytearr = null;
 48 
 49     /**
 50      * Creates a new data output stream to write data to the specified
<span class="line-modified"> 51      * underlying output stream. The counter {@code written} is</span>
 52      * set to zero.
 53      *
 54      * @param   out   the underlying output stream, to be saved for later
 55      *                use.
 56      * @see     java.io.FilterOutputStream#out
 57      */
 58     public DataOutputStream(OutputStream out) {
 59         super(out);
 60     }
 61 
 62     /**
 63      * Increases the written counter by the specified value
 64      * until it reaches Integer.MAX_VALUE.
 65      */
 66     private void incCount(int value) {
 67         int temp = written + value;
 68         if (temp &lt; 0) {
 69             temp = Integer.MAX_VALUE;
 70         }
 71         written = temp;
 72     }
 73 
 74     /**
 75      * Writes the specified byte (the low eight bits of the argument
<span class="line-modified"> 76      * {@code b}) to the underlying output stream. If no exception</span>
<span class="line-modified"> 77      * is thrown, the counter {@code written} is incremented by</span>
<span class="line-modified"> 78      * {@code 1}.</span>
 79      * &lt;p&gt;
<span class="line-modified"> 80      * Implements the {@code write} method of {@code OutputStream}.</span>
 81      *
<span class="line-modified"> 82      * @param      b   the {@code byte} to be written.</span>
<span class="line-modified"> 83      * @throws     IOException  if an I/O error occurs.</span>
 84      * @see        java.io.FilterOutputStream#out
 85      */
 86     public synchronized void write(int b) throws IOException {
 87         out.write(b);
 88         incCount(1);
 89     }
 90 
 91     /**
<span class="line-modified"> 92      * Writes {@code len} bytes from the specified byte array</span>
<span class="line-modified"> 93      * starting at offset {@code off} to the underlying output stream.</span>
<span class="line-modified"> 94      * If no exception is thrown, the counter {@code written} is</span>
<span class="line-modified"> 95      * incremented by {@code len}.</span>
 96      *
 97      * @param      b     the data.
 98      * @param      off   the start offset in the data.
 99      * @param      len   the number of bytes to write.
<span class="line-modified">100      * @throws     IOException  if an I/O error occurs.</span>
101      * @see        java.io.FilterOutputStream#out
102      */
103     public synchronized void write(byte b[], int off, int len)
104         throws IOException
105     {
106         out.write(b, off, len);
107         incCount(len);
108     }
109 
110     /**
111      * Flushes this data output stream. This forces any buffered output
112      * bytes to be written out to the stream.
113      * &lt;p&gt;
<span class="line-modified">114      * The {@code flush} method of {@code DataOutputStream}</span>
<span class="line-modified">115      * calls the {@code flush} method of its underlying output stream.</span>
116      *
<span class="line-modified">117      * @throws     IOException  if an I/O error occurs.</span>
118      * @see        java.io.FilterOutputStream#out
119      * @see        java.io.OutputStream#flush()
120      */
121     public void flush() throws IOException {
122         out.flush();
123     }
124 
125     /**
<span class="line-modified">126      * Writes a {@code boolean} to the underlying output stream as</span>
<span class="line-modified">127      * a 1-byte value. The value {@code true} is written out as the</span>
<span class="line-modified">128      * value {@code (byte)1}; the value {@code false} is</span>
<span class="line-modified">129      * written out as the value {@code (byte)0}. If no exception is</span>
<span class="line-modified">130      * thrown, the counter {@code written} is incremented by</span>
<span class="line-modified">131      * {@code 1}.</span>
132      *
<span class="line-modified">133      * @param      v   a {@code boolean} value to be written.</span>
<span class="line-modified">134      * @throws     IOException  if an I/O error occurs.</span>
135      * @see        java.io.FilterOutputStream#out
136      */
137     public final void writeBoolean(boolean v) throws IOException {
138         out.write(v ? 1 : 0);
139         incCount(1);
140     }
141 
142     /**
<span class="line-modified">143      * Writes out a {@code byte} to the underlying output stream as</span>
144      * a 1-byte value. If no exception is thrown, the counter
<span class="line-modified">145      * {@code written} is incremented by {@code 1}.</span>
146      *
<span class="line-modified">147      * @param      v   a {@code byte} value to be written.</span>
<span class="line-modified">148      * @throws     IOException  if an I/O error occurs.</span>
149      * @see        java.io.FilterOutputStream#out
150      */
151     public final void writeByte(int v) throws IOException {
152         out.write(v);
153         incCount(1);
154     }
155 
156     /**
<span class="line-modified">157      * Writes a {@code short} to the underlying output stream as two</span>
158      * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">159      * {@code written} is incremented by {@code 2}.</span>
160      *
<span class="line-modified">161      * @param      v   a {@code short} to be written.</span>
<span class="line-modified">162      * @throws     IOException  if an I/O error occurs.</span>
163      * @see        java.io.FilterOutputStream#out
164      */
165     public final void writeShort(int v) throws IOException {
166         out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
167         out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
168         incCount(2);
169     }
170 
171     /**
<span class="line-modified">172      * Writes a {@code char} to the underlying output stream as a</span>
173      * 2-byte value, high byte first. If no exception is thrown, the
<span class="line-modified">174      * counter {@code written} is incremented by {@code 2}.</span>
175      *
<span class="line-modified">176      * @param      v   a {@code char} value to be written.</span>
<span class="line-modified">177      * @throws     IOException  if an I/O error occurs.</span>
178      * @see        java.io.FilterOutputStream#out
179      */
180     public final void writeChar(int v) throws IOException {
181         out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
182         out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
183         incCount(2);
184     }
185 
186     /**
<span class="line-modified">187      * Writes an {@code int} to the underlying output stream as four</span>
188      * bytes, high byte first. If no exception is thrown, the counter
<span class="line-modified">189      * {@code written} is incremented by {@code 4}.</span>
190      *
<span class="line-modified">191      * @param      v   an {@code int} to be written.</span>
<span class="line-modified">192      * @throws     IOException  if an I/O error occurs.</span>
193      * @see        java.io.FilterOutputStream#out
194      */
195     public final void writeInt(int v) throws IOException {
196         out.write((v &gt;&gt;&gt; 24) &amp; 0xFF);
197         out.write((v &gt;&gt;&gt; 16) &amp; 0xFF);
198         out.write((v &gt;&gt;&gt;  8) &amp; 0xFF);
199         out.write((v &gt;&gt;&gt;  0) &amp; 0xFF);
200         incCount(4);
201     }
202 
203     private byte writeBuffer[] = new byte[8];
204 
205     /**
<span class="line-modified">206      * Writes a {@code long} to the underlying output stream as eight</span>
207      * bytes, high byte first. In no exception is thrown, the counter
<span class="line-modified">208      * {@code written} is incremented by {@code 8}.</span>
209      *
<span class="line-modified">210      * @param      v   a {@code long} to be written.</span>
<span class="line-modified">211      * @throws     IOException  if an I/O error occurs.</span>
212      * @see        java.io.FilterOutputStream#out
213      */
214     public final void writeLong(long v) throws IOException {
215         writeBuffer[0] = (byte)(v &gt;&gt;&gt; 56);
216         writeBuffer[1] = (byte)(v &gt;&gt;&gt; 48);
217         writeBuffer[2] = (byte)(v &gt;&gt;&gt; 40);
218         writeBuffer[3] = (byte)(v &gt;&gt;&gt; 32);
219         writeBuffer[4] = (byte)(v &gt;&gt;&gt; 24);
220         writeBuffer[5] = (byte)(v &gt;&gt;&gt; 16);
221         writeBuffer[6] = (byte)(v &gt;&gt;&gt;  8);
222         writeBuffer[7] = (byte)(v &gt;&gt;&gt;  0);
223         out.write(writeBuffer, 0, 8);
224         incCount(8);
225     }
226 
227     /**
<span class="line-modified">228      * Converts the float argument to an {@code int} using the</span>
<span class="line-modified">229      * {@code floatToIntBits} method in class {@code Float},</span>
<span class="line-modified">230      * and then writes that {@code int} value to the underlying</span>
231      * output stream as a 4-byte quantity, high byte first. If no
<span class="line-modified">232      * exception is thrown, the counter {@code written} is</span>
<span class="line-modified">233      * incremented by {@code 4}.</span>
234      *
<span class="line-modified">235      * @param      v   a {@code float} value to be written.</span>
<span class="line-modified">236      * @throws     IOException  if an I/O error occurs.</span>
237      * @see        java.io.FilterOutputStream#out
238      * @see        java.lang.Float#floatToIntBits(float)
239      */
240     public final void writeFloat(float v) throws IOException {
241         writeInt(Float.floatToIntBits(v));
242     }
243 
244     /**
<span class="line-modified">245      * Converts the double argument to a {@code long} using the</span>
<span class="line-modified">246      * {@code doubleToLongBits} method in class {@code Double},</span>
<span class="line-modified">247      * and then writes that {@code long} value to the underlying</span>
248      * output stream as an 8-byte quantity, high byte first. If no
<span class="line-modified">249      * exception is thrown, the counter {@code written} is</span>
<span class="line-modified">250      * incremented by {@code 8}.</span>
251      *
<span class="line-modified">252      * @param      v   a {@code double} value to be written.</span>
<span class="line-modified">253      * @throws     IOException  if an I/O error occurs.</span>
254      * @see        java.io.FilterOutputStream#out
255      * @see        java.lang.Double#doubleToLongBits(double)
256      */
257     public final void writeDouble(double v) throws IOException {
258         writeLong(Double.doubleToLongBits(v));
259     }
260 
261     /**
262      * Writes out the string to the underlying output stream as a
263      * sequence of bytes. Each character in the string is written out, in
264      * sequence, by discarding its high eight bits. If no exception is
<span class="line-modified">265      * thrown, the counter {@code written} is incremented by the</span>
<span class="line-modified">266      * length of {@code s}.</span>
267      *
268      * @param      s   a string of bytes to be written.
<span class="line-modified">269      * @throws     IOException  if an I/O error occurs.</span>
270      * @see        java.io.FilterOutputStream#out
271      */
272     public final void writeBytes(String s) throws IOException {
273         int len = s.length();
274         for (int i = 0 ; i &lt; len ; i++) {
275             out.write((byte)s.charAt(i));
276         }
277         incCount(len);
278     }
279 
280     /**
281      * Writes a string to the underlying output stream as a sequence of
282      * characters. Each character is written to the data output stream as
<span class="line-modified">283      * if by the {@code writeChar} method. If no exception is</span>
<span class="line-modified">284      * thrown, the counter {@code written} is incremented by twice</span>
<span class="line-modified">285      * the length of {@code s}.</span>
286      *
<span class="line-modified">287      * @param      s   a {@code String} value to be written.</span>
<span class="line-modified">288      * @throws     IOException  if an I/O error occurs.</span>
289      * @see        java.io.DataOutputStream#writeChar(int)
290      * @see        java.io.FilterOutputStream#out
291      */
292     public final void writeChars(String s) throws IOException {
293         int len = s.length();
294         for (int i = 0 ; i &lt; len ; i++) {
295             int v = s.charAt(i);
296             out.write((v &gt;&gt;&gt; 8) &amp; 0xFF);
297             out.write((v &gt;&gt;&gt; 0) &amp; 0xFF);
298         }
299         incCount(len * 2);
300     }
301 
302     /**
303      * Writes a string to the underlying output stream using
304      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
305      * encoding in a machine-independent manner.
306      * &lt;p&gt;
307      * First, two bytes are written to the output stream as if by the
<span class="line-modified">308      * {@code writeShort} method giving the number of bytes to</span>
309      * follow. This value is the number of bytes actually written out,
310      * not the length of the string. Following the length, each character
311      * of the string is output, in sequence, using the modified UTF-8 encoding
312      * for the character. If no exception is thrown, the counter
<span class="line-modified">313      * {@code written} is incremented by the total number of</span>
314      * bytes written to the output stream. This will be at least two
<span class="line-modified">315      * plus the length of {@code str}, and at most two plus</span>
<span class="line-modified">316      * thrice the length of {@code str}.</span>
317      *
318      * @param      str   a string to be written.
<span class="line-modified">319      * @throws     UTFDataFormatException  if the modified UTF-8 encoding of</span>
<span class="line-added">320      *             {@code str} would exceed 65535 bytes in length</span>
<span class="line-added">321      * @throws     IOException  if some other I/O error occurs.</span>
<span class="line-added">322      * @see        #writeChars(String)</span>
323      */
324     public final void writeUTF(String str) throws IOException {
325         writeUTF(str, this);
326     }
327 
328     /**
329      * Writes a string to the specified DataOutput using
330      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
331      * encoding in a machine-independent manner.
332      * &lt;p&gt;
<span class="line-modified">333      * First, two bytes are written to out as if by the {@code writeShort}</span>
334      * method giving the number of bytes to follow. This value is the number of
335      * bytes actually written out, not the length of the string. Following the
336      * length, each character of the string is output, in sequence, using the
337      * modified UTF-8 encoding for the character. If no exception is thrown, the
<span class="line-modified">338      * counter {@code written} is incremented by the total number of</span>
339      * bytes written to the output stream. This will be at least two
<span class="line-modified">340      * plus the length of {@code str}, and at most two plus</span>
<span class="line-modified">341      * thrice the length of {@code str}.</span>
342      *
343      * @param      str   a string to be written.
344      * @param      out   destination to write to
345      * @return     The number of bytes written out.
<span class="line-modified">346      * @throws     UTFDataFormatException  if the modified UTF-8 encoding of</span>
<span class="line-added">347      *             {@code str} would exceed 65535 bytes in length</span>
<span class="line-added">348      * @throws     IOException  if some other I/O error occurs.</span>
349      */
350     static int writeUTF(String str, DataOutput out) throws IOException {
<span class="line-modified">351         final int strlen = str.length();</span>
<span class="line-modified">352         int utflen = strlen; // optimized for ASCII</span>

353 

354         for (int i = 0; i &lt; strlen; i++) {
<span class="line-modified">355             int c = str.charAt(i);</span>
<span class="line-modified">356             if (c &gt;= 0x80 || c == 0)</span>
<span class="line-modified">357                 utflen += (c &gt;= 0x800) ? 2 : 1;</span>





358         }
359 
<span class="line-modified">360         if (utflen &gt; 65535 || /* overflow */ utflen &lt; strlen)</span>
<span class="line-modified">361             throw new UTFDataFormatException(tooLongMsg(str, utflen));</span>

362 
<span class="line-modified">363         final byte[] bytearr;</span>
364         if (out instanceof DataOutputStream) {
365             DataOutputStream dos = (DataOutputStream)out;
<span class="line-modified">366             if (dos.bytearr == null || (dos.bytearr.length &lt; (utflen + 2)))</span>
367                 dos.bytearr = new byte[(utflen*2) + 2];
368             bytearr = dos.bytearr;
369         } else {
<span class="line-modified">370             bytearr = new byte[utflen + 2];</span>
371         }
372 
<span class="line-added">373         int count = 0;</span>
374         bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 8) &amp; 0xFF);
375         bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 0) &amp; 0xFF);
376 
<span class="line-modified">377         int i = 0;</span>
<span class="line-modified">378         for (i = 0; i &lt; strlen; i++) { // optimized for initial run of ASCII</span>
<span class="line-modified">379             int c = str.charAt(i);</span>
<span class="line-modified">380             if (c &gt;= 0x80 || c == 0) break;</span>
<span class="line-modified">381             bytearr[count++] = (byte) c;</span>
382         }
383 
<span class="line-modified">384         for (; i &lt; strlen; i++) {</span>
<span class="line-modified">385             int c = str.charAt(i);</span>
<span class="line-modified">386             if (c &lt; 0x80 &amp;&amp; c != 0) {</span>
387                 bytearr[count++] = (byte) c;
<span class="line-modified">388             } else if (c &gt;= 0x800) {</span>

389                 bytearr[count++] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
390                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  6) &amp; 0x3F));
391                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
392             } else {
393                 bytearr[count++] = (byte) (0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));
394                 bytearr[count++] = (byte) (0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
395             }
396         }
<span class="line-modified">397         out.write(bytearr, 0, utflen + 2);</span>
398         return utflen + 2;
399     }
400 
<span class="line-added">401     private static String tooLongMsg(String s, int bits32) {</span>
<span class="line-added">402         int slen = s.length();</span>
<span class="line-added">403         String head = s.substring(0, 8);</span>
<span class="line-added">404         String tail = s.substring(slen - 8, slen);</span>
<span class="line-added">405         // handle int overflow with max 3x expansion</span>
<span class="line-added">406         long actualLength = (long)slen + Integer.toUnsignedLong(bits32 - slen);</span>
<span class="line-added">407         return &quot;encoded string (&quot; + head + &quot;...&quot; + tail + &quot;) too long: &quot;</span>
<span class="line-added">408             + actualLength + &quot; bytes&quot;;</span>
<span class="line-added">409     }</span>
<span class="line-added">410 </span>
411     /**
<span class="line-modified">412      * Returns the current value of the counter {@code written},</span>
413      * the number of bytes written to this data output stream so far.
414      * If the counter overflows, it will be wrapped to Integer.MAX_VALUE.
415      *
<span class="line-modified">416      * @return  the value of the {@code written} field.</span>
417      * @see     java.io.DataOutputStream#written
418      */
419     public final int size() {
420         return written;
421     }
422 }
</pre>
</td>
</tr>
</table>
<center><a href="DataOutput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="EOFException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
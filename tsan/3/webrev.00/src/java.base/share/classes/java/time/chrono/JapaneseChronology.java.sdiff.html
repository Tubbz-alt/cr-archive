<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/time/chrono/JapaneseChronology.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoChronology.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JapaneseDate.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/time/chrono/JapaneseChronology.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
118  * This class is immutable and thread-safe.
119  *
120  * @since 1.8
121  */
122 public final class JapaneseChronology extends AbstractChronology implements Serializable {
123 
124     static final LocalGregorianCalendar JCAL =
125         (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);
126 
127     // Locale for creating a JapaneseImpericalCalendar.
128     static final Locale LOCALE = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);
129 
130     /**
131      * Singleton instance for Japanese chronology.
132      */
133     public static final JapaneseChronology INSTANCE = new JapaneseChronology();
134 
135     /**
136      * Serialization version.
137      */

138     private static final long serialVersionUID = 459996390165777884L;
139 
140     //-----------------------------------------------------------------------
141     /**
142      * Restricted constructor.
143      */
144     private JapaneseChronology() {
145     }
146 
147     //-----------------------------------------------------------------------
148     /**
149      * Gets the ID of the chronology - &#39;Japanese&#39;.
150      * &lt;p&gt;
151      * The ID uniquely identifies the {@code Chronology}.
152      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
153      *
154      * @return the chronology ID - &#39;Japanese&#39;
155      * @see #getCalendarType()
156      */
157     @Override
</pre>
<hr />
<pre>
346         }
347 
348         JapaneseEra jera = (JapaneseEra) era;
349         int gregorianYear = jera.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;
350         if (yearOfEra == 1) {
351             return gregorianYear;
352         }
353         if (gregorianYear &gt;= Year.MIN_VALUE &amp;&amp; gregorianYear &lt;= Year.MAX_VALUE) {
354             LocalGregorianCalendar.Date jdate = JCAL.newCalendarDate(null);
355             jdate.setEra(jera.getPrivateEra()).setDate(yearOfEra, 1, 1);
356             if (JapaneseChronology.JCAL.validate(jdate)) {
357                 return gregorianYear;
358             }
359         }
360         throw new DateTimeException(&quot;Invalid yearOfEra value&quot;);
361     }
362 
363     /**
364      * Returns the calendar system era object from the given numeric value.
365      *
<span class="line-modified">366      * See the description of each Era for the numeric values of:</span>
<span class="line-modified">367      * {@link JapaneseEra#HEISEI}, {@link JapaneseEra#SHOWA},{@link JapaneseEra#TAISHO},</span>
<span class="line-removed">368      * {@link JapaneseEra#MEIJI}), only Meiji and later eras are supported.</span>
369      *
370      * @param eraValue  the era value
371      * @return the Japanese {@code Era} for the given numeric era value
372      * @throws DateTimeException if {@code eraValue} is invalid
373      */
374     @Override
375     public JapaneseEra eraOf(int eraValue) {
376         return JapaneseEra.of(eraValue);
377     }
378 
379     @Override
380     public List&lt;Era&gt; eras() {
381         return List.of(JapaneseEra.values());
382     }
383 
384     JapaneseEra getCurrentEra() {
385         // Assume that the last JapaneseEra is the current one.
386         JapaneseEra[] eras = JapaneseEra.values();
387         return eras[eras.length - 1];
388     }
</pre>
<hr />
<pre>
500             long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);
501             return dateYearDay(y, 1).plus(days, DAYS);
502         }
503         int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);
504         return dateYearDay(era, yoe, doy);  // smart is same as strict
505     }
506 
507     //-----------------------------------------------------------------------
508     /**
509      * Writes the Chronology using a
510      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
511      * @serialData
512      * &lt;pre&gt;
513      *  out.writeByte(1);     // identifies a Chronology
514      *  out.writeUTF(getId());
515      * &lt;/pre&gt;
516      *
517      * @return the instance of {@code Ser}, not null
518      */
519     @Override

520     Object writeReplace() {
521         return super.writeReplace();
522     }
523 
524     /**
525      * Defend against malicious streams.
526      *
527      * @param s the stream to read
528      * @throws InvalidObjectException always
529      */

530     private void readObject(ObjectInputStream s) throws InvalidObjectException {
531         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
532     }
533 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
118  * This class is immutable and thread-safe.
119  *
120  * @since 1.8
121  */
122 public final class JapaneseChronology extends AbstractChronology implements Serializable {
123 
124     static final LocalGregorianCalendar JCAL =
125         (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);
126 
127     // Locale for creating a JapaneseImpericalCalendar.
128     static final Locale LOCALE = Locale.forLanguageTag(&quot;ja-JP-u-ca-japanese&quot;);
129 
130     /**
131      * Singleton instance for Japanese chronology.
132      */
133     public static final JapaneseChronology INSTANCE = new JapaneseChronology();
134 
135     /**
136      * Serialization version.
137      */
<span class="line-added">138     @java.io.Serial</span>
139     private static final long serialVersionUID = 459996390165777884L;
140 
141     //-----------------------------------------------------------------------
142     /**
143      * Restricted constructor.
144      */
145     private JapaneseChronology() {
146     }
147 
148     //-----------------------------------------------------------------------
149     /**
150      * Gets the ID of the chronology - &#39;Japanese&#39;.
151      * &lt;p&gt;
152      * The ID uniquely identifies the {@code Chronology}.
153      * It can be used to lookup the {@code Chronology} using {@link Chronology#of(String)}.
154      *
155      * @return the chronology ID - &#39;Japanese&#39;
156      * @see #getCalendarType()
157      */
158     @Override
</pre>
<hr />
<pre>
347         }
348 
349         JapaneseEra jera = (JapaneseEra) era;
350         int gregorianYear = jera.getPrivateEra().getSinceDate().getYear() + yearOfEra - 1;
351         if (yearOfEra == 1) {
352             return gregorianYear;
353         }
354         if (gregorianYear &gt;= Year.MIN_VALUE &amp;&amp; gregorianYear &lt;= Year.MAX_VALUE) {
355             LocalGregorianCalendar.Date jdate = JCAL.newCalendarDate(null);
356             jdate.setEra(jera.getPrivateEra()).setDate(yearOfEra, 1, 1);
357             if (JapaneseChronology.JCAL.validate(jdate)) {
358                 return gregorianYear;
359             }
360         }
361         throw new DateTimeException(&quot;Invalid yearOfEra value&quot;);
362     }
363 
364     /**
365      * Returns the calendar system era object from the given numeric value.
366      *
<span class="line-modified">367      * The numeric values supported by this method are the same as the</span>
<span class="line-modified">368      * numeric values supported by {@link JapaneseEra#of(int)}.</span>

369      *
370      * @param eraValue  the era value
371      * @return the Japanese {@code Era} for the given numeric era value
372      * @throws DateTimeException if {@code eraValue} is invalid
373      */
374     @Override
375     public JapaneseEra eraOf(int eraValue) {
376         return JapaneseEra.of(eraValue);
377     }
378 
379     @Override
380     public List&lt;Era&gt; eras() {
381         return List.of(JapaneseEra.values());
382     }
383 
384     JapaneseEra getCurrentEra() {
385         // Assume that the last JapaneseEra is the current one.
386         JapaneseEra[] eras = JapaneseEra.values();
387         return eras[eras.length - 1];
388     }
</pre>
<hr />
<pre>
500             long days = Math.subtractExact(fieldValues.remove(DAY_OF_YEAR), 1);
501             return dateYearDay(y, 1).plus(days, DAYS);
502         }
503         int doy = range(DAY_OF_YEAR).checkValidIntValue(fieldValues.remove(DAY_OF_YEAR), DAY_OF_YEAR);
504         return dateYearDay(era, yoe, doy);  // smart is same as strict
505     }
506 
507     //-----------------------------------------------------------------------
508     /**
509      * Writes the Chronology using a
510      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
511      * @serialData
512      * &lt;pre&gt;
513      *  out.writeByte(1);     // identifies a Chronology
514      *  out.writeUTF(getId());
515      * &lt;/pre&gt;
516      *
517      * @return the instance of {@code Ser}, not null
518      */
519     @Override
<span class="line-added">520     @java.io.Serial</span>
521     Object writeReplace() {
522         return super.writeReplace();
523     }
524 
525     /**
526      * Defend against malicious streams.
527      *
528      * @param s the stream to read
529      * @throws InvalidObjectException always
530      */
<span class="line-added">531     @java.io.Serial</span>
532     private void readObject(ObjectInputStream s) throws InvalidObjectException {
533         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
534     }
535 }
</pre>
</td>
</tr>
</table>
<center><a href="IsoChronology.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JapaneseDate.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
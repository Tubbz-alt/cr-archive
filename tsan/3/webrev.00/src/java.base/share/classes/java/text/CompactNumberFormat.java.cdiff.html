<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/CompactNumberFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Collator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormat.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/CompactNumberFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,15 ***</span>
<span class="line-new-header">--- 30,21 ---</span>
  import java.math.BigDecimal;
  import java.math.BigInteger;
  import java.math.RoundingMode;
  import java.util.ArrayList;
  import java.util.Arrays;
<span class="line-added">+ import java.util.HashMap;</span>
  import java.util.List;
  import java.util.Locale;
<span class="line-added">+ import java.util.Map;</span>
  import java.util.Objects;
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
<span class="line-added">+ import java.util.regex.Matcher;</span>
<span class="line-added">+ import java.util.regex.Pattern;</span>
<span class="line-added">+ import java.util.stream.Collectors;</span>
<span class="line-added">+ import java.util.stream.Stream;</span>
  
  
  /**
   * &lt;p&gt;
   * {@code CompactNumberFormat} is a concrete subclass of {@code NumberFormat}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,11 ***</span>
   * NumberFormat fmt = NumberFormat.getCompactNumberInstance(
   *                             new Locale(&quot;hi&quot;, &quot;IN&quot;), NumberFormat.Style.SHORT);
   * String result = fmt.format(1000);
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;compact_number_style&quot;&gt;Style&lt;/a&gt;&lt;/h3&gt;</span>
   * &lt;p&gt;
   * A number can be formatted in the compact forms with two different
   * styles, {@link NumberFormat.Style#SHORT SHORT}
   * and {@link NumberFormat.Style#LONG LONG}. Use
   * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and
<span class="line-new-header">--- 77,11 ---</span>
   * NumberFormat fmt = NumberFormat.getCompactNumberInstance(
   *                             new Locale(&quot;hi&quot;, &quot;IN&quot;), NumberFormat.Style.SHORT);
   * String result = fmt.format(1000);
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;compact_number_style&quot;&gt;Style&lt;/a&gt;&lt;/h2&gt;</span>
   * &lt;p&gt;
   * A number can be formatted in the compact forms with two different
   * styles, {@link NumberFormat.Style#SHORT SHORT}
   * and {@link NumberFormat.Style#LONG LONG}. Use
   * {@link NumberFormat#getCompactNumberInstance(Locale, Style)} for formatting and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,11 ***</span>
   * compact number instance in the {@link java.util.Locale#US US locale} formats
   * {@code 10000} as {@code &quot;10K&quot;}. However, a
   * {@link NumberFormat.Style#LONG LONG} style instance in same locale
   * formats {@code 10000} as {@code &quot;10 thousand&quot;}.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;compact_number_patterns&quot;&gt;Compact Number Patterns&lt;/a&gt;&lt;/h3&gt;</span>
   * &lt;p&gt;
   * The compact number patterns are represented in a series of patterns where each
   * pattern is used to format a range of numbers. An example of
   * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns
   * for the {@link java.util.Locale#US US locale} is {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;,
<span class="line-new-header">--- 92,11 ---</span>
   * compact number instance in the {@link java.util.Locale#US US locale} formats
   * {@code 10000} as {@code &quot;10K&quot;}. However, a
   * {@link NumberFormat.Style#LONG LONG} style instance in same locale
   * formats {@code 10000} as {@code &quot;10 thousand&quot;}.
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;compact_number_patterns&quot;&gt;Compact Number Patterns&lt;/a&gt;&lt;/h2&gt;</span>
   * &lt;p&gt;
   * The compact number patterns are represented in a series of patterns where each
   * pattern is used to format a range of numbers. An example of
   * {@link NumberFormat.Style#SHORT SHORT} styled compact number patterns
   * for the {@link java.util.Locale#US US locale} is {@code {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;0K&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,31 ***</span>
   * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 2}&lt;/sup&gt; are empty
   * strings, which implicitly means a special pattern {@code &quot;0&quot;}.
   * A special pattern {@code &quot;0&quot;} is used for any range which does not contain
   * a compact pattern. This special pattern can appear explicitly for any specific
   * range, or considered as a default pattern for an empty string.
<span class="line-removed">-  * &lt;p&gt;</span>
<span class="line-removed">-  * A compact pattern has the following syntax:</span>
<span class="line-removed">-  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-removed">-  * &lt;i&gt;Pattern:&lt;/i&gt;</span>
<span class="line-removed">-  *         &lt;i&gt;PositivePattern&lt;/i&gt;</span>
<span class="line-removed">-  *         &lt;i&gt;PositivePattern&lt;/i&gt; &lt;i&gt;[; NegativePattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed">-  * &lt;i&gt;PositivePattern:&lt;/i&gt;</span>
<span class="line-removed">-  *         &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed">-  * &lt;i&gt;NegativePattern:&lt;/i&gt;</span>
<span class="line-removed">-  *        &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-removed">-  * &lt;i&gt;Prefix:&lt;/i&gt;</span>
<span class="line-removed">-  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-removed">-  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;</span>
<span class="line-removed">-  * &lt;i&gt;Suffix:&lt;/i&gt;</span>
<span class="line-removed">-  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-removed">-  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;</span>
<span class="line-removed">-  * &lt;i&gt;MinimumInteger:&lt;/i&gt;</span>
<span class="line-removed">-  *      0</span>
<span class="line-removed">-  *      0 &lt;i&gt;MinimumInteger&lt;/i&gt;</span>
<span class="line-removed">-  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
   *
   * A compact pattern contains a positive and negative subpattern
   * separated by a subpattern boundary character {@code &#39;;&#39; (U+003B)},
   * for example, {@code &quot;0K;-0K&quot;}. Each subpattern has a prefix,
   * minimum integer digits, and suffix. The negative subpattern
   * is optional, if absent, then the positive subpattern prefixed with the
<span class="line-new-header">--- 112,12 ---</span>
   * {@code 10}&lt;sup&gt;{@code 0}&lt;/sup&gt;-{@code 10}&lt;sup&gt;{@code 2}&lt;/sup&gt; are empty
   * strings, which implicitly means a special pattern {@code &quot;0&quot;}.
   * A special pattern {@code &quot;0&quot;} is used for any range which does not contain
   * a compact pattern. This special pattern can appear explicitly for any specific
   * range, or considered as a default pattern for an empty string.
   *
<span class="line-added">+  * &lt;p&gt;</span>
   * A compact pattern contains a positive and negative subpattern
   * separated by a subpattern boundary character {@code &#39;;&#39; (U+003B)},
   * for example, {@code &quot;0K;-0K&quot;}. Each subpattern has a prefix,
   * minimum integer digits, and suffix. The negative subpattern
   * is optional, if absent, then the positive subpattern prefixed with the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,11 ***</span>
   * on the other hand, stand for other characters, strings, or classes of
   * characters. They must be quoted, using single quote {@code &#39; (U+0027)}
   * unless noted otherwise, if they are to appear in the prefix or suffix
   * as literals. For example, 0\u0915&#39;.&#39;.
   *
<span class="line-modified">!  * &lt;h3&gt;Formatting&lt;/h3&gt;</span>
   * The default formatting behavior returns a formatted string with no fractional
   * digits, however users can use the {@link #setMinimumFractionDigits(int)}
   * method to include the fractional part.
   * The number {@code 1000.0} or {@code 1000} is formatted as {@code &quot;1K&quot;}
   * not {@code &quot;1.00K&quot;} (in the {@link java.util.Locale#US US locale}). For this
<span class="line-new-header">--- 136,53 ---</span>
   * on the other hand, stand for other characters, strings, or classes of
   * characters. They must be quoted, using single quote {@code &#39; (U+0027)}
   * unless noted otherwise, if they are to appear in the prefix or suffix
   * as literals. For example, 0\u0915&#39;.&#39;.
   *
<span class="line-modified">!  * &lt;h3&gt;Plurals&lt;/h3&gt;</span>
<span class="line-added">+  * &lt;p&gt;</span>
<span class="line-added">+  * In case some localization requires compact number patterns to be different for</span>
<span class="line-added">+  * plurals, each singular and plural pattern can be enumerated within a pair of</span>
<span class="line-added">+  * curly brackets &lt;code&gt;&#39;{&#39; (U+007B)&lt;/code&gt; and &lt;code&gt;&#39;}&#39; (U+007D)&lt;/code&gt;, separated</span>
<span class="line-added">+  * by a space {@code &#39; &#39; (U+0020)}. If this format is used, each pattern needs to be</span>
<span class="line-added">+  * prepended by its {@code count}, followed by a single colon {@code &#39;:&#39; (U+003A)}.</span>
<span class="line-added">+  * If the pattern includes spaces literally, they must be quoted.</span>
<span class="line-added">+  * &lt;p&gt;</span>
<span class="line-added">+  * For example, the compact number pattern representing millions in German locale can be</span>
<span class="line-added">+  * specified as {@code &quot;{one:0&#39; &#39;Million other:0&#39; &#39;Millionen}&quot;}. The {@code count}</span>
<span class="line-added">+  * follows LDML&#39;s</span>
<span class="line-added">+  * &lt;a href=&quot;https://unicode.org/reports/tr35/tr35-numbers.html#Language_Plural_Rules&quot;&gt;</span>
<span class="line-added">+  * Language Plural Rules&lt;/a&gt;.</span>
<span class="line-added">+  * &lt;p&gt;</span>
<span class="line-added">+  * A compact pattern has the following syntax:</span>
<span class="line-added">+  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">+  * &lt;i&gt;Pattern:&lt;/i&gt;</span>
<span class="line-added">+  *         &lt;i&gt;SimplePattern&lt;/i&gt;</span>
<span class="line-added">+  *         &#39;{&#39; &lt;i&gt;PluralPattern&lt;/i&gt; &lt;i&gt;[&#39; &#39; PluralPattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &#39;}&#39;</span>
<span class="line-added">+  * &lt;i&gt;SimplePattern:&lt;/i&gt;</span>
<span class="line-added">+  *         &lt;i&gt;PositivePattern&lt;/i&gt;</span>
<span class="line-added">+  *         &lt;i&gt;PositivePattern&lt;/i&gt; &lt;i&gt;[; NegativePattern]&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added">+  * &lt;i&gt;PluralPattern:&lt;/i&gt;</span>
<span class="line-added">+  *         &lt;i&gt;Count&lt;/i&gt;:&lt;i&gt;SimplePattern&lt;/i&gt;</span>
<span class="line-added">+  * &lt;i&gt;Count:&lt;/i&gt;</span>
<span class="line-added">+  *         &quot;zero&quot; / &quot;one&quot; / &quot;two&quot; / &quot;few&quot; / &quot;many&quot; / &quot;other&quot;</span>
<span class="line-added">+  * &lt;i&gt;PositivePattern:&lt;/i&gt;</span>
<span class="line-added">+  *         &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added">+  * &lt;i&gt;NegativePattern:&lt;/i&gt;</span>
<span class="line-added">+  *        &lt;i&gt;Prefix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;MinimumInteger&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;optional&lt;/sub&gt;&lt;/i&gt;</span>
<span class="line-added">+  * &lt;i&gt;Prefix:&lt;/i&gt;</span>
<span class="line-added">+  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-added">+  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;.</span>
<span class="line-added">+  * &lt;i&gt;Suffix:&lt;/i&gt;</span>
<span class="line-added">+  *      Any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and</span>
<span class="line-added">+  *      &lt;a href = &quot;DecimalFormat.html#special_pattern_character&quot;&gt;special characters&lt;/a&gt;.</span>
<span class="line-added">+  * &lt;i&gt;MinimumInteger:&lt;/i&gt;</span>
<span class="line-added">+  *      0</span>
<span class="line-added">+  *      0 &lt;i&gt;MinimumInteger&lt;/i&gt;</span>
<span class="line-added">+  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * &lt;h2&gt;Formatting&lt;/h2&gt;</span>
   * The default formatting behavior returns a formatted string with no fractional
   * digits, however users can use the {@link #setMinimumFractionDigits(int)}
   * method to include the fractional part.
   * The number {@code 1000.0} or {@code 1000} is formatted as {@code &quot;1K&quot;}
   * not {@code &quot;1.00K&quot;} (in the {@link java.util.Locale#US US locale}). For this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,18 ***</span>
   * selected for formatting a number is {@code &quot;0&quot;} (special pattern),
   * either explicit or defaulted, then the general number formatting provided by
   * {@link java.text.DecimalFormat DecimalFormat}
   * for the specified locale is used.
   *
<span class="line-modified">!  * &lt;h3&gt;Parsing&lt;/h3&gt;</span>
   * The default parsing behavior does not allow a grouping separator until
   * grouping used is set to {@code true} by using
   * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part
   * depends on the {@link #isParseIntegerOnly()}. For example, if the
   * parse integer only is set to true, then the fractional part is skipped.
   *
<span class="line-modified">!  * &lt;h3&gt;Rounding&lt;/h3&gt;</span>
   * {@code CompactNumberFormat} provides rounding modes defined in
   * {@link java.math.RoundingMode} for formatting.  By default, it uses
   * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
   *
   * @see CompactNumberFormat.Style
<span class="line-new-header">--- 192,18 ---</span>
   * selected for formatting a number is {@code &quot;0&quot;} (special pattern),
   * either explicit or defaulted, then the general number formatting provided by
   * {@link java.text.DecimalFormat DecimalFormat}
   * for the specified locale is used.
   *
<span class="line-modified">!  * &lt;h2&gt;Parsing&lt;/h2&gt;</span>
   * The default parsing behavior does not allow a grouping separator until
   * grouping used is set to {@code true} by using
   * {@link #setGroupingUsed(boolean)}. The parsing of the fractional part
   * depends on the {@link #isParseIntegerOnly()}. For example, if the
   * parse integer only is set to true, then the fractional part is skipped.
   *
<span class="line-modified">!  * &lt;h2&gt;Rounding&lt;/h2&gt;</span>
   * {@code CompactNumberFormat} provides rounding modes defined in
   * {@link java.math.RoundingMode} for formatting.  By default, it uses
   * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
   *
   * @see CompactNumberFormat.Style
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,10 ***</span>
<span class="line-new-header">--- 211,11 ---</span>
   * @see DecimalFormat
   * @since 12
   */
  public final class CompactNumberFormat extends NumberFormat {
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 7128367218649234678L;
  
      /**
       * The patterns for compact form of numbers for this
       * {@code CompactNumberFormat}. A possible example is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,29 ***</span>
  
      /**
       * List of positive prefix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;String&gt; positivePrefixPatterns;</span>
  
      /**
       * List of negative prefix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;String&gt; negativePrefixPatterns;</span>
  
      /**
       * List of positive suffix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;String&gt; positiveSuffixPatterns;</span>
  
      /**
       * List of negative suffix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;String&gt; negativeSuffixPatterns;</span>
  
      /**
       * List of divisors of this formatter&#39;s compact number patterns.
       * Divisor can be either Long or BigInteger (if the divisor value goes
       * beyond long boundary)
<span class="line-new-header">--- 234,29 ---</span>
  
      /**
       * List of positive prefix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;Patterns&gt; positivePrefixPatterns;</span>
  
      /**
       * List of negative prefix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;Patterns&gt; negativePrefixPatterns;</span>
  
      /**
       * List of positive suffix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;Patterns&gt; positiveSuffixPatterns;</span>
  
      /**
       * List of negative suffix patterns of this formatter&#39;s
       * compact number patterns.
       */
<span class="line-modified">!     private transient List&lt;Patterns&gt; negativeSuffixPatterns;</span>
  
      /**
       * List of divisors of this formatter&#39;s compact number patterns.
       * Divisor can be either Long or BigInteger (if the divisor value goes
       * beyond long boundary)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,10 ***</span>
<span class="line-new-header">--- 325,30 ---</span>
       *
       * @serial
       */
      private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * The {@code pluralRules} used in this compact number format.</span>
<span class="line-added">+      * {@code pluralRules} is a String designating plural rules which associate</span>
<span class="line-added">+      * the {@code Count} keyword, such as &quot;{@code one}&quot;, and the</span>
<span class="line-added">+      * actual integer number. Its syntax is defined in Unicode Consortium&#39;s</span>
<span class="line-added">+      * &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;</span>
<span class="line-added">+      * Plural rules syntax&lt;/a&gt;.</span>
<span class="line-added">+      * The default value is an empty string, meaning there is no plural rules.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @serial</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String pluralRules = &quot;&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The map for plural rules that maps LDML defined tags (e.g. &quot;one&quot;) to</span>
<span class="line-added">+      * its rule.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private transient Map&lt;String, String&gt; rulesMap;</span>
<span class="line-added">+ </span>
      /**
       * Special pattern used for compact numbers
       */
      private static final String SPECIAL_PATTERN = &quot;0&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,24 ***</span>
       * @param symbols the set of symbols to be used
       * @param compactPatterns an array of
       *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;
       *        compact number patterns&lt;/a&gt;
       * @throws NullPointerException if any of the given arguments is
<span class="line-modified">!      *                                 {@code null}</span>
       * @throws IllegalArgumentException if the given {@code decimalPattern} or the
<span class="line-modified">!      *                     {@code compactPatterns} array contains an invalid pattern</span>
<span class="line-modified">!      *                     or if a {@code null} appears in the array of compact</span>
<span class="line-modified">!      *                     patterns</span>
       * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)
       * @see DecimalFormatSymbols
       */
      public CompactNumberFormat(String decimalPattern,
<span class="line-modified">!             DecimalFormatSymbols symbols, String[] compactPatterns) {</span>
  
          Objects.requireNonNull(decimalPattern, &quot;decimalPattern&quot;);
          Objects.requireNonNull(symbols, &quot;symbols&quot;);
          Objects.requireNonNull(compactPatterns, &quot;compactPatterns&quot;);
  
          this.symbols = symbols;
          // Instantiating the DecimalFormat with &quot;0&quot; pattern; this acts just as a
          // basic pattern; the properties (For example, prefix/suffix)
          // are later computed based on the compact number formatting process.
<span class="line-new-header">--- 375,60 ---</span>
       * @param symbols the set of symbols to be used
       * @param compactPatterns an array of
       *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;
       *        compact number patterns&lt;/a&gt;
       * @throws NullPointerException if any of the given arguments is
<span class="line-modified">!      *       {@code null}</span>
       * @throws IllegalArgumentException if the given {@code decimalPattern} or the
<span class="line-modified">!      *       {@code compactPatterns} array contains an invalid pattern</span>
<span class="line-modified">!      *       or if a {@code null} appears in the array of compact</span>
<span class="line-modified">!      *       patterns</span>
<span class="line-added">+      * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)</span>
<span class="line-added">+      * @see DecimalFormatSymbols</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public CompactNumberFormat(String decimalPattern,</span>
<span class="line-added">+                                DecimalFormatSymbols symbols, String[] compactPatterns) {</span>
<span class="line-added">+         this(decimalPattern, symbols, compactPatterns, &quot;&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates a {@code CompactNumberFormat} using the given decimal pattern,</span>
<span class="line-added">+      * decimal format symbols, compact patterns, and plural rules.</span>
<span class="line-added">+      * To obtain the instance of {@code CompactNumberFormat} with the standard</span>
<span class="line-added">+      * compact patterns for a {@code Locale}, {@code Style}, and {@code pluralRules},</span>
<span class="line-added">+      * it is recommended to use the factory methods given by</span>
<span class="line-added">+      * {@code NumberFormat} for compact number formatting. For example,</span>
<span class="line-added">+      * {@link NumberFormat#getCompactNumberInstance(Locale, Style)}.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param decimalPattern a decimal pattern for general number formatting</span>
<span class="line-added">+      * @param symbols the set of symbols to be used</span>
<span class="line-added">+      * @param compactPatterns an array of</span>
<span class="line-added">+      *        &lt;a href = &quot;CompactNumberFormat.html#compact_number_patterns&quot;&gt;</span>
<span class="line-added">+      *        compact number patterns&lt;/a&gt;</span>
<span class="line-added">+      * @param pluralRules a String designating plural rules which associate</span>
<span class="line-added">+      *        the {@code Count} keyword, such as &quot;{@code one}&quot;, and the</span>
<span class="line-added">+      *        actual integer number. Its syntax is defined in Unicode Consortium&#39;s</span>
<span class="line-added">+      *        &lt;a href = &quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;</span>
<span class="line-added">+      *        Plural rules syntax&lt;/a&gt;</span>
<span class="line-added">+      * @throws NullPointerException if any of the given arguments is</span>
<span class="line-added">+      *        {@code null}</span>
<span class="line-added">+      * @throws IllegalArgumentException if the given {@code decimalPattern},</span>
<span class="line-added">+      *        the {@code compactPatterns} array contains an invalid pattern,</span>
<span class="line-added">+      *        a {@code null} appears in the array of compact patterns,</span>
<span class="line-added">+      *        or if the given {@code pluralRules} contains an invalid syntax</span>
       * @see DecimalFormat#DecimalFormat(java.lang.String, DecimalFormatSymbols)
       * @see DecimalFormatSymbols
<span class="line-added">+      * @since 14</span>
       */
      public CompactNumberFormat(String decimalPattern,
<span class="line-modified">!             DecimalFormatSymbols symbols, String[] compactPatterns,</span>
<span class="line-added">+             String pluralRules) {</span>
  
          Objects.requireNonNull(decimalPattern, &quot;decimalPattern&quot;);
          Objects.requireNonNull(symbols, &quot;symbols&quot;);
          Objects.requireNonNull(compactPatterns, &quot;compactPatterns&quot;);
<span class="line-added">+         Objects.requireNonNull(pluralRules, &quot;pluralRules&quot;);</span>
  
          this.symbols = symbols;
          // Instantiating the DecimalFormat with &quot;0&quot; pattern; this acts just as a
          // basic pattern; the properties (For example, prefix/suffix)
          // are later computed based on the compact number formatting process.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,10 ***</span>
<span class="line-new-header">--- 454,13 ---</span>
          // with no fraction digits
          this.decimalPattern = decimalPattern;
          defaultDecimalFormat = new DecimalFormat(this.decimalPattern,
                  this.symbols);
          defaultDecimalFormat.setMaximumFractionDigits(0);
<span class="line-added">+ </span>
<span class="line-added">+         this.pluralRules = pluralRules;</span>
<span class="line-added">+ </span>
          // Process compact patterns to extract the prefixes, suffixes and
          // divisors
          processCompactPatterns();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,18 ***</span>
          dList.set(isNegative, number, getMinimumFractionDigits());
  
          double roundedNumber = dList.getDouble();
          int compactDataIndex = selectCompactPattern((long) roundedNumber);
          if (compactDataIndex != -1) {
<span class="line-modified">!             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified">!             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positiveSuffixPatterns.get(compactDataIndex);</span>
  
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
<span class="line-removed">-                 long divisor = (Long) divisors.get(compactDataIndex);</span>
                  roundedNumber = roundedNumber / divisor;
                  decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());
                  decimalFormat.subformatNumber(result, delegate, isNegative,
                          false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
                          getMaximumFractionDigits(), getMinimumFractionDigits());
<span class="line-new-header">--- 580,17 ---</span>
          dList.set(isNegative, number, getMinimumFractionDigits());
  
          double roundedNumber = dList.getDouble();
          int compactDataIndex = selectCompactPattern((long) roundedNumber);
          if (compactDataIndex != -1) {
<span class="line-modified">!             long divisor = (Long) divisors.get(compactDataIndex);</span>
<span class="line-modified">!             int iPart = getIntegerPart(number, divisor);</span>
<span class="line-modified">!             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified">!             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
  
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
                  roundedNumber = roundedNumber / divisor;
                  decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());
                  decimalFormat.subformatNumber(result, delegate, isNegative,
                          false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
                          getMaximumFractionDigits(), getMinimumFractionDigits());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,17 ***</span>
              return format(bigIntegerValue, result, delegate, true);
          }
  
          int compactDataIndex = selectCompactPattern(number);
          if (compactDataIndex != -1) {
<span class="line-modified">!             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified">!             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positiveSuffixPatterns.get(compactDataIndex);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
<span class="line-removed">-                 long divisor = (Long) divisors.get(compactDataIndex);</span>
                  if ((number % divisor == 0)) {
                      number = number / divisor;
                      decimalFormat.setDigitList(number, isNegative, 0);
                      decimalFormat.subformatNumber(result, delegate,
                              isNegative, true, getMaximumIntegerDigits(),
<span class="line-new-header">--- 647,16 ---</span>
              return format(bigIntegerValue, result, delegate, true);
          }
  
          int compactDataIndex = selectCompactPattern(number);
          if (compactDataIndex != -1) {
<span class="line-modified">!             long divisor = (Long) divisors.get(compactDataIndex);</span>
<span class="line-modified">!             int iPart = getIntegerPart(number, divisor);</span>
<span class="line-modified">!             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified">!             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
                  if ((number % divisor == 0)) {
                      number = number / divisor;
                      decimalFormat.setDigitList(number, isNegative, 0);
                      decimalFormat.subformatNumber(result, delegate,
                              isNegative, true, getMaximumIntegerDigits(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,23 ***</span>
          // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
          number = number.setScale(getMinimumFractionDigits(), getRoundingMode());
  
          int compactDataIndex;
          if (number.toBigInteger().bitLength() &lt; 64) {
<span class="line-modified">!             compactDataIndex = selectCompactPattern(number.toBigInteger().longValue());</span>
          } else {
              compactDataIndex = selectCompactPattern(number.toBigInteger());
          }
  
          if (compactDataIndex != -1) {
<span class="line-modified">!             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified">!             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positiveSuffixPatterns.get(compactDataIndex);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
<span class="line-removed">-                 Number divisor = divisors.get(compactDataIndex);</span>
                  number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());
                  decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());
                  decimalFormat.subformatNumber(result, delegate, isNegative,
                          false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
                          getMaximumFractionDigits(), getMinimumFractionDigits());
<span class="line-new-header">--- 733,23 ---</span>
          // to 1000 and outputs 1K/thousand in &quot;en_US&quot; locale
          number = number.setScale(getMinimumFractionDigits(), getRoundingMode());
  
          int compactDataIndex;
          if (number.toBigInteger().bitLength() &lt; 64) {
<span class="line-modified">!             long longNumber = number.toBigInteger().longValue();</span>
<span class="line-added">+             compactDataIndex = selectCompactPattern(longNumber);</span>
          } else {
              compactDataIndex = selectCompactPattern(number.toBigInteger());
          }
  
          if (compactDataIndex != -1) {
<span class="line-modified">!             Number divisor = divisors.get(compactDataIndex);</span>
<span class="line-modified">!             int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());</span>
<span class="line-modified">!             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified">!             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
                  number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());
                  decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());
                  decimalFormat.subformatNumber(result, delegate, isNegative,
                          false, getMaximumIntegerDigits(), getMinimumIntegerDigits(),
                          getMaximumFractionDigits(), getMinimumFractionDigits());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 718,17 ***</span>
              number = number.negate();
          }
  
          int compactDataIndex = selectCompactPattern(number);
          if (compactDataIndex != -1) {
<span class="line-modified">!             String prefix = isNegative ? negativePrefixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positivePrefixPatterns.get(compactDataIndex);</span>
<span class="line-modified">!             String suffix = isNegative ? negativeSuffixPatterns.get(compactDataIndex)</span>
<span class="line-modified">!                     : positiveSuffixPatterns.get(compactDataIndex);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
<span class="line-removed">-                 Number divisor = divisors.get(compactDataIndex);</span>
                  if (number.mod(new BigInteger(divisor.toString()))
                          .compareTo(BigInteger.ZERO) == 0) {
                      number = number.divide(new BigInteger(divisor.toString()));
  
                      decimalFormat.setDigitList(number, isNegative, 0);
<span class="line-new-header">--- 805,16 ---</span>
              number = number.negate();
          }
  
          int compactDataIndex = selectCompactPattern(number);
          if (compactDataIndex != -1) {
<span class="line-modified">!             Number divisor = divisors.get(compactDataIndex);</span>
<span class="line-modified">!             int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());</span>
<span class="line-modified">!             String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);</span>
<span class="line-modified">!             String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);</span>
              if (!prefix.isEmpty() || !suffix.isEmpty()) {
                  appendPrefix(result, prefix, delegate);
                  if (number.mod(new BigInteger(divisor.toString()))
                          .compareTo(BigInteger.ZERO) == 0) {
                      number = number.divide(new BigInteger(divisor.toString()));
  
                      decimalFormat.setDigitList(number, isNegative, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,10 ***</span>
<span class="line-new-header">--- 844,22 ---</span>
              defaultDecimalFormat.format(number, result, delegate, formatLong);
          }
          return result;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Obtain the designated affix from the appropriate list of affixes,</span>
<span class="line-added">+      * based on the given arguments.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String getAffix(boolean isExpanded, boolean isPrefix, boolean isNegative, int compactDataIndex, int iPart) {</span>
<span class="line-added">+         return (isExpanded ? (isPrefix ? (isNegative ? negativePrefixes : positivePrefixes) :</span>
<span class="line-added">+                                          (isNegative ? negativeSuffixes : positiveSuffixes)) :</span>
<span class="line-added">+                              (isPrefix ? (isNegative ? negativePrefixPatterns : positivePrefixPatterns) :</span>
<span class="line-added">+                                          (isNegative ? negativeSuffixPatterns : positiveSuffixPatterns)))</span>
<span class="line-added">+                 .get(compactDataIndex).get(iPart);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Appends the {@code prefix} to the {@code result} and also set the
       * {@code NumberFormat.Field.SIGN} and {@code NumberFormat.Field.PREFIX}
       * field positions.
       * @param result the resulting string, where the pefix is to be appended
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,11 ***</span>
          for (int index = 0; index &lt; pattern.length();) {
              char ch = pattern.charAt(index++);
              if (ch == QUOTE) {
                  ch = pattern.charAt(index++);
                  if (ch == MINUS_SIGN) {
<span class="line-modified">!                     ch = symbols.getMinusSign();</span>
                  }
              }
              sb.append(ch);
          }
          return sb.toString();
<span class="line-new-header">--- 932,12 ---</span>
          for (int index = 0; index &lt; pattern.length();) {
              char ch = pattern.charAt(index++);
              if (ch == QUOTE) {
                  ch = pattern.charAt(index++);
                  if (ch == MINUS_SIGN) {
<span class="line-modified">!                     sb.append(symbols.getMinusSignText());</span>
<span class="line-added">+                     continue;</span>
                  }
              }
              sb.append(ch);
          }
          return sb.toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,15 ***</span>
          for (int index = 0; index &lt; pattern.length();) {
              char ch = pattern.charAt(index++);
              if (ch == QUOTE) {
                  ch = pattern.charAt(index++);
                  if (ch == MINUS_SIGN) {
<span class="line-modified">!                     ch = symbols.getMinusSign();</span>
                      FieldPosition fp = new FieldPosition(NumberFormat.Field.SIGN);
                      fp.setBeginIndex(stringIndex);
<span class="line-modified">!                     fp.setEndIndex(stringIndex + 1);</span>
                      positions.add(fp);
                  }
              }
              stringIndex++;
              affix.append(ch);
          }
<span class="line-new-header">--- 956,18 ---</span>
          for (int index = 0; index &lt; pattern.length();) {
              char ch = pattern.charAt(index++);
              if (ch == QUOTE) {
                  ch = pattern.charAt(index++);
                  if (ch == MINUS_SIGN) {
<span class="line-modified">!                     String minusText = symbols.getMinusSignText();</span>
                      FieldPosition fp = new FieldPosition(NumberFormat.Field.SIGN);
                      fp.setBeginIndex(stringIndex);
<span class="line-modified">!                     fp.setEndIndex(stringIndex + minusText.length());</span>
                      positions.add(fp);
<span class="line-added">+                     stringIndex += minusText.length();</span>
<span class="line-added">+                     affix.append(minusText);</span>
<span class="line-added">+                     continue;</span>
                  }
              }
              stringIndex++;
              affix.append(ch);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1035,30 ***</span>
       * Process the series of compact patterns to compute the
       * series of prefixes, suffixes and their respective divisor
       * value.
       *
       */
      private void processCompactPatterns() {
          int size = compactPatterns.length;
          positivePrefixPatterns = new ArrayList&lt;&gt;(size);
          negativePrefixPatterns = new ArrayList&lt;&gt;(size);
          positiveSuffixPatterns = new ArrayList&lt;&gt;(size);
          negativeSuffixPatterns = new ArrayList&lt;&gt;(size);
          divisors = new ArrayList&lt;&gt;(size);
  
          for (int index = 0; index &lt; size; index++) {
<span class="line-modified">!             applyPattern(compactPatterns[index], index);</span>
          }
      }
  
      /**
       * Process a compact pattern at a specific {@code index}
       * @param pattern the compact pattern to be processed
       * @param index index in the array of compact patterns
       *
       */
<span class="line-modified">!     private void applyPattern(String pattern, int index) {</span>
  
          if (pattern == null) {
              throw new IllegalArgumentException(&quot;A null compact pattern&quot; +
                      &quot; encountered at index: &quot; + index);
          }
<span class="line-new-header">--- 1137,106 ---</span>
       * Process the series of compact patterns to compute the
       * series of prefixes, suffixes and their respective divisor
       * value.
       *
       */
<span class="line-added">+     private static final Pattern PLURALS =</span>
<span class="line-added">+             Pattern.compile(&quot;^\\{(?&lt;plurals&gt;.*)\\}$&quot;);</span>
<span class="line-added">+     private static final Pattern COUNT_PATTERN =</span>
<span class="line-added">+             Pattern.compile(&quot;(zero|one|two|few|many|other):((&#39; &#39;|[^ ])+)[ ]*&quot;);</span>
      private void processCompactPatterns() {
          int size = compactPatterns.length;
          positivePrefixPatterns = new ArrayList&lt;&gt;(size);
          negativePrefixPatterns = new ArrayList&lt;&gt;(size);
          positiveSuffixPatterns = new ArrayList&lt;&gt;(size);
          negativeSuffixPatterns = new ArrayList&lt;&gt;(size);
          divisors = new ArrayList&lt;&gt;(size);
  
          for (int index = 0; index &lt; size; index++) {
<span class="line-modified">!             String text = compactPatterns[index];</span>
<span class="line-added">+             positivePrefixPatterns.add(new Patterns());</span>
<span class="line-added">+             negativePrefixPatterns.add(new Patterns());</span>
<span class="line-added">+             positiveSuffixPatterns.add(new Patterns());</span>
<span class="line-added">+             negativeSuffixPatterns.add(new Patterns());</span>
<span class="line-added">+ </span>
<span class="line-added">+             // check if it is the old style</span>
<span class="line-added">+             Matcher m = text != null ? PLURALS.matcher(text) : null;</span>
<span class="line-added">+             if (m != null &amp;&amp; m.matches()) {</span>
<span class="line-added">+                 final int idx = index;</span>
<span class="line-added">+                 String plurals = m.group(&quot;plurals&quot;);</span>
<span class="line-added">+                 COUNT_PATTERN.matcher(plurals).results()</span>
<span class="line-added">+                         .forEach(mr -&gt; applyPattern(mr.group(1), mr.group(2), idx));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 applyPattern(&quot;other&quot;, text, index);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         rulesMap = buildPluralRulesMap();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Build the plural rules map.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalArgumentException if the {@code pluralRules} has invalid syntax,</span>
<span class="line-added">+      *      or its length exceeds 2,048 chars</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private Map&lt;String, String&gt; buildPluralRulesMap() {</span>
<span class="line-added">+         // length limitation check. 2K for now.</span>
<span class="line-added">+         if (pluralRules.length() &gt; 2_048) {</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;plural rules is too long (&gt; 2,048)&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return Arrays.stream(pluralRules.split(&quot;;&quot;))</span>
<span class="line-added">+                 .map(this::validateRule)</span>
<span class="line-added">+                 .collect(Collectors.toMap(</span>
<span class="line-added">+                         r -&gt; r.replaceFirst(&quot;:.*&quot;, &quot;&quot;),</span>
<span class="line-added">+                         r -&gt; r.replaceFirst(&quot;[^:]+:&quot;, &quot;&quot;)</span>
<span class="line-added">+                 ));</span>
<span class="line-added">+         } catch (IllegalStateException ise) {</span>
<span class="line-added">+             throw new IllegalArgumentException(ise);</span>
          }
      }
  
<span class="line-added">+     // Patterns for plurals syntax validation</span>
<span class="line-added">+     private final static String EXPR = &quot;([niftvw]{1})\\s*(([/\\%])\\s*(\\d+))*&quot;;</span>
<span class="line-added">+     private final static String RELATION = &quot;(!{0,1}=)&quot;;</span>
<span class="line-added">+     private final static String VALUE_RANGE = &quot;((\\d+)\\.\\.(\\d+)|\\d+)&quot;;</span>
<span class="line-added">+     private final static String CONDITION = EXPR + &quot;\\s*&quot; +</span>
<span class="line-added">+                                              RELATION + &quot;\\s*&quot; +</span>
<span class="line-added">+                                              VALUE_RANGE + &quot;\\s*&quot; +</span>
<span class="line-added">+                                              &quot;(\\,\\s*&quot; + VALUE_RANGE + &quot;)*&quot;;</span>
<span class="line-added">+     private final static Pattern PLURALRULES_PATTERN =</span>
<span class="line-added">+             Pattern.compile(&quot;(zero|one|two|few|many):\\s*&quot; +</span>
<span class="line-added">+                             CONDITION +</span>
<span class="line-added">+                             &quot;(\\s*(and|or)\\s*&quot; + CONDITION + &quot;)*&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Validates a plural rule.</span>
<span class="line-added">+      * @param rule rule to validate</span>
<span class="line-added">+      * @throws IllegalArgumentException if the {@code rule} has invalid syntax</span>
<span class="line-added">+      * @return the input rule (trimmed)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String validateRule(String rule) {</span>
<span class="line-added">+         rule = rule.trim();</span>
<span class="line-added">+         if (!rule.isEmpty() &amp;&amp; !rule.equals(&quot;other:&quot;)) {</span>
<span class="line-added">+             Matcher validator = PLURALRULES_PATTERN.matcher(rule);</span>
<span class="line-added">+             if (!validator.matches()) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Invalid plural rules syntax: &quot; + rule);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return rule;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Process a compact pattern at a specific {@code index}
       * @param pattern the compact pattern to be processed
       * @param index index in the array of compact patterns
       *
       */
<span class="line-modified">!     private void applyPattern(String count, String pattern, int index) {</span>
  
          if (pattern == null) {
              throw new IllegalArgumentException(&quot;A null compact pattern&quot; +
                      &quot; encountered at index: &quot; + index);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,21 ***</span>
                      + &quot; placement 0s&quot;);
          }
  
          // Only if positive affix exists; else put empty strings
          if (!positivePrefix.isEmpty() || !positiveSuffix.isEmpty()) {
<span class="line-modified">!             positivePrefixPatterns.add(positivePrefix);</span>
<span class="line-modified">!             negativePrefixPatterns.add(negativePrefix);</span>
<span class="line-modified">!             positiveSuffixPatterns.add(positiveSuffix);</span>
<span class="line-modified">!             negativeSuffixPatterns.add(negativeSuffix);</span>
<span class="line-modified">!             divisors.add(computeDivisor(zeros, index));</span>
          } else {
<span class="line-modified">!             positivePrefixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">!             negativePrefixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">!             positiveSuffixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">!             negativeSuffixPatterns.add(&quot;&quot;);</span>
<span class="line-modified">!             divisors.add(1L);</span>
          }
      }
  
      private final transient DigitList digitList = new DigitList();
      private static final int STATUS_INFINITE = 0;
<span class="line-new-header">--- 1407,25 ---</span>
                      + &quot; placement 0s&quot;);
          }
  
          // Only if positive affix exists; else put empty strings
          if (!positivePrefix.isEmpty() || !positiveSuffix.isEmpty()) {
<span class="line-modified">!             positivePrefixPatterns.get(index).put(count, positivePrefix);</span>
<span class="line-modified">!             negativePrefixPatterns.get(index).put(count, negativePrefix);</span>
<span class="line-modified">!             positiveSuffixPatterns.get(index).put(count, positiveSuffix);</span>
<span class="line-modified">!             negativeSuffixPatterns.get(index).put(count, negativeSuffix);</span>
<span class="line-modified">!             if (divisors.size() &lt;= index) {</span>
<span class="line-added">+                 divisors.add(computeDivisor(zeros, index));</span>
<span class="line-added">+             }</span>
          } else {
<span class="line-modified">!             positivePrefixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">!             negativePrefixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">!             positiveSuffixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">!             negativeSuffixPatterns.get(index).put(count, &quot;&quot;);</span>
<span class="line-modified">!             if (divisors.size() &lt;= index) {</span>
<span class="line-added">+                 divisors.add(1L);</span>
<span class="line-added">+             }</span>
          }
      }
  
      private final transient DigitList digitList = new DigitList();
      private static final int STATUS_INFINITE = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1263,25 ***</span>
  
      // Expanded form of positive/negative prefix/suffix,
      // the expanded form contains special characters in
      // its localized form, which are used for matching
      // while parsing a string to number
<span class="line-modified">!     private transient List&lt;String&gt; positivePrefixes;</span>
<span class="line-modified">!     private transient List&lt;String&gt; negativePrefixes;</span>
<span class="line-modified">!     private transient List&lt;String&gt; positiveSuffixes;</span>
<span class="line-modified">!     private transient List&lt;String&gt; negativeSuffixes;</span>
  
      private void expandAffixPatterns() {
          positivePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
          negativePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
          positiveSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
          negativeSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
          for (int index = 0; index &lt; compactPatterns.length; index++) {
<span class="line-modified">!             positivePrefixes.add(expandAffix(positivePrefixPatterns.get(index)));</span>
<span class="line-modified">!             negativePrefixes.add(expandAffix(negativePrefixPatterns.get(index)));</span>
<span class="line-modified">!             positiveSuffixes.add(expandAffix(positiveSuffixPatterns.get(index)));</span>
<span class="line-modified">!             negativeSuffixes.add(expandAffix(negativeSuffixPatterns.get(index)));</span>
          }
      }
  
      /**
       * Parses a compact number from a string to produce a {@code Number}.
<span class="line-new-header">--- 1445,25 ---</span>
  
      // Expanded form of positive/negative prefix/suffix,
      // the expanded form contains special characters in
      // its localized form, which are used for matching
      // while parsing a string to number
<span class="line-modified">!     private transient List&lt;Patterns&gt; positivePrefixes;</span>
<span class="line-modified">!     private transient List&lt;Patterns&gt; negativePrefixes;</span>
<span class="line-modified">!     private transient List&lt;Patterns&gt; positiveSuffixes;</span>
<span class="line-modified">!     private transient List&lt;Patterns&gt; negativeSuffixes;</span>
  
      private void expandAffixPatterns() {
          positivePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
          negativePrefixes = new ArrayList&lt;&gt;(compactPatterns.length);
          positiveSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
          negativeSuffixes = new ArrayList&lt;&gt;(compactPatterns.length);
          for (int index = 0; index &lt; compactPatterns.length; index++) {
<span class="line-modified">!             positivePrefixes.add(positivePrefixPatterns.get(index).expandAffix());</span>
<span class="line-modified">!             negativePrefixes.add(negativePrefixPatterns.get(index).expandAffix());</span>
<span class="line-modified">!             positiveSuffixes.add(positiveSuffixPatterns.get(index).expandAffix());</span>
<span class="line-modified">!             negativeSuffixes.add(negativeSuffixPatterns.get(index).expandAffix());</span>
          }
      }
  
      /**
       * Parses a compact number from a string to produce a {@code Number}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1335,11 ***</span>
       *
       * @param text the string to be parsed
       * @param pos  a {@code ParsePosition} object with index and error
       *             index information as described above
       * @return the parsed value, or {@code null} if the parse fails
<span class="line-modified">!      * @exception  NullPointerException if {@code text} or</span>
       *             {@code pos} is null
       *
       */
      @Override
      public Number parse(String text, ParsePosition pos) {
<span class="line-new-header">--- 1517,11 ---</span>
       *
       * @param text the string to be parsed
       * @param pos  a {@code ParsePosition} object with index and error
       *             index information as described above
       * @return the parsed value, or {@code null} if the parse fails
<span class="line-modified">!      * @throws     NullPointerException if {@code text} or</span>
       *             {@code pos} is null
       *
       */
      @Override
      public Number parse(String text, ParsePosition pos) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1375,14 ***</span>
          int matchedNegIndex = -1;
          String matchedPosPrefix = &quot;&quot;;
          String matchedNegPrefix = &quot;&quot;;
          String defaultPosPrefix = defaultDecimalFormat.getPositivePrefix();
          String defaultNegPrefix = defaultDecimalFormat.getNegativePrefix();
          // Prefix matching
          for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">!             String positivePrefix = positivePrefixes.get(compactIndex);</span>
<span class="line-modified">!             String negativePrefix = negativePrefixes.get(compactIndex);</span>
  
              // Do not break if a match occur; there is a possibility that the
              // subsequent affixes may match the longer subsequence in the given
              // string.
              // For example, matching &quot;Mdx 3&quot; with &quot;M&quot;, &quot;Md&quot; as prefix should
<span class="line-new-header">--- 1557,16 ---</span>
          int matchedNegIndex = -1;
          String matchedPosPrefix = &quot;&quot;;
          String matchedNegPrefix = &quot;&quot;;
          String defaultPosPrefix = defaultDecimalFormat.getPositivePrefix();
          String defaultNegPrefix = defaultDecimalFormat.getNegativePrefix();
<span class="line-added">+         double num = parseNumberPart(text, position);</span>
<span class="line-added">+ </span>
          // Prefix matching
          for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">!             String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);</span>
<span class="line-modified">!             String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);</span>
  
              // Do not break if a match occur; there is a possibility that the
              // subsequent affixes may match the longer subsequence in the given
              // string.
              // For example, matching &quot;Mdx 3&quot; with &quot;M&quot;, &quot;Md&quot; as prefix should
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1480,11 ***</span>
          // Number parsed successfully; match prefix and
          // suffix to obtain multiplier
          pos.index = position;
          Number multiplier = computeParseMultiplier(text, pos,
                  gotPositive ? matchedPosPrefix : matchedNegPrefix,
<span class="line-modified">!                 status, gotPositive, gotNegative);</span>
  
          if (multiplier.longValue() == -1L) {
              return null;
          } else if (multiplier.longValue() != 1L) {
              cnfMultiplier = multiplier;
<span class="line-new-header">--- 1664,11 ---</span>
          // Number parsed successfully; match prefix and
          // suffix to obtain multiplier
          pos.index = position;
          Number multiplier = computeParseMultiplier(text, pos,
                  gotPositive ? matchedPosPrefix : matchedNegPrefix,
<span class="line-modified">!                 status, gotPositive, gotNegative, num);</span>
  
          if (multiplier.longValue() == -1L) {
              return null;
          } else if (multiplier.longValue() != 1L) {
              cnfMultiplier = multiplier;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1522,10 ***</span>
<span class="line-new-header">--- 1706,37 ---</span>
              }
              return cnfResult;
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Parse the number part in the input text into a number</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param text input text to be parsed</span>
<span class="line-added">+      * @param position starting position</span>
<span class="line-added">+      * @return the number</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static Pattern DIGITS = Pattern.compile(&quot;\\p{Nd}+&quot;);</span>
<span class="line-added">+     private double parseNumberPart(String text, int position) {</span>
<span class="line-added">+         if (text.startsWith(symbols.getInfinity(), position)) {</span>
<span class="line-added">+             return Double.POSITIVE_INFINITY;</span>
<span class="line-added">+         } else if (!text.startsWith(symbols.getNaN(), position)) {</span>
<span class="line-added">+             Matcher m = DIGITS.matcher(text);</span>
<span class="line-added">+             if (m.find(position)) {</span>
<span class="line-added">+                 String digits = m.group();</span>
<span class="line-added">+                 int cp = digits.codePointAt(0);</span>
<span class="line-added">+                 if (Character.isDigit(cp)) {</span>
<span class="line-added">+                     return Double.parseDouble(digits.codePoints()</span>
<span class="line-added">+                         .map(Character::getNumericValue)</span>
<span class="line-added">+                         .mapToObj(Integer::toString)</span>
<span class="line-added">+                         .collect(Collectors.joining()));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return Double.NaN;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the parsed result by multiplying the parsed number
       * with the multiplier representing the prefix and suffix.
       *
       * @param number parsed number component
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1657,24 ***</span>
       * @param gotNegative based on the prefix parsed; whether the number is negative
       * @return the multiplier matching the prefix and suffix; -1 otherwise
       */
      private Number computeParseMultiplier(String text, ParsePosition parsePosition,
              String matchedPrefix, boolean[] status, boolean gotPositive,
<span class="line-modified">!             boolean gotNegative) {</span>
  
          int position = parsePosition.index;
          boolean gotPos = false;
          boolean gotNeg = false;
          int matchedPosIndex = -1;
          int matchedNegIndex = -1;
          String matchedPosSuffix = &quot;&quot;;
          String matchedNegSuffix = &quot;&quot;;
          for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">!             String positivePrefix = positivePrefixes.get(compactIndex);</span>
<span class="line-modified">!             String negativePrefix = negativePrefixes.get(compactIndex);</span>
<span class="line-modified">!             String positiveSuffix = positiveSuffixes.get(compactIndex);</span>
<span class="line-modified">!             String negativeSuffix = negativeSuffixes.get(compactIndex);</span>
  
              // Do not break if a match occur; there is a possibility that the
              // subsequent affixes may match the longer subsequence in the given
              // string.
              // For example, matching &quot;3Mdx&quot; with &quot;M&quot;, &quot;Md&quot; should match with &quot;Md&quot;
<span class="line-new-header">--- 1868,24 ---</span>
       * @param gotNegative based on the prefix parsed; whether the number is negative
       * @return the multiplier matching the prefix and suffix; -1 otherwise
       */
      private Number computeParseMultiplier(String text, ParsePosition parsePosition,
              String matchedPrefix, boolean[] status, boolean gotPositive,
<span class="line-modified">!             boolean gotNegative, double num) {</span>
  
          int position = parsePosition.index;
          boolean gotPos = false;
          boolean gotNeg = false;
          int matchedPosIndex = -1;
          int matchedNegIndex = -1;
          String matchedPosSuffix = &quot;&quot;;
          String matchedNegSuffix = &quot;&quot;;
          for (int compactIndex = 0; compactIndex &lt; compactPatterns.length; compactIndex++) {
<span class="line-modified">!             String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);</span>
<span class="line-modified">!             String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);</span>
<span class="line-modified">!             String positiveSuffix = getAffix(true, false, false, compactIndex, (int)num);</span>
<span class="line-modified">!             String negativeSuffix = getAffix(true, false, true, compactIndex, (int)num);</span>
  
              // Do not break if a match occur; there is a possibility that the
              // subsequent affixes may match the longer subsequence in the given
              // string.
              // For example, matching &quot;3Mdx&quot; with &quot;M&quot;, &quot;Md&quot; should match with &quot;Md&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,16 ***</span>
<span class="line-new-header">--- 1983,19 ---</span>
       * negative. This check is performed by superclass&#39;s readObject.
       * &lt;li&gt; If the minimum or maximum integer digit count is larger than 309 or
       * if the minimum or maximum fraction digit count is larger than 340.
       * &lt;li&gt; If the grouping size is negative or larger than 127.
       * &lt;/ul&gt;
<span class="line-added">+      * If the {@code pluralRules} field is not deserialized from the stream, it</span>
<span class="line-added">+      * will be set to an empty string.</span>
       *
       * @param inStream the stream
       * @throws IOException if an I/O error occurs
       * @throws ClassNotFoundException if the class of a serialized object
       *         could not be found
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream inStream) throws IOException,
              ClassNotFoundException {
  
          inStream.defaultReadObject();
          if (decimalPattern == null || compactPatterns == null
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1802,10 ***</span>
<span class="line-new-header">--- 2016,15 ---</span>
          // put value &gt; 127, it wraps around, so check just negative value
          if (groupingSize &lt; 0) {
              throw new InvalidObjectException(&quot;Grouping size is negative&quot;);
          }
  
<span class="line-added">+         // pluralRules is since 14. Fill in empty string if it is null</span>
<span class="line-added">+         if (pluralRules == null) {</span>
<span class="line-added">+             pluralRules = &quot;&quot;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          try {
              processCompactPatterns();
          } catch (IllegalArgumentException ex) {
              throw new InvalidObjectException(ex.getMessage());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2103,10 ***</span>
<span class="line-new-header">--- 2322,11 ---</span>
          CompactNumberFormat other = (CompactNumberFormat) obj;
          return decimalPattern.equals(other.decimalPattern)
                  &amp;&amp; symbols.equals(other.symbols)
                  &amp;&amp; Arrays.equals(compactPatterns, other.compactPatterns)
                  &amp;&amp; roundingMode.equals(other.roundingMode)
<span class="line-added">+                 &amp;&amp; pluralRules.equals(other.pluralRules)</span>
                  &amp;&amp; groupingSize == other.groupingSize
                  &amp;&amp; parseBigDecimal == other.parseBigDecimal;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2115,11 ***</span>
       * @return hash code for this {@code CompactNumberFormat}
       */
      @Override
      public int hashCode() {
          return 31 * super.hashCode() +
<span class="line-modified">!                 Objects.hash(decimalPattern, symbols, roundingMode)</span>
                  + Arrays.hashCode(compactPatterns) + groupingSize
                  + Boolean.hashCode(parseBigDecimal);
      }
  
      /**
<span class="line-new-header">--- 2335,11 ---</span>
       * @return hash code for this {@code CompactNumberFormat}
       */
      @Override
      public int hashCode() {
          return 31 * super.hashCode() +
<span class="line-modified">!                 Objects.hash(decimalPattern, symbols, roundingMode, pluralRules)</span>
                  + Arrays.hashCode(compactPatterns) + groupingSize
                  + Boolean.hashCode(parseBigDecimal);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2134,7 ***</span>
          other.compactPatterns = compactPatterns.clone();
          other.symbols = (DecimalFormatSymbols) symbols.clone();
          return other;
      }
  
<span class="line-modified">! }</span>
  
<span class="line-new-header">--- 2354,157 ---</span>
          other.compactPatterns = compactPatterns.clone();
          other.symbols = (DecimalFormatSymbols) symbols.clone();
          return other;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Abstraction of affix patterns for each &quot;count&quot; tag.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final class Patterns {</span>
<span class="line-added">+         private Map&lt;String, String&gt; patternsMap = new HashMap&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+         void put(String count, String pattern) {</span>
<span class="line-added">+             patternsMap.put(count, pattern);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         String get(double num) {</span>
<span class="line-added">+             return patternsMap.getOrDefault(getPluralCategory(num),</span>
<span class="line-added">+                     patternsMap.getOrDefault(&quot;other&quot;, &quot;&quot;));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Patterns expandAffix() {</span>
<span class="line-added">+             Patterns ret = new Patterns();</span>
<span class="line-added">+             patternsMap.entrySet().stream()</span>
<span class="line-added">+                     .forEach(e -&gt; ret.put(e.getKey(), CompactNumberFormat.this.expandAffix(e.getValue())));</span>
<span class="line-added">+             return ret;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final int getIntegerPart(double number, double divisor) {</span>
<span class="line-added">+         return BigDecimal.valueOf(number)</span>
<span class="line-added">+                 .divide(BigDecimal.valueOf(divisor), roundingMode).intValue();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns LDML&#39;s tag from the plurals rules</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param input input number in double type</span>
<span class="line-added">+      * @return LDML &quot;count&quot; tag</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String getPluralCategory(double input) {</span>
<span class="line-added">+         if (rulesMap != null) {</span>
<span class="line-added">+             return rulesMap.entrySet().stream()</span>
<span class="line-added">+                     .filter(e -&gt; matchPluralRule(e.getValue(), input))</span>
<span class="line-added">+                     .map(e -&gt; e.getKey())</span>
<span class="line-added">+                     .findFirst()</span>
<span class="line-added">+                     .orElse(&quot;other&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // defaults to &quot;other&quot;</span>
<span class="line-added">+         return &quot;other&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static boolean matchPluralRule(String condition, double input) {</span>
<span class="line-added">+         return Arrays.stream(condition.split(&quot;or&quot;))</span>
<span class="line-added">+             .anyMatch(and_condition -&gt; {</span>
<span class="line-added">+                 return Arrays.stream(and_condition.split(&quot;and&quot;))</span>
<span class="line-added">+                     .allMatch(r -&gt; relationCheck(r, input));</span>
<span class="line-added">+             });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final static String NAMED_EXPR = &quot;(?&lt;op&gt;[niftvw]{1})\\s*((?&lt;div&gt;[/\\%])\\s*(?&lt;val&gt;\\d+))*&quot;;</span>
<span class="line-added">+     private final static String NAMED_RELATION = &quot;(?&lt;rel&gt;!{0,1}=)&quot;;</span>
<span class="line-added">+     private final static String NAMED_VALUE_RANGE = &quot;(?&lt;start&gt;\\d+)\\.\\.(?&lt;end&gt;\\d+)|(?&lt;value&gt;\\d+)&quot;;</span>
<span class="line-added">+     private final static Pattern EXPR_PATTERN = Pattern.compile(NAMED_EXPR);</span>
<span class="line-added">+     private final static Pattern RELATION_PATTERN = Pattern.compile(NAMED_RELATION);</span>
<span class="line-added">+     private final static Pattern VALUE_RANGE_PATTERN = Pattern.compile(NAMED_VALUE_RANGE);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Checks if the &#39;input&#39; equals the value, or within the range.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param valueOrRange A string representing either a single value or a range</span>
<span class="line-added">+      * @param input to examine in double</span>
<span class="line-added">+      * @return match indicator</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static boolean valOrRangeMatches(String valueOrRange, double input) {</span>
<span class="line-added">+         Matcher m = VALUE_RANGE_PATTERN.matcher(valueOrRange);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m.find()) {</span>
<span class="line-added">+             String value = m.group(&quot;value&quot;);</span>
<span class="line-added">+             if (value != null) {</span>
<span class="line-added">+                 return input == Double.parseDouble(value);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return input &gt;= Double.parseDouble(m.group(&quot;start&quot;)) &amp;&amp;</span>
<span class="line-added">+                        input &lt;= Double.parseDouble(m.group(&quot;end&quot;));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Checks if the input value satisfies the relation. Each possible value or range is</span>
<span class="line-added">+      * separated by a comma &#39;,&#39;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param relation relation string, e.g, &quot;n = 1, 3..5&quot;, or &quot;n != 1, 3..5&quot;</span>
<span class="line-added">+      * @param input value to examine in double</span>
<span class="line-added">+      * @return boolean to indicate whether the relation satisfies or not. If the relation</span>
<span class="line-added">+      *  is &#39;=&#39;, true if any of the possible value/range satisfies. If the relation is &#39;!=&#39;,</span>
<span class="line-added">+      *  none of the possible value/range should satisfy to return true.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static boolean relationCheck(String relation, double input) {</span>
<span class="line-added">+         Matcher expr = EXPR_PATTERN.matcher(relation);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (expr.find()) {</span>
<span class="line-added">+             double lop = evalLOperand(expr, input);</span>
<span class="line-added">+             Matcher rel = RELATION_PATTERN.matcher(relation);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (rel.find(expr.end())) {</span>
<span class="line-added">+                 var conditions =</span>
<span class="line-added">+                     Arrays.stream(relation.substring(rel.end()).split(&quot;,&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (rel.group(&quot;rel&quot;).equals(&quot;!=&quot;)) {</span>
<span class="line-added">+                     return conditions.noneMatch(c -&gt; valOrRangeMatches(c, lop));</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return conditions.anyMatch(c -&gt; valOrRangeMatches(c, lop));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Evaluates the left operand value.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param expr Match result</span>
<span class="line-added">+      * @param input value to examine in double</span>
<span class="line-added">+      * @return resulting double value</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static double evalLOperand(Matcher expr, double input) {</span>
<span class="line-added">+         double ret = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (input == Double.POSITIVE_INFINITY) {</span>
<span class="line-added">+             ret =input;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             String op = expr.group(&quot;op&quot;);</span>
<span class="line-added">+             if (op.equals(&quot;n&quot;) || op.equals(&quot;i&quot;)) {</span>
<span class="line-added">+                 ret = input;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             String divop = expr.group(&quot;div&quot;);</span>
<span class="line-added">+             if (divop != null) {</span>
<span class="line-added">+                 String divisor = expr.group(&quot;val&quot;);</span>
<span class="line-added">+                 switch (divop) {</span>
<span class="line-added">+                     case &quot;%&quot;:</span>
<span class="line-added">+                         ret %= Double.parseDouble(divisor);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case &quot;/&quot;:</span>
<span class="line-added">+                         ret /= Double.parseDouble(divisor);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return ret;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="Collator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormat.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
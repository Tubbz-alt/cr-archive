<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/Reader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="RandomAccessFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SequenceInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/Reader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
186     public int read(java.nio.CharBuffer target) throws IOException {
187         int len = target.remaining();
188         char[] cbuf = new char[len];
189         int n = read(cbuf, 0, len);
190         if (n &gt; 0)
191             target.put(cbuf, 0, n);
192         return n;
193     }
194 
195     /**
196      * Reads a single character.  This method will block until a character is
197      * available, an I/O error occurs, or the end of the stream is reached.
198      *
199      * &lt;p&gt; Subclasses that intend to support efficient single-character input
200      * should override this method.
201      *
202      * @return     The character read, as an integer in the range 0 to 65535
203      *             ({@code 0x00-0xffff}), or -1 if the end of the stream has
204      *             been reached
205      *
<span class="line-modified">206      * @exception  IOException  If an I/O error occurs</span>
207      */
208     public int read() throws IOException {
209         char cb[] = new char[1];
210         if (read(cb, 0, 1) == -1)
211             return -1;
212         else
213             return cb[0];
214     }
215 
216     /**
217      * Reads characters into an array.  This method will block until some input
218      * is available, an I/O error occurs, or the end of the stream is reached.
219      *
220      * @param       cbuf  Destination buffer
221      *
222      * @return      The number of characters read, or -1
223      *              if the end of the stream
224      *              has been reached
225      *
<span class="line-modified">226      * @exception   IOException  If an I/O error occurs</span>
227      */
228     public int read(char cbuf[]) throws IOException {
229         return read(cbuf, 0, cbuf.length);
230     }
231 
232     /**
233      * Reads characters into a portion of an array.  This method will block
234      * until some input is available, an I/O error occurs, or the end of the
235      * stream is reached.
236      *
237      * @param      cbuf  Destination buffer
238      * @param      off   Offset at which to start storing characters
239      * @param      len   Maximum number of characters to read
240      *
241      * @return     The number of characters read, or -1 if the end of the
242      *             stream has been reached
243      *
<span class="line-modified">244      * @exception  IOException  If an I/O error occurs</span>
<span class="line-modified">245      * @exception  IndexOutOfBoundsException</span>
246      *             If {@code off} is negative, or {@code len} is negative,
247      *             or {@code len} is greater than {@code cbuf.length - off}
248      */
249     public abstract int read(char cbuf[], int off, int len) throws IOException;
250 
251     /** Maximum skip-buffer size */
252     private static final int maxSkipBufferSize = 8192;
253 
254     /** Skip buffer, null until allocated */
255     private char skipBuffer[] = null;
256 
257     /**
258      * Skips characters.  This method will block until some characters are
259      * available, an I/O error occurs, or the end of the stream is reached.
260      *
261      * @param  n  The number of characters to skip
262      *
263      * @return    The number of characters actually skipped
264      *
<span class="line-modified">265      * @exception  IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</span>
<span class="line-modified">266      * @exception  IOException  If an I/O error occurs</span>
267      */
268     public long skip(long n) throws IOException {
269         if (n &lt; 0L)
270             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
271         int nn = (int) Math.min(n, maxSkipBufferSize);
272         synchronized (lock) {
273             if ((skipBuffer == null) || (skipBuffer.length &lt; nn))
274                 skipBuffer = new char[nn];
275             long r = n;
276             while (r &gt; 0) {
277                 int nc = read(skipBuffer, 0, (int)Math.min(r, nn));
278                 if (nc == -1)
279                     break;
280                 r -= nc;
281             }
282             return n - r;
283         }
284     }
285 
286     /**
287      * Tells whether this stream is ready to be read.
288      *
289      * @return True if the next read() is guaranteed not to block for input,
290      * false otherwise.  Note that returning false does not guarantee that the
291      * next read will block.
292      *
<span class="line-modified">293      * @exception  IOException  If an I/O error occurs</span>
294      */
295     public boolean ready() throws IOException {
296         return false;
297     }
298 
299     /**
300      * Tells whether this stream supports the mark() operation. The default
301      * implementation always returns false. Subclasses should override this
302      * method.
303      *
304      * @return true if and only if this stream supports the mark operation.
305      */
306     public boolean markSupported() {
307         return false;
308     }
309 
310     /**
311      * Marks the present position in the stream.  Subsequent calls to reset()
312      * will attempt to reposition the stream to this point.  Not all
313      * character-input streams support the mark() operation.
314      *
315      * @param  readAheadLimit  Limit on the number of characters that may be
316      *                         read while still preserving the mark.  After
317      *                         reading this many characters, attempting to
318      *                         reset the stream may fail.
319      *
<span class="line-modified">320      * @exception  IOException  If the stream does not support mark(),</span>
321      *                          or if some other I/O error occurs
322      */
323     public void mark(int readAheadLimit) throws IOException {
324         throw new IOException(&quot;mark() not supported&quot;);
325     }
326 
327     /**
328      * Resets the stream.  If the stream has been marked, then attempt to
329      * reposition it at the mark.  If the stream has not been marked, then
330      * attempt to reset it in some way appropriate to the particular stream,
331      * for example by repositioning it to its starting point.  Not all
332      * character-input streams support the reset() operation, and some support
333      * reset() without supporting mark().
334      *
<span class="line-modified">335      * @exception  IOException  If the stream has not been marked,</span>
336      *                          or if the mark has been invalidated,
337      *                          or if the stream does not support reset(),
338      *                          or if some other I/O error occurs
339      */
340     public void reset() throws IOException {
341         throw new IOException(&quot;reset() not supported&quot;);
342     }
343 
344     /**
345      * Closes the stream and releases any system resources associated with
346      * it.  Once the stream has been closed, further read(), ready(),
347      * mark(), reset(), or skip() invocations will throw an IOException.
348      * Closing a previously closed stream has no effect.
349      *
<span class="line-modified">350      * @exception  IOException  If an I/O error occurs</span>
351      */
352      public abstract void close() throws IOException;
353 
354     /**
355      * Reads all characters from this reader and writes the characters to the
356      * given writer in the order that they are read. On return, this reader
357      * will be at end of the stream. This method does not close either reader
358      * or writer.
359      * &lt;p&gt;
360      * This method may block indefinitely reading from the reader, or
361      * writing to the writer. The behavior for the case where the reader
362      * and/or writer is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
363      * interrupted during the transfer, is highly reader and writer
364      * specific, and therefore not specified.
365      * &lt;p&gt;
366      * If an I/O error occurs reading from the reader or writing to the
367      * writer, then it may do so after some characters have been read or
368      * written. Consequently the reader may not be at end of the stream and
369      * one, or both, streams may be in an inconsistent state. It is strongly
370      * recommended that both streams be promptly closed if an I/O error occurs.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
186     public int read(java.nio.CharBuffer target) throws IOException {
187         int len = target.remaining();
188         char[] cbuf = new char[len];
189         int n = read(cbuf, 0, len);
190         if (n &gt; 0)
191             target.put(cbuf, 0, n);
192         return n;
193     }
194 
195     /**
196      * Reads a single character.  This method will block until a character is
197      * available, an I/O error occurs, or the end of the stream is reached.
198      *
199      * &lt;p&gt; Subclasses that intend to support efficient single-character input
200      * should override this method.
201      *
202      * @return     The character read, as an integer in the range 0 to 65535
203      *             ({@code 0x00-0xffff}), or -1 if the end of the stream has
204      *             been reached
205      *
<span class="line-modified">206      * @throws     IOException  If an I/O error occurs</span>
207      */
208     public int read() throws IOException {
209         char cb[] = new char[1];
210         if (read(cb, 0, 1) == -1)
211             return -1;
212         else
213             return cb[0];
214     }
215 
216     /**
217      * Reads characters into an array.  This method will block until some input
218      * is available, an I/O error occurs, or the end of the stream is reached.
219      *
220      * @param       cbuf  Destination buffer
221      *
222      * @return      The number of characters read, or -1
223      *              if the end of the stream
224      *              has been reached
225      *
<span class="line-modified">226      * @throws      IOException  If an I/O error occurs</span>
227      */
228     public int read(char cbuf[]) throws IOException {
229         return read(cbuf, 0, cbuf.length);
230     }
231 
232     /**
233      * Reads characters into a portion of an array.  This method will block
234      * until some input is available, an I/O error occurs, or the end of the
235      * stream is reached.
236      *
237      * @param      cbuf  Destination buffer
238      * @param      off   Offset at which to start storing characters
239      * @param      len   Maximum number of characters to read
240      *
241      * @return     The number of characters read, or -1 if the end of the
242      *             stream has been reached
243      *
<span class="line-modified">244      * @throws     IOException  If an I/O error occurs</span>
<span class="line-modified">245      * @throws     IndexOutOfBoundsException</span>
246      *             If {@code off} is negative, or {@code len} is negative,
247      *             or {@code len} is greater than {@code cbuf.length - off}
248      */
249     public abstract int read(char cbuf[], int off, int len) throws IOException;
250 
251     /** Maximum skip-buffer size */
252     private static final int maxSkipBufferSize = 8192;
253 
254     /** Skip buffer, null until allocated */
255     private char skipBuffer[] = null;
256 
257     /**
258      * Skips characters.  This method will block until some characters are
259      * available, an I/O error occurs, or the end of the stream is reached.
260      *
261      * @param  n  The number of characters to skip
262      *
263      * @return    The number of characters actually skipped
264      *
<span class="line-modified">265      * @throws     IllegalArgumentException  If {@code n} is negative.</span>
<span class="line-modified">266      * @throws     IOException  If an I/O error occurs</span>
267      */
268     public long skip(long n) throws IOException {
269         if (n &lt; 0L)
270             throw new IllegalArgumentException(&quot;skip value is negative&quot;);
271         int nn = (int) Math.min(n, maxSkipBufferSize);
272         synchronized (lock) {
273             if ((skipBuffer == null) || (skipBuffer.length &lt; nn))
274                 skipBuffer = new char[nn];
275             long r = n;
276             while (r &gt; 0) {
277                 int nc = read(skipBuffer, 0, (int)Math.min(r, nn));
278                 if (nc == -1)
279                     break;
280                 r -= nc;
281             }
282             return n - r;
283         }
284     }
285 
286     /**
287      * Tells whether this stream is ready to be read.
288      *
289      * @return True if the next read() is guaranteed not to block for input,
290      * false otherwise.  Note that returning false does not guarantee that the
291      * next read will block.
292      *
<span class="line-modified">293      * @throws     IOException  If an I/O error occurs</span>
294      */
295     public boolean ready() throws IOException {
296         return false;
297     }
298 
299     /**
300      * Tells whether this stream supports the mark() operation. The default
301      * implementation always returns false. Subclasses should override this
302      * method.
303      *
304      * @return true if and only if this stream supports the mark operation.
305      */
306     public boolean markSupported() {
307         return false;
308     }
309 
310     /**
311      * Marks the present position in the stream.  Subsequent calls to reset()
312      * will attempt to reposition the stream to this point.  Not all
313      * character-input streams support the mark() operation.
314      *
315      * @param  readAheadLimit  Limit on the number of characters that may be
316      *                         read while still preserving the mark.  After
317      *                         reading this many characters, attempting to
318      *                         reset the stream may fail.
319      *
<span class="line-modified">320      * @throws     IOException  If the stream does not support mark(),</span>
321      *                          or if some other I/O error occurs
322      */
323     public void mark(int readAheadLimit) throws IOException {
324         throw new IOException(&quot;mark() not supported&quot;);
325     }
326 
327     /**
328      * Resets the stream.  If the stream has been marked, then attempt to
329      * reposition it at the mark.  If the stream has not been marked, then
330      * attempt to reset it in some way appropriate to the particular stream,
331      * for example by repositioning it to its starting point.  Not all
332      * character-input streams support the reset() operation, and some support
333      * reset() without supporting mark().
334      *
<span class="line-modified">335      * @throws     IOException  If the stream has not been marked,</span>
336      *                          or if the mark has been invalidated,
337      *                          or if the stream does not support reset(),
338      *                          or if some other I/O error occurs
339      */
340     public void reset() throws IOException {
341         throw new IOException(&quot;reset() not supported&quot;);
342     }
343 
344     /**
345      * Closes the stream and releases any system resources associated with
346      * it.  Once the stream has been closed, further read(), ready(),
347      * mark(), reset(), or skip() invocations will throw an IOException.
348      * Closing a previously closed stream has no effect.
349      *
<span class="line-modified">350      * @throws     IOException  If an I/O error occurs</span>
351      */
352      public abstract void close() throws IOException;
353 
354     /**
355      * Reads all characters from this reader and writes the characters to the
356      * given writer in the order that they are read. On return, this reader
357      * will be at end of the stream. This method does not close either reader
358      * or writer.
359      * &lt;p&gt;
360      * This method may block indefinitely reading from the reader, or
361      * writing to the writer. The behavior for the case where the reader
362      * and/or writer is &lt;i&gt;asynchronously closed&lt;/i&gt;, or the thread
363      * interrupted during the transfer, is highly reader and writer
364      * specific, and therefore not specified.
365      * &lt;p&gt;
366      * If an I/O error occurs reading from the reader or writing to the
367      * writer, then it may do so after some characters have been read or
368      * written. Consequently the reader may not be at end of the stream and
369      * one, or both, streams may be in an inconsistent state. It is strongly
370      * recommended that both streams be promptly closed if an I/O error occurs.
</pre>
</td>
</tr>
</table>
<center><a href="RandomAccessFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SequenceInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
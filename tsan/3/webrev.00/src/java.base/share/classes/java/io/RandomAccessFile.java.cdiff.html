<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/RandomAccessFile.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PushbackReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Reader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/RandomAccessFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,21 ***</span>
       * is also called with the {@code name} argument
       * as its argument to see if write access to the file is allowed.
       *
       * @param      name   the system-dependent filename
       * @param      mode   the access &lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;
<span class="line-modified">!      * @exception  IllegalArgumentException  if the mode argument is not equal</span>
       *             to one of {@code &quot;r&quot;}, {@code &quot;rw&quot;}, {@code &quot;rws&quot;}, or
       *             {@code &quot;rwd&quot;}
<span class="line-modified">!      * @exception FileNotFoundException</span>
<span class="line-modified">!      *            if the mode is {@code &quot;r&quot;} but the given string does not</span>
<span class="line-modified">!      *            denote an existing regular file, or if the mode begins with</span>
<span class="line-modified">!      *            {@code &quot;rw&quot;} but the given string does not denote an</span>
<span class="line-modified">!      *            existing, writable regular file and a new regular file of</span>
<span class="line-modified">!      *            that name cannot be created, or if some other error occurs</span>
<span class="line-modified">!      *            while opening or creating the file</span>
<span class="line-modified">!      * @exception  SecurityException   if a security manager exists and its</span>
       *             {@code checkRead} method denies read access to the file
       *             or the mode is {@code &quot;rw&quot;} and the security manager&#39;s
       *             {@code checkWrite} method denies write access to the file
       * @see        java.lang.SecurityException
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
<span class="line-new-header">--- 101,21 ---</span>
       * is also called with the {@code name} argument
       * as its argument to see if write access to the file is allowed.
       *
       * @param      name   the system-dependent filename
       * @param      mode   the access &lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;
<span class="line-modified">!      * @throws     IllegalArgumentException  if the mode argument is not equal</span>
       *             to one of {@code &quot;r&quot;}, {@code &quot;rw&quot;}, {@code &quot;rws&quot;}, or
       *             {@code &quot;rwd&quot;}
<span class="line-modified">!      * @throws     FileNotFoundException</span>
<span class="line-modified">!      *             if the mode is {@code &quot;r&quot;} but the given string does not</span>
<span class="line-modified">!      *             denote an existing regular file, or if the mode begins with</span>
<span class="line-modified">!      *             {@code &quot;rw&quot;} but the given string does not denote an</span>
<span class="line-modified">!      *             existing, writable regular file and a new regular file of</span>
<span class="line-modified">!      *             that name cannot be created, or if some other error occurs</span>
<span class="line-modified">!      *             while opening or creating the file</span>
<span class="line-modified">!      * @throws      SecurityException   if a security manager exists and its</span>
       *             {@code checkRead} method denies read access to the file
       *             or the mode is {@code &quot;rw&quot;} and the security manager&#39;s
       *             {@code checkWrite} method denies write access to the file
       * @see        java.lang.SecurityException
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,21 ***</span>
       * allowed.
       *
       * @param      file   the file object
       * @param      mode   the access mode, as described
       *                    &lt;a href=&quot;#mode&quot;&gt;above&lt;/a&gt;
<span class="line-modified">!      * @exception  IllegalArgumentException  if the mode argument is not equal</span>
       *             to one of {@code &quot;r&quot;}, {@code &quot;rw&quot;}, {@code &quot;rws&quot;}, or
       *             {@code &quot;rwd&quot;}
<span class="line-modified">!      * @exception FileNotFoundException</span>
<span class="line-modified">!      *            if the mode is {@code &quot;r&quot;} but the given file object does</span>
<span class="line-modified">!      *            not denote an existing regular file, or if the mode begins</span>
<span class="line-modified">!      *            with {@code &quot;rw&quot;} but the given file object does not denote</span>
<span class="line-modified">!      *            an existing, writable regular file and a new regular file of</span>
<span class="line-modified">!      *            that name cannot be created, or if some other error occurs</span>
<span class="line-modified">!      *            while opening or creating the file</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkRead} method denies read access to the file
       *             or the mode is {@code &quot;rw&quot;} and the security manager&#39;s
       *             {@code checkWrite} method denies write access to the file
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
<span class="line-new-header">--- 188,21 ---</span>
       * allowed.
       *
       * @param      file   the file object
       * @param      mode   the access mode, as described
       *                    &lt;a href=&quot;#mode&quot;&gt;above&lt;/a&gt;
<span class="line-modified">!      * @throws     IllegalArgumentException  if the mode argument is not equal</span>
       *             to one of {@code &quot;r&quot;}, {@code &quot;rw&quot;}, {@code &quot;rws&quot;}, or
       *             {@code &quot;rwd&quot;}
<span class="line-modified">!      * @throws     FileNotFoundException</span>
<span class="line-modified">!      *             if the mode is {@code &quot;r&quot;} but the given file object does</span>
<span class="line-modified">!      *             not denote an existing regular file, or if the mode begins</span>
<span class="line-modified">!      *             with {@code &quot;rw&quot;} but the given file object does not denote</span>
<span class="line-modified">!      *             an existing, writable regular file and a new regular file of</span>
<span class="line-modified">!      *             that name cannot be created, or if some other error occurs</span>
<span class="line-modified">!      *             while opening or creating the file</span>
<span class="line-modified">!      * @throws      SecurityException  if a security manager exists and its</span>
       *             {@code checkRead} method denies read access to the file
       *             or the mode is {@code &quot;rw&quot;} and the security manager&#39;s
       *             {@code checkWrite} method denies write access to the file
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 265,11 ***</span>
      /**
       * Returns the opaque file descriptor object associated with this
       * stream.
       *
       * @return     the file descriptor object associated with this stream.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FileDescriptor
       */
      public final FileDescriptor getFD() throws IOException {
          if (fd != null) {
              return fd;
<span class="line-new-header">--- 265,11 ---</span>
      /**
       * Returns the opaque file descriptor object associated with this
       * stream.
       *
       * @return     the file descriptor object associated with this stream.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FileDescriptor
       */
      public final FileDescriptor getFD() throws IOException {
          if (fd != null) {
              return fd;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,25 ***</span>
       * way as the {@link InputStream#read()} method of
       * {@code InputStream}.
       *
       * @return     the next byte of data, or {@code -1} if the end of the
       *             file has been reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs. Not thrown if</span>
       *                          end-of-file has been reached.
       */
      public int read() throws IOException {
          return read0();
      }
  
      private native int read0() throws IOException;
  
      /**
       * Reads a sub array as a sequence of bytes.
<span class="line-modified">!      * @param b the buffer into which the data is read.</span>
<span class="line-modified">!      * @param off the start offset of the data.</span>
<span class="line-modified">!      * @param len the number of bytes to read.</span>
<span class="line-modified">!      * @exception IOException If an I/O error has occurred.</span>
       */
      private native int readBytes(byte b[], int off, int len) throws IOException;
  
      /**
       * Reads up to {@code len} bytes of data from this file into an
<span class="line-new-header">--- 359,25 ---</span>
       * way as the {@link InputStream#read()} method of
       * {@code InputStream}.
       *
       * @return     the next byte of data, or {@code -1} if the end of the
       *             file has been reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs. Not thrown if</span>
       *                          end-of-file has been reached.
       */
      public int read() throws IOException {
          return read0();
      }
  
      private native int read0() throws IOException;
  
      /**
       * Reads a sub array as a sequence of bytes.
<span class="line-modified">!      * @param     b the buffer into which the data is read.</span>
<span class="line-modified">!      * @param     off the start offset of the data.</span>
<span class="line-modified">!      * @param     len the number of bytes to read.</span>
<span class="line-modified">!      * @throws    IOException If an I/O error has occurred.</span>
       */
      private native int readBytes(byte b[], int off, int len) throws IOException;
  
      /**
       * Reads up to {@code len} bytes of data from this file into an
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,17 ***</span>
       *                   at which the data is written.
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             the file has been reached.
<span class="line-modified">!      * @exception  IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than end of file, or if the random access file has been closed, or if</span>
<span class="line-modified">!      * some other I/O error occurs.</span>
<span class="line-modified">!      * @exception  NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      * {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      * {@code b.length - off}</span>
       */
      public int read(byte b[], int off, int len) throws IOException {
          return readBytes(b, off, len);
      }
  
<span class="line-new-header">--- 394,17 ---</span>
       *                   at which the data is written.
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             the file has been reached.
<span class="line-modified">!      * @throws     IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than end of file, or if the random access file has been closed,</span>
<span class="line-modified">!      *             or if some other I/O error occurs.</span>
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      *             {@code b.length - off}</span>
       */
      public int read(byte b[], int off, int len) throws IOException {
          return readBytes(b, off, len);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,14 ***</span>
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             this file has been reached.
<span class="line-modified">!      * @exception  IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      * other than end of file, or if the random access file has been closed, or if</span>
<span class="line-modified">!      * some other I/O error occurs.</span>
<span class="line-modified">!      * @exception  NullPointerException If {@code b} is {@code null}.</span>
       */
      public int read(byte b[]) throws IOException {
          return readBytes(b, 0, b.length);
      }
  
<span class="line-new-header">--- 420,14 ---</span>
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
       *             {@code -1} if there is no more data because the end of
       *             this file has been reached.
<span class="line-modified">!      * @throws     IOException If the first byte cannot be read for any reason</span>
<span class="line-modified">!      *             other than end of file, or if the random access file has been closed,</span>
<span class="line-modified">!      *             or if some other I/O error occurs.</span>
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
       */
      public int read(byte b[]) throws IOException {
          return readBytes(b, 0, b.length);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,11 ***</span>
       * The actual number of bytes skipped is returned.  If {@code n}
       * is negative, no bytes are skipped.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public int skipBytes(int n) throws IOException {
          long pos;
          long len;
          long newpos;
<span class="line-new-header">--- 488,11 ---</span>
       * The actual number of bytes skipped is returned.  If {@code n}
       * is negative, no bytes are skipped.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public int skipBytes(int n) throws IOException {
          long pos;
          long len;
          long newpos;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,34 ***</span>
      /**
       * Writes the specified byte to this file. The write starts at
       * the current file pointer.
       *
       * @param      b   the {@code byte} to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public void write(int b) throws IOException {
          write0(b);
      }
  
      private native void write0(int b) throws IOException;
  
      /**
       * Writes a sub array as a sequence of bytes.
<span class="line-modified">!      * @param b the data to be written</span>
  
<span class="line-modified">!      * @param off the start offset in the data</span>
<span class="line-modified">!      * @param len the number of bytes that are written</span>
<span class="line-modified">!      * @exception IOException If an I/O error has occurred.</span>
       */
      private native void writeBytes(byte b[], int off, int len) throws IOException;
  
      /**
       * Writes {@code b.length} bytes from the specified byte array
       * to this file, starting at the current file pointer.
       *
       * @param      b   the data.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public void write(byte b[]) throws IOException {
          writeBytes(b, 0, b.length);
      }
  
<span class="line-new-header">--- 517,34 ---</span>
      /**
       * Writes the specified byte to this file. The write starts at
       * the current file pointer.
       *
       * @param      b   the {@code byte} to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public void write(int b) throws IOException {
          write0(b);
      }
  
      private native void write0(int b) throws IOException;
  
      /**
       * Writes a sub array as a sequence of bytes.
<span class="line-modified">!      * @param     b the data to be written</span>
  
<span class="line-modified">!      * @param     off the start offset in the data</span>
<span class="line-modified">!      * @param     len the number of bytes that are written</span>
<span class="line-modified">!      * @throws    IOException If an I/O error has occurred.</span>
       */
      private native void writeBytes(byte b[], int off, int len) throws IOException;
  
      /**
       * Writes {@code b.length} bytes from the specified byte array
       * to this file, starting at the current file pointer.
       *
       * @param      b   the data.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public void write(byte b[]) throws IOException {
          writeBytes(b, 0, b.length);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,11 ***</span>
       * starting at offset {@code off} to this file.
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public void write(byte b[], int off, int len) throws IOException {
          writeBytes(b, off, len);
      }
  
<span class="line-new-header">--- 553,11 ---</span>
       * starting at offset {@code off} to this file.
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public void write(byte b[], int off, int len) throws IOException {
          writeBytes(b, off, len);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,11 ***</span>
      /**
       * Returns the current offset in this file.
       *
       * @return     the offset from the beginning of the file, in bytes,
       *             at which the next read or write occurs.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public native long getFilePointer() throws IOException;
  
      /**
       * Sets the file-pointer offset, measured from the beginning of this
<span class="line-new-header">--- 566,11 ---</span>
      /**
       * Returns the current offset in this file.
       *
       * @return     the offset from the beginning of the file, in bytes,
       *             at which the next read or write occurs.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public native long getFilePointer() throws IOException;
  
      /**
       * Sets the file-pointer offset, measured from the beginning of this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 581,11 ***</span>
       * of the file.
       *
       * @param      pos   the offset position, measured in bytes from the
       *                   beginning of the file, at which to set the file
       *                   pointer.
<span class="line-modified">!      * @exception  IOException  if {@code pos} is less than</span>
       *                          {@code 0} or if an I/O error occurs.
       */
      public void seek(long pos) throws IOException {
          if (pos &lt; 0) {
              throw new IOException(&quot;Negative seek offset&quot;);
<span class="line-new-header">--- 581,11 ---</span>
       * of the file.
       *
       * @param      pos   the offset position, measured in bytes from the
       *                   beginning of the file, at which to set the file
       *                   pointer.
<span class="line-modified">!      * @throws     IOException  if {@code pos} is less than</span>
       *                          {@code 0} or if an I/O error occurs.
       */
      public void seek(long pos) throws IOException {
          if (pos &lt; 0) {
              throw new IOException(&quot;Negative seek offset&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,11 ***</span>
  
      /**
       * Returns the length of this file.
       *
       * @return     the length of this file, measured in bytes.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public native long length() throws IOException;
  
      /**
       * Sets the length of this file.
<span class="line-new-header">--- 598,11 ---</span>
  
      /**
       * Returns the length of this file.
       *
       * @return     the length of this file, measured in bytes.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public native long length() throws IOException;
  
      /**
       * Sets the length of this file.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,11 ***</span>
       * {@code length} method is smaller than the {@code newLength}
       * argument then the file will be extended.  In this case, the contents of
       * the extended portion of the file are not defined.
       *
       * @param      newLength    The desired length of the file
<span class="line-modified">!      * @exception  IOException  If an I/O error occurs</span>
       * @since      1.2
       */
      public native void setLength(long newLength) throws IOException;
  
      /**
<span class="line-new-header">--- 618,11 ---</span>
       * {@code length} method is smaller than the {@code newLength}
       * argument then the file will be extended.  In this case, the contents of
       * the extended portion of the file are not defined.
       *
       * @param      newLength    The desired length of the file
<span class="line-modified">!      * @throws     IOException  If an I/O error occurs</span>
       * @since      1.2
       */
      public native void setLength(long newLength) throws IOException;
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,11 ***</span>
       * reopened.
       *
       * &lt;p&gt; If this file has an associated channel then the channel is closed
       * as well.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() throws IOException {
<span class="line-new-header">--- 632,11 ---</span>
       * reopened.
       *
       * &lt;p&gt; If this file has an associated channel then the channel is closed
       * as well.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,12 ***</span>
       * {@code false}. Any other value represents {@code true}.
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the {@code boolean} value read.
<span class="line-modified">!      * @exception  EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final boolean readBoolean() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
<span class="line-new-header">--- 676,12 ---</span>
       * {@code false}. Any other value represents {@code true}.
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the {@code boolean} value read.
<span class="line-modified">!      * @throws     EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final boolean readBoolean() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,12 ***</span>
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the next byte of this file as a signed eight-bit
       *             {@code byte}.
<span class="line-modified">!      * @exception  EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final byte readByte() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
<span class="line-new-header">--- 701,12 ---</span>
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the next byte of this file as a signed eight-bit
       *             {@code byte}.
<span class="line-modified">!      * @throws     EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final byte readByte() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,12 ***</span>
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the next byte of this file, interpreted as an unsigned
       *             eight-bit number.
<span class="line-modified">!      * @exception  EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final int readUnsignedByte() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
<span class="line-new-header">--- 721,12 ---</span>
       * This method blocks until the byte is read, the end of the stream
       * is detected, or an exception is thrown.
       *
       * @return     the next byte of this file, interpreted as an unsigned
       *             eight-bit number.
<span class="line-modified">!      * @throws     EOFException  if this file has reached the end.</span>
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final int readUnsignedByte() throws IOException {
          int ch = this.read();
          if (ch &lt; 0)
              throw new EOFException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 747,13 ***</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as a signed
       *             16-bit number.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final short readShort() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
<span class="line-new-header">--- 747,13 ---</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as a signed
       *             16-bit number.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final short readShort() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,13 ***</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as an unsigned
       *             16-bit integer.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final int readUnsignedShort() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
<span class="line-new-header">--- 775,13 ---</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as an unsigned
       *             16-bit integer.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final int readUnsignedShort() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 803,13 ***</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as a
       *                  {@code char}.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final char readChar() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
<span class="line-new-header">--- 803,13 ---</span>
       * This method blocks until the two bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next two bytes of this file, interpreted as a
       *                  {@code char}.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *               two bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final char readChar() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          if ((ch1 | ch2) &lt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 831,13 ***</span>
       * This method blocks until the four bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next four bytes of this file, interpreted as an
       *             {@code int}.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *               four bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final int readInt() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          int ch3 = this.read();
<span class="line-new-header">--- 831,13 ---</span>
       * This method blocks until the four bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next four bytes of this file, interpreted as an
       *             {@code int}.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *               four bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final int readInt() throws IOException {
          int ch1 = this.read();
          int ch2 = this.read();
          int ch3 = this.read();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 869,13 ***</span>
       * This method blocks until the eight bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next eight bytes of this file, interpreted as a
       *             {@code long}.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *               eight bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       */
      public final long readLong() throws IOException {
          return ((long)(readInt()) &lt;&lt; 32) + (readInt() &amp; 0xFFFFFFFFL);
      }
  
<span class="line-new-header">--- 869,13 ---</span>
       * This method blocks until the eight bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next eight bytes of this file, interpreted as a
       *             {@code long}.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *               eight bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       */
      public final long readLong() throws IOException {
          return ((long)(readInt()) &lt;&lt; 32) + (readInt() &amp; 0xFFFFFFFFL);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,13 ***</span>
       * This method blocks until the four bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next four bytes of this file, interpreted as a
       *             {@code float}.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *             four bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#readInt()
       * @see        java.lang.Float#intBitsToFloat(int)
       */
      public final float readFloat() throws IOException {
          return Float.intBitsToFloat(readInt());
<span class="line-new-header">--- 890,13 ---</span>
       * This method blocks until the four bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next four bytes of this file, interpreted as a
       *             {@code float}.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *             four bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#readInt()
       * @see        java.lang.Float#intBitsToFloat(int)
       */
      public final float readFloat() throws IOException {
          return Float.intBitsToFloat(readInt());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,13 ***</span>
       * This method blocks until the eight bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next eight bytes of this file, interpreted as a
       *             {@code double}.
<span class="line-modified">!      * @exception  EOFException  if this file reaches the end before reading</span>
       *             eight bytes.
<span class="line-modified">!      * @exception  IOException   if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#readLong()
       * @see        java.lang.Double#longBitsToDouble(long)
       */
      public final double readDouble() throws IOException {
          return Double.longBitsToDouble(readLong());
<span class="line-new-header">--- 913,13 ---</span>
       * This method blocks until the eight bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     the next eight bytes of this file, interpreted as a
       *             {@code double}.
<span class="line-modified">!      * @throws     EOFException  if this file reaches the end before reading</span>
       *             eight bytes.
<span class="line-modified">!      * @throws     IOException   if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#readLong()
       * @see        java.lang.Double#longBitsToDouble(long)
       */
      public final double readDouble() throws IOException {
          return Double.longBitsToDouble(readLong());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 944,11 ***</span>
       * return and the byte following it are read (to see if it is a newline),
       * the end of the file is reached, or an exception is thrown.
       *
       * @return     the next line of text from this file, or null if end
       *             of file is encountered before even one byte is read.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
  
      public final String readLine() throws IOException {
          StringBuilder input = new StringBuilder();
          int c = -1;
<span class="line-new-header">--- 944,11 ---</span>
       * return and the byte following it are read (to see if it is a newline),
       * the end of the file is reached, or an exception is thrown.
       *
       * @return     the next line of text from this file, or null if end
       *             of file is encountered before even one byte is read.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
  
      public final String readLine() throws IOException {
          StringBuilder input = new StringBuilder();
          int c = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,14 ***</span>
       * &lt;p&gt;
       * This method blocks until all the bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     a Unicode string.
<span class="line-modified">!      * @exception  EOFException            if this file reaches the end before</span>
       *               reading all the bytes.
<span class="line-modified">!      * @exception  IOException             if an I/O error occurs.</span>
<span class="line-modified">!      * @exception  UTFDataFormatException  if the bytes do not represent</span>
       *               valid modified UTF-8 encoding of a Unicode string.
       * @see        java.io.RandomAccessFile#readUnsignedShort()
       */
      public final String readUTF() throws IOException {
          return DataInputStream.readUTF(this);
<span class="line-new-header">--- 995,14 ---</span>
       * &lt;p&gt;
       * This method blocks until all the bytes are read, the end of the
       * stream is detected, or an exception is thrown.
       *
       * @return     a Unicode string.
<span class="line-modified">!      * @throws     EOFException            if this file reaches the end before</span>
       *               reading all the bytes.
<span class="line-modified">!      * @throws     IOException             if an I/O error occurs.</span>
<span class="line-modified">!      * @throws     UTFDataFormatException  if the bytes do not represent</span>
       *               valid modified UTF-8 encoding of a Unicode string.
       * @see        java.io.RandomAccessFile#readUnsignedShort()
       */
      public final String readUTF() throws IOException {
          return DataInputStream.readUTF(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1014,11 ***</span>
       * {@code (byte)1}; the value {@code false} is written out
       * as the value {@code (byte)0}. The write starts at
       * the current position of the file pointer.
       *
       * @param      v   a {@code boolean} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeBoolean(boolean v) throws IOException {
          write(v ? 1 : 0);
          //written++;
      }
<span class="line-new-header">--- 1014,11 ---</span>
       * {@code (byte)1}; the value {@code false} is written out
       * as the value {@code (byte)0}. The write starts at
       * the current position of the file pointer.
       *
       * @param      v   a {@code boolean} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeBoolean(boolean v) throws IOException {
          write(v ? 1 : 0);
          //written++;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,11 ***</span>
      /**
       * Writes a {@code byte} to the file as a one-byte value. The
       * write starts at the current position of the file pointer.
       *
       * @param      v   a {@code byte} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeByte(int v) throws IOException {
          write(v);
          //written++;
      }
<span class="line-new-header">--- 1026,11 ---</span>
      /**
       * Writes a {@code byte} to the file as a one-byte value. The
       * write starts at the current position of the file pointer.
       *
       * @param      v   a {@code byte} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeByte(int v) throws IOException {
          write(v);
          //written++;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,11 ***</span>
      /**
       * Writes a {@code short} to the file as two bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   a {@code short} to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeShort(int v) throws IOException {
          write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          //written += 2;
<span class="line-new-header">--- 1038,11 ---</span>
      /**
       * Writes a {@code short} to the file as two bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   a {@code short} to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeShort(int v) throws IOException {
          write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          //written += 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,11 ***</span>
       * Writes a {@code char} to the file as a two-byte value, high
       * byte first. The write starts at the current position of the
       * file pointer.
       *
       * @param      v   a {@code char} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeChar(int v) throws IOException {
          write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          //written += 2;
<span class="line-new-header">--- 1052,11 ---</span>
       * Writes a {@code char} to the file as a two-byte value, high
       * byte first. The write starts at the current position of the
       * file pointer.
       *
       * @param      v   a {@code char} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeChar(int v) throws IOException {
          write((v &gt;&gt;&gt; 8) &amp; 0xFF);
          write((v &gt;&gt;&gt; 0) &amp; 0xFF);
          //written += 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,11 ***</span>
      /**
       * Writes an {@code int} to the file as four bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   an {@code int} to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeInt(int v) throws IOException {
          write((v &gt;&gt;&gt; 24) &amp; 0xFF);
          write((v &gt;&gt;&gt; 16) &amp; 0xFF);
          write((v &gt;&gt;&gt;  8) &amp; 0xFF);
<span class="line-new-header">--- 1065,11 ---</span>
      /**
       * Writes an {@code int} to the file as four bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   an {@code int} to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeInt(int v) throws IOException {
          write((v &gt;&gt;&gt; 24) &amp; 0xFF);
          write((v &gt;&gt;&gt; 16) &amp; 0xFF);
          write((v &gt;&gt;&gt;  8) &amp; 0xFF);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,11 ***</span>
      /**
       * Writes a {@code long} to the file as eight bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   a {@code long} to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeLong(long v) throws IOException {
          write((int)(v &gt;&gt;&gt; 56) &amp; 0xFF);
          write((int)(v &gt;&gt;&gt; 48) &amp; 0xFF);
          write((int)(v &gt;&gt;&gt; 40) &amp; 0xFF);
<span class="line-new-header">--- 1080,11 ---</span>
      /**
       * Writes a {@code long} to the file as eight bytes, high byte first.
       * The write starts at the current position of the file pointer.
       *
       * @param      v   a {@code long} to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeLong(long v) throws IOException {
          write((int)(v &gt;&gt;&gt; 56) &amp; 0xFF);
          write((int)(v &gt;&gt;&gt; 48) &amp; 0xFF);
          write((int)(v &gt;&gt;&gt; 40) &amp; 0xFF);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1102,11 ***</span>
       * and then writes that {@code int} value to the file as a
       * four-byte quantity, high byte first. The write starts at the
       * current position of the file pointer.
       *
       * @param      v   a {@code float} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.lang.Float#floatToIntBits(float)
       */
      public final void writeFloat(float v) throws IOException {
          writeInt(Float.floatToIntBits(v));
      }
<span class="line-new-header">--- 1102,11 ---</span>
       * and then writes that {@code int} value to the file as a
       * four-byte quantity, high byte first. The write starts at the
       * current position of the file pointer.
       *
       * @param      v   a {@code float} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.lang.Float#floatToIntBits(float)
       */
      public final void writeFloat(float v) throws IOException {
          writeInt(Float.floatToIntBits(v));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1117,11 ***</span>
       * and then writes that {@code long} value to the file as an
       * eight-byte quantity, high byte first. The write starts at the current
       * position of the file pointer.
       *
       * @param      v   a {@code double} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.lang.Double#doubleToLongBits(double)
       */
      public final void writeDouble(double v) throws IOException {
          writeLong(Double.doubleToLongBits(v));
      }
<span class="line-new-header">--- 1117,11 ---</span>
       * and then writes that {@code long} value to the file as an
       * eight-byte quantity, high byte first. The write starts at the current
       * position of the file pointer.
       *
       * @param      v   a {@code double} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.lang.Double#doubleToLongBits(double)
       */
      public final void writeDouble(double v) throws IOException {
          writeLong(Double.doubleToLongBits(v));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1131,11 ***</span>
       * character in the string is written out, in sequence, by discarding
       * its high eight bits. The write starts at the current position of
       * the file pointer.
       *
       * @param      s   a string of bytes to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      @SuppressWarnings(&quot;deprecation&quot;)
      public final void writeBytes(String s) throws IOException {
          int len = s.length();
          byte[] b = new byte[len];
<span class="line-new-header">--- 1131,11 ---</span>
       * character in the string is written out, in sequence, by discarding
       * its high eight bits. The write starts at the current position of
       * the file pointer.
       *
       * @param      s   a string of bytes to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      @SuppressWarnings(&quot;deprecation&quot;)
      public final void writeBytes(String s) throws IOException {
          int len = s.length();
          byte[] b = new byte[len];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1148,11 ***</span>
       * character is written to the data output stream as if by the
       * {@code writeChar} method. The write starts at the current
       * position of the file pointer.
       *
       * @param      s   a {@code String} value to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#writeChar(int)
       */
      public final void writeChars(String s) throws IOException {
          int clen = s.length();
          int blen = 2*clen;
<span class="line-new-header">--- 1148,11 ---</span>
       * character is written to the data output stream as if by the
       * {@code writeChar} method. The write starts at the current
       * position of the file pointer.
       *
       * @param      s   a {@code String} value to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.RandomAccessFile#writeChar(int)
       */
      public final void writeChars(String s) throws IOException {
          int clen = s.length();
          int blen = 2*clen;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,11 ***</span>
       * not the length of the string. Following the length, each character
       * of the string is output, in sequence, using the modified UTF-8 encoding
       * for each character.
       *
       * @param      str   a string to be written.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public final void writeUTF(String str) throws IOException {
          DataOutputStream.writeUTF(str, this);
      }
  
<span class="line-new-header">--- 1178,11 ---</span>
       * not the length of the string. Following the length, each character
       * of the string is output, in sequence, using the modified UTF-8 encoding
       * for each character.
       *
       * @param      str   a string to be written.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public final void writeUTF(String str) throws IOException {
          DataOutputStream.writeUTF(str, this);
      }
  
</pre>
<center><a href="PushbackReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Reader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/DateFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CompactNumberFormat.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormatSymbols.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/DateFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,11 ***</span>
  /**
   * {@code DateFormat} is an abstract class for date/time formatting subclasses which
   * formats and parses dates or time in a language-independent manner.
   * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
   * formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
<span class="line-modified">!  * normalization.  The date is represented as a &lt;code&gt;Date&lt;/code&gt; object or</span>
   * as the milliseconds since January 1, 1970, 00:00:00 GMT.
   *
   * &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
   * formatters based on the default or a given locale and a number of formatting
   * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
<span class="line-new-header">--- 56,11 ---</span>
  /**
   * {@code DateFormat} is an abstract class for date/time formatting subclasses which
   * formats and parses dates or time in a language-independent manner.
   * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
   * formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
<span class="line-modified">!  * normalization.  The date is represented as a {@code Date} object or</span>
   * as the milliseconds since January 1, 1970, 00:00:00 GMT.
   *
   * &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
   * formatters based on the default or a given locale and a number of formatting
   * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,11 ***</span>
   * &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
   * &lt;li&gt;align any particular field, or find out where it is for selection
   * on the screen.
   * &lt;/ul&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Date formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
<span class="line-new-header">--- 138,11 ---</span>
   * &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
   * &lt;li&gt;align any particular field, or find out where it is for selection
   * on the screen.
   * &lt;/ul&gt;
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt;
   * Date formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,19 ***</span>
       * and the instant of time. This field is used for both formatting and
       * parsing.
       *
       * &lt;p&gt;Subclasses should initialize this field to a {@link Calendar}
       * appropriate for the {@link Locale} associated with this
<span class="line-modified">!      * &lt;code&gt;DateFormat&lt;/code&gt;.</span>
       * @serial
       */
      protected Calendar calendar;
  
      /**
<span class="line-modified">!      * The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers</span>
       * in dates and times.  Subclasses should initialize this to a number format
<span class="line-modified">!      * appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</span>
       * @serial
       */
      protected NumberFormat numberFormat;
  
      /**
<span class="line-new-header">--- 183,19 ---</span>
       * and the instant of time. This field is used for both formatting and
       * parsing.
       *
       * &lt;p&gt;Subclasses should initialize this field to a {@link Calendar}
       * appropriate for the {@link Locale} associated with this
<span class="line-modified">!      * {@code DateFormat}.</span>
       * @serial
       */
      protected Calendar calendar;
  
      /**
<span class="line-modified">!      * The number formatter that {@code DateFormat} uses to format numbers</span>
       * in dates and times.  Subclasses should initialize this to a number format
<span class="line-modified">!      * appropriate for the locale associated with this {@code DateFormat}.</span>
       * @serial
       */
      protected NumberFormat numberFormat;
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,10 ***</span>
<span class="line-new-header">--- 296,11 ---</span>
       * Used in FieldPosition of date/time formatting.
       */
      public static final int TIMEZONE_FIELD = 17;
  
      // Proclaim serial compatibility with 1.1 FCS
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 7218322306649953788L;
  
      /**
       * Formats the given {@code Object} into a date-time string. The formatted
       * string is appended to the given {@code StringBuffer}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,11 ***</span>
       * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
       * {@code fieldPosition} will be set to 5 and 8, respectively, for the
       * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
       * @return the string buffer passed in as {@code toAppendTo},
       *         with formatted text appended.
<span class="line-modified">!      * @exception IllegalArgumentException if the {@code Format} cannot format</span>
       *            the given {@code obj}.
       * @see java.text.Format
       */
      public final StringBuffer format(Object obj, StringBuffer toAppendTo,
                                       FieldPosition fieldPosition)
<span class="line-new-header">--- 321,11 ---</span>
       * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
       * {@code fieldPosition} will be set to 5 and 8, respectively, for the
       * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
       * @return the string buffer passed in as {@code toAppendTo},
       *         with formatted text appended.
<span class="line-modified">!      * @throws    IllegalArgumentException if the {@code Format} cannot format</span>
       *            the given {@code obj}.
       * @see java.text.Format
       */
      public final StringBuffer format(Object obj, StringBuffer toAppendTo,
                                       FieldPosition fieldPosition)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,13 ***</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on date parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">!      * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string.</span>
<span class="line-modified">!      * @exception ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Date parse(String source) throws ParseException
      {
          ParsePosition pos = new ParsePosition(0);
<span class="line-new-header">--- 381,13 ---</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on date parsing.
       *
<span class="line-modified">!      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">!      * @return A {@code Date} parsed from the string.</span>
<span class="line-modified">!      * @throws    ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Date parse(String source) throws ParseException
      {
          ParsePosition pos = new ParsePosition(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,30 ***</span>
       * @return      A {@code Date}, or {@code null} if the input could not be parsed
       */
      public abstract Date parse(String source, ParsePosition pos);
  
      /**
<span class="line-modified">!      * Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.</span>
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">!      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on date parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      public Object parseObject(String source, ParsePosition pos) {
          return parse(source, pos);
<span class="line-new-header">--- 425,30 ---</span>
       * @return      A {@code Date}, or {@code null} if the input could not be parsed
       */
      public abstract Date parse(String source, ParsePosition pos);
  
      /**
<span class="line-modified">!      * Parses text from a string to produce a {@code Date}.</span>
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * {@code pos}.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of {@code pos} is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * date is returned. The updated {@code pos} can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">!      * changed, the error index of {@code pos} is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on date parsing.
       *
<span class="line-modified">!      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A {@code ParsePosition} object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return A {@code Date} parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code source} or {@code pos} is null.
       */
      public Object parseObject(String source, ParsePosition pos) {
          return parse(source, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,20 ***</span>
          return getDateTimeInstance(SHORT, SHORT);
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
<span class="line-modified">!      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to</span>
       * {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         &lt;code&gt;DateFormat&lt;/code&gt; instances are available.</span>
       */
      public static Locale[] getAvailableLocales()
      {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(DateFormatProvider.class);
<span class="line-new-header">--- 626,20 ---</span>
          return getDateTimeInstance(SHORT, SHORT);
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * {@code get*Instance} methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
<span class="line-modified">!      * It must contain at least a {@code Locale} instance equal to</span>
       * {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         {@code DateFormat} instances are available.</span>
       */
      public static Locale[] getAvailableLocales()
      {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(DateFormatProvider.class);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,23 ***</span>
       */
      protected DateFormat() {}
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">!      * from &lt;code&gt;DateFormat.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified">!      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
       * &lt;p&gt;
       * The class also provides two methods to map
       * between its constants and the corresponding Calendar constants.
       *
       * @since 1.4
       * @see java.util.Calendar
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
          private static final long serialVersionUID = 7441350119349544720L;
  
          // table of all instances in this class, used by readResolve
          private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(18);
          // Maps from Calendar constant (such as Calendar.ERA) to Field
<span class="line-new-header">--- 852,24 ---</span>
       */
      protected DateFormat() {}
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">!      * from {@code DateFormat.formatToCharacterIterator} and as</span>
<span class="line-modified">!      * field identifiers in {@code FieldPosition}.</span>
       * &lt;p&gt;
       * The class also provides two methods to map
       * between its constants and the corresponding Calendar constants.
       *
       * @since 1.4
       * @see java.util.Calendar
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 7441350119349544720L;
  
          // table of all instances in this class, used by readResolve
          private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(18);
          // Maps from Calendar constant (such as Calendar.ERA) to Field
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,17 ***</span>
  
          /** Calendar field. */
          private int calendarField;
  
          /**
<span class="line-modified">!          * Returns the &lt;code&gt;Field&lt;/code&gt; constant that corresponds to</span>
<span class="line-modified">!          * the &lt;code&gt;Calendar&lt;/code&gt; constant &lt;code&gt;calendarField&lt;/code&gt;.</span>
<span class="line-modified">!          * If there is no direct mapping between the &lt;code&gt;Calendar&lt;/code&gt;</span>
<span class="line-modified">!          * constant and a &lt;code&gt;Field&lt;/code&gt;, null is returned.</span>
           *
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;calendarField&lt;/code&gt; is</span>
<span class="line-modified">!          *         not the value of a &lt;code&gt;Calendar&lt;/code&gt; field constant.</span>
           * @param calendarField Calendar field constant
           * @return Field instance representing calendarField.
           * @see java.util.Calendar
           */
          public static Field ofCalendarField(int calendarField) {
<span class="line-new-header">--- 879,17 ---</span>
  
          /** Calendar field. */
          private int calendarField;
  
          /**
<span class="line-modified">!          * Returns the {@code Field} constant that corresponds to</span>
<span class="line-modified">!          * the {@code Calendar} constant {@code calendarField}.</span>
<span class="line-modified">!          * If there is no direct mapping between the {@code Calendar}</span>
<span class="line-modified">!          * constant and a {@code Field}, null is returned.</span>
           *
<span class="line-modified">!          * @throws IllegalArgumentException if {@code calendarField} is</span>
<span class="line-modified">!          *         not the value of a {@code Calendar} field constant.</span>
           * @param calendarField Calendar field constant
           * @return Field instance representing calendarField.
           * @see java.util.Calendar
           */
          public static Field ofCalendarField(int calendarField) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 898,18 ***</span>
              }
              return calendarToFieldMapping[calendarField];
          }
  
          /**
<span class="line-modified">!          * Creates a &lt;code&gt;Field&lt;/code&gt;.</span>
           *
<span class="line-modified">!          * @param name the name of the &lt;code&gt;Field&lt;/code&gt;</span>
<span class="line-modified">!          * @param calendarField the &lt;code&gt;Calendar&lt;/code&gt; constant this</span>
<span class="line-modified">!          *        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one</span>
<span class="line-modified">!          *        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may</span>
<span class="line-modified">!          *        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values</span>
<span class="line-modified">!          *        that don&#39;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values</span>
           */
          protected Field(String name, int calendarField) {
              super(name);
              this.calendarField = calendarField;
              if (this.getClass() == DateFormat.Field.class) {
<span class="line-new-header">--- 900,18 ---</span>
              }
              return calendarToFieldMapping[calendarField];
          }
  
          /**
<span class="line-modified">!          * Creates a {@code Field}.</span>
           *
<span class="line-modified">!          * @param name the name of the {@code Field}</span>
<span class="line-modified">!          * @param calendarField the {@code Calendar} constant this</span>
<span class="line-modified">!          *        {@code Field} corresponds to; any value, even one</span>
<span class="line-modified">!          *        outside the range of legal {@code Calendar} values may</span>
<span class="line-modified">!          *        be used, but {@code -1} should be used for values</span>
<span class="line-modified">!          *        that don&#39;t correspond to legal {@code Calendar} values</span>
           */
          protected Field(String name, int calendarField) {
              super(name);
              this.calendarField = calendarField;
              if (this.getClass() == DateFormat.Field.class) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 920,15 ***</span>
                  }
              }
          }
  
          /**
<span class="line-modified">!          * Returns the &lt;code&gt;Calendar&lt;/code&gt; field associated with this</span>
           * attribute. For example, if this represents the hours field of
<span class="line-modified">!          * a &lt;code&gt;Calendar&lt;/code&gt;, this would return</span>
<span class="line-modified">!          * &lt;code&gt;Calendar.HOUR&lt;/code&gt;. If there is no corresponding</span>
<span class="line-modified">!          * &lt;code&gt;Calendar&lt;/code&gt; constant, this will return -1.</span>
           *
           * @return Calendar constant for this field
           * @see java.util.Calendar
           */
          public int getCalendarField() {
<span class="line-new-header">--- 922,15 ---</span>
                  }
              }
          }
  
          /**
<span class="line-modified">!          * Returns the {@code Calendar} field associated with this</span>
           * attribute. For example, if this represents the hours field of
<span class="line-modified">!          * a {@code Calendar}, this would return</span>
<span class="line-modified">!          * {@code Calendar.HOUR}. If there is no corresponding</span>
<span class="line-modified">!          * {@code Calendar} constant, this will return -1.</span>
           *
           * @return Calendar constant for this field
           * @see java.util.Calendar
           */
          public int getCalendarField() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 941,10 ***</span>
<span class="line-new-header">--- 943,11 ---</span>
           * @throws InvalidObjectException if the constant could not be
           *         resolved.
           * @return resolved DateFormat.Field constant
           */
          @Override
<span class="line-added">+         @java.io.Serial</span>
          protected Object readResolve() throws InvalidObjectException {
              if (this.getClass() != DateFormat.Field.class) {
                  throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
              }
  
</pre>
<center><a href="CompactNumberFormat.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormatSymbols.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
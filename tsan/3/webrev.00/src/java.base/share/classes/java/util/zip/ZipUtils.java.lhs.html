<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/zip/ZipUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.nio.ByteBuffer;
 29 import java.nio.file.attribute.FileTime;
<a name="2" id="anc2"></a><span class="line-removed"> 30 import java.security.AccessController;</span>
<span class="line-removed"> 31 import java.security.PrivilegedAction;</span>
 32 import java.time.DateTimeException;
 33 import java.time.Instant;
 34 import java.time.LocalDateTime;
 35 import java.time.ZoneId;
 36 import java.util.Date;
 37 import java.util.concurrent.TimeUnit;
 38 
 39 import static java.util.zip.ZipConstants.ENDHDR;
 40 
 41 import jdk.internal.misc.Unsafe;
 42 
 43 class ZipUtils {
 44 
 45     // used to adjust values between Windows and java epoch
 46     private static final long WINDOWS_EPOCH_IN_MICROSECONDS = -11644473600000000L;
 47 
 48     // used to indicate the corresponding windows time is not available
 49     public static final long WINDOWS_TIME_NOT_AVAILABLE = Long.MIN_VALUE;
 50 
 51     // static final ByteBuffer defaultBuf = ByteBuffer.allocateDirect(0);
 52     static final ByteBuffer defaultBuf = ByteBuffer.allocate(0);
 53 
 54     /**
 55      * Converts Windows time (in microseconds, UTC/GMT) time to FileTime.
 56      */
 57     public static final FileTime winTimeToFileTime(long wtime) {
 58         return FileTime.from(wtime / 10 + WINDOWS_EPOCH_IN_MICROSECONDS,
 59                              TimeUnit.MICROSECONDS);
 60     }
 61 
 62     /**
 63      * Converts FileTime to Windows time.
 64      */
 65     public static final long fileTimeToWinTime(FileTime ftime) {
 66         return (ftime.to(TimeUnit.MICROSECONDS) - WINDOWS_EPOCH_IN_MICROSECONDS) * 10;
 67     }
 68 
 69     /**
 70      * The upper bound of the 32-bit unix time, the &quot;year 2038 problem&quot;.
 71      */
 72     public static final long UPPER_UNIXTIME_BOUND = 0x7fffffff;
 73 
 74     /**
 75      * Converts &quot;standard Unix time&quot;(in seconds, UTC/GMT) to FileTime
 76      */
 77     public static final FileTime unixTimeToFileTime(long utime) {
 78         return FileTime.from(utime, TimeUnit.SECONDS);
 79     }
 80 
 81     /**
 82      * Converts FileTime to &quot;standard Unix time&quot;.
 83      */
 84     public static final long fileTimeToUnixTime(FileTime ftime) {
 85         return ftime.to(TimeUnit.SECONDS);
 86     }
 87 
 88     /**
 89      * Converts DOS time to Java time (number of milliseconds since epoch).
 90      */
 91     public static long dosToJavaTime(long dtime) {
 92         int year = (int) (((dtime &gt;&gt; 25) &amp; 0x7f) + 1980);
 93         int month = (int) ((dtime &gt;&gt; 21) &amp; 0x0f);
 94         int day = (int) ((dtime &gt;&gt; 16) &amp; 0x1f);
 95         int hour = (int) ((dtime &gt;&gt; 11) &amp; 0x1f);
 96         int minute = (int) ((dtime &gt;&gt; 5) &amp; 0x3f);
 97         int second = (int) ((dtime &lt;&lt; 1) &amp; 0x3e);
 98 
 99         if (month &gt; 0 &amp;&amp; month &lt; 13 &amp;&amp; day &gt; 0 &amp;&amp; hour &lt; 24 &amp;&amp; minute &lt; 60 &amp;&amp; second &lt; 60) {
100             try {
101                 LocalDateTime ldt = LocalDateTime.of(year, month, day, hour, minute, second);
102                 return TimeUnit.MILLISECONDS.convert(ldt.toEpochSecond(
103                         ZoneId.systemDefault().getRules().getOffset(ldt)), TimeUnit.SECONDS);
104             } catch (DateTimeException dte) {
105                 // ignore
106             }
107         }
108         return overflowDosToJavaTime(year, month, day, hour, minute, second);
109     }
110 
111     /*
112      * Deal with corner cases where an arguably mal-formed DOS time is used
113      */
114     @SuppressWarnings(&quot;deprecation&quot;) // Use of Date constructor
115     private static long overflowDosToJavaTime(int year, int month, int day,
116                                               int hour, int minute, int second) {
117         return new Date(year - 1900, month - 1, day, hour, minute, second).getTime();
118     }
119 
120 
121     /**
122      * Converts extended DOS time to Java time, where up to 1999 milliseconds
123      * might be encoded into the upper half of the returned long.
124      *
125      * @param xdostime the extended DOS time value
126      * @return milliseconds since epoch
127      */
128     public static long extendedDosToJavaTime(long xdostime) {
129         long time = dosToJavaTime(xdostime);
130         return time + (xdostime &gt;&gt; 32);
131     }
132 
133     /**
134      * Converts Java time to DOS time.
135      */
136     private static long javaToDosTime(long time) {
137         Instant instant = Instant.ofEpochMilli(time);
138         LocalDateTime ldt = LocalDateTime.ofInstant(
139                 instant, ZoneId.systemDefault());
140         int year = ldt.getYear() - 1980;
141         if (year &lt; 0) {
142             return (1 &lt;&lt; 21) | (1 &lt;&lt; 16);
143         }
144         return (year &lt;&lt; 25 |
145             ldt.getMonthValue() &lt;&lt; 21 |
146             ldt.getDayOfMonth() &lt;&lt; 16 |
147             ldt.getHour() &lt;&lt; 11 |
148             ldt.getMinute() &lt;&lt; 5 |
149             ldt.getSecond() &gt;&gt; 1) &amp; 0xffffffffL;
150     }
151 
152     /**
153      * Converts Java time to DOS time, encoding any milliseconds lost
154      * in the conversion into the upper half of the returned long.
155      *
156      * @param time milliseconds since epoch
157      * @return DOS time with 2s remainder encoded into upper half
158      */
159     public static long javaToExtendedDosTime(long time) {
160         if (time &lt; 0) {
161             return ZipEntry.DOSTIME_BEFORE_1980;
162         }
163         long dostime = javaToDosTime(time);
164         return (dostime != ZipEntry.DOSTIME_BEFORE_1980)
165                 ? dostime + ((time % 2000) &lt;&lt; 32)
166                 : ZipEntry.DOSTIME_BEFORE_1980;
167     }
168 
169     /**
170      * Fetches unsigned 16-bit value from byte array at specified offset.
171      * The bytes are assumed to be in Intel (little-endian) byte order.
172      */
173     public static final int get16(byte b[], int off) {
174         return (b[off] &amp; 0xff) | ((b[off + 1] &amp; 0xff) &lt;&lt; 8);
175     }
176 
177     /**
178      * Fetches unsigned 32-bit value from byte array at specified offset.
179      * The bytes are assumed to be in Intel (little-endian) byte order.
180      */
181     public static final long get32(byte b[], int off) {
182         return (get16(b, off) | ((long)get16(b, off+2) &lt;&lt; 16)) &amp; 0xffffffffL;
183     }
184 
185     /**
186      * Fetches signed 64-bit value from byte array at specified offset.
187      * The bytes are assumed to be in Intel (little-endian) byte order.
188      */
189     public static final long get64(byte b[], int off) {
190         return get32(b, off) | (get32(b, off+4) &lt;&lt; 32);
191     }
192 
193     /**
194      * Fetches signed 32-bit value from byte array at specified offset.
195      * The bytes are assumed to be in Intel (little-endian) byte order.
196      *
197      */
198     public static final int get32S(byte b[], int off) {
199         return (get16(b, off) | (get16(b, off+2) &lt;&lt; 16));
200     }
201 
202     // fields access methods
203     static final int CH(byte[] b, int n) {
204         return b[n] &amp; 0xff ;
205     }
206 
207     static final int SH(byte[] b, int n) {
208         return (b[n] &amp; 0xff) | ((b[n + 1] &amp; 0xff) &lt;&lt; 8);
209     }
210 
211     static final long LG(byte[] b, int n) {
212         return ((SH(b, n)) | (SH(b, n + 2) &lt;&lt; 16)) &amp; 0xffffffffL;
213     }
214 
215     static final long LL(byte[] b, int n) {
216         return (LG(b, n)) | (LG(b, n + 4) &lt;&lt; 32);
217     }
218 
219     static final long GETSIG(byte[] b) {
220         return LG(b, 0);
221     }
222 
223     // local file (LOC) header fields
224     static final long LOCSIG(byte[] b) { return LG(b, 0); } // signature
225     static final int  LOCVER(byte[] b) { return SH(b, 4); } // version needed to extract
226     static final int  LOCFLG(byte[] b) { return SH(b, 6); } // general purpose bit flags
227     static final int  LOCHOW(byte[] b) { return SH(b, 8); } // compression method
228     static final long LOCTIM(byte[] b) { return LG(b, 10);} // modification time
229     static final long LOCCRC(byte[] b) { return LG(b, 14);} // crc of uncompressed data
230     static final long LOCSIZ(byte[] b) { return LG(b, 18);} // compressed data size
231     static final long LOCLEN(byte[] b) { return LG(b, 22);} // uncompressed data size
232     static final int  LOCNAM(byte[] b) { return SH(b, 26);} // filename length
233     static final int  LOCEXT(byte[] b) { return SH(b, 28);} // extra field length
234 
235     // extra local (EXT) header fields
236     static final long EXTCRC(byte[] b) { return LG(b, 4);}  // crc of uncompressed data
237     static final long EXTSIZ(byte[] b) { return LG(b, 8);}  // compressed size
238     static final long EXTLEN(byte[] b) { return LG(b, 12);} // uncompressed size
239 
240     // end of central directory header (END) fields
241     static final int  ENDSUB(byte[] b) { return SH(b, 8); }  // number of entries on this disk
242     static final int  ENDTOT(byte[] b) { return SH(b, 10);}  // total number of entries
243     static final long ENDSIZ(byte[] b) { return LG(b, 12);}  // central directory size
244     static final long ENDOFF(byte[] b) { return LG(b, 16);}  // central directory offset
245     static final int  ENDCOM(byte[] b) { return SH(b, 20);}  // size of zip file comment
246     static final int  ENDCOM(byte[] b, int off) { return SH(b, off + 20);}
247 
248     // zip64 end of central directory recoder fields
249     static final long ZIP64_ENDTOD(byte[] b) { return LL(b, 24);}  // total number of entries on disk
250     static final long ZIP64_ENDTOT(byte[] b) { return LL(b, 32);}  // total number of entries
251     static final long ZIP64_ENDSIZ(byte[] b) { return LL(b, 40);}  // central directory size
252     static final long ZIP64_ENDOFF(byte[] b) { return LL(b, 48);}  // central directory offset
253     static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   // zip64 end offset
254 
255     // central directory header (CEN) fields
256     static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }
257     static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }
258     static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }
259     static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }
260     static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}
261     static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}
262     static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}
263     static final long CENSIZ(byte[] b, int pos) { return LG(b, pos + 20);}
264     static final long CENLEN(byte[] b, int pos) { return LG(b, pos + 24);}
265     static final int  CENNAM(byte[] b, int pos) { return SH(b, pos + 28);}
266     static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}
267     static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}
268     static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}
269     static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}
270     static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}
271     static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}
272 
273     // The END header is followed by a variable length comment of size &lt; 64k.
274     static final long END_MAXLEN = 0xFFFF + ENDHDR;
275     static final int READBLOCKSZ = 128;
276 
277     /**
278      * Loads zip native library, if not already laoded
279      */
280     static void loadLibrary() {
<a name="3" id="anc3"></a><span class="line-modified">281         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-removed">282         if (sm == null) {</span>
<span class="line-removed">283             System.loadLibrary(&quot;zip&quot;);</span>
<span class="line-removed">284         } else {</span>
<span class="line-removed">285             PrivilegedAction&lt;Void&gt; pa = () -&gt; { System.loadLibrary(&quot;zip&quot;); return null; };</span>
<span class="line-removed">286             AccessController.doPrivileged(pa);</span>
<span class="line-removed">287         }</span>
288     }
289 
290     private static final Unsafe unsafe = Unsafe.getUnsafe();
291 
292     private static final long byteBufferArrayOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;hb&quot;);
293     private static final long byteBufferOffsetOffset = unsafe.objectFieldOffset(ByteBuffer.class, &quot;offset&quot;);
294 
295     static byte[] getBufferArray(ByteBuffer byteBuffer) {
296         return (byte[]) unsafe.getReference(byteBuffer, byteBufferArrayOffset);
297     }
298 
299     static int getBufferOffset(ByteBuffer byteBuffer) {
300         return unsafe.getInt(byteBuffer, byteBufferOffsetOffset);
301     }
302 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
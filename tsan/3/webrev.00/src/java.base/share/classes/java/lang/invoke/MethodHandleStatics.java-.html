<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/MethodHandleStatics.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.misc.Unsafe;
 29 import sun.security.action.GetPropertyAction;
 30 
 31 import java.util.Properties;
 32 
 33 /**
 34  * This class consists exclusively of static names internal to the
 35  * method handle implementation.
 36  * Usage:  {@code import static java.lang.invoke.MethodHandleStatics.*}
 37  * @author John Rose, JSR 292 EG
 38  */
 39 /*non-public*/ class MethodHandleStatics {
 40 
 41     private MethodHandleStatics() { }  // do not instantiate
 42 
 43     static final Unsafe UNSAFE = Unsafe.getUnsafe();
 44 
 45     static final boolean DEBUG_METHOD_HANDLE_NAMES;
 46     static final boolean DUMP_CLASS_FILES;
 47     static final boolean TRACE_INTERPRETER;
 48     static final boolean TRACE_METHOD_LINKAGE;
 49     static final boolean TRACE_RESOLVE;
 50     static final int COMPILE_THRESHOLD;
 51     static final boolean LOG_LF_COMPILATION_FAILURE;
 52     static final int DONT_INLINE_THRESHOLD;
 53     static final int PROFILE_LEVEL;
 54     static final boolean PROFILE_GWT;
 55     static final int CUSTOMIZE_THRESHOLD;
 56     static final boolean VAR_HANDLE_GUARDS;
 57     static final int MAX_ARITY;
 58 
 59     static {
 60         Properties props = GetPropertyAction.privilegedGetProperties();
 61         DEBUG_METHOD_HANDLE_NAMES = Boolean.parseBoolean(
 62                 props.getProperty(&quot;java.lang.invoke.MethodHandle.DEBUG_NAMES&quot;));
 63         DUMP_CLASS_FILES = Boolean.parseBoolean(
 64                 props.getProperty(&quot;java.lang.invoke.MethodHandle.DUMP_CLASS_FILES&quot;));
 65         TRACE_INTERPRETER = Boolean.parseBoolean(
 66                 props.getProperty(&quot;java.lang.invoke.MethodHandle.TRACE_INTERPRETER&quot;));
 67         TRACE_METHOD_LINKAGE = Boolean.parseBoolean(
 68                 props.getProperty(&quot;java.lang.invoke.MethodHandle.TRACE_METHOD_LINKAGE&quot;));
 69         TRACE_RESOLVE = Boolean.parseBoolean(
 70                 props.getProperty(&quot;java.lang.invoke.MethodHandle.TRACE_RESOLVE&quot;));
 71         COMPILE_THRESHOLD = Integer.parseInt(
 72                 props.getProperty(&quot;java.lang.invoke.MethodHandle.COMPILE_THRESHOLD&quot;, &quot;0&quot;));
 73         LOG_LF_COMPILATION_FAILURE = Boolean.parseBoolean(
 74                 props.getProperty(&quot;java.lang.invoke.MethodHandle.LOG_LF_COMPILATION_FAILURE&quot;, &quot;false&quot;));
 75         DONT_INLINE_THRESHOLD = Integer.parseInt(
 76                 props.getProperty(&quot;java.lang.invoke.MethodHandle.DONT_INLINE_THRESHOLD&quot;, &quot;30&quot;));
 77         PROFILE_LEVEL = Integer.parseInt(
 78                 props.getProperty(&quot;java.lang.invoke.MethodHandle.PROFILE_LEVEL&quot;, &quot;0&quot;));
 79         PROFILE_GWT = Boolean.parseBoolean(
 80                 props.getProperty(&quot;java.lang.invoke.MethodHandle.PROFILE_GWT&quot;, &quot;true&quot;));
 81         CUSTOMIZE_THRESHOLD = Integer.parseInt(
 82                 props.getProperty(&quot;java.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD&quot;, &quot;127&quot;));
 83         VAR_HANDLE_GUARDS = Boolean.parseBoolean(
 84                 props.getProperty(&quot;java.lang.invoke.VarHandle.VAR_HANDLE_GUARDS&quot;, &quot;true&quot;));
 85 
 86         // Do not adjust this except for special platforms:
 87         MAX_ARITY = Integer.parseInt(
 88                 props.getProperty(&quot;java.lang.invoke.MethodHandleImpl.MAX_ARITY&quot;, &quot;255&quot;));
 89 
 90         if (CUSTOMIZE_THRESHOLD &lt; -1 || CUSTOMIZE_THRESHOLD &gt; 127) {
 91             throw newInternalError(&quot;CUSTOMIZE_THRESHOLD should be in [-1...127] range&quot;);
 92         }
 93     }
 94 
 95     /** Tell if any of the debugging switches are turned on.
 96      *  If this is the case, it is reasonable to perform extra checks or save extra information.
 97      */
 98     /*non-public*/ static boolean debugEnabled() {
 99         return (DEBUG_METHOD_HANDLE_NAMES |
100                 DUMP_CLASS_FILES |
101                 TRACE_INTERPRETER |
102                 TRACE_METHOD_LINKAGE |
103                 LOG_LF_COMPILATION_FAILURE);
104     }
105 
106     // handy shared exception makers (they simplify the common case code)
107     /*non-public*/ static InternalError newInternalError(String message) {
108         return new InternalError(message);
109     }
110     /*non-public*/ static InternalError newInternalError(String message, Exception cause) {
111         return new InternalError(message, cause);
112     }
113     /*non-public*/ static InternalError newInternalError(Exception cause) {
114         return new InternalError(cause);
115     }
116     /*non-public*/ static RuntimeException newIllegalStateException(String message) {
117         return new IllegalStateException(message);
118     }
119     /*non-public*/ static RuntimeException newIllegalStateException(String message, Object obj) {
120         return new IllegalStateException(message(message, obj));
121     }
122     /*non-public*/ static RuntimeException newIllegalArgumentException(String message) {
123         return new IllegalArgumentException(message);
124     }
125     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj) {
126         return new IllegalArgumentException(message(message, obj));
127     }
128     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj, Object obj2) {
129         return new IllegalArgumentException(message(message, obj, obj2));
130     }
131     /** Propagate unchecked exceptions and errors, but wrap anything checked and throw that instead. */
132     /*non-public*/ static Error uncaughtException(Throwable ex) {
133         if (ex instanceof Error)  throw (Error) ex;
134         if (ex instanceof RuntimeException)  throw (RuntimeException) ex;
135         throw new InternalError(&quot;uncaught exception&quot;, ex);
136     }
137     private static String message(String message, Object obj) {
138         if (obj != null)  message = message + &quot;: &quot; + obj;
139         return message;
140     }
141     private static String message(String message, Object obj, Object obj2) {
142         if (obj != null || obj2 != null)  message = message + &quot;: &quot; + obj + &quot;, &quot; + obj2;
143         return message;
144     }
145     /*non-public*/ static void rangeCheck2(int start, int end, int size) {
146         if (0 &gt; start || start &gt; end || end &gt; size)
147             throw new IndexOutOfBoundsException(start+&quot;..&quot;+end);
148     }
149     /*non-public*/ static int rangeCheck1(int index, int size) {
150         if (0 &gt; index || index &gt;= size)
151             throw new IndexOutOfBoundsException(index);
152         return index;
153     }
154 }
    </pre>
  </body>
</html>
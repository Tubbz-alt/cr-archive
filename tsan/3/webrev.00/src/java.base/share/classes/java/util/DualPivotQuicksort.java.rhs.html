<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/DualPivotQuicksort.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
<a name="2" id="anc2"></a><span class="line-added">  28 import java.util.concurrent.CountedCompleter;</span>
<span class="line-added">  29 import java.util.concurrent.RecursiveTask;</span>
<span class="line-added">  30 </span>
  31 /**
<a name="3" id="anc3"></a><span class="line-modified">  32  * This class implements powerful and fully optimized versions, both</span>
<span class="line-modified">  33  * sequential and parallel, of the Dual-Pivot Quicksort algorithm by</span>
<span class="line-modified">  34  * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified">  35  * offers O(n log(n)) performance on all data sets, and is typically</span>
  36  * faster than traditional (one-pivot) Quicksort implementations.
  37  *
<a name="4" id="anc4"></a><span class="line-modified">  38  * There are also additional algorithms, invoked from the Dual-Pivot</span>
<span class="line-modified">  39  * Quicksort, such as mixed insertion sort, merging of runs and heap</span>
<span class="line-modified">  40  * sort, counting sort and parallel merge sort.</span>

  41  *
  42  * @author Vladimir Yaroslavskiy
  43  * @author Jon Bentley
  44  * @author Josh Bloch
<a name="5" id="anc5"></a><span class="line-added">  45  * @author Doug Lea</span>
<span class="line-added">  46  *</span>
<span class="line-added">  47  * @version 2018.08.18</span>
  48  *
<a name="6" id="anc6"></a><span class="line-modified">  49  * @since 1.7 * 14</span>

  50  */
  51 final class DualPivotQuicksort {
  52 
  53     /**
  54      * Prevents instantiation.
  55      */
  56     private DualPivotQuicksort() {}
  57 
<a name="7" id="anc7"></a><span class="line-modified">  58     /**</span>
<span class="line-modified">  59      * Max array size to use mixed insertion sort.</span>
  60      */
<a name="8" id="anc8"></a><span class="line-added">  61     private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;</span>
  62 
  63     /**
<a name="9" id="anc9"></a><span class="line-modified">  64      * Max array size to use insertion sort.</span>
  65      */
<a name="10" id="anc10"></a><span class="line-modified">  66     private static final int MAX_INSERTION_SORT_SIZE = 44;</span>
  67 
  68     /**
<a name="11" id="anc11"></a><span class="line-modified">  69      * Min array size to perform sorting in parallel.</span>

  70      */
<a name="12" id="anc12"></a><span class="line-modified">  71     private static final int MIN_PARALLEL_SORT_SIZE = 4 &lt;&lt; 10;</span>
  72 
  73     /**
<a name="13" id="anc13"></a><span class="line-modified">  74      * Min array size to try merging of runs.</span>

  75      */
<a name="14" id="anc14"></a><span class="line-modified">  76     private static final int MIN_TRY_MERGE_SIZE = 4 &lt;&lt; 10;</span>
  77 
  78     /**
<a name="15" id="anc15"></a><span class="line-modified">  79      * Min size of the first run to continue with scanning.</span>

  80      */
<a name="16" id="anc16"></a><span class="line-modified">  81     private static final int MIN_FIRST_RUN_SIZE = 16;</span>
  82 
  83     /**
<a name="17" id="anc17"></a><span class="line-modified">  84      * Min factor for the first runs to continue scanning.</span>

  85      */
<a name="18" id="anc18"></a><span class="line-modified">  86     private static final int MIN_FIRST_RUNS_FACTOR = 7;</span>
  87 
<a name="19" id="anc19"></a><span class="line-modified">  88     /**</span>
<span class="line-modified">  89      * Max capacity of the index array for tracking runs.</span>
  90      */
<a name="20" id="anc20"></a><span class="line-added">  91     private static final int MAX_RUN_CAPACITY = 5 &lt;&lt; 10;</span>
  92 
  93     /**
<a name="21" id="anc21"></a><span class="line-modified">  94      * Min number of runs, required by parallel merging.</span>
<span class="line-modified">  95      */</span>
<span class="line-modified">  96     private static final int MIN_RUN_COUNT = 4;</span>














  97 
<a name="22" id="anc22"></a><span class="line-modified">  98     /**</span>
<span class="line-modified">  99      * Min array size to use parallel merging of parts.</span>
<span class="line-modified"> 100      */</span>
<span class="line-modified"> 101     private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 &lt;&lt; 10;</span>


 102 
<a name="23" id="anc23"></a><span class="line-modified"> 103     /**</span>
<span class="line-modified"> 104      * Min size of a byte array to use counting sort.</span>
<span class="line-modified"> 105      */</span>
<span class="line-modified"> 106     private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;</span>











 107 
<a name="24" id="anc24"></a><span class="line-modified"> 108     /**</span>
<span class="line-modified"> 109      * Min size of a short or char array to use counting sort.</span>
<span class="line-modified"> 110      */</span>
<span class="line-modified"> 111     private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;</span>

 112 
<a name="25" id="anc25"></a><span class="line-modified"> 113     /**</span>
<span class="line-modified"> 114      * Threshold of mixed insertion sort is incremented by this value.</span>
<span class="line-modified"> 115      */</span>
<span class="line-modified"> 116     private static final int DELTA = 3 &lt;&lt; 1;</span>





 117 
<a name="26" id="anc26"></a><span class="line-modified"> 118     /**</span>
<span class="line-modified"> 119      * Max recursive partitioning depth before using heap sort.</span>
<span class="line-modified"> 120      */</span>
<span class="line-added"> 121     private static final int MAX_RECURSION_DEPTH = 64 * DELTA;</span>
 122 
<a name="27" id="anc27"></a><span class="line-modified"> 123     /**</span>
<span class="line-modified"> 124      * Calculates the double depth of parallel merging.</span>
<span class="line-modified"> 125      * Depth is negative, if tasks split before sorting.</span>
<span class="line-modified"> 126      *</span>
<span class="line-modified"> 127      * @param parallelism the parallelism level</span>
<span class="line-modified"> 128      * @param size the target size</span>
<span class="line-modified"> 129      * @return the depth of parallel merging</span>
<span class="line-modified"> 130      */</span>
<span class="line-modified"> 131     private static int getDepth(int parallelism, int size) {</span>
<span class="line-modified"> 132         int depth = 0;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134         while ((parallelism &gt;&gt;= 3) &gt; 0 &amp;&amp; (size &gt;&gt;= 2) &gt; 0) {</span>
<span class="line-modified"> 135             depth -= 2;</span>


















































 136         }
<a name="28" id="anc28"></a><span class="line-added"> 137         return depth;</span>
 138     }
 139 
 140     /**
<a name="29" id="anc29"></a><span class="line-modified"> 141      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added"> 142      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added"> 143      *</span>
<span class="line-added"> 144      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added"> 145      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added"> 146      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added"> 147      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added"> 148      * parallelism to process the partitions.</span>
 149      *
 150      * @param a the array to be sorted
<a name="30" id="anc30"></a><span class="line-modified"> 151      * @param parallelism the parallelism level</span>
<span class="line-modified"> 152      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 153      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 154      */</span>
<span class="line-modified"> 155     static void sort(int[] a, int parallelism, int low, int high) {</span>
<span class="line-modified"> 156         int size = high - low;</span>






















































 157 
<a name="31" id="anc31"></a><span class="line-modified"> 158         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-modified"> 159             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-modified"> 160             int[] b = depth == 0 ? null : new int[size];</span>
<span class="line-modified"> 161             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-modified"> 162         } else {</span>
<span class="line-modified"> 163             sort(null, a, 0, low, high);</span>
 164         }
<a name="32" id="anc32"></a><span class="line-added"> 165     }</span>
 166 
<a name="33" id="anc33"></a><span class="line-modified"> 167     /**</span>
<span class="line-modified"> 168      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-modified"> 169      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-modified"> 170      *</span>
<span class="line-modified"> 171      * @param sorter parallel context</span>
<span class="line-modified"> 172      * @param a the array to be sorted</span>
<span class="line-modified"> 173      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-modified"> 174      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-modified"> 175      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 176      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 177      */</span>
<span class="line-modified"> 178     static void sort(Sorter sorter, int[] a, int bits, int low, int high) {</span>
<span class="line-modified"> 179         while (true) {</span>
<span class="line-modified"> 180             int end = high - 1, size = high - low;</span>




 181 
<a name="34" id="anc34"></a><span class="line-modified"> 182             /*</span>
<span class="line-modified"> 183              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-modified"> 184              */</span>
<span class="line-modified"> 185             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified"> 186                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-modified"> 187                 return;</span>
 188             }
<a name="35" id="anc35"></a><span class="line-modified"> 189 </span>
<span class="line-modified"> 190             /*</span>
<span class="line-modified"> 191              * Invoke insertion sort on small leftmost part.</span>
<span class="line-modified"> 192              */</span>
<span class="line-modified"> 193             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-modified"> 194                 insertionSort(a, low, high);</span>
<span class="line-added"> 195                 return;</span>
 196             }
<a name="36" id="anc36"></a>
 197 
<a name="37" id="anc37"></a><span class="line-modified"> 198             /*</span>
<span class="line-modified"> 199              * Check if the whole array or large non-leftmost</span>
<span class="line-modified"> 200              * parts are nearly sorted and then merge runs.</span>
<span class="line-added"> 201              */</span>
<span class="line-added"> 202             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added"> 203                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added"> 204                 return;</span>
<span class="line-added"> 205             }</span>
 206 
<a name="38" id="anc38"></a>
 207             /*
<a name="39" id="anc39"></a><span class="line-modified"> 208              * Switch to heap sort if execution</span>
<span class="line-modified"> 209              * time is becoming quadratic.</span>

 210              */
<a name="40" id="anc40"></a><span class="line-modified"> 211             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-modified"> 212                 heapSort(a, low, high);</span>
<span class="line-added"> 213                 return;</span>
<span class="line-added"> 214             }</span>
 215 
 216             /*
<a name="41" id="anc41"></a><span class="line-modified"> 217              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-modified"> 218              * to select five sample elements and determine pivots.</span>


 219              */
<a name="42" id="anc42"></a><span class="line-modified"> 220             int step = (size &gt;&gt; 3) * 3 + 3;</span>

 221 
 222             /*
<a name="43" id="anc43"></a><span class="line-modified"> 223              * Five elements around (and including) the central element</span>
<span class="line-added"> 224              * will be used for pivot selection as described below. The</span>
<span class="line-added"> 225              * unequal choice of spacing these elements was empirically</span>
<span class="line-added"> 226              * determined to work well on a wide variety of inputs.</span>
 227              */
<a name="44" id="anc44"></a><span class="line-modified"> 228             int e1 = low + step;</span>
<span class="line-modified"> 229             int e5 = end - step;</span>
<span class="line-added"> 230             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 231             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 232             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 233             int a3 = a[e3];</span>
 234 
 235             /*
<a name="45" id="anc45"></a><span class="line-modified"> 236              * Sort these elements in place by the combination</span>
<span class="line-added"> 237              * of 4-element sorting network and insertion sort.</span>
 238              *
<a name="46" id="anc46"></a><span class="line-modified"> 239              *    5 ------o-----------o------------</span>
<span class="line-modified"> 240              *            |           |</span>
<span class="line-modified"> 241              *    4 ------|-----o-----o-----o------</span>
<span class="line-modified"> 242              *            |     |           |</span>
<span class="line-modified"> 243              *    2 ------o-----|-----o-----o------</span>
<span class="line-modified"> 244              *                  |     |</span>
<span class="line-modified"> 245              *    1 ------------o-----o------------</span>








 246              */
<a name="47" id="anc47"></a><span class="line-modified"> 247             if (a[e5] &lt; a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-modified"> 248             if (a[e4] &lt; a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 249             if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-modified"> 250             if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 251             if (a[e4] &lt; a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-modified"> 252 </span>
<span class="line-modified"> 253             if (a3 &lt; a[e2]) {</span>
<span class="line-modified"> 254                 if (a3 &lt; a[e1]) {</span>
<span class="line-modified"> 255                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-modified"> 256                 } else {</span>
<span class="line-modified"> 257                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-modified"> 258                 }</span>
<span class="line-modified"> 259             } else if (a3 &gt; a[e4]) {</span>
<span class="line-modified"> 260                 if (a3 &gt; a[e5]) {</span>
<span class="line-modified"> 261                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-modified"> 262                 } else {</span>
<span class="line-modified"> 263                     a[e3] = a[e4]; a[e4] = a3;</span>













 264                 }
 265             }
 266 
<a name="48" id="anc48"></a><span class="line-modified"> 267             // Pointers</span>
<span class="line-modified"> 268             int lower = low; // The index of the last element of the left part</span>
<span class="line-modified"> 269             int upper = end; // The index of the first element of the right part</span>




 270 
 271             /*
<a name="49" id="anc49"></a><span class="line-modified"> 272              * Partitioning with 2 pivots in case of different elements.</span>

 273              */
<a name="50" id="anc50"></a><span class="line-modified"> 274             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added"> 275 </span>
 276                 /*
<a name="51" id="anc51"></a><span class="line-modified"> 277                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added"> 278                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added"> 279                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
 280                  */
<a name="52" id="anc52"></a><span class="line-modified"> 281                 int pivot1 = a[e1];</span>
<span class="line-modified"> 282                 int pivot2 = a[e5];</span>

 283 
<a name="53" id="anc53"></a><span class="line-modified"> 284                 /*</span>
<span class="line-modified"> 285                  * The first and the last elements to be sorted are moved</span>
<span class="line-modified"> 286                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added"> 287                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added"> 288                  * into their final positions, and excluded from the next</span>
<span class="line-added"> 289                  * subsequent sorting.</span>
<span class="line-added"> 290                  */</span>
<span class="line-added"> 291                 a[e1] = a[lower];</span>
<span class="line-added"> 292                 a[e5] = a[upper];</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294                 /*</span>
<span class="line-added"> 295                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added"> 296                  */</span>
<span class="line-added"> 297                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added"> 298                 while (a[--upper] &gt; pivot2);</span>
 299 
 300                 /*
<a name="54" id="anc54"></a><span class="line-modified"> 301                  * Backward 3-interval partitioning</span>
 302                  *
<a name="55" id="anc55"></a><span class="line-modified"> 303                  *   left part                 central part          right part</span>
<span class="line-modified"> 304                  * +------------------------------------------------------------+</span>
<span class="line-modified"> 305                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-modified"> 306                  * +------------------------------------------------------------+</span>
<span class="line-modified"> 307                  *             ^       ^                            ^</span>
<span class="line-modified"> 308                  *             |       |                            |</span>
<span class="line-modified"> 309                  *           lower     k                          upper</span>
 310                  *
 311                  * Invariants:
 312                  *
<a name="56" id="anc56"></a><span class="line-modified"> 313                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-modified"> 314                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-modified"> 315                  *              all in [upper, end) &gt; pivot2</span>
 316                  *
<a name="57" id="anc57"></a><span class="line-modified"> 317                  * Pointer k is the last index of ?-part</span>
 318                  */
<a name="58" id="anc58"></a><span class="line-modified"> 319                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>

 320                     int ak = a[k];
<a name="59" id="anc59"></a><span class="line-modified"> 321 </span>
<span class="line-modified"> 322                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-modified"> 323                         while (lower &lt; k) {</span>
<span class="line-modified"> 324                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-modified"> 325                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-modified"> 326                                     a[k] = a[--upper];</span>
<span class="line-modified"> 327                                     a[upper] = a[lower];</span>
<span class="line-modified"> 328                                 } else {</span>
<span class="line-added"> 329                                     a[k] = a[lower];</span>
<span class="line-added"> 330                                 }</span>
<span class="line-added"> 331                                 a[lower] = ak;</span>
<span class="line-added"> 332                                 break;</span>
 333                             }
 334                         }
<a name="60" id="anc60"></a><span class="line-modified"> 335                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-modified"> 336                         a[k] = a[--upper];</span>
<span class="line-modified"> 337                         a[upper] = ak;</span>














 338                     }
 339                 }
<a name="61" id="anc61"></a>



 340 
<a name="62" id="anc62"></a><span class="line-modified"> 341                 /*</span>
<span class="line-modified"> 342                  * Swap the pivots into their final positions.</span>
<span class="line-modified"> 343                  */</span>
<span class="line-modified"> 344                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-modified"> 345                 a[end] = a[upper]; a[upper] = pivot2;</span>

 346 
<a name="63" id="anc63"></a><span class="line-modified"> 347                 /*</span>
<span class="line-modified"> 348                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-modified"> 349                  * excluding known pivots.</span>
<span class="line-modified"> 350                  */</span>
<span class="line-modified"> 351                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-modified"> 352                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-modified"> 353                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-modified"> 354                 } else {</span>
<span class="line-modified"> 355                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-modified"> 356                     sort(sorter, a, bits | 1, upper + 1, high);</span>








































 357                 }
<a name="64" id="anc64"></a>





























 358 
<a name="65" id="anc65"></a><span class="line-modified"> 359             } else { // Use single pivot in case of many equal elements</span>





 360 
<a name="66" id="anc66"></a><span class="line-modified"> 361                 /*</span>
<span class="line-modified"> 362                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-modified"> 363                  * This value is inexpensive approximation of the median.</span>
<span class="line-modified"> 364                  */</span>
<span class="line-modified"> 365                 int pivot = a[e3];</span>










 366 
<a name="67" id="anc67"></a><span class="line-modified"> 367                 /*</span>
<span class="line-modified"> 368                  * The first element to be sorted is moved to the</span>
<span class="line-modified"> 369                  * location formerly occupied by the pivot. After</span>
<span class="line-modified"> 370                  * completion of partitioning the pivot is swapped</span>
<span class="line-modified"> 371                  * back into its final position, and excluded from</span>
<span class="line-added"> 372                  * the next subsequent sorting.</span>
<span class="line-added"> 373                  */</span>
<span class="line-added"> 374                 a[e3] = a[lower];</span>
 375 
<a name="68" id="anc68"></a><span class="line-modified"> 376                 /*</span>
<span class="line-modified"> 377                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-modified"> 378                  *</span>
<span class="line-modified"> 379                  *   left part                 central part    right part</span>
<span class="line-modified"> 380                  * +------------------------------------------------------+</span>
<span class="line-modified"> 381                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-modified"> 382                  * +------------------------------------------------------+</span>
<span class="line-modified"> 383                  *              ^           ^                ^</span>
<span class="line-modified"> 384                  *              |           |                |</span>
<span class="line-added"> 385                  *            lower         k              upper</span>
<span class="line-added"> 386                  *</span>
<span class="line-added"> 387                  * Invariants:</span>
<span class="line-added"> 388                  *</span>
<span class="line-added"> 389                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added"> 390                  *   all in (k, upper)  == pivot</span>
<span class="line-added"> 391                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added"> 392                  *</span>
<span class="line-added"> 393                  * Pointer k is the last index of ?-part</span>
<span class="line-added"> 394                  */</span>
<span class="line-added"> 395                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added"> 396                     int ak = a[k];</span>
 397 
<a name="69" id="anc69"></a><span class="line-modified"> 398                     if (ak != pivot) {</span>
<span class="line-modified"> 399                         a[k] = pivot;</span>

 400 
<a name="70" id="anc70"></a><span class="line-modified"> 401                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-modified"> 402                             while (a[++lower] &lt; pivot);</span>































































 403 
<a name="71" id="anc71"></a><span class="line-modified"> 404                             if (a[lower] &gt; pivot) {</span>
<span class="line-modified"> 405                                 a[--upper] = a[lower];</span>
<span class="line-modified"> 406                             }</span>
<span class="line-modified"> 407                             a[lower] = ak;</span>
<span class="line-modified"> 408                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-modified"> 409                             a[--upper] = ak;</span>



















 410                         }
 411                     }
<a name="72" id="anc72"></a>
 412                 }
<a name="73" id="anc73"></a><span class="line-modified"> 413 </span>
 414                 /*
<a name="74" id="anc74"></a><span class="line-modified"> 415                  * Swap the pivot into its final position.</span>
 416                  */
<a name="75" id="anc75"></a><span class="line-modified"> 417                 a[low] = a[lower]; a[lower] = pivot;</span>




 418 
 419                 /*
<a name="76" id="anc76"></a><span class="line-modified"> 420                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-modified"> 421                  * known pivot. All elements from the central part are</span>
<span class="line-modified"> 422                  * equal and therefore already sorted.</span>



 423                  */
<a name="77" id="anc77"></a><span class="line-modified"> 424                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-modified"> 425                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-modified"> 426                 } else {</span>
<span class="line-modified"> 427                     sort(sorter, a, bits | 1, upper, high);</span>
















 428                 }
<a name="78" id="anc78"></a>
 429             }
<a name="79" id="anc79"></a><span class="line-modified"> 430             high = lower; // Iterate along the left part</span>
 431         }
<a name="80" id="anc80"></a><span class="line-added"> 432     }</span>
 433 
<a name="81" id="anc81"></a><span class="line-modified"> 434     /**</span>
<span class="line-modified"> 435      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-modified"> 436      *</span>
<span class="line-modified"> 437      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-modified"> 438      * pin insertion sort and pair insertion sort.</span>
<span class="line-modified"> 439      *</span>
<span class="line-modified"> 440      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-modified"> 441      * from the left part plays the role of sentinel, because it</span>
<span class="line-modified"> 442      * is less than any elements from the given part. Therefore,</span>
<span class="line-modified"> 443      * expensive check of the left range can be skipped on each</span>
<span class="line-modified"> 444      * iteration unless it is the leftmost call.</span>
<span class="line-modified"> 445      *</span>
<span class="line-modified"> 446      * @param a the array to be sorted</span>
<span class="line-modified"> 447      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 448      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added"> 449      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 450      */</span>
<span class="line-added"> 451     private static void mixedInsertionSort(int[] a, int low, int end, int high) {</span>
<span class="line-added"> 452         if (end == high) {</span>
 453 
<a name="82" id="anc82"></a><span class="line-modified"> 454             /*</span>
<span class="line-modified"> 455              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added"> 456              */</span>
<span class="line-added"> 457             for (int i; ++low &lt; end; ) {</span>
<span class="line-added"> 458                 int ai = a[i = low];</span>
 459 
<a name="83" id="anc83"></a><span class="line-modified"> 460                 while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 461                     a[i + 1] = a[i];</span>










 462                 }
<a name="84" id="anc84"></a><span class="line-added"> 463                 a[i + 1] = ai;</span>
 464             }
<a name="85" id="anc85"></a><span class="line-modified"> 465         } else {</span>




 466 
<a name="86" id="anc86"></a>
 467             /*
<a name="87" id="anc87"></a><span class="line-modified"> 468              * Start with pin insertion sort on small part.</span>
<span class="line-modified"> 469              *</span>
<span class="line-modified"> 470              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added"> 471              * The main idea of this sort is to put elements larger</span>
<span class="line-added"> 472              * than an element called pin to the end of array (the</span>
<span class="line-added"> 473              * proper area for such elements). It avoids expensive</span>
<span class="line-added"> 474              * movements of these elements through the whole array.</span>
 475              */
<a name="88" id="anc88"></a><span class="line-modified"> 476             int pin = a[end];</span>

 477 
<a name="89" id="anc89"></a><span class="line-modified"> 478             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified"> 479                 int ai = a[i = low];</span>






 480 
<a name="90" id="anc90"></a><span class="line-modified"> 481                 if (ai &lt; a[i - 1]) { // Small element</span>




 482 
<a name="91" id="anc91"></a>























 483                     /*
<a name="92" id="anc92"></a><span class="line-modified"> 484                      * Insert small element into sorted part.</span>

 485                      */
<a name="93" id="anc93"></a><span class="line-modified"> 486                     a[i] = a[--i];</span>
<span class="line-modified"> 487 </span>
<span class="line-modified"> 488                     while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 489                         a[i + 1] = a[i];</span>



 490                     }
<a name="94" id="anc94"></a><span class="line-modified"> 491                     a[i + 1] = ai;</span>
<span class="line-modified"> 492 </span>
<span class="line-modified"> 493                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-modified"> 494 </span>
<span class="line-modified"> 495                     /*</span>
<span class="line-modified"> 496                      * Find element smaller than pin.</span>
<span class="line-added"> 497                      */</span>
<span class="line-added"> 498                     while (a[--p] &gt; pin);</span>
<span class="line-added"> 499 </span>
<span class="line-added"> 500                     /*</span>
<span class="line-added"> 501                      * Swap it with large element.</span>
<span class="line-added"> 502                      */</span>
<span class="line-added"> 503                     if (p &gt; i) {</span>
<span class="line-added"> 504                         ai = a[p];</span>
<span class="line-added"> 505                         a[p] = a[i];</span>
 506                     }
<a name="95" id="anc95"></a><span class="line-added"> 507 </span>
 508                     /*
<a name="96" id="anc96"></a><span class="line-modified"> 509                      * Insert small element into sorted part.</span>

 510                      */
<a name="97" id="anc97"></a><span class="line-modified"> 511                     while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 512                         a[i + 1] = a[i];</span>
<span class="line-added"> 513                     }</span>
<span class="line-added"> 514                     a[i + 1] = ai;</span>
 515                 }
 516             }
 517 
<a name="98" id="anc98"></a>







 518             /*
<a name="99" id="anc99"></a><span class="line-modified"> 519              * Continue with pair insertion sort on remain part.</span>

 520              */
<a name="100" id="anc100"></a><span class="line-modified"> 521             for (int i; low &lt; high; ++low) {</span>
<span class="line-added"> 522                 int a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added"> 523 </span>
 524                 /*
<a name="101" id="anc101"></a><span class="line-modified"> 525                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added"> 526                  * larger element and then insert the smaller element, but</span>
<span class="line-added"> 527                  * from the position where the larger element was inserted.</span>
 528                  */
<a name="102" id="anc102"></a><span class="line-modified"> 529                 if (a1 &gt; a2) {</span>


 530 
<a name="103" id="anc103"></a><span class="line-modified"> 531                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified"> 532                         a[i + 2] = a[i];</span>
<span class="line-modified"> 533                     }</span>
<span class="line-added"> 534                     a[++i + 1] = a1;</span>
 535 
<a name="104" id="anc104"></a><span class="line-modified"> 536                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified"> 537                         a[i + 1] = a[i];</span>















































 538                     }
<a name="105" id="anc105"></a><span class="line-modified"> 539                     a[i + 1] = a2;</span>

 540 
<a name="106" id="anc106"></a><span class="line-modified"> 541                 } else if (a1 &lt; a[i - 1]) {</span>

 542 
<a name="107" id="anc107"></a><span class="line-modified"> 543                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified"> 544                         a[i + 2] = a[i];</span>





































 545                     }
<a name="108" id="anc108"></a><span class="line-modified"> 546                     a[++i + 1] = a2;</span>
<span class="line-modified"> 547 </span>
<span class="line-modified"> 548                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified"> 549                         a[i + 1] = a[i];</span>










 550                     }
<a name="109" id="anc109"></a><span class="line-modified"> 551                     a[i + 1] = a1;</span>

 552                 }
 553             }
<a name="110" id="anc110"></a>







 554         }
 555     }
 556 
 557     /**
<a name="111" id="anc111"></a><span class="line-modified"> 558      * Sorts the specified range of the array using insertion sort.</span>

 559      *
 560      * @param a the array to be sorted
<a name="112" id="anc112"></a><span class="line-modified"> 561      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 562      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 563      */</span>
<span class="line-modified"> 564     private static void insertionSort(int[] a, int low, int high) {</span>
<span class="line-modified"> 565         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-modified"> 566             int ai = a[i = k];</span>













 567 
<a name="113" id="anc113"></a><span class="line-modified"> 568             if (ai &lt; a[i - 1]) {</span>
<span class="line-modified"> 569                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-modified"> 570                     a[i + 1] = a[i];</span>
<span class="line-added"> 571                 }</span>
<span class="line-added"> 572                 a[i + 1] = ai;</span>
 573             }
<a name="114" id="anc114"></a>

 574         }
 575     }
 576 
<a name="115" id="anc115"></a>


 577     /**
<a name="116" id="anc116"></a><span class="line-modified"> 578      * Sorts the specified range of the array using heap sort.</span>
 579      *
 580      * @param a the array to be sorted
<a name="117" id="anc117"></a><span class="line-modified"> 581      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 582      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 583      */</span>
<span class="line-modified"> 584     private static void heapSort(int[] a, int low, int high) {</span>
<span class="line-modified"> 585         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified"> 586             pushDown(a, --k, a[k], low, high);</span>






 587         }
<a name="118" id="anc118"></a><span class="line-modified"> 588         while (--high &gt; low) {</span>
<span class="line-modified"> 589             int max = a[low];</span>
<span class="line-modified"> 590             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified"> 591             a[high] = max;</span>


































 592         }
<a name="119" id="anc119"></a><span class="line-added"> 593     }</span>
 594 
<a name="120" id="anc120"></a><span class="line-modified"> 595     /**</span>
<span class="line-modified"> 596      * Pushes specified element down during heap sort.</span>
<span class="line-modified"> 597      *</span>
<span class="line-added"> 598      * @param a the given array</span>
<span class="line-added"> 599      * @param p the start index</span>
<span class="line-added"> 600      * @param value the given element</span>
<span class="line-added"> 601      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 602      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 603      */</span>
<span class="line-added"> 604     private static void pushDown(int[] a, int p, int value, int low, int high) {</span>
<span class="line-added"> 605         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added"> 606             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
 607 
<a name="121" id="anc121"></a><span class="line-modified"> 608             if (k &gt; high) {</span>
<span class="line-modified"> 609                 break;</span>




















































 610             }
<a name="122" id="anc122"></a><span class="line-modified"> 611             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-modified"> 612                 --k;</span>
<span class="line-modified"> 613             }</span>
<span class="line-modified"> 614             if (a[k] &lt;= value) {</span>
<span class="line-modified"> 615                 break;</span>
 616             }
<a name="123" id="anc123"></a>

 617         }
<a name="124" id="anc124"></a><span class="line-added"> 618         a[p] = value;</span>
 619     }
 620 
 621     /**
<a name="125" id="anc125"></a><span class="line-modified"> 622      * Tries to sort the specified range of the array.</span>
 623      *
<a name="126" id="anc126"></a><span class="line-added"> 624      * @param sorter parallel context</span>
 625      * @param a the array to be sorted
<a name="127" id="anc127"></a><span class="line-modified"> 626      * @param low the index of the first element to be sorted</span>
<span class="line-modified"> 627      * @param size the array size</span>
<span class="line-modified"> 628      * @return true if finally sorted, false otherwise</span>
<span class="line-modified"> 629      */</span>
<span class="line-modified"> 630     private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {</span>





























 631 
<a name="128" id="anc128"></a><span class="line-modified"> 632         /*</span>
<span class="line-modified"> 633          * The run array is constructed only if initial runs are</span>
<span class="line-modified"> 634          * long enough to continue, run[i] then holds start index</span>
<span class="line-modified"> 635          * of the i-th sequence of elements in non-descending order.</span>
<span class="line-modified"> 636          */</span>
<span class="line-modified"> 637         int[] run = null;</span>
<span class="line-modified"> 638         int high = low + size;</span>
<span class="line-modified"> 639         int count = 1, last = low;</span>


 640 
<a name="129" id="anc129"></a><span class="line-modified"> 641         /*</span>
<span class="line-modified"> 642          * Identify all possible runs.</span>
<span class="line-modified"> 643          */</span>
<span class="line-modified"> 644         for (int k = low + 1; k &lt; high; ) {</span>



 645 
<a name="130" id="anc130"></a><span class="line-modified"> 646             /*</span>
<span class="line-modified"> 647              * Find the end index of the current run.</span>
<span class="line-modified"> 648              */</span>
<span class="line-modified"> 649             if (a[k - 1] &lt; a[k]) {</span>


 650 
<a name="131" id="anc131"></a><span class="line-modified"> 651                 // Identify ascending sequence</span>
<span class="line-modified"> 652                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>





 653 
<a name="132" id="anc132"></a><span class="line-modified"> 654             } else if (a[k - 1] &gt; a[k]) {</span>

 655 
<a name="133" id="anc133"></a><span class="line-modified"> 656                 // Identify descending sequence</span>
<span class="line-modified"> 657                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>










 658 
<a name="134" id="anc134"></a><span class="line-modified"> 659                 // Reverse into ascending order</span>
<span class="line-modified"> 660                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added"> 661                     int ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added"> 662                 }</span>
<span class="line-added"> 663             } else { // Identify constant sequence</span>
<span class="line-added"> 664                 for (int ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
 665 
<a name="135" id="anc135"></a><span class="line-modified"> 666                 if (k &lt; high) {</span>
<span class="line-modified"> 667                     continue;</span>










 668                 }
 669             }
<a name="136" id="anc136"></a>






















 670 
 671             /*
<a name="137" id="anc137"></a><span class="line-modified"> 672              * Check special cases.</span>
 673              */
<a name="138" id="anc138"></a><span class="line-modified"> 674             if (run == null) {</span>
<span class="line-modified"> 675                 if (k == high) {</span>
 676 
<a name="139" id="anc139"></a>























 677                     /*
<a name="140" id="anc140"></a><span class="line-modified"> 678                      * The array is monotonous sequence,</span>
<span class="line-modified"> 679                      * and therefore already sorted.</span>
 680                      */
<a name="141" id="anc141"></a><span class="line-modified"> 681                     return true;</span>
<span class="line-modified"> 682                 }</span>
<span class="line-modified"> 683 </span>
<span class="line-modified"> 684                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-modified"> 685 </span>










 686                     /*
<a name="142" id="anc142"></a><span class="line-modified"> 687                      * The first run is too small</span>
<span class="line-modified"> 688                      * to proceed with scanning.</span>
 689                      */
<a name="143" id="anc143"></a><span class="line-modified"> 690                     return false;</span>

 691                 }
<a name="144" id="anc144"></a>
 692 
<a name="145" id="anc145"></a><span class="line-modified"> 693                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-modified"> 694                 run[0] = low;</span>

 695 
<a name="146" id="anc146"></a><span class="line-modified"> 696             } else if (a[last - 1] &gt; a[last]) {</span>


 697 
<a name="147" id="anc147"></a><span class="line-modified"> 698                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>










 699 
<a name="148" id="anc148"></a><span class="line-modified"> 700                     /*</span>
<span class="line-modified"> 701                      * The first runs are not long</span>
<span class="line-added"> 702                      * enough to continue scanning.</span>
<span class="line-added"> 703                      */</span>
<span class="line-added"> 704                     return false;</span>
 705                 }
 706 
<a name="149" id="anc149"></a><span class="line-modified"> 707                 if (++count == MAX_RUN_CAPACITY) {</span>



















































 708 
<a name="150" id="anc150"></a><span class="line-modified"> 709                     /*</span>
<span class="line-modified"> 710                      * Array is not highly structured.</span>
<span class="line-added"> 711                      */</span>
<span class="line-added"> 712                     return false;</span>
<span class="line-added"> 713                 }</span>
 714 
<a name="151" id="anc151"></a><span class="line-modified"> 715                 if (count == run.length) {</span>





 716 
<a name="152" id="anc152"></a><span class="line-modified"> 717                     /*</span>
<span class="line-modified"> 718                      * Increase capacity of index array.</span>
<span class="line-modified"> 719                      */</span>
<span class="line-modified"> 720                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>














































 721                 }
 722             }
<a name="153" id="anc153"></a><span class="line-modified"> 723             run[count] = (last = k);</span>







 724         }
<a name="154" id="anc154"></a>
 725 
<a name="155" id="anc155"></a><span class="line-modified"> 726         /*</span>
<span class="line-modified"> 727          * Merge runs of highly structured array.</span>
<span class="line-modified"> 728          */</span>
<span class="line-modified"> 729         if (count &gt; 1) {</span>
<span class="line-modified"> 730             int[] b; int offset = low;</span>



















 731 
<a name="156" id="anc156"></a><span class="line-modified"> 732             if (sorter == null || (b = (int[]) sorter.b) == null) {</span>
<span class="line-modified"> 733                 b = new int[size];</span>
<span class="line-modified"> 734             } else {</span>
<span class="line-added"> 735                 offset = sorter.offset;</span>
 736             }
<a name="157" id="anc157"></a><span class="line-modified"> 737             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>

 738         }
<a name="158" id="anc158"></a><span class="line-added"> 739         return true;</span>
 740     }
 741 
<a name="159" id="anc159"></a>


 742     /**
<a name="160" id="anc160"></a><span class="line-modified"> 743      * Merges the specified runs.</span>
 744      *
<a name="161" id="anc161"></a><span class="line-modified"> 745      * @param a the source array</span>
<span class="line-modified"> 746      * @param b the temporary buffer used in merging</span>
<span class="line-modified"> 747      * @param offset the start index in the source, inclusive</span>
<span class="line-modified"> 748      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified"> 749      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified"> 750      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified"> 751      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified"> 752      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified"> 753      * @return the destination where runs are merged</span>
<span class="line-modified"> 754      */</span>
<span class="line-modified"> 755     private static int[] mergeRuns(int[] a, int[] b, int offset,</span>
<span class="line-modified"> 756             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified"> 757 </span>
<span class="line-added"> 758         if (hi - lo == 1) {</span>
<span class="line-added"> 759             if (aim &gt;= 0) {</span>
<span class="line-added"> 760                 return a;</span>
<span class="line-added"> 761             }</span>
<span class="line-added"> 762             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added"> 763                 b[--j] = a[--i]</span>
<span class="line-added"> 764             );</span>
<span class="line-added"> 765             return b;</span>
 766         }
 767 
 768         /*
<a name="162" id="anc162"></a><span class="line-modified"> 769          * Split into approximately equal parts.</span>

 770          */
<a name="163" id="anc163"></a><span class="line-modified"> 771         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified"> 772         while (run[++mi + 1] &lt;= rmi);</span>
















 773 
<a name="164" id="anc164"></a><span class="line-modified"> 774         /*</span>
<span class="line-modified"> 775          * Merge the left and right parts.</span>
<span class="line-modified"> 776          */</span>
<span class="line-modified"> 777         int[] a1, a2;</span>

 778 
<a name="165" id="anc165"></a><span class="line-modified"> 779         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified"> 780             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified"> 781             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified"> 782             a2 = (int[]) merger.getDestination();</span>
<span class="line-modified"> 783         } else {</span>
<span class="line-modified"> 784             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified"> 785             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

 786         }
 787 
<a name="166" id="anc166"></a><span class="line-modified"> 788         int[] dst = a1 == a ? b : a;</span>


 789 
<a name="167" id="anc167"></a><span class="line-modified"> 790         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified"> 791         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified"> 792         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified"> 793         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified"> 794         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified"> 795 </span>
<span class="line-modified"> 796         if (parallel) {</span>
<span class="line-modified"> 797             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























 798         } else {
<a name="168" id="anc168"></a><span class="line-modified"> 799             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























 800         }
<a name="169" id="anc169"></a><span class="line-added"> 801         return dst;</span>
 802     }
 803 
 804     /**
<a name="170" id="anc170"></a><span class="line-modified"> 805      * Merges the sorted parts.</span>
 806      *
<a name="171" id="anc171"></a><span class="line-modified"> 807      * @param merger parallel context</span>
<span class="line-modified"> 808      * @param dst the destination where parts are merged</span>
<span class="line-modified"> 809      * @param k the start index of the destination, inclusive</span>
<span class="line-modified"> 810      * @param a1 the first part</span>
<span class="line-modified"> 811      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified"> 812      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified"> 813      * @param a2 the second part</span>
<span class="line-modified"> 814      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified"> 815      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified"> 816      */</span>
<span class="line-modified"> 817     private static void mergeParts(Merger merger, int[] dst, int k,</span>
<span class="line-modified"> 818             int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {</span>
<span class="line-modified"> 819 </span>
<span class="line-modified"> 820         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified"> 821 </span>
<span class="line-modified"> 822             while (true) {</span>
<span class="line-modified"> 823 </span>
<span class="line-modified"> 824                 /*</span>
<span class="line-modified"> 825                  * The first part must be larger.</span>
<span class="line-modified"> 826                  */</span>
<span class="line-modified"> 827                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified"> 828                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified"> 829                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


 830                 }
<a name="172" id="anc172"></a><span class="line-modified"> 831 </span>
 832                 /*
<a name="173" id="anc173"></a><span class="line-modified"> 833                  * Small parts will be merged sequentially.</span>
 834                  */
<a name="174" id="anc174"></a><span class="line-modified"> 835                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified"> 836                     break;</span>
<span class="line-modified"> 837                 }</span>


 838 
 839                 /*
<a name="175" id="anc175"></a><span class="line-modified"> 840                  * Find the median of the larger part.</span>





 841                  */
<a name="176" id="anc176"></a><span class="line-modified"> 842                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified"> 843                 int key = a1[mi1];</span>
<span class="line-added"> 844                 int mi2 = hi2;</span>
 845 
<a name="177" id="anc177"></a><span class="line-modified"> 846                 /*</span>
<span class="line-modified"> 847                  * Partition the smaller part.</span>
<span class="line-modified"> 848                  */</span>
<span class="line-modified"> 849                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified"> 850                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


 851 
<a name="178" id="anc178"></a><span class="line-modified"> 852                     if (key &gt; a2[t]) {</span>
<span class="line-modified"> 853                         loo = t + 1;</span>
<span class="line-added"> 854                     } else {</span>
<span class="line-added"> 855                         mi2 = t;</span>
 856                     }
<a name="179" id="anc179"></a>
 857                 }
<a name="180" id="anc180"></a>
 858 
<a name="181" id="anc181"></a><span class="line-modified"> 859                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861                 /*</span>
<span class="line-modified"> 862                  * Merge the right sub-parts in parallel.</span>
<span class="line-added"> 863                  */</span>
<span class="line-added"> 864                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added"> 865 </span>
<span class="line-added"> 866                 /*</span>
<span class="line-added"> 867                  * Process the sub-left parts.</span>
<span class="line-added"> 868                  */</span>
<span class="line-added"> 869                 hi1 = mi1;</span>
<span class="line-added"> 870                 hi2 = mi2;</span>
 871             }
<a name="182" id="anc182"></a>
 872         }
 873 
<a name="183" id="anc183"></a>


 874         /*
<a name="184" id="anc184"></a><span class="line-modified"> 875          * Merge small parts sequentially.</span>




 876          */
<a name="185" id="anc185"></a><span class="line-modified"> 877         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified"> 878             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









 879         }
<a name="186" id="anc186"></a><span class="line-modified"> 880         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified"> 881             while (lo1 &lt; hi1) {</span>
<span class="line-modified"> 882                 dst[k++] = a1[lo1++];</span>
 883             }
 884         }
<a name="187" id="anc187"></a><span class="line-modified"> 885         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified"> 886             while (lo2 &lt; hi2) {</span>
<span class="line-modified"> 887                 dst[k++] = a2[lo2++];</span>


 888             }
 889         }
<a name="188" id="anc188"></a><span class="line-added"> 890     }</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892 // [long]</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894     /**</span>
<span class="line-added"> 895      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added"> 896      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added"> 897      *</span>
<span class="line-added"> 898      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added"> 899      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added"> 900      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added"> 901      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added"> 902      * parallelism to process the partitions.</span>
<span class="line-added"> 903      *</span>
<span class="line-added"> 904      * @param a the array to be sorted</span>
<span class="line-added"> 905      * @param parallelism the parallelism level</span>
<span class="line-added"> 906      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 907      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 908      */</span>
<span class="line-added"> 909     static void sort(long[] a, int parallelism, int low, int high) {</span>
<span class="line-added"> 910         int size = high - low;</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added"> 913             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added"> 914             long[] b = depth == 0 ? null : new long[size];</span>
<span class="line-added"> 915             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added"> 916         } else {</span>
<span class="line-added"> 917             sort(null, a, 0, low, high);</span>
<span class="line-added"> 918         }</span>
<span class="line-added"> 919     }</span>
 920 
<a name="189" id="anc189"></a><span class="line-modified"> 921     /**</span>
<span class="line-modified"> 922      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-modified"> 923      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added"> 924      *</span>
<span class="line-added"> 925      * @param sorter parallel context</span>
<span class="line-added"> 926      * @param a the array to be sorted</span>
<span class="line-added"> 927      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added"> 928      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added"> 929      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 930      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 931      */</span>
<span class="line-added"> 932     static void sort(Sorter sorter, long[] a, int bits, int low, int high) {</span>
<span class="line-added"> 933         while (true) {</span>
<span class="line-added"> 934             int end = high - 1, size = high - low;</span>
 935 
<a name="190" id="anc190"></a>
 936             /*
<a name="191" id="anc191"></a><span class="line-modified"> 937              * Run mixed insertion sort on small non-leftmost parts.</span>


 938              */
<a name="192" id="anc192"></a><span class="line-modified"> 939             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified"> 940                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-added"> 941                 return;</span>
<span class="line-added"> 942             }</span>
 943 
 944             /*
<a name="193" id="anc193"></a><span class="line-modified"> 945              * Invoke insertion sort on small leftmost part.</span>



 946              */
<a name="194" id="anc194"></a><span class="line-modified"> 947             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-modified"> 948                 insertionSort(a, low, high);</span>
<span class="line-added"> 949                 return;</span>
<span class="line-added"> 950             }</span>
 951 
 952             /*
<a name="195" id="anc195"></a><span class="line-modified"> 953              * Check if the whole array or large non-leftmost</span>
<span class="line-added"> 954              * parts are nearly sorted and then merge runs.</span>
 955              */
<a name="196" id="anc196"></a><span class="line-modified"> 956             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-modified"> 957                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added"> 958                 return;</span>
<span class="line-added"> 959             }</span>
 960 
 961             /*
<a name="197" id="anc197"></a><span class="line-modified"> 962              * Switch to heap sort if execution</span>
<span class="line-modified"> 963              * time is becoming quadratic.</span>















 964              */
<a name="198" id="anc198"></a><span class="line-modified"> 965             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-modified"> 966                 heapSort(a, low, high);</span>
<span class="line-modified"> 967                 return;</span>




























 968             }
 969 
<a name="199" id="anc199"></a><span class="line-modified"> 970             /*</span>
<span class="line-modified"> 971              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-modified"> 972              * to select five sample elements and determine pivots.</span>
<span class="line-modified"> 973              */</span>
<span class="line-modified"> 974             int step = (size &gt;&gt; 3) * 3 + 3;</span>


 975 
 976             /*
<a name="200" id="anc200"></a><span class="line-modified"> 977              * Five elements around (and including) the central element</span>
<span class="line-modified"> 978              * will be used for pivot selection as described below. The</span>
<span class="line-added"> 979              * unequal choice of spacing these elements was empirically</span>
<span class="line-added"> 980              * determined to work well on a wide variety of inputs.</span>
 981              */
<a name="201" id="anc201"></a><span class="line-modified"> 982             int e1 = low + step;</span>
<span class="line-modified"> 983             int e5 = end - step;</span>
<span class="line-modified"> 984             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 985             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 986             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 987             long a3 = a[e3];</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989             /*</span>
<span class="line-added"> 990              * Sort these elements in place by the combination</span>
<span class="line-added"> 991              * of 4-element sorting network and insertion sort.</span>
<span class="line-added"> 992              *</span>
<span class="line-added"> 993              *    5 ------o-----------o------------</span>
<span class="line-added"> 994              *            |           |</span>
<span class="line-added"> 995              *    4 ------|-----o-----o-----o------</span>
<span class="line-added"> 996              *            |     |           |</span>
<span class="line-added"> 997              *    2 ------o-----|-----o-----o------</span>
<span class="line-added"> 998              *                  |     |</span>
<span class="line-added"> 999              *    1 ------------o-----o------------</span>
<span class="line-added">1000              */</span>
<span class="line-added">1001             if (a[e5] &lt; a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1002             if (a[e4] &lt; a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1003             if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">1004             if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1005             if (a[e4] &lt; a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1006 </span>
<span class="line-added">1007             if (a3 &lt; a[e2]) {</span>
<span class="line-added">1008                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">1009                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">1010                 } else {</span>
<span class="line-added">1011                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">1012                 }</span>
<span class="line-added">1013             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">1014                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">1015                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">1016                 } else {</span>
<span class="line-added">1017                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">1018                 }</span>
<span class="line-added">1019             }</span>
<span class="line-added">1020 </span>
<span class="line-added">1021             // Pointers</span>
<span class="line-added">1022             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">1023             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">1024 </span>
<span class="line-added">1025             /*</span>
<span class="line-added">1026              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">1027              */</span>
<span class="line-added">1028             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">1029 </span>
<span class="line-added">1030                 /*</span>
<span class="line-added">1031                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">1032                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">1033                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">1034                  */</span>
<span class="line-added">1035                 long pivot1 = a[e1];</span>
<span class="line-added">1036                 long pivot2 = a[e5];</span>
<span class="line-added">1037 </span>
<span class="line-added">1038                 /*</span>
<span class="line-added">1039                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">1040                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">1041                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">1042                  * into their final positions, and excluded from the next</span>
<span class="line-added">1043                  * subsequent sorting.</span>
1044                  */
<a name="202" id="anc202"></a><span class="line-modified">1045                 a[e1] = a[lower];</span>
<span class="line-modified">1046                 a[e5] = a[upper];</span>
<span class="line-added">1047 </span>
<span class="line-added">1048                 /*</span>
<span class="line-added">1049                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">1050                  */</span>
<span class="line-added">1051                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">1052                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">1053 </span>
<span class="line-added">1054                 /*</span>
<span class="line-added">1055                  * Backward 3-interval partitioning</span>
<span class="line-added">1056                  *</span>
<span class="line-added">1057                  *   left part                 central part          right part</span>
<span class="line-added">1058                  * +------------------------------------------------------------+</span>
<span class="line-added">1059                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">1060                  * +------------------------------------------------------------+</span>
<span class="line-added">1061                  *             ^       ^                            ^</span>
<span class="line-added">1062                  *             |       |                            |</span>
<span class="line-added">1063                  *           lower     k                          upper</span>
<span class="line-added">1064                  *</span>
<span class="line-added">1065                  * Invariants:</span>
<span class="line-added">1066                  *</span>
<span class="line-added">1067                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">1068                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">1069                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">1070                  *</span>
<span class="line-added">1071                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1072                  */</span>
<span class="line-added">1073                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1074                     long ak = a[k];</span>
<span class="line-added">1075 </span>
<span class="line-added">1076                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">1077                         while (lower &lt; k) {</span>
<span class="line-added">1078                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">1079                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">1080                                     a[k] = a[--upper];</span>
<span class="line-added">1081                                     a[upper] = a[lower];</span>
<span class="line-added">1082                                 } else {</span>
<span class="line-added">1083                                     a[k] = a[lower];</span>
<span class="line-added">1084                                 }</span>
<span class="line-added">1085                                 a[lower] = ak;</span>
<span class="line-added">1086                                 break;</span>
<span class="line-added">1087                             }</span>
<span class="line-added">1088                         }</span>
<span class="line-added">1089                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">1090                         a[k] = a[--upper];</span>
<span class="line-added">1091                         a[upper] = ak;</span>
<span class="line-added">1092                     }</span>
1093                 }
1094 
<a name="203" id="anc203"></a><span class="line-modified">1095                 /*</span>
<span class="line-modified">1096                  * Swap the pivots into their final positions.</span>
<span class="line-added">1097                  */</span>
<span class="line-added">1098                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">1099                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">1100 </span>
<span class="line-added">1101                 /*</span>
<span class="line-added">1102                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">1103                  * excluding known pivots.</span>
<span class="line-added">1104                  */</span>
<span class="line-added">1105                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">1106                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">1107                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">1108                 } else {</span>
<span class="line-added">1109                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">1110                     sort(sorter, a, bits | 1, upper + 1, high);</span>
1111                 }
1112 
<a name="204" id="anc204"></a><span class="line-added">1113             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">1114 </span>
<span class="line-added">1115                 /*</span>
<span class="line-added">1116                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">1117                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">1118                  */</span>
<span class="line-added">1119                 long pivot = a[e3];</span>
<span class="line-added">1120 </span>
<span class="line-added">1121                 /*</span>
<span class="line-added">1122                  * The first element to be sorted is moved to the</span>
<span class="line-added">1123                  * location formerly occupied by the pivot. After</span>
<span class="line-added">1124                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">1125                  * back into its final position, and excluded from</span>
<span class="line-added">1126                  * the next subsequent sorting.</span>
<span class="line-added">1127                  */</span>
<span class="line-added">1128                 a[e3] = a[lower];</span>
<span class="line-added">1129 </span>
1130                 /*
<a name="205" id="anc205"></a><span class="line-modified">1131                  * Traditional 3-way (Dutch National Flag) partitioning</span>
1132                  *
<a name="206" id="anc206"></a><span class="line-modified">1133                  *   left part                 central part    right part</span>
<span class="line-modified">1134                  * +------------------------------------------------------+</span>
<span class="line-modified">1135                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-modified">1136                  * +------------------------------------------------------+</span>
<span class="line-modified">1137                  *              ^           ^                ^</span>
<span class="line-modified">1138                  *              |           |                |</span>
<span class="line-modified">1139                  *            lower         k              upper</span>
1140                  *
1141                  * Invariants:
1142                  *
<a name="207" id="anc207"></a><span class="line-modified">1143                  *   all in (low, lower] &lt; pivot</span>
<span class="line-modified">1144                  *   all in (k, upper)  == pivot</span>
<span class="line-modified">1145                  *   all in [upper, end] &gt; pivot</span>
1146                  *
<a name="208" id="anc208"></a><span class="line-modified">1147                  * Pointer k is the last index of ?-part</span>
1148                  */
<a name="209" id="anc209"></a><span class="line-modified">1149                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-modified">1150                     long ak = a[k];</span>
<span class="line-modified">1151 </span>
<span class="line-modified">1152                     if (ak != pivot) {</span>
<span class="line-modified">1153                         a[k] = pivot;</span>
<span class="line-modified">1154 </span>
<span class="line-modified">1155                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-modified">1156                             while (a[++lower] &lt; pivot);</span>
<span class="line-modified">1157 </span>
<span class="line-modified">1158                             if (a[lower] &gt; pivot) {</span>
<span class="line-modified">1159                                 a[--upper] = a[lower];</span>
1160                             }
<a name="210" id="anc210"></a><span class="line-added">1161                             a[lower] = ak;</span>
<span class="line-added">1162                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">1163                             a[--upper] = ak;</span>
1164                         }
<a name="211" id="anc211"></a>
















1165                     }
1166                 }
<a name="212" id="anc212"></a><span class="line-added">1167 </span>
<span class="line-added">1168                 /*</span>
<span class="line-added">1169                  * Swap the pivot into its final position.</span>
<span class="line-added">1170                  */</span>
<span class="line-added">1171                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">1172 </span>
<span class="line-added">1173                 /*</span>
<span class="line-added">1174                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">1175                  * known pivot. All elements from the central part are</span>
<span class="line-added">1176                  * equal and therefore already sorted.</span>
<span class="line-added">1177                  */</span>
<span class="line-added">1178                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">1179                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">1180                 } else {</span>
<span class="line-added">1181                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">1182                 }</span>
1183             }
<a name="213" id="anc213"></a><span class="line-added">1184             high = lower; // Iterate along the left part</span>
<span class="line-added">1185         }</span>
<span class="line-added">1186     }</span>
1187 
<a name="214" id="anc214"></a><span class="line-modified">1188     /**</span>
<span class="line-modified">1189      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">1190      *</span>
<span class="line-added">1191      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">1192      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">1193      *</span>
<span class="line-added">1194      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">1195      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">1196      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">1197      * expensive check of the left range can be skipped on each</span>
<span class="line-added">1198      * iteration unless it is the leftmost call.</span>
<span class="line-added">1199      *</span>
<span class="line-added">1200      * @param a the array to be sorted</span>
<span class="line-added">1201      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1202      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">1203      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1204      */</span>
<span class="line-added">1205     private static void mixedInsertionSort(long[] a, int low, int end, int high) {</span>
<span class="line-added">1206         if (end == high) {</span>
1207 
<a name="215" id="anc215"></a>
1208             /*
<a name="216" id="anc216"></a><span class="line-modified">1209              * Invoke simple insertion sort on tiny array.</span>

1210              */
<a name="217" id="anc217"></a><span class="line-modified">1211             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">1212                 long ai = a[i = low];</span>
<span class="line-added">1213 </span>
<span class="line-added">1214                 while (ai &lt; a[--i]) {</span>
<span class="line-added">1215                     a[i + 1] = a[i];</span>
<span class="line-added">1216                 }</span>
<span class="line-added">1217                 a[i + 1] = ai;</span>
<span class="line-added">1218             }</span>
<span class="line-added">1219         } else {</span>
1220 
1221             /*
<a name="218" id="anc218"></a><span class="line-modified">1222              * Start with pin insertion sort on small part.</span>











1223              *
<a name="219" id="anc219"></a><span class="line-modified">1224              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-modified">1225              * The main idea of this sort is to put elements larger</span>
<span class="line-modified">1226              * than an element called pin to the end of array (the</span>
<span class="line-modified">1227              * proper area for such elements). It avoids expensive</span>
<span class="line-modified">1228              * movements of these elements through the whole array.</span>
1229              */
<a name="220" id="anc220"></a><span class="line-modified">1230             long pin = a[end];</span>
<span class="line-modified">1231 </span>
<span class="line-modified">1232             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified">1233                 long ai = a[i = low];</span>
<span class="line-modified">1234 </span>
<span class="line-modified">1235                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-modified">1236 </span>
<span class="line-modified">1237                     /*</span>
<span class="line-modified">1238                      * Insert small element into sorted part.</span>
<span class="line-modified">1239                      */</span>
<span class="line-modified">1240                     a[i] = a[--i];</span>
<span class="line-modified">1241 </span>
<span class="line-added">1242                     while (ai &lt; a[--i]) {</span>
<span class="line-added">1243                         a[i + 1] = a[i];</span>
1244                     }
<a name="221" id="anc221"></a><span class="line-modified">1245                     a[i + 1] = ai;</span>
<span class="line-modified">1246 </span>
<span class="line-modified">1247                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-modified">1248 </span>
<span class="line-modified">1249                     /*</span>
<span class="line-modified">1250                      * Find element smaller than pin.</span>
<span class="line-modified">1251                      */</span>
<span class="line-modified">1252                     while (a[--p] &gt; pin);</span>
<span class="line-modified">1253 </span>
<span class="line-modified">1254                     /*</span>
<span class="line-modified">1255                      * Swap it with large element.</span>
<span class="line-modified">1256                      */</span>
<span class="line-modified">1257                     if (p &gt; i) {</span>
<span class="line-modified">1258                         ai = a[p];</span>
<span class="line-added">1259                         a[p] = a[i];</span>
<span class="line-added">1260                     }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262                     /*</span>
<span class="line-added">1263                      * Insert small element into sorted part.</span>
<span class="line-added">1264                      */</span>
<span class="line-added">1265                     while (ai &lt; a[--i]) {</span>
<span class="line-added">1266                         a[i + 1] = a[i];</span>
1267                     }
<a name="222" id="anc222"></a><span class="line-modified">1268                     a[i + 1] = ai;</span>

1269                 }
1270             }
1271 
1272             /*
<a name="223" id="anc223"></a><span class="line-modified">1273              * Continue with pair insertion sort on remain part.</span>


1274              */
<a name="224" id="anc224"></a><span class="line-modified">1275             for (int i; low &lt; high; ++low) {</span>
<span class="line-modified">1276                 long a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added">1277 </span>
<span class="line-added">1278                 /*</span>
<span class="line-added">1279                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added">1280                  * larger element and then insert the smaller element, but</span>
<span class="line-added">1281                  * from the position where the larger element was inserted.</span>
<span class="line-added">1282                  */</span>
<span class="line-added">1283                 if (a1 &gt; a2) {</span>
<span class="line-added">1284 </span>
<span class="line-added">1285                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">1286                         a[i + 2] = a[i];</span>
<span class="line-added">1287                     }</span>
<span class="line-added">1288                     a[++i + 1] = a1;</span>
<span class="line-added">1289 </span>
<span class="line-added">1290                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">1291                         a[i + 1] = a[i];</span>
<span class="line-added">1292                     }</span>
<span class="line-added">1293                     a[i + 1] = a2;</span>
<span class="line-added">1294 </span>
<span class="line-added">1295                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="line-added">1296 </span>
<span class="line-added">1297                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">1298                         a[i + 2] = a[i];</span>
<span class="line-added">1299                     }</span>
<span class="line-added">1300                     a[++i + 1] = a2;</span>
<span class="line-added">1301 </span>
<span class="line-added">1302                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">1303                         a[i + 1] = a[i];</span>
<span class="line-added">1304                     }</span>
<span class="line-added">1305                     a[i + 1] = a1;</span>
<span class="line-added">1306                 }</span>
<span class="line-added">1307             }</span>
1308         }
1309     }
1310 
<a name="225" id="anc225"></a>


1311     /**
<a name="226" id="anc226"></a><span class="line-modified">1312      * Sorts the specified range of the array using insertion sort.</span>
1313      *
1314      * @param a the array to be sorted
<a name="227" id="anc227"></a><span class="line-modified">1315      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1316      * @param high the index of the last element, exclusive, to be sorted</span>
1317      */
<a name="228" id="anc228"></a><span class="line-modified">1318     private static void insertionSort(long[] a, int low, int high) {</span>
<span class="line-modified">1319         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-modified">1320             long ai = a[i = k];</span>









1321 
<a name="229" id="anc229"></a><span class="line-modified">1322             if (ai &lt; a[i - 1]) {</span>
<span class="line-modified">1323                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-modified">1324                     a[i + 1] = a[i];</span>









1325                 }
<a name="230" id="anc230"></a><span class="line-modified">1326                 a[i + 1] = ai;</span>
1327             }
1328         }
1329     }
1330 
1331     /**
<a name="231" id="anc231"></a><span class="line-modified">1332      * Sorts the specified range of the array using heap sort.</span>

1333      *
1334      * @param a the array to be sorted
<a name="232" id="anc232"></a><span class="line-modified">1335      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1336      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">1337      */</span>
<span class="line-modified">1338     private static void heapSort(long[] a, int low, int high) {</span>
<span class="line-modified">1339         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified">1340             pushDown(a, --k, a[k], low, high);</span>
<span class="line-modified">1341         }</span>
<span class="line-modified">1342         while (--high &gt; low) {</span>
<span class="line-modified">1343             long max = a[low];</span>
<span class="line-modified">1344             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified">1345             a[high] = max;</span>


1346         }
<a name="233" id="anc233"></a><span class="line-modified">1347     }</span>
<span class="line-modified">1348 </span>
<span class="line-modified">1349     /**</span>
<span class="line-modified">1350      * Pushes specified element down during heap sort.</span>
<span class="line-modified">1351      *</span>
<span class="line-modified">1352      * @param a the given array</span>
<span class="line-added">1353      * @param p the start index</span>
<span class="line-added">1354      * @param value the given element</span>
<span class="line-added">1355      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1356      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1357      */</span>
<span class="line-added">1358     private static void pushDown(long[] a, int p, long value, int low, int high) {</span>
<span class="line-added">1359         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">1360             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">1361 </span>
<span class="line-added">1362             if (k &gt; high) {</span>
<span class="line-added">1363                 break;</span>
<span class="line-added">1364             }</span>
<span class="line-added">1365             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">1366                 --k;</span>
<span class="line-added">1367             }</span>
<span class="line-added">1368             if (a[k] &lt;= value) {</span>
<span class="line-added">1369                 break;</span>
1370             }
1371         }
<a name="234" id="anc234"></a><span class="line-added">1372         a[p] = value;</span>
<span class="line-added">1373     }</span>
1374 
<a name="235" id="anc235"></a><span class="line-modified">1375     /**</span>
<span class="line-modified">1376      * Tries to sort the specified range of the array.</span>
<span class="line-modified">1377      *</span>
<span class="line-modified">1378      * @param sorter parallel context</span>
<span class="line-added">1379      * @param a the array to be sorted</span>
<span class="line-added">1380      * @param low the index of the first element to be sorted</span>
<span class="line-added">1381      * @param size the array size</span>
<span class="line-added">1382      * @return true if finally sorted, false otherwise</span>
<span class="line-added">1383      */</span>
<span class="line-added">1384     private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {</span>
1385 
1386         /*
<a name="236" id="anc236"></a><span class="line-modified">1387          * The run array is constructed only if initial runs are</span>
<span class="line-added">1388          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">1389          * of the i-th sequence of elements in non-descending order.</span>
1390          */
<a name="237" id="anc237"></a><span class="line-modified">1391         int[] run = null;</span>
<span class="line-added">1392         int high = low + size;</span>
<span class="line-added">1393         int count = 1, last = low;</span>
1394 
1395         /*
<a name="238" id="anc238"></a><span class="line-modified">1396          * Identify all possible runs.</span>
1397          */
<a name="239" id="anc239"></a><span class="line-modified">1398         for (int k = low + 1; k &lt; high; ) {</span>


1399 
<a name="240" id="anc240"></a><span class="line-modified">1400             /*</span>
<span class="line-modified">1401              * Find the end index of the current run.</span>
<span class="line-modified">1402              */</span>
<span class="line-modified">1403             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">1404 </span>
<span class="line-added">1405                 // Identify ascending sequence</span>
<span class="line-added">1406                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">1407 </span>
<span class="line-added">1408             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">1409 </span>
<span class="line-added">1410                 // Identify descending sequence</span>
<span class="line-added">1411                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">1412 </span>
<span class="line-added">1413                 // Reverse into ascending order</span>
<span class="line-added">1414                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">1415                     long ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">1416                 }</span>
<span class="line-added">1417             } else { // Identify constant sequence</span>
<span class="line-added">1418                 for (long ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">1419 </span>
<span class="line-added">1420                 if (k &lt; high) {</span>
<span class="line-added">1421                     continue;</span>
<span class="line-added">1422                 }</span>
1423             }
<a name="241" id="anc241"></a>
1424 
<a name="242" id="anc242"></a><span class="line-modified">1425             /*</span>
<span class="line-modified">1426              * Check special cases.</span>
<span class="line-modified">1427              */</span>
<span class="line-modified">1428             if (run == null) {</span>
<span class="line-modified">1429                 if (k == high) {</span>
<span class="line-added">1430 </span>
<span class="line-added">1431                     /*</span>
<span class="line-added">1432                      * The array is monotonous sequence,</span>
<span class="line-added">1433                      * and therefore already sorted.</span>
<span class="line-added">1434                      */</span>
<span class="line-added">1435                     return true;</span>
<span class="line-added">1436                 }</span>
<span class="line-added">1437 </span>
<span class="line-added">1438                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">1439 </span>
<span class="line-added">1440                     /*</span>
<span class="line-added">1441                      * The first run is too small</span>
<span class="line-added">1442                      * to proceed with scanning.</span>
<span class="line-added">1443                      */</span>
<span class="line-added">1444                     return false;</span>
<span class="line-added">1445                 }</span>
<span class="line-added">1446 </span>
<span class="line-added">1447                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">1448                 run[0] = low;</span>
<span class="line-added">1449 </span>
<span class="line-added">1450             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">1451 </span>
<span class="line-added">1452                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">1453 </span>
<span class="line-added">1454                     /*</span>
<span class="line-added">1455                      * The first runs are not long</span>
<span class="line-added">1456                      * enough to continue scanning.</span>
<span class="line-added">1457                      */</span>
<span class="line-added">1458                     return false;</span>
<span class="line-added">1459                 }</span>
<span class="line-added">1460 </span>
<span class="line-added">1461                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">1462 </span>
<span class="line-added">1463                     /*</span>
<span class="line-added">1464                      * Array is not highly structured.</span>
<span class="line-added">1465                      */</span>
<span class="line-added">1466                     return false;</span>
<span class="line-added">1467                 }</span>
<span class="line-added">1468 </span>
<span class="line-added">1469                 if (count == run.length) {</span>
<span class="line-added">1470 </span>
<span class="line-added">1471                     /*</span>
<span class="line-added">1472                      * Increase capacity of index array.</span>
<span class="line-added">1473                      */</span>
<span class="line-added">1474                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">1475                 }</span>
<span class="line-added">1476             }</span>
<span class="line-added">1477             run[count] = (last = k);</span>
1478         }
1479 
1480         /*
<a name="243" id="anc243"></a><span class="line-modified">1481          * Merge runs of highly structured array.</span>


















1482          */
<a name="244" id="anc244"></a><span class="line-modified">1483         if (count &gt; 1) {</span>
<span class="line-modified">1484             long[] b; int offset = low;</span>
<span class="line-modified">1485 </span>
<span class="line-modified">1486             if (sorter == null || (b = (long[]) sorter.b) == null) {</span>
<span class="line-modified">1487                 b = new long[size];</span>
<span class="line-modified">1488             } else {</span>
<span class="line-modified">1489                 offset = sorter.offset;</span>

1490             }
<a name="245" id="anc245"></a><span class="line-added">1491             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
1492         }
<a name="246" id="anc246"></a><span class="line-added">1493         return true;</span>
1494     }
1495 
1496     /**
<a name="247" id="anc247"></a><span class="line-modified">1497      * Merges the specified runs.</span>
1498      *
<a name="248" id="anc248"></a><span class="line-modified">1499      * @param a the source array</span>
<span class="line-modified">1500      * @param b the temporary buffer used in merging</span>
<span class="line-modified">1501      * @param offset the start index in the source, inclusive</span>
<span class="line-modified">1502      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified">1503      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified">1504      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified">1505      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified">1506      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified">1507      * @return the destination where runs are merged</span>
<span class="line-modified">1508      */</span>
<span class="line-modified">1509     private static long[] mergeRuns(long[] a, long[] b, int offset,</span>
<span class="line-modified">1510             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified">1511 </span>
<span class="line-added">1512         if (hi - lo == 1) {</span>
<span class="line-added">1513             if (aim &gt;= 0) {</span>
<span class="line-added">1514                 return a;</span>
<span class="line-added">1515             }</span>
<span class="line-added">1516             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">1517                 b[--j] = a[--i]</span>
<span class="line-added">1518             );</span>
<span class="line-added">1519             return b;</span>
1520         }
1521 
1522         /*
<a name="249" id="anc249"></a><span class="line-modified">1523          * Split into approximately equal parts.</span>

1524          */
<a name="250" id="anc250"></a><span class="line-modified">1525         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified">1526         while (run[++mi + 1] &lt;= rmi);</span>
















1527 
<a name="251" id="anc251"></a><span class="line-modified">1528         /*</span>
<span class="line-modified">1529          * Merge the left and right parts.</span>
<span class="line-modified">1530          */</span>
<span class="line-modified">1531         long[] a1, a2;</span>

1532 
<a name="252" id="anc252"></a><span class="line-modified">1533         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified">1534             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified">1535             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified">1536             a2 = (long[]) merger.getDestination();</span>
<span class="line-modified">1537         } else {</span>
<span class="line-modified">1538             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified">1539             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

1540         }
1541 
<a name="253" id="anc253"></a><span class="line-modified">1542         long[] dst = a1 == a ? b : a;</span>


1543 
<a name="254" id="anc254"></a><span class="line-modified">1544         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified">1545         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified">1546         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">1547         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">1548         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified">1549 </span>
<span class="line-modified">1550         if (parallel) {</span>
<span class="line-modified">1551             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























1552         } else {
<a name="255" id="anc255"></a><span class="line-modified">1553             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























1554         }
<a name="256" id="anc256"></a><span class="line-added">1555         return dst;</span>
1556     }
1557 
1558     /**
<a name="257" id="anc257"></a><span class="line-modified">1559      * Merges the sorted parts.</span>
1560      *
<a name="258" id="anc258"></a><span class="line-modified">1561      * @param merger parallel context</span>
<span class="line-modified">1562      * @param dst the destination where parts are merged</span>
<span class="line-modified">1563      * @param k the start index of the destination, inclusive</span>
<span class="line-modified">1564      * @param a1 the first part</span>
<span class="line-modified">1565      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified">1566      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified">1567      * @param a2 the second part</span>
<span class="line-modified">1568      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified">1569      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified">1570      */</span>
<span class="line-modified">1571     private static void mergeParts(Merger merger, long[] dst, int k,</span>
<span class="line-modified">1572             long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {</span>
<span class="line-modified">1573 </span>
<span class="line-modified">1574         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified">1575 </span>
<span class="line-modified">1576             while (true) {</span>
<span class="line-modified">1577 </span>
<span class="line-modified">1578                 /*</span>
<span class="line-modified">1579                  * The first part must be larger.</span>
<span class="line-modified">1580                  */</span>
<span class="line-modified">1581                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified">1582                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified">1583                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


1584                 }
<a name="259" id="anc259"></a><span class="line-modified">1585 </span>
1586                 /*
<a name="260" id="anc260"></a><span class="line-modified">1587                  * Small parts will be merged sequentially.</span>
1588                  */
<a name="261" id="anc261"></a><span class="line-modified">1589                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified">1590                     break;</span>
<span class="line-modified">1591                 }</span>


1592 
1593                 /*
<a name="262" id="anc262"></a><span class="line-modified">1594                  * Find the median of the larger part.</span>





1595                  */
<a name="263" id="anc263"></a><span class="line-modified">1596                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified">1597                 long key = a1[mi1];</span>
<span class="line-added">1598                 int mi2 = hi2;</span>
1599 
<a name="264" id="anc264"></a><span class="line-modified">1600                 /*</span>
<span class="line-modified">1601                  * Partition the smaller part.</span>
<span class="line-modified">1602                  */</span>
<span class="line-modified">1603                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified">1604                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


1605 
<a name="265" id="anc265"></a><span class="line-modified">1606                     if (key &gt; a2[t]) {</span>
<span class="line-modified">1607                         loo = t + 1;</span>
<span class="line-added">1608                     } else {</span>
<span class="line-added">1609                         mi2 = t;</span>
1610                     }
<a name="266" id="anc266"></a>
1611                 }
<a name="267" id="anc267"></a>
1612 
<a name="268" id="anc268"></a><span class="line-modified">1613                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified">1614 </span>
<span class="line-modified">1615                 /*</span>
<span class="line-modified">1616                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">1617                  */</span>
<span class="line-added">1618                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">1619 </span>
<span class="line-added">1620                 /*</span>
<span class="line-added">1621                  * Process the sub-left parts.</span>
<span class="line-added">1622                  */</span>
<span class="line-added">1623                 hi1 = mi1;</span>
<span class="line-added">1624                 hi2 = mi2;</span>
1625             }
<a name="269" id="anc269"></a>
1626         }
1627 
<a name="270" id="anc270"></a>


1628         /*
<a name="271" id="anc271"></a><span class="line-modified">1629          * Merge small parts sequentially.</span>




1630          */
<a name="272" id="anc272"></a><span class="line-modified">1631         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified">1632             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









1633         }
<a name="273" id="anc273"></a><span class="line-modified">1634         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified">1635             while (lo1 &lt; hi1) {</span>
<span class="line-modified">1636                 dst[k++] = a1[lo1++];</span>
1637             }
1638         }
<a name="274" id="anc274"></a><span class="line-modified">1639         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified">1640             while (lo2 &lt; hi2) {</span>
<span class="line-modified">1641                 dst[k++] = a2[lo2++];</span>


1642             }
1643         }
<a name="275" id="anc275"></a><span class="line-added">1644     }</span>
1645 
<a name="276" id="anc276"></a><span class="line-modified">1646 // [byte]</span>











1647 
<a name="277" id="anc277"></a><span class="line-modified">1648     /**</span>
<span class="line-modified">1649      * Sorts the specified range of the array using</span>
<span class="line-modified">1650      * counting sort or insertion sort.</span>
<span class="line-modified">1651      *</span>
<span class="line-modified">1652      * @param a the array to be sorted</span>
<span class="line-modified">1653      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1654      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">1655      */</span>
<span class="line-added">1656     static void sort(byte[] a, int low, int high) {</span>
<span class="line-added">1657         if (high - low &gt; MIN_BYTE_COUNTING_SORT_SIZE) {</span>
<span class="line-added">1658             countingSort(a, low, high);</span>
<span class="line-added">1659         } else {</span>
<span class="line-added">1660             insertionSort(a, low, high);</span>
<span class="line-added">1661         }</span>
<span class="line-added">1662     }</span>
1663 
<a name="278" id="anc278"></a><span class="line-modified">1664     /**</span>
<span class="line-modified">1665      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-modified">1666      *</span>
<span class="line-modified">1667      * @param a the array to be sorted</span>
<span class="line-modified">1668      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1669      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1670      */</span>
<span class="line-added">1671     private static void insertionSort(byte[] a, int low, int high) {</span>
<span class="line-added">1672         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">1673             byte ai = a[i = k];</span>
<span class="line-added">1674 </span>
<span class="line-added">1675             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">1676                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">1677                     a[i + 1] = a[i];</span>
<span class="line-added">1678                 }</span>
<span class="line-added">1679                 a[i + 1] = ai;</span>
<span class="line-added">1680             }</span>
<span class="line-added">1681         }</span>
<span class="line-added">1682     }</span>
<span class="line-added">1683 </span>
<span class="line-added">1684     /**</span>
<span class="line-added">1685      * The number of distinct byte values.</span>
<span class="line-added">1686      */</span>
<span class="line-added">1687     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="line-added">1688 </span>
<span class="line-added">1689     /**</span>
<span class="line-added">1690      * Max index of byte counter.</span>
<span class="line-added">1691      */</span>
<span class="line-added">1692     private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;</span>
<span class="line-added">1693 </span>
<span class="line-added">1694     /**</span>
<span class="line-added">1695      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">1696      *</span>
<span class="line-added">1697      * @param a the array to be sorted</span>
<span class="line-added">1698      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1699      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1700      */</span>
<span class="line-added">1701     private static void countingSort(byte[] a, int low, int high) {</span>
<span class="line-added">1702         int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="line-added">1703 </span>
<span class="line-added">1704         /*</span>
<span class="line-added">1705          * Compute a histogram with the number of each values.</span>
<span class="line-added">1706          */</span>
<span class="line-added">1707         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFF]);</span>
<span class="line-added">1708 </span>
<span class="line-added">1709         /*</span>
<span class="line-added">1710          * Place values on their final positions.</span>
<span class="line-added">1711          */</span>
<span class="line-added">1712         if (high - low &gt; NUM_BYTE_VALUES) {</span>
<span class="line-added">1713             for (int i = MAX_BYTE_INDEX; --i &gt; Byte.MAX_VALUE; ) {</span>
<span class="line-added">1714                 int value = i &amp; 0xFF;</span>
<span class="line-added">1715 </span>
<span class="line-added">1716                 for (low = high - count[value]; high &gt; low;</span>
<span class="line-added">1717                     a[--high] = (byte) value</span>
<span class="line-added">1718                 );</span>
<span class="line-added">1719             }</span>
<span class="line-added">1720         } else {</span>
<span class="line-added">1721             for (int i = MAX_BYTE_INDEX; high &gt; low; ) {</span>
<span class="line-added">1722                 while (count[--i &amp; 0xFF] == 0);</span>
<span class="line-added">1723 </span>
<span class="line-added">1724                 int value = i &amp; 0xFF;</span>
<span class="line-added">1725                 int c = count[value];</span>
<span class="line-added">1726 </span>
<span class="line-added">1727                 do {</span>
<span class="line-added">1728                     a[--high] = (byte) value;</span>
<span class="line-added">1729                 } while (--c &gt; 0);</span>
<span class="line-added">1730             }</span>
<span class="line-added">1731         }</span>
<span class="line-added">1732     }</span>
<span class="line-added">1733 </span>
<span class="line-added">1734 // [char]</span>
<span class="line-added">1735 </span>
<span class="line-added">1736     /**</span>
<span class="line-added">1737      * Sorts the specified range of the array using</span>
<span class="line-added">1738      * counting sort or Dual-Pivot Quicksort.</span>
<span class="line-added">1739      *</span>
<span class="line-added">1740      * @param a the array to be sorted</span>
<span class="line-added">1741      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1742      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1743      */</span>
<span class="line-added">1744     static void sort(char[] a, int low, int high) {</span>
<span class="line-added">1745         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="line-added">1746             countingSort(a, low, high);</span>
<span class="line-added">1747         } else {</span>
<span class="line-added">1748             sort(a, 0, low, high);</span>
<span class="line-added">1749         }</span>
<span class="line-added">1750     }</span>
<span class="line-added">1751 </span>
<span class="line-added">1752     /**</span>
<span class="line-added">1753      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">1754      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">1755      *</span>
<span class="line-added">1756      * @param a the array to be sorted</span>
<span class="line-added">1757      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">1758      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">1759      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1760      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1761      */</span>
<span class="line-added">1762     static void sort(char[] a, int bits, int low, int high) {</span>
<span class="line-added">1763         while (true) {</span>
<span class="line-added">1764             int end = high - 1, size = high - low;</span>
<span class="line-added">1765 </span>
<span class="line-added">1766             /*</span>
<span class="line-added">1767              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">1768              */</span>
<span class="line-added">1769             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">1770                 insertionSort(a, low, high);</span>
<span class="line-added">1771                 return;</span>
<span class="line-added">1772             }</span>
<span class="line-added">1773 </span>
<span class="line-added">1774             /*</span>
<span class="line-added">1775              * Switch to counting sort if execution</span>
<span class="line-added">1776              * time is becoming quadratic.</span>
<span class="line-added">1777              */</span>
<span class="line-added">1778             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">1779                 countingSort(a, low, high);</span>
<span class="line-added">1780                 return;</span>
<span class="line-added">1781             }</span>
<span class="line-added">1782 </span>
<span class="line-added">1783             /*</span>
<span class="line-added">1784              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">1785              * to select five sample elements and determine pivots.</span>
<span class="line-added">1786              */</span>
<span class="line-added">1787             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">1788 </span>
<span class="line-added">1789             /*</span>
<span class="line-added">1790              * Five elements around (and including) the central element</span>
<span class="line-added">1791              * will be used for pivot selection as described below. The</span>
<span class="line-added">1792              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">1793              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">1794              */</span>
<span class="line-added">1795             int e1 = low + step;</span>
<span class="line-added">1796             int e5 = end - step;</span>
<span class="line-added">1797             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">1798             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">1799             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">1800             char a3 = a[e3];</span>
<span class="line-added">1801 </span>
<span class="line-added">1802             /*</span>
<span class="line-added">1803              * Sort these elements in place by the combination</span>
<span class="line-added">1804              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">1805              *</span>
<span class="line-added">1806              *    5 ------o-----------o------------</span>
<span class="line-added">1807              *            |           |</span>
<span class="line-added">1808              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">1809              *            |     |           |</span>
<span class="line-added">1810              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">1811              *                  |     |</span>
<span class="line-added">1812              *    1 ------------o-----o------------</span>
<span class="line-added">1813              */</span>
<span class="line-added">1814             if (a[e5] &lt; a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1815             if (a[e4] &lt; a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1816             if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">1817             if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1818             if (a[e4] &lt; a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1819 </span>
<span class="line-added">1820             if (a3 &lt; a[e2]) {</span>
<span class="line-added">1821                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">1822                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">1823                 } else {</span>
<span class="line-added">1824                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">1825                 }</span>
<span class="line-added">1826             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">1827                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">1828                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">1829                 } else {</span>
<span class="line-added">1830                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">1831                 }</span>
<span class="line-added">1832             }</span>
<span class="line-added">1833 </span>
<span class="line-added">1834             // Pointers</span>
<span class="line-added">1835             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">1836             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">1837 </span>
<span class="line-added">1838             /*</span>
<span class="line-added">1839              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">1840              */</span>
<span class="line-added">1841             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">1842 </span>
<span class="line-added">1843                 /*</span>
<span class="line-added">1844                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">1845                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">1846                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">1847                  */</span>
<span class="line-added">1848                 char pivot1 = a[e1];</span>
<span class="line-added">1849                 char pivot2 = a[e5];</span>
<span class="line-added">1850 </span>
<span class="line-added">1851                 /*</span>
<span class="line-added">1852                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">1853                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">1854                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">1855                  * into their final positions, and excluded from the next</span>
<span class="line-added">1856                  * subsequent sorting.</span>
<span class="line-added">1857                  */</span>
<span class="line-added">1858                 a[e1] = a[lower];</span>
<span class="line-added">1859                 a[e5] = a[upper];</span>
<span class="line-added">1860 </span>
<span class="line-added">1861                 /*</span>
<span class="line-added">1862                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">1863                  */</span>
<span class="line-added">1864                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">1865                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">1866 </span>
<span class="line-added">1867                 /*</span>
<span class="line-added">1868                  * Backward 3-interval partitioning</span>
<span class="line-added">1869                  *</span>
<span class="line-added">1870                  *   left part                 central part          right part</span>
<span class="line-added">1871                  * +------------------------------------------------------------+</span>
<span class="line-added">1872                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">1873                  * +------------------------------------------------------------+</span>
<span class="line-added">1874                  *             ^       ^                            ^</span>
<span class="line-added">1875                  *             |       |                            |</span>
<span class="line-added">1876                  *           lower     k                          upper</span>
<span class="line-added">1877                  *</span>
<span class="line-added">1878                  * Invariants:</span>
<span class="line-added">1879                  *</span>
<span class="line-added">1880                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">1881                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">1882                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">1883                  *</span>
<span class="line-added">1884                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1885                  */</span>
<span class="line-added">1886                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1887                     char ak = a[k];</span>
<span class="line-added">1888 </span>
<span class="line-added">1889                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">1890                         while (lower &lt; k) {</span>
<span class="line-added">1891                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">1892                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">1893                                     a[k] = a[--upper];</span>
<span class="line-added">1894                                     a[upper] = a[lower];</span>
<span class="line-added">1895                                 } else {</span>
<span class="line-added">1896                                     a[k] = a[lower];</span>
<span class="line-added">1897                                 }</span>
<span class="line-added">1898                                 a[lower] = ak;</span>
<span class="line-added">1899                                 break;</span>
<span class="line-added">1900                             }</span>
<span class="line-added">1901                         }</span>
<span class="line-added">1902                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">1903                         a[k] = a[--upper];</span>
<span class="line-added">1904                         a[upper] = ak;</span>
<span class="line-added">1905                     }</span>
<span class="line-added">1906                 }</span>
<span class="line-added">1907 </span>
<span class="line-added">1908                 /*</span>
<span class="line-added">1909                  * Swap the pivots into their final positions.</span>
<span class="line-added">1910                  */</span>
<span class="line-added">1911                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">1912                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">1913 </span>
<span class="line-added">1914                 /*</span>
<span class="line-added">1915                  * Sort non-left parts recursively,</span>
<span class="line-added">1916                  * excluding known pivots.</span>
<span class="line-added">1917                  */</span>
<span class="line-added">1918                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="line-added">1919                 sort(a, bits | 1, upper + 1, high);</span>
<span class="line-added">1920 </span>
<span class="line-added">1921             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">1922 </span>
<span class="line-added">1923                 /*</span>
<span class="line-added">1924                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">1925                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">1926                  */</span>
<span class="line-added">1927                 char pivot = a[e3];</span>
<span class="line-added">1928 </span>
<span class="line-added">1929                 /*</span>
<span class="line-added">1930                  * The first element to be sorted is moved to the</span>
<span class="line-added">1931                  * location formerly occupied by the pivot. After</span>
<span class="line-added">1932                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">1933                  * back into its final position, and excluded from</span>
<span class="line-added">1934                  * the next subsequent sorting.</span>
<span class="line-added">1935                  */</span>
<span class="line-added">1936                 a[e3] = a[lower];</span>
<span class="line-added">1937 </span>
<span class="line-added">1938                 /*</span>
<span class="line-added">1939                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">1940                  *</span>
<span class="line-added">1941                  *   left part                 central part    right part</span>
<span class="line-added">1942                  * +------------------------------------------------------+</span>
<span class="line-added">1943                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">1944                  * +------------------------------------------------------+</span>
<span class="line-added">1945                  *              ^           ^                ^</span>
<span class="line-added">1946                  *              |           |                |</span>
<span class="line-added">1947                  *            lower         k              upper</span>
<span class="line-added">1948                  *</span>
<span class="line-added">1949                  * Invariants:</span>
<span class="line-added">1950                  *</span>
<span class="line-added">1951                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">1952                  *   all in (k, upper)  == pivot</span>
<span class="line-added">1953                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">1954                  *</span>
<span class="line-added">1955                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1956                  */</span>
<span class="line-added">1957                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1958                     char ak = a[k];</span>
<span class="line-added">1959 </span>
<span class="line-added">1960                     if (ak != pivot) {</span>
<span class="line-added">1961                         a[k] = pivot;</span>
<span class="line-added">1962 </span>
<span class="line-added">1963                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">1964                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">1965 </span>
<span class="line-added">1966                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">1967                                 a[--upper] = a[lower];</span>
<span class="line-added">1968                             }</span>
<span class="line-added">1969                             a[lower] = ak;</span>
<span class="line-added">1970                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">1971                             a[--upper] = ak;</span>
<span class="line-added">1972                         }</span>
<span class="line-added">1973                     }</span>
<span class="line-added">1974                 }</span>
<span class="line-added">1975 </span>
<span class="line-added">1976                 /*</span>
<span class="line-added">1977                  * Swap the pivot into its final position.</span>
<span class="line-added">1978                  */</span>
<span class="line-added">1979                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">1980 </span>
<span class="line-added">1981                 /*</span>
<span class="line-added">1982                  * Sort the right part, excluding known pivot.</span>
<span class="line-added">1983                  * All elements from the central part are</span>
<span class="line-added">1984                  * equal and therefore already sorted.</span>
<span class="line-added">1985                  */</span>
<span class="line-added">1986                 sort(a, bits | 1, upper, high);</span>
<span class="line-added">1987             }</span>
<span class="line-added">1988             high = lower; // Iterate along the left part</span>
<span class="line-added">1989         }</span>
<span class="line-added">1990     }</span>
<span class="line-added">1991 </span>
<span class="line-added">1992     /**</span>
<span class="line-added">1993      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">1994      *</span>
<span class="line-added">1995      * @param a the array to be sorted</span>
<span class="line-added">1996      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1997      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1998      */</span>
<span class="line-added">1999     private static void insertionSort(char[] a, int low, int high) {</span>
<span class="line-added">2000         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2001             char ai = a[i = k];</span>
<span class="line-added">2002 </span>
<span class="line-added">2003             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2004                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2005                     a[i + 1] = a[i];</span>
<span class="line-added">2006                 }</span>
<span class="line-added">2007                 a[i + 1] = ai;</span>
<span class="line-added">2008             }</span>
<span class="line-added">2009         }</span>
<span class="line-added">2010     }</span>
<span class="line-added">2011 </span>
<span class="line-added">2012     /**</span>
<span class="line-added">2013      * The number of distinct char values.</span>
<span class="line-added">2014      */</span>
<span class="line-added">2015     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-added">2016 </span>
<span class="line-added">2017     /**</span>
<span class="line-added">2018      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">2019      *</span>
<span class="line-added">2020      * @param a the array to be sorted</span>
<span class="line-added">2021      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2022      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2023      */</span>
<span class="line-added">2024     private static void countingSort(char[] a, int low, int high) {</span>
<span class="line-added">2025         int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="line-added">2026 </span>
<span class="line-added">2027         /*</span>
<span class="line-added">2028          * Compute a histogram with the number of each values.</span>
<span class="line-added">2029          */</span>
<span class="line-added">2030         for (int i = high; i &gt; low; ++count[a[--i]]);</span>
<span class="line-added">2031 </span>
<span class="line-added">2032         /*</span>
<span class="line-added">2033          * Place values on their final positions.</span>
<span class="line-added">2034          */</span>
<span class="line-added">2035         if (high - low &gt; NUM_CHAR_VALUES) {</span>
<span class="line-added">2036             for (int i = NUM_CHAR_VALUES; i &gt; 0; ) {</span>
<span class="line-added">2037                 for (low = high - count[--i]; high &gt; low;</span>
<span class="line-added">2038                     a[--high] = (char) i</span>
<span class="line-added">2039                 );</span>
<span class="line-added">2040             }</span>
<span class="line-added">2041         } else {</span>
<span class="line-added">2042             for (int i = NUM_CHAR_VALUES; high &gt; low; ) {</span>
<span class="line-added">2043                 while (count[--i] == 0);</span>
<span class="line-added">2044                 int c = count[i];</span>
<span class="line-added">2045 </span>
<span class="line-added">2046                 do {</span>
<span class="line-added">2047                     a[--high] = (char) i;</span>
<span class="line-added">2048                 } while (--c &gt; 0);</span>
<span class="line-added">2049             }</span>
<span class="line-added">2050         }</span>
<span class="line-added">2051     }</span>
<span class="line-added">2052 </span>
<span class="line-added">2053 // [short]</span>
<span class="line-added">2054 </span>
<span class="line-added">2055     /**</span>
<span class="line-added">2056      * Sorts the specified range of the array using</span>
<span class="line-added">2057      * counting sort or Dual-Pivot Quicksort.</span>
<span class="line-added">2058      *</span>
<span class="line-added">2059      * @param a the array to be sorted</span>
<span class="line-added">2060      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2061      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2062      */</span>
<span class="line-added">2063     static void sort(short[] a, int low, int high) {</span>
<span class="line-added">2064         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="line-added">2065             countingSort(a, low, high);</span>
<span class="line-added">2066         } else {</span>
<span class="line-added">2067             sort(a, 0, low, high);</span>
<span class="line-added">2068         }</span>
<span class="line-added">2069     }</span>
<span class="line-added">2070 </span>
<span class="line-added">2071     /**</span>
<span class="line-added">2072      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">2073      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">2074      *</span>
<span class="line-added">2075      * @param a the array to be sorted</span>
<span class="line-added">2076      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">2077      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">2078      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2079      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2080      */</span>
<span class="line-added">2081     static void sort(short[] a, int bits, int low, int high) {</span>
<span class="line-added">2082         while (true) {</span>
<span class="line-added">2083             int end = high - 1, size = high - low;</span>
<span class="line-added">2084 </span>
<span class="line-added">2085             /*</span>
<span class="line-added">2086              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">2087              */</span>
<span class="line-added">2088             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">2089                 insertionSort(a, low, high);</span>
<span class="line-added">2090                 return;</span>
<span class="line-added">2091             }</span>
<span class="line-added">2092 </span>
<span class="line-added">2093             /*</span>
<span class="line-added">2094              * Switch to counting sort if execution</span>
<span class="line-added">2095              * time is becoming quadratic.</span>
<span class="line-added">2096              */</span>
<span class="line-added">2097             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">2098                 countingSort(a, low, high);</span>
<span class="line-added">2099                 return;</span>
<span class="line-added">2100             }</span>
<span class="line-added">2101 </span>
<span class="line-added">2102             /*</span>
<span class="line-added">2103              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">2104              * to select five sample elements and determine pivots.</span>
<span class="line-added">2105              */</span>
<span class="line-added">2106             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">2107 </span>
<span class="line-added">2108             /*</span>
<span class="line-added">2109              * Five elements around (and including) the central element</span>
<span class="line-added">2110              * will be used for pivot selection as described below. The</span>
<span class="line-added">2111              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">2112              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">2113              */</span>
<span class="line-added">2114             int e1 = low + step;</span>
<span class="line-added">2115             int e5 = end - step;</span>
<span class="line-added">2116             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2117             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">2118             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2119             short a3 = a[e3];</span>
<span class="line-added">2120 </span>
<span class="line-added">2121             /*</span>
<span class="line-added">2122              * Sort these elements in place by the combination</span>
<span class="line-added">2123              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">2124              *</span>
<span class="line-added">2125              *    5 ------o-----------o------------</span>
<span class="line-added">2126              *            |           |</span>
<span class="line-added">2127              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">2128              *            |     |           |</span>
<span class="line-added">2129              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">2130              *                  |     |</span>
<span class="line-added">2131              *    1 ------------o-----o------------</span>
<span class="line-added">2132              */</span>
<span class="line-added">2133             if (a[e5] &lt; a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2134             if (a[e4] &lt; a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2135             if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">2136             if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2137             if (a[e4] &lt; a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2138 </span>
<span class="line-added">2139             if (a3 &lt; a[e2]) {</span>
<span class="line-added">2140                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">2141                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">2142                 } else {</span>
<span class="line-added">2143                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">2144                 }</span>
<span class="line-added">2145             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">2146                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">2147                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">2148                 } else {</span>
<span class="line-added">2149                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">2150                 }</span>
<span class="line-added">2151             }</span>
<span class="line-added">2152 </span>
<span class="line-added">2153             // Pointers</span>
<span class="line-added">2154             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">2155             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">2156 </span>
<span class="line-added">2157             /*</span>
<span class="line-added">2158              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">2159              */</span>
<span class="line-added">2160             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">2161 </span>
<span class="line-added">2162                 /*</span>
<span class="line-added">2163                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">2164                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">2165                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">2166                  */</span>
<span class="line-added">2167                 short pivot1 = a[e1];</span>
<span class="line-added">2168                 short pivot2 = a[e5];</span>
<span class="line-added">2169 </span>
<span class="line-added">2170                 /*</span>
<span class="line-added">2171                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">2172                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">2173                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">2174                  * into their final positions, and excluded from the next</span>
<span class="line-added">2175                  * subsequent sorting.</span>
<span class="line-added">2176                  */</span>
<span class="line-added">2177                 a[e1] = a[lower];</span>
<span class="line-added">2178                 a[e5] = a[upper];</span>
<span class="line-added">2179 </span>
<span class="line-added">2180                 /*</span>
<span class="line-added">2181                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">2182                  */</span>
<span class="line-added">2183                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">2184                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">2185 </span>
<span class="line-added">2186                 /*</span>
<span class="line-added">2187                  * Backward 3-interval partitioning</span>
<span class="line-added">2188                  *</span>
<span class="line-added">2189                  *   left part                 central part          right part</span>
<span class="line-added">2190                  * +------------------------------------------------------------+</span>
<span class="line-added">2191                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">2192                  * +------------------------------------------------------------+</span>
<span class="line-added">2193                  *             ^       ^                            ^</span>
<span class="line-added">2194                  *             |       |                            |</span>
<span class="line-added">2195                  *           lower     k                          upper</span>
<span class="line-added">2196                  *</span>
<span class="line-added">2197                  * Invariants:</span>
<span class="line-added">2198                  *</span>
<span class="line-added">2199                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">2200                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">2201                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">2202                  *</span>
<span class="line-added">2203                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2204                  */</span>
<span class="line-added">2205                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2206                     short ak = a[k];</span>
<span class="line-added">2207 </span>
<span class="line-added">2208                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">2209                         while (lower &lt; k) {</span>
<span class="line-added">2210                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">2211                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">2212                                     a[k] = a[--upper];</span>
<span class="line-added">2213                                     a[upper] = a[lower];</span>
<span class="line-added">2214                                 } else {</span>
<span class="line-added">2215                                     a[k] = a[lower];</span>
<span class="line-added">2216                                 }</span>
<span class="line-added">2217                                 a[lower] = ak;</span>
<span class="line-added">2218                                 break;</span>
<span class="line-added">2219                             }</span>
<span class="line-added">2220                         }</span>
<span class="line-added">2221                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">2222                         a[k] = a[--upper];</span>
<span class="line-added">2223                         a[upper] = ak;</span>
<span class="line-added">2224                     }</span>
<span class="line-added">2225                 }</span>
<span class="line-added">2226 </span>
<span class="line-added">2227                 /*</span>
<span class="line-added">2228                  * Swap the pivots into their final positions.</span>
<span class="line-added">2229                  */</span>
<span class="line-added">2230                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">2231                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">2232 </span>
<span class="line-added">2233                 /*</span>
<span class="line-added">2234                  * Sort non-left parts recursively,</span>
<span class="line-added">2235                  * excluding known pivots.</span>
<span class="line-added">2236                  */</span>
<span class="line-added">2237                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="line-added">2238                 sort(a, bits | 1, upper + 1, high);</span>
<span class="line-added">2239 </span>
<span class="line-added">2240             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">2241 </span>
<span class="line-added">2242                 /*</span>
<span class="line-added">2243                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">2244                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">2245                  */</span>
<span class="line-added">2246                 short pivot = a[e3];</span>
<span class="line-added">2247 </span>
<span class="line-added">2248                 /*</span>
<span class="line-added">2249                  * The first element to be sorted is moved to the</span>
<span class="line-added">2250                  * location formerly occupied by the pivot. After</span>
<span class="line-added">2251                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">2252                  * back into its final position, and excluded from</span>
<span class="line-added">2253                  * the next subsequent sorting.</span>
<span class="line-added">2254                  */</span>
<span class="line-added">2255                 a[e3] = a[lower];</span>
<span class="line-added">2256 </span>
<span class="line-added">2257                 /*</span>
<span class="line-added">2258                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">2259                  *</span>
<span class="line-added">2260                  *   left part                 central part    right part</span>
<span class="line-added">2261                  * +------------------------------------------------------+</span>
<span class="line-added">2262                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">2263                  * +------------------------------------------------------+</span>
<span class="line-added">2264                  *              ^           ^                ^</span>
<span class="line-added">2265                  *              |           |                |</span>
<span class="line-added">2266                  *            lower         k              upper</span>
<span class="line-added">2267                  *</span>
<span class="line-added">2268                  * Invariants:</span>
<span class="line-added">2269                  *</span>
<span class="line-added">2270                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">2271                  *   all in (k, upper)  == pivot</span>
<span class="line-added">2272                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">2273                  *</span>
<span class="line-added">2274                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2275                  */</span>
<span class="line-added">2276                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2277                     short ak = a[k];</span>
<span class="line-added">2278 </span>
<span class="line-added">2279                     if (ak != pivot) {</span>
<span class="line-added">2280                         a[k] = pivot;</span>
<span class="line-added">2281 </span>
<span class="line-added">2282                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">2283                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">2284 </span>
<span class="line-added">2285                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">2286                                 a[--upper] = a[lower];</span>
<span class="line-added">2287                             }</span>
<span class="line-added">2288                             a[lower] = ak;</span>
<span class="line-added">2289                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">2290                             a[--upper] = ak;</span>
<span class="line-added">2291                         }</span>
<span class="line-added">2292                     }</span>
<span class="line-added">2293                 }</span>
<span class="line-added">2294 </span>
<span class="line-added">2295                 /*</span>
<span class="line-added">2296                  * Swap the pivot into its final position.</span>
<span class="line-added">2297                  */</span>
<span class="line-added">2298                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">2299 </span>
<span class="line-added">2300                 /*</span>
<span class="line-added">2301                  * Sort the right part, excluding known pivot.</span>
<span class="line-added">2302                  * All elements from the central part are</span>
<span class="line-added">2303                  * equal and therefore already sorted.</span>
<span class="line-added">2304                  */</span>
<span class="line-added">2305                 sort(a, bits | 1, upper, high);</span>
<span class="line-added">2306             }</span>
<span class="line-added">2307             high = lower; // Iterate along the left part</span>
<span class="line-added">2308         }</span>
<span class="line-added">2309     }</span>
<span class="line-added">2310 </span>
<span class="line-added">2311     /**</span>
<span class="line-added">2312      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">2313      *</span>
<span class="line-added">2314      * @param a the array to be sorted</span>
<span class="line-added">2315      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2316      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2317      */</span>
<span class="line-added">2318     private static void insertionSort(short[] a, int low, int high) {</span>
<span class="line-added">2319         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2320             short ai = a[i = k];</span>
<span class="line-added">2321 </span>
<span class="line-added">2322             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2323                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2324                     a[i + 1] = a[i];</span>
<span class="line-added">2325                 }</span>
<span class="line-added">2326                 a[i + 1] = ai;</span>
<span class="line-added">2327             }</span>
<span class="line-added">2328         }</span>
<span class="line-added">2329     }</span>
<span class="line-added">2330 </span>
<span class="line-added">2331     /**</span>
<span class="line-added">2332      * The number of distinct short values.</span>
<span class="line-added">2333      */</span>
<span class="line-added">2334     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-added">2335 </span>
<span class="line-added">2336     /**</span>
<span class="line-added">2337      * Max index of short counter.</span>
<span class="line-added">2338      */</span>
<span class="line-added">2339     private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;</span>
<span class="line-added">2340 </span>
<span class="line-added">2341     /**</span>
<span class="line-added">2342      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">2343      *</span>
<span class="line-added">2344      * @param a the array to be sorted</span>
<span class="line-added">2345      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2346      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2347      */</span>
<span class="line-added">2348     private static void countingSort(short[] a, int low, int high) {</span>
<span class="line-added">2349         int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="line-added">2350 </span>
<span class="line-added">2351         /*</span>
<span class="line-added">2352          * Compute a histogram with the number of each values.</span>
<span class="line-added">2353          */</span>
<span class="line-added">2354         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFFFF]);</span>
<span class="line-added">2355 </span>
<span class="line-added">2356         /*</span>
<span class="line-added">2357          * Place values on their final positions.</span>
<span class="line-added">2358          */</span>
<span class="line-added">2359         if (high - low &gt; NUM_SHORT_VALUES) {</span>
<span class="line-added">2360             for (int i = MAX_SHORT_INDEX; --i &gt; Short.MAX_VALUE; ) {</span>
<span class="line-added">2361                 int value = i &amp; 0xFFFF;</span>
<span class="line-added">2362 </span>
<span class="line-added">2363                 for (low = high - count[value]; high &gt; low;</span>
<span class="line-added">2364                     a[--high] = (short) value</span>
<span class="line-added">2365                 );</span>
<span class="line-added">2366             }</span>
<span class="line-added">2367         } else {</span>
<span class="line-added">2368             for (int i = MAX_SHORT_INDEX; high &gt; low; ) {</span>
<span class="line-added">2369                 while (count[--i &amp; 0xFFFF] == 0);</span>
<span class="line-added">2370 </span>
<span class="line-added">2371                 int value = i &amp; 0xFFFF;</span>
<span class="line-added">2372                 int c = count[value];</span>
<span class="line-added">2373 </span>
<span class="line-added">2374                 do {</span>
<span class="line-added">2375                     a[--high] = (short) value;</span>
<span class="line-added">2376                 } while (--c &gt; 0);</span>
<span class="line-added">2377             }</span>
<span class="line-added">2378         }</span>
<span class="line-added">2379     }</span>
<span class="line-added">2380 </span>
<span class="line-added">2381 // [float]</span>
<span class="line-added">2382 </span>
<span class="line-added">2383     /**</span>
<span class="line-added">2384      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added">2385      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added">2386      *</span>
<span class="line-added">2387      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added">2388      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added">2389      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added">2390      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added">2391      * parallelism to process the partitions.</span>
<span class="line-added">2392      *</span>
<span class="line-added">2393      * @param a the array to be sorted</span>
<span class="line-added">2394      * @param parallelism the parallelism level</span>
<span class="line-added">2395      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2396      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2397      */</span>
<span class="line-added">2398     static void sort(float[] a, int parallelism, int low, int high) {</span>
<span class="line-added">2399         /*</span>
<span class="line-added">2400          * Phase 1. Count the number of negative zero -0.0f,</span>
<span class="line-added">2401          * turn them into positive zero, and move all NaNs</span>
<span class="line-added">2402          * to the end of the array.</span>
<span class="line-added">2403          */</span>
<span class="line-added">2404         int numNegativeZero = 0;</span>
<span class="line-added">2405 </span>
<span class="line-added">2406         for (int k = high; k &gt; low; ) {</span>
<span class="line-added">2407             float ak = a[--k];</span>
<span class="line-added">2408 </span>
<span class="line-added">2409             if (ak == 0.0f &amp;&amp; Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="line-added">2410                 numNegativeZero += 1;</span>
<span class="line-added">2411                 a[k] = 0.0f;</span>
<span class="line-added">2412             } else if (ak != ak) { // ak is NaN</span>
<span class="line-added">2413                 a[k] = a[--high];</span>
<span class="line-added">2414                 a[high] = ak;</span>
<span class="line-added">2415             }</span>
<span class="line-added">2416         }</span>
<span class="line-added">2417 </span>
<span class="line-added">2418         /*</span>
<span class="line-added">2419          * Phase 2. Sort everything except NaNs,</span>
<span class="line-added">2420          * which are already in place.</span>
<span class="line-added">2421          */</span>
<span class="line-added">2422         int size = high - low;</span>
<span class="line-added">2423 </span>
<span class="line-added">2424         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added">2425             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added">2426             float[] b = depth == 0 ? null : new float[size];</span>
<span class="line-added">2427             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added">2428         } else {</span>
<span class="line-added">2429             sort(null, a, 0, low, high);</span>
<span class="line-added">2430         }</span>
<span class="line-added">2431 </span>
<span class="line-added">2432         /*</span>
<span class="line-added">2433          * Phase 3. Turn positive zero 0.0f</span>
<span class="line-added">2434          * back into negative zero -0.0f.</span>
<span class="line-added">2435          */</span>
<span class="line-added">2436         if (++numNegativeZero == 1) {</span>
<span class="line-added">2437             return;</span>
<span class="line-added">2438         }</span>
<span class="line-added">2439 </span>
<span class="line-added">2440         /*</span>
<span class="line-added">2441          * Find the position one less than</span>
<span class="line-added">2442          * the index of the first zero.</span>
<span class="line-added">2443          */</span>
<span class="line-added">2444         while (low &lt;= high) {</span>
<span class="line-added">2445             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="line-added">2446 </span>
<span class="line-added">2447             if (a[middle] &lt; 0) {</span>
<span class="line-added">2448                 low = middle + 1;</span>
<span class="line-added">2449             } else {</span>
<span class="line-added">2450                 high = middle - 1;</span>
<span class="line-added">2451             }</span>
<span class="line-added">2452         }</span>
<span class="line-added">2453 </span>
<span class="line-added">2454         /*</span>
<span class="line-added">2455          * Replace the required number of 0.0f by -0.0f.</span>
<span class="line-added">2456          */</span>
<span class="line-added">2457         while (--numNegativeZero &gt; 0) {</span>
<span class="line-added">2458             a[++high] = -0.0f;</span>
<span class="line-added">2459         }</span>
<span class="line-added">2460     }</span>
<span class="line-added">2461 </span>
<span class="line-added">2462     /**</span>
<span class="line-added">2463      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">2464      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">2465      *</span>
<span class="line-added">2466      * @param sorter parallel context</span>
<span class="line-added">2467      * @param a the array to be sorted</span>
<span class="line-added">2468      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">2469      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">2470      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2471      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2472      */</span>
<span class="line-added">2473     static void sort(Sorter sorter, float[] a, int bits, int low, int high) {</span>
<span class="line-added">2474         while (true) {</span>
<span class="line-added">2475             int end = high - 1, size = high - low;</span>
<span class="line-added">2476 </span>
<span class="line-added">2477             /*</span>
<span class="line-added">2478              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-added">2479              */</span>
<span class="line-added">2480             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-added">2481                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-added">2482                 return;</span>
<span class="line-added">2483             }</span>
<span class="line-added">2484 </span>
<span class="line-added">2485             /*</span>
<span class="line-added">2486              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">2487              */</span>
<span class="line-added">2488             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">2489                 insertionSort(a, low, high);</span>
<span class="line-added">2490                 return;</span>
<span class="line-added">2491             }</span>
<span class="line-added">2492 </span>
<span class="line-added">2493             /*</span>
<span class="line-added">2494              * Check if the whole array or large non-leftmost</span>
<span class="line-added">2495              * parts are nearly sorted and then merge runs.</span>
<span class="line-added">2496              */</span>
<span class="line-added">2497             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added">2498                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added">2499                 return;</span>
<span class="line-added">2500             }</span>
<span class="line-added">2501 </span>
<span class="line-added">2502             /*</span>
<span class="line-added">2503              * Switch to heap sort if execution</span>
<span class="line-added">2504              * time is becoming quadratic.</span>
<span class="line-added">2505              */</span>
<span class="line-added">2506             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">2507                 heapSort(a, low, high);</span>
<span class="line-added">2508                 return;</span>
<span class="line-added">2509             }</span>
<span class="line-added">2510 </span>
<span class="line-added">2511             /*</span>
<span class="line-added">2512              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">2513              * to select five sample elements and determine pivots.</span>
<span class="line-added">2514              */</span>
<span class="line-added">2515             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">2516 </span>
<span class="line-added">2517             /*</span>
<span class="line-added">2518              * Five elements around (and including) the central element</span>
<span class="line-added">2519              * will be used for pivot selection as described below. The</span>
<span class="line-added">2520              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">2521              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">2522              */</span>
<span class="line-added">2523             int e1 = low + step;</span>
<span class="line-added">2524             int e5 = end - step;</span>
<span class="line-added">2525             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2526             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">2527             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2528             float a3 = a[e3];</span>
<span class="line-added">2529 </span>
<span class="line-added">2530             /*</span>
<span class="line-added">2531              * Sort these elements in place by the combination</span>
<span class="line-added">2532              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">2533              *</span>
<span class="line-added">2534              *    5 ------o-----------o------------</span>
<span class="line-added">2535              *            |           |</span>
<span class="line-added">2536              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">2537              *            |     |           |</span>
<span class="line-added">2538              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">2539              *                  |     |</span>
<span class="line-added">2540              *    1 ------------o-----o------------</span>
<span class="line-added">2541              */</span>
<span class="line-added">2542             if (a[e5] &lt; a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2543             if (a[e4] &lt; a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2544             if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">2545             if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2546             if (a[e4] &lt; a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2547 </span>
<span class="line-added">2548             if (a3 &lt; a[e2]) {</span>
<span class="line-added">2549                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">2550                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">2551                 } else {</span>
<span class="line-added">2552                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">2553                 }</span>
<span class="line-added">2554             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">2555                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">2556                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">2557                 } else {</span>
<span class="line-added">2558                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">2559                 }</span>
<span class="line-added">2560             }</span>
<span class="line-added">2561 </span>
<span class="line-added">2562             // Pointers</span>
<span class="line-added">2563             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">2564             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">2565 </span>
<span class="line-added">2566             /*</span>
<span class="line-added">2567              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">2568              */</span>
<span class="line-added">2569             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">2570 </span>
<span class="line-added">2571                 /*</span>
<span class="line-added">2572                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">2573                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">2574                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">2575                  */</span>
<span class="line-added">2576                 float pivot1 = a[e1];</span>
<span class="line-added">2577                 float pivot2 = a[e5];</span>
<span class="line-added">2578 </span>
<span class="line-added">2579                 /*</span>
<span class="line-added">2580                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">2581                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">2582                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">2583                  * into their final positions, and excluded from the next</span>
<span class="line-added">2584                  * subsequent sorting.</span>
<span class="line-added">2585                  */</span>
<span class="line-added">2586                 a[e1] = a[lower];</span>
<span class="line-added">2587                 a[e5] = a[upper];</span>
<span class="line-added">2588 </span>
<span class="line-added">2589                 /*</span>
<span class="line-added">2590                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">2591                  */</span>
<span class="line-added">2592                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">2593                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">2594 </span>
<span class="line-added">2595                 /*</span>
<span class="line-added">2596                  * Backward 3-interval partitioning</span>
<span class="line-added">2597                  *</span>
<span class="line-added">2598                  *   left part                 central part          right part</span>
<span class="line-added">2599                  * +------------------------------------------------------------+</span>
<span class="line-added">2600                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">2601                  * +------------------------------------------------------------+</span>
<span class="line-added">2602                  *             ^       ^                            ^</span>
<span class="line-added">2603                  *             |       |                            |</span>
<span class="line-added">2604                  *           lower     k                          upper</span>
<span class="line-added">2605                  *</span>
<span class="line-added">2606                  * Invariants:</span>
<span class="line-added">2607                  *</span>
<span class="line-added">2608                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">2609                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">2610                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">2611                  *</span>
<span class="line-added">2612                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2613                  */</span>
<span class="line-added">2614                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2615                     float ak = a[k];</span>
<span class="line-added">2616 </span>
<span class="line-added">2617                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">2618                         while (lower &lt; k) {</span>
<span class="line-added">2619                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">2620                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">2621                                     a[k] = a[--upper];</span>
<span class="line-added">2622                                     a[upper] = a[lower];</span>
<span class="line-added">2623                                 } else {</span>
<span class="line-added">2624                                     a[k] = a[lower];</span>
<span class="line-added">2625                                 }</span>
<span class="line-added">2626                                 a[lower] = ak;</span>
<span class="line-added">2627                                 break;</span>
<span class="line-added">2628                             }</span>
<span class="line-added">2629                         }</span>
<span class="line-added">2630                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">2631                         a[k] = a[--upper];</span>
<span class="line-added">2632                         a[upper] = ak;</span>
<span class="line-added">2633                     }</span>
<span class="line-added">2634                 }</span>
<span class="line-added">2635 </span>
<span class="line-added">2636                 /*</span>
<span class="line-added">2637                  * Swap the pivots into their final positions.</span>
<span class="line-added">2638                  */</span>
<span class="line-added">2639                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">2640                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">2641 </span>
<span class="line-added">2642                 /*</span>
<span class="line-added">2643                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">2644                  * excluding known pivots.</span>
<span class="line-added">2645                  */</span>
<span class="line-added">2646                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">2647                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">2648                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">2649                 } else {</span>
<span class="line-added">2650                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">2651                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="line-added">2652                 }</span>
<span class="line-added">2653 </span>
<span class="line-added">2654             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">2655 </span>
<span class="line-added">2656                 /*</span>
<span class="line-added">2657                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">2658                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">2659                  */</span>
<span class="line-added">2660                 float pivot = a[e3];</span>
<span class="line-added">2661 </span>
<span class="line-added">2662                 /*</span>
<span class="line-added">2663                  * The first element to be sorted is moved to the</span>
<span class="line-added">2664                  * location formerly occupied by the pivot. After</span>
<span class="line-added">2665                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">2666                  * back into its final position, and excluded from</span>
<span class="line-added">2667                  * the next subsequent sorting.</span>
<span class="line-added">2668                  */</span>
<span class="line-added">2669                 a[e3] = a[lower];</span>
<span class="line-added">2670 </span>
<span class="line-added">2671                 /*</span>
<span class="line-added">2672                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">2673                  *</span>
<span class="line-added">2674                  *   left part                 central part    right part</span>
<span class="line-added">2675                  * +------------------------------------------------------+</span>
<span class="line-added">2676                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">2677                  * +------------------------------------------------------+</span>
<span class="line-added">2678                  *              ^           ^                ^</span>
<span class="line-added">2679                  *              |           |                |</span>
<span class="line-added">2680                  *            lower         k              upper</span>
<span class="line-added">2681                  *</span>
<span class="line-added">2682                  * Invariants:</span>
<span class="line-added">2683                  *</span>
<span class="line-added">2684                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">2685                  *   all in (k, upper)  == pivot</span>
<span class="line-added">2686                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">2687                  *</span>
<span class="line-added">2688                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2689                  */</span>
<span class="line-added">2690                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2691                     float ak = a[k];</span>
<span class="line-added">2692 </span>
<span class="line-added">2693                     if (ak != pivot) {</span>
<span class="line-added">2694                         a[k] = pivot;</span>
<span class="line-added">2695 </span>
<span class="line-added">2696                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">2697                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">2698 </span>
<span class="line-added">2699                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">2700                                 a[--upper] = a[lower];</span>
<span class="line-added">2701                             }</span>
<span class="line-added">2702                             a[lower] = ak;</span>
<span class="line-added">2703                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">2704                             a[--upper] = ak;</span>
<span class="line-added">2705                         }</span>
<span class="line-added">2706                     }</span>
<span class="line-added">2707                 }</span>
<span class="line-added">2708 </span>
<span class="line-added">2709                 /*</span>
<span class="line-added">2710                  * Swap the pivot into its final position.</span>
<span class="line-added">2711                  */</span>
<span class="line-added">2712                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">2713 </span>
<span class="line-added">2714                 /*</span>
<span class="line-added">2715                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">2716                  * known pivot. All elements from the central part are</span>
<span class="line-added">2717                  * equal and therefore already sorted.</span>
<span class="line-added">2718                  */</span>
<span class="line-added">2719                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">2720                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">2721                 } else {</span>
<span class="line-added">2722                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">2723                 }</span>
<span class="line-added">2724             }</span>
<span class="line-added">2725             high = lower; // Iterate along the left part</span>
<span class="line-added">2726         }</span>
<span class="line-added">2727     }</span>
<span class="line-added">2728 </span>
<span class="line-added">2729     /**</span>
<span class="line-added">2730      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">2731      *</span>
<span class="line-added">2732      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">2733      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">2734      *</span>
<span class="line-added">2735      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">2736      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">2737      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">2738      * expensive check of the left range can be skipped on each</span>
<span class="line-added">2739      * iteration unless it is the leftmost call.</span>
<span class="line-added">2740      *</span>
<span class="line-added">2741      * @param a the array to be sorted</span>
<span class="line-added">2742      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2743      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">2744      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2745      */</span>
<span class="line-added">2746     private static void mixedInsertionSort(float[] a, int low, int end, int high) {</span>
<span class="line-added">2747         if (end == high) {</span>
<span class="line-added">2748 </span>
<span class="line-added">2749             /*</span>
<span class="line-added">2750              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added">2751              */</span>
<span class="line-added">2752             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">2753                 float ai = a[i = low];</span>
<span class="line-added">2754 </span>
<span class="line-added">2755                 while (ai &lt; a[--i]) {</span>
<span class="line-added">2756                     a[i + 1] = a[i];</span>
<span class="line-added">2757                 }</span>
<span class="line-added">2758                 a[i + 1] = ai;</span>
<span class="line-added">2759             }</span>
<span class="line-added">2760         } else {</span>
<span class="line-added">2761 </span>
<span class="line-added">2762             /*</span>
<span class="line-added">2763              * Start with pin insertion sort on small part.</span>
<span class="line-added">2764              *</span>
<span class="line-added">2765              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added">2766              * The main idea of this sort is to put elements larger</span>
<span class="line-added">2767              * than an element called pin to the end of array (the</span>
<span class="line-added">2768              * proper area for such elements). It avoids expensive</span>
<span class="line-added">2769              * movements of these elements through the whole array.</span>
<span class="line-added">2770              */</span>
<span class="line-added">2771             float pin = a[end];</span>
<span class="line-added">2772 </span>
<span class="line-added">2773             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-added">2774                 float ai = a[i = low];</span>
<span class="line-added">2775 </span>
<span class="line-added">2776                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-added">2777 </span>
<span class="line-added">2778                     /*</span>
<span class="line-added">2779                      * Insert small element into sorted part.</span>
<span class="line-added">2780                      */</span>
<span class="line-added">2781                     a[i] = a[--i];</span>
<span class="line-added">2782 </span>
<span class="line-added">2783                     while (ai &lt; a[--i]) {</span>
<span class="line-added">2784                         a[i + 1] = a[i];</span>
<span class="line-added">2785                     }</span>
<span class="line-added">2786                     a[i + 1] = ai;</span>
<span class="line-added">2787 </span>
<span class="line-added">2788                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-added">2789 </span>
<span class="line-added">2790                     /*</span>
<span class="line-added">2791                      * Find element smaller than pin.</span>
<span class="line-added">2792                      */</span>
<span class="line-added">2793                     while (a[--p] &gt; pin);</span>
<span class="line-added">2794 </span>
<span class="line-added">2795                     /*</span>
<span class="line-added">2796                      * Swap it with large element.</span>
<span class="line-added">2797                      */</span>
<span class="line-added">2798                     if (p &gt; i) {</span>
<span class="line-added">2799                         ai = a[p];</span>
<span class="line-added">2800                         a[p] = a[i];</span>
<span class="line-added">2801                     }</span>
<span class="line-added">2802 </span>
<span class="line-added">2803                     /*</span>
<span class="line-added">2804                      * Insert small element into sorted part.</span>
<span class="line-added">2805                      */</span>
<span class="line-added">2806                     while (ai &lt; a[--i]) {</span>
<span class="line-added">2807                         a[i + 1] = a[i];</span>
<span class="line-added">2808                     }</span>
<span class="line-added">2809                     a[i + 1] = ai;</span>
<span class="line-added">2810                 }</span>
<span class="line-added">2811             }</span>
<span class="line-added">2812 </span>
<span class="line-added">2813             /*</span>
<span class="line-added">2814              * Continue with pair insertion sort on remain part.</span>
<span class="line-added">2815              */</span>
<span class="line-added">2816             for (int i; low &lt; high; ++low) {</span>
<span class="line-added">2817                 float a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added">2818 </span>
<span class="line-added">2819                 /*</span>
<span class="line-added">2820                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added">2821                  * larger element and then insert the smaller element, but</span>
<span class="line-added">2822                  * from the position where the larger element was inserted.</span>
<span class="line-added">2823                  */</span>
<span class="line-added">2824                 if (a1 &gt; a2) {</span>
<span class="line-added">2825 </span>
<span class="line-added">2826                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">2827                         a[i + 2] = a[i];</span>
<span class="line-added">2828                     }</span>
<span class="line-added">2829                     a[++i + 1] = a1;</span>
<span class="line-added">2830 </span>
<span class="line-added">2831                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">2832                         a[i + 1] = a[i];</span>
<span class="line-added">2833                     }</span>
<span class="line-added">2834                     a[i + 1] = a2;</span>
<span class="line-added">2835 </span>
<span class="line-added">2836                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="line-added">2837 </span>
<span class="line-added">2838                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">2839                         a[i + 2] = a[i];</span>
<span class="line-added">2840                     }</span>
<span class="line-added">2841                     a[++i + 1] = a2;</span>
<span class="line-added">2842 </span>
<span class="line-added">2843                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">2844                         a[i + 1] = a[i];</span>
<span class="line-added">2845                     }</span>
<span class="line-added">2846                     a[i + 1] = a1;</span>
<span class="line-added">2847                 }</span>
<span class="line-added">2848             }</span>
<span class="line-added">2849         }</span>
<span class="line-added">2850     }</span>
<span class="line-added">2851 </span>
<span class="line-added">2852     /**</span>
<span class="line-added">2853      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">2854      *</span>
<span class="line-added">2855      * @param a the array to be sorted</span>
<span class="line-added">2856      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2857      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2858      */</span>
<span class="line-added">2859     private static void insertionSort(float[] a, int low, int high) {</span>
<span class="line-added">2860         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2861             float ai = a[i = k];</span>
<span class="line-added">2862 </span>
<span class="line-added">2863             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2864                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2865                     a[i + 1] = a[i];</span>
<span class="line-added">2866                 }</span>
<span class="line-added">2867                 a[i + 1] = ai;</span>
<span class="line-added">2868             }</span>
<span class="line-added">2869         }</span>
<span class="line-added">2870     }</span>
<span class="line-added">2871 </span>
<span class="line-added">2872     /**</span>
<span class="line-added">2873      * Sorts the specified range of the array using heap sort.</span>
<span class="line-added">2874      *</span>
<span class="line-added">2875      * @param a the array to be sorted</span>
<span class="line-added">2876      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2877      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2878      */</span>
<span class="line-added">2879     private static void heapSort(float[] a, int low, int high) {</span>
<span class="line-added">2880         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-added">2881             pushDown(a, --k, a[k], low, high);</span>
<span class="line-added">2882         }</span>
<span class="line-added">2883         while (--high &gt; low) {</span>
<span class="line-added">2884             float max = a[low];</span>
<span class="line-added">2885             pushDown(a, low, a[high], low, high);</span>
<span class="line-added">2886             a[high] = max;</span>
<span class="line-added">2887         }</span>
<span class="line-added">2888     }</span>
<span class="line-added">2889 </span>
<span class="line-added">2890     /**</span>
<span class="line-added">2891      * Pushes specified element down during heap sort.</span>
<span class="line-added">2892      *</span>
<span class="line-added">2893      * @param a the given array</span>
<span class="line-added">2894      * @param p the start index</span>
<span class="line-added">2895      * @param value the given element</span>
<span class="line-added">2896      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2897      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2898      */</span>
<span class="line-added">2899     private static void pushDown(float[] a, int p, float value, int low, int high) {</span>
<span class="line-added">2900         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">2901             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">2902 </span>
<span class="line-added">2903             if (k &gt; high) {</span>
<span class="line-added">2904                 break;</span>
<span class="line-added">2905             }</span>
<span class="line-added">2906             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">2907                 --k;</span>
<span class="line-added">2908             }</span>
<span class="line-added">2909             if (a[k] &lt;= value) {</span>
<span class="line-added">2910                 break;</span>
<span class="line-added">2911             }</span>
<span class="line-added">2912         }</span>
<span class="line-added">2913         a[p] = value;</span>
<span class="line-added">2914     }</span>
<span class="line-added">2915 </span>
<span class="line-added">2916     /**</span>
<span class="line-added">2917      * Tries to sort the specified range of the array.</span>
<span class="line-added">2918      *</span>
<span class="line-added">2919      * @param sorter parallel context</span>
<span class="line-added">2920      * @param a the array to be sorted</span>
<span class="line-added">2921      * @param low the index of the first element to be sorted</span>
<span class="line-added">2922      * @param size the array size</span>
<span class="line-added">2923      * @return true if finally sorted, false otherwise</span>
<span class="line-added">2924      */</span>
<span class="line-added">2925     private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {</span>
<span class="line-added">2926 </span>
<span class="line-added">2927         /*</span>
<span class="line-added">2928          * The run array is constructed only if initial runs are</span>
<span class="line-added">2929          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">2930          * of the i-th sequence of elements in non-descending order.</span>
<span class="line-added">2931          */</span>
<span class="line-added">2932         int[] run = null;</span>
<span class="line-added">2933         int high = low + size;</span>
<span class="line-added">2934         int count = 1, last = low;</span>
<span class="line-added">2935 </span>
<span class="line-added">2936         /*</span>
<span class="line-added">2937          * Identify all possible runs.</span>
<span class="line-added">2938          */</span>
<span class="line-added">2939         for (int k = low + 1; k &lt; high; ) {</span>
<span class="line-added">2940 </span>
<span class="line-added">2941             /*</span>
<span class="line-added">2942              * Find the end index of the current run.</span>
<span class="line-added">2943              */</span>
<span class="line-added">2944             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">2945 </span>
<span class="line-added">2946                 // Identify ascending sequence</span>
<span class="line-added">2947                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">2948 </span>
<span class="line-added">2949             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">2950 </span>
<span class="line-added">2951                 // Identify descending sequence</span>
<span class="line-added">2952                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">2953 </span>
<span class="line-added">2954                 // Reverse into ascending order</span>
<span class="line-added">2955                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">2956                     float ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">2957                 }</span>
<span class="line-added">2958             } else { // Identify constant sequence</span>
<span class="line-added">2959                 for (float ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">2960 </span>
<span class="line-added">2961                 if (k &lt; high) {</span>
<span class="line-added">2962                     continue;</span>
<span class="line-added">2963                 }</span>
<span class="line-added">2964             }</span>
<span class="line-added">2965 </span>
<span class="line-added">2966             /*</span>
<span class="line-added">2967              * Check special cases.</span>
<span class="line-added">2968              */</span>
<span class="line-added">2969             if (run == null) {</span>
<span class="line-added">2970                 if (k == high) {</span>
<span class="line-added">2971 </span>
<span class="line-added">2972                     /*</span>
<span class="line-added">2973                      * The array is monotonous sequence,</span>
<span class="line-added">2974                      * and therefore already sorted.</span>
<span class="line-added">2975                      */</span>
<span class="line-added">2976                     return true;</span>
<span class="line-added">2977                 }</span>
<span class="line-added">2978 </span>
<span class="line-added">2979                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">2980 </span>
<span class="line-added">2981                     /*</span>
<span class="line-added">2982                      * The first run is too small</span>
<span class="line-added">2983                      * to proceed with scanning.</span>
<span class="line-added">2984                      */</span>
<span class="line-added">2985                     return false;</span>
<span class="line-added">2986                 }</span>
<span class="line-added">2987 </span>
<span class="line-added">2988                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">2989                 run[0] = low;</span>
<span class="line-added">2990 </span>
<span class="line-added">2991             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">2992 </span>
<span class="line-added">2993                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">2994 </span>
<span class="line-added">2995                     /*</span>
<span class="line-added">2996                      * The first runs are not long</span>
<span class="line-added">2997                      * enough to continue scanning.</span>
<span class="line-added">2998                      */</span>
<span class="line-added">2999                     return false;</span>
<span class="line-added">3000                 }</span>
<span class="line-added">3001 </span>
<span class="line-added">3002                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">3003 </span>
<span class="line-added">3004                     /*</span>
<span class="line-added">3005                      * Array is not highly structured.</span>
<span class="line-added">3006                      */</span>
<span class="line-added">3007                     return false;</span>
<span class="line-added">3008                 }</span>
<span class="line-added">3009 </span>
<span class="line-added">3010                 if (count == run.length) {</span>
<span class="line-added">3011 </span>
<span class="line-added">3012                     /*</span>
<span class="line-added">3013                      * Increase capacity of index array.</span>
<span class="line-added">3014                      */</span>
<span class="line-added">3015                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">3016                 }</span>
<span class="line-added">3017             }</span>
<span class="line-added">3018             run[count] = (last = k);</span>
<span class="line-added">3019         }</span>
<span class="line-added">3020 </span>
<span class="line-added">3021         /*</span>
<span class="line-added">3022          * Merge runs of highly structured array.</span>
<span class="line-added">3023          */</span>
<span class="line-added">3024         if (count &gt; 1) {</span>
<span class="line-added">3025             float[] b; int offset = low;</span>
<span class="line-added">3026 </span>
<span class="line-added">3027             if (sorter == null || (b = (float[]) sorter.b) == null) {</span>
<span class="line-added">3028                 b = new float[size];</span>
<span class="line-added">3029             } else {</span>
<span class="line-added">3030                 offset = sorter.offset;</span>
<span class="line-added">3031             }</span>
<span class="line-added">3032             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
<span class="line-added">3033         }</span>
<span class="line-added">3034         return true;</span>
<span class="line-added">3035     }</span>
<span class="line-added">3036 </span>
<span class="line-added">3037     /**</span>
<span class="line-added">3038      * Merges the specified runs.</span>
<span class="line-added">3039      *</span>
<span class="line-added">3040      * @param a the source array</span>
<span class="line-added">3041      * @param b the temporary buffer used in merging</span>
<span class="line-added">3042      * @param offset the start index in the source, inclusive</span>
<span class="line-added">3043      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-added">3044      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-added">3045      * @param run the start indexes of the runs, inclusive</span>
<span class="line-added">3046      * @param lo the start index of the first run, inclusive</span>
<span class="line-added">3047      * @param hi the start index of the last run, inclusive</span>
<span class="line-added">3048      * @return the destination where runs are merged</span>
<span class="line-added">3049      */</span>
<span class="line-added">3050     private static float[] mergeRuns(float[] a, float[] b, int offset,</span>
<span class="line-added">3051             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-added">3052 </span>
<span class="line-added">3053         if (hi - lo == 1) {</span>
<span class="line-added">3054             if (aim &gt;= 0) {</span>
<span class="line-added">3055                 return a;</span>
<span class="line-added">3056             }</span>
<span class="line-added">3057             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">3058                 b[--j] = a[--i]</span>
<span class="line-added">3059             );</span>
<span class="line-added">3060             return b;</span>
<span class="line-added">3061         }</span>
<span class="line-added">3062 </span>
<span class="line-added">3063         /*</span>
<span class="line-added">3064          * Split into approximately equal parts.</span>
<span class="line-added">3065          */</span>
<span class="line-added">3066         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-added">3067         while (run[++mi + 1] &lt;= rmi);</span>
<span class="line-added">3068 </span>
<span class="line-added">3069         /*</span>
<span class="line-added">3070          * Merge the left and right parts.</span>
<span class="line-added">3071          */</span>
<span class="line-added">3072         float[] a1, a2;</span>
<span class="line-added">3073 </span>
<span class="line-added">3074         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-added">3075             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-added">3076             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-added">3077             a2 = (float[]) merger.getDestination();</span>
<span class="line-added">3078         } else {</span>
<span class="line-added">3079             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-added">3080             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
<span class="line-added">3081         }</span>
<span class="line-added">3082 </span>
<span class="line-added">3083         float[] dst = a1 == a ? b : a;</span>
<span class="line-added">3084 </span>
<span class="line-added">3085         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-added">3086         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-added">3087         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-added">3088         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-added">3089         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-added">3090 </span>
<span class="line-added">3091         if (parallel) {</span>
<span class="line-added">3092             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
<span class="line-added">3093         } else {</span>
<span class="line-added">3094             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
<span class="line-added">3095         }</span>
<span class="line-added">3096         return dst;</span>
<span class="line-added">3097     }</span>
<span class="line-added">3098 </span>
<span class="line-added">3099     /**</span>
<span class="line-added">3100      * Merges the sorted parts.</span>
<span class="line-added">3101      *</span>
<span class="line-added">3102      * @param merger parallel context</span>
<span class="line-added">3103      * @param dst the destination where parts are merged</span>
<span class="line-added">3104      * @param k the start index of the destination, inclusive</span>
<span class="line-added">3105      * @param a1 the first part</span>
<span class="line-added">3106      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-added">3107      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-added">3108      * @param a2 the second part</span>
<span class="line-added">3109      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-added">3110      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-added">3111      */</span>
<span class="line-added">3112     private static void mergeParts(Merger merger, float[] dst, int k,</span>
<span class="line-added">3113             float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {</span>
<span class="line-added">3114 </span>
<span class="line-added">3115         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-added">3116 </span>
<span class="line-added">3117             while (true) {</span>
<span class="line-added">3118 </span>
<span class="line-added">3119                 /*</span>
<span class="line-added">3120                  * The first part must be larger.</span>
<span class="line-added">3121                  */</span>
<span class="line-added">3122                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-added">3123                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-added">3124                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
<span class="line-added">3125                 }</span>
<span class="line-added">3126 </span>
<span class="line-added">3127                 /*</span>
<span class="line-added">3128                  * Small parts will be merged sequentially.</span>
<span class="line-added">3129                  */</span>
<span class="line-added">3130                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-added">3131                     break;</span>
<span class="line-added">3132                 }</span>
<span class="line-added">3133 </span>
<span class="line-added">3134                 /*</span>
<span class="line-added">3135                  * Find the median of the larger part.</span>
<span class="line-added">3136                  */</span>
<span class="line-added">3137                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-added">3138                 float key = a1[mi1];</span>
<span class="line-added">3139                 int mi2 = hi2;</span>
<span class="line-added">3140 </span>
<span class="line-added">3141                 /*</span>
<span class="line-added">3142                  * Partition the smaller part.</span>
<span class="line-added">3143                  */</span>
<span class="line-added">3144                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-added">3145                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
<span class="line-added">3146 </span>
<span class="line-added">3147                     if (key &gt; a2[t]) {</span>
<span class="line-added">3148                         loo = t + 1;</span>
<span class="line-added">3149                     } else {</span>
<span class="line-added">3150                         mi2 = t;</span>
<span class="line-added">3151                     }</span>
<span class="line-added">3152                 }</span>
<span class="line-added">3153 </span>
<span class="line-added">3154                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-added">3155 </span>
<span class="line-added">3156                 /*</span>
<span class="line-added">3157                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">3158                  */</span>
<span class="line-added">3159                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">3160 </span>
<span class="line-added">3161                 /*</span>
<span class="line-added">3162                  * Process the sub-left parts.</span>
<span class="line-added">3163                  */</span>
<span class="line-added">3164                 hi1 = mi1;</span>
<span class="line-added">3165                 hi2 = mi2;</span>
<span class="line-added">3166             }</span>
<span class="line-added">3167         }</span>
<span class="line-added">3168 </span>
<span class="line-added">3169         /*</span>
<span class="line-added">3170          * Merge small parts sequentially.</span>
<span class="line-added">3171          */</span>
<span class="line-added">3172         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-added">3173             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
<span class="line-added">3174         }</span>
<span class="line-added">3175         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-added">3176             while (lo1 &lt; hi1) {</span>
<span class="line-added">3177                 dst[k++] = a1[lo1++];</span>
<span class="line-added">3178             }</span>
<span class="line-added">3179         }</span>
<span class="line-added">3180         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-added">3181             while (lo2 &lt; hi2) {</span>
<span class="line-added">3182                 dst[k++] = a2[lo2++];</span>
<span class="line-added">3183             }</span>
<span class="line-added">3184         }</span>
<span class="line-added">3185     }</span>
<span class="line-added">3186 </span>
<span class="line-added">3187 // [double]</span>
<span class="line-added">3188 </span>
<span class="line-added">3189     /**</span>
<span class="line-added">3190      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added">3191      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added">3192      *</span>
<span class="line-added">3193      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added">3194      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added">3195      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added">3196      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added">3197      * parallelism to process the partitions.</span>
<span class="line-added">3198      *</span>
<span class="line-added">3199      * @param a the array to be sorted</span>
<span class="line-added">3200      * @param parallelism the parallelism level</span>
<span class="line-added">3201      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3202      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3203      */</span>
<span class="line-added">3204     static void sort(double[] a, int parallelism, int low, int high) {</span>
<span class="line-added">3205         /*</span>
<span class="line-added">3206          * Phase 1. Count the number of negative zero -0.0d,</span>
<span class="line-added">3207          * turn them into positive zero, and move all NaNs</span>
<span class="line-added">3208          * to the end of the array.</span>
<span class="line-added">3209          */</span>
<span class="line-added">3210         int numNegativeZero = 0;</span>
<span class="line-added">3211 </span>
<span class="line-added">3212         for (int k = high; k &gt; low; ) {</span>
<span class="line-added">3213             double ak = a[--k];</span>
<span class="line-added">3214 </span>
<span class="line-added">3215             if (ak == 0.0d &amp;&amp; Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="line-added">3216                 numNegativeZero += 1;</span>
<span class="line-added">3217                 a[k] = 0.0d;</span>
<span class="line-added">3218             } else if (ak != ak) { // ak is NaN</span>
<span class="line-added">3219                 a[k] = a[--high];</span>
<span class="line-added">3220                 a[high] = ak;</span>
<span class="line-added">3221             }</span>
<span class="line-added">3222         }</span>
<span class="line-added">3223 </span>
<span class="line-added">3224         /*</span>
<span class="line-added">3225          * Phase 2. Sort everything except NaNs,</span>
<span class="line-added">3226          * which are already in place.</span>
<span class="line-added">3227          */</span>
<span class="line-added">3228         int size = high - low;</span>
<span class="line-added">3229 </span>
<span class="line-added">3230         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added">3231             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added">3232             double[] b = depth == 0 ? null : new double[size];</span>
<span class="line-added">3233             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added">3234         } else {</span>
<span class="line-added">3235             sort(null, a, 0, low, high);</span>
<span class="line-added">3236         }</span>
<span class="line-added">3237 </span>
<span class="line-added">3238         /*</span>
<span class="line-added">3239          * Phase 3. Turn positive zero 0.0d</span>
<span class="line-added">3240          * back into negative zero -0.0d.</span>
<span class="line-added">3241          */</span>
<span class="line-added">3242         if (++numNegativeZero == 1) {</span>
<span class="line-added">3243             return;</span>
<span class="line-added">3244         }</span>
<span class="line-added">3245 </span>
<span class="line-added">3246         /*</span>
<span class="line-added">3247          * Find the position one less than</span>
<span class="line-added">3248          * the index of the first zero.</span>
<span class="line-added">3249          */</span>
<span class="line-added">3250         while (low &lt;= high) {</span>
<span class="line-added">3251             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="line-added">3252 </span>
<span class="line-added">3253             if (a[middle] &lt; 0) {</span>
<span class="line-added">3254                 low = middle + 1;</span>
<span class="line-added">3255             } else {</span>
<span class="line-added">3256                 high = middle - 1;</span>
<span class="line-added">3257             }</span>
<span class="line-added">3258         }</span>
<span class="line-added">3259 </span>
<span class="line-added">3260         /*</span>
<span class="line-added">3261          * Replace the required number of 0.0d by -0.0d.</span>
<span class="line-added">3262          */</span>
<span class="line-added">3263         while (--numNegativeZero &gt; 0) {</span>
<span class="line-added">3264             a[++high] = -0.0d;</span>
<span class="line-added">3265         }</span>
<span class="line-added">3266     }</span>
<span class="line-added">3267 </span>
<span class="line-added">3268     /**</span>
<span class="line-added">3269      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">3270      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">3271      *</span>
<span class="line-added">3272      * @param sorter parallel context</span>
<span class="line-added">3273      * @param a the array to be sorted</span>
<span class="line-added">3274      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">3275      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">3276      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3277      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3278      */</span>
<span class="line-added">3279     static void sort(Sorter sorter, double[] a, int bits, int low, int high) {</span>
<span class="line-added">3280         while (true) {</span>
<span class="line-added">3281             int end = high - 1, size = high - low;</span>
3282 
3283             /*
<a name="279" id="anc279"></a><span class="line-modified">3284              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-modified">3285              */</span>
<span class="line-modified">3286             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified">3287                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-modified">3288                 return;</span>
<span class="line-modified">3289             }</span>
<span class="line-modified">3290 </span>
<span class="line-modified">3291             /*</span>
<span class="line-modified">3292              * Invoke insertion sort on small leftmost part.</span>
<span class="line-modified">3293              */</span>
<span class="line-modified">3294             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">3295                 insertionSort(a, low, high);</span>
<span class="line-added">3296                 return;</span>
<span class="line-added">3297             }</span>
<span class="line-added">3298 </span>
<span class="line-added">3299             /*</span>
<span class="line-added">3300              * Check if the whole array or large non-leftmost</span>
<span class="line-added">3301              * parts are nearly sorted and then merge runs.</span>
<span class="line-added">3302              */</span>
<span class="line-added">3303             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added">3304                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added">3305                 return;</span>
<span class="line-added">3306             }</span>
<span class="line-added">3307 </span>
<span class="line-added">3308             /*</span>
<span class="line-added">3309              * Switch to heap sort if execution</span>
<span class="line-added">3310              * time is becoming quadratic.</span>
<span class="line-added">3311              */</span>
<span class="line-added">3312             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">3313                 heapSort(a, low, high);</span>
<span class="line-added">3314                 return;</span>
<span class="line-added">3315             }</span>
<span class="line-added">3316 </span>
<span class="line-added">3317             /*</span>
<span class="line-added">3318              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">3319              * to select five sample elements and determine pivots.</span>
<span class="line-added">3320              */</span>
<span class="line-added">3321             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">3322 </span>
<span class="line-added">3323             /*</span>
<span class="line-added">3324              * Five elements around (and including) the central element</span>
<span class="line-added">3325              * will be used for pivot selection as described below. The</span>
<span class="line-added">3326              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">3327              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">3328              */</span>
<span class="line-added">3329             int e1 = low + step;</span>
<span class="line-added">3330             int e5 = end - step;</span>
<span class="line-added">3331             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">3332             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">3333             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">3334             double a3 = a[e3];</span>
<span class="line-added">3335 </span>
<span class="line-added">3336             /*</span>
<span class="line-added">3337              * Sort these elements in place by the combination</span>
<span class="line-added">3338              * of 4-element sorting network and insertion sort.</span>
3339              *
<a name="280" id="anc280"></a><span class="line-modified">3340              *    5 ------o-----------o------------</span>
<span class="line-modified">3341              *            |           |</span>
<span class="line-modified">3342              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">3343              *            |     |           |</span>
<span class="line-added">3344              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">3345              *                  |     |</span>
<span class="line-added">3346              *    1 ------------o-----o------------</span>
<span class="line-added">3347              */</span>
<span class="line-added">3348             if (a[e5] &lt; a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">3349             if (a[e4] &lt; a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">3350             if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">3351             if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">3352             if (a[e4] &lt; a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">3353 </span>
<span class="line-added">3354             if (a3 &lt; a[e2]) {</span>
<span class="line-added">3355                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">3356                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">3357                 } else {</span>
<span class="line-added">3358                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">3359                 }</span>
<span class="line-added">3360             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">3361                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">3362                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">3363                 } else {</span>
<span class="line-added">3364                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">3365                 }</span>
<span class="line-added">3366             }</span>
<span class="line-added">3367 </span>
<span class="line-added">3368             // Pointers</span>
<span class="line-added">3369             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">3370             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">3371 </span>
<span class="line-added">3372             /*</span>
<span class="line-added">3373              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">3374              */</span>
<span class="line-added">3375             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">3376 </span>
<span class="line-added">3377                 /*</span>
<span class="line-added">3378                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">3379                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">3380                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">3381                  */</span>
<span class="line-added">3382                 double pivot1 = a[e1];</span>
<span class="line-added">3383                 double pivot2 = a[e5];</span>
<span class="line-added">3384 </span>
<span class="line-added">3385                 /*</span>
<span class="line-added">3386                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">3387                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">3388                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">3389                  * into their final positions, and excluded from the next</span>
<span class="line-added">3390                  * subsequent sorting.</span>
<span class="line-added">3391                  */</span>
<span class="line-added">3392                 a[e1] = a[lower];</span>
<span class="line-added">3393                 a[e5] = a[upper];</span>
<span class="line-added">3394 </span>
<span class="line-added">3395                 /*</span>
<span class="line-added">3396                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">3397                  */</span>
<span class="line-added">3398                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">3399                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">3400 </span>
<span class="line-added">3401                 /*</span>
<span class="line-added">3402                  * Backward 3-interval partitioning</span>
<span class="line-added">3403                  *</span>
<span class="line-added">3404                  *   left part                 central part          right part</span>
<span class="line-added">3405                  * +------------------------------------------------------------+</span>
<span class="line-added">3406                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">3407                  * +------------------------------------------------------------+</span>
<span class="line-added">3408                  *             ^       ^                            ^</span>
<span class="line-added">3409                  *             |       |                            |</span>
<span class="line-added">3410                  *           lower     k                          upper</span>
<span class="line-added">3411                  *</span>
<span class="line-added">3412                  * Invariants:</span>
<span class="line-added">3413                  *</span>
<span class="line-added">3414                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">3415                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">3416                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">3417                  *</span>
<span class="line-added">3418                  * Pointer k is the last index of ?-part</span>
<span class="line-added">3419                  */</span>
<span class="line-added">3420                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">3421                     double ak = a[k];</span>
<span class="line-added">3422 </span>
<span class="line-added">3423                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">3424                         while (lower &lt; k) {</span>
<span class="line-added">3425                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">3426                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">3427                                     a[k] = a[--upper];</span>
<span class="line-added">3428                                     a[upper] = a[lower];</span>
<span class="line-added">3429                                 } else {</span>
<span class="line-added">3430                                     a[k] = a[lower];</span>
<span class="line-added">3431                                 }</span>
<span class="line-added">3432                                 a[lower] = ak;</span>
<span class="line-added">3433                                 break;</span>
<span class="line-added">3434                             }</span>
<span class="line-added">3435                         }</span>
<span class="line-added">3436                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">3437                         a[k] = a[--upper];</span>
<span class="line-added">3438                         a[upper] = ak;</span>
<span class="line-added">3439                     }</span>
<span class="line-added">3440                 }</span>
<span class="line-added">3441 </span>
<span class="line-added">3442                 /*</span>
<span class="line-added">3443                  * Swap the pivots into their final positions.</span>
<span class="line-added">3444                  */</span>
<span class="line-added">3445                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">3446                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">3447 </span>
<span class="line-added">3448                 /*</span>
<span class="line-added">3449                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">3450                  * excluding known pivots.</span>
<span class="line-added">3451                  */</span>
<span class="line-added">3452                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">3453                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">3454                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">3455                 } else {</span>
<span class="line-added">3456                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">3457                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="line-added">3458                 }</span>
<span class="line-added">3459 </span>
<span class="line-added">3460             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">3461 </span>
<span class="line-added">3462                 /*</span>
<span class="line-added">3463                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">3464                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">3465                  */</span>
<span class="line-added">3466                 double pivot = a[e3];</span>
<span class="line-added">3467 </span>
<span class="line-added">3468                 /*</span>
<span class="line-added">3469                  * The first element to be sorted is moved to the</span>
<span class="line-added">3470                  * location formerly occupied by the pivot. After</span>
<span class="line-added">3471                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">3472                  * back into its final position, and excluded from</span>
<span class="line-added">3473                  * the next subsequent sorting.</span>
<span class="line-added">3474                  */</span>
<span class="line-added">3475                 a[e3] = a[lower];</span>
<span class="line-added">3476 </span>
<span class="line-added">3477                 /*</span>
<span class="line-added">3478                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">3479                  *</span>
<span class="line-added">3480                  *   left part                 central part    right part</span>
<span class="line-added">3481                  * +------------------------------------------------------+</span>
<span class="line-added">3482                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">3483                  * +------------------------------------------------------+</span>
<span class="line-added">3484                  *              ^           ^                ^</span>
<span class="line-added">3485                  *              |           |                |</span>
<span class="line-added">3486                  *            lower         k              upper</span>
<span class="line-added">3487                  *</span>
<span class="line-added">3488                  * Invariants:</span>
<span class="line-added">3489                  *</span>
<span class="line-added">3490                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">3491                  *   all in (k, upper)  == pivot</span>
<span class="line-added">3492                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">3493                  *</span>
<span class="line-added">3494                  * Pointer k is the last index of ?-part</span>
<span class="line-added">3495                  */</span>
<span class="line-added">3496                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">3497                     double ak = a[k];</span>
<span class="line-added">3498 </span>
<span class="line-added">3499                     if (ak != pivot) {</span>
<span class="line-added">3500                         a[k] = pivot;</span>
<span class="line-added">3501 </span>
<span class="line-added">3502                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">3503                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">3504 </span>
<span class="line-added">3505                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">3506                                 a[--upper] = a[lower];</span>
<span class="line-added">3507                             }</span>
<span class="line-added">3508                             a[lower] = ak;</span>
<span class="line-added">3509                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">3510                             a[--upper] = ak;</span>
<span class="line-added">3511                         }</span>
<span class="line-added">3512                     }</span>
<span class="line-added">3513                 }</span>
<span class="line-added">3514 </span>
<span class="line-added">3515                 /*</span>
<span class="line-added">3516                  * Swap the pivot into its final position.</span>
<span class="line-added">3517                  */</span>
<span class="line-added">3518                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">3519 </span>
<span class="line-added">3520                 /*</span>
<span class="line-added">3521                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">3522                  * known pivot. All elements from the central part are</span>
<span class="line-added">3523                  * equal and therefore already sorted.</span>
<span class="line-added">3524                  */</span>
<span class="line-added">3525                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">3526                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">3527                 } else {</span>
<span class="line-added">3528                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">3529                 }</span>
<span class="line-added">3530             }</span>
<span class="line-added">3531             high = lower; // Iterate along the left part</span>
<span class="line-added">3532         }</span>
<span class="line-added">3533     }</span>
<span class="line-added">3534 </span>
<span class="line-added">3535     /**</span>
<span class="line-added">3536      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">3537      *</span>
<span class="line-added">3538      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">3539      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">3540      *</span>
<span class="line-added">3541      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">3542      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">3543      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">3544      * expensive check of the left range can be skipped on each</span>
<span class="line-added">3545      * iteration unless it is the leftmost call.</span>
<span class="line-added">3546      *</span>
<span class="line-added">3547      * @param a the array to be sorted</span>
<span class="line-added">3548      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3549      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">3550      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3551      */</span>
<span class="line-added">3552     private static void mixedInsertionSort(double[] a, int low, int end, int high) {</span>
<span class="line-added">3553         if (end == high) {</span>
<span class="line-added">3554 </span>
<span class="line-added">3555             /*</span>
<span class="line-added">3556              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added">3557              */</span>
<span class="line-added">3558             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">3559                 double ai = a[i = low];</span>
<span class="line-added">3560 </span>
<span class="line-added">3561                 while (ai &lt; a[--i]) {</span>
<span class="line-added">3562                     a[i + 1] = a[i];</span>
<span class="line-added">3563                 }</span>
<span class="line-added">3564                 a[i + 1] = ai;</span>
<span class="line-added">3565             }</span>
<span class="line-added">3566         } else {</span>
<span class="line-added">3567 </span>
<span class="line-added">3568             /*</span>
<span class="line-added">3569              * Start with pin insertion sort on small part.</span>
3570              *
<a name="281" id="anc281"></a><span class="line-modified">3571              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added">3572              * The main idea of this sort is to put elements larger</span>
<span class="line-added">3573              * than an element called pin to the end of array (the</span>
<span class="line-added">3574              * proper area for such elements). It avoids expensive</span>
<span class="line-added">3575              * movements of these elements through the whole array.</span>
3576              */
<a name="282" id="anc282"></a><span class="line-modified">3577             double pin = a[end];</span>
<span class="line-modified">3578 </span>
<span class="line-modified">3579             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified">3580                 double ai = a[i = low];</span>
<span class="line-modified">3581 </span>
<span class="line-added">3582                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-added">3583 </span>
<span class="line-added">3584                     /*</span>
<span class="line-added">3585                      * Insert small element into sorted part.</span>
<span class="line-added">3586                      */</span>
<span class="line-added">3587                     a[i] = a[--i];</span>
<span class="line-added">3588 </span>
<span class="line-added">3589                     while (ai &lt; a[--i]) {</span>
<span class="line-added">3590                         a[i + 1] = a[i];</span>
<span class="line-added">3591                     }</span>
<span class="line-added">3592                     a[i + 1] = ai;</span>
<span class="line-added">3593 </span>
<span class="line-added">3594                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-added">3595 </span>
<span class="line-added">3596                     /*</span>
<span class="line-added">3597                      * Find element smaller than pin.</span>
<span class="line-added">3598                      */</span>
<span class="line-added">3599                     while (a[--p] &gt; pin);</span>
<span class="line-added">3600 </span>
3601                     /*
<a name="283" id="anc283"></a><span class="line-modified">3602                      * Swap it with large element.</span>

3603                      */
<a name="284" id="anc284"></a><span class="line-modified">3604                     if (p &gt; i) {</span>
<span class="line-modified">3605                         ai = a[p];</span>
<span class="line-modified">3606                         a[p] = a[i];</span>











3607                     }
<a name="285" id="anc285"></a><span class="line-added">3608 </span>
3609                     /*
<a name="286" id="anc286"></a><span class="line-modified">3610                      * Insert small element into sorted part.</span>

3611                      */
<a name="287" id="anc287"></a><span class="line-modified">3612                     while (ai &lt; a[--i]) {</span>
<span class="line-modified">3613                         a[i + 1] = a[i];</span>
<span class="line-added">3614                     }</span>
<span class="line-added">3615                     a[i + 1] = ai;</span>
3616                 }
3617             }
3618 
<a name="288" id="anc288"></a>







3619             /*
<a name="289" id="anc289"></a><span class="line-modified">3620              * Continue with pair insertion sort on remain part.</span>

3621              */
<a name="290" id="anc290"></a><span class="line-modified">3622             for (int i; low &lt; high; ++low) {</span>
<span class="line-modified">3623                 double a1 = a[i = low], a2 = a[++low];</span>









3624 
3625                 /*
<a name="291" id="anc291"></a><span class="line-modified">3626                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-modified">3627                  * larger element and then insert the smaller element, but</span>
<span class="line-modified">3628                  * from the position where the larger element was inserted.</span>














3629                  */
<a name="292" id="anc292"></a><span class="line-modified">3630                 if (a1 &gt; a2) {</span>
<span class="line-modified">3631 </span>
<span class="line-modified">3632                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified">3633                         a[i + 2] = a[i];</span>


























3634                     }
<a name="293" id="anc293"></a><span class="line-modified">3635                     a[++i + 1] = a1;</span>

3636 
<a name="294" id="anc294"></a><span class="line-modified">3637                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified">3638                         a[i + 1] = a[i];</span>
<span class="line-added">3639                     }</span>
<span class="line-added">3640                     a[i + 1] = a2;</span>
3641 
<a name="295" id="anc295"></a><span class="line-modified">3642                 } else if (a1 &lt; a[i - 1]) {</span>





3643 
<a name="296" id="anc296"></a><span class="line-modified">3644                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified">3645                         a[i + 2] = a[i];</span>






























3646                     }
<a name="297" id="anc297"></a><span class="line-modified">3647                     a[++i + 1] = a2;</span>
<span class="line-modified">3648 </span>
<span class="line-modified">3649                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified">3650                         a[i + 1] = a[i];</span>










3651                     }
<a name="298" id="anc298"></a><span class="line-modified">3652                     a[i + 1] = a1;</span>

3653                 }
3654             }
<a name="299" id="anc299"></a><span class="line-added">3655         }</span>
<span class="line-added">3656     }</span>
3657 
<a name="300" id="anc300"></a><span class="line-modified">3658     /**</span>
<span class="line-modified">3659      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-modified">3660      *</span>
<span class="line-modified">3661      * @param a the array to be sorted</span>
<span class="line-modified">3662      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">3663      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">3664      */</span>
<span class="line-added">3665     private static void insertionSort(double[] a, int low, int high) {</span>
<span class="line-added">3666         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">3667             double ai = a[i = k];</span>
<span class="line-added">3668 </span>
<span class="line-added">3669             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">3670                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">3671                     a[i + 1] = a[i];</span>
<span class="line-added">3672                 }</span>
<span class="line-added">3673                 a[i + 1] = ai;</span>
<span class="line-added">3674             }</span>
3675         }
3676     }
3677 
3678     /**
<a name="301" id="anc301"></a><span class="line-modified">3679      * Sorts the specified range of the array using heap sort.</span>

3680      *
3681      * @param a the array to be sorted
<a name="302" id="anc302"></a><span class="line-modified">3682      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">3683      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">3684      */</span>
<span class="line-modified">3685     private static void heapSort(double[] a, int low, int high) {</span>
<span class="line-modified">3686         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified">3687             pushDown(a, --k, a[k], low, high);</span>







3688         }
<a name="303" id="anc303"></a><span class="line-modified">3689         while (--high &gt; low) {</span>
<span class="line-modified">3690             double max = a[low];</span>
<span class="line-modified">3691             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified">3692             a[high] = max;</span>
<span class="line-modified">3693         }</span>
<span class="line-modified">3694     }</span>
<span class="line-added">3695 </span>
<span class="line-added">3696     /**</span>
<span class="line-added">3697      * Pushes specified element down during heap sort.</span>
<span class="line-added">3698      *</span>
<span class="line-added">3699      * @param a the given array</span>
<span class="line-added">3700      * @param p the start index</span>
<span class="line-added">3701      * @param value the given element</span>
<span class="line-added">3702      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3703      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3704      */</span>
<span class="line-added">3705     private static void pushDown(double[] a, int p, double value, int low, int high) {</span>
<span class="line-added">3706         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">3707             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">3708 </span>
<span class="line-added">3709             if (k &gt; high) {</span>
<span class="line-added">3710                 break;</span>
<span class="line-added">3711             }</span>
<span class="line-added">3712             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">3713                 --k;</span>
<span class="line-added">3714             }</span>
<span class="line-added">3715             if (a[k] &lt;= value) {</span>
<span class="line-added">3716                 break;</span>
3717             }
3718         }
<a name="304" id="anc304"></a><span class="line-added">3719         a[p] = value;</span>
<span class="line-added">3720     }</span>
3721 
<a name="305" id="anc305"></a><span class="line-modified">3722     /**</span>
<span class="line-modified">3723      * Tries to sort the specified range of the array.</span>
<span class="line-modified">3724      *</span>
<span class="line-modified">3725      * @param sorter parallel context</span>
<span class="line-added">3726      * @param a the array to be sorted</span>
<span class="line-added">3727      * @param low the index of the first element to be sorted</span>
<span class="line-added">3728      * @param size the array size</span>
<span class="line-added">3729      * @return true if finally sorted, false otherwise</span>
<span class="line-added">3730      */</span>
<span class="line-added">3731     private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {</span>
3732 
3733         /*
<a name="306" id="anc306"></a><span class="line-modified">3734          * The run array is constructed only if initial runs are</span>
<span class="line-added">3735          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">3736          * of the i-th sequence of elements in non-descending order.</span>
3737          */
<a name="307" id="anc307"></a><span class="line-modified">3738         int[] run = null;</span>
<span class="line-added">3739         int high = low + size;</span>
<span class="line-added">3740         int count = 1, last = low;</span>
3741 
3742         /*
<a name="308" id="anc308"></a><span class="line-modified">3743          * Identify all possible runs.</span>
3744          */
<a name="309" id="anc309"></a><span class="line-modified">3745         for (int k = low + 1; k &lt; high; ) {</span>


3746 
<a name="310" id="anc310"></a><span class="line-modified">3747             /*</span>
<span class="line-modified">3748              * Find the end index of the current run.</span>
<span class="line-modified">3749              */</span>
<span class="line-modified">3750             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">3751 </span>
<span class="line-added">3752                 // Identify ascending sequence</span>
<span class="line-added">3753                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">3754 </span>
<span class="line-added">3755             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">3756 </span>
<span class="line-added">3757                 // Identify descending sequence</span>
<span class="line-added">3758                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">3759 </span>
<span class="line-added">3760                 // Reverse into ascending order</span>
<span class="line-added">3761                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">3762                     double ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">3763                 }</span>
<span class="line-added">3764             } else { // Identify constant sequence</span>
<span class="line-added">3765                 for (double ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">3766 </span>
<span class="line-added">3767                 if (k &lt; high) {</span>
<span class="line-added">3768                     continue;</span>
<span class="line-added">3769                 }</span>
3770             }
<a name="311" id="anc311"></a>
3771 
<a name="312" id="anc312"></a><span class="line-modified">3772             /*</span>
<span class="line-modified">3773              * Check special cases.</span>
<span class="line-modified">3774              */</span>
<span class="line-modified">3775             if (run == null) {</span>
<span class="line-modified">3776                 if (k == high) {</span>
<span class="line-added">3777 </span>
<span class="line-added">3778                     /*</span>
<span class="line-added">3779                      * The array is monotonous sequence,</span>
<span class="line-added">3780                      * and therefore already sorted.</span>
<span class="line-added">3781                      */</span>
<span class="line-added">3782                     return true;</span>
<span class="line-added">3783                 }</span>
<span class="line-added">3784 </span>
<span class="line-added">3785                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">3786 </span>
<span class="line-added">3787                     /*</span>
<span class="line-added">3788                      * The first run is too small</span>
<span class="line-added">3789                      * to proceed with scanning.</span>
<span class="line-added">3790                      */</span>
<span class="line-added">3791                     return false;</span>
<span class="line-added">3792                 }</span>
<span class="line-added">3793 </span>
<span class="line-added">3794                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">3795                 run[0] = low;</span>
<span class="line-added">3796 </span>
<span class="line-added">3797             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">3798 </span>
<span class="line-added">3799                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">3800 </span>
<span class="line-added">3801                     /*</span>
<span class="line-added">3802                      * The first runs are not long</span>
<span class="line-added">3803                      * enough to continue scanning.</span>
<span class="line-added">3804                      */</span>
<span class="line-added">3805                     return false;</span>
<span class="line-added">3806                 }</span>
<span class="line-added">3807 </span>
<span class="line-added">3808                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">3809 </span>
<span class="line-added">3810                     /*</span>
<span class="line-added">3811                      * Array is not highly structured.</span>
<span class="line-added">3812                      */</span>
<span class="line-added">3813                     return false;</span>
<span class="line-added">3814                 }</span>
<span class="line-added">3815 </span>
<span class="line-added">3816                 if (count == run.length) {</span>
<span class="line-added">3817 </span>
<span class="line-added">3818                     /*</span>
<span class="line-added">3819                      * Increase capacity of index array.</span>
<span class="line-added">3820                      */</span>
<span class="line-added">3821                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">3822                 }</span>
<span class="line-added">3823             }</span>
<span class="line-added">3824             run[count] = (last = k);</span>
3825         }
3826 
3827         /*
<a name="313" id="anc313"></a><span class="line-modified">3828          * Merge runs of highly structured array.</span>


















3829          */
<a name="314" id="anc314"></a><span class="line-modified">3830         if (count &gt; 1) {</span>
<span class="line-modified">3831             double[] b; int offset = low;</span>
<span class="line-modified">3832 </span>
<span class="line-modified">3833             if (sorter == null || (b = (double[]) sorter.b) == null) {</span>
<span class="line-modified">3834                 b = new double[size];</span>
<span class="line-modified">3835             } else {</span>
<span class="line-modified">3836                 offset = sorter.offset;</span>

3837             }
<a name="315" id="anc315"></a><span class="line-added">3838             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
3839         }
<a name="316" id="anc316"></a><span class="line-added">3840         return true;</span>
3841     }
3842 
3843     /**
<a name="317" id="anc317"></a><span class="line-modified">3844      * Merges the specified runs.</span>
3845      *
<a name="318" id="anc318"></a><span class="line-modified">3846      * @param a the source array</span>
<span class="line-modified">3847      * @param b the temporary buffer used in merging</span>
<span class="line-modified">3848      * @param offset the start index in the source, inclusive</span>
<span class="line-modified">3849      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified">3850      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified">3851      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified">3852      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified">3853      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified">3854      * @return the destination where runs are merged</span>
<span class="line-modified">3855      */</span>
<span class="line-modified">3856     private static double[] mergeRuns(double[] a, double[] b, int offset,</span>
<span class="line-modified">3857             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified">3858 </span>
<span class="line-added">3859         if (hi - lo == 1) {</span>
<span class="line-added">3860             if (aim &gt;= 0) {</span>
<span class="line-added">3861                 return a;</span>
<span class="line-added">3862             }</span>
<span class="line-added">3863             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">3864                 b[--j] = a[--i]</span>
<span class="line-added">3865             );</span>
<span class="line-added">3866             return b;</span>
3867         }
3868 
3869         /*
<a name="319" id="anc319"></a><span class="line-modified">3870          * Split into approximately equal parts.</span>

3871          */
<a name="320" id="anc320"></a><span class="line-modified">3872         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified">3873         while (run[++mi + 1] &lt;= rmi);</span>
















3874 
<a name="321" id="anc321"></a><span class="line-modified">3875         /*</span>
<span class="line-modified">3876          * Merge the left and right parts.</span>
<span class="line-modified">3877          */</span>
<span class="line-modified">3878         double[] a1, a2;</span>

3879 
<a name="322" id="anc322"></a><span class="line-modified">3880         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified">3881             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified">3882             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified">3883             a2 = (double[]) merger.getDestination();</span>
<span class="line-modified">3884         } else {</span>
<span class="line-modified">3885             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified">3886             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

3887         }
3888 
<a name="323" id="anc323"></a><span class="line-modified">3889         double[] dst = a1 == a ? b : a;</span>


3890 
<a name="324" id="anc324"></a><span class="line-modified">3891         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified">3892         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified">3893         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">3894         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">3895         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified">3896 </span>
<span class="line-modified">3897         if (parallel) {</span>
<span class="line-modified">3898             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























3899         } else {
<a name="325" id="anc325"></a><span class="line-modified">3900             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























3901         }
<a name="326" id="anc326"></a><span class="line-added">3902         return dst;</span>
3903     }
3904 
3905     /**
<a name="327" id="anc327"></a><span class="line-modified">3906      * Merges the sorted parts.</span>
3907      *
<a name="328" id="anc328"></a><span class="line-modified">3908      * @param merger parallel context</span>
<span class="line-modified">3909      * @param dst the destination where parts are merged</span>
<span class="line-modified">3910      * @param k the start index of the destination, inclusive</span>
<span class="line-modified">3911      * @param a1 the first part</span>
<span class="line-modified">3912      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified">3913      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified">3914      * @param a2 the second part</span>
<span class="line-modified">3915      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified">3916      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified">3917      */</span>
<span class="line-modified">3918     private static void mergeParts(Merger merger, double[] dst, int k,</span>
<span class="line-modified">3919             double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {</span>
<span class="line-modified">3920 </span>
<span class="line-modified">3921         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified">3922 </span>
<span class="line-modified">3923             while (true) {</span>
<span class="line-modified">3924 </span>
<span class="line-modified">3925                 /*</span>
<span class="line-modified">3926                  * The first part must be larger.</span>
<span class="line-modified">3927                  */</span>
<span class="line-modified">3928                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified">3929                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified">3930                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


3931                 }
<a name="329" id="anc329"></a><span class="line-modified">3932 </span>
3933                 /*
<a name="330" id="anc330"></a><span class="line-modified">3934                  * Small parts will be merged sequentially.</span>
3935                  */
<a name="331" id="anc331"></a><span class="line-modified">3936                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified">3937                     break;</span>
<span class="line-modified">3938                 }</span>


3939 
3940                 /*
<a name="332" id="anc332"></a><span class="line-modified">3941                  * Find the median of the larger part.</span>





3942                  */
<a name="333" id="anc333"></a><span class="line-modified">3943                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified">3944                 double key = a1[mi1];</span>
<span class="line-added">3945                 int mi2 = hi2;</span>
3946 
<a name="334" id="anc334"></a><span class="line-modified">3947                 /*</span>
<span class="line-modified">3948                  * Partition the smaller part.</span>
<span class="line-modified">3949                  */</span>
<span class="line-modified">3950                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified">3951                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


3952 
<a name="335" id="anc335"></a><span class="line-modified">3953                     if (key &gt; a2[t]) {</span>
<span class="line-modified">3954                         loo = t + 1;</span>
<span class="line-added">3955                     } else {</span>
<span class="line-added">3956                         mi2 = t;</span>
3957                     }
<a name="336" id="anc336"></a>
3958                 }
<a name="337" id="anc337"></a>
3959 
<a name="338" id="anc338"></a><span class="line-modified">3960                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified">3961 </span>
<span class="line-modified">3962                 /*</span>
<span class="line-modified">3963                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">3964                  */</span>
<span class="line-added">3965                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">3966 </span>
<span class="line-added">3967                 /*</span>
<span class="line-added">3968                  * Process the sub-left parts.</span>
<span class="line-added">3969                  */</span>
<span class="line-added">3970                 hi1 = mi1;</span>
<span class="line-added">3971                 hi2 = mi2;</span>
3972             }
<a name="339" id="anc339"></a>
3973         }
3974 
<a name="340" id="anc340"></a>


3975         /*
<a name="341" id="anc341"></a><span class="line-modified">3976          * Merge small parts sequentially.</span>




3977          */
<a name="342" id="anc342"></a><span class="line-modified">3978         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified">3979             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









3980         }
<a name="343" id="anc343"></a><span class="line-modified">3981         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified">3982             while (lo1 &lt; hi1) {</span>
<span class="line-modified">3983                 dst[k++] = a1[lo1++];</span>
3984             }
3985         }
<a name="344" id="anc344"></a><span class="line-modified">3986         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified">3987             while (lo2 &lt; hi2) {</span>
<span class="line-modified">3988                 dst[k++] = a2[lo2++];</span>


3989             }
3990         }
<a name="345" id="anc345"></a><span class="line-added">3991     }</span>
3992 
<a name="346" id="anc346"></a><span class="line-modified">3993 // [class]</span>




















3994 
<a name="347" id="anc347"></a><span class="line-modified">3995     /**</span>
<span class="line-modified">3996      * This class implements parallel sorting.</span>
<span class="line-modified">3997      */</span>
<span class="line-modified">3998     private static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-modified">3999         private static final long serialVersionUID = 20180818L;</span>
<span class="line-added">4000         private final Object a, b;</span>
<span class="line-added">4001         private final int low, size, offset, depth;</span>
<span class="line-added">4002 </span>
<span class="line-added">4003         private Sorter(CountedCompleter&lt;?&gt; parent,</span>
<span class="line-added">4004                 Object a, Object b, int low, int size, int offset, int depth) {</span>
<span class="line-added">4005             super(parent);</span>
<span class="line-added">4006             this.a = a;</span>
<span class="line-added">4007             this.b = b;</span>
<span class="line-added">4008             this.low = low;</span>
<span class="line-added">4009             this.size = size;</span>
<span class="line-added">4010             this.offset = offset;</span>
<span class="line-added">4011             this.depth = depth;</span>
<span class="line-added">4012         }</span>
4013 
<a name="348" id="anc348"></a><span class="line-modified">4014         @Override</span>
<span class="line-modified">4015         public final void compute() {</span>
<span class="line-modified">4016             if (depth &lt; 0) {</span>
<span class="line-modified">4017                 setPendingCount(2);</span>
<span class="line-modified">4018                 int half = size &gt;&gt; 1;</span>
<span class="line-modified">4019                 new Sorter(this, b, a, low, half, offset, depth + 1).fork();</span>
<span class="line-modified">4020                 new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();</span>
<span class="line-modified">4021             } else {</span>
<span class="line-modified">4022                 if (a instanceof int[]) {</span>
<span class="line-modified">4023                     sort(this, (int[]) a, depth, low, low + size);</span>
<span class="line-modified">4024                 } else if (a instanceof long[]) {</span>
<span class="line-modified">4025                     sort(this, (long[]) a, depth, low, low + size);</span>
<span class="line-modified">4026                 } else if (a instanceof float[]) {</span>
<span class="line-modified">4027                     sort(this, (float[]) a, depth, low, low + size);</span>
<span class="line-modified">4028                 } else if (a instanceof double[]) {</span>
<span class="line-modified">4029                     sort(this, (double[]) a, depth, low, low + size);</span>
<span class="line-modified">4030                 } else {</span>
<span class="line-modified">4031                     throw new IllegalArgumentException(</span>
<span class="line-modified">4032                         &quot;Unknown type of array: &quot; + a.getClass().getName());</span>






























4033                 }
4034             }
<a name="349" id="anc349"></a><span class="line-added">4035             tryComplete();</span>
<span class="line-added">4036         }</span>
4037 
<a name="350" id="anc350"></a><span class="line-modified">4038         @Override</span>
<span class="line-modified">4039         public final void onCompletion(CountedCompleter&lt;?&gt; caller) {</span>
<span class="line-modified">4040             if (depth &lt; 0) {</span>
<span class="line-modified">4041                 int mi = low + (size &gt;&gt; 1);</span>
<span class="line-modified">4042                 boolean src = (depth &amp; 1) == 0;</span>
<span class="line-modified">4043 </span>
<span class="line-modified">4044                 new Merger(null,</span>
<span class="line-added">4045                     a,</span>
<span class="line-added">4046                     src ? low : low - offset,</span>
<span class="line-added">4047                     b,</span>
<span class="line-added">4048                     src ? low - offset : low,</span>
<span class="line-added">4049                     src ? mi - offset : mi,</span>
<span class="line-added">4050                     b,</span>
<span class="line-added">4051                     src ? mi - offset : mi,</span>
<span class="line-added">4052                     src ? low + size - offset : low + size</span>
<span class="line-added">4053                 ).invoke();</span>
<span class="line-added">4054             }</span>
<span class="line-added">4055         }</span>
4056 
<a name="351" id="anc351"></a><span class="line-modified">4057         private void forkSorter(int depth, int low, int high) {</span>
<span class="line-modified">4058             addToPendingCount(1);</span>
<span class="line-modified">4059             Object a = this.a; // Use local variable for performance</span>
<span class="line-modified">4060             new Sorter(this, a, b, low, high - low, offset, depth).fork();</span>
<span class="line-modified">4061         }</span>
<span class="line-modified">4062     }</span>





4063 
<a name="352" id="anc352"></a><span class="line-modified">4064     /**</span>
<span class="line-modified">4065      * This class implements parallel merging.</span>
<span class="line-modified">4066      */</span>
<span class="line-added">4067     private static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-added">4068         private static final long serialVersionUID = 20180818L;</span>
<span class="line-added">4069         private final Object dst, a1, a2;</span>
<span class="line-added">4070         private final int k, lo1, hi1, lo2, hi2;</span>
<span class="line-added">4071 </span>
<span class="line-added">4072         private Merger(CountedCompleter&lt;?&gt; parent, Object dst, int k,</span>
<span class="line-added">4073                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="line-added">4074             super(parent);</span>
<span class="line-added">4075             this.dst = dst;</span>
<span class="line-added">4076             this.k = k;</span>
<span class="line-added">4077             this.a1 = a1;</span>
<span class="line-added">4078             this.lo1 = lo1;</span>
<span class="line-added">4079             this.hi1 = hi1;</span>
<span class="line-added">4080             this.a2 = a2;</span>
<span class="line-added">4081             this.lo2 = lo2;</span>
<span class="line-added">4082             this.hi2 = hi2;</span>
<span class="line-added">4083         }</span>
4084 
<a name="353" id="anc353"></a><span class="line-modified">4085         @Override</span>
<span class="line-modified">4086         public final void compute() {</span>
<span class="line-modified">4087             if (dst instanceof int[]) {</span>
<span class="line-modified">4088                 mergeParts(this, (int[]) dst, k,</span>
<span class="line-modified">4089                     (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);</span>
<span class="line-modified">4090             } else if (dst instanceof long[]) {</span>
<span class="line-modified">4091                 mergeParts(this, (long[]) dst, k,</span>
<span class="line-modified">4092                     (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);</span>
<span class="line-modified">4093             } else if (dst instanceof float[]) {</span>
<span class="line-modified">4094                 mergeParts(this, (float[]) dst, k,</span>
<span class="line-modified">4095                     (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);</span>
<span class="line-modified">4096             } else if (dst instanceof double[]) {</span>
<span class="line-modified">4097                 mergeParts(this, (double[]) dst, k,</span>
<span class="line-modified">4098                     (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);</span>
<span class="line-modified">4099             } else {</span>
<span class="line-modified">4100                 throw new IllegalArgumentException(</span>
<span class="line-modified">4101                     &quot;Unknown type of array: &quot; + dst.getClass().getName());</span>


































4102             }
<a name="354" id="anc354"></a><span class="line-added">4103             propagateCompletion();</span>
<span class="line-added">4104         }</span>
4105 
<a name="355" id="anc355"></a><span class="line-modified">4106         private void forkMerger(Object dst, int k,</span>
<span class="line-modified">4107                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="line-added">4108             addToPendingCount(1);</span>
<span class="line-added">4109             new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();</span>
<span class="line-added">4110         }</span>
<span class="line-added">4111     }</span>
4112 
<a name="356" id="anc356"></a><span class="line-modified">4113     /**</span>
<span class="line-modified">4114      * This class implements parallel merging of runs.</span>
<span class="line-modified">4115      */</span>
<span class="line-modified">4116     private static final class RunMerger extends RecursiveTask&lt;Object&gt; {</span>
<span class="line-modified">4117         private static final long serialVersionUID = 20180818L;</span>
<span class="line-modified">4118         private final Object a, b;</span>
<span class="line-added">4119         private final int[] run;</span>
<span class="line-added">4120         private final int offset, aim, lo, hi;</span>
<span class="line-added">4121 </span>
<span class="line-added">4122         private RunMerger(Object a, Object b, int offset,</span>
<span class="line-added">4123                 int aim, int[] run, int lo, int hi) {</span>
<span class="line-added">4124             this.a = a;</span>
<span class="line-added">4125             this.b = b;</span>
<span class="line-added">4126             this.offset = offset;</span>
<span class="line-added">4127             this.aim = aim;</span>
<span class="line-added">4128             this.run = run;</span>
<span class="line-added">4129             this.lo = lo;</span>
<span class="line-added">4130             this.hi = hi;</span>
<span class="line-added">4131         }</span>
4132 
<a name="357" id="anc357"></a><span class="line-modified">4133         @Override</span>
<span class="line-modified">4134         protected final Object compute() {</span>
<span class="line-modified">4135             if (a instanceof int[]) {</span>
<span class="line-modified">4136                 return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);</span>















































4137             }
<a name="358" id="anc358"></a><span class="line-added">4138             if (a instanceof long[]) {</span>
<span class="line-added">4139                 return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4140             }</span>
<span class="line-added">4141             if (a instanceof float[]) {</span>
<span class="line-added">4142                 return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4143             }</span>
<span class="line-added">4144             if (a instanceof double[]) {</span>
<span class="line-added">4145                 return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4146             }</span>
<span class="line-added">4147             throw new IllegalArgumentException(</span>
<span class="line-added">4148                 &quot;Unknown type of array: &quot; + a.getClass().getName());</span>
<span class="line-added">4149         }</span>
4150 
<a name="359" id="anc359"></a><span class="line-modified">4151         private RunMerger forkMe() {</span>
<span class="line-modified">4152             fork();</span>
<span class="line-modified">4153             return this;</span>
<span class="line-modified">4154         }</span>
<span class="line-modified">4155 </span>
<span class="line-modified">4156         private Object getDestination() {</span>
<span class="line-modified">4157             join();</span>
<span class="line-added">4158             return getRawResult();</span>
4159         }
4160     }
4161 }
<a name="360" id="anc360"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="360" type="hidden" />
</body>
</html>
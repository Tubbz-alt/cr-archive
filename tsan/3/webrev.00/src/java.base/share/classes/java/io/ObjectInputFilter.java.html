<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/ObjectInputFilter.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.security.AccessController;
 29 import java.security.PrivilegedAction;
 30 import java.security.Security;
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 import java.util.Objects;
 34 import java.util.Optional;
 35 import java.util.function.Function;
 36 
 37 import jdk.internal.access.SharedSecrets;
 38 import jdk.internal.util.StaticProperty;
 39 
 40 /**
 41  * Filter classes, array lengths, and graph metrics during deserialization.
 42  *
 43  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
 44  * and should be avoided. Untrusted data should be carefully validated according to the
 45  * &quot;Serialization and Deserialization&quot; section of the
 46  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
 47  * {@extLink serialization_filter_guide Serialization Filtering} describes best
 48  * practices for defensive use of serial filters.
 49  * &lt;/strong&gt;&lt;/p&gt;
 50  *
 51  * If set on an {@link ObjectInputStream}, the {@link #checkInput checkInput(FilterInfo)}
 52  * method is called to validate classes, the length of each array,
 53  * the number of objects being read from the stream, the depth of the graph,
 54  * and the total number of bytes read from the stream.
 55  * &lt;p&gt;
 56  * A filter can be set via {@link ObjectInputStream#setObjectInputFilter setObjectInputFilter}
 57  * for an individual ObjectInputStream.
 58  * A filter can be set via {@link Config#setSerialFilter(ObjectInputFilter) Config.setSerialFilter}
 59  * to affect every {@code ObjectInputStream} that does not otherwise set a filter.
 60  * &lt;p&gt;
 61  * A filter determines whether the arguments are {@link Status#ALLOWED ALLOWED}
 62  * or {@link Status#REJECTED REJECTED} and should return the appropriate status.
 63  * If the filter cannot determine the status it should return
 64  * {@link Status#UNDECIDED UNDECIDED}.
 65  * Filters should be designed for the specific use case and expected types.
 66  * A filter designed for a particular use may be passed a class that is outside
 67  * of the scope of the filter. If the purpose of the filter is to black-list classes
 68  * then it can reject a candidate class that matches and report UNDECIDED for others.
 69  * A filter may be called with class equals {@code null}, {@code arrayLength} equal -1,
 70  * the depth, number of references, and stream size and return a status
 71  * that reflects only one or only some of the values.
 72  * This allows a filter to specific about the choice it is reporting and
 73  * to use other filters without forcing either allowed or rejected status.
 74  *
 75  * &lt;p&gt;
 76  * Typically, a custom filter should check if a system-wide filter
 77  * is configured and defer to it if so. For example,
 78  * &lt;pre&gt;{@code
 79  * ObjectInputFilter.Status checkInput(FilterInfo info) {
 80  *     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();
 81  *     if (serialFilter != null) {
 82  *         ObjectInputFilter.Status status = serialFilter.checkInput(info);
 83  *         if (status != ObjectInputFilter.Status.UNDECIDED) {
 84  *             // The system-wide filter overrides this filter
 85  *             return status;
 86  *         }
 87  *     }
 88  *     if (info.serialClass() != null &amp;&amp;
 89  *         Remote.class.isAssignableFrom(info.serialClass())) {
 90  *         return Status.REJECTED;      // Do not allow Remote objects
 91  *     }
 92  *     return Status.UNDECIDED;
 93  * }
 94  *}&lt;/pre&gt;
 95  * &lt;p&gt;
 96  * Unless otherwise noted, passing a {@code null} argument to a
 97  * method in this interface and its nested classes will cause a
 98  * {@link NullPointerException} to be thrown.
 99  *
100  * @see ObjectInputStream#setObjectInputFilter(ObjectInputFilter)
101  * @since 9
102  */
103 @FunctionalInterface
104 public interface ObjectInputFilter {
105 
106     /**
107      * Check the class, array length, number of object references, depth,
108      * stream size, and other available filtering information.
109      * Implementations of this method check the contents of the object graph being created
110      * during deserialization. The filter returns {@link Status#ALLOWED Status.ALLOWED},
111      * {@link Status#REJECTED Status.REJECTED}, or {@link Status#UNDECIDED Status.UNDECIDED}.
112      *
113      * @param filterInfo provides information about the current object being deserialized,
114      *             if any, and the status of the {@link ObjectInputStream}
115      * @return  {@link Status#ALLOWED Status.ALLOWED} if accepted,
116      *          {@link Status#REJECTED Status.REJECTED} if rejected,
117      *          {@link Status#UNDECIDED Status.UNDECIDED} if undecided.
118      */
119     Status checkInput(FilterInfo filterInfo);
120 
121     /**
122      * FilterInfo provides access to information about the current object
123      * being deserialized and the status of the {@link ObjectInputStream}.
124      * @since 9
125      */
126     interface FilterInfo {
127         /**
128          * The class of an object being deserialized.
129          * For arrays, it is the array type.
130          * For example, the array class name of a 2 dimensional array of strings is
131          * &quot;{@code [[Ljava.lang.String;}&quot;.
132          * To check the array&#39;s element type, iteratively use
133          * {@link Class#getComponentType() Class.getComponentType} while the result
134          * is an array and then check the class.
135          * The {@code serialClass is null} in the case where a new object is not being
136          * created and to give the filter a chance to check the depth, number of
137          * references to existing objects, and the stream size.
138          *
139          * @return class of an object being deserialized; may be null
140          */
141         Class&lt;?&gt; serialClass();
142 
143         /**
144          * The number of array elements when deserializing an array of the class.
145          *
146          * @return the non-negative number of array elements when deserializing
147          * an array of the class, otherwise -1
148          */
149         long arrayLength();
150 
151         /**
152          * The current depth.
153          * The depth starts at {@code 1} and increases for each nested object and
154          * decrements when each nested object returns.
155          *
156          * @return the current depth
157          */
158         long depth();
159 
160         /**
161          * The current number of object references.
162          *
163          * @return the non-negative current number of object references
164          */
165         long references();
166 
167         /**
168          * The current number of bytes consumed.
169          * @implSpec  {@code streamBytes} is implementation specific
170          * and may not be directly related to the object in the stream
171          * that caused the callback.
172          *
173          * @return the non-negative current number of bytes consumed
174          */
175         long streamBytes();
176     }
177 
178     /**
179      * The status of a check on the class, array length, number of references,
180      * depth, and stream size.
181      *
182      * @since 9
183      */
184     enum Status {
185         /**
186          * The status is undecided, not allowed and not rejected.
187          */
188         UNDECIDED,
189         /**
190          * The status is allowed.
191          */
192         ALLOWED,
193         /**
194          * The status is rejected.
195          */
196         REJECTED;
197     }
198 
199     /**
200      * A utility class to set and get the system-wide filter or create a filter
201      * from a pattern string. If a system-wide filter is set, it will be
202      * used for each {@link ObjectInputStream} that does not set its own filter.
203      * &lt;p&gt;
204      * When setting the filter, it should be stateless and idempotent,
205      * reporting the same result when passed the same arguments.
206      * &lt;p&gt;
207      * The filter is configured during the initialization of the {@code ObjectInputFilter.Config}
208      * class. For example, by calling {@link #getSerialFilter() Config.getSerialFilter}.
209      * If the Java virtual machine is started with the system property
210      * {@systemProperty jdk.serialFilter}, its value is used to configure the filter.
211      * If the system property is not defined, and the {@link java.security.Security} property
212      * {@code jdk.serialFilter} is defined then it is used to configure the filter.
213      * Otherwise, the filter is not configured during initialization and
214      * can be set with {@link #setSerialFilter(ObjectInputFilter) Config.setSerialFilter}.
215      * Setting the {@code jdk.serialFilter} with {@link System#setProperty(String, String)
216      * System.setProperty} &lt;em&gt;does not set the filter&lt;/em&gt;.
217      * The syntax for each property is the same as for the
218      * {@link #createFilter(String) createFilter} method.
219      *
220      * @since 9
221      */
222     final class Config {
223         /* No instances. */
224         private Config() {}
225 
226         /**
227          * Lock object for system-wide filter.
228          */
229         private final static Object serialFilterLock = new Object();
230 
231         /**
232          * Debug: Logger
233          */
234         private final static System.Logger configLog;
235 
236         /**
237          * Logger for debugging.
238          */
239         static void filterLog(System.Logger.Level level, String msg, Object... args) {
240             if (configLog != null) {
241                 configLog.log(level, msg, args);
242             }
243         }
244 
245         /**
246          * The name for the system-wide deserialization filter.
247          * Used as a system property and a java.security.Security property.
248          */
249         private final static String SERIAL_FILTER_PROPNAME = &quot;jdk.serialFilter&quot;;
250 
251         /**
252          * The system-wide filter; may be null.
253          * Lookup the filter in java.security.Security or
254          * the system property.
255          */
256         private final static ObjectInputFilter configuredFilter;
257 
258         static {
259             configuredFilter = AccessController
260                     .doPrivileged((PrivilegedAction&lt;ObjectInputFilter&gt;) () -&gt; {
261                         String props = StaticProperty.jdkSerialFilter();
262                         if (props == null) {
263                             props = Security.getProperty(SERIAL_FILTER_PROPNAME);
264                         }
265                         if (props != null) {
266                             System.Logger log =
267                                     System.getLogger(&quot;java.io.serialization&quot;);
268                             log.log(System.Logger.Level.INFO,
269                                     &quot;Creating serialization filter from {0}&quot;, props);
270                             try {
271                                 return createFilter(props);
272                             } catch (RuntimeException re) {
273                                 log.log(System.Logger.Level.ERROR,
274                                         &quot;Error configuring filter: {0}&quot;, re);
275                             }
276                         }
277                         return null;
278                     });
279             configLog = (configuredFilter != null) ? System.getLogger(&quot;java.io.serialization&quot;) : null;
280 
281             // Setup shared secrets for RegistryImpl to use.
282             SharedSecrets.setJavaObjectInputFilterAccess(Config::createFilter2);
283         }
284 
285         /**
286          * Current configured filter.
287          */
288         private static volatile ObjectInputFilter serialFilter = configuredFilter;
289 
290         /**
291          * Returns the system-wide serialization filter or {@code null} if not configured.
292          *
293          * @return the system-wide serialization filter or {@code null} if not configured
294          */
295         public static ObjectInputFilter getSerialFilter() {
296             return serialFilter;
297         }
298 
299         /**
300          * Set the system-wide filter if it has not already been configured or set.
301          *
302          * @param filter the serialization filter to set as the system-wide filter; not null
303          * @throws SecurityException if there is security manager and the
304          *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
305          * @throws IllegalStateException if the filter has already been set {@code non-null}
306          */
307         public static void setSerialFilter(ObjectInputFilter filter) {
308             Objects.requireNonNull(filter, &quot;filter&quot;);
309             SecurityManager sm = System.getSecurityManager();
310             if (sm != null) {
311                 sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
312             }
313             synchronized (serialFilterLock) {
314                 if (serialFilter != null) {
315                     throw new IllegalStateException(&quot;Serial filter can only be set once&quot;);
316                 }
317                 serialFilter = filter;
318             }
319         }
320 
321         /**
322          * Returns an ObjectInputFilter from a string of patterns.
323          * &lt;p&gt;
324          * Patterns are separated by &quot;;&quot; (semicolon). Whitespace is significant and
325          * is considered part of the pattern.
326          * If a pattern includes an equals assignment, &quot;{@code =}&quot; it sets a limit.
327          * If a limit appears more than once the last value is used.
328          * &lt;ul&gt;
329          *     &lt;li&gt;maxdepth={@code value} - the maximum depth of a graph&lt;/li&gt;
330          *     &lt;li&gt;maxrefs={@code value}  - the maximum number of internal references&lt;/li&gt;
331          *     &lt;li&gt;maxbytes={@code value} - the maximum number of bytes in the input stream&lt;/li&gt;
332          *     &lt;li&gt;maxarray={@code value} - the maximum array length allowed&lt;/li&gt;
333          * &lt;/ul&gt;
334          * &lt;p&gt;
335          * Other patterns match or reject class or package name
336          * as returned from {@link Class#getName() Class.getName()} and
337          * if an optional module name is present
338          * {@link Module#getName() class.getModule().getName()}.
339          * Note that for arrays the element type is used in the pattern,
340          * not the array type.
341          * &lt;ul&gt;
342          * &lt;li&gt;If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched;
343          *     otherwise the class is allowed if the pattern matches.
344          * &lt;li&gt;If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name;
345          *     if the module name matches the module name of the class then
346          *     the remaining pattern is matched with the class name.
347          *     If there is no &quot;/&quot;, the module name is not compared.
348          * &lt;li&gt;If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.
349          * &lt;li&gt;If the pattern ends with &quot;.*&quot; it matches any class in the package.
350          * &lt;li&gt;If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.
351          * &lt;li&gt;If the pattern is equal to the class name, it matches.
352          * &lt;li&gt;Otherwise, the pattern is not matched.
353          * &lt;/ul&gt;
354          * &lt;p&gt;
355          * The resulting filter performs the limit checks and then
356          * tries to match the class, if any. If any of the limits are exceeded,
357          * the filter returns {@link Status#REJECTED Status.REJECTED}.
358          * If the class is an array type, the class to be matched is the element type.
359          * Arrays of any number of dimensions are treated the same as the element type.
360          * For example, a pattern of &quot;{@code !example.Foo}&quot;,
361          * rejects creation of any instance or array of {@code example.Foo}.
362          * The first pattern that matches, working from left to right, determines
363          * the {@link Status#ALLOWED Status.ALLOWED}
364          * or {@link Status#REJECTED Status.REJECTED} result.
365          * If the limits are not exceeded and no pattern matches the class,
366          * the result is {@link Status#UNDECIDED Status.UNDECIDED}.
367          *
368          * @param pattern the pattern string to parse; not null
369          * @return a filter to check a class being deserialized;
370          *          {@code null} if no patterns
371          * @throws IllegalArgumentException if the pattern string is illegal or
372          *         malformed and cannot be parsed.
373          *         In particular, if any of the following is true:
374          * &lt;ul&gt;
375          * &lt;li&gt;   if a limit is missing the name or the name is not one of
376          *        &quot;maxdepth&quot;, &quot;maxrefs&quot;, &quot;maxbytes&quot;, or &quot;maxarray&quot;
377          * &lt;li&gt;   if the value of the limit can not be parsed by
378          *        {@link Long#parseLong Long.parseLong} or is negative
379          * &lt;li&gt;   if the pattern contains &quot;/&quot; and the module name is missing
380          *        or the remaining pattern is empty
381          * &lt;li&gt;   if the package is missing for &quot;.*&quot; and &quot;.**&quot;
382          * &lt;/ul&gt;
383          */
384         public static ObjectInputFilter createFilter(String pattern) {
385             Objects.requireNonNull(pattern, &quot;pattern&quot;);
386             return Global.createFilter(pattern, true);
387         }
388 
389         /**
390          * Returns an ObjectInputFilter from a string of patterns that
391          * checks only the length for arrays, not the component type.
392          *
393          * @param pattern the pattern string to parse; not null
394          * @return a filter to check a class being deserialized;
395          *          {@code null} if no patterns
396          */
397         static ObjectInputFilter createFilter2(String pattern) {
398             Objects.requireNonNull(pattern, &quot;pattern&quot;);
399             return Global.createFilter(pattern, false);
400         }
401 
402         /**
403          * Implementation of ObjectInputFilter that performs the checks of
404          * the system-wide serialization filter. If configured, it will be
405          * used for all ObjectInputStreams that do not set their own filters.
406          *
407          */
408         final static class Global implements ObjectInputFilter {
409             /**
410              * The pattern used to create the filter.
411              */
412             private final String pattern;
413             /**
414              * The list of class filters.
415              */
416             private final List&lt;Function&lt;Class&lt;?&gt;, Status&gt;&gt; filters;
417             /**
418              * Maximum allowed bytes in the stream.
419              */
420             private long maxStreamBytes;
421             /**
422              * Maximum depth of the graph allowed.
423              */
424             private long maxDepth;
425             /**
426              * Maximum number of references in a graph.
427              */
428             private long maxReferences;
429             /**
430              * Maximum length of any array.
431              */
432             private long maxArrayLength;
433             /**
434              * True to check the component type for arrays.
435              */
436             private final boolean checkComponentType;
437 
438             /**
439              * Returns an ObjectInputFilter from a string of patterns.
440              *
441              * @param pattern the pattern string to parse
442              * @param checkComponentType true if the filter should check
443              *                           the component type of arrays
444              * @return a filter to check a class being deserialized;
445              *          {@code null} if no patterns
446              * @throws IllegalArgumentException if the parameter is malformed
447              *                if the pattern is missing the name, the long value
448              *                is not a number or is negative.
449              */
450             static ObjectInputFilter createFilter(String pattern, boolean checkComponentType) {
451                 try {
452                     return new Global(pattern, checkComponentType);
453                 } catch (UnsupportedOperationException uoe) {
454                     // no non-empty patterns
455                     return null;
456                 }
457             }
458 
459             /**
460              * Construct a new filter from the pattern String.
461              *
462              * @param pattern a pattern string of filters
463              * @param checkComponentType true if the filter should check
464              *                           the component type of arrays
465              * @throws IllegalArgumentException if the pattern is malformed
466              * @throws UnsupportedOperationException if there are no non-empty patterns
467              */
468             private Global(String pattern, boolean checkComponentType) {
469                 boolean hasLimits = false;
470                 this.pattern = pattern;
471                 this.checkComponentType = checkComponentType;
472 
473                 maxArrayLength = Long.MAX_VALUE; // Default values are unlimited
474                 maxDepth = Long.MAX_VALUE;
475                 maxReferences = Long.MAX_VALUE;
476                 maxStreamBytes = Long.MAX_VALUE;
477 
478                 String[] patterns = pattern.split(&quot;;&quot;);
479                 filters = new ArrayList&lt;&gt;(patterns.length);
480                 for (int i = 0; i &lt; patterns.length; i++) {
481                     String p = patterns[i];
482                     int nameLen = p.length();
483                     if (nameLen == 0) {
484                         continue;
485                     }
486                     if (parseLimit(p)) {
487                         // If the pattern contained a limit setting, i.e. type=value
488                         hasLimits = true;
489                         continue;
490                     }
491                     boolean negate = p.charAt(0) == &#39;!&#39;;
492                     int poffset = negate ? 1 : 0;
493 
494                     // isolate module name, if any
495                     int slash = p.indexOf(&#39;/&#39;, poffset);
496                     if (slash == poffset) {
497                         throw new IllegalArgumentException(&quot;module name is missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
498                     }
499                     final String moduleName = (slash &gt;= 0) ? p.substring(poffset, slash) : null;
500                     poffset = (slash &gt;= 0) ? slash + 1 : poffset;
501 
502                     final Function&lt;Class&lt;?&gt;, Status&gt; patternFilter;
503                     if (p.endsWith(&quot;*&quot;)) {
504                         // Wildcard cases
505                         if (p.endsWith(&quot;.*&quot;)) {
506                             // Pattern is a package name with a wildcard
507                             final String pkg = p.substring(poffset, nameLen - 2);
508                             if (pkg.isEmpty()) {
509                                 throw new IllegalArgumentException(&quot;package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
510                             }
511                             if (negate) {
512                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
513                                 patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.REJECTED : Status.UNDECIDED;
514                             } else {
515                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
516                                 patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.ALLOWED : Status.UNDECIDED;
517                             }
518                         } else if (p.endsWith(&quot;.**&quot;)) {
519                             // Pattern is a package prefix with a double wildcard
520                             final String pkgs = p.substring(poffset, nameLen - 2);
521                             if (pkgs.length() &lt; 2) {
522                                 throw new IllegalArgumentException(&quot;package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
523                             }
524                             if (negate) {
525                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
526                                 patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.REJECTED : Status.UNDECIDED;
527                             } else {
528                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
529                                 patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.ALLOWED : Status.UNDECIDED;
530                             }
531                         } else {
532                             // Pattern is a classname (possibly empty) with a trailing wildcard
533                             final String className = p.substring(poffset, nameLen - 1);
534                             if (negate) {
535                                 // A Function that fails if the class starts with the pattern, otherwise don&#39;t care
536                                 patternFilter = c -&gt; c.getName().startsWith(className) ? Status.REJECTED : Status.UNDECIDED;
537                             } else {
538                                 // A Function that succeeds if the class starts with the pattern, otherwise don&#39;t care
539                                 patternFilter = c -&gt; c.getName().startsWith(className) ? Status.ALLOWED : Status.UNDECIDED;
540                             }
541                         }
542                     } else {
543                         final String name = p.substring(poffset);
544                         if (name.isEmpty()) {
545                             throw new IllegalArgumentException(&quot;class or package missing in: \&quot;&quot; + pattern + &quot;\&quot;&quot;);
546                         }
547                         // Pattern is a class name
548                         if (negate) {
549                             // A Function that fails if the class equals the pattern, otherwise don&#39;t care
550                             patternFilter = c -&gt; c.getName().equals(name) ? Status.REJECTED : Status.UNDECIDED;
551                         } else {
552                             // A Function that succeeds if the class equals the pattern, otherwise don&#39;t care
553                             patternFilter = c -&gt; c.getName().equals(name) ? Status.ALLOWED : Status.UNDECIDED;
554                         }
555                     }
556                     // If there is a moduleName, combine the module name check with the package/class check
557                     if (moduleName == null) {
558                         filters.add(patternFilter);
559                     } else {
560                         filters.add(c -&gt; moduleName.equals(c.getModule().getName()) ? patternFilter.apply(c) : Status.UNDECIDED);
561                     }
562                 }
563                 if (filters.isEmpty() &amp;&amp; !hasLimits) {
564                     throw new UnsupportedOperationException(&quot;no non-empty patterns&quot;);
565                 }
566             }
567 
568             /**
569              * Parse out a limit for one of maxarray, maxdepth, maxbytes, maxreferences.
570              *
571              * @param pattern a string with a type name, &#39;=&#39; and a value
572              * @return {@code true} if a limit was parsed, else {@code false}
573              * @throws IllegalArgumentException if the pattern is missing
574              *                the name, the Long value is not a number or is negative.
575              */
576             private boolean parseLimit(String pattern) {
577                 int eqNdx = pattern.indexOf(&#39;=&#39;);
578                 if (eqNdx &lt; 0) {
579                     // not a limit pattern
580                     return false;
581                 }
582                 String valueString = pattern.substring(eqNdx + 1);
583                 if (pattern.startsWith(&quot;maxdepth=&quot;)) {
584                     maxDepth = parseValue(valueString);
585                 } else if (pattern.startsWith(&quot;maxarray=&quot;)) {
586                     maxArrayLength = parseValue(valueString);
587                 } else if (pattern.startsWith(&quot;maxrefs=&quot;)) {
588                     maxReferences = parseValue(valueString);
589                 } else if (pattern.startsWith(&quot;maxbytes=&quot;)) {
590                     maxStreamBytes = parseValue(valueString);
591                 } else {
592                     throw new IllegalArgumentException(&quot;unknown limit: &quot; + pattern.substring(0, eqNdx));
593                 }
594                 return true;
595             }
596 
597             /**
598              * Parse the value of a limit and check that it is non-negative.
599              * @param string inputstring
600              * @return the parsed value
601              * @throws IllegalArgumentException if parsing the value fails or the value is negative
602              */
603             private static long parseValue(String string) throws IllegalArgumentException {
604                 // Parse a Long from after the &#39;=&#39; to the end
605                 long value = Long.parseLong(string);
606                 if (value &lt; 0) {
607                     throw new IllegalArgumentException(&quot;negative limit: &quot; + string);
608                 }
609                 return value;
610             }
611 
612             /**
613              * {@inheritDoc}
614              */
615             @Override
616             public Status checkInput(FilterInfo filterInfo) {
617                 if (filterInfo.references() &lt; 0
618                         || filterInfo.depth() &lt; 0
619                         || filterInfo.streamBytes() &lt; 0
620                         || filterInfo.references() &gt; maxReferences
621                         || filterInfo.depth() &gt; maxDepth
622                         || filterInfo.streamBytes() &gt; maxStreamBytes) {
623                     return Status.REJECTED;
624                 }
625 
626                 Class&lt;?&gt; clazz = filterInfo.serialClass();
627                 if (clazz != null) {
628                     if (clazz.isArray()) {
629                         if (filterInfo.arrayLength() &gt;= 0 &amp;&amp; filterInfo.arrayLength() &gt; maxArrayLength) {
630                             // array length is too big
631                             return Status.REJECTED;
632                         }
633                         if (!checkComponentType) {
634                             // As revised; do not check the component type for arrays
635                             return Status.UNDECIDED;
636                         }
637                         do {
638                             // Arrays are decided based on the component type
639                             clazz = clazz.getComponentType();
640                         } while (clazz.isArray());
641                     }
642 
643                     if (clazz.isPrimitive())  {
644                         // Primitive types are undecided; let someone else decide
645                         return Status.UNDECIDED;
646                     } else {
647                         // Find any filter that allowed or rejected the class
648                         final Class&lt;?&gt; cl = clazz;
649                         Optional&lt;Status&gt; status = filters.stream()
650                                 .map(f -&gt; f.apply(cl))
651                                 .filter(p -&gt; p != Status.UNDECIDED)
652                                 .findFirst();
653                         return status.orElse(Status.UNDECIDED);
654                     }
655                 }
656                 return Status.UNDECIDED;
657             }
658 
659             /**
660              * Returns {@code true} if the class is in the package.
661              *
662              * @param c   a class
663              * @param pkg a package name
664              * @return {@code true} if the class is in the package,
665              * otherwise {@code false}
666              */
667             private static boolean matchesPackage(Class&lt;?&gt; c, String pkg) {
668                 return pkg.equals(c.getPackageName());
669             }
670 
671             /**
672              * Returns the pattern used to create this filter.
673              * @return the pattern used to create this filter
674              */
675             @Override
676             public String toString() {
677                 return pattern;
678             }
679         }
680     }
681 }
    </pre>
  </body>
</html>
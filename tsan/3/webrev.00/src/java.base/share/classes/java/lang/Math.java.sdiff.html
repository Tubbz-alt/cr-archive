<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Math.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Long.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Module.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Math.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  75  * returned.  For exact results large in magnitude, one of the
  76  * endpoints of the bracket may be infinite.  Besides accuracy at
  77  * individual arguments, maintaining proper relations between the
  78  * method at different arguments is also important.  Therefore, most
  79  * methods with more than 0.5 ulp errors are required to be
  80  * &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical function is
  81  * non-decreasing, so is the floating-point approximation, likewise,
  82  * whenever the mathematical function is non-increasing, so is the
  83  * floating-point approximation.  Not all approximations that have 1
  84  * ulp accuracy will automatically meet the monotonicity requirements.
  85  *
  86  * &lt;p&gt;
  87  * The platform uses signed two&#39;s complement integer arithmetic with
  88  * int and long primitive types.  The developer should choose
  89  * the primitive type to ensure that arithmetic operations consistently
  90  * produce correct results, which in some cases means the operations
  91  * will not overflow the range of values of the computation.
  92  * The best practice is to choose the primitive type and algorithm to avoid
  93  * overflow. In cases where the size is {@code int} or {@code long} and
  94  * overflow errors need to be detected, the methods {@code addExact},
<span class="line-modified">  95  * {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}</span>

  96  * throw an {@code ArithmeticException} when the results overflow.
<span class="line-modified">  97  * For other arithmetic operations such as divide, absolute value,</span>
<span class="line-modified">  98  * increment by one, decrement by one, and negation, overflow occurs only with</span>
<span class="line-modified">  99  * a specific minimum or maximum value and should be checked against</span>
<span class="line-removed"> 100  * the minimum or maximum as appropriate.</span>
 101  *
 102  * @author  unascribed
 103  * @author  Joseph D. Darcy
 104  * @since   1.0
 105  */
 106 
 107 public final class Math {
 108 
 109     /**
 110      * Don&#39;t let anyone instantiate this class.
 111      */
 112     private Math() {}
 113 
 114     /**
 115      * The {@code double} value that is closer than any other to
 116      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
 117      */
 118     public static final double E = 2.7182818284590452354;
 119 
 120     /**
</pre>
<hr />
<pre>
 423 
 424     /**
 425      * Returns the smallest (closest to negative infinity)
 426      * {@code double} value that is greater than or equal to the
 427      * argument and is equal to a mathematical integer. Special cases:
 428      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 429      * mathematical integer, then the result is the same as the
 430      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 431      * positive zero or negative zero, then the result is the same as
 432      * the argument.  &lt;li&gt;If the argument value is less than zero but
 433      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 434      * that the value of {@code Math.ceil(x)} is exactly the
 435      * value of {@code -Math.floor(-x)}.
 436      *
 437      *
 438      * @param   a   a value.
 439      * @return  the smallest (closest to negative infinity)
 440      *          floating-point value that is greater than or equal to
 441      *          the argument and is equal to a mathematical integer.
 442      */

 443     public static double ceil(double a) {
 444         return StrictMath.ceil(a); // default impl. delegates to StrictMath
 445     }
 446 
 447     /**
 448      * Returns the largest (closest to positive infinity)
 449      * {@code double} value that is less than or equal to the
 450      * argument and is equal to a mathematical integer. Special cases:
 451      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 452      * mathematical integer, then the result is the same as the
 453      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 454      * positive zero or negative zero, then the result is the same as
 455      * the argument.&lt;/ul&gt;
 456      *
 457      * @param   a   a value.
 458      * @return  the largest (closest to positive infinity)
 459      *          floating-point value that less than or equal to the argument
 460      *          and is equal to a mathematical integer.
 461      */

 462     public static double floor(double a) {
 463         return StrictMath.floor(a); // default impl. delegates to StrictMath
 464     }
 465 
 466     /**
 467      * Returns the {@code double} value that is closest in value
 468      * to the argument and is equal to a mathematical integer. If two
 469      * {@code double} values that are mathematical integers are
 470      * equally close, the result is the integer value that is
 471      * even. Special cases:
 472      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 473      * integer, then the result is the same as the argument.
 474      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 475      * zero, then the result is the same as the argument.&lt;/ul&gt;
 476      *
 477      * @param   a   a {@code double} value.
 478      * @return  the closest floating-point value to {@code a} that is
 479      *          equal to a mathematical integer.
 480      */

 481     public static double rint(double a) {
 482         return StrictMath.rint(a); // default impl. delegates to StrictMath
 483     }
 484 
 485     /**
 486      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 487      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 488      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 489      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 490      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 491      * cases:
 492      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 493      * &lt;li&gt;If the first argument is positive zero and the second argument
 494      * is positive, or the first argument is positive and finite and the
 495      * second argument is positive infinity, then the result is positive
 496      * zero.
 497      * &lt;li&gt;If the first argument is negative zero and the second argument
 498      * is positive, or the first argument is negative and finite and the
 499      * second argument is positive infinity, then the result is negative zero.
 500      * &lt;li&gt;If the first argument is positive zero and the second argument
</pre>
<hr />
<pre>
 935     @HotSpotIntrinsicCandidate
 936     public static long multiplyExact(long x, long y) {
 937         long r = x * y;
 938         long ax = Math.abs(x);
 939         long ay = Math.abs(y);
 940         if (((ax | ay) &gt;&gt;&gt; 31 != 0)) {
 941             // Some bits greater than 2^31 that might cause overflow
 942             // Check the result using the divide operator
 943             // and check for the special case of Long.MIN_VALUE * -1
 944            if (((y != 0) &amp;&amp; (r / y != x)) ||
 945                (x == Long.MIN_VALUE &amp;&amp; y == -1)) {
 946                 throw new ArithmeticException(&quot;long overflow&quot;);
 947             }
 948         }
 949         return r;
 950     }
 951 
 952     /**
 953      * Returns the argument incremented by one, throwing an exception if the
 954      * result overflows an {@code int}.

 955      *
 956      * @param a the value to increment
 957      * @return the result
 958      * @throws ArithmeticException if the result overflows an int
 959      * @since 1.8
 960      */
 961     @HotSpotIntrinsicCandidate
 962     public static int incrementExact(int a) {
 963         if (a == Integer.MAX_VALUE) {
 964             throw new ArithmeticException(&quot;integer overflow&quot;);
 965         }
 966 
 967         return a + 1;
 968     }
 969 
 970     /**
 971      * Returns the argument incremented by one, throwing an exception if the
 972      * result overflows a {@code long}.

 973      *
 974      * @param a the value to increment
 975      * @return the result
 976      * @throws ArithmeticException if the result overflows a long
 977      * @since 1.8
 978      */
 979     @HotSpotIntrinsicCandidate
 980     public static long incrementExact(long a) {
 981         if (a == Long.MAX_VALUE) {
 982             throw new ArithmeticException(&quot;long overflow&quot;);
 983         }
 984 
 985         return a + 1L;
 986     }
 987 
 988     /**
 989      * Returns the argument decremented by one, throwing an exception if the
 990      * result overflows an {@code int}.

 991      *
 992      * @param a the value to decrement
 993      * @return the result
 994      * @throws ArithmeticException if the result overflows an int
 995      * @since 1.8
 996      */
 997     @HotSpotIntrinsicCandidate
 998     public static int decrementExact(int a) {
 999         if (a == Integer.MIN_VALUE) {
1000             throw new ArithmeticException(&quot;integer overflow&quot;);
1001         }
1002 
1003         return a - 1;
1004     }
1005 
1006     /**
1007      * Returns the argument decremented by one, throwing an exception if the
1008      * result overflows a {@code long}.

1009      *
1010      * @param a the value to decrement
1011      * @return the result
1012      * @throws ArithmeticException if the result overflows a long
1013      * @since 1.8
1014      */
1015     @HotSpotIntrinsicCandidate
1016     public static long decrementExact(long a) {
1017         if (a == Long.MIN_VALUE) {
1018             throw new ArithmeticException(&quot;long overflow&quot;);
1019         }
1020 
1021         return a - 1L;
1022     }
1023 
1024     /**
1025      * Returns the negation of the argument, throwing an exception if the
1026      * result overflows an {@code int}.

1027      *
1028      * @param a the value to negate
1029      * @return the result
1030      * @throws ArithmeticException if the result overflows an int
1031      * @since 1.8
1032      */
1033     @HotSpotIntrinsicCandidate
1034     public static int negateExact(int a) {
1035         if (a == Integer.MIN_VALUE) {
1036             throw new ArithmeticException(&quot;integer overflow&quot;);
1037         }
1038 
1039         return -a;
1040     }
1041 
1042     /**
1043      * Returns the negation of the argument, throwing an exception if the
1044      * result overflows a {@code long}.

1045      *
1046      * @param a the value to negate
1047      * @return the result
1048      * @throws ArithmeticException if the result overflows a long
1049      * @since 1.8
1050      */
1051     @HotSpotIntrinsicCandidate
1052     public static long negateExact(long a) {
1053         if (a == Long.MIN_VALUE) {
1054             throw new ArithmeticException(&quot;long overflow&quot;);
1055         }
1056 
1057         return -a;
1058     }
1059 
1060     /**
<span class="line-modified">1061      * Returns the value of the {@code long} argument;</span>
1062      * throwing an exception if the value overflows an {@code int}.
1063      *
1064      * @param value the long value
1065      * @return the argument as an int
1066      * @throws ArithmeticException if the {@code argument} overflows an int
1067      * @since 1.8
1068      */
1069     public static int toIntExact(long value) {
1070         if ((int)value != value) {
1071             throw new ArithmeticException(&quot;integer overflow&quot;);
1072         }
1073         return (int)value;
1074     }
1075 
1076     /**
1077      * Returns the exact mathematical product of the arguments.
1078      *
1079      * @param x the first value
1080      * @param y the second value
1081      * @return the result
</pre>
<hr />
<pre>
1233      * Returns the floor modulus of the {@code int} arguments.
1234      * &lt;p&gt;
1235      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1236      * has the same sign as the divisor {@code y}, and
1237      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1238      *
1239      * &lt;p&gt;
1240      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1241      * &lt;ul&gt;
1242      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1243      * &lt;/ul&gt;
1244      * &lt;p&gt;
1245      * The difference in values between {@code floorMod} and
1246      * the {@code %} operator is due to the difference between
1247      * {@code floorDiv} that returns the integer less than or equal to the quotient
1248      * and the {@code /} operator that returns the integer closest to zero.
1249      * &lt;p&gt;
1250      * Examples:
1251      * &lt;ul&gt;
1252      *   &lt;li&gt;If the signs of the arguments are the same, the results
<span class="line-modified">1253      *       of {@code floorMod} and the {@code %} operator are the same.  &lt;br&gt;</span>






1254      *       &lt;ul&gt;
<span class="line-modified">1255      *       &lt;li&gt;{@code floorMod(4, 3) == 1}; &amp;nbsp; and {@code (4 % 3) == 1}&lt;/li&gt;</span>

1256      *       &lt;/ul&gt;
<span class="line-removed">1257      *   &lt;li&gt;If the signs of the arguments are different, the results differ from the {@code %} operator.&lt;br&gt;</span>
<span class="line-removed">1258      *      &lt;ul&gt;</span>
<span class="line-removed">1259      *      &lt;li&gt;{@code floorMod(+4, -3) == -2}; &amp;nbsp; and {@code (+4 % -3) == +1} &lt;/li&gt;</span>
<span class="line-removed">1260      *      &lt;li&gt;{@code floorMod(-4, +3) == +2}; &amp;nbsp; and {@code (-4 % +3) == -1} &lt;/li&gt;</span>
<span class="line-removed">1261      *      &lt;li&gt;{@code floorMod(-4, -3) == -1}; &amp;nbsp; and {@code (-4 % -3) == -1 } &lt;/li&gt;</span>
<span class="line-removed">1262      *      &lt;/ul&gt;</span>
1263      *   &lt;/li&gt;
1264      * &lt;/ul&gt;
1265      * &lt;p&gt;
1266      * If the signs of arguments are unknown and a positive modulus
1267      * is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
1268      *
1269      * @param x the dividend
1270      * @param y the divisor
1271      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1272      * @throws ArithmeticException if the divisor {@code y} is zero
1273      * @see #floorDiv(int, int)
1274      * @since 1.8
1275      */
1276     public static int floorMod(int x, int y) {
<span class="line-modified">1277         return x - floorDiv(x, y) * y;</span>





1278     }
1279 
1280     /**
1281      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1282      * &lt;p&gt;
1283      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1284      * has the same sign as the divisor {@code y}, and
1285      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1286      *
1287      * &lt;p&gt;
1288      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1289      * &lt;ul&gt;
1290      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1291      * &lt;/ul&gt;
1292      * &lt;p&gt;
1293      * For examples, see {@link #floorMod(int, int)}.
1294      *
1295      * @param x the dividend
1296      * @param y the divisor
1297      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1298      * @throws ArithmeticException if the divisor {@code y} is zero
1299      * @see #floorDiv(long, int)
1300      * @since 9
1301      */
1302     public static int floorMod(long x, int y) {
1303         // Result cannot overflow the range of int.
<span class="line-modified">1304         return (int)(x - floorDiv(x, y) * y);</span>
1305     }
1306 
1307     /**
1308      * Returns the floor modulus of the {@code long} arguments.
1309      * &lt;p&gt;
1310      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1311      * has the same sign as the divisor {@code y}, and
1312      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1313      *
1314      * &lt;p&gt;
1315      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1316      * &lt;ul&gt;
1317      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1318      * &lt;/ul&gt;
1319      * &lt;p&gt;
1320      * For examples, see {@link #floorMod(int, int)}.
1321      *
1322      * @param x the dividend
1323      * @param y the divisor
1324      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1325      * @throws ArithmeticException if the divisor {@code y} is zero
1326      * @see #floorDiv(long, long)
1327      * @since 1.8
1328      */
1329     public static long floorMod(long x, long y) {
<span class="line-modified">1330         return x - floorDiv(x, y) * y;</span>





1331     }
1332 
1333     /**
1334      * Returns the absolute value of an {@code int} value.
1335      * If the argument is not negative, the argument is returned.
1336      * If the argument is negative, the negation of the argument is returned.
1337      *
1338      * &lt;p&gt;Note that if the argument is equal to the value of
1339      * {@link Integer#MIN_VALUE}, the most negative representable
1340      * {@code int} value, the result is that same value, which is
1341      * negative.
1342      *
1343      * @param   a   the argument whose absolute value is to be determined
1344      * @return  the absolute value of the argument.
1345      */

1346     public static int abs(int a) {
1347         return (a &lt; 0) ? -a : a;
1348     }
1349 
1350     /**
1351      * Returns the absolute value of a {@code long} value.
1352      * If the argument is not negative, the argument is returned.
1353      * If the argument is negative, the negation of the argument is returned.
1354      *
1355      * &lt;p&gt;Note that if the argument is equal to the value of
1356      * {@link Long#MIN_VALUE}, the most negative representable
1357      * {@code long} value, the result is that same value, which
1358      * is negative.
1359      *
1360      * @param   a   the argument whose absolute value is to be determined
1361      * @return  the absolute value of the argument.
1362      */

1363     public static long abs(long a) {
1364         return (a &lt; 0) ? -a : a;
1365     }
1366 
1367     /**
1368      * Returns the absolute value of a {@code float} value.
1369      * If the argument is not negative, the argument is returned.
1370      * If the argument is negative, the negation of the argument is returned.
1371      * Special cases:
1372      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1373      * result is positive zero.
1374      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1375      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1376      *
1377      * @apiNote As implied by the above, one valid implementation of
1378      * this method is given by the expression below which computes a
1379      * {@code float} with the same exponent and significand as the
1380      * argument but with a guaranteed zero sign bit indicating a
1381      * positive value:&lt;br&gt;
1382      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1383      *
1384      * @param   a   the argument whose absolute value is to be determined
1385      * @return  the absolute value of the argument.
1386      */

1387     public static float abs(float a) {
1388         return (a &lt;= 0.0F) ? 0.0F - a : a;
1389     }
1390 
1391     /**
1392      * Returns the absolute value of a {@code double} value.
1393      * If the argument is not negative, the argument is returned.
1394      * If the argument is negative, the negation of the argument is returned.
1395      * Special cases:
1396      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1397      * is positive zero.
1398      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1399      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1400      *
1401      * @apiNote As implied by the above, one valid implementation of
1402      * this method is given by the expression below which computes a
1403      * {@code double} with the same exponent and significand as the
1404      * argument but with a guaranteed zero sign bit indicating a
1405      * positive value:&lt;br&gt;
1406      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  75  * returned.  For exact results large in magnitude, one of the
  76  * endpoints of the bracket may be infinite.  Besides accuracy at
  77  * individual arguments, maintaining proper relations between the
  78  * method at different arguments is also important.  Therefore, most
  79  * methods with more than 0.5 ulp errors are required to be
  80  * &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical function is
  81  * non-decreasing, so is the floating-point approximation, likewise,
  82  * whenever the mathematical function is non-increasing, so is the
  83  * floating-point approximation.  Not all approximations that have 1
  84  * ulp accuracy will automatically meet the monotonicity requirements.
  85  *
  86  * &lt;p&gt;
  87  * The platform uses signed two&#39;s complement integer arithmetic with
  88  * int and long primitive types.  The developer should choose
  89  * the primitive type to ensure that arithmetic operations consistently
  90  * produce correct results, which in some cases means the operations
  91  * will not overflow the range of values of the computation.
  92  * The best practice is to choose the primitive type and algorithm to avoid
  93  * overflow. In cases where the size is {@code int} or {@code long} and
  94  * overflow errors need to be detected, the methods {@code addExact},
<span class="line-modified">  95  * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},</span>
<span class="line-added">  96  * {@code incrementExact}, {@code decrementExact} and {@code negateExact}</span>
  97  * throw an {@code ArithmeticException} when the results overflow.
<span class="line-modified">  98  * For the arithmetic operations divide and absolute value, overflow</span>
<span class="line-modified">  99  * occurs only with a specific minimum or maximum value and</span>
<span class="line-modified"> 100  * should be checked against the minimum or maximum as appropriate.</span>

 101  *
 102  * @author  unascribed
 103  * @author  Joseph D. Darcy
 104  * @since   1.0
 105  */
 106 
 107 public final class Math {
 108 
 109     /**
 110      * Don&#39;t let anyone instantiate this class.
 111      */
 112     private Math() {}
 113 
 114     /**
 115      * The {@code double} value that is closer than any other to
 116      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
 117      */
 118     public static final double E = 2.7182818284590452354;
 119 
 120     /**
</pre>
<hr />
<pre>
 423 
 424     /**
 425      * Returns the smallest (closest to negative infinity)
 426      * {@code double} value that is greater than or equal to the
 427      * argument and is equal to a mathematical integer. Special cases:
 428      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 429      * mathematical integer, then the result is the same as the
 430      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 431      * positive zero or negative zero, then the result is the same as
 432      * the argument.  &lt;li&gt;If the argument value is less than zero but
 433      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 434      * that the value of {@code Math.ceil(x)} is exactly the
 435      * value of {@code -Math.floor(-x)}.
 436      *
 437      *
 438      * @param   a   a value.
 439      * @return  the smallest (closest to negative infinity)
 440      *          floating-point value that is greater than or equal to
 441      *          the argument and is equal to a mathematical integer.
 442      */
<span class="line-added"> 443     @HotSpotIntrinsicCandidate</span>
 444     public static double ceil(double a) {
 445         return StrictMath.ceil(a); // default impl. delegates to StrictMath
 446     }
 447 
 448     /**
 449      * Returns the largest (closest to positive infinity)
 450      * {@code double} value that is less than or equal to the
 451      * argument and is equal to a mathematical integer. Special cases:
 452      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 453      * mathematical integer, then the result is the same as the
 454      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 455      * positive zero or negative zero, then the result is the same as
 456      * the argument.&lt;/ul&gt;
 457      *
 458      * @param   a   a value.
 459      * @return  the largest (closest to positive infinity)
 460      *          floating-point value that less than or equal to the argument
 461      *          and is equal to a mathematical integer.
 462      */
<span class="line-added"> 463     @HotSpotIntrinsicCandidate</span>
 464     public static double floor(double a) {
 465         return StrictMath.floor(a); // default impl. delegates to StrictMath
 466     }
 467 
 468     /**
 469      * Returns the {@code double} value that is closest in value
 470      * to the argument and is equal to a mathematical integer. If two
 471      * {@code double} values that are mathematical integers are
 472      * equally close, the result is the integer value that is
 473      * even. Special cases:
 474      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 475      * integer, then the result is the same as the argument.
 476      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 477      * zero, then the result is the same as the argument.&lt;/ul&gt;
 478      *
 479      * @param   a   a {@code double} value.
 480      * @return  the closest floating-point value to {@code a} that is
 481      *          equal to a mathematical integer.
 482      */
<span class="line-added"> 483     @HotSpotIntrinsicCandidate</span>
 484     public static double rint(double a) {
 485         return StrictMath.rint(a); // default impl. delegates to StrictMath
 486     }
 487 
 488     /**
 489      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 490      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 491      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 492      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 493      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 494      * cases:
 495      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 496      * &lt;li&gt;If the first argument is positive zero and the second argument
 497      * is positive, or the first argument is positive and finite and the
 498      * second argument is positive infinity, then the result is positive
 499      * zero.
 500      * &lt;li&gt;If the first argument is negative zero and the second argument
 501      * is positive, or the first argument is negative and finite and the
 502      * second argument is positive infinity, then the result is negative zero.
 503      * &lt;li&gt;If the first argument is positive zero and the second argument
</pre>
<hr />
<pre>
 938     @HotSpotIntrinsicCandidate
 939     public static long multiplyExact(long x, long y) {
 940         long r = x * y;
 941         long ax = Math.abs(x);
 942         long ay = Math.abs(y);
 943         if (((ax | ay) &gt;&gt;&gt; 31 != 0)) {
 944             // Some bits greater than 2^31 that might cause overflow
 945             // Check the result using the divide operator
 946             // and check for the special case of Long.MIN_VALUE * -1
 947            if (((y != 0) &amp;&amp; (r / y != x)) ||
 948                (x == Long.MIN_VALUE &amp;&amp; y == -1)) {
 949                 throw new ArithmeticException(&quot;long overflow&quot;);
 950             }
 951         }
 952         return r;
 953     }
 954 
 955     /**
 956      * Returns the argument incremented by one, throwing an exception if the
 957      * result overflows an {@code int}.
<span class="line-added"> 958      * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.</span>
 959      *
 960      * @param a the value to increment
 961      * @return the result
 962      * @throws ArithmeticException if the result overflows an int
 963      * @since 1.8
 964      */
 965     @HotSpotIntrinsicCandidate
 966     public static int incrementExact(int a) {
 967         if (a == Integer.MAX_VALUE) {
 968             throw new ArithmeticException(&quot;integer overflow&quot;);
 969         }
 970 
 971         return a + 1;
 972     }
 973 
 974     /**
 975      * Returns the argument incremented by one, throwing an exception if the
 976      * result overflows a {@code long}.
<span class="line-added"> 977      * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.</span>
 978      *
 979      * @param a the value to increment
 980      * @return the result
 981      * @throws ArithmeticException if the result overflows a long
 982      * @since 1.8
 983      */
 984     @HotSpotIntrinsicCandidate
 985     public static long incrementExact(long a) {
 986         if (a == Long.MAX_VALUE) {
 987             throw new ArithmeticException(&quot;long overflow&quot;);
 988         }
 989 
 990         return a + 1L;
 991     }
 992 
 993     /**
 994      * Returns the argument decremented by one, throwing an exception if the
 995      * result overflows an {@code int}.
<span class="line-added"> 996      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.</span>
 997      *
 998      * @param a the value to decrement
 999      * @return the result
1000      * @throws ArithmeticException if the result overflows an int
1001      * @since 1.8
1002      */
1003     @HotSpotIntrinsicCandidate
1004     public static int decrementExact(int a) {
1005         if (a == Integer.MIN_VALUE) {
1006             throw new ArithmeticException(&quot;integer overflow&quot;);
1007         }
1008 
1009         return a - 1;
1010     }
1011 
1012     /**
1013      * Returns the argument decremented by one, throwing an exception if the
1014      * result overflows a {@code long}.
<span class="line-added">1015      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.</span>
1016      *
1017      * @param a the value to decrement
1018      * @return the result
1019      * @throws ArithmeticException if the result overflows a long
1020      * @since 1.8
1021      */
1022     @HotSpotIntrinsicCandidate
1023     public static long decrementExact(long a) {
1024         if (a == Long.MIN_VALUE) {
1025             throw new ArithmeticException(&quot;long overflow&quot;);
1026         }
1027 
1028         return a - 1L;
1029     }
1030 
1031     /**
1032      * Returns the negation of the argument, throwing an exception if the
1033      * result overflows an {@code int}.
<span class="line-added">1034      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.</span>
1035      *
1036      * @param a the value to negate
1037      * @return the result
1038      * @throws ArithmeticException if the result overflows an int
1039      * @since 1.8
1040      */
1041     @HotSpotIntrinsicCandidate
1042     public static int negateExact(int a) {
1043         if (a == Integer.MIN_VALUE) {
1044             throw new ArithmeticException(&quot;integer overflow&quot;);
1045         }
1046 
1047         return -a;
1048     }
1049 
1050     /**
1051      * Returns the negation of the argument, throwing an exception if the
1052      * result overflows a {@code long}.
<span class="line-added">1053      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.</span>
1054      *
1055      * @param a the value to negate
1056      * @return the result
1057      * @throws ArithmeticException if the result overflows a long
1058      * @since 1.8
1059      */
1060     @HotSpotIntrinsicCandidate
1061     public static long negateExact(long a) {
1062         if (a == Long.MIN_VALUE) {
1063             throw new ArithmeticException(&quot;long overflow&quot;);
1064         }
1065 
1066         return -a;
1067     }
1068 
1069     /**
<span class="line-modified">1070      * Returns the value of the {@code long} argument,</span>
1071      * throwing an exception if the value overflows an {@code int}.
1072      *
1073      * @param value the long value
1074      * @return the argument as an int
1075      * @throws ArithmeticException if the {@code argument} overflows an int
1076      * @since 1.8
1077      */
1078     public static int toIntExact(long value) {
1079         if ((int)value != value) {
1080             throw new ArithmeticException(&quot;integer overflow&quot;);
1081         }
1082         return (int)value;
1083     }
1084 
1085     /**
1086      * Returns the exact mathematical product of the arguments.
1087      *
1088      * @param x the first value
1089      * @param y the second value
1090      * @return the result
</pre>
<hr />
<pre>
1242      * Returns the floor modulus of the {@code int} arguments.
1243      * &lt;p&gt;
1244      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1245      * has the same sign as the divisor {@code y}, and
1246      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1247      *
1248      * &lt;p&gt;
1249      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1250      * &lt;ul&gt;
1251      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1252      * &lt;/ul&gt;
1253      * &lt;p&gt;
1254      * The difference in values between {@code floorMod} and
1255      * the {@code %} operator is due to the difference between
1256      * {@code floorDiv} that returns the integer less than or equal to the quotient
1257      * and the {@code /} operator that returns the integer closest to zero.
1258      * &lt;p&gt;
1259      * Examples:
1260      * &lt;ul&gt;
1261      *   &lt;li&gt;If the signs of the arguments are the same, the results
<span class="line-modified">1262      *       of {@code floorMod} and the {@code %} operator are the same.&lt;br&gt;</span>
<span class="line-added">1263      *       &lt;ul&gt;</span>
<span class="line-added">1264      *       &lt;li&gt;{@code floorMod(+4, +3) == +1}; &amp;nbsp; and {@code (+4 % +3) == +1}&lt;/li&gt;</span>
<span class="line-added">1265      *       &lt;li&gt;{@code floorMod(-4, -3) == -1}; &amp;nbsp; and {@code (-4 % -3) == -1}&lt;/li&gt;</span>
<span class="line-added">1266      *       &lt;/ul&gt;</span>
<span class="line-added">1267      *   &lt;li&gt;If the signs of the arguments are different, the results</span>
<span class="line-added">1268      *       differ from the {@code %} operator.&lt;br&gt;</span>
1269      *       &lt;ul&gt;
<span class="line-modified">1270      *       &lt;li&gt;{@code floorMod(+4, -3) == -2}; &amp;nbsp; and {@code (+4 % -3) == +1}&lt;/li&gt;</span>
<span class="line-added">1271      *       &lt;li&gt;{@code floorMod(-4, +3) == +2}; &amp;nbsp; and {@code (-4 % +3) == -1}&lt;/li&gt;</span>
1272      *       &lt;/ul&gt;






1273      *   &lt;/li&gt;
1274      * &lt;/ul&gt;
1275      * &lt;p&gt;
1276      * If the signs of arguments are unknown and a positive modulus
1277      * is needed it can be computed as {@code (floorMod(x, y) + abs(y)) % abs(y)}.
1278      *
1279      * @param x the dividend
1280      * @param y the divisor
1281      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1282      * @throws ArithmeticException if the divisor {@code y} is zero
1283      * @see #floorDiv(int, int)
1284      * @since 1.8
1285      */
1286     public static int floorMod(int x, int y) {
<span class="line-modified">1287         int mod = x % y;</span>
<span class="line-added">1288         // if the signs are different and modulo not zero, adjust result</span>
<span class="line-added">1289         if ((mod ^ y) &lt; 0 &amp;&amp; mod != 0) {</span>
<span class="line-added">1290             mod += y;</span>
<span class="line-added">1291         }</span>
<span class="line-added">1292         return mod;</span>
1293     }
1294 
1295     /**
1296      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1297      * &lt;p&gt;
1298      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1299      * has the same sign as the divisor {@code y}, and
1300      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1301      *
1302      * &lt;p&gt;
1303      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1304      * &lt;ul&gt;
1305      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1306      * &lt;/ul&gt;
1307      * &lt;p&gt;
1308      * For examples, see {@link #floorMod(int, int)}.
1309      *
1310      * @param x the dividend
1311      * @param y the divisor
1312      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1313      * @throws ArithmeticException if the divisor {@code y} is zero
1314      * @see #floorDiv(long, int)
1315      * @since 9
1316      */
1317     public static int floorMod(long x, int y) {
1318         // Result cannot overflow the range of int.
<span class="line-modified">1319         return (int)floorMod(x, (long)y);</span>
1320     }
1321 
1322     /**
1323      * Returns the floor modulus of the {@code long} arguments.
1324      * &lt;p&gt;
1325      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1326      * has the same sign as the divisor {@code y}, and
1327      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1328      *
1329      * &lt;p&gt;
1330      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1331      * &lt;ul&gt;
1332      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1333      * &lt;/ul&gt;
1334      * &lt;p&gt;
1335      * For examples, see {@link #floorMod(int, int)}.
1336      *
1337      * @param x the dividend
1338      * @param y the divisor
1339      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1340      * @throws ArithmeticException if the divisor {@code y} is zero
1341      * @see #floorDiv(long, long)
1342      * @since 1.8
1343      */
1344     public static long floorMod(long x, long y) {
<span class="line-modified">1345         long mod = x % y;</span>
<span class="line-added">1346         // if the signs are different and modulo not zero, adjust result</span>
<span class="line-added">1347         if ((x ^ y) &lt; 0 &amp;&amp; mod != 0) {</span>
<span class="line-added">1348             mod += y;</span>
<span class="line-added">1349         }</span>
<span class="line-added">1350         return mod;</span>
1351     }
1352 
1353     /**
1354      * Returns the absolute value of an {@code int} value.
1355      * If the argument is not negative, the argument is returned.
1356      * If the argument is negative, the negation of the argument is returned.
1357      *
1358      * &lt;p&gt;Note that if the argument is equal to the value of
1359      * {@link Integer#MIN_VALUE}, the most negative representable
1360      * {@code int} value, the result is that same value, which is
1361      * negative.
1362      *
1363      * @param   a   the argument whose absolute value is to be determined
1364      * @return  the absolute value of the argument.
1365      */
<span class="line-added">1366     @HotSpotIntrinsicCandidate</span>
1367     public static int abs(int a) {
1368         return (a &lt; 0) ? -a : a;
1369     }
1370 
1371     /**
1372      * Returns the absolute value of a {@code long} value.
1373      * If the argument is not negative, the argument is returned.
1374      * If the argument is negative, the negation of the argument is returned.
1375      *
1376      * &lt;p&gt;Note that if the argument is equal to the value of
1377      * {@link Long#MIN_VALUE}, the most negative representable
1378      * {@code long} value, the result is that same value, which
1379      * is negative.
1380      *
1381      * @param   a   the argument whose absolute value is to be determined
1382      * @return  the absolute value of the argument.
1383      */
<span class="line-added">1384     @HotSpotIntrinsicCandidate</span>
1385     public static long abs(long a) {
1386         return (a &lt; 0) ? -a : a;
1387     }
1388 
1389     /**
1390      * Returns the absolute value of a {@code float} value.
1391      * If the argument is not negative, the argument is returned.
1392      * If the argument is negative, the negation of the argument is returned.
1393      * Special cases:
1394      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1395      * result is positive zero.
1396      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1397      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1398      *
1399      * @apiNote As implied by the above, one valid implementation of
1400      * this method is given by the expression below which computes a
1401      * {@code float} with the same exponent and significand as the
1402      * argument but with a guaranteed zero sign bit indicating a
1403      * positive value:&lt;br&gt;
1404      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1405      *
1406      * @param   a   the argument whose absolute value is to be determined
1407      * @return  the absolute value of the argument.
1408      */
<span class="line-added">1409     @HotSpotIntrinsicCandidate</span>
1410     public static float abs(float a) {
1411         return (a &lt;= 0.0F) ? 0.0F - a : a;
1412     }
1413 
1414     /**
1415      * Returns the absolute value of a {@code double} value.
1416      * If the argument is not negative, the argument is returned.
1417      * If the argument is negative, the negation of the argument is returned.
1418      * Special cases:
1419      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1420      * is positive zero.
1421      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1422      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1423      *
1424      * @apiNote As implied by the above, one valid implementation of
1425      * this method is given by the expression below which computes a
1426      * {@code double} with the same exponent and significand as the
1427      * argument but with a guaranteed zero sign bit indicating a
1428      * positive value:&lt;br&gt;
1429      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
</pre>
</td>
</tr>
</table>
<center><a href="Long.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Module.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InfoFromMemberName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.org.objectweb.asm.*;
 29 import sun.invoke.util.BytecodeDescriptor;
 30 import jdk.internal.misc.Unsafe;
 31 import sun.security.action.GetPropertyAction;

 32 
 33 import java.io.FilePermission;
 34 import java.io.Serializable;
 35 import java.lang.reflect.Constructor;
 36 import java.security.AccessController;
 37 import java.security.PrivilegedAction;
 38 import java.util.LinkedHashSet;
 39 import java.util.concurrent.atomic.AtomicInteger;
 40 import java.util.PropertyPermission;
 41 import java.util.Set;
 42 
 43 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 44 
 45 /**
 46  * Lambda metafactory implementation which dynamically creates an
 47  * inner-class-like class per lambda callsite.
 48  *
 49  * @see LambdaMetafactory
 50  */
 51 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
</pre>
<hr />
<pre>
 70     private static final String DESCR_CLASS = &quot;Ljava/lang/Class;&quot;;
 71     private static final String DESCR_STRING = &quot;Ljava/lang/String;&quot;;
 72     private static final String DESCR_OBJECT = &quot;Ljava/lang/Object;&quot;;
 73     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
 74             = &quot;(&quot; + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;I&quot;
 75             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;[&quot; + DESCR_OBJECT + &quot;)V&quot;;
 76 
 77     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = &quot;(Ljava/lang/String;)V&quot;;
 78     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 79 
 80     private static final String DESCR_HIDDEN = &quot;Ljdk/internal/vm/annotation/Hidden;&quot;;
 81 
 82     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 83 
 84     // Used to ensure that each spun class name is unique
 85     private static final AtomicInteger counter = new AtomicInteger(0);
 86 
 87     // For dumping generated classes to disk, for debugging purposes
 88     private static final ProxyClassesDumper dumper;
 89 


 90     static {
<span class="line-modified"> 91         final String key = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;</span>
<span class="line-modified"> 92         String path = GetPropertyAction.privilegedGetProperty(key);</span>
<span class="line-modified"> 93         dumper = (null == path) ? null : ProxyClassesDumper.getInstance(path);</span>



 94     }
 95 
 96     // See context values in AbstractValidatingLambdaMetafactory
 97     private final String implMethodClassName;        // Name of type containing implementation &quot;CC&quot;
 98     private final String implMethodName;             // Name of implementation method &quot;impl&quot;
 99     private final String implMethodDesc;             // Type descriptor for implementation methods &quot;(I)Ljava/lang/String;&quot;
100     private final MethodType constructorType;        // Generated class constructor type &quot;(CC)void&quot;
101     private final ClassWriter cw;                    // ASM class writer
102     private final String[] argNames;                 // Generated names for the constructor arguments
103     private final String[] argDescs;                 // Type descriptors for the constructor arguments
104     private final String lambdaClassName;            // Generated name for the generated class &quot;X$$Lambda$1&quot;
105 
106     /**
107      * General meta-factory constructor, supporting both standard cases and
108      * allowing for uncommon options such as serialization or bridging.
109      *
110      * @param caller Stacked automatically by VM; represents a lookup context
111      *               with the accessibility privileges of the caller.
112      * @param invokedType Stacked automatically by VM; the signature of the
113      *                    invoked method, which includes the expected static
</pre>
<hr />
<pre>
170         } else {
171             argNames = argDescs = EMPTY_STRING_ARRAY;
172         }
173     }
174 
175     /**
176      * Build the CallSite. Generate a class file which implements the functional
177      * interface, define the class, if there are no parameters create an instance
178      * of the class which the CallSite will return, otherwise, generate handles
179      * which will call the class&#39; constructor.
180      *
181      * @return a CallSite, which, when invoked, will return an instance of the
182      * functional interface
183      * @throws ReflectiveOperationException
184      * @throws LambdaConversionException If properly formed functional interface
185      * is not found
186      */
187     @Override
188     CallSite buildCallSite() throws LambdaConversionException {
189         final Class&lt;?&gt; innerClass = spinInnerClass();
<span class="line-modified">190         if (invokedType.parameterCount() == 0) {</span>


191             final Constructor&lt;?&gt;[] ctrs = AccessController.doPrivileged(
192                     new PrivilegedAction&lt;&gt;() {
193                 @Override
194                 public Constructor&lt;?&gt;[] run() {
195                     Constructor&lt;?&gt;[] ctrs = innerClass.getDeclaredConstructors();
196                     if (ctrs.length == 1) {
197                         // The lambda implementing inner class constructor is private, set
198                         // it accessible (by us) before creating the constant sole instance
199                         ctrs[0].setAccessible(true);
200                     }
201                     return ctrs;
202                 }
203                     });
204             if (ctrs.length != 1) {
205                 throw new LambdaConversionException(&quot;Expected one lambda constructor for &quot;
206                         + innerClass.getCanonicalName() + &quot;, got &quot; + ctrs.length);
207             }
208 
209             try {
210                 Object inst = ctrs[0].newInstance();
211                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
212             }
213             catch (ReflectiveOperationException e) {
214                 throw new LambdaConversionException(&quot;Exception instantiating lambda object&quot;, e);
215             }
216         } else {
217             try {
<span class="line-modified">218                 UNSAFE.ensureClassInitialized(innerClass);</span>


219                 return new ConstantCallSite(
220                         MethodHandles.Lookup.IMPL_LOOKUP
221                              .findStatic(innerClass, NAME_FACTORY, invokedType));
222             }
223             catch (ReflectiveOperationException e) {
224                 throw new LambdaConversionException(&quot;Exception finding constructor&quot;, e);
225             }
226         }
227     }
228 
229     /**
230      * Generate a class file which implements the functional
231      * interface, define and return the class.
232      *
233      * @implNote The class that is generated does not include signature
234      * information for exceptions that may be present on the SAM method.
235      * This is to reduce classfile size, and is harmless as checked exceptions
236      * are erased anyway, no one will ever compile against this classfile,
237      * and we make no guarantees about the reflective properties of lambda
238      * objects.
</pre>
<hr />
<pre>
256                 accidentallySerializable |= !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(markerInterface);
257             }
258             interfaces = itfs.toArray(new String[itfs.size()]);
259         }
260 
261         cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
262                  lambdaClassName, null,
263                  JAVA_LANG_OBJECT, interfaces);
264 
265         // Generate final fields to be filled in by constructor
266         for (int i = 0; i &lt; argDescs.length; i++) {
267             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,
268                                             argNames[i],
269                                             argDescs[i],
270                                             null, null);
271             fv.visitEnd();
272         }
273 
274         generateConstructor();
275 
<span class="line-modified">276         if (invokedType.parameterCount() != 0) {</span>
277             generateFactory();
278         }
279 
280         // Forward the SAM method
281         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
282                                           samMethodType.toMethodDescriptorString(), null, null);
283         mv.visitAnnotation(DESCR_HIDDEN, true);
284         new ForwardingMethodGenerator(mv).generate(samMethodType);
285 
286         // Forward the bridges
287         if (additionalBridges != null) {
288             for (MethodType mt : additionalBridges) {
289                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
290                                     mt.toMethodDescriptorString(), null, null);
291                 mv.visitAnnotation(DESCR_HIDDEN, true);
292                 new ForwardingMethodGenerator(mv).generate(mt);
293             }
294         }
295 
296         if (isSerializable)
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.org.objectweb.asm.*;
 29 import sun.invoke.util.BytecodeDescriptor;
 30 import jdk.internal.misc.Unsafe;
 31 import sun.security.action.GetPropertyAction;
<span class="line-added"> 32 import sun.security.action.GetBooleanAction;</span>
 33 
 34 import java.io.FilePermission;
 35 import java.io.Serializable;
 36 import java.lang.reflect.Constructor;
 37 import java.security.AccessController;
 38 import java.security.PrivilegedAction;
 39 import java.util.LinkedHashSet;
 40 import java.util.concurrent.atomic.AtomicInteger;
 41 import java.util.PropertyPermission;
 42 import java.util.Set;
 43 
 44 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 45 
 46 /**
 47  * Lambda metafactory implementation which dynamically creates an
 48  * inner-class-like class per lambda callsite.
 49  *
 50  * @see LambdaMetafactory
 51  */
 52 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
</pre>
<hr />
<pre>
 71     private static final String DESCR_CLASS = &quot;Ljava/lang/Class;&quot;;
 72     private static final String DESCR_STRING = &quot;Ljava/lang/String;&quot;;
 73     private static final String DESCR_OBJECT = &quot;Ljava/lang/Object;&quot;;
 74     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
 75             = &quot;(&quot; + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;I&quot;
 76             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;[&quot; + DESCR_OBJECT + &quot;)V&quot;;
 77 
 78     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = &quot;(Ljava/lang/String;)V&quot;;
 79     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 80 
 81     private static final String DESCR_HIDDEN = &quot;Ljdk/internal/vm/annotation/Hidden;&quot;;
 82 
 83     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 84 
 85     // Used to ensure that each spun class name is unique
 86     private static final AtomicInteger counter = new AtomicInteger(0);
 87 
 88     // For dumping generated classes to disk, for debugging purposes
 89     private static final ProxyClassesDumper dumper;
 90 
<span class="line-added"> 91     private static final boolean disableEagerInitialization;</span>
<span class="line-added"> 92 </span>
 93     static {
<span class="line-modified"> 94         final String dumpProxyClassesKey = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;</span>
<span class="line-modified"> 95         String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);</span>
<span class="line-modified"> 96         dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98         final String disableEagerInitializationKey = &quot;jdk.internal.lambda.disableEagerInitialization&quot;;</span>
<span class="line-added"> 99         disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);</span>
100     }
101 
102     // See context values in AbstractValidatingLambdaMetafactory
103     private final String implMethodClassName;        // Name of type containing implementation &quot;CC&quot;
104     private final String implMethodName;             // Name of implementation method &quot;impl&quot;
105     private final String implMethodDesc;             // Type descriptor for implementation methods &quot;(I)Ljava/lang/String;&quot;
106     private final MethodType constructorType;        // Generated class constructor type &quot;(CC)void&quot;
107     private final ClassWriter cw;                    // ASM class writer
108     private final String[] argNames;                 // Generated names for the constructor arguments
109     private final String[] argDescs;                 // Type descriptors for the constructor arguments
110     private final String lambdaClassName;            // Generated name for the generated class &quot;X$$Lambda$1&quot;
111 
112     /**
113      * General meta-factory constructor, supporting both standard cases and
114      * allowing for uncommon options such as serialization or bridging.
115      *
116      * @param caller Stacked automatically by VM; represents a lookup context
117      *               with the accessibility privileges of the caller.
118      * @param invokedType Stacked automatically by VM; the signature of the
119      *                    invoked method, which includes the expected static
</pre>
<hr />
<pre>
176         } else {
177             argNames = argDescs = EMPTY_STRING_ARRAY;
178         }
179     }
180 
181     /**
182      * Build the CallSite. Generate a class file which implements the functional
183      * interface, define the class, if there are no parameters create an instance
184      * of the class which the CallSite will return, otherwise, generate handles
185      * which will call the class&#39; constructor.
186      *
187      * @return a CallSite, which, when invoked, will return an instance of the
188      * functional interface
189      * @throws ReflectiveOperationException
190      * @throws LambdaConversionException If properly formed functional interface
191      * is not found
192      */
193     @Override
194     CallSite buildCallSite() throws LambdaConversionException {
195         final Class&lt;?&gt; innerClass = spinInnerClass();
<span class="line-modified">196         if (invokedType.parameterCount() == 0 &amp;&amp; !disableEagerInitialization) {</span>
<span class="line-added">197             // In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,</span>
<span class="line-added">198             // unless we&#39;ve suppressed eager initialization</span>
199             final Constructor&lt;?&gt;[] ctrs = AccessController.doPrivileged(
200                     new PrivilegedAction&lt;&gt;() {
201                 @Override
202                 public Constructor&lt;?&gt;[] run() {
203                     Constructor&lt;?&gt;[] ctrs = innerClass.getDeclaredConstructors();
204                     if (ctrs.length == 1) {
205                         // The lambda implementing inner class constructor is private, set
206                         // it accessible (by us) before creating the constant sole instance
207                         ctrs[0].setAccessible(true);
208                     }
209                     return ctrs;
210                 }
211                     });
212             if (ctrs.length != 1) {
213                 throw new LambdaConversionException(&quot;Expected one lambda constructor for &quot;
214                         + innerClass.getCanonicalName() + &quot;, got &quot; + ctrs.length);
215             }
216 
217             try {
218                 Object inst = ctrs[0].newInstance();
219                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
220             }
221             catch (ReflectiveOperationException e) {
222                 throw new LambdaConversionException(&quot;Exception instantiating lambda object&quot;, e);
223             }
224         } else {
225             try {
<span class="line-modified">226                 if (!disableEagerInitialization) {</span>
<span class="line-added">227                     UNSAFE.ensureClassInitialized(innerClass);</span>
<span class="line-added">228                 }</span>
229                 return new ConstantCallSite(
230                         MethodHandles.Lookup.IMPL_LOOKUP
231                              .findStatic(innerClass, NAME_FACTORY, invokedType));
232             }
233             catch (ReflectiveOperationException e) {
234                 throw new LambdaConversionException(&quot;Exception finding constructor&quot;, e);
235             }
236         }
237     }
238 
239     /**
240      * Generate a class file which implements the functional
241      * interface, define and return the class.
242      *
243      * @implNote The class that is generated does not include signature
244      * information for exceptions that may be present on the SAM method.
245      * This is to reduce classfile size, and is harmless as checked exceptions
246      * are erased anyway, no one will ever compile against this classfile,
247      * and we make no guarantees about the reflective properties of lambda
248      * objects.
</pre>
<hr />
<pre>
266                 accidentallySerializable |= !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(markerInterface);
267             }
268             interfaces = itfs.toArray(new String[itfs.size()]);
269         }
270 
271         cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
272                  lambdaClassName, null,
273                  JAVA_LANG_OBJECT, interfaces);
274 
275         // Generate final fields to be filled in by constructor
276         for (int i = 0; i &lt; argDescs.length; i++) {
277             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,
278                                             argNames[i],
279                                             argDescs[i],
280                                             null, null);
281             fv.visitEnd();
282         }
283 
284         generateConstructor();
285 
<span class="line-modified">286         if (invokedType.parameterCount() != 0 || disableEagerInitialization) {</span>
287             generateFactory();
288         }
289 
290         // Forward the SAM method
291         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
292                                           samMethodType.toMethodDescriptorString(), null, null);
293         mv.visitAnnotation(DESCR_HIDDEN, true);
294         new ForwardingMethodGenerator(mv).generate(samMethodType);
295 
296         // Forward the bridges
297         if (additionalBridges != null) {
298             for (MethodType mt : additionalBridges) {
299                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
300                                     mt.toMethodDescriptorString(), null, null);
301                 mv.visitAnnotation(DESCR_HIDDEN, true);
302                 new ForwardingMethodGenerator(mv).generate(mt);
303             }
304         }
305 
306         if (isSerializable)
</pre>
</td>
</tr>
</table>
<center><a href="InfoFromMemberName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
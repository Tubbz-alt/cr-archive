<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/FilterInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FilenameFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FilterOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/FilterInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,125 ***</span>
   */
  
  package java.io;
  
  /**
<span class="line-modified">!  * A &lt;code&gt;FilterInputStream&lt;/code&gt; contains</span>
   * some other input stream, which it uses as
   * its  basic source of data, possibly transforming
   * the data along the way or providing  additional
<span class="line-modified">!  * functionality. The class &lt;code&gt;FilterInputStream&lt;/code&gt;</span>
   * itself simply overrides all  methods of
<span class="line-modified">!  * &lt;code&gt;InputStream&lt;/code&gt; with versions that</span>
   * pass all requests to the contained  input
<span class="line-modified">!  * stream. Subclasses of &lt;code&gt;FilterInputStream&lt;/code&gt;</span>
   * may further override some of  these methods
   * and may also provide additional methods
   * and fields.
   *
   * @author  Jonathan Payne
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class FilterInputStream extends InputStream {</span>
      /**
       * The input stream to be filtered.
       */
      protected volatile InputStream in;
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt;</span>
<span class="line-modified">!      * by assigning the  argument &lt;code&gt;in&lt;/code&gt;</span>
<span class="line-modified">!      * to the field &lt;code&gt;this.in&lt;/code&gt; so as</span>
       * to remember it for later use.
       *
<span class="line-modified">!      * @param   in   the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if</span>
       *          this instance is to be created without an underlying stream.
       */
      protected FilterInputStream(InputStream in) {
          this.in = in;
      }
  
      /**
       * Reads the next byte of data from this input stream. The value
<span class="line-modified">!      * byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range</span>
<span class="line-modified">!      * &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available</span>
       * because the end of the stream has been reached, the value
<span class="line-modified">!      * &lt;code&gt;-1&lt;/code&gt; is returned. This method blocks until input data</span>
       * is available, the end of the stream is detected, or an exception
       * is thrown.
       * &lt;p&gt;
       * This method
<span class="line-modified">!      * simply performs &lt;code&gt;in.read()&lt;/code&gt; and returns the result.</span>
       *
<span class="line-modified">!      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int read() throws IOException {
          return in.read();
      }
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;b.length&lt;/code&gt; bytes of data from this</span>
       * input stream into an array of bytes. This method blocks until some
       * input is available.
       * &lt;p&gt;
       * This method simply performs the call
<span class="line-modified">!      * &lt;code&gt;read(b, 0, b.length)&lt;/code&gt; and returns</span>
       * the  result. It is important that it does
<span class="line-modified">!      * &lt;i&gt;not&lt;/i&gt; do &lt;code&gt;in.read(b)&lt;/code&gt; instead;</span>
<span class="line-modified">!      * certain subclasses of  &lt;code&gt;FilterInputStream&lt;/code&gt;</span>
       * depend on the implementation strategy actually
       * used.
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#read(byte[], int, int)
       */
      public int read(byte b[]) throws IOException {
          return read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream</span>
<span class="line-modified">!      * into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not zero, the method</span>
       * blocks until some input is available; otherwise, no
<span class="line-modified">!      * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs &lt;code&gt;in.read(b, off, len)&lt;/code&gt;</span>
       * and returns the result.
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int read(byte b[], int off, int len) throws IOException {
          return in.read(b, off, len);
      }
  
      /**
<span class="line-modified">!      * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from the</span>
<span class="line-modified">!      * input stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of</span>
       * reasons, end up skipping over some smaller number of bytes,
<span class="line-modified">!      * possibly &lt;code&gt;0&lt;/code&gt;. The actual number of bytes skipped is</span>
       * returned.
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs &lt;code&gt;in.skip(n)&lt;/code&gt;.</span>
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
       * @throws     IOException  if {@code in.skip(n)} throws an IOException.
       */
<span class="line-new-header">--- 24,124 ---</span>
   */
  
  package java.io;
  
  /**
<span class="line-modified">!  * A {@code FilterInputStream} contains</span>
   * some other input stream, which it uses as
   * its  basic source of data, possibly transforming
   * the data along the way or providing  additional
<span class="line-modified">!  * functionality. The class {@code FilterInputStream}</span>
   * itself simply overrides all  methods of
<span class="line-modified">!  * {@code InputStream} with versions that</span>
   * pass all requests to the contained  input
<span class="line-modified">!  * stream. Subclasses of {@code FilterInputStream}</span>
   * may further override some of  these methods
   * and may also provide additional methods
   * and fields.
   *
   * @author  Jonathan Payne
   * @since   1.0
   */
<span class="line-modified">! public class FilterInputStream extends InputStream {</span>
      /**
       * The input stream to be filtered.
       */
      protected volatile InputStream in;
  
      /**
<span class="line-modified">!      * Creates a {@code FilterInputStream}</span>
<span class="line-modified">!      * by assigning the  argument {@code in}</span>
<span class="line-modified">!      * to the field {@code this.in} so as</span>
       * to remember it for later use.
       *
<span class="line-modified">!      * @param   in   the underlying input stream, or {@code null} if</span>
       *          this instance is to be created without an underlying stream.
       */
      protected FilterInputStream(InputStream in) {
          this.in = in;
      }
  
      /**
       * Reads the next byte of data from this input stream. The value
<span class="line-modified">!      * byte is returned as an {@code int} in the range</span>
<span class="line-modified">!      * {@code 0} to {@code 255}. If no byte is available</span>
       * because the end of the stream has been reached, the value
<span class="line-modified">!      * {@code -1} is returned. This method blocks until input data</span>
       * is available, the end of the stream is detected, or an exception
       * is thrown.
       * &lt;p&gt;
       * This method
<span class="line-modified">!      * simply performs {@code in.read()} and returns the result.</span>
       *
<span class="line-modified">!      * @return     the next byte of data, or {@code -1} if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int read() throws IOException {
          return in.read();
      }
  
      /**
<span class="line-modified">!      * Reads up to {@code b.length} bytes of data from this</span>
       * input stream into an array of bytes. This method blocks until some
       * input is available.
       * &lt;p&gt;
       * This method simply performs the call
<span class="line-modified">!      * {@code read(b, 0, b.length)} and returns</span>
       * the  result. It is important that it does
<span class="line-modified">!      * &lt;i&gt;not&lt;/i&gt; do {@code in.read(b)} instead;</span>
<span class="line-modified">!      * certain subclasses of  {@code FilterInputStream}</span>
       * depend on the implementation strategy actually
       * used.
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#read(byte[], int, int)
       */
      public int read(byte b[]) throws IOException {
          return read(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to {@code len} bytes of data from this input stream</span>
<span class="line-modified">!      * into an array of bytes. If {@code len} is not zero, the method</span>
       * blocks until some input is available; otherwise, no
<span class="line-modified">!      * bytes are read and {@code 0} is returned.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs {@code in.read(b, off, len)}</span>
       * and returns the result.
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in the destination array {@code b}</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      *             {@code b.length - off}</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public int read(byte b[], int off, int len) throws IOException {
          return in.read(b, off, len);
      }
  
      /**
<span class="line-modified">!      * Skips over and discards {@code n} bytes of data from the</span>
<span class="line-modified">!      * input stream. The {@code skip} method may, for a variety of</span>
       * reasons, end up skipping over some smaller number of bytes,
<span class="line-modified">!      * possibly {@code 0}. The actual number of bytes skipped is</span>
       * returned.
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs {@code in.skip(n)}.</span>
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
       * @throws     IOException  if {@code in.skip(n)} throws an IOException.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,39 ***</span>
       * &lt;p&gt;
       * This method returns the result of {@link #in in}.available().
       *
       * @return     an estimate of the number of bytes that can be read (or skipped
       *             over) from this input stream without blocking.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public int available() throws IOException {
          return in.available();
      }
  
      /**
       * Closes this input stream and releases any system resources
       * associated with the stream.
       * This
<span class="line-modified">!      * method simply performs &lt;code&gt;in.close()&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public void close() throws IOException {
          in.close();
      }
  
      /**
       * Marks the current position in this input stream. A subsequent
<span class="line-modified">!      * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span>
       * the last marked position so that subsequent reads re-read the same bytes.
       * &lt;p&gt;
<span class="line-modified">!      * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span>
       * allow that many bytes to be read before the mark position gets
       * invalidated.
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span>
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.FilterInputStream#in
       * @see     java.io.FilterInputStream#reset()
<span class="line-new-header">--- 158,39 ---</span>
       * &lt;p&gt;
       * This method returns the result of {@link #in in}.available().
       *
       * @return     an estimate of the number of bytes that can be read (or skipped
       *             over) from this input stream without blocking.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public int available() throws IOException {
          return in.available();
      }
  
      /**
       * Closes this input stream and releases any system resources
       * associated with the stream.
       * This
<span class="line-modified">!      * method simply performs {@code in.close()}.</span>
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FilterInputStream#in
       */
      public void close() throws IOException {
          in.close();
      }
  
      /**
       * Marks the current position in this input stream. A subsequent
<span class="line-modified">!      * call to the {@code reset} method repositions this stream at</span>
       * the last marked position so that subsequent reads re-read the same bytes.
       * &lt;p&gt;
<span class="line-modified">!      * The {@code readlimit} argument tells this input stream to</span>
       * allow that many bytes to be read before the mark position gets
       * invalidated.
       * &lt;p&gt;
<span class="line-modified">!      * This method simply performs {@code in.mark(readlimit)}.</span>
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.FilterInputStream#in
       * @see     java.io.FilterInputStream#reset()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,42 ***</span>
          in.mark(readlimit);
      }
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.</span>
       * &lt;p&gt;
       * This method
<span class="line-modified">!      * simply performs &lt;code&gt;in.reset()&lt;/code&gt;.</span>
       * &lt;p&gt;
       * Stream marks are intended to be used in
       * situations where you need to read ahead a little to see what&#39;s in
       * the stream. Often this is most easily done by invoking some
       * general parser. If the stream is of the type handled by the
       * parse, it just chugs along happily. If the stream is not of
       * that type, the parser should toss an exception when it fails.
       * If this happens within readlimit bytes, it allows the outer
       * code to reset the stream and try another parser.
       *
<span class="line-modified">!      * @exception  IOException  if the stream has not been marked or if the</span>
       *               mark has been invalidated.
       * @see        java.io.FilterInputStream#in
       * @see        java.io.FilterInputStream#mark(int)
       */
      public synchronized void reset() throws IOException {
          in.reset();
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt;</span>
<span class="line-modified">!      * and &lt;code&gt;reset&lt;/code&gt; methods.</span>
       * This method
<span class="line-modified">!      * simply performs &lt;code&gt;in.markSupported()&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @return  &lt;code&gt;true&lt;/code&gt; if this stream type supports the</span>
<span class="line-modified">!      *          &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; method;</span>
<span class="line-modified">!      *          &lt;code&gt;false&lt;/code&gt; otherwise.</span>
       * @see     java.io.FilterInputStream#in
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
<span class="line-new-header">--- 199,42 ---</span>
          in.mark(readlimit);
      }
  
      /**
       * Repositions this stream to the position at the time the
<span class="line-modified">!      * {@code mark} method was last called on this input stream.</span>
       * &lt;p&gt;
       * This method
<span class="line-modified">!      * simply performs {@code in.reset()}.</span>
       * &lt;p&gt;
       * Stream marks are intended to be used in
       * situations where you need to read ahead a little to see what&#39;s in
       * the stream. Often this is most easily done by invoking some
       * general parser. If the stream is of the type handled by the
       * parse, it just chugs along happily. If the stream is not of
       * that type, the parser should toss an exception when it fails.
       * If this happens within readlimit bytes, it allows the outer
       * code to reset the stream and try another parser.
       *
<span class="line-modified">!      * @throws     IOException  if the stream has not been marked or if the</span>
       *               mark has been invalidated.
       * @see        java.io.FilterInputStream#in
       * @see        java.io.FilterInputStream#mark(int)
       */
      public synchronized void reset() throws IOException {
          in.reset();
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the {@code mark}</span>
<span class="line-modified">!      * and {@code reset} methods.</span>
       * This method
<span class="line-modified">!      * simply performs {@code in.markSupported()}.</span>
       *
<span class="line-modified">!      * @return  {@code true} if this stream type supports the</span>
<span class="line-modified">!      *          {@code mark} and {@code reset} method;</span>
<span class="line-modified">!      *          {@code false} otherwise.</span>
       * @see     java.io.FilterInputStream#in
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
</pre>
<center><a href="FilenameFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FilterOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
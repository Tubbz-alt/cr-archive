<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/MessageFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MergeCollation.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Normalizer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/MessageFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,31 ***</span>
  import java.util.List;
  import java.util.Locale;
  
  
  /**
<span class="line-modified">!  * &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated</span>
   * messages in a language-neutral way. Use this to construct messages
   * displayed for end users.
   *
   * &lt;p&gt;
<span class="line-modified">!  * &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then</span>
   * inserts the formatted strings into the pattern at the appropriate places.
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">!  * &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified">!  * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one</span>
<span class="line-modified">!  * of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory</span>
<span class="line-modified">!  * method). The factory methods aren&#39;t necessary because &lt;code&gt;MessageFormat&lt;/code&gt;</span>
   * itself doesn&#39;t implement locale specific behavior. Any locale specific
   * behavior is defined by the pattern that you provide as well as the
   * subformats used for inserted arguments.
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;</span>
   *
<span class="line-modified">!  * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
   *         &lt;i&gt;String&lt;/i&gt;
   *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
   *
<span class="line-new-header">--- 48,31 ---</span>
  import java.util.List;
  import java.util.Locale;
  
  
  /**
<span class="line-modified">!  * {@code MessageFormat} provides a means to produce concatenated</span>
   * messages in a language-neutral way. Use this to construct messages
   * displayed for end users.
   *
   * &lt;p&gt;
<span class="line-modified">!  * {@code MessageFormat} takes a set of objects, formats them, then</span>
   * inserts the formatted strings into the pattern at the appropriate places.
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">!  * {@code MessageFormat} differs from the other {@code Format}</span>
<span class="line-modified">!  * classes in that you create a {@code MessageFormat} object with one</span>
<span class="line-modified">!  * of its constructors (not with a {@code getInstance} style factory</span>
<span class="line-modified">!  * method). The factory methods aren&#39;t necessary because {@code MessageFormat}</span>
   * itself doesn&#39;t implement locale specific behavior. Any locale specific
   * behavior is defined by the pattern that you provide as well as the
   * subformats used for inserted arguments.
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h2&gt;</span>
   *
<span class="line-modified">!  * {@code MessageFormat} uses patterns of the following form:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
   *         &lt;i&gt;String&lt;/i&gt;
   *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
   * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
   * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
   * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
   * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
   * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
<span class="line-modified">!  * left curly brace), &lt;code&gt;&#39;&#39;&lt;/code&gt; (a single quote), and</span>
   * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
   * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
   * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
   * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
   *
<span class="line-new-header">--- 100,11 ---</span>
   * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
   * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
   * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
   * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
   * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
<span class="line-modified">!  * left curly brace), {@code &#39;&#39;} (a single quote), and</span>
   * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
   * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
   * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
   * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,20 ***</span>
   *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
   *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
   * &lt;/tbody&gt;
   * &lt;/table&gt;
   *
<span class="line-modified">!  * &lt;h4&gt;Usage Information&lt;/h4&gt;</span>
   *
   * &lt;p&gt;
   * Here are some examples of usage.
   * In real internationalized programs, the message format pattern and other
   * static strings will, of course, be obtained from resource bundles.
   * Other parameters will be dynamically determined at runtime.
   * &lt;p&gt;
<span class="line-modified">!  * The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,</span>
<span class="line-modified">!  * which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * int planet = 7;
   * String event = &quot;a disturbance in the Force&quot;;
   *
   * String result = MessageFormat.format(
<span class="line-new-header">--- 218,20 ---</span>
   *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
   *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
   * &lt;/tbody&gt;
   * &lt;/table&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;Usage Information&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Here are some examples of usage.
   * In real internationalized programs, the message format pattern and other
   * static strings will, of course, be obtained from resource bundles.
   * Other parameters will be dynamically determined at runtime.
   * &lt;p&gt;
<span class="line-modified">!  * The first example uses the static method {@code MessageFormat.format},</span>
<span class="line-modified">!  * which internally creates a {@code MessageFormat} for one-time use:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * int planet = 7;
   * String event = &quot;a disturbance in the Force&quot;;
   *
   * String result = MessageFormat.format(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,11 ***</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that</span>
   * can be used repeatedly:
   * &lt;blockquote&gt;&lt;pre&gt;
   * int fileCount = 1273;
   * String diskName = &quot;MyDisk&quot;;
   * Object[] testArgs = {new Long(fileCount), diskName};
<span class="line-new-header">--- 242,11 ---</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * The following example creates a {@code MessageFormat} instance that</span>
   * can be used repeatedly:
   * &lt;blockquote&gt;&lt;pre&gt;
   * int fileCount = 1273;
   * String diskName = &quot;MyDisk&quot;;
   * Object[] testArgs = {new Long(fileCount), diskName};
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,19 ***</span>
   * MessageFormat form = new MessageFormat(
   *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
   *
   * System.out.println(form.format(testArgs));
   * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified">!  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * The disk &quot;MyDisk&quot; contains 0 file(s).
   * The disk &quot;MyDisk&quot; contains 1 file(s).
   * The disk &quot;MyDisk&quot; contains 1,273 file(s).
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
   * to produce correct forms for singular and plural:
   * &lt;blockquote&gt;&lt;pre&gt;
   * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
   * double[] filelimits = {0,1,2};
   * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
<span class="line-new-header">--- 254,19 ---</span>
   * MessageFormat form = new MessageFormat(
   *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
   *
   * System.out.println(form.format(testArgs));
   * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified">!  * The output with different values for {@code fileCount}:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * The disk &quot;MyDisk&quot; contains 0 file(s).
   * The disk &quot;MyDisk&quot; contains 1 file(s).
   * The disk &quot;MyDisk&quot; contains 1,273 file(s).
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * For more sophisticated patterns, you can use a {@code ChoiceFormat}</span>
   * to produce correct forms for singular and plural:
   * &lt;blockquote&gt;&lt;pre&gt;
   * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
   * double[] filelimits = {0,1,2};
   * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,31 ***</span>
   * String diskName = &quot;MyDisk&quot;;
   * Object[] testArgs = {new Long(fileCount), diskName};
   *
   * System.out.println(form.format(testArgs));
   * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified">!  * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * The disk &quot;MyDisk&quot; contains no files.
   * The disk &quot;MyDisk&quot; contains one file.
   * The disk &quot;MyDisk&quot; contains 1,273 files.
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the</span>
   * above example, or by using a pattern. See {@link ChoiceFormat}
   * for more information.
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * form.applyPattern(
   *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
<span class="line-modified">!  * by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;</span>
   * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
<span class="line-modified">!  * If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
   * programmatically (instead of using the string patterns), then be careful not to
   * produce a format that recurses on itself, which will cause an infinite loop.
   * &lt;p&gt;
   * When a single argument is parsed more than once in the string, the last match
   * will be the final result of the parsing.  For example,
<span class="line-new-header">--- 277,31 ---</span>
   * String diskName = &quot;MyDisk&quot;;
   * Object[] testArgs = {new Long(fileCount), diskName};
   *
   * System.out.println(form.format(testArgs));
   * &lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-modified">!  * The output with different values for {@code fileCount}:</span>
   * &lt;blockquote&gt;&lt;pre&gt;
   * The disk &quot;MyDisk&quot; contains no files.
   * The disk &quot;MyDisk&quot; contains one file.
   * The disk &quot;MyDisk&quot; contains 1,273 files.
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
<span class="line-modified">!  * You can create the {@code ChoiceFormat} programmatically, as in the</span>
   * above example, or by using a pattern. See {@link ChoiceFormat}
   * for more information.
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * form.applyPattern(
   *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
<span class="line-modified">!  * by a {@code ChoiceFormat} in {@code MessageFormat} is treated as special;</span>
   * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
<span class="line-modified">!  * If you create both a {@code MessageFormat} and {@code ChoiceFormat}</span>
   * programmatically (instead of using the string patterns), then be careful not to
   * produce a format that recurses on itself, which will cause an infinite loop.
   * &lt;p&gt;
   * When a single argument is parsed more than once in the string, the last match
   * will be the final result of the parsing.  For example,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,11 ***</span>
   * String forParsing = &quot;x, y, z&quot;;
   * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
   * // result now equals {new String(&quot;z&quot;)}
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
   *
   * &lt;p&gt;
   * Message formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
<span class="line-new-header">--- 324,11 ---</span>
   * String forParsing = &quot;x, y, z&quot;;
   * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
   * // result now equals {new String(&quot;z&quot;)}
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Message formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,10 ***</span>
<span class="line-new-header">--- 347,11 ---</span>
   * @since 1.1
   */
  
  public class MessageFormat extends Format {
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 6479157306784022952L;
  
      /**
       * Constructs a MessageFormat for the default
       * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,12 ***</span>
       * creates a list of subformats for the format elements contained in it.
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
<span class="line-modified">!      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @exception NullPointerException if {@code pattern} is</span>
       *            {@code null}
       */
      public MessageFormat(String pattern) {
          this.locale = Locale.getDefault(Locale.Category.FORMAT);
          applyPattern(pattern);
<span class="line-new-header">--- 360,12 ---</span>
       * creates a list of subformats for the format elements contained in it.
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
<span class="line-modified">!      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @throws    NullPointerException if {@code pattern} is</span>
       *            {@code null}
       */
      public MessageFormat(String pattern) {
          this.locale = Locale.getDefault(Locale.Category.FORMAT);
          applyPattern(pattern);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,12 ***</span>
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
       * @param locale the locale for this message format
<span class="line-modified">!      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @exception NullPointerException if {@code pattern} is</span>
       *            {@code null}
       * @since 1.4
       */
      public MessageFormat(String pattern, Locale locale) {
          this.locale = locale;
<span class="line-new-header">--- 379,12 ---</span>
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
       * @param locale the locale for this message format
<span class="line-modified">!      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @throws    NullPointerException if {@code pattern} is</span>
       *            {@code null}
       * @since 1.4
       */
      public MessageFormat(String pattern, Locale locale) {
          this.locale = locale;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,12 ***</span>
       * This affects subsequent calls
       * &lt;ul&gt;
       * &lt;li&gt;to the {@link #applyPattern applyPattern}
       *     and {@link #toPattern toPattern} methods if format elements specify
       *     a format type and therefore have the subformats created in the
<span class="line-modified">!      *     &lt;code&gt;applyPattern&lt;/code&gt; method, as well as</span>
<span class="line-modified">!      * &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and</span>
       *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
       *     if format elements do not specify a format type and therefore have
       *     the subformats created in the formatting methods.
       * &lt;/ul&gt;
       * Subformats that have already been created are not affected.
<span class="line-new-header">--- 396,12 ---</span>
       * This affects subsequent calls
       * &lt;ul&gt;
       * &lt;li&gt;to the {@link #applyPattern applyPattern}
       *     and {@link #toPattern toPattern} methods if format elements specify
       *     a format type and therefore have the subformats created in the
<span class="line-modified">!      *     {@code applyPattern} method, as well as</span>
<span class="line-modified">!      * &lt;li&gt;to the {@code format} and</span>
       *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
       *     if format elements do not specify a format type and therefore have
       *     the subformats created in the formatting methods.
       * &lt;/ul&gt;
       * Subformats that have already been created are not affected.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,12 ***</span>
       * for the format elements contained in it.
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
<span class="line-modified">!      * @exception IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @exception NullPointerException if {@code pattern} is</span>
       *            {@code null}
       */
      @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
      public void applyPattern(String pattern) {
              StringBuilder[] segments = new StringBuilder[4];
<span class="line-new-header">--- 428,12 ---</span>
       * for the format elements contained in it.
       * Patterns and their interpretation are specified in the
       * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
       *
       * @param pattern the pattern for this message format
<span class="line-modified">!      * @throws    IllegalArgumentException if the pattern is invalid</span>
<span class="line-modified">!      * @throws    NullPointerException if {@code pattern} is</span>
       *            {@code null}
       */
      @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
      public void applyPattern(String pattern) {
              StringBuilder[] segments = new StringBuilder[4];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,29 ***</span>
          return result.toString();
      }
  
      /**
       * Sets the formats to use for the values passed into
<span class="line-modified">!      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
<span class="line-modified">!      * methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;</span>
       * correspond to the argument indices used in the previously set
       * pattern string.
<span class="line-modified">!      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to</span>
<span class="line-modified">!      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified">!      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified">!      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
       * &lt;p&gt;
       * If an argument index is used for more than one format element
       * in the pattern string, then the corresponding new format is used
       * for all such format elements. If an argument index is not used
       * for any format element in the pattern string, then the
       * corresponding new format is ignored. If fewer formats are provided
       * than needed, then only the formats for argument indices less
<span class="line-modified">!      * than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.</span>
       *
       * @param newFormats the new formats to use
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
       * @since 1.4
       */
      public void setFormatsByArgumentIndex(Format[] newFormats) {
          for (int i = 0; i &lt;= maxOffset; i++) {
              int j = argumentNumbers[i];
<span class="line-new-header">--- 594,29 ---</span>
          return result.toString();
      }
  
      /**
       * Sets the formats to use for the values passed into
<span class="line-modified">!      * {@code format} methods or returned from {@code parse}</span>
<span class="line-modified">!      * methods. The indices of elements in {@code newFormats}</span>
       * correspond to the argument indices used in the previously set
       * pattern string.
<span class="line-modified">!      * The order of formats in {@code newFormats} thus corresponds to</span>
<span class="line-modified">!      * the order of elements in the {@code arguments} array passed</span>
<span class="line-modified">!      * to the {@code format} methods or the result array returned</span>
<span class="line-modified">!      * by the {@code parse} methods.</span>
       * &lt;p&gt;
       * If an argument index is used for more than one format element
       * in the pattern string, then the corresponding new format is used
       * for all such format elements. If an argument index is not used
       * for any format element in the pattern string, then the
       * corresponding new format is ignored. If fewer formats are provided
       * than needed, then only the formats for argument indices less
<span class="line-modified">!      * than {@code newFormats.length} are replaced.</span>
       *
       * @param newFormats the new formats to use
<span class="line-modified">!      * @throws    NullPointerException if {@code newFormats} is null</span>
       * @since 1.4
       */
      public void setFormatsByArgumentIndex(Format[] newFormats) {
          for (int i = 0; i &lt;= maxOffset; i++) {
              int j = argumentNumbers[i];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,28 ***</span>
      }
  
      /**
       * Sets the formats to use for the format elements in the
       * previously set pattern string.
<span class="line-modified">!      * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to</span>
       * the order of format elements in the pattern string.
       * &lt;p&gt;
       * If more formats are provided than needed by the pattern string,
       * the remaining ones are ignored. If fewer formats are provided
<span class="line-modified">!      * than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;</span>
       * formats are replaced.
       * &lt;p&gt;
       * Since the order of format elements in a pattern string often
       * changes during localization, it is generally better to use the
       * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
       * method, which assumes an order of formats corresponding to the
<span class="line-modified">!      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified">!      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified">!      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
       *
       * @param newFormats the new formats to use
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null</span>
       */
      public void setFormats(Format[] newFormats) {
          int runsToCopy = newFormats.length;
          if (runsToCopy &gt; maxOffset + 1) {
              runsToCopy = maxOffset + 1;
<span class="line-new-header">--- 627,28 ---</span>
      }
  
      /**
       * Sets the formats to use for the format elements in the
       * previously set pattern string.
<span class="line-modified">!      * The order of formats in {@code newFormats} corresponds to</span>
       * the order of format elements in the pattern string.
       * &lt;p&gt;
       * If more formats are provided than needed by the pattern string,
       * the remaining ones are ignored. If fewer formats are provided
<span class="line-modified">!      * than needed, then only the first {@code newFormats.length}</span>
       * formats are replaced.
       * &lt;p&gt;
       * Since the order of format elements in a pattern string often
       * changes during localization, it is generally better to use the
       * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
       * method, which assumes an order of formats corresponding to the
<span class="line-modified">!      * order of elements in the {@code arguments} array passed to</span>
<span class="line-modified">!      * the {@code format} methods or the result array returned by</span>
<span class="line-modified">!      * the {@code parse} methods.</span>
       *
       * @param newFormats the new formats to use
<span class="line-modified">!      * @throws    NullPointerException if {@code newFormats} is null</span>
       */
      public void setFormats(Format[] newFormats) {
          int runsToCopy = newFormats.length;
          if (runsToCopy &gt; maxOffset + 1) {
              runsToCopy = maxOffset + 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 660,13 ***</span>
      /**
       * Sets the format to use for the format elements within the
       * previously set pattern string that use the given argument
       * index.
       * The argument index is part of the format element definition and
<span class="line-modified">!      * represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified">!      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified">!      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
       * &lt;p&gt;
       * If the argument index is used for more than one format element
       * in the pattern string, then the new format is used for all such
       * format elements. If the argument index is not used for any format
       * element in the pattern string, then the new format is ignored.
<span class="line-new-header">--- 661,13 ---</span>
      /**
       * Sets the format to use for the format elements within the
       * previously set pattern string that use the given argument
       * index.
       * The argument index is part of the format element definition and
<span class="line-modified">!      * represents an index into the {@code arguments} array passed</span>
<span class="line-modified">!      * to the {@code format} methods or the result array returned</span>
<span class="line-modified">!      * by the {@code parse} methods.</span>
       * &lt;p&gt;
       * If the argument index is used for more than one format element
       * in the pattern string, then the new format is used for all such
       * format elements. If the argument index is not used for any format
       * element in the pattern string, then the new format is ignored.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,11 ***</span>
       * method, which accesses format elements based on the argument
       * index they specify.
       *
       * @param formatElementIndex the index of a format element within the pattern
       * @param newFormat the format to use for the specified format element
<span class="line-modified">!      * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or</span>
       *            larger than the number of format elements in the pattern string
       */
      public void setFormat(int formatElementIndex, Format newFormat) {
  
          if (formatElementIndex &gt; maxOffset) {
<span class="line-new-header">--- 696,11 ---</span>
       * method, which accesses format elements based on the argument
       * index they specify.
       *
       * @param formatElementIndex the index of a format element within the pattern
       * @param newFormat the format to use for the specified format element
<span class="line-modified">!      * @throws    ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or</span>
       *            larger than the number of format elements in the pattern string
       */
      public void setFormat(int formatElementIndex, Format newFormat) {
  
          if (formatElementIndex &gt; maxOffset) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 708,18 ***</span>
          formats[formatElementIndex] = newFormat;
      }
  
      /**
       * Gets the formats used for the values passed into
<span class="line-modified">!      * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;</span>
       * methods. The indices of elements in the returned array
       * correspond to the argument indices used in the previously set
       * pattern string.
       * The order of formats in the returned array thus corresponds to
<span class="line-modified">!      * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed</span>
<span class="line-modified">!      * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned</span>
<span class="line-modified">!      * by the &lt;code&gt;parse&lt;/code&gt; methods.</span>
       * &lt;p&gt;
       * If an argument index is used for more than one format element
       * in the pattern string, then the format used for the last such
       * format element is returned in the array. If an argument index
       * is not used for any format element in the pattern string, then
<span class="line-new-header">--- 709,18 ---</span>
          formats[formatElementIndex] = newFormat;
      }
  
      /**
       * Gets the formats used for the values passed into
<span class="line-modified">!      * {@code format} methods or returned from {@code parse}</span>
       * methods. The indices of elements in the returned array
       * correspond to the argument indices used in the previously set
       * pattern string.
       * The order of formats in the returned array thus corresponds to
<span class="line-modified">!      * the order of elements in the {@code arguments} array passed</span>
<span class="line-modified">!      * to the {@code format} methods or the result array returned</span>
<span class="line-modified">!      * by the {@code parse} methods.</span>
       * &lt;p&gt;
       * If an argument index is used for more than one format element
       * in the pattern string, then the format used for the last such
       * format element is returned in the array. If an argument index
       * is not used for any format element in the pattern string, then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 750,33 ***</span>
       * &lt;p&gt;
       * Since the order of format elements in a pattern string often
       * changes during localization, it&#39;s generally better to use the
       * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
       * method, which assumes an order of formats corresponding to the
<span class="line-modified">!      * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to</span>
<span class="line-modified">!      * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by</span>
<span class="line-modified">!      * the &lt;code&gt;parse&lt;/code&gt; methods.</span>
       *
       * @return the formats used for the format elements in the pattern
       */
      public Format[] getFormats() {
          Format[] resultArray = new Format[maxOffset + 1];
          System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
          return resultArray;
      }
  
      /**
<span class="line-modified">!      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
       * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified">!      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
       * &lt;p&gt;
       * The text substituted for the individual format elements is derived from
       * the current subformat of the format element and the
<span class="line-modified">!      * &lt;code&gt;arguments&lt;/code&gt; element at the format element&#39;s argument index</span>
       * as indicated by the first matching line of the following table. An
<span class="line-modified">!      * argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is</span>
<span class="line-modified">!      * &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.</span>
       *
       * &lt;table class=&quot;plain&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
       * &lt;thead&gt;
       *    &lt;tr&gt;
<span class="line-new-header">--- 751,33 ---</span>
       * &lt;p&gt;
       * Since the order of format elements in a pattern string often
       * changes during localization, it&#39;s generally better to use the
       * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
       * method, which assumes an order of formats corresponding to the
<span class="line-modified">!      * order of elements in the {@code arguments} array passed to</span>
<span class="line-modified">!      * the {@code format} methods or the result array returned by</span>
<span class="line-modified">!      * the {@code parse} methods.</span>
       *
       * @return the formats used for the format elements in the pattern
       */
      public Format[] getFormats() {
          Format[] resultArray = new Format[maxOffset + 1];
          System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
          return resultArray;
      }
  
      /**
<span class="line-modified">!      * Formats an array of objects and appends the {@code MessageFormat}&#39;s</span>
       * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified">!      * provided {@code StringBuffer}.</span>
       * &lt;p&gt;
       * The text substituted for the individual format elements is derived from
       * the current subformat of the format element and the
<span class="line-modified">!      * {@code arguments} element at the format element&#39;s argument index</span>
       * as indicated by the first matching line of the following table. An
<span class="line-modified">!      * argument is &lt;i&gt;unavailable&lt;/i&gt; if {@code arguments} is</span>
<span class="line-modified">!      * {@code null} or has fewer than argumentIndex+1 elements.</span>
       *
       * &lt;table class=&quot;plain&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
       * &lt;thead&gt;
       *    &lt;tr&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,52 ***</span>
       *    &lt;tr&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
       *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;</span>
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
       *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
       *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
       *           subformat.format(argument)&lt;/code&gt;
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;!= null&lt;/code&gt;</span>
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;&lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Number&lt;/code&gt;</span>
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof Date&lt;/code&gt;</span>
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;code&gt;instanceof String&lt;/code&gt;</span>
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;</span>
       *    &lt;tr&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified">!      *       &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;</span>
       * &lt;/tbody&gt;
       * &lt;/table&gt;
       * &lt;p&gt;
<span class="line-modified">!      * If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to</span>
<span class="line-modified">!      * &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted</span>
       * string will be returned.
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @param result where text is appended.
       * @param pos keeps track on the position of the first replaced argument
                    in the output string.
       * @return the string buffer passed in as {@code result}, with formatted
       * text appended
<span class="line-modified">!      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
       *            expected by the format element(s) that use it.
<span class="line-modified">!      * @exception NullPointerException if {@code result} is {@code null}</span>
       */
      public final StringBuffer format(Object[] arguments, StringBuffer result,
                                       FieldPosition pos)
      {
          return subformat(arguments, result, pos, null);
<span class="line-new-header">--- 789,52 ---</span>
       *    &lt;tr&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
       *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code null}</span>
<span class="line-modified">!      *       &lt;td&gt;{@code &quot;null&quot;}</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof ChoiceFormat}</span>
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
       *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
       *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
       *           subformat.format(argument)&lt;/code&gt;
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code != null}</span>
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified">!      *       &lt;td&gt;{@code subformat.format(argument)}</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;{@code null}</span>
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Number}</span>
<span class="line-modified">!      *       &lt;td&gt;{@code NumberFormat.getInstance(getLocale()).format(argument)}</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Date}</span>
<span class="line-modified">!      *       &lt;td&gt;{@code DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)}</span>
       *    &lt;tr&gt;
<span class="line-modified">!      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof String}</span>
<span class="line-modified">!      *       &lt;td&gt;{@code argument}</span>
       *    &lt;tr&gt;
       *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
<span class="line-modified">!      *       &lt;td&gt;{@code argument.toString()}</span>
       * &lt;/tbody&gt;
       * &lt;/table&gt;
       * &lt;p&gt;
<span class="line-modified">!      * If {@code pos} is non-null, and refers to</span>
<span class="line-modified">!      * {@code Field.ARGUMENT}, the location of the first formatted</span>
       * string will be returned.
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @param result where text is appended.
       * @param pos keeps track on the position of the first replaced argument
                    in the output string.
       * @return the string buffer passed in as {@code result}, with formatted
       * text appended
<span class="line-modified">!      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            {@code arguments} array is not of the type</span>
       *            expected by the format element(s) that use it.
<span class="line-modified">!      * @throws    NullPointerException if {@code result} is {@code null}</span>
       */
      public final StringBuffer format(Object[] arguments, StringBuffer result,
                                       FieldPosition pos)
      {
          return subformat(arguments, result, pos, null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 847,78 ***</span>
       * &lt;/blockquote&gt;
       *
       * @param pattern   the pattern string
       * @param arguments object(s) to format
       * @return the formatted string
<span class="line-modified">!      * @exception IllegalArgumentException if the pattern is invalid,</span>
<span class="line-modified">!      *            or if an argument in the &lt;code&gt;arguments&lt;/code&gt; array</span>
       *            is not of the type expected by the format element(s)
       *            that use it.
<span class="line-modified">!      * @exception NullPointerException if {@code pattern} is {@code null}</span>
       */
      public static String format(String pattern, Object ... arguments) {
          MessageFormat temp = new MessageFormat(pattern);
          return temp.format(arguments);
      }
  
      // Overrides
      /**
<span class="line-modified">!      * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s</span>
       * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified">!      * provided &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
       * This is equivalent to
       * &lt;blockquote&gt;
       *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
       * &lt;/blockquote&gt;
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @param result where text is appended.
       * @param pos keeps track on the position of the first replaced argument
       *            in the output string.
<span class="line-modified">!      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
       *            expected by the format element(s) that use it.
<span class="line-modified">!      * @exception NullPointerException if {@code result} is {@code null}</span>
       */
      public final StringBuffer format(Object arguments, StringBuffer result,
                                       FieldPosition pos)
      {
          return subformat((Object[]) arguments, result, pos, null);
      }
  
      /**
       * Formats an array of objects and inserts them into the
<span class="line-modified">!      * &lt;code&gt;MessageFormat&lt;/code&gt;&#39;s pattern, producing an</span>
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">!      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
       * to build the resulting String, as well as to determine information
       * about the resulting String.
       * &lt;p&gt;
<span class="line-modified">!      * The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is</span>
       * the same that would be returned by
       * &lt;blockquote&gt;
       *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
       * &lt;/blockquote&gt;
       * &lt;p&gt;
<span class="line-modified">!      * In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at</span>
       * least attributes indicating where text was generated from an
<span class="line-modified">!      * argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of</span>
<span class="line-modified">!      * type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are</span>
<span class="line-modified">!      * &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;</span>
       * array of the argument from which the text was generated.
       * &lt;p&gt;
<span class="line-modified">!      * The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified">!      * instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be</span>
<span class="line-modified">!      * placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
       * This allows you to not only find where an argument is placed in the
       * resulting String, but also which fields it contains in turn.
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @return AttributedCharacterIterator describing the formatted value.
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.</span>
<span class="line-modified">!      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
       *            expected by the format element(s) that use it.
       * @since 1.4
       */
      public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
          StringBuffer result = new StringBuffer();
<span class="line-new-header">--- 848,78 ---</span>
       * &lt;/blockquote&gt;
       *
       * @param pattern   the pattern string
       * @param arguments object(s) to format
       * @return the formatted string
<span class="line-modified">!      * @throws    IllegalArgumentException if the pattern is invalid,</span>
<span class="line-modified">!      *            or if an argument in the {@code arguments} array</span>
       *            is not of the type expected by the format element(s)
       *            that use it.
<span class="line-modified">!      * @throws    NullPointerException if {@code pattern} is {@code null}</span>
       */
      public static String format(String pattern, Object ... arguments) {
          MessageFormat temp = new MessageFormat(pattern);
          return temp.format(arguments);
      }
  
      // Overrides
      /**
<span class="line-modified">!      * Formats an array of objects and appends the {@code MessageFormat}&#39;s</span>
       * pattern, with format elements replaced by the formatted objects, to the
<span class="line-modified">!      * provided {@code StringBuffer}.</span>
       * This is equivalent to
       * &lt;blockquote&gt;
       *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
       * &lt;/blockquote&gt;
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @param result where text is appended.
       * @param pos keeps track on the position of the first replaced argument
       *            in the output string.
<span class="line-modified">!      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            {@code arguments} array is not of the type</span>
       *            expected by the format element(s) that use it.
<span class="line-modified">!      * @throws    NullPointerException if {@code result} is {@code null}</span>
       */
      public final StringBuffer format(Object arguments, StringBuffer result,
                                       FieldPosition pos)
      {
          return subformat((Object[]) arguments, result, pos, null);
      }
  
      /**
       * Formats an array of objects and inserts them into the
<span class="line-modified">!      * {@code MessageFormat}&#39;s pattern, producing an</span>
<span class="line-modified">!      * {@code AttributedCharacterIterator}.</span>
<span class="line-modified">!      * You can use the returned {@code AttributedCharacterIterator}</span>
       * to build the resulting String, as well as to determine information
       * about the resulting String.
       * &lt;p&gt;
<span class="line-modified">!      * The text of the returned {@code AttributedCharacterIterator} is</span>
       * the same that would be returned by
       * &lt;blockquote&gt;
       *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
       * &lt;/blockquote&gt;
       * &lt;p&gt;
<span class="line-modified">!      * In addition, the {@code AttributedCharacterIterator} contains at</span>
       * least attributes indicating where text was generated from an
<span class="line-modified">!      * argument in the {@code arguments} array. The keys of these attributes are of</span>
<span class="line-modified">!      * type {@code MessageFormat.Field}, their values are</span>
<span class="line-modified">!      * {@code Integer} objects indicating the index in the {@code arguments}</span>
       * array of the argument from which the text was generated.
       * &lt;p&gt;
<span class="line-modified">!      * The attributes/value from the underlying {@code Format}</span>
<span class="line-modified">!      * instances that {@code MessageFormat} uses will also be</span>
<span class="line-modified">!      * placed in the resulting {@code AttributedCharacterIterator}.</span>
       * This allows you to not only find where an argument is placed in the
       * resulting String, but also which fields it contains in turn.
       *
       * @param arguments an array of objects to be formatted and substituted.
       * @return AttributedCharacterIterator describing the formatted value.
<span class="line-modified">!      * @throws    NullPointerException if {@code arguments} is null.</span>
<span class="line-modified">!      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            {@code arguments} array is not of the type</span>
       *            expected by the format element(s) that use it.
       * @since 1.4
       */
      public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
          StringBuffer result = new StringBuffer();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,11 ***</span>
       * If the source is null, return an empty array.
       *
       * @param source the string to parse
       * @param pos    the parse position
       * @return an array of parsed objects
<span class="line-modified">!      * @exception NullPointerException if {@code pos} is {@code null}</span>
       *            for a non-null {@code source} string.
       */
      public Object[] parse(String source, ParsePosition pos) {
          if (source == null) {
              Object[] empty = {};
<span class="line-new-header">--- 966,11 ---</span>
       * If the source is null, return an empty array.
       *
       * @param source the string to parse
       * @param pos    the parse position
       * @return an array of parsed objects
<span class="line-modified">!      * @throws    NullPointerException if {@code pos} is {@code null}</span>
       *            for a non-null {@code source} string.
       */
      public Object[] parse(String source, ParsePosition pos) {
          if (source == null) {
              Object[] empty = {};
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,13 ***</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on message parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified">!      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.</span>
<span class="line-modified">!      * @exception ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Object[] parse(String source) throws ParseException {
          ParsePosition pos  = new ParsePosition(0);
          Object[] result = parse(source, pos);
<span class="line-new-header">--- 1053,13 ---</span>
       * The method may not use the entire text of the given string.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on message parsing.
       *
<span class="line-modified">!      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified">!      * @return An {@code Object} array parsed from the string.</span>
<span class="line-modified">!      * @throws    ParseException if the beginning of the specified string</span>
       *            cannot be parsed.
       */
      public Object[] parse(String source) throws ParseException {
          ParsePosition pos  = new ParsePosition(0);
          Object[] result = parse(source, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1070,27 ***</span>
  
      /**
       * Parses text from a string to produce an object array.
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">!      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on message parsing.
       *
<span class="line-modified">!      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code pos} is null.
       */
      public Object parseObject(String source, ParsePosition pos) {
          return parse(source, pos);
<span class="line-new-header">--- 1071,27 ---</span>
  
      /**
       * Parses text from a string to produce an object array.
       * &lt;p&gt;
       * The method attempts to parse text starting at the index given by
<span class="line-modified">!      * {@code pos}.</span>
<span class="line-modified">!      * If parsing succeeds, then the index of {@code pos} is updated</span>
       * to the index after the last character used (parsing does not necessarily
       * use all characters up to the end of the string), and the parsed
<span class="line-modified">!      * object array is returned. The updated {@code pos} can be used to</span>
       * indicate the starting point for the next call to this method.
<span class="line-modified">!      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">!      * changed, the error index of {@code pos} is set to the index of</span>
       * the character where the error occurred, and null is returned.
       * &lt;p&gt;
       * See the {@link #parse(String, ParsePosition)} method for more information
       * on message parsing.
       *
<span class="line-modified">!      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified">!      * @param pos A {@code ParsePosition} object with index and error</span>
       *            index information as described above.
<span class="line-modified">!      * @return An {@code Object} array parsed from the string. In case of</span>
       *         error, returns null.
       * @throws NullPointerException if {@code pos} is null.
       */
      public Object parseObject(String source, ParsePosition pos) {
          return parse(source, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,18 ***</span>
      }
  
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified">!      * from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.</span>
       *
       * @since 1.4
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
          private static final long serialVersionUID = 7899943957617360810L;
  
          /**
           * Creates a Field with the specified name.
           *
<span class="line-new-header">--- 1144,19 ---</span>
      }
  
  
      /**
       * Defines constants that are used as attribute keys in the
<span class="line-modified">!      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified">!      * from {@code MessageFormat.formatToCharacterIterator}.</span>
       *
       * @since 1.4
       */
      public static class Field extends Format.Field {
  
          // Proclaim serial compatibility with 1.4 FCS
<span class="line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 7899943957617360810L;
  
          /**
           * Creates a Field with the specified name.
           *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,10 ***</span>
<span class="line-new-header">--- 1171,11 ---</span>
           *
           * @throws InvalidObjectException if the constant could not be
           *         resolved.
           * @return resolved MessageFormat.Field constant
           */
<span class="line-added">+         @java.io.Serial</span>
          protected Object readResolve() throws InvalidObjectException {
              if (this.getClass() != MessageFormat.Field.class) {
                  throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,13 ***</span>
          // The constants
          //
  
          /**
           * Constant identifying a portion of a message that was generated
<span class="line-modified">!          * from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">!          * The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;</span>
<span class="line-modified">!          * indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the</span>
           * argument from which the text was generated.
           */
          public static final Field ARGUMENT =
                             new Field(&quot;message argument field&quot;);
      }
<span class="line-new-header">--- 1186,13 ---</span>
          // The constants
          //
  
          /**
           * Constant identifying a portion of a message that was generated
<span class="line-modified">!          * from an argument passed into {@code formatToCharacterIterator}.</span>
<span class="line-modified">!          * The value associated with the key will be an {@code Integer}</span>
<span class="line-modified">!          * indicating the index in the {@code arguments} array of the</span>
           * argument from which the text was generated.
           */
          public static final Field ARGUMENT =
                             new Field(&quot;message argument field&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1232,13 ***</span>
       * @serial
       */
      private int[] argumentNumbers = new int[INITIAL_FORMATS];
  
      /**
<span class="line-modified">!      * One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of</span>
<span class="line-modified">!      * as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.</span>
<span class="line-modified">!      * All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;</span>
       * does, and so this variable suffices to tell us how many entries are in all of them.
       * @serial
       */
      private int maxOffset = -1;
  
<span class="line-new-header">--- 1235,13 ---</span>
       * @serial
       */
      private int[] argumentNumbers = new int[INITIAL_FORMATS];
  
      /**
<span class="line-modified">!      * One less than the number of entries in {@code offsets}.  Can also be thought of</span>
<span class="line-modified">!      * as the index of the highest-numbered element in {@code offsets} that is being used.</span>
<span class="line-modified">!      * All of these arrays should have the same number of elements being used as {@code offsets}</span>
       * does, and so this variable suffices to tell us how many entries are in all of them.
       * @serial
       */
      private int maxOffset = -1;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,12 ***</span>
       * subformats as necessary. If {@code characterIterators} is {@code null}
       * and {@code fp} is {@code non-null} and identifies
       * {@code Field.ARGUMENT} as the field attribute, the location of
       * the first replaced argument will be set in it.
       *
<span class="line-modified">!      * @exception IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type</span>
       *            expected by the format element(s) that use it.
       */
      private StringBuffer subformat(Object[] arguments, StringBuffer result,
                                     FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
          // note: this implementation assumes a fast substring &amp; index.
<span class="line-new-header">--- 1251,12 ---</span>
       * subformats as necessary. If {@code characterIterators} is {@code null}
       * and {@code fp} is {@code non-null} and identifies
       * {@code Field.ARGUMENT} as the field attribute, the location of
       * the first replaced argument will be set in it.
       *
<span class="line-modified">!      * @throws    IllegalArgumentException if an argument in the</span>
<span class="line-modified">!      *            {@code arguments} array is not of the type</span>
       *            expected by the format element(s) that use it.
       */
      private StringBuffer subformat(Object[] arguments, StringBuffer result,
                                     FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
          // note: this implementation assumes a fast substring &amp; index.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1362,11 ***</span>
          return result;
      }
  
      /**
       * Convenience method to append all the characters in
<span class="line-modified">!      * &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.</span>
       */
      private void append(StringBuffer result, CharacterIterator iterator) {
          if (iterator.first() != CharacterIterator.DONE) {
              char aChar;
  
<span class="line-new-header">--- 1365,11 ---</span>
          return result;
      }
  
      /**
       * Convenience method to append all the characters in
<span class="line-modified">!      * {@code iterator} to the StringBuffer {@code result}.</span>
       */
      private void append(StringBuffer result, CharacterIterator iterator) {
          if (iterator.first() != CharacterIterator.DONE) {
              char aChar;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1599,10 ***</span>
<span class="line-new-header">--- 1602,11 ---</span>
      /**
       * After reading an object from the input stream, do a simple verification
       * to maintain class invariants.
       * @throws InvalidObjectException if the objects read from the stream is invalid.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
          in.defaultReadObject();
          boolean isValid = maxOffset &gt;= -1
                  &amp;&amp; formats.length &gt; maxOffset
                  &amp;&amp; offsets.length &gt; maxOffset
</pre>
<center><a href="MergeCollation.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Normalizer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/util/stream/package-info.java b/src/java.base/share/classes/java/util/stream/package-info.java
--- a/src/java.base/share/classes/java/util/stream/package-info.java
+++ b/src/java.base/share/classes/java/util/stream/package-info.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,11 +41,11 @@
  * operation.)
  *
  * <p>The key abstraction introduced in this package is <em>stream</em>.  The
  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
- * are streams over objects and the primitive {@code int}, {@code long} and
+ * are streams over objects and the primitive {@code int}, {@code long}, and
  * {@code double} types.  Streams differ from collections in several ways:
  *
  * <ul>
  *     <li>No storage.  A stream is not a data structure that stores elements;
  *     instead, it conveys elements from a source such as a data structure,
@@ -174,11 +174,11 @@
  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
  * To execute the prior "sum of weights of widgets" query in parallel, we would
  * do:
  *
  * <pre>{@code
- *     int sumOfWeights = widgets.}<code><b>parallelStream()</b></code>{@code
+ *     int sumOfWeights = widgets.parallelStream()
  *                               .filter(b -> b.getColor() == RED)
  *                               .mapToInt(b -> b.getWeight())
  *                               .sum();
  * }</pre>
  *
@@ -240,11 +240,11 @@
  *     Stream<String> sl = l.stream();
  *     l.add("three");
  *     String s = sl.collect(joining(" "));
  * }</pre>
  *
- * First a list is created consisting of two strings: "one"; and "two". Then a
+ * First a list is created consisting of two strings: "one" and "two". Then a
  * stream is created from that list. Next the list is modified by adding a third
  * string: "three". Finally the elements of the stream are collected and joined
  * together. Since the list was modified before the terminal {@code collect}
  * operation commenced the result will be a string of "one two three". All the
  * streams returned from JDK collections, and most other JDK classes,
@@ -342,11 +342,11 @@
  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
  * operation that is safer, more efficient, and more amenable to
  * parallelization:
  *
  * <pre>{@code
- *     List<String>results =
+ *     List<String> results =
  *         stream.filter(s -> pattern.matcher(s).matches())
  *               .collect(Collectors.toList());  // No side-effects!
  * }</pre>
  *
  * <h3><a id="Ordering">Ordering</a></h3>

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/URLPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.ObjectInputStream;
 29 import java.io.IOException;
 30 import java.util.List;
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.security.Permission;
 34 
 35 /**
 36  * Represents permission to access a resource or set of resources defined by a
 37  * given url, and for a given set of user-settable request methods
 38  * and request headers. The &lt;i&gt;name&lt;/i&gt; of the permission is the url string.
 39  * The &lt;i&gt;actions&lt;/i&gt; string is a concatenation of the request methods and headers.
 40  * The range of method and header names is not restricted by this class.
 41  * &lt;p&gt;&lt;b&gt;The url&lt;/b&gt;&lt;p&gt;
 42  * The url string has the following expected structure.
 43  * &lt;pre&gt;
 44  *     scheme : // authority [ / path ] [ ignored-query-or-fragment ]
 45  * &lt;/pre&gt;
 46  * &lt;i&gt;scheme&lt;/i&gt; will typically be http or https, but is not restricted by this
 47  * class.
 48  * &lt;i&gt;authority&lt;/i&gt; is specified as:
 49  * &lt;pre&gt;
 50  *     authority = [ userinfo @ ] hostrange [ : portrange ]
 51  *     portrange = portnumber | -portnumber | portnumber-[portnumber] | *
 52  *     hostrange = ([*.] dnsname) | IPv4address | IPv6address
 53  * &lt;/pre&gt;
 54  * &lt;i&gt;dnsname&lt;/i&gt; is a standard DNS host or domain name, i.e. one or more labels
 55  * separated by &quot;.&quot;. &lt;i&gt;IPv4address&lt;/i&gt; is a standard literal IPv4 address and
 56  * &lt;i&gt;IPv6address&lt;/i&gt; is as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;
 57  * RFC 2732&lt;/a&gt;. Literal IPv6 addresses must however, be enclosed in &#39;[]&#39; characters.
 58  * The &lt;i&gt;dnsname&lt;/i&gt; specification can be preceded by &quot;*.&quot; which means
 59  * the name will match any hostname whose right-most domain labels are the same as
 60  * this name. For example, &quot;*.example.com&quot; matches &quot;foo.bar.example.com&quot;
 61  * &lt;p&gt;
 62  * &lt;i&gt;portrange&lt;/i&gt; is used to specify a port number, or a bounded or unbounded range of ports
 63  * that this permission applies to. If portrange is absent or invalid, then a default
 64  * port number is assumed if the scheme is {@code http} (default 80) or {@code https}
 65  * (default 443). No default is assumed for other schemes. A wildcard may be specified
 66  * which means all ports.
 67  * &lt;p&gt;
 68  * &lt;i&gt;userinfo&lt;/i&gt; is optional. A userinfo component if present, is ignored when
 69  * creating a URLPermission, and has no effect on any other methods defined by this class.
 70  * &lt;p&gt;
 71  * The &lt;i&gt;path&lt;/i&gt; component comprises a sequence of path segments,
 72  * separated by &#39;/&#39; characters. &lt;i&gt;path&lt;/i&gt; may also be empty. The path is specified
 73  * in a similar way to the path in {@link java.io.FilePermission}. There are
 74  * three different ways as the following examples show:
 75  * &lt;table class=&quot;striped&quot;&gt;
 76  * &lt;caption&gt;URL Examples&lt;/caption&gt;
 77  * &lt;thead&gt;
 78  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Example url&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 79  * &lt;/thead&gt;
 80  * &lt;tbody style=&quot;text-align:left&quot;&gt;
 81  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;white-space:nowrap;&quot;&gt;http://www.example.com/a/b/c.html&lt;/th&gt;
 82  *   &lt;td&gt;A url which identifies a specific (single) resource&lt;/td&gt;
 83  * &lt;/tr&gt;
 84  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;http://www.example.com/a/b/*&lt;/th&gt;
 85  *   &lt;td&gt;The &#39;*&#39; character refers to all resources in the same &quot;directory&quot; - in
 86  *       other words all resources with the same number of path components, and
 87  *       which only differ in the final path component, represented by the &#39;*&#39;.
 88  *   &lt;/td&gt;
 89  * &lt;/tr&gt;
 90  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;http://www.example.com/a/b/-&lt;/th&gt;
 91  *   &lt;td&gt;The &#39;-&#39; character refers to all resources recursively below the
 92  *       preceding path (e.g. http://www.example.com/a/b/c/d/e.html matches this
 93  *       example).
 94  *   &lt;/td&gt;
 95  * &lt;/tr&gt;
 96  * &lt;/tbody&gt;
 97  * &lt;/table&gt;
 98  * &lt;p&gt;
 99  * The &#39;*&#39; and &#39;-&#39; may only be specified in the final segment of a path and must be
100  * the only character in that segment. Any query or fragment components of the
101  * url are ignored when constructing URLPermissions.
102  * &lt;p&gt;
103  * As a special case, urls of the form, &quot;scheme:*&quot; are accepted to
104  * mean any url of the given scheme.
105  * &lt;p&gt;
106  * The &lt;i&gt;scheme&lt;/i&gt; and &lt;i&gt;authority&lt;/i&gt; components of the url string are handled
107  * without regard to case. This means {@link #equals(Object)},
108  * {@link #hashCode()} and {@link #implies(Permission)} are case insensitive with respect
109  * to these components. If the &lt;i&gt;authority&lt;/i&gt; contains a literal IP address,
110  * then the address is normalized for comparison. The path component is case sensitive.
111  * &lt;p&gt;
112  * &lt;i&gt;ignored-query-or-fragment&lt;/i&gt; refers to any query or fragment which appears after the
113  * path component, and which is ignored by the constructors of this class. It is defined as:
114  * &lt;pre&gt;
115  *     ignored-query-or-fragment = [ ? query ] [ # fragment ]
116  * &lt;/pre&gt;
117  * where &lt;i&gt;query&lt;/i&gt; and &lt;i&gt;fragment&lt;/i&gt; are as defined in
118  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2296.txt&quot;&gt;RFC2396&lt;/a&gt;. {@link #getName() getName()} therefore returns
119  * only the &lt;i&gt;scheme&lt;/i&gt;, &lt;i&gt;authority&lt;/i&gt; and &lt;i&gt;path&lt;/i&gt; components of the url string that
120  * the permission was created with.
121  * &lt;p&gt;&lt;b&gt;The actions string&lt;/b&gt;&lt;p&gt;
122  * The actions string of a URLPermission is a concatenation of the &lt;i&gt;method list&lt;/i&gt;
123  * and the &lt;i&gt;request headers list&lt;/i&gt;. These are lists of the permitted request
124  * methods and permitted request headers of the permission (respectively). The two lists
125  * are separated by a colon &#39;:&#39; character and elements of each list are comma separated.
126  * Some examples are:
127  * &lt;ul&gt;
128  * &lt;li&gt;&quot;POST,GET,DELETE&quot;
129  * &lt;li&gt;&quot;GET:X-Foo-Request,X-Bar-Request&quot;
130  * &lt;li&gt;&quot;POST,GET:Header1,Header2&quot;
131  * &lt;/ul&gt;
132  * &lt;p&gt;
133  * The first example specifies the methods: POST, GET and DELETE, but no request headers.
134  * The second example specifies one request method and two headers. The third
135  * example specifies two request methods, and two headers.
136  * &lt;p&gt;
137  * The colon separator need not be present if the request headers list is empty.
138  * No white-space is permitted in the actions string. The action strings supplied to
139  * the URLPermission constructors are case-insensitive and are normalized by converting
140  * method names to upper-case and header names to the form defines in RFC2616 (lower case
141  * with initial letter of each word capitalized). Either list can contain a wild-card &#39;*&#39;
142  * character which signifies all request methods or headers respectively.
143  * &lt;p&gt;
144  * Note. Depending on the context of use, some request methods and headers may be permitted
145  * at all times, and others may not be permitted at any time. For example, the
146  * HTTP protocol handler might disallow certain headers such as Content-Length
147  * from being set by application code, regardless of whether the security policy
148  * in force, permits it.
149  *
150  * @since 1.8
151  */
152 public final class URLPermission extends Permission {
153 
<a name="2" id="anc2"></a>
154     private static final long serialVersionUID = -2702463814894478682L;
155 
156     private transient String scheme;
157     private transient String ssp;                 // scheme specific part
158     private transient String path;
159     private transient List&lt;String&gt; methods;
160     private transient List&lt;String&gt; requestHeaders;
161     private transient Authority authority;
162 
163     // serialized field
164     private String actions;
165 
166     /**
167      * Creates a new URLPermission from a url string and which permits the given
168      * request methods and user-settable request headers.
169      * The name of the permission is the url string it was created with. Only the scheme,
170      * authority and path components of the url are used internally. Any fragment or query
171      * components are ignored. The permissions action string is as specified above.
172      *
173      * @param url the url string
174      *
175      * @param actions the actions string
176      *
<a name="3" id="anc3"></a><span class="line-modified">177      * @exception IllegalArgumentException if url is invalid or if actions contains white-space.</span>
178      */
179     public URLPermission(String url, String actions) {
180         super(normalize(url));
181         init(actions);
182     }
183 
184     /**
185      * Remove any query or fragment from url string
186      */
187     private static String normalize(String url) {
188         int index = url.indexOf(&#39;?&#39;);
189         if (index &gt;= 0) {
190             url = url.substring(0, index);
191         } else {
192             index = url.indexOf(&#39;#&#39;);
193             if (index &gt;= 0) {
194                 url = url.substring(0, index);
195             }
196         }
197         return url;
198     }
199 
200     private void init(String actions) {
201         parseURI(getName());
202         int colon = actions.indexOf(&#39;:&#39;);
203         if (actions.lastIndexOf(&#39;:&#39;) != colon) {
204             throw new IllegalArgumentException(
205                 &quot;Invalid actions string: \&quot;&quot; + actions + &quot;\&quot;&quot;);
206         }
207 
208         String methods, headers;
209         if (colon == -1) {
210             methods = actions;
211             headers = &quot;&quot;;
212         } else {
213             methods = actions.substring(0, colon);
214             headers = actions.substring(colon+1);
215         }
216 
217         List&lt;String&gt; l = normalizeMethods(methods);
218         Collections.sort(l);
219         this.methods = Collections.unmodifiableList(l);
220 
221         l = normalizeHeaders(headers);
222         Collections.sort(l);
223         this.requestHeaders = Collections.unmodifiableList(l);
224 
225         this.actions = actions();
226     }
227 
228     /**
229      * Creates a URLPermission with the given url string and unrestricted
230      * methods and request headers by invoking the two argument
231      * constructor as follows: URLPermission(url, &quot;*:*&quot;)
232      *
233      * @param url the url string
234      *
235      * @throws    IllegalArgumentException if url does not result in a valid {@link URI}
236      */
237     public URLPermission(String url) {
238         this(url, &quot;*:*&quot;);
239     }
240 
241     /**
242      * Returns the normalized method list and request
243      * header list, in the form:
244      * &lt;pre&gt;
245      *      &quot;method-names : header-names&quot;
246      * &lt;/pre&gt;
247      * &lt;p&gt;
248      * where method-names is the list of methods separated by commas
249      * and header-names is the list of permitted headers separated by commas.
250      * There is no white space in the returned String. If header-names is empty
251      * then the colon separator may not be present.
252      */
253     public String getActions() {
254         return actions;
255     }
256 
257     /**
258      * Checks if this URLPermission implies the given permission.
259      * Specifically, the following checks are done as if in the
260      * following sequence:
261      * &lt;ul&gt;
262      * &lt;li&gt;if &#39;p&#39; is not an instance of URLPermission return false&lt;/li&gt;
263      * &lt;li&gt;if any of p&#39;s methods are not in this&#39;s method list, and if
264      *     this&#39;s method list is not equal to &quot;*&quot;, then return false.&lt;/li&gt;
265      * &lt;li&gt;if any of p&#39;s headers are not in this&#39;s request header list, and if
266      *     this&#39;s request header list is not equal to &quot;*&quot;, then return false.&lt;/li&gt;
267      * &lt;li&gt;if this&#39;s url scheme is not equal to p&#39;s url scheme return false&lt;/li&gt;
268      * &lt;li&gt;if the scheme specific part of this&#39;s url is &#39;*&#39; return true&lt;/li&gt;
269      * &lt;li&gt;if the set of hosts defined by p&#39;s url hostrange is not a subset of
270      *     this&#39;s url hostrange then return false. For example, &quot;*.foo.example.com&quot;
271      *     is a subset of &quot;*.example.com&quot;. &quot;foo.bar.example.com&quot; is not
272      *     a subset of &quot;*.foo.example.com&quot;&lt;/li&gt;
273      * &lt;li&gt;if the portrange defined by p&#39;s url is not a subset of the
274      *     portrange defined by this&#39;s url then return false.
275      * &lt;li&gt;if the path or paths specified by p&#39;s url are contained in the
276      *     set of paths specified by this&#39;s url, then return true
277      * &lt;li&gt;otherwise, return false&lt;/li&gt;
278      * &lt;/ul&gt;
279      * &lt;p&gt;Some examples of how paths are matched are shown below:
280      * &lt;table class=&quot;plain&quot;&gt;
281      * &lt;caption&gt;Examples of Path Matching&lt;/caption&gt;
282      * &lt;thead&gt;
283      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;this&#39;s path&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;p&#39;s path&lt;/th&gt;&lt;th&gt;match&lt;/th&gt;&lt;/tr&gt;
284      * &lt;/thead&gt;
285      * &lt;tbody style=&quot;text-align:left&quot;&gt;
286      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;/a/b&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
287      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot;&gt;/a/b/*&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b/c&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
288      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/d&lt;/th&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
289      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/-&lt;/th&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
290      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot;&gt;/a/b/-&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b/c/d&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
291      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/d/e&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
292      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/*&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
293      * &lt;/tbody&gt;
294      * &lt;/table&gt;
295      */
296     public boolean implies(Permission p) {
297         if (! (p instanceof URLPermission)) {
298             return false;
299         }
300 
301         URLPermission that = (URLPermission)p;
302 
303         if (this.methods.isEmpty() &amp;&amp; !that.methods.isEmpty()) {
304             return false;
305         }
306 
307         if (!this.methods.isEmpty() &amp;&amp;
308             !this.methods.get(0).equals(&quot;*&quot;) &amp;&amp;
309             Collections.indexOfSubList(this.methods,
310                                        that.methods) == -1) {
311             return false;
312         }
313 
314         if (this.requestHeaders.isEmpty() &amp;&amp; !that.requestHeaders.isEmpty()) {
315             return false;
316         }
317 
318         if (!this.requestHeaders.isEmpty() &amp;&amp;
319             !this.requestHeaders.get(0).equals(&quot;*&quot;) &amp;&amp;
320              Collections.indexOfSubList(this.requestHeaders,
321                                         that.requestHeaders) == -1) {
322             return false;
323         }
324 
325         if (!this.scheme.equals(that.scheme)) {
326             return false;
327         }
328 
329         if (this.ssp.equals(&quot;*&quot;)) {
330             return true;
331         }
332 
333         if (!this.authority.implies(that.authority)) {
334             return false;
335         }
336 
337         if (this.path == null) {
338             return that.path == null;
339         }
340         if (that.path == null) {
341             return false;
342         }
343 
344         if (this.path.endsWith(&quot;/-&quot;)) {
345             String thisprefix = this.path.substring(0, this.path.length() - 1);
346             return that.path.startsWith(thisprefix);
347             }
348 
349         if (this.path.endsWith(&quot;/*&quot;)) {
350             String thisprefix = this.path.substring(0, this.path.length() - 1);
351             if (!that.path.startsWith(thisprefix)) {
352                 return false;
353             }
354             String thatsuffix = that.path.substring(thisprefix.length());
355             // suffix must not contain &#39;/&#39; chars
356             if (thatsuffix.indexOf(&#39;/&#39;) != -1) {
357                 return false;
358             }
359             if (thatsuffix.equals(&quot;-&quot;)) {
360                 return false;
361             }
362             return true;
363         }
364         return this.path.equals(that.path);
365     }
366 
367 
368     /**
369      * Returns true if, this.getActions().equals(p.getActions())
370      * and p&#39;s url equals this&#39;s url.  Returns false otherwise.
371      */
372     public boolean equals(Object p) {
373         if (!(p instanceof URLPermission)) {
374             return false;
375         }
376         URLPermission that = (URLPermission)p;
377         if (!this.scheme.equals(that.scheme)) {
378             return false;
379         }
380         if (!this.getActions().equals(that.getActions())) {
381             return false;
382         }
383         if (!this.authority.equals(that.authority)) {
384             return false;
385         }
386         if (this.path != null) {
387             return this.path.equals(that.path);
388         } else {
389             return that.path == null;
390         }
391     }
392 
393     /**
394      * Returns a hashcode calculated from the hashcode of the
395      * actions String and the url string.
396      */
397     public int hashCode() {
398         return getActions().hashCode()
399             + scheme.hashCode()
400             + authority.hashCode()
401             + (path == null ? 0 : path.hashCode());
402     }
403 
404 
405     private List&lt;String&gt; normalizeMethods(String methods) {
406         List&lt;String&gt; l = new ArrayList&lt;&gt;();
407         StringBuilder b = new StringBuilder();
408         for (int i=0; i&lt;methods.length(); i++) {
409             char c = methods.charAt(i);
410             if (c == &#39;,&#39;) {
411                 String s = b.toString();
412                 if (!s.isEmpty())
413                     l.add(s);
414                 b = new StringBuilder();
415             } else if (c == &#39; &#39; || c == &#39;\t&#39;) {
416                 throw new IllegalArgumentException(
417                     &quot;White space not allowed in methods: \&quot;&quot; + methods + &quot;\&quot;&quot;);
418             } else {
419                 if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
420                     c += &#39;A&#39; - &#39;a&#39;;
421                 }
422                 b.append(c);
423             }
424         }
425         String s = b.toString();
426         if (!s.isEmpty())
427             l.add(s);
428         return l;
429     }
430 
431     private List&lt;String&gt; normalizeHeaders(String headers) {
432         List&lt;String&gt; l = new ArrayList&lt;&gt;();
433         StringBuilder b = new StringBuilder();
434         boolean capitalizeNext = true;
435         for (int i=0; i&lt;headers.length(); i++) {
436             char c = headers.charAt(i);
437             if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
438                 if (capitalizeNext) {
439                     c += &#39;A&#39; - &#39;a&#39;;
440                     capitalizeNext = false;
441                 }
442                 b.append(c);
443             } else if (c == &#39; &#39; || c == &#39;\t&#39;) {
444                 throw new IllegalArgumentException(
445                     &quot;White space not allowed in headers: \&quot;&quot; + headers + &quot;\&quot;&quot;);
446             } else if (c == &#39;-&#39;) {
447                     capitalizeNext = true;
448                 b.append(c);
449             } else if (c == &#39;,&#39;) {
450                 String s = b.toString();
451                 if (!s.isEmpty())
452                     l.add(s);
453                 b = new StringBuilder();
454                 capitalizeNext = true;
455             } else {
456                 capitalizeNext = false;
457                 b.append(c);
458             }
459         }
460         String s = b.toString();
461         if (!s.isEmpty())
462             l.add(s);
463         return l;
464     }
465 
466     private void parseURI(String url) {
467         int len = url.length();
468         int delim = url.indexOf(&#39;:&#39;);
469         if (delim == -1 || delim + 1 == len) {
470             throw new IllegalArgumentException(
471                 &quot;Invalid URL string: \&quot;&quot; + url + &quot;\&quot;&quot;);
472         }
473         scheme = url.substring(0, delim).toLowerCase();
474         this.ssp = url.substring(delim + 1);
475 
476         if (!ssp.startsWith(&quot;//&quot;)) {
477             if (!ssp.equals(&quot;*&quot;)) {
478                 throw new IllegalArgumentException(
479                     &quot;Invalid URL string: \&quot;&quot; + url + &quot;\&quot;&quot;);
480             }
481             this.authority = new Authority(scheme, &quot;*&quot;);
482             return;
483         }
484         String authpath = ssp.substring(2);
485 
486         delim = authpath.indexOf(&#39;/&#39;);
487         String auth;
488         if (delim == -1) {
489             this.path = &quot;&quot;;
490             auth = authpath;
491         } else {
492             auth = authpath.substring(0, delim);
493             this.path = authpath.substring(delim);
494         }
495         this.authority = new Authority(scheme, auth.toLowerCase());
496     }
497 
498     private String actions() {
499         // The colon separator is optional when the request headers list is
500         // empty.This implementation chooses to include it even when the request
501         // headers list is empty.
502         return String.join(&quot;,&quot;, methods) + &quot;:&quot; + String.join(&quot;,&quot;, requestHeaders);
503     }
504 
505     /**
506      * restore the state of this object from stream
507      */
<a name="4" id="anc4"></a>
508     private void readObject(ObjectInputStream s)
509         throws IOException, ClassNotFoundException {
510         ObjectInputStream.GetField fields = s.readFields();
511         String actions = (String)fields.get(&quot;actions&quot;, null);
512 
513         init(actions);
514     }
515 
516     static class Authority {
517         HostPortrange p;
518 
519         Authority(String scheme, String authority) {
520             int at = authority.indexOf(&#39;@&#39;);
521             if (at == -1) {
522                     p = new HostPortrange(scheme, authority);
523             } else {
524                     p = new HostPortrange(scheme, authority.substring(at+1));
525             }
526         }
527 
528         boolean implies(Authority other) {
529             return impliesHostrange(other) &amp;&amp; impliesPortrange(other);
530         }
531 
532         private boolean impliesHostrange(Authority that) {
533             String thishost = this.p.hostname();
534             String thathost = that.p.hostname();
535 
536             if (p.wildcard() &amp;&amp; thishost.isEmpty()) {
537                 // this &quot;*&quot; implies all others
538                 return true;
539             }
540             if (that.p.wildcard() &amp;&amp; thathost.isEmpty()) {
541                 // that &quot;*&quot; can only be implied by this &quot;*&quot;
542                 return false;
543             }
544             if (thishost.equals(thathost)) {
545                 // covers all cases of literal IP addresses and fixed
546                 // domain names.
547                 return true;
548             }
549             if (this.p.wildcard()) {
550                 // this &quot;*.foo.com&quot; implies &quot;bub.bar.foo.com&quot;
551                 return thathost.endsWith(thishost);
552             }
553             return false;
554         }
555 
556         private boolean impliesPortrange(Authority that) {
557             int[] thisrange = this.p.portrange();
558             int[] thatrange = that.p.portrange();
559             if (thisrange[0] == -1) {
560                 /* port not specified non http/s URL */
561                 return true;
562             }
563             return thisrange[0] &lt;= thatrange[0] &amp;&amp;
564                         thisrange[1] &gt;= thatrange[1];
565         }
566 
567         boolean equals(Authority that) {
568             return this.p.equals(that.p);
569         }
570 
571         public int hashCode() {
572             return p.hashCode();
573         }
574     }
575 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
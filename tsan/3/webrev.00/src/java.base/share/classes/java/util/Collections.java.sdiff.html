<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Collections.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Collection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Comparators.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Collections.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;

  29 import java.io.ObjectOutputStream;
  30 import java.io.Serializable;
  31 import java.lang.reflect.Array;
  32 import java.util.function.BiConsumer;
  33 import java.util.function.BiFunction;
  34 import java.util.function.Consumer;
  35 import java.util.function.Function;
  36 import java.util.function.IntFunction;
  37 import java.util.function.Predicate;
  38 import java.util.function.UnaryOperator;
  39 import java.util.stream.IntStream;
  40 import java.util.stream.Stream;
  41 import java.util.stream.StreamSupport;

  42 
  43 /**
  44  * This class consists exclusively of static methods that operate on or return
  45  * collections.  It contains polymorphic algorithms that operate on
  46  * collections, &quot;wrappers&quot;, which return a new collection backed by a
  47  * specified collection, and a few other odds and ends.
  48  *
  49  * &lt;p&gt;The methods of this class all throw a {@code NullPointerException}
  50  * if the collections or class objects provided to them are null.
  51  *
  52  * &lt;p&gt;The documentation for the polymorphic algorithms contained in this class
  53  * generally includes a brief description of the &lt;i&gt;implementation&lt;/i&gt;.  Such
  54  * descriptions should be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than
  55  * parts of the &lt;i&gt;specification&lt;/i&gt;.  Implementors should feel free to
  56  * substitute other algorithms, so long as the specification itself is adhered
  57  * to.  (For example, the algorithm used by {@code sort} does not have to be
  58  * a mergesort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
  59  *
  60  * &lt;p&gt;The &quot;destructive&quot; algorithms contained in this class, that is, the
  61  * algorithms that modify the collection on which they operate, are specified
</pre>
<hr />
<pre>
1002      * {@code Object}&#39;s {@code equals} and {@code hashCode} methods.  This
1003      * is necessary to preserve the contracts of these operations in the case
1004      * that the backing collection is a set or a list.&lt;p&gt;
1005      *
1006      * The returned collection will be serializable if the specified collection
1007      * is serializable.
1008      *
1009      * @param  &lt;T&gt; the class of the objects in the collection
1010      * @param  c the collection for which an unmodifiable view is to be
1011      *         returned.
1012      * @return an unmodifiable view of the specified collection.
1013      */
1014     public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {
1015         return new UnmodifiableCollection&lt;&gt;(c);
1016     }
1017 
1018     /**
1019      * @serial include
1020      */
1021     static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {

1022         private static final long serialVersionUID = 1820017752578914078L;
1023 

1024         final Collection&lt;? extends E&gt; c;
1025 
1026         UnmodifiableCollection(Collection&lt;? extends E&gt; c) {
1027             if (c==null)
1028                 throw new NullPointerException();
1029             this.c = c;
1030         }
1031 
1032         public int size()                          {return c.size();}
1033         public boolean isEmpty()                   {return c.isEmpty();}
1034         public boolean contains(Object o)          {return c.contains(o);}
1035         public Object[] toArray()                  {return c.toArray();}
1036         public &lt;T&gt; T[] toArray(T[] a)              {return c.toArray(a);}
1037         public &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; f) {return c.toArray(f);}
1038         public String toString()                   {return c.toString();}
1039 
1040         public Iterator&lt;E&gt; iterator() {
1041             return new Iterator&lt;E&gt;() {
1042                 private final Iterator&lt;? extends E&gt; i = c.iterator();
1043 
</pre>
<hr />
<pre>
1108      * specified set. Query operations on the returned set &quot;read through&quot; to the specified
1109      * set, and attempts to modify the returned set, whether direct or via its
1110      * iterator, result in an {@code UnsupportedOperationException}.&lt;p&gt;
1111      *
1112      * The returned set will be serializable if the specified set
1113      * is serializable.
1114      *
1115      * @param  &lt;T&gt; the class of the objects in the set
1116      * @param  s the set for which an unmodifiable view is to be returned.
1117      * @return an unmodifiable view of the specified set.
1118      */
1119     public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) {
1120         return new UnmodifiableSet&lt;&gt;(s);
1121     }
1122 
1123     /**
1124      * @serial include
1125      */
1126     static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
1127                                  implements Set&lt;E&gt;, Serializable {

1128         private static final long serialVersionUID = -9215047833775013803L;
1129 
1130         UnmodifiableSet(Set&lt;? extends E&gt; s)     {super(s);}
1131         public boolean equals(Object o) {return o == this || c.equals(o);}
1132         public int hashCode()           {return c.hashCode();}
1133     }
1134 
1135     /**
1136      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1137      * specified sorted set. Query operations on the returned sorted set &quot;read
1138      * through&quot; to the specified sorted set.  Attempts to modify the returned
1139      * sorted set, whether direct, via its iterator, or via its
1140      * {@code subSet}, {@code headSet}, or {@code tailSet} views, result in
1141      * an {@code UnsupportedOperationException}.&lt;p&gt;
1142      *
1143      * The returned sorted set will be serializable if the specified sorted set
1144      * is serializable.
1145      *
1146      * @param  &lt;T&gt; the class of the objects in the set
1147      * @param s the sorted set for which an unmodifiable view is to be
1148      *        returned.
1149      * @return an unmodifiable view of the specified sorted set.
1150      */
1151     public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) {
1152         return new UnmodifiableSortedSet&lt;&gt;(s);
1153     }
1154 
1155     /**
1156      * @serial include
1157      */
1158     static class UnmodifiableSortedSet&lt;E&gt;
1159                              extends UnmodifiableSet&lt;E&gt;
1160                              implements SortedSet&lt;E&gt;, Serializable {

1161         private static final long serialVersionUID = -4929149591599911165L;

1162         private final SortedSet&lt;E&gt; ss;
1163 
1164         UnmodifiableSortedSet(SortedSet&lt;E&gt; s) {super(s); ss = s;}
1165 
1166         public Comparator&lt;? super E&gt; comparator() {return ss.comparator();}
1167 
1168         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
1169             return new UnmodifiableSortedSet&lt;&gt;(ss.subSet(fromElement,toElement));
1170         }
1171         public SortedSet&lt;E&gt; headSet(E toElement) {
1172             return new UnmodifiableSortedSet&lt;&gt;(ss.headSet(toElement));
1173         }
1174         public SortedSet&lt;E&gt; tailSet(E fromElement) {
1175             return new UnmodifiableSortedSet&lt;&gt;(ss.tailSet(fromElement));
1176         }
1177 
1178         public E first()                   {return ss.first();}
1179         public E last()                    {return ss.last();}
1180     }
1181 
</pre>
<hr />
<pre>
1193      * @param  &lt;T&gt; the class of the objects in the set
1194      * @param s the navigable set for which an unmodifiable view is to be
1195      *        returned
1196      * @return an unmodifiable view of the specified navigable set
1197      * @since 1.8
1198      */
1199     public static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) {
1200         return new UnmodifiableNavigableSet&lt;&gt;(s);
1201     }
1202 
1203     /**
1204      * Wraps a navigable set and disables all of the mutative operations.
1205      *
1206      * @param &lt;E&gt; type of elements
1207      * @serial include
1208      */
1209     static class UnmodifiableNavigableSet&lt;E&gt;
1210                              extends UnmodifiableSortedSet&lt;E&gt;
1211                              implements NavigableSet&lt;E&gt;, Serializable {
1212 

1213         private static final long serialVersionUID = -6027448201786391929L;
1214 
1215         /**
1216          * A singleton empty unmodifiable navigable set used for
1217          * {@link #emptyNavigableSet()}.
1218          *
1219          * @param &lt;E&gt; type of elements, if there were any, and bounds
1220          */
1221         private static class EmptyNavigableSet&lt;E&gt; extends UnmodifiableNavigableSet&lt;E&gt;
1222             implements Serializable {

1223             private static final long serialVersionUID = -6291252904449939134L;
1224 
1225             public EmptyNavigableSet() {
1226                 super(new TreeSet&lt;&gt;());
1227             }
1228 

1229             private Object readResolve()        { return EMPTY_NAVIGABLE_SET; }
1230         }
1231 
1232         @SuppressWarnings(&quot;rawtypes&quot;)
1233         private static final NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =
1234                 new EmptyNavigableSet&lt;&gt;();
1235 
1236         /**
1237          * The instance we are protecting.
1238          */

1239         private final NavigableSet&lt;E&gt; ns;
1240 
1241         UnmodifiableNavigableSet(NavigableSet&lt;E&gt; s)         {super(s); ns = s;}
1242 
1243         public E lower(E e)                             { return ns.lower(e); }
1244         public E floor(E e)                             { return ns.floor(e); }
1245         public E ceiling(E e)                         { return ns.ceiling(e); }
1246         public E higher(E e)                           { return ns.higher(e); }
1247         public E pollFirst()     { throw new UnsupportedOperationException(); }
1248         public E pollLast()      { throw new UnsupportedOperationException(); }
1249         public NavigableSet&lt;E&gt; descendingSet()
1250                  { return new UnmodifiableNavigableSet&lt;&gt;(ns.descendingSet()); }
1251         public Iterator&lt;E&gt; descendingIterator()
1252                                          { return descendingSet().iterator(); }
1253 
1254         public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
1255             return new UnmodifiableNavigableSet&lt;&gt;(
1256                 ns.subSet(fromElement, fromInclusive, toElement, toInclusive));
1257         }
1258 
</pre>
<hr />
<pre>
1276      *
1277      * The returned list will be serializable if the specified list
1278      * is serializable. Similarly, the returned list will implement
1279      * {@link RandomAccess} if the specified list does.
1280      *
1281      * @param  &lt;T&gt; the class of the objects in the list
1282      * @param  list the list for which an unmodifiable view is to be returned.
1283      * @return an unmodifiable view of the specified list.
1284      */
1285     public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) {
1286         return (list instanceof RandomAccess ?
1287                 new UnmodifiableRandomAccessList&lt;&gt;(list) :
1288                 new UnmodifiableList&lt;&gt;(list));
1289     }
1290 
1291     /**
1292      * @serial include
1293      */
1294     static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
1295                                   implements List&lt;E&gt; {

1296         private static final long serialVersionUID = -283967356065247728L;
1297 

1298         final List&lt;? extends E&gt; list;
1299 
1300         UnmodifiableList(List&lt;? extends E&gt; list) {
1301             super(list);
1302             this.list = list;
1303         }
1304 
1305         public boolean equals(Object o) {return o == this || list.equals(o);}
1306         public int hashCode()           {return list.hashCode();}
1307 
1308         public E get(int index) {return list.get(index);}
1309         public E set(int index, E element) {
1310             throw new UnsupportedOperationException();
1311         }
1312         public void add(int index, E element) {
1313             throw new UnsupportedOperationException();
1314         }
1315         public E remove(int index) {
1316             throw new UnsupportedOperationException();
1317         }
</pre>
<hr />
<pre>
1360                 }
1361             };
1362         }
1363 
1364         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1365             return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));
1366         }
1367 
1368         /**
1369          * UnmodifiableRandomAccessList instances are serialized as
1370          * UnmodifiableList instances to allow them to be deserialized
1371          * in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList).
1372          * This method inverts the transformation.  As a beneficial
1373          * side-effect, it also grafts the RandomAccess marker onto
1374          * UnmodifiableList instances that were serialized in pre-1.4 JREs.
1375          *
1376          * Note: Unfortunately, UnmodifiableRandomAccessList instances
1377          * serialized in 1.4.1 and deserialized in 1.4 will become
1378          * UnmodifiableList instances, as this method was missing in 1.4.
1379          */

1380         private Object readResolve() {
1381             return (list instanceof RandomAccess
1382                     ? new UnmodifiableRandomAccessList&lt;&gt;(list)
1383                     : this);
1384         }
1385     }
1386 
1387     /**
1388      * @serial include
1389      */
1390     static class UnmodifiableRandomAccessList&lt;E&gt; extends UnmodifiableList&lt;E&gt;
1391                                               implements RandomAccess
1392     {
1393         UnmodifiableRandomAccessList(List&lt;? extends E&gt; list) {
1394             super(list);
1395         }
1396 
1397         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1398             return new UnmodifiableRandomAccessList&lt;&gt;(
1399                 list.subList(fromIndex, toIndex));
1400         }
1401 

1402         private static final long serialVersionUID = -2542308836966382001L;
1403 
1404         /**
1405          * Allows instances to be deserialized in pre-1.4 JREs (which do
1406          * not have UnmodifiableRandomAccessList).  UnmodifiableList has
1407          * a readResolve method that inverts this transformation upon
1408          * deserialization.
1409          */

1410         private Object writeReplace() {
1411             return new UnmodifiableList&lt;&gt;(list);
1412         }
1413     }
1414 
1415     /**
1416      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1417      * specified map. Query operations on the returned map &quot;read through&quot;
1418      * to the specified map, and attempts to modify the returned
1419      * map, whether direct or via its collection views, result in an
1420      * {@code UnsupportedOperationException}.&lt;p&gt;
1421      *
1422      * The returned map will be serializable if the specified map
1423      * is serializable.
1424      *
1425      * @param &lt;K&gt; the class of the map keys
1426      * @param &lt;V&gt; the class of the map values
1427      * @param  m the map for which an unmodifiable view is to be returned.
1428      * @return an unmodifiable view of the specified map.
1429      */
1430     public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
1431         return new UnmodifiableMap&lt;&gt;(m);
1432     }
1433 
1434     /**
1435      * @serial include
1436      */
1437     private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable {

1438         private static final long serialVersionUID = -1034234728574286014L;
1439 

1440         private final Map&lt;? extends K, ? extends V&gt; m;
1441 
1442         UnmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
1443             if (m==null)
1444                 throw new NullPointerException();
1445             this.m = m;
1446         }
1447 
1448         public int size()                        {return m.size();}
1449         public boolean isEmpty()                 {return m.isEmpty();}
1450         public boolean containsKey(Object key)   {return m.containsKey(key);}
1451         public boolean containsValue(Object val) {return m.containsValue(val);}
1452         public V get(Object key)                 {return m.get(key);}
1453 
1454         public V put(K key, V value) {
1455             throw new UnsupportedOperationException();
1456         }
1457         public V remove(Object key) {
1458             throw new UnsupportedOperationException();
1459         }
</pre>
<hr />
<pre>
1544                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1545             throw new UnsupportedOperationException();
1546         }
1547 
1548         @Override
1549         public V merge(K key, V value,
1550                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
1551             throw new UnsupportedOperationException();
1552         }
1553 
1554         /**
1555          * We need this class in addition to UnmodifiableSet as
1556          * Map.Entries themselves permit modification of the backing Map
1557          * via their setValue operation.  This class is subtle: there are
1558          * many possible attacks that must be thwarted.
1559          *
1560          * @serial include
1561          */
1562         static class UnmodifiableEntrySet&lt;K,V&gt;
1563             extends UnmodifiableSet&lt;Map.Entry&lt;K,V&gt;&gt; {

1564             private static final long serialVersionUID = 7854390611657943733L;
1565 
1566             @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
1567             UnmodifiableEntrySet(Set&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; s) {
1568                 // Need to cast to raw in order to work around a limitation in the type system
1569                 super((Set)s);
1570             }
1571 
1572             static &lt;K, V&gt; Consumer&lt;Map.Entry&lt;? extends K, ? extends V&gt;&gt; entryConsumer(
1573                     Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
1574                 return e -&gt; action.accept(new UnmodifiableEntry&lt;&gt;(e));
1575             }
1576 
1577             public void forEach(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
1578                 Objects.requireNonNull(action);
1579                 c.forEach(entryConsumer(action));
1580             }
1581 
1582             static final class UnmodifiableEntrySetSpliterator&lt;K, V&gt;
1583                     implements Spliterator&lt;Entry&lt;K,V&gt;&gt; {
</pre>
<hr />
<pre>
1775      *
1776      * The returned sorted map will be serializable if the specified sorted map
1777      * is serializable.
1778      *
1779      * @param &lt;K&gt; the class of the map keys
1780      * @param &lt;V&gt; the class of the map values
1781      * @param m the sorted map for which an unmodifiable view is to be
1782      *        returned.
1783      * @return an unmodifiable view of the specified sorted map.
1784      */
1785     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {
1786         return new UnmodifiableSortedMap&lt;&gt;(m);
1787     }
1788 
1789     /**
1790      * @serial include
1791      */
1792     static class UnmodifiableSortedMap&lt;K,V&gt;
1793           extends UnmodifiableMap&lt;K,V&gt;
1794           implements SortedMap&lt;K,V&gt;, Serializable {

1795         private static final long serialVersionUID = -8806743815996713206L;
1796 

1797         private final SortedMap&lt;K, ? extends V&gt; sm;
1798 
1799         UnmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {super(m); sm = m; }
1800         public Comparator&lt;? super K&gt; comparator()   { return sm.comparator(); }
1801         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)
1802              { return new UnmodifiableSortedMap&lt;&gt;(sm.subMap(fromKey, toKey)); }
1803         public SortedMap&lt;K,V&gt; headMap(K toKey)
1804                      { return new UnmodifiableSortedMap&lt;&gt;(sm.headMap(toKey)); }
1805         public SortedMap&lt;K,V&gt; tailMap(K fromKey)
1806                    { return new UnmodifiableSortedMap&lt;&gt;(sm.tailMap(fromKey)); }
1807         public K firstKey()                           { return sm.firstKey(); }
1808         public K lastKey()                             { return sm.lastKey(); }
1809     }
1810 
1811     /**
1812      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1813      * specified navigable map. Query operations on the returned navigable map &quot;read
1814      * through&quot; to the specified navigable map.  Attempts to modify the returned
1815      * navigable map, whether direct, via its collection views, or via its
1816      * {@code subMap}, {@code headMap}, or {@code tailMap} views, result in
</pre>
<hr />
<pre>
1819      * The returned navigable map will be serializable if the specified
1820      * navigable map is serializable.
1821      *
1822      * @param &lt;K&gt; the class of the map keys
1823      * @param &lt;V&gt; the class of the map values
1824      * @param m the navigable map for which an unmodifiable view is to be
1825      *        returned
1826      * @return an unmodifiable view of the specified navigable map
1827      * @since 1.8
1828      */
1829     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) {
1830         return new UnmodifiableNavigableMap&lt;&gt;(m);
1831     }
1832 
1833     /**
1834      * @serial include
1835      */
1836     static class UnmodifiableNavigableMap&lt;K,V&gt;
1837           extends UnmodifiableSortedMap&lt;K,V&gt;
1838           implements NavigableMap&lt;K,V&gt;, Serializable {

1839         private static final long serialVersionUID = -4858195264774772197L;
1840 
1841         /**
1842          * A class for the {@link EMPTY_NAVIGABLE_MAP} which needs readResolve
1843          * to preserve singleton property.
1844          *
1845          * @param &lt;K&gt; type of keys, if there were any, and of bounds
1846          * @param &lt;V&gt; type of values, if there were any
1847          */
1848         private static class EmptyNavigableMap&lt;K,V&gt; extends UnmodifiableNavigableMap&lt;K,V&gt;
1849             implements Serializable {
1850 

1851             private static final long serialVersionUID = -2239321462712562324L;
1852 
1853             EmptyNavigableMap()                       { super(new TreeMap&lt;&gt;()); }
1854 
1855             @Override
1856             public NavigableSet&lt;K&gt; navigableKeySet()
1857                                                 { return emptyNavigableSet(); }
1858 

1859             private Object readResolve()        { return EMPTY_NAVIGABLE_MAP; }
1860         }
1861 
1862         /**
1863          * Singleton for {@link emptyNavigableMap()} which is also immutable.
1864          */
1865         private static final EmptyNavigableMap&lt;?,?&gt; EMPTY_NAVIGABLE_MAP =
1866             new EmptyNavigableMap&lt;&gt;();
1867 
1868         /**
1869          * The instance we wrap and protect.
1870          */

1871         private final NavigableMap&lt;K, ? extends V&gt; nm;
1872 
1873         UnmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)
1874                                                             {super(m); nm = m;}
1875 
1876         public K lowerKey(K key)                   { return nm.lowerKey(key); }
1877         public K floorKey(K key)                   { return nm.floorKey(key); }
1878         public K ceilingKey(K key)               { return nm.ceilingKey(key); }
1879         public K higherKey(K key)                 { return nm.higherKey(key); }
1880 
1881         @SuppressWarnings(&quot;unchecked&quot;)
1882         public Entry&lt;K, V&gt; lowerEntry(K key) {
1883             Entry&lt;K,V&gt; lower = (Entry&lt;K, V&gt;) nm.lowerEntry(key);
1884             return (null != lower)
1885                 ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(lower)
1886                 : null;
1887         }
1888 
1889         @SuppressWarnings(&quot;unchecked&quot;)
1890         public Entry&lt;K, V&gt; floorEntry(K key) {
</pre>
<hr />
<pre>
1979      *
1980      * The returned collection will be serializable if the specified collection
1981      * is serializable.
1982      *
1983      * @param  &lt;T&gt; the class of the objects in the collection
1984      * @param  c the collection to be &quot;wrapped&quot; in a synchronized collection.
1985      * @return a synchronized view of the specified collection.
1986      */
1987     public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) {
1988         return new SynchronizedCollection&lt;&gt;(c);
1989     }
1990 
1991     static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c, Object mutex) {
1992         return new SynchronizedCollection&lt;&gt;(c, mutex);
1993     }
1994 
1995     /**
1996      * @serial include
1997      */
1998     static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {

1999         private static final long serialVersionUID = 3053995032091335093L;
2000 

2001         final Collection&lt;E&gt; c;  // Backing Collection

2002         final Object mutex;     // Object on which to synchronize
2003 
2004         SynchronizedCollection(Collection&lt;E&gt; c) {
2005             this.c = Objects.requireNonNull(c);
2006             mutex = this;
2007         }
2008 
2009         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2010             this.c = Objects.requireNonNull(c);
2011             this.mutex = Objects.requireNonNull(mutex);
2012         }
2013 
2014         public int size() {
2015             synchronized (mutex) {return c.size();}
2016         }
2017         public boolean isEmpty() {
2018             synchronized (mutex) {return c.isEmpty();}
2019         }
2020         public boolean contains(Object o) {
2021             synchronized (mutex) {return c.contains(o);}
</pre>
<hr />
<pre>
2063         @Override
2064         public void forEach(Consumer&lt;? super E&gt; consumer) {
2065             synchronized (mutex) {c.forEach(consumer);}
2066         }
2067         @Override
2068         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
2069             synchronized (mutex) {return c.removeIf(filter);}
2070         }
2071         @Override
2072         public Spliterator&lt;E&gt; spliterator() {
2073             return c.spliterator(); // Must be manually synched by user!
2074         }
2075         @Override
2076         public Stream&lt;E&gt; stream() {
2077             return c.stream(); // Must be manually synched by user!
2078         }
2079         @Override
2080         public Stream&lt;E&gt; parallelStream() {
2081             return c.parallelStream(); // Must be manually synched by user!
2082         }

2083         private void writeObject(ObjectOutputStream s) throws IOException {
2084             synchronized (mutex) {s.defaultWriteObject();}
2085         }
2086     }
2087 
2088     /**
2089      * Returns a synchronized (thread-safe) set backed by the specified
2090      * set.  In order to guarantee serial access, it is critical that
2091      * &lt;strong&gt;all&lt;/strong&gt; access to the backing set is accomplished
2092      * through the returned set.&lt;p&gt;
2093      *
2094      * It is imperative that the user manually synchronize on the returned
2095      * collection when traversing it via {@link Iterator}, {@link Spliterator}
2096      * or {@link Stream}:
2097      * &lt;pre&gt;
2098      *  Set s = Collections.synchronizedSet(new HashSet());
2099      *      ...
2100      *  synchronized (s) {
2101      *      Iterator i = s.iterator(); // Must be in the synchronized block
2102      *      while (i.hasNext())
</pre>
<hr />
<pre>
2109      * serializable.
2110      *
2111      * @param  &lt;T&gt; the class of the objects in the set
2112      * @param  s the set to be &quot;wrapped&quot; in a synchronized set.
2113      * @return a synchronized view of the specified set.
2114      */
2115     public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {
2116         return new SynchronizedSet&lt;&gt;(s);
2117     }
2118 
2119     static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s, Object mutex) {
2120         return new SynchronizedSet&lt;&gt;(s, mutex);
2121     }
2122 
2123     /**
2124      * @serial include
2125      */
2126     static class SynchronizedSet&lt;E&gt;
2127           extends SynchronizedCollection&lt;E&gt;
2128           implements Set&lt;E&gt; {

2129         private static final long serialVersionUID = 487447009682186044L;
2130 
2131         SynchronizedSet(Set&lt;E&gt; s) {
2132             super(s);
2133         }
2134         SynchronizedSet(Set&lt;E&gt; s, Object mutex) {
2135             super(s, mutex);
2136         }
2137 
2138         public boolean equals(Object o) {
2139             if (this == o)
2140                 return true;
2141             synchronized (mutex) {return c.equals(o);}
2142         }
2143         public int hashCode() {
2144             synchronized (mutex) {return c.hashCode();}
2145         }
2146     }
2147 
2148     /**
</pre>
<hr />
<pre>
2178      * Failure to follow this advice may result in non-deterministic behavior.
2179      *
2180      * &lt;p&gt;The returned sorted set will be serializable if the specified
2181      * sorted set is serializable.
2182      *
2183      * @param  &lt;T&gt; the class of the objects in the set
2184      * @param  s the sorted set to be &quot;wrapped&quot; in a synchronized sorted set.
2185      * @return a synchronized view of the specified sorted set.
2186      */
2187     public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) {
2188         return new SynchronizedSortedSet&lt;&gt;(s);
2189     }
2190 
2191     /**
2192      * @serial include
2193      */
2194     static class SynchronizedSortedSet&lt;E&gt;
2195         extends SynchronizedSet&lt;E&gt;
2196         implements SortedSet&lt;E&gt;
2197     {

2198         private static final long serialVersionUID = 8695801310862127406L;
2199 

2200         private final SortedSet&lt;E&gt; ss;
2201 
2202         SynchronizedSortedSet(SortedSet&lt;E&gt; s) {
2203             super(s);
2204             ss = s;
2205         }
2206         SynchronizedSortedSet(SortedSet&lt;E&gt; s, Object mutex) {
2207             super(s, mutex);
2208             ss = s;
2209         }
2210 
2211         public Comparator&lt;? super E&gt; comparator() {
2212             synchronized (mutex) {return ss.comparator();}
2213         }
2214 
2215         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
2216             synchronized (mutex) {
2217                 return new SynchronizedSortedSet&lt;&gt;(
2218                     ss.subSet(fromElement, toElement), mutex);
2219             }
</pre>
<hr />
<pre>
2272      * &lt;p&gt;The returned navigable set will be serializable if the specified
2273      * navigable set is serializable.
2274      *
2275      * @param  &lt;T&gt; the class of the objects in the set
2276      * @param  s the navigable set to be &quot;wrapped&quot; in a synchronized navigable
2277      * set
2278      * @return a synchronized view of the specified navigable set
2279      * @since 1.8
2280      */
2281     public static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s) {
2282         return new SynchronizedNavigableSet&lt;&gt;(s);
2283     }
2284 
2285     /**
2286      * @serial include
2287      */
2288     static class SynchronizedNavigableSet&lt;E&gt;
2289         extends SynchronizedSortedSet&lt;E&gt;
2290         implements NavigableSet&lt;E&gt;
2291     {

2292         private static final long serialVersionUID = -5505529816273629798L;
2293 

2294         private final NavigableSet&lt;E&gt; ns;
2295 
2296         SynchronizedNavigableSet(NavigableSet&lt;E&gt; s) {
2297             super(s);
2298             ns = s;
2299         }
2300 
2301         SynchronizedNavigableSet(NavigableSet&lt;E&gt; s, Object mutex) {
2302             super(s, mutex);
2303             ns = s;
2304         }
2305         public E lower(E e)      { synchronized (mutex) {return ns.lower(e);} }
2306         public E floor(E e)      { synchronized (mutex) {return ns.floor(e);} }
2307         public E ceiling(E e)  { synchronized (mutex) {return ns.ceiling(e);} }
2308         public E higher(E e)    { synchronized (mutex) {return ns.higher(e);} }
2309         public E pollFirst()  { synchronized (mutex) {return ns.pollFirst();} }
2310         public E pollLast()    { synchronized (mutex) {return ns.pollLast();} }
2311 
2312         public NavigableSet&lt;E&gt; descendingSet() {
2313             synchronized (mutex) {
</pre>
<hr />
<pre>
2381      * @return a synchronized view of the specified list.
2382      */
2383     public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) {
2384         return (list instanceof RandomAccess ?
2385                 new SynchronizedRandomAccessList&lt;&gt;(list) :
2386                 new SynchronizedList&lt;&gt;(list));
2387     }
2388 
2389     static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) {
2390         return (list instanceof RandomAccess ?
2391                 new SynchronizedRandomAccessList&lt;&gt;(list, mutex) :
2392                 new SynchronizedList&lt;&gt;(list, mutex));
2393     }
2394 
2395     /**
2396      * @serial include
2397      */
2398     static class SynchronizedList&lt;E&gt;
2399         extends SynchronizedCollection&lt;E&gt;
2400         implements List&lt;E&gt; {

2401         private static final long serialVersionUID = -7754090372962971524L;
2402 

2403         final List&lt;E&gt; list;
2404 
2405         SynchronizedList(List&lt;E&gt; list) {
2406             super(list);
2407             this.list = list;
2408         }
2409         SynchronizedList(List&lt;E&gt; list, Object mutex) {
2410             super(list, mutex);
2411             this.list = list;
2412         }
2413 
2414         public boolean equals(Object o) {
2415             if (this == o)
2416                 return true;
2417             synchronized (mutex) {return list.equals(o);}
2418         }
2419         public int hashCode() {
2420             synchronized (mutex) {return list.hashCode();}
2421         }
2422 
</pre>
<hr />
<pre>
2463         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
2464             synchronized (mutex) {list.replaceAll(operator);}
2465         }
2466         @Override
2467         public void sort(Comparator&lt;? super E&gt; c) {
2468             synchronized (mutex) {list.sort(c);}
2469         }
2470 
2471         /**
2472          * SynchronizedRandomAccessList instances are serialized as
2473          * SynchronizedList instances to allow them to be deserialized
2474          * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList).
2475          * This method inverts the transformation.  As a beneficial
2476          * side-effect, it also grafts the RandomAccess marker onto
2477          * SynchronizedList instances that were serialized in pre-1.4 JREs.
2478          *
2479          * Note: Unfortunately, SynchronizedRandomAccessList instances
2480          * serialized in 1.4.1 and deserialized in 1.4 will become
2481          * SynchronizedList instances, as this method was missing in 1.4.
2482          */

2483         private Object readResolve() {
2484             return (list instanceof RandomAccess
2485                     ? new SynchronizedRandomAccessList&lt;&gt;(list)
2486                     : this);
2487         }
2488     }
2489 
2490     /**
2491      * @serial include
2492      */
2493     static class SynchronizedRandomAccessList&lt;E&gt;
2494         extends SynchronizedList&lt;E&gt;
2495         implements RandomAccess {
2496 
2497         SynchronizedRandomAccessList(List&lt;E&gt; list) {
2498             super(list);
2499         }
2500 
2501         SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) {
2502             super(list, mutex);
2503         }
2504 
2505         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
2506             synchronized (mutex) {
2507                 return new SynchronizedRandomAccessList&lt;&gt;(
2508                     list.subList(fromIndex, toIndex), mutex);
2509             }
2510         }
2511 

2512         private static final long serialVersionUID = 1530674583602358482L;
2513 
2514         /**
2515          * Allows instances to be deserialized in pre-1.4 JREs (which do
2516          * not have SynchronizedRandomAccessList).  SynchronizedList has
2517          * a readResolve method that inverts this transformation upon
2518          * deserialization.
2519          */

2520         private Object writeReplace() {
2521             return new SynchronizedList&lt;&gt;(list);
2522         }
2523     }
2524 
2525     /**
2526      * Returns a synchronized (thread-safe) map backed by the specified
2527      * map.  In order to guarantee serial access, it is critical that
2528      * &lt;strong&gt;all&lt;/strong&gt; access to the backing map is accomplished
2529      * through the returned map.&lt;p&gt;
2530      *
2531      * It is imperative that the user manually synchronize on the returned
2532      * map when traversing any of its collection views via {@link Iterator},
2533      * {@link Spliterator} or {@link Stream}:
2534      * &lt;pre&gt;
2535      *  Map m = Collections.synchronizedMap(new HashMap());
2536      *      ...
2537      *  Set s = m.keySet();  // Needn&#39;t be in synchronized block
2538      *      ...
2539      *  synchronized (m) {  // Synchronizing on m, not s!
</pre>
<hr />
<pre>
2544      * &lt;/pre&gt;
2545      * Failure to follow this advice may result in non-deterministic behavior.
2546      *
2547      * &lt;p&gt;The returned map will be serializable if the specified map is
2548      * serializable.
2549      *
2550      * @param &lt;K&gt; the class of the map keys
2551      * @param &lt;V&gt; the class of the map values
2552      * @param  m the map to be &quot;wrapped&quot; in a synchronized map.
2553      * @return a synchronized view of the specified map.
2554      */
2555     public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {
2556         return new SynchronizedMap&lt;&gt;(m);
2557     }
2558 
2559     /**
2560      * @serial include
2561      */
2562     private static class SynchronizedMap&lt;K,V&gt;
2563         implements Map&lt;K,V&gt;, Serializable {

2564         private static final long serialVersionUID = 1978198479659022715L;
2565 

2566         private final Map&lt;K,V&gt; m;     // Backing Map

2567         final Object      mutex;        // Object on which to synchronize
2568 
2569         SynchronizedMap(Map&lt;K,V&gt; m) {
2570             this.m = Objects.requireNonNull(m);
2571             mutex = this;
2572         }
2573 
2574         SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {
2575             this.m = m;
2576             this.mutex = mutex;
2577         }
2578 
2579         public int size() {
2580             synchronized (mutex) {return m.size();}
2581         }
2582         public boolean isEmpty() {
2583             synchronized (mutex) {return m.isEmpty();}
2584         }
2585         public boolean containsKey(Object key) {
2586             synchronized (mutex) {return m.containsKey(key);}
</pre>
<hr />
<pre>
2678         public V computeIfAbsent(K key,
2679                 Function&lt;? super K, ? extends V&gt; mappingFunction) {
2680             synchronized (mutex) {return m.computeIfAbsent(key, mappingFunction);}
2681         }
2682         @Override
2683         public V computeIfPresent(K key,
2684                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
2685             synchronized (mutex) {return m.computeIfPresent(key, remappingFunction);}
2686         }
2687         @Override
2688         public V compute(K key,
2689                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
2690             synchronized (mutex) {return m.compute(key, remappingFunction);}
2691         }
2692         @Override
2693         public V merge(K key, V value,
2694                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
2695             synchronized (mutex) {return m.merge(key, value, remappingFunction);}
2696         }
2697 

2698         private void writeObject(ObjectOutputStream s) throws IOException {
2699             synchronized (mutex) {s.defaultWriteObject();}
2700         }
2701     }
2702 
2703     /**
2704      * Returns a synchronized (thread-safe) sorted map backed by the specified
2705      * sorted map.  In order to guarantee serial access, it is critical that
2706      * &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted map is accomplished
2707      * through the returned sorted map (or its views).&lt;p&gt;
2708      *
2709      * It is imperative that the user manually synchronize on the returned
2710      * sorted map when traversing any of its collection views, or the
2711      * collections views of any of its {@code subMap}, {@code headMap} or
2712      * {@code tailMap} views, via {@link Iterator}, {@link Spliterator} or
2713      * {@link Stream}:
2714      * &lt;pre&gt;
2715      *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
2716      *      ...
2717      *  Set s = m.keySet();  // Needn&#39;t be in synchronized block
</pre>
<hr />
<pre>
2739      *
2740      * &lt;p&gt;The returned sorted map will be serializable if the specified
2741      * sorted map is serializable.
2742      *
2743      * @param &lt;K&gt; the class of the map keys
2744      * @param &lt;V&gt; the class of the map values
2745      * @param  m the sorted map to be &quot;wrapped&quot; in a synchronized sorted map.
2746      * @return a synchronized view of the specified sorted map.
2747      */
2748     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
2749         return new SynchronizedSortedMap&lt;&gt;(m);
2750     }
2751 
2752     /**
2753      * @serial include
2754      */
2755     static class SynchronizedSortedMap&lt;K,V&gt;
2756         extends SynchronizedMap&lt;K,V&gt;
2757         implements SortedMap&lt;K,V&gt;
2758     {

2759         private static final long serialVersionUID = -8798146769416483793L;
2760 

2761         private final SortedMap&lt;K,V&gt; sm;
2762 
2763         SynchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
2764             super(m);
2765             sm = m;
2766         }
2767         SynchronizedSortedMap(SortedMap&lt;K,V&gt; m, Object mutex) {
2768             super(m, mutex);
2769             sm = m;
2770         }
2771 
2772         public Comparator&lt;? super K&gt; comparator() {
2773             synchronized (mutex) {return sm.comparator();}
2774         }
2775 
2776         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
2777             synchronized (mutex) {
2778                 return new SynchronizedSortedMap&lt;&gt;(
2779                     sm.subMap(fromKey, toKey), mutex);
2780             }
</pre>
<hr />
<pre>
2841      * @param &lt;K&gt; the class of the map keys
2842      * @param &lt;V&gt; the class of the map values
2843      * @param  m the navigable map to be &quot;wrapped&quot; in a synchronized navigable
2844      *              map
2845      * @return a synchronized view of the specified navigable map.
2846      * @since 1.8
2847      */
2848     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
2849         return new SynchronizedNavigableMap&lt;&gt;(m);
2850     }
2851 
2852     /**
2853      * A synchronized NavigableMap.
2854      *
2855      * @serial include
2856      */
2857     static class SynchronizedNavigableMap&lt;K,V&gt;
2858         extends SynchronizedSortedMap&lt;K,V&gt;
2859         implements NavigableMap&lt;K,V&gt;
2860     {

2861         private static final long serialVersionUID = 699392247599746807L;
2862 

2863         private final NavigableMap&lt;K,V&gt; nm;
2864 
2865         SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
2866             super(m);
2867             nm = m;
2868         }
2869         SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m, Object mutex) {
2870             super(m, mutex);
2871             nm = m;
2872         }
2873 
2874         public Entry&lt;K, V&gt; lowerEntry(K key)
2875                         { synchronized (mutex) { return nm.lowerEntry(key); } }
2876         public K lowerKey(K key)
2877                           { synchronized (mutex) { return nm.lowerKey(key); } }
2878         public Entry&lt;K, V&gt; floorEntry(K key)
2879                         { synchronized (mutex) { return nm.floorEntry(key); } }
2880         public K floorKey(K key)
2881                           { synchronized (mutex) { return nm.floorKey(key); } }
2882         public Entry&lt;K, V&gt; ceilingEntry(K key)
</pre>
<hr />
<pre>
3019      * @param c the collection for which a dynamically typesafe view is to be
3020      *          returned
3021      * @param type the type of element that {@code c} is permitted to hold
3022      * @return a dynamically typesafe view of the specified collection
3023      * @since 1.5
3024      */
3025     public static &lt;E&gt; Collection&lt;E&gt; checkedCollection(Collection&lt;E&gt; c,
3026                                                       Class&lt;E&gt; type) {
3027         return new CheckedCollection&lt;&gt;(c, type);
3028     }
3029 
3030     @SuppressWarnings(&quot;unchecked&quot;)
3031     static &lt;T&gt; T[] zeroLengthArray(Class&lt;T&gt; type) {
3032         return (T[]) Array.newInstance(type, 0);
3033     }
3034 
3035     /**
3036      * @serial include
3037      */
3038     static class CheckedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {

3039         private static final long serialVersionUID = 1578914078182001775L;
3040 

3041         final Collection&lt;E&gt; c;

3042         final Class&lt;E&gt; type;
3043 
3044         @SuppressWarnings(&quot;unchecked&quot;)
3045         E typeCheck(Object o) {
3046             if (o != null &amp;&amp; !type.isInstance(o))
3047                 throw new ClassCastException(badElementMsg(o));
3048             return (E) o;
3049         }
3050 
3051         private String badElementMsg(Object o) {
3052             return &quot;Attempt to insert &quot; + o.getClass() +
3053                 &quot; element into collection with element type &quot; + type;
3054         }
3055 
3056         CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) {
3057             this.c = Objects.requireNonNull(c, &quot;c&quot;);
3058             this.type = Objects.requireNonNull(type, &quot;type&quot;);
3059         }
3060 
3061         public int size()                          { return c.size(); }
</pre>
<hr />
<pre>
3077         public boolean retainAll(Collection&lt;?&gt; coll) {
3078             return c.retainAll(coll);
3079         }
3080 
3081         public Iterator&lt;E&gt; iterator() {
3082             // JDK-6363904 - unwrapped iterator could be typecast to
3083             // ListIterator with unsafe set()
3084             final Iterator&lt;E&gt; it = c.iterator();
3085             return new Iterator&lt;E&gt;() {
3086                 public boolean hasNext() { return it.hasNext(); }
3087                 public E next()          { return it.next(); }
3088                 public void remove()     {        it.remove(); }
3089                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
3090                     it.forEachRemaining(action);
3091                 }
3092             };
3093         }
3094 
3095         public boolean add(E e)          { return c.add(typeCheck(e)); }
3096 

3097         private E[] zeroLengthElementArray; // Lazily initialized
3098 
3099         private E[] zeroLengthElementArray() {
3100             return zeroLengthElementArray != null ? zeroLengthElementArray :
3101                 (zeroLengthElementArray = zeroLengthArray(type));
3102         }
3103 
3104         @SuppressWarnings(&quot;unchecked&quot;)
3105         Collection&lt;E&gt; checkedCopyOf(Collection&lt;? extends E&gt; coll) {
3106             Object[] a;
3107             try {
3108                 E[] z = zeroLengthElementArray();
3109                 a = coll.toArray(z);
3110                 // Defend against coll violating the toArray contract
3111                 if (a.getClass() != z.getClass())
3112                     a = Arrays.copyOf(a, a.length, z.getClass());
3113             } catch (ArrayStoreException ignore) {
3114                 // To get better and consistent diagnostics,
3115                 // we call typeCheck explicitly on each element.
3116                 // We call clone() to defend against coll retaining a
</pre>
<hr />
<pre>
3168      * whenever the backing queue does.
3169      *
3170      * @param &lt;E&gt; the class of the objects in the queue
3171      * @param queue the queue for which a dynamically typesafe view is to be
3172      *             returned
3173      * @param type the type of element that {@code queue} is permitted to hold
3174      * @return a dynamically typesafe view of the specified queue
3175      * @since 1.8
3176      */
3177     public static &lt;E&gt; Queue&lt;E&gt; checkedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; type) {
3178         return new CheckedQueue&lt;&gt;(queue, type);
3179     }
3180 
3181     /**
3182      * @serial include
3183      */
3184     static class CheckedQueue&lt;E&gt;
3185         extends CheckedCollection&lt;E&gt;
3186         implements Queue&lt;E&gt;, Serializable
3187     {

3188         private static final long serialVersionUID = 1433151992604707767L;

3189         final Queue&lt;E&gt; queue;
3190 
3191         CheckedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; elementType) {
3192             super(queue, elementType);
3193             this.queue = queue;
3194         }
3195 
3196         public E element()              {return queue.element();}
3197         public boolean equals(Object o) {return o == this || c.equals(o);}
3198         public int hashCode()           {return c.hashCode();}
3199         public E peek()                 {return queue.peek();}
3200         public E poll()                 {return queue.poll();}
3201         public E remove()               {return queue.remove();}
3202         public boolean offer(E e)       {return queue.offer(typeCheck(e));}
3203     }
3204 
3205     /**
3206      * Returns a dynamically typesafe view of the specified set.
3207      * Any attempt to insert an element of the wrong type will result in
3208      * an immediate {@link ClassCastException}.  Assuming a set contains
</pre>
<hr />
<pre>
3222      * type, the returned set permits insertion of null elements whenever
3223      * the backing set does.
3224      *
3225      * @param &lt;E&gt; the class of the objects in the set
3226      * @param s the set for which a dynamically typesafe view is to be
3227      *          returned
3228      * @param type the type of element that {@code s} is permitted to hold
3229      * @return a dynamically typesafe view of the specified set
3230      * @since 1.5
3231      */
3232     public static &lt;E&gt; Set&lt;E&gt; checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type) {
3233         return new CheckedSet&lt;&gt;(s, type);
3234     }
3235 
3236     /**
3237      * @serial include
3238      */
3239     static class CheckedSet&lt;E&gt; extends CheckedCollection&lt;E&gt;
3240                                  implements Set&lt;E&gt;, Serializable
3241     {

3242         private static final long serialVersionUID = 4694047833775013803L;
3243 
3244         CheckedSet(Set&lt;E&gt; s, Class&lt;E&gt; elementType) { super(s, elementType); }
3245 
3246         public boolean equals(Object o) { return o == this || c.equals(o); }
3247         public int hashCode()           { return c.hashCode(); }
3248     }
3249 
3250     /**
3251      * Returns a dynamically typesafe view of the specified sorted set.
3252      * Any attempt to insert an element of the wrong type will result in an
3253      * immediate {@link ClassCastException}.  Assuming a sorted set
3254      * contains no incorrectly typed elements prior to the time a
3255      * dynamically typesafe view is generated, and that all subsequent
3256      * access to the sorted set takes place through the view, it is
3257      * &lt;i&gt;guaranteed&lt;/i&gt; that the sorted set cannot contain an incorrectly
3258      * typed element.
3259      *
3260      * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
3261      * found in the documentation for the {@link #checkedCollection
</pre>
<hr />
<pre>
3269      * whenever the backing sorted set does.
3270      *
3271      * @param &lt;E&gt; the class of the objects in the set
3272      * @param s the sorted set for which a dynamically typesafe view is to be
3273      *          returned
3274      * @param type the type of element that {@code s} is permitted to hold
3275      * @return a dynamically typesafe view of the specified sorted set
3276      * @since 1.5
3277      */
3278     public static &lt;E&gt; SortedSet&lt;E&gt; checkedSortedSet(SortedSet&lt;E&gt; s,
3279                                                     Class&lt;E&gt; type) {
3280         return new CheckedSortedSet&lt;&gt;(s, type);
3281     }
3282 
3283     /**
3284      * @serial include
3285      */
3286     static class CheckedSortedSet&lt;E&gt; extends CheckedSet&lt;E&gt;
3287         implements SortedSet&lt;E&gt;, Serializable
3288     {

3289         private static final long serialVersionUID = 1599911165492914959L;
3290 

3291         private final SortedSet&lt;E&gt; ss;
3292 
3293         CheckedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type) {
3294             super(s, type);
3295             ss = s;
3296         }
3297 
3298         public Comparator&lt;? super E&gt; comparator() { return ss.comparator(); }
3299         public E first()                   { return ss.first(); }
3300         public E last()                    { return ss.last(); }
3301 
3302         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
3303             return checkedSortedSet(ss.subSet(fromElement,toElement), type);
3304         }
3305         public SortedSet&lt;E&gt; headSet(E toElement) {
3306             return checkedSortedSet(ss.headSet(toElement), type);
3307         }
3308         public SortedSet&lt;E&gt; tailSet(E fromElement) {
3309             return checkedSortedSet(ss.tailSet(fromElement), type);
3310         }
</pre>
<hr />
<pre>
3332      * whenever the backing sorted set does.
3333      *
3334      * @param &lt;E&gt; the class of the objects in the set
3335      * @param s the navigable set for which a dynamically typesafe view is to be
3336      *          returned
3337      * @param type the type of element that {@code s} is permitted to hold
3338      * @return a dynamically typesafe view of the specified navigable set
3339      * @since 1.8
3340      */
3341     public static &lt;E&gt; NavigableSet&lt;E&gt; checkedNavigableSet(NavigableSet&lt;E&gt; s,
3342                                                     Class&lt;E&gt; type) {
3343         return new CheckedNavigableSet&lt;&gt;(s, type);
3344     }
3345 
3346     /**
3347      * @serial include
3348      */
3349     static class CheckedNavigableSet&lt;E&gt; extends CheckedSortedSet&lt;E&gt;
3350         implements NavigableSet&lt;E&gt;, Serializable
3351     {

3352         private static final long serialVersionUID = -5429120189805438922L;
3353 

3354         private final NavigableSet&lt;E&gt; ns;
3355 
3356         CheckedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type) {
3357             super(s, type);
3358             ns = s;
3359         }
3360 
3361         public E lower(E e)                             { return ns.lower(e); }
3362         public E floor(E e)                             { return ns.floor(e); }
3363         public E ceiling(E e)                         { return ns.ceiling(e); }
3364         public E higher(E e)                           { return ns.higher(e); }
3365         public E pollFirst()                         { return ns.pollFirst(); }
3366         public E pollLast()                            {return ns.pollLast(); }
3367         public NavigableSet&lt;E&gt; descendingSet()
3368                       { return checkedNavigableSet(ns.descendingSet(), type); }
3369         public Iterator&lt;E&gt; descendingIterator()
3370             {return checkedNavigableSet(ns.descendingSet(), type).iterator(); }
3371 
3372         public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
3373             return checkedNavigableSet(ns.subSet(fromElement, true, toElement, false), type);
</pre>
<hr />
<pre>
3415      * @param &lt;E&gt; the class of the objects in the list
3416      * @param list the list for which a dynamically typesafe view is to be
3417      *             returned
3418      * @param type the type of element that {@code list} is permitted to hold
3419      * @return a dynamically typesafe view of the specified list
3420      * @since 1.5
3421      */
3422     public static &lt;E&gt; List&lt;E&gt; checkedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3423         return (list instanceof RandomAccess ?
3424                 new CheckedRandomAccessList&lt;&gt;(list, type) :
3425                 new CheckedList&lt;&gt;(list, type));
3426     }
3427 
3428     /**
3429      * @serial include
3430      */
3431     static class CheckedList&lt;E&gt;
3432         extends CheckedCollection&lt;E&gt;
3433         implements List&lt;E&gt;
3434     {

3435         private static final long serialVersionUID = 65247728283967356L;

3436         final List&lt;E&gt; list;
3437 
3438         CheckedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3439             super(list, type);
3440             this.list = list;
3441         }
3442 
3443         public boolean equals(Object o)  { return o == this || list.equals(o); }
3444         public int hashCode()            { return list.hashCode(); }
3445         public E get(int index)          { return list.get(index); }
3446         public E remove(int index)       { return list.remove(index); }
3447         public int indexOf(Object o)     { return list.indexOf(o); }
3448         public int lastIndexOf(Object o) { return list.lastIndexOf(o); }
3449 
3450         public E set(int index, E element) {
3451             return list.set(index, typeCheck(element));
3452         }
3453 
3454         public void add(int index, E element) {
3455             list.add(index, typeCheck(element));
</pre>
<hr />
<pre>
3500          *         already been replaced.
3501          */
3502         @Override
3503         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
3504             Objects.requireNonNull(operator);
3505             list.replaceAll(e -&gt; typeCheck(operator.apply(e)));
3506         }
3507 
3508         @Override
3509         public void sort(Comparator&lt;? super E&gt; c) {
3510             list.sort(c);
3511         }
3512     }
3513 
3514     /**
3515      * @serial include
3516      */
3517     static class CheckedRandomAccessList&lt;E&gt; extends CheckedList&lt;E&gt;
3518                                             implements RandomAccess
3519     {

3520         private static final long serialVersionUID = 1638200125423088369L;
3521 
3522         CheckedRandomAccessList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3523             super(list, type);
3524         }
3525 
3526         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
3527             return new CheckedRandomAccessList&lt;&gt;(
3528                     list.subList(fromIndex, toIndex), type);
3529         }
3530     }
3531 
3532     /**
3533      * Returns a dynamically typesafe view of the specified map.
3534      * Any attempt to insert a mapping whose key or value have the wrong
3535      * type will result in an immediate {@link ClassCastException}.
3536      * Similarly, any attempt to modify the value currently associated with
3537      * a key will result in an immediate {@link ClassCastException},
3538      * whether the modification is attempted directly through the map
3539      * itself, or through a {@link Map.Entry} instance obtained from the
</pre>
<hr />
<pre>
3561      * @param m the map for which a dynamically typesafe view is to be
3562      *          returned
3563      * @param keyType the type of key that {@code m} is permitted to hold
3564      * @param valueType the type of value that {@code m} is permitted to hold
3565      * @return a dynamically typesafe view of the specified map
3566      * @since 1.5
3567      */
3568     public static &lt;K, V&gt; Map&lt;K, V&gt; checkedMap(Map&lt;K, V&gt; m,
3569                                               Class&lt;K&gt; keyType,
3570                                               Class&lt;V&gt; valueType) {
3571         return new CheckedMap&lt;&gt;(m, keyType, valueType);
3572     }
3573 
3574 
3575     /**
3576      * @serial include
3577      */
3578     private static class CheckedMap&lt;K,V&gt;
3579         implements Map&lt;K,V&gt;, Serializable
3580     {

3581         private static final long serialVersionUID = 5742860141034234728L;
3582 

3583         private final Map&lt;K, V&gt; m;

3584         final Class&lt;K&gt; keyType;

3585         final Class&lt;V&gt; valueType;
3586 
3587         private void typeCheck(Object key, Object value) {
3588             if (key != null &amp;&amp; !keyType.isInstance(key))
3589                 throw new ClassCastException(badKeyMsg(key));
3590 
3591             if (value != null &amp;&amp; !valueType.isInstance(value))
3592                 throw new ClassCastException(badValueMsg(value));
3593         }
3594 
3595         private BiFunction&lt;? super K, ? super V, ? extends V&gt; typeCheck(
3596                 BiFunction&lt;? super K, ? super V, ? extends V&gt; func) {
3597             Objects.requireNonNull(func);
3598             return (k, v) -&gt; {
3599                 V newValue = func.apply(k, v);
3600                 typeCheck(k, newValue);
3601                 return newValue;
3602             };
3603         }
3604 
</pre>
<hr />
<pre>
3960      * @param &lt;V&gt; the class of the map values
3961      * @param m the map for which a dynamically typesafe view is to be
3962      *          returned
3963      * @param keyType the type of key that {@code m} is permitted to hold
3964      * @param valueType the type of value that {@code m} is permitted to hold
3965      * @return a dynamically typesafe view of the specified map
3966      * @since 1.5
3967      */
3968     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; checkedSortedMap(SortedMap&lt;K, V&gt; m,
3969                                                         Class&lt;K&gt; keyType,
3970                                                         Class&lt;V&gt; valueType) {
3971         return new CheckedSortedMap&lt;&gt;(m, keyType, valueType);
3972     }
3973 
3974     /**
3975      * @serial include
3976      */
3977     static class CheckedSortedMap&lt;K,V&gt; extends CheckedMap&lt;K,V&gt;
3978         implements SortedMap&lt;K,V&gt;, Serializable
3979     {

3980         private static final long serialVersionUID = 1599671320688067438L;
3981 

3982         private final SortedMap&lt;K, V&gt; sm;
3983 
3984         CheckedSortedMap(SortedMap&lt;K, V&gt; m,
3985                          Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
3986             super(m, keyType, valueType);
3987             sm = m;
3988         }
3989 
3990         public Comparator&lt;? super K&gt; comparator() { return sm.comparator(); }
3991         public K firstKey()                       { return sm.firstKey(); }
3992         public K lastKey()                        { return sm.lastKey(); }
3993 
3994         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
3995             return checkedSortedMap(sm.subMap(fromKey, toKey),
3996                                     keyType, valueType);
3997         }
3998         public SortedMap&lt;K,V&gt; headMap(K toKey) {
3999             return checkedSortedMap(sm.headMap(toKey), keyType, valueType);
4000         }
4001         public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
</pre>
<hr />
<pre>
4034      * @param &lt;V&gt; type of map values
4035      * @param m the map for which a dynamically typesafe view is to be
4036      *          returned
4037      * @param keyType the type of key that {@code m} is permitted to hold
4038      * @param valueType the type of value that {@code m} is permitted to hold
4039      * @return a dynamically typesafe view of the specified map
4040      * @since 1.8
4041      */
4042     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; checkedNavigableMap(NavigableMap&lt;K, V&gt; m,
4043                                                         Class&lt;K&gt; keyType,
4044                                                         Class&lt;V&gt; valueType) {
4045         return new CheckedNavigableMap&lt;&gt;(m, keyType, valueType);
4046     }
4047 
4048     /**
4049      * @serial include
4050      */
4051     static class CheckedNavigableMap&lt;K,V&gt; extends CheckedSortedMap&lt;K,V&gt;
4052         implements NavigableMap&lt;K,V&gt;, Serializable
4053     {

4054         private static final long serialVersionUID = -4852462692372534096L;
4055 

4056         private final NavigableMap&lt;K, V&gt; nm;
4057 
4058         CheckedNavigableMap(NavigableMap&lt;K, V&gt; m,
4059                          Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
4060             super(m, keyType, valueType);
4061             nm = m;
4062         }
4063 
4064         public Comparator&lt;? super K&gt; comparator()   { return nm.comparator(); }
4065         public K firstKey()                           { return nm.firstKey(); }
4066         public K lastKey()                             { return nm.lastKey(); }
4067 
4068         public Entry&lt;K, V&gt; lowerEntry(K key) {
4069             Entry&lt;K,V&gt; lower = nm.lowerEntry(key);
4070             return (null != lower)
4071                 ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(lower, valueType)
4072                 : null;
4073         }
4074 
4075         public K lowerKey(K key)                   { return nm.lowerKey(key); }
</pre>
<hr />
<pre>
4312      * field does not provide type safety.)
4313      *
4314      * @param  &lt;T&gt; the class of the objects in the set
4315      * @return the empty set
4316      *
4317      * @see #EMPTY_SET
4318      * @since 1.5
4319      */
4320     @SuppressWarnings(&quot;unchecked&quot;)
4321     public static final &lt;T&gt; Set&lt;T&gt; emptySet() {
4322         return (Set&lt;T&gt;) EMPTY_SET;
4323     }
4324 
4325     /**
4326      * @serial include
4327      */
4328     private static class EmptySet&lt;E&gt;
4329         extends AbstractSet&lt;E&gt;
4330         implements Serializable
4331     {

4332         private static final long serialVersionUID = 1582296315990362920L;
4333 
4334         public Iterator&lt;E&gt; iterator() { return emptyIterator(); }
4335 
4336         public int size() {return 0;}
4337         public boolean isEmpty() {return true;}
4338         public void clear() {}
4339 
4340         public boolean contains(Object obj) {return false;}
4341         public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }
4342 
4343         public Object[] toArray() { return new Object[0]; }
4344 
4345         public &lt;T&gt; T[] toArray(T[] a) {
4346             if (a.length &gt; 0)
4347                 a[0] = null;
4348             return a;
4349         }
4350 
4351         // Override default methods in Collection
4352         @Override
4353         public void forEach(Consumer&lt;? super E&gt; action) {
4354             Objects.requireNonNull(action);
4355         }
4356         @Override
4357         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
4358             Objects.requireNonNull(filter);
4359             return false;
4360         }
4361         @Override
4362         public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
4363 
4364         // Preserves singleton property

4365         private Object readResolve() {
4366             return EMPTY_SET;
4367         }
4368 
4369         @Override
4370         public int hashCode() {
4371             return 0;
4372         }
4373     }
4374 
4375     /**
4376      * Returns an empty sorted set (immutable).  This set is serializable.
4377      *
4378      * &lt;p&gt;This example illustrates the type-safe way to obtain an empty
4379      * sorted set:
4380      * &lt;pre&gt; {@code
4381      *     SortedSet&lt;String&gt; s = Collections.emptySortedSet();
4382      * }&lt;/pre&gt;
4383      *
4384      * @implNote Implementations of this method need not create a separate
</pre>
<hr />
<pre>
4436      * cost to using the like-named field.  (Unlike this method, the field does
4437      * not provide type safety.)
4438      *
4439      * @param &lt;T&gt; type of elements, if there were any, in the list
4440      * @return an empty immutable list
4441      *
4442      * @see #EMPTY_LIST
4443      * @since 1.5
4444      */
4445     @SuppressWarnings(&quot;unchecked&quot;)
4446     public static final &lt;T&gt; List&lt;T&gt; emptyList() {
4447         return (List&lt;T&gt;) EMPTY_LIST;
4448     }
4449 
4450     /**
4451      * @serial include
4452      */
4453     private static class EmptyList&lt;E&gt;
4454         extends AbstractList&lt;E&gt;
4455         implements RandomAccess, Serializable {

4456         private static final long serialVersionUID = 8842843931221139166L;
4457 
4458         public Iterator&lt;E&gt; iterator() {
4459             return emptyIterator();
4460         }
4461         public ListIterator&lt;E&gt; listIterator() {
4462             return emptyListIterator();
4463         }
4464 
4465         public int size() {return 0;}
4466         public boolean isEmpty() {return true;}
4467         public void clear() {}
4468 
4469         public boolean contains(Object obj) {return false;}
4470         public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }
4471 
4472         public Object[] toArray() { return new Object[0]; }
4473 
4474         public &lt;T&gt; T[] toArray(T[] a) {
4475             if (a.length &gt; 0)
</pre>
<hr />
<pre>
4493             return false;
4494         }
4495         @Override
4496         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
4497             Objects.requireNonNull(operator);
4498         }
4499         @Override
4500         public void sort(Comparator&lt;? super E&gt; c) {
4501         }
4502 
4503         // Override default methods in Collection
4504         @Override
4505         public void forEach(Consumer&lt;? super E&gt; action) {
4506             Objects.requireNonNull(action);
4507         }
4508 
4509         @Override
4510         public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
4511 
4512         // Preserves singleton property

4513         private Object readResolve() {
4514             return EMPTY_LIST;
4515         }
4516     }
4517 
4518     /**
4519      * The empty map (immutable).  This map is serializable.
4520      *
4521      * @see #emptyMap()
4522      * @since 1.3
4523      */
4524     @SuppressWarnings(&quot;rawtypes&quot;)
4525     public static final Map EMPTY_MAP = new EmptyMap&lt;&gt;();
4526 
4527     /**
4528      * Returns an empty map (immutable).  This map is serializable.
4529      *
4530      * &lt;p&gt;This example illustrates the type-safe way to obtain an empty map:
4531      * &lt;pre&gt;
4532      *     Map&amp;lt;String, Date&amp;gt; s = Collections.emptyMap();
</pre>
<hr />
<pre>
4579      * @implNote Implementations of this method need not create a separate
4580      * {@code NavigableMap} object for each call.
4581      *
4582      * @param &lt;K&gt; the class of the map keys
4583      * @param &lt;V&gt; the class of the map values
4584      * @return an empty navigable map
4585      * @since 1.8
4586      */
4587     @SuppressWarnings(&quot;unchecked&quot;)
4588     public static final &lt;K,V&gt; NavigableMap&lt;K,V&gt; emptyNavigableMap() {
4589         return (NavigableMap&lt;K,V&gt;) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;
4590     }
4591 
4592     /**
4593      * @serial include
4594      */
4595     private static class EmptyMap&lt;K,V&gt;
4596         extends AbstractMap&lt;K,V&gt;
4597         implements Serializable
4598     {

4599         private static final long serialVersionUID = 6428348081105594320L;
4600 
4601         public int size()                          {return 0;}
4602         public boolean isEmpty()                   {return true;}
4603         public void clear()                        {}
4604         public boolean containsKey(Object key)     {return false;}
4605         public boolean containsValue(Object value) {return false;}
4606         public V get(Object key)                   {return null;}
4607         public Set&lt;K&gt; keySet()                     {return emptySet();}
4608         public Collection&lt;V&gt; values()              {return emptySet();}
4609         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()      {return emptySet();}
4610 
4611         public boolean equals(Object o) {
4612             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
4613         }
4614 
4615         public int hashCode()                      {return 0;}
4616 
4617         // Override default methods in Map
4618         @Override
</pre>
<hr />
<pre>
4659 
4660         @Override
4661         public V computeIfPresent(K key,
4662                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
4663             throw new UnsupportedOperationException();
4664         }
4665 
4666         @Override
4667         public V compute(K key,
4668                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
4669             throw new UnsupportedOperationException();
4670         }
4671 
4672         @Override
4673         public V merge(K key, V value,
4674                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
4675             throw new UnsupportedOperationException();
4676         }
4677 
4678         // Preserves singleton property

4679         private Object readResolve() {
4680             return EMPTY_MAP;
4681         }
4682     }
4683 
4684     // Singleton collections
4685 
4686     /**
4687      * Returns an immutable set containing only the specified object.
4688      * The returned set is serializable.
4689      *
4690      * @param  &lt;T&gt; the class of the objects in the set
4691      * @param o the sole object to be stored in the returned set.
4692      * @return an immutable set containing only the specified object.
4693      */
4694     public static &lt;T&gt; Set&lt;T&gt; singleton(T o) {
4695         return new SingletonSet&lt;&gt;(o);
4696     }
4697 
4698     static &lt;E&gt; Iterator&lt;E&gt; singletonIterator(final E e) {
</pre>
<hr />
<pre>
4758                 return est;
4759             }
4760 
4761             @Override
4762             public int characteristics() {
4763                 int value = (element != null) ? Spliterator.NONNULL : 0;
4764 
4765                 return value | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE |
4766                        Spliterator.DISTINCT | Spliterator.ORDERED;
4767             }
4768         };
4769     }
4770 
4771     /**
4772      * @serial include
4773      */
4774     private static class SingletonSet&lt;E&gt;
4775         extends AbstractSet&lt;E&gt;
4776         implements Serializable
4777     {

4778         private static final long serialVersionUID = 3193687207550431679L;
4779 

4780         private final E element;
4781 
4782         SingletonSet(E e) {element = e;}
4783 
4784         public Iterator&lt;E&gt; iterator() {
4785             return singletonIterator(element);
4786         }
4787 
4788         public int size() {return 1;}
4789 
4790         public boolean contains(Object o) {return eq(o, element);}
4791 
4792         // Override default methods for Collection
4793         @Override
4794         public void forEach(Consumer&lt;? super E&gt; action) {
4795             action.accept(element);
4796         }
4797         @Override
4798         public Spliterator&lt;E&gt; spliterator() {
4799             return singletonSpliterator(element);
</pre>
<hr />
<pre>
4811     /**
4812      * Returns an immutable list containing only the specified object.
4813      * The returned list is serializable.
4814      *
4815      * @param  &lt;T&gt; the class of the objects in the list
4816      * @param o the sole object to be stored in the returned list.
4817      * @return an immutable list containing only the specified object.
4818      * @since 1.3
4819      */
4820     public static &lt;T&gt; List&lt;T&gt; singletonList(T o) {
4821         return new SingletonList&lt;&gt;(o);
4822     }
4823 
4824     /**
4825      * @serial include
4826      */
4827     private static class SingletonList&lt;E&gt;
4828         extends AbstractList&lt;E&gt;
4829         implements RandomAccess, Serializable {
4830 

4831         private static final long serialVersionUID = 3093736618740652951L;
4832 

4833         private final E element;
4834 
4835         SingletonList(E obj)                {element = obj;}
4836 
4837         public Iterator&lt;E&gt; iterator() {
4838             return singletonIterator(element);
4839         }
4840 
4841         public int size()                   {return 1;}
4842 
4843         public boolean contains(Object obj) {return eq(obj, element);}
4844 
4845         public E get(int index) {
4846             if (index != 0)
4847               throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: 1&quot;);
4848             return element;
4849         }
4850 
4851         // Override default methods for Collection
4852         @Override
</pre>
<hr />
<pre>
4879      * specified value.  The returned map is serializable.
4880      *
4881      * @param &lt;K&gt; the class of the map keys
4882      * @param &lt;V&gt; the class of the map values
4883      * @param key the sole key to be stored in the returned map.
4884      * @param value the value to which the returned map maps {@code key}.
4885      * @return an immutable map containing only the specified key-value
4886      *         mapping.
4887      * @since 1.3
4888      */
4889     public static &lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value) {
4890         return new SingletonMap&lt;&gt;(key, value);
4891     }
4892 
4893     /**
4894      * @serial include
4895      */
4896     private static class SingletonMap&lt;K,V&gt;
4897           extends AbstractMap&lt;K,V&gt;
4898           implements Serializable {

4899         private static final long serialVersionUID = -6979724477215052911L;
4900 

4901         private final K k;

4902         private final V v;
4903 
4904         SingletonMap(K key, V value) {
4905             k = key;
4906             v = value;
4907         }
4908 
4909         public int size()                                           {return 1;}
4910         public boolean isEmpty()                                {return false;}
4911         public boolean containsKey(Object key)             {return eq(key, k);}
4912         public boolean containsValue(Object value)       {return eq(value, v);}
4913         public V get(Object key)              {return (eq(key, k) ? v : null);}
4914 
4915         private transient Set&lt;K&gt; keySet;
4916         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
4917         private transient Collection&lt;V&gt; values;
4918 
4919         public Set&lt;K&gt; keySet() {
4920             if (keySet==null)
4921                 keySet = singleton(k);
</pre>
<hr />
<pre>
5016      * @param  o the element to appear repeatedly in the returned list.
5017      * @return an immutable list consisting of {@code n} copies of the
5018      *         specified object.
5019      * @throws IllegalArgumentException if {@code n &lt; 0}
5020      * @see    List#addAll(Collection)
5021      * @see    List#addAll(int, Collection)
5022      */
5023     public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o) {
5024         if (n &lt; 0)
5025             throw new IllegalArgumentException(&quot;List length = &quot; + n);
5026         return new CopiesList&lt;&gt;(n, o);
5027     }
5028 
5029     /**
5030      * @serial include
5031      */
5032     private static class CopiesList&lt;E&gt;
5033         extends AbstractList&lt;E&gt;
5034         implements RandomAccess, Serializable
5035     {

5036         private static final long serialVersionUID = 2739099268398711800L;
5037 
5038         final int n;

5039         final E element;
5040 
5041         CopiesList(int n, E e) {
5042             assert n &gt;= 0;
5043             this.n = n;
5044             element = e;
5045         }
5046 
5047         public int size() {
5048             return n;
5049         }
5050 
5051         public boolean contains(Object obj) {
5052             return n != 0 &amp;&amp; eq(obj, element);
5053         }
5054 
5055         public int indexOf(Object o) {
5056             return contains(o) ? 0 : -1;
5057         }
5058 
</pre>
<hr />
<pre>
5146                 }
5147             }
5148             return remaining == 0 &amp;&amp; !itr.hasNext();
5149         }
5150 
5151         // Override default methods in Collection
5152         @Override
5153         public Stream&lt;E&gt; stream() {
5154             return IntStream.range(0, n).mapToObj(i -&gt; element);
5155         }
5156 
5157         @Override
5158         public Stream&lt;E&gt; parallelStream() {
5159             return IntStream.range(0, n).parallel().mapToObj(i -&gt; element);
5160         }
5161 
5162         @Override
5163         public Spliterator&lt;E&gt; spliterator() {
5164             return stream().spliterator();
5165         }






5166     }
5167 
5168     /**
5169      * Returns a comparator that imposes the reverse of the &lt;em&gt;natural
5170      * ordering&lt;/em&gt; on a collection of objects that implement the
5171      * {@code Comparable} interface.  (The natural ordering is the ordering
5172      * imposed by the objects&#39; own {@code compareTo} method.)  This enables a
5173      * simple idiom for sorting (or maintaining) collections (or arrays) of
5174      * objects that implement the {@code Comparable} interface in
5175      * reverse-natural-order.  For example, suppose {@code a} is an array of
5176      * strings. Then: &lt;pre&gt;
5177      *          Arrays.sort(a, Collections.reverseOrder());
5178      * &lt;/pre&gt; sorts the array in reverse-lexicographic (alphabetical) order.&lt;p&gt;
5179      *
5180      * The returned comparator is serializable.
5181      *
5182      * @param  &lt;T&gt; the class of the objects compared by the comparator
5183      * @return A comparator that imposes the reverse of the &lt;i&gt;natural
5184      *         ordering&lt;/i&gt; on a collection of objects that implement
5185      *         the {@code Comparable} interface.
5186      * @see Comparable
5187      */
5188     @SuppressWarnings(&quot;unchecked&quot;)
5189     public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() {
5190         return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5191     }
5192 
5193     /**
5194      * @serial include
5195      */
5196     private static class ReverseComparator
5197         implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {
5198 

5199         private static final long serialVersionUID = 7207038068494060240L;
5200 
5201         static final ReverseComparator REVERSE_ORDER
5202             = new ReverseComparator();
5203 
5204         public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {
5205             return c2.compareTo(c1);
5206         }
5207 

5208         private Object readResolve() { return Collections.reverseOrder(); }
5209 
5210         @Override
5211         public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {
5212             return Comparator.naturalOrder();
5213         }
5214     }
5215 
5216     /**
5217      * Returns a comparator that imposes the reverse ordering of the specified
5218      * comparator.  If the specified comparator is {@code null}, this method is
5219      * equivalent to {@link #reverseOrder()} (in other words, it returns a
5220      * comparator that imposes the reverse of the &lt;em&gt;natural ordering&lt;/em&gt; on
5221      * a collection of objects that implement the Comparable interface).
5222      *
5223      * &lt;p&gt;The returned comparator is serializable (assuming the specified
5224      * comparator is also serializable or {@code null}).
5225      *
5226      * @param &lt;T&gt; the class of the objects compared by the comparator
5227      * @param cmp a comparator who&#39;s ordering is to be reversed by the returned
</pre>
<hr />
<pre>
5234     public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) {
5235         if (cmp == null) {
5236             return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5237         } else if (cmp == ReverseComparator.REVERSE_ORDER) {
5238             return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;
5239         } else if (cmp == Comparators.NaturalOrderComparator.INSTANCE) {
5240             return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5241         } else if (cmp instanceof ReverseComparator2) {
5242             return ((ReverseComparator2&lt;T&gt;) cmp).cmp;
5243         } else {
5244             return new ReverseComparator2&lt;&gt;(cmp);
5245         }
5246     }
5247 
5248     /**
5249      * @serial include
5250      */
5251     private static class ReverseComparator2&lt;T&gt; implements Comparator&lt;T&gt;,
5252         Serializable
5253     {

5254         private static final long serialVersionUID = 4374092139857L;
5255 
5256         /**
5257          * The comparator specified in the static factory.  This will never
5258          * be null, as the static factory returns a ReverseComparator
5259          * instance if its argument is null.
5260          *
5261          * @serial
5262          */

5263         final Comparator&lt;T&gt; cmp;
5264 
5265         ReverseComparator2(Comparator&lt;T&gt; cmp) {
5266             assert cmp != null;
5267             this.cmp = cmp;
5268         }
5269 
5270         public int compare(T t1, T t2) {
5271             return cmp.compare(t2, t1);
5272         }
5273 
5274         public boolean equals(Object o) {
5275             return (o == this) ||
5276                 (o instanceof ReverseComparator2 &amp;&amp;
5277                  cmp.equals(((ReverseComparator2)o).cmp));
5278         }
5279 
5280         public int hashCode() {
5281             return cmp.hashCode() ^ Integer.MIN_VALUE;
5282         }
</pre>
<hr />
<pre>
5524      *        new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());
5525      * &lt;/pre&gt;
5526      *
5527      * @param &lt;E&gt; the class of the map keys and of the objects in the
5528      *        returned set
5529      * @param map the backing map
5530      * @return the set backed by the map
5531      * @throws IllegalArgumentException if {@code map} is not empty
5532      * @since 1.6
5533      */
5534     public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
5535         return new SetFromMap&lt;&gt;(map);
5536     }
5537 
5538     /**
5539      * @serial include
5540      */
5541     private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
5542         implements Set&lt;E&gt;, Serializable
5543     {

5544         private final Map&lt;E, Boolean&gt; m;  // The backing map
5545         private transient Set&lt;E&gt; s;       // Its keySet
5546 
5547         SetFromMap(Map&lt;E, Boolean&gt; map) {
5548             if (!map.isEmpty())
5549                 throw new IllegalArgumentException(&quot;Map is non-empty&quot;);
5550             m = map;
5551             s = map.keySet();
5552         }
5553 
5554         public void clear()               {        m.clear(); }
5555         public int size()                 { return m.size(); }
5556         public boolean isEmpty()          { return m.isEmpty(); }
5557         public boolean contains(Object o) { return m.containsKey(o); }
5558         public boolean remove(Object o)   { return m.remove(o) != null; }
5559         public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }
5560         public Iterator&lt;E&gt; iterator()     { return s.iterator(); }
5561         public Object[] toArray()         { return s.toArray(); }
5562         public &lt;T&gt; T[] toArray(T[] a)     { return s.toArray(a); }
5563         public String toString()          { return s.toString(); }
</pre>
<hr />
<pre>
5568         public boolean retainAll(Collection&lt;?&gt; c)   {return s.retainAll(c);}
5569         // addAll is the only inherited implementation
5570 
5571         // Override default methods in Collection
5572         @Override
5573         public void forEach(Consumer&lt;? super E&gt; action) {
5574             s.forEach(action);
5575         }
5576         @Override
5577         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
5578             return s.removeIf(filter);
5579         }
5580 
5581         @Override
5582         public Spliterator&lt;E&gt; spliterator() {return s.spliterator();}
5583         @Override
5584         public Stream&lt;E&gt; stream()           {return s.stream();}
5585         @Override
5586         public Stream&lt;E&gt; parallelStream()   {return s.parallelStream();}
5587 

5588         private static final long serialVersionUID = 2454657854757543876L;
5589 

5590         private void readObject(java.io.ObjectInputStream stream)
5591             throws IOException, ClassNotFoundException
5592         {
5593             stream.defaultReadObject();
5594             s = m.keySet();
5595         }
5596     }
5597 
5598     /**
5599      * Returns a view of a {@link Deque} as a Last-in-first-out (Lifo)
5600      * {@link Queue}. Method {@code add} is mapped to {@code push},
5601      * {@code remove} is mapped to {@code pop} and so on. This
5602      * view can be useful when you would like to use a method
5603      * requiring a {@code Queue} but you need Lifo ordering.
5604      *
5605      * &lt;p&gt;Each method invocation on the queue returned by this method
5606      * results in exactly one method invocation on the backing deque, with
5607      * one exception.  The {@link Queue#addAll addAll} method is
5608      * implemented as a sequence of {@link Deque#addFirst addFirst}
5609      * invocations on the backing deque.
5610      *
5611      * @param  &lt;T&gt; the class of the objects in the deque
5612      * @param deque the deque
5613      * @return the queue
5614      * @since  1.6
5615      */
5616     public static &lt;T&gt; Queue&lt;T&gt; asLifoQueue(Deque&lt;T&gt; deque) {
5617         return new AsLIFOQueue&lt;&gt;(Objects.requireNonNull(deque));
5618     }
5619 
5620     /**
5621      * @serial include
5622      */
5623     static class AsLIFOQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
5624         implements Queue&lt;E&gt;, Serializable {

5625         private static final long serialVersionUID = 1802017725587941708L;

5626         private final Deque&lt;E&gt; q;
5627         AsLIFOQueue(Deque&lt;E&gt; q)                     { this.q = q; }
5628         public boolean add(E e)                     { q.addFirst(e); return true; }
5629         public boolean offer(E e)                   { return q.offerFirst(e); }
5630         public E poll()                             { return q.pollFirst(); }
5631         public E remove()                           { return q.removeFirst(); }
5632         public E peek()                             { return q.peekFirst(); }
5633         public E element()                          { return q.getFirst(); }
5634         public void clear()                         {        q.clear(); }
5635         public int size()                           { return q.size(); }
5636         public boolean isEmpty()                    { return q.isEmpty(); }
5637         public boolean contains(Object o)           { return q.contains(o); }
5638         public boolean remove(Object o)             { return q.remove(o); }
5639         public Iterator&lt;E&gt; iterator()               { return q.iterator(); }
5640         public Object[] toArray()                   { return q.toArray(); }
5641         public &lt;T&gt; T[] toArray(T[] a)               { return q.toArray(a); }
5642         public &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; f)  { return q.toArray(f); }
5643         public String toString()                    { return q.toString(); }
5644         public boolean containsAll(Collection&lt;?&gt; c) { return q.containsAll(c); }
5645         public boolean removeAll(Collection&lt;?&gt; c)   { return q.removeAll(c); }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;
<span class="line-added">  29 import java.io.ObjectInputStream;</span>
  30 import java.io.ObjectOutputStream;
  31 import java.io.Serializable;
  32 import java.lang.reflect.Array;
  33 import java.util.function.BiConsumer;
  34 import java.util.function.BiFunction;
  35 import java.util.function.Consumer;
  36 import java.util.function.Function;
  37 import java.util.function.IntFunction;
  38 import java.util.function.Predicate;
  39 import java.util.function.UnaryOperator;
  40 import java.util.stream.IntStream;
  41 import java.util.stream.Stream;
  42 import java.util.stream.StreamSupport;
<span class="line-added">  43 import jdk.internal.access.SharedSecrets;</span>
  44 
  45 /**
  46  * This class consists exclusively of static methods that operate on or return
  47  * collections.  It contains polymorphic algorithms that operate on
  48  * collections, &quot;wrappers&quot;, which return a new collection backed by a
  49  * specified collection, and a few other odds and ends.
  50  *
  51  * &lt;p&gt;The methods of this class all throw a {@code NullPointerException}
  52  * if the collections or class objects provided to them are null.
  53  *
  54  * &lt;p&gt;The documentation for the polymorphic algorithms contained in this class
  55  * generally includes a brief description of the &lt;i&gt;implementation&lt;/i&gt;.  Such
  56  * descriptions should be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than
  57  * parts of the &lt;i&gt;specification&lt;/i&gt;.  Implementors should feel free to
  58  * substitute other algorithms, so long as the specification itself is adhered
  59  * to.  (For example, the algorithm used by {@code sort} does not have to be
  60  * a mergesort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
  61  *
  62  * &lt;p&gt;The &quot;destructive&quot; algorithms contained in this class, that is, the
  63  * algorithms that modify the collection on which they operate, are specified
</pre>
<hr />
<pre>
1004      * {@code Object}&#39;s {@code equals} and {@code hashCode} methods.  This
1005      * is necessary to preserve the contracts of these operations in the case
1006      * that the backing collection is a set or a list.&lt;p&gt;
1007      *
1008      * The returned collection will be serializable if the specified collection
1009      * is serializable.
1010      *
1011      * @param  &lt;T&gt; the class of the objects in the collection
1012      * @param  c the collection for which an unmodifiable view is to be
1013      *         returned.
1014      * @return an unmodifiable view of the specified collection.
1015      */
1016     public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {
1017         return new UnmodifiableCollection&lt;&gt;(c);
1018     }
1019 
1020     /**
1021      * @serial include
1022      */
1023     static class UnmodifiableCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="line-added">1024         @java.io.Serial</span>
1025         private static final long serialVersionUID = 1820017752578914078L;
1026 
<span class="line-added">1027         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1028         final Collection&lt;? extends E&gt; c;
1029 
1030         UnmodifiableCollection(Collection&lt;? extends E&gt; c) {
1031             if (c==null)
1032                 throw new NullPointerException();
1033             this.c = c;
1034         }
1035 
1036         public int size()                          {return c.size();}
1037         public boolean isEmpty()                   {return c.isEmpty();}
1038         public boolean contains(Object o)          {return c.contains(o);}
1039         public Object[] toArray()                  {return c.toArray();}
1040         public &lt;T&gt; T[] toArray(T[] a)              {return c.toArray(a);}
1041         public &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; f) {return c.toArray(f);}
1042         public String toString()                   {return c.toString();}
1043 
1044         public Iterator&lt;E&gt; iterator() {
1045             return new Iterator&lt;E&gt;() {
1046                 private final Iterator&lt;? extends E&gt; i = c.iterator();
1047 
</pre>
<hr />
<pre>
1112      * specified set. Query operations on the returned set &quot;read through&quot; to the specified
1113      * set, and attempts to modify the returned set, whether direct or via its
1114      * iterator, result in an {@code UnsupportedOperationException}.&lt;p&gt;
1115      *
1116      * The returned set will be serializable if the specified set
1117      * is serializable.
1118      *
1119      * @param  &lt;T&gt; the class of the objects in the set
1120      * @param  s the set for which an unmodifiable view is to be returned.
1121      * @return an unmodifiable view of the specified set.
1122      */
1123     public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) {
1124         return new UnmodifiableSet&lt;&gt;(s);
1125     }
1126 
1127     /**
1128      * @serial include
1129      */
1130     static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
1131                                  implements Set&lt;E&gt;, Serializable {
<span class="line-added">1132         @java.io.Serial</span>
1133         private static final long serialVersionUID = -9215047833775013803L;
1134 
1135         UnmodifiableSet(Set&lt;? extends E&gt; s)     {super(s);}
1136         public boolean equals(Object o) {return o == this || c.equals(o);}
1137         public int hashCode()           {return c.hashCode();}
1138     }
1139 
1140     /**
1141      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1142      * specified sorted set. Query operations on the returned sorted set &quot;read
1143      * through&quot; to the specified sorted set.  Attempts to modify the returned
1144      * sorted set, whether direct, via its iterator, or via its
1145      * {@code subSet}, {@code headSet}, or {@code tailSet} views, result in
1146      * an {@code UnsupportedOperationException}.&lt;p&gt;
1147      *
1148      * The returned sorted set will be serializable if the specified sorted set
1149      * is serializable.
1150      *
1151      * @param  &lt;T&gt; the class of the objects in the set
1152      * @param s the sorted set for which an unmodifiable view is to be
1153      *        returned.
1154      * @return an unmodifiable view of the specified sorted set.
1155      */
1156     public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) {
1157         return new UnmodifiableSortedSet&lt;&gt;(s);
1158     }
1159 
1160     /**
1161      * @serial include
1162      */
1163     static class UnmodifiableSortedSet&lt;E&gt;
1164                              extends UnmodifiableSet&lt;E&gt;
1165                              implements SortedSet&lt;E&gt;, Serializable {
<span class="line-added">1166         @java.io.Serial</span>
1167         private static final long serialVersionUID = -4929149591599911165L;
<span class="line-added">1168         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1169         private final SortedSet&lt;E&gt; ss;
1170 
1171         UnmodifiableSortedSet(SortedSet&lt;E&gt; s) {super(s); ss = s;}
1172 
1173         public Comparator&lt;? super E&gt; comparator() {return ss.comparator();}
1174 
1175         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
1176             return new UnmodifiableSortedSet&lt;&gt;(ss.subSet(fromElement,toElement));
1177         }
1178         public SortedSet&lt;E&gt; headSet(E toElement) {
1179             return new UnmodifiableSortedSet&lt;&gt;(ss.headSet(toElement));
1180         }
1181         public SortedSet&lt;E&gt; tailSet(E fromElement) {
1182             return new UnmodifiableSortedSet&lt;&gt;(ss.tailSet(fromElement));
1183         }
1184 
1185         public E first()                   {return ss.first();}
1186         public E last()                    {return ss.last();}
1187     }
1188 
</pre>
<hr />
<pre>
1200      * @param  &lt;T&gt; the class of the objects in the set
1201      * @param s the navigable set for which an unmodifiable view is to be
1202      *        returned
1203      * @return an unmodifiable view of the specified navigable set
1204      * @since 1.8
1205      */
1206     public static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) {
1207         return new UnmodifiableNavigableSet&lt;&gt;(s);
1208     }
1209 
1210     /**
1211      * Wraps a navigable set and disables all of the mutative operations.
1212      *
1213      * @param &lt;E&gt; type of elements
1214      * @serial include
1215      */
1216     static class UnmodifiableNavigableSet&lt;E&gt;
1217                              extends UnmodifiableSortedSet&lt;E&gt;
1218                              implements NavigableSet&lt;E&gt;, Serializable {
1219 
<span class="line-added">1220         @java.io.Serial</span>
1221         private static final long serialVersionUID = -6027448201786391929L;
1222 
1223         /**
1224          * A singleton empty unmodifiable navigable set used for
1225          * {@link #emptyNavigableSet()}.
1226          *
1227          * @param &lt;E&gt; type of elements, if there were any, and bounds
1228          */
1229         private static class EmptyNavigableSet&lt;E&gt; extends UnmodifiableNavigableSet&lt;E&gt;
1230             implements Serializable {
<span class="line-added">1231             @java.io.Serial</span>
1232             private static final long serialVersionUID = -6291252904449939134L;
1233 
1234             public EmptyNavigableSet() {
1235                 super(new TreeSet&lt;&gt;());
1236             }
1237 
<span class="line-added">1238             @java.io.Serial</span>
1239             private Object readResolve()        { return EMPTY_NAVIGABLE_SET; }
1240         }
1241 
1242         @SuppressWarnings(&quot;rawtypes&quot;)
1243         private static final NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =
1244                 new EmptyNavigableSet&lt;&gt;();
1245 
1246         /**
1247          * The instance we are protecting.
1248          */
<span class="line-added">1249         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1250         private final NavigableSet&lt;E&gt; ns;
1251 
1252         UnmodifiableNavigableSet(NavigableSet&lt;E&gt; s)         {super(s); ns = s;}
1253 
1254         public E lower(E e)                             { return ns.lower(e); }
1255         public E floor(E e)                             { return ns.floor(e); }
1256         public E ceiling(E e)                         { return ns.ceiling(e); }
1257         public E higher(E e)                           { return ns.higher(e); }
1258         public E pollFirst()     { throw new UnsupportedOperationException(); }
1259         public E pollLast()      { throw new UnsupportedOperationException(); }
1260         public NavigableSet&lt;E&gt; descendingSet()
1261                  { return new UnmodifiableNavigableSet&lt;&gt;(ns.descendingSet()); }
1262         public Iterator&lt;E&gt; descendingIterator()
1263                                          { return descendingSet().iterator(); }
1264 
1265         public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
1266             return new UnmodifiableNavigableSet&lt;&gt;(
1267                 ns.subSet(fromElement, fromInclusive, toElement, toInclusive));
1268         }
1269 
</pre>
<hr />
<pre>
1287      *
1288      * The returned list will be serializable if the specified list
1289      * is serializable. Similarly, the returned list will implement
1290      * {@link RandomAccess} if the specified list does.
1291      *
1292      * @param  &lt;T&gt; the class of the objects in the list
1293      * @param  list the list for which an unmodifiable view is to be returned.
1294      * @return an unmodifiable view of the specified list.
1295      */
1296     public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) {
1297         return (list instanceof RandomAccess ?
1298                 new UnmodifiableRandomAccessList&lt;&gt;(list) :
1299                 new UnmodifiableList&lt;&gt;(list));
1300     }
1301 
1302     /**
1303      * @serial include
1304      */
1305     static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;
1306                                   implements List&lt;E&gt; {
<span class="line-added">1307         @java.io.Serial</span>
1308         private static final long serialVersionUID = -283967356065247728L;
1309 
<span class="line-added">1310         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1311         final List&lt;? extends E&gt; list;
1312 
1313         UnmodifiableList(List&lt;? extends E&gt; list) {
1314             super(list);
1315             this.list = list;
1316         }
1317 
1318         public boolean equals(Object o) {return o == this || list.equals(o);}
1319         public int hashCode()           {return list.hashCode();}
1320 
1321         public E get(int index) {return list.get(index);}
1322         public E set(int index, E element) {
1323             throw new UnsupportedOperationException();
1324         }
1325         public void add(int index, E element) {
1326             throw new UnsupportedOperationException();
1327         }
1328         public E remove(int index) {
1329             throw new UnsupportedOperationException();
1330         }
</pre>
<hr />
<pre>
1373                 }
1374             };
1375         }
1376 
1377         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1378             return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));
1379         }
1380 
1381         /**
1382          * UnmodifiableRandomAccessList instances are serialized as
1383          * UnmodifiableList instances to allow them to be deserialized
1384          * in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList).
1385          * This method inverts the transformation.  As a beneficial
1386          * side-effect, it also grafts the RandomAccess marker onto
1387          * UnmodifiableList instances that were serialized in pre-1.4 JREs.
1388          *
1389          * Note: Unfortunately, UnmodifiableRandomAccessList instances
1390          * serialized in 1.4.1 and deserialized in 1.4 will become
1391          * UnmodifiableList instances, as this method was missing in 1.4.
1392          */
<span class="line-added">1393         @java.io.Serial</span>
1394         private Object readResolve() {
1395             return (list instanceof RandomAccess
1396                     ? new UnmodifiableRandomAccessList&lt;&gt;(list)
1397                     : this);
1398         }
1399     }
1400 
1401     /**
1402      * @serial include
1403      */
1404     static class UnmodifiableRandomAccessList&lt;E&gt; extends UnmodifiableList&lt;E&gt;
1405                                               implements RandomAccess
1406     {
1407         UnmodifiableRandomAccessList(List&lt;? extends E&gt; list) {
1408             super(list);
1409         }
1410 
1411         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
1412             return new UnmodifiableRandomAccessList&lt;&gt;(
1413                 list.subList(fromIndex, toIndex));
1414         }
1415 
<span class="line-added">1416         @java.io.Serial</span>
1417         private static final long serialVersionUID = -2542308836966382001L;
1418 
1419         /**
1420          * Allows instances to be deserialized in pre-1.4 JREs (which do
1421          * not have UnmodifiableRandomAccessList).  UnmodifiableList has
1422          * a readResolve method that inverts this transformation upon
1423          * deserialization.
1424          */
<span class="line-added">1425         @java.io.Serial</span>
1426         private Object writeReplace() {
1427             return new UnmodifiableList&lt;&gt;(list);
1428         }
1429     }
1430 
1431     /**
1432      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1433      * specified map. Query operations on the returned map &quot;read through&quot;
1434      * to the specified map, and attempts to modify the returned
1435      * map, whether direct or via its collection views, result in an
1436      * {@code UnsupportedOperationException}.&lt;p&gt;
1437      *
1438      * The returned map will be serializable if the specified map
1439      * is serializable.
1440      *
1441      * @param &lt;K&gt; the class of the map keys
1442      * @param &lt;V&gt; the class of the map values
1443      * @param  m the map for which an unmodifiable view is to be returned.
1444      * @return an unmodifiable view of the specified map.
1445      */
1446     public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
1447         return new UnmodifiableMap&lt;&gt;(m);
1448     }
1449 
1450     /**
1451      * @serial include
1452      */
1453     private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable {
<span class="line-added">1454         @java.io.Serial</span>
1455         private static final long serialVersionUID = -1034234728574286014L;
1456 
<span class="line-added">1457         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1458         private final Map&lt;? extends K, ? extends V&gt; m;
1459 
1460         UnmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {
1461             if (m==null)
1462                 throw new NullPointerException();
1463             this.m = m;
1464         }
1465 
1466         public int size()                        {return m.size();}
1467         public boolean isEmpty()                 {return m.isEmpty();}
1468         public boolean containsKey(Object key)   {return m.containsKey(key);}
1469         public boolean containsValue(Object val) {return m.containsValue(val);}
1470         public V get(Object key)                 {return m.get(key);}
1471 
1472         public V put(K key, V value) {
1473             throw new UnsupportedOperationException();
1474         }
1475         public V remove(Object key) {
1476             throw new UnsupportedOperationException();
1477         }
</pre>
<hr />
<pre>
1562                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1563             throw new UnsupportedOperationException();
1564         }
1565 
1566         @Override
1567         public V merge(K key, V value,
1568                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
1569             throw new UnsupportedOperationException();
1570         }
1571 
1572         /**
1573          * We need this class in addition to UnmodifiableSet as
1574          * Map.Entries themselves permit modification of the backing Map
1575          * via their setValue operation.  This class is subtle: there are
1576          * many possible attacks that must be thwarted.
1577          *
1578          * @serial include
1579          */
1580         static class UnmodifiableEntrySet&lt;K,V&gt;
1581             extends UnmodifiableSet&lt;Map.Entry&lt;K,V&gt;&gt; {
<span class="line-added">1582             @java.io.Serial</span>
1583             private static final long serialVersionUID = 7854390611657943733L;
1584 
1585             @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
1586             UnmodifiableEntrySet(Set&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; s) {
1587                 // Need to cast to raw in order to work around a limitation in the type system
1588                 super((Set)s);
1589             }
1590 
1591             static &lt;K, V&gt; Consumer&lt;Map.Entry&lt;? extends K, ? extends V&gt;&gt; entryConsumer(
1592                     Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
1593                 return e -&gt; action.accept(new UnmodifiableEntry&lt;&gt;(e));
1594             }
1595 
1596             public void forEach(Consumer&lt;? super Entry&lt;K, V&gt;&gt; action) {
1597                 Objects.requireNonNull(action);
1598                 c.forEach(entryConsumer(action));
1599             }
1600 
1601             static final class UnmodifiableEntrySetSpliterator&lt;K, V&gt;
1602                     implements Spliterator&lt;Entry&lt;K,V&gt;&gt; {
</pre>
<hr />
<pre>
1794      *
1795      * The returned sorted map will be serializable if the specified sorted map
1796      * is serializable.
1797      *
1798      * @param &lt;K&gt; the class of the map keys
1799      * @param &lt;V&gt; the class of the map values
1800      * @param m the sorted map for which an unmodifiable view is to be
1801      *        returned.
1802      * @return an unmodifiable view of the specified sorted map.
1803      */
1804     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {
1805         return new UnmodifiableSortedMap&lt;&gt;(m);
1806     }
1807 
1808     /**
1809      * @serial include
1810      */
1811     static class UnmodifiableSortedMap&lt;K,V&gt;
1812           extends UnmodifiableMap&lt;K,V&gt;
1813           implements SortedMap&lt;K,V&gt;, Serializable {
<span class="line-added">1814         @java.io.Serial</span>
1815         private static final long serialVersionUID = -8806743815996713206L;
1816 
<span class="line-added">1817         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1818         private final SortedMap&lt;K, ? extends V&gt; sm;
1819 
1820         UnmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m) {super(m); sm = m; }
1821         public Comparator&lt;? super K&gt; comparator()   { return sm.comparator(); }
1822         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)
1823              { return new UnmodifiableSortedMap&lt;&gt;(sm.subMap(fromKey, toKey)); }
1824         public SortedMap&lt;K,V&gt; headMap(K toKey)
1825                      { return new UnmodifiableSortedMap&lt;&gt;(sm.headMap(toKey)); }
1826         public SortedMap&lt;K,V&gt; tailMap(K fromKey)
1827                    { return new UnmodifiableSortedMap&lt;&gt;(sm.tailMap(fromKey)); }
1828         public K firstKey()                           { return sm.firstKey(); }
1829         public K lastKey()                             { return sm.lastKey(); }
1830     }
1831 
1832     /**
1833      * Returns an &lt;a href=&quot;Collection.html#unmodview&quot;&gt;unmodifiable view&lt;/a&gt; of the
1834      * specified navigable map. Query operations on the returned navigable map &quot;read
1835      * through&quot; to the specified navigable map.  Attempts to modify the returned
1836      * navigable map, whether direct, via its collection views, or via its
1837      * {@code subMap}, {@code headMap}, or {@code tailMap} views, result in
</pre>
<hr />
<pre>
1840      * The returned navigable map will be serializable if the specified
1841      * navigable map is serializable.
1842      *
1843      * @param &lt;K&gt; the class of the map keys
1844      * @param &lt;V&gt; the class of the map values
1845      * @param m the navigable map for which an unmodifiable view is to be
1846      *        returned
1847      * @return an unmodifiable view of the specified navigable map
1848      * @since 1.8
1849      */
1850     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) {
1851         return new UnmodifiableNavigableMap&lt;&gt;(m);
1852     }
1853 
1854     /**
1855      * @serial include
1856      */
1857     static class UnmodifiableNavigableMap&lt;K,V&gt;
1858           extends UnmodifiableSortedMap&lt;K,V&gt;
1859           implements NavigableMap&lt;K,V&gt;, Serializable {
<span class="line-added">1860         @java.io.Serial</span>
1861         private static final long serialVersionUID = -4858195264774772197L;
1862 
1863         /**
1864          * A class for the {@link EMPTY_NAVIGABLE_MAP} which needs readResolve
1865          * to preserve singleton property.
1866          *
1867          * @param &lt;K&gt; type of keys, if there were any, and of bounds
1868          * @param &lt;V&gt; type of values, if there were any
1869          */
1870         private static class EmptyNavigableMap&lt;K,V&gt; extends UnmodifiableNavigableMap&lt;K,V&gt;
1871             implements Serializable {
1872 
<span class="line-added">1873             @java.io.Serial</span>
1874             private static final long serialVersionUID = -2239321462712562324L;
1875 
1876             EmptyNavigableMap()                       { super(new TreeMap&lt;&gt;()); }
1877 
1878             @Override
1879             public NavigableSet&lt;K&gt; navigableKeySet()
1880                                                 { return emptyNavigableSet(); }
1881 
<span class="line-added">1882             @java.io.Serial</span>
1883             private Object readResolve()        { return EMPTY_NAVIGABLE_MAP; }
1884         }
1885 
1886         /**
1887          * Singleton for {@link emptyNavigableMap()} which is also immutable.
1888          */
1889         private static final EmptyNavigableMap&lt;?,?&gt; EMPTY_NAVIGABLE_MAP =
1890             new EmptyNavigableMap&lt;&gt;();
1891 
1892         /**
1893          * The instance we wrap and protect.
1894          */
<span class="line-added">1895         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
1896         private final NavigableMap&lt;K, ? extends V&gt; nm;
1897 
1898         UnmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)
1899                                                             {super(m); nm = m;}
1900 
1901         public K lowerKey(K key)                   { return nm.lowerKey(key); }
1902         public K floorKey(K key)                   { return nm.floorKey(key); }
1903         public K ceilingKey(K key)               { return nm.ceilingKey(key); }
1904         public K higherKey(K key)                 { return nm.higherKey(key); }
1905 
1906         @SuppressWarnings(&quot;unchecked&quot;)
1907         public Entry&lt;K, V&gt; lowerEntry(K key) {
1908             Entry&lt;K,V&gt; lower = (Entry&lt;K, V&gt;) nm.lowerEntry(key);
1909             return (null != lower)
1910                 ? new UnmodifiableEntrySet.UnmodifiableEntry&lt;&gt;(lower)
1911                 : null;
1912         }
1913 
1914         @SuppressWarnings(&quot;unchecked&quot;)
1915         public Entry&lt;K, V&gt; floorEntry(K key) {
</pre>
<hr />
<pre>
2004      *
2005      * The returned collection will be serializable if the specified collection
2006      * is serializable.
2007      *
2008      * @param  &lt;T&gt; the class of the objects in the collection
2009      * @param  c the collection to be &quot;wrapped&quot; in a synchronized collection.
2010      * @return a synchronized view of the specified collection.
2011      */
2012     public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) {
2013         return new SynchronizedCollection&lt;&gt;(c);
2014     }
2015 
2016     static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c, Object mutex) {
2017         return new SynchronizedCollection&lt;&gt;(c, mutex);
2018     }
2019 
2020     /**
2021      * @serial include
2022      */
2023     static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="line-added">2024         @java.io.Serial</span>
2025         private static final long serialVersionUID = 3053995032091335093L;
2026 
<span class="line-added">2027         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2028         final Collection&lt;E&gt; c;  // Backing Collection
<span class="line-added">2029         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2030         final Object mutex;     // Object on which to synchronize
2031 
2032         SynchronizedCollection(Collection&lt;E&gt; c) {
2033             this.c = Objects.requireNonNull(c);
2034             mutex = this;
2035         }
2036 
2037         SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
2038             this.c = Objects.requireNonNull(c);
2039             this.mutex = Objects.requireNonNull(mutex);
2040         }
2041 
2042         public int size() {
2043             synchronized (mutex) {return c.size();}
2044         }
2045         public boolean isEmpty() {
2046             synchronized (mutex) {return c.isEmpty();}
2047         }
2048         public boolean contains(Object o) {
2049             synchronized (mutex) {return c.contains(o);}
</pre>
<hr />
<pre>
2091         @Override
2092         public void forEach(Consumer&lt;? super E&gt; consumer) {
2093             synchronized (mutex) {c.forEach(consumer);}
2094         }
2095         @Override
2096         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
2097             synchronized (mutex) {return c.removeIf(filter);}
2098         }
2099         @Override
2100         public Spliterator&lt;E&gt; spliterator() {
2101             return c.spliterator(); // Must be manually synched by user!
2102         }
2103         @Override
2104         public Stream&lt;E&gt; stream() {
2105             return c.stream(); // Must be manually synched by user!
2106         }
2107         @Override
2108         public Stream&lt;E&gt; parallelStream() {
2109             return c.parallelStream(); // Must be manually synched by user!
2110         }
<span class="line-added">2111         @java.io.Serial</span>
2112         private void writeObject(ObjectOutputStream s) throws IOException {
2113             synchronized (mutex) {s.defaultWriteObject();}
2114         }
2115     }
2116 
2117     /**
2118      * Returns a synchronized (thread-safe) set backed by the specified
2119      * set.  In order to guarantee serial access, it is critical that
2120      * &lt;strong&gt;all&lt;/strong&gt; access to the backing set is accomplished
2121      * through the returned set.&lt;p&gt;
2122      *
2123      * It is imperative that the user manually synchronize on the returned
2124      * collection when traversing it via {@link Iterator}, {@link Spliterator}
2125      * or {@link Stream}:
2126      * &lt;pre&gt;
2127      *  Set s = Collections.synchronizedSet(new HashSet());
2128      *      ...
2129      *  synchronized (s) {
2130      *      Iterator i = s.iterator(); // Must be in the synchronized block
2131      *      while (i.hasNext())
</pre>
<hr />
<pre>
2138      * serializable.
2139      *
2140      * @param  &lt;T&gt; the class of the objects in the set
2141      * @param  s the set to be &quot;wrapped&quot; in a synchronized set.
2142      * @return a synchronized view of the specified set.
2143      */
2144     public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {
2145         return new SynchronizedSet&lt;&gt;(s);
2146     }
2147 
2148     static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s, Object mutex) {
2149         return new SynchronizedSet&lt;&gt;(s, mutex);
2150     }
2151 
2152     /**
2153      * @serial include
2154      */
2155     static class SynchronizedSet&lt;E&gt;
2156           extends SynchronizedCollection&lt;E&gt;
2157           implements Set&lt;E&gt; {
<span class="line-added">2158         @java.io.Serial</span>
2159         private static final long serialVersionUID = 487447009682186044L;
2160 
2161         SynchronizedSet(Set&lt;E&gt; s) {
2162             super(s);
2163         }
2164         SynchronizedSet(Set&lt;E&gt; s, Object mutex) {
2165             super(s, mutex);
2166         }
2167 
2168         public boolean equals(Object o) {
2169             if (this == o)
2170                 return true;
2171             synchronized (mutex) {return c.equals(o);}
2172         }
2173         public int hashCode() {
2174             synchronized (mutex) {return c.hashCode();}
2175         }
2176     }
2177 
2178     /**
</pre>
<hr />
<pre>
2208      * Failure to follow this advice may result in non-deterministic behavior.
2209      *
2210      * &lt;p&gt;The returned sorted set will be serializable if the specified
2211      * sorted set is serializable.
2212      *
2213      * @param  &lt;T&gt; the class of the objects in the set
2214      * @param  s the sorted set to be &quot;wrapped&quot; in a synchronized sorted set.
2215      * @return a synchronized view of the specified sorted set.
2216      */
2217     public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) {
2218         return new SynchronizedSortedSet&lt;&gt;(s);
2219     }
2220 
2221     /**
2222      * @serial include
2223      */
2224     static class SynchronizedSortedSet&lt;E&gt;
2225         extends SynchronizedSet&lt;E&gt;
2226         implements SortedSet&lt;E&gt;
2227     {
<span class="line-added">2228         @java.io.Serial</span>
2229         private static final long serialVersionUID = 8695801310862127406L;
2230 
<span class="line-added">2231         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2232         private final SortedSet&lt;E&gt; ss;
2233 
2234         SynchronizedSortedSet(SortedSet&lt;E&gt; s) {
2235             super(s);
2236             ss = s;
2237         }
2238         SynchronizedSortedSet(SortedSet&lt;E&gt; s, Object mutex) {
2239             super(s, mutex);
2240             ss = s;
2241         }
2242 
2243         public Comparator&lt;? super E&gt; comparator() {
2244             synchronized (mutex) {return ss.comparator();}
2245         }
2246 
2247         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
2248             synchronized (mutex) {
2249                 return new SynchronizedSortedSet&lt;&gt;(
2250                     ss.subSet(fromElement, toElement), mutex);
2251             }
</pre>
<hr />
<pre>
2304      * &lt;p&gt;The returned navigable set will be serializable if the specified
2305      * navigable set is serializable.
2306      *
2307      * @param  &lt;T&gt; the class of the objects in the set
2308      * @param  s the navigable set to be &quot;wrapped&quot; in a synchronized navigable
2309      * set
2310      * @return a synchronized view of the specified navigable set
2311      * @since 1.8
2312      */
2313     public static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s) {
2314         return new SynchronizedNavigableSet&lt;&gt;(s);
2315     }
2316 
2317     /**
2318      * @serial include
2319      */
2320     static class SynchronizedNavigableSet&lt;E&gt;
2321         extends SynchronizedSortedSet&lt;E&gt;
2322         implements NavigableSet&lt;E&gt;
2323     {
<span class="line-added">2324         @java.io.Serial</span>
2325         private static final long serialVersionUID = -5505529816273629798L;
2326 
<span class="line-added">2327         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2328         private final NavigableSet&lt;E&gt; ns;
2329 
2330         SynchronizedNavigableSet(NavigableSet&lt;E&gt; s) {
2331             super(s);
2332             ns = s;
2333         }
2334 
2335         SynchronizedNavigableSet(NavigableSet&lt;E&gt; s, Object mutex) {
2336             super(s, mutex);
2337             ns = s;
2338         }
2339         public E lower(E e)      { synchronized (mutex) {return ns.lower(e);} }
2340         public E floor(E e)      { synchronized (mutex) {return ns.floor(e);} }
2341         public E ceiling(E e)  { synchronized (mutex) {return ns.ceiling(e);} }
2342         public E higher(E e)    { synchronized (mutex) {return ns.higher(e);} }
2343         public E pollFirst()  { synchronized (mutex) {return ns.pollFirst();} }
2344         public E pollLast()    { synchronized (mutex) {return ns.pollLast();} }
2345 
2346         public NavigableSet&lt;E&gt; descendingSet() {
2347             synchronized (mutex) {
</pre>
<hr />
<pre>
2415      * @return a synchronized view of the specified list.
2416      */
2417     public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) {
2418         return (list instanceof RandomAccess ?
2419                 new SynchronizedRandomAccessList&lt;&gt;(list) :
2420                 new SynchronizedList&lt;&gt;(list));
2421     }
2422 
2423     static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) {
2424         return (list instanceof RandomAccess ?
2425                 new SynchronizedRandomAccessList&lt;&gt;(list, mutex) :
2426                 new SynchronizedList&lt;&gt;(list, mutex));
2427     }
2428 
2429     /**
2430      * @serial include
2431      */
2432     static class SynchronizedList&lt;E&gt;
2433         extends SynchronizedCollection&lt;E&gt;
2434         implements List&lt;E&gt; {
<span class="line-added">2435         @java.io.Serial</span>
2436         private static final long serialVersionUID = -7754090372962971524L;
2437 
<span class="line-added">2438         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2439         final List&lt;E&gt; list;
2440 
2441         SynchronizedList(List&lt;E&gt; list) {
2442             super(list);
2443             this.list = list;
2444         }
2445         SynchronizedList(List&lt;E&gt; list, Object mutex) {
2446             super(list, mutex);
2447             this.list = list;
2448         }
2449 
2450         public boolean equals(Object o) {
2451             if (this == o)
2452                 return true;
2453             synchronized (mutex) {return list.equals(o);}
2454         }
2455         public int hashCode() {
2456             synchronized (mutex) {return list.hashCode();}
2457         }
2458 
</pre>
<hr />
<pre>
2499         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
2500             synchronized (mutex) {list.replaceAll(operator);}
2501         }
2502         @Override
2503         public void sort(Comparator&lt;? super E&gt; c) {
2504             synchronized (mutex) {list.sort(c);}
2505         }
2506 
2507         /**
2508          * SynchronizedRandomAccessList instances are serialized as
2509          * SynchronizedList instances to allow them to be deserialized
2510          * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList).
2511          * This method inverts the transformation.  As a beneficial
2512          * side-effect, it also grafts the RandomAccess marker onto
2513          * SynchronizedList instances that were serialized in pre-1.4 JREs.
2514          *
2515          * Note: Unfortunately, SynchronizedRandomAccessList instances
2516          * serialized in 1.4.1 and deserialized in 1.4 will become
2517          * SynchronizedList instances, as this method was missing in 1.4.
2518          */
<span class="line-added">2519         @java.io.Serial</span>
2520         private Object readResolve() {
2521             return (list instanceof RandomAccess
2522                     ? new SynchronizedRandomAccessList&lt;&gt;(list)
2523                     : this);
2524         }
2525     }
2526 
2527     /**
2528      * @serial include
2529      */
2530     static class SynchronizedRandomAccessList&lt;E&gt;
2531         extends SynchronizedList&lt;E&gt;
2532         implements RandomAccess {
2533 
2534         SynchronizedRandomAccessList(List&lt;E&gt; list) {
2535             super(list);
2536         }
2537 
2538         SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) {
2539             super(list, mutex);
2540         }
2541 
2542         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
2543             synchronized (mutex) {
2544                 return new SynchronizedRandomAccessList&lt;&gt;(
2545                     list.subList(fromIndex, toIndex), mutex);
2546             }
2547         }
2548 
<span class="line-added">2549         @java.io.Serial</span>
2550         private static final long serialVersionUID = 1530674583602358482L;
2551 
2552         /**
2553          * Allows instances to be deserialized in pre-1.4 JREs (which do
2554          * not have SynchronizedRandomAccessList).  SynchronizedList has
2555          * a readResolve method that inverts this transformation upon
2556          * deserialization.
2557          */
<span class="line-added">2558         @java.io.Serial</span>
2559         private Object writeReplace() {
2560             return new SynchronizedList&lt;&gt;(list);
2561         }
2562     }
2563 
2564     /**
2565      * Returns a synchronized (thread-safe) map backed by the specified
2566      * map.  In order to guarantee serial access, it is critical that
2567      * &lt;strong&gt;all&lt;/strong&gt; access to the backing map is accomplished
2568      * through the returned map.&lt;p&gt;
2569      *
2570      * It is imperative that the user manually synchronize on the returned
2571      * map when traversing any of its collection views via {@link Iterator},
2572      * {@link Spliterator} or {@link Stream}:
2573      * &lt;pre&gt;
2574      *  Map m = Collections.synchronizedMap(new HashMap());
2575      *      ...
2576      *  Set s = m.keySet();  // Needn&#39;t be in synchronized block
2577      *      ...
2578      *  synchronized (m) {  // Synchronizing on m, not s!
</pre>
<hr />
<pre>
2583      * &lt;/pre&gt;
2584      * Failure to follow this advice may result in non-deterministic behavior.
2585      *
2586      * &lt;p&gt;The returned map will be serializable if the specified map is
2587      * serializable.
2588      *
2589      * @param &lt;K&gt; the class of the map keys
2590      * @param &lt;V&gt; the class of the map values
2591      * @param  m the map to be &quot;wrapped&quot; in a synchronized map.
2592      * @return a synchronized view of the specified map.
2593      */
2594     public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {
2595         return new SynchronizedMap&lt;&gt;(m);
2596     }
2597 
2598     /**
2599      * @serial include
2600      */
2601     private static class SynchronizedMap&lt;K,V&gt;
2602         implements Map&lt;K,V&gt;, Serializable {
<span class="line-added">2603         @java.io.Serial</span>
2604         private static final long serialVersionUID = 1978198479659022715L;
2605 
<span class="line-added">2606         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2607         private final Map&lt;K,V&gt; m;     // Backing Map
<span class="line-added">2608         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2609         final Object      mutex;        // Object on which to synchronize
2610 
2611         SynchronizedMap(Map&lt;K,V&gt; m) {
2612             this.m = Objects.requireNonNull(m);
2613             mutex = this;
2614         }
2615 
2616         SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {
2617             this.m = m;
2618             this.mutex = mutex;
2619         }
2620 
2621         public int size() {
2622             synchronized (mutex) {return m.size();}
2623         }
2624         public boolean isEmpty() {
2625             synchronized (mutex) {return m.isEmpty();}
2626         }
2627         public boolean containsKey(Object key) {
2628             synchronized (mutex) {return m.containsKey(key);}
</pre>
<hr />
<pre>
2720         public V computeIfAbsent(K key,
2721                 Function&lt;? super K, ? extends V&gt; mappingFunction) {
2722             synchronized (mutex) {return m.computeIfAbsent(key, mappingFunction);}
2723         }
2724         @Override
2725         public V computeIfPresent(K key,
2726                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
2727             synchronized (mutex) {return m.computeIfPresent(key, remappingFunction);}
2728         }
2729         @Override
2730         public V compute(K key,
2731                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
2732             synchronized (mutex) {return m.compute(key, remappingFunction);}
2733         }
2734         @Override
2735         public V merge(K key, V value,
2736                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
2737             synchronized (mutex) {return m.merge(key, value, remappingFunction);}
2738         }
2739 
<span class="line-added">2740         @java.io.Serial</span>
2741         private void writeObject(ObjectOutputStream s) throws IOException {
2742             synchronized (mutex) {s.defaultWriteObject();}
2743         }
2744     }
2745 
2746     /**
2747      * Returns a synchronized (thread-safe) sorted map backed by the specified
2748      * sorted map.  In order to guarantee serial access, it is critical that
2749      * &lt;strong&gt;all&lt;/strong&gt; access to the backing sorted map is accomplished
2750      * through the returned sorted map (or its views).&lt;p&gt;
2751      *
2752      * It is imperative that the user manually synchronize on the returned
2753      * sorted map when traversing any of its collection views, or the
2754      * collections views of any of its {@code subMap}, {@code headMap} or
2755      * {@code tailMap} views, via {@link Iterator}, {@link Spliterator} or
2756      * {@link Stream}:
2757      * &lt;pre&gt;
2758      *  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
2759      *      ...
2760      *  Set s = m.keySet();  // Needn&#39;t be in synchronized block
</pre>
<hr />
<pre>
2782      *
2783      * &lt;p&gt;The returned sorted map will be serializable if the specified
2784      * sorted map is serializable.
2785      *
2786      * @param &lt;K&gt; the class of the map keys
2787      * @param &lt;V&gt; the class of the map values
2788      * @param  m the sorted map to be &quot;wrapped&quot; in a synchronized sorted map.
2789      * @return a synchronized view of the specified sorted map.
2790      */
2791     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
2792         return new SynchronizedSortedMap&lt;&gt;(m);
2793     }
2794 
2795     /**
2796      * @serial include
2797      */
2798     static class SynchronizedSortedMap&lt;K,V&gt;
2799         extends SynchronizedMap&lt;K,V&gt;
2800         implements SortedMap&lt;K,V&gt;
2801     {
<span class="line-added">2802         @java.io.Serial</span>
2803         private static final long serialVersionUID = -8798146769416483793L;
2804 
<span class="line-added">2805         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2806         private final SortedMap&lt;K,V&gt; sm;
2807 
2808         SynchronizedSortedMap(SortedMap&lt;K,V&gt; m) {
2809             super(m);
2810             sm = m;
2811         }
2812         SynchronizedSortedMap(SortedMap&lt;K,V&gt; m, Object mutex) {
2813             super(m, mutex);
2814             sm = m;
2815         }
2816 
2817         public Comparator&lt;? super K&gt; comparator() {
2818             synchronized (mutex) {return sm.comparator();}
2819         }
2820 
2821         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
2822             synchronized (mutex) {
2823                 return new SynchronizedSortedMap&lt;&gt;(
2824                     sm.subMap(fromKey, toKey), mutex);
2825             }
</pre>
<hr />
<pre>
2886      * @param &lt;K&gt; the class of the map keys
2887      * @param &lt;V&gt; the class of the map values
2888      * @param  m the navigable map to be &quot;wrapped&quot; in a synchronized navigable
2889      *              map
2890      * @return a synchronized view of the specified navigable map.
2891      * @since 1.8
2892      */
2893     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
2894         return new SynchronizedNavigableMap&lt;&gt;(m);
2895     }
2896 
2897     /**
2898      * A synchronized NavigableMap.
2899      *
2900      * @serial include
2901      */
2902     static class SynchronizedNavigableMap&lt;K,V&gt;
2903         extends SynchronizedSortedMap&lt;K,V&gt;
2904         implements NavigableMap&lt;K,V&gt;
2905     {
<span class="line-added">2906         @java.io.Serial</span>
2907         private static final long serialVersionUID = 699392247599746807L;
2908 
<span class="line-added">2909         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
2910         private final NavigableMap&lt;K,V&gt; nm;
2911 
2912         SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m) {
2913             super(m);
2914             nm = m;
2915         }
2916         SynchronizedNavigableMap(NavigableMap&lt;K,V&gt; m, Object mutex) {
2917             super(m, mutex);
2918             nm = m;
2919         }
2920 
2921         public Entry&lt;K, V&gt; lowerEntry(K key)
2922                         { synchronized (mutex) { return nm.lowerEntry(key); } }
2923         public K lowerKey(K key)
2924                           { synchronized (mutex) { return nm.lowerKey(key); } }
2925         public Entry&lt;K, V&gt; floorEntry(K key)
2926                         { synchronized (mutex) { return nm.floorEntry(key); } }
2927         public K floorKey(K key)
2928                           { synchronized (mutex) { return nm.floorKey(key); } }
2929         public Entry&lt;K, V&gt; ceilingEntry(K key)
</pre>
<hr />
<pre>
3066      * @param c the collection for which a dynamically typesafe view is to be
3067      *          returned
3068      * @param type the type of element that {@code c} is permitted to hold
3069      * @return a dynamically typesafe view of the specified collection
3070      * @since 1.5
3071      */
3072     public static &lt;E&gt; Collection&lt;E&gt; checkedCollection(Collection&lt;E&gt; c,
3073                                                       Class&lt;E&gt; type) {
3074         return new CheckedCollection&lt;&gt;(c, type);
3075     }
3076 
3077     @SuppressWarnings(&quot;unchecked&quot;)
3078     static &lt;T&gt; T[] zeroLengthArray(Class&lt;T&gt; type) {
3079         return (T[]) Array.newInstance(type, 0);
3080     }
3081 
3082     /**
3083      * @serial include
3084      */
3085     static class CheckedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {
<span class="line-added">3086         @java.io.Serial</span>
3087         private static final long serialVersionUID = 1578914078182001775L;
3088 
<span class="line-added">3089         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3090         final Collection&lt;E&gt; c;
<span class="line-added">3091         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3092         final Class&lt;E&gt; type;
3093 
3094         @SuppressWarnings(&quot;unchecked&quot;)
3095         E typeCheck(Object o) {
3096             if (o != null &amp;&amp; !type.isInstance(o))
3097                 throw new ClassCastException(badElementMsg(o));
3098             return (E) o;
3099         }
3100 
3101         private String badElementMsg(Object o) {
3102             return &quot;Attempt to insert &quot; + o.getClass() +
3103                 &quot; element into collection with element type &quot; + type;
3104         }
3105 
3106         CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) {
3107             this.c = Objects.requireNonNull(c, &quot;c&quot;);
3108             this.type = Objects.requireNonNull(type, &quot;type&quot;);
3109         }
3110 
3111         public int size()                          { return c.size(); }
</pre>
<hr />
<pre>
3127         public boolean retainAll(Collection&lt;?&gt; coll) {
3128             return c.retainAll(coll);
3129         }
3130 
3131         public Iterator&lt;E&gt; iterator() {
3132             // JDK-6363904 - unwrapped iterator could be typecast to
3133             // ListIterator with unsafe set()
3134             final Iterator&lt;E&gt; it = c.iterator();
3135             return new Iterator&lt;E&gt;() {
3136                 public boolean hasNext() { return it.hasNext(); }
3137                 public E next()          { return it.next(); }
3138                 public void remove()     {        it.remove(); }
3139                 public void forEachRemaining(Consumer&lt;? super E&gt; action) {
3140                     it.forEachRemaining(action);
3141                 }
3142             };
3143         }
3144 
3145         public boolean add(E e)          { return c.add(typeCheck(e)); }
3146 
<span class="line-added">3147         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3148         private E[] zeroLengthElementArray; // Lazily initialized
3149 
3150         private E[] zeroLengthElementArray() {
3151             return zeroLengthElementArray != null ? zeroLengthElementArray :
3152                 (zeroLengthElementArray = zeroLengthArray(type));
3153         }
3154 
3155         @SuppressWarnings(&quot;unchecked&quot;)
3156         Collection&lt;E&gt; checkedCopyOf(Collection&lt;? extends E&gt; coll) {
3157             Object[] a;
3158             try {
3159                 E[] z = zeroLengthElementArray();
3160                 a = coll.toArray(z);
3161                 // Defend against coll violating the toArray contract
3162                 if (a.getClass() != z.getClass())
3163                     a = Arrays.copyOf(a, a.length, z.getClass());
3164             } catch (ArrayStoreException ignore) {
3165                 // To get better and consistent diagnostics,
3166                 // we call typeCheck explicitly on each element.
3167                 // We call clone() to defend against coll retaining a
</pre>
<hr />
<pre>
3219      * whenever the backing queue does.
3220      *
3221      * @param &lt;E&gt; the class of the objects in the queue
3222      * @param queue the queue for which a dynamically typesafe view is to be
3223      *             returned
3224      * @param type the type of element that {@code queue} is permitted to hold
3225      * @return a dynamically typesafe view of the specified queue
3226      * @since 1.8
3227      */
3228     public static &lt;E&gt; Queue&lt;E&gt; checkedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; type) {
3229         return new CheckedQueue&lt;&gt;(queue, type);
3230     }
3231 
3232     /**
3233      * @serial include
3234      */
3235     static class CheckedQueue&lt;E&gt;
3236         extends CheckedCollection&lt;E&gt;
3237         implements Queue&lt;E&gt;, Serializable
3238     {
<span class="line-added">3239         @java.io.Serial</span>
3240         private static final long serialVersionUID = 1433151992604707767L;
<span class="line-added">3241         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3242         final Queue&lt;E&gt; queue;
3243 
3244         CheckedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; elementType) {
3245             super(queue, elementType);
3246             this.queue = queue;
3247         }
3248 
3249         public E element()              {return queue.element();}
3250         public boolean equals(Object o) {return o == this || c.equals(o);}
3251         public int hashCode()           {return c.hashCode();}
3252         public E peek()                 {return queue.peek();}
3253         public E poll()                 {return queue.poll();}
3254         public E remove()               {return queue.remove();}
3255         public boolean offer(E e)       {return queue.offer(typeCheck(e));}
3256     }
3257 
3258     /**
3259      * Returns a dynamically typesafe view of the specified set.
3260      * Any attempt to insert an element of the wrong type will result in
3261      * an immediate {@link ClassCastException}.  Assuming a set contains
</pre>
<hr />
<pre>
3275      * type, the returned set permits insertion of null elements whenever
3276      * the backing set does.
3277      *
3278      * @param &lt;E&gt; the class of the objects in the set
3279      * @param s the set for which a dynamically typesafe view is to be
3280      *          returned
3281      * @param type the type of element that {@code s} is permitted to hold
3282      * @return a dynamically typesafe view of the specified set
3283      * @since 1.5
3284      */
3285     public static &lt;E&gt; Set&lt;E&gt; checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type) {
3286         return new CheckedSet&lt;&gt;(s, type);
3287     }
3288 
3289     /**
3290      * @serial include
3291      */
3292     static class CheckedSet&lt;E&gt; extends CheckedCollection&lt;E&gt;
3293                                  implements Set&lt;E&gt;, Serializable
3294     {
<span class="line-added">3295         @java.io.Serial</span>
3296         private static final long serialVersionUID = 4694047833775013803L;
3297 
3298         CheckedSet(Set&lt;E&gt; s, Class&lt;E&gt; elementType) { super(s, elementType); }
3299 
3300         public boolean equals(Object o) { return o == this || c.equals(o); }
3301         public int hashCode()           { return c.hashCode(); }
3302     }
3303 
3304     /**
3305      * Returns a dynamically typesafe view of the specified sorted set.
3306      * Any attempt to insert an element of the wrong type will result in an
3307      * immediate {@link ClassCastException}.  Assuming a sorted set
3308      * contains no incorrectly typed elements prior to the time a
3309      * dynamically typesafe view is generated, and that all subsequent
3310      * access to the sorted set takes place through the view, it is
3311      * &lt;i&gt;guaranteed&lt;/i&gt; that the sorted set cannot contain an incorrectly
3312      * typed element.
3313      *
3314      * &lt;p&gt;A discussion of the use of dynamically typesafe views may be
3315      * found in the documentation for the {@link #checkedCollection
</pre>
<hr />
<pre>
3323      * whenever the backing sorted set does.
3324      *
3325      * @param &lt;E&gt; the class of the objects in the set
3326      * @param s the sorted set for which a dynamically typesafe view is to be
3327      *          returned
3328      * @param type the type of element that {@code s} is permitted to hold
3329      * @return a dynamically typesafe view of the specified sorted set
3330      * @since 1.5
3331      */
3332     public static &lt;E&gt; SortedSet&lt;E&gt; checkedSortedSet(SortedSet&lt;E&gt; s,
3333                                                     Class&lt;E&gt; type) {
3334         return new CheckedSortedSet&lt;&gt;(s, type);
3335     }
3336 
3337     /**
3338      * @serial include
3339      */
3340     static class CheckedSortedSet&lt;E&gt; extends CheckedSet&lt;E&gt;
3341         implements SortedSet&lt;E&gt;, Serializable
3342     {
<span class="line-added">3343         @java.io.Serial</span>
3344         private static final long serialVersionUID = 1599911165492914959L;
3345 
<span class="line-added">3346         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3347         private final SortedSet&lt;E&gt; ss;
3348 
3349         CheckedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type) {
3350             super(s, type);
3351             ss = s;
3352         }
3353 
3354         public Comparator&lt;? super E&gt; comparator() { return ss.comparator(); }
3355         public E first()                   { return ss.first(); }
3356         public E last()                    { return ss.last(); }
3357 
3358         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
3359             return checkedSortedSet(ss.subSet(fromElement,toElement), type);
3360         }
3361         public SortedSet&lt;E&gt; headSet(E toElement) {
3362             return checkedSortedSet(ss.headSet(toElement), type);
3363         }
3364         public SortedSet&lt;E&gt; tailSet(E fromElement) {
3365             return checkedSortedSet(ss.tailSet(fromElement), type);
3366         }
</pre>
<hr />
<pre>
3388      * whenever the backing sorted set does.
3389      *
3390      * @param &lt;E&gt; the class of the objects in the set
3391      * @param s the navigable set for which a dynamically typesafe view is to be
3392      *          returned
3393      * @param type the type of element that {@code s} is permitted to hold
3394      * @return a dynamically typesafe view of the specified navigable set
3395      * @since 1.8
3396      */
3397     public static &lt;E&gt; NavigableSet&lt;E&gt; checkedNavigableSet(NavigableSet&lt;E&gt; s,
3398                                                     Class&lt;E&gt; type) {
3399         return new CheckedNavigableSet&lt;&gt;(s, type);
3400     }
3401 
3402     /**
3403      * @serial include
3404      */
3405     static class CheckedNavigableSet&lt;E&gt; extends CheckedSortedSet&lt;E&gt;
3406         implements NavigableSet&lt;E&gt;, Serializable
3407     {
<span class="line-added">3408         @java.io.Serial</span>
3409         private static final long serialVersionUID = -5429120189805438922L;
3410 
<span class="line-added">3411         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3412         private final NavigableSet&lt;E&gt; ns;
3413 
3414         CheckedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type) {
3415             super(s, type);
3416             ns = s;
3417         }
3418 
3419         public E lower(E e)                             { return ns.lower(e); }
3420         public E floor(E e)                             { return ns.floor(e); }
3421         public E ceiling(E e)                         { return ns.ceiling(e); }
3422         public E higher(E e)                           { return ns.higher(e); }
3423         public E pollFirst()                         { return ns.pollFirst(); }
3424         public E pollLast()                            {return ns.pollLast(); }
3425         public NavigableSet&lt;E&gt; descendingSet()
3426                       { return checkedNavigableSet(ns.descendingSet(), type); }
3427         public Iterator&lt;E&gt; descendingIterator()
3428             {return checkedNavigableSet(ns.descendingSet(), type).iterator(); }
3429 
3430         public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
3431             return checkedNavigableSet(ns.subSet(fromElement, true, toElement, false), type);
</pre>
<hr />
<pre>
3473      * @param &lt;E&gt; the class of the objects in the list
3474      * @param list the list for which a dynamically typesafe view is to be
3475      *             returned
3476      * @param type the type of element that {@code list} is permitted to hold
3477      * @return a dynamically typesafe view of the specified list
3478      * @since 1.5
3479      */
3480     public static &lt;E&gt; List&lt;E&gt; checkedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3481         return (list instanceof RandomAccess ?
3482                 new CheckedRandomAccessList&lt;&gt;(list, type) :
3483                 new CheckedList&lt;&gt;(list, type));
3484     }
3485 
3486     /**
3487      * @serial include
3488      */
3489     static class CheckedList&lt;E&gt;
3490         extends CheckedCollection&lt;E&gt;
3491         implements List&lt;E&gt;
3492     {
<span class="line-added">3493         @java.io.Serial</span>
3494         private static final long serialVersionUID = 65247728283967356L;
<span class="line-added">3495         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3496         final List&lt;E&gt; list;
3497 
3498         CheckedList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3499             super(list, type);
3500             this.list = list;
3501         }
3502 
3503         public boolean equals(Object o)  { return o == this || list.equals(o); }
3504         public int hashCode()            { return list.hashCode(); }
3505         public E get(int index)          { return list.get(index); }
3506         public E remove(int index)       { return list.remove(index); }
3507         public int indexOf(Object o)     { return list.indexOf(o); }
3508         public int lastIndexOf(Object o) { return list.lastIndexOf(o); }
3509 
3510         public E set(int index, E element) {
3511             return list.set(index, typeCheck(element));
3512         }
3513 
3514         public void add(int index, E element) {
3515             list.add(index, typeCheck(element));
</pre>
<hr />
<pre>
3560          *         already been replaced.
3561          */
3562         @Override
3563         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
3564             Objects.requireNonNull(operator);
3565             list.replaceAll(e -&gt; typeCheck(operator.apply(e)));
3566         }
3567 
3568         @Override
3569         public void sort(Comparator&lt;? super E&gt; c) {
3570             list.sort(c);
3571         }
3572     }
3573 
3574     /**
3575      * @serial include
3576      */
3577     static class CheckedRandomAccessList&lt;E&gt; extends CheckedList&lt;E&gt;
3578                                             implements RandomAccess
3579     {
<span class="line-added">3580         @java.io.Serial</span>
3581         private static final long serialVersionUID = 1638200125423088369L;
3582 
3583         CheckedRandomAccessList(List&lt;E&gt; list, Class&lt;E&gt; type) {
3584             super(list, type);
3585         }
3586 
3587         public List&lt;E&gt; subList(int fromIndex, int toIndex) {
3588             return new CheckedRandomAccessList&lt;&gt;(
3589                     list.subList(fromIndex, toIndex), type);
3590         }
3591     }
3592 
3593     /**
3594      * Returns a dynamically typesafe view of the specified map.
3595      * Any attempt to insert a mapping whose key or value have the wrong
3596      * type will result in an immediate {@link ClassCastException}.
3597      * Similarly, any attempt to modify the value currently associated with
3598      * a key will result in an immediate {@link ClassCastException},
3599      * whether the modification is attempted directly through the map
3600      * itself, or through a {@link Map.Entry} instance obtained from the
</pre>
<hr />
<pre>
3622      * @param m the map for which a dynamically typesafe view is to be
3623      *          returned
3624      * @param keyType the type of key that {@code m} is permitted to hold
3625      * @param valueType the type of value that {@code m} is permitted to hold
3626      * @return a dynamically typesafe view of the specified map
3627      * @since 1.5
3628      */
3629     public static &lt;K, V&gt; Map&lt;K, V&gt; checkedMap(Map&lt;K, V&gt; m,
3630                                               Class&lt;K&gt; keyType,
3631                                               Class&lt;V&gt; valueType) {
3632         return new CheckedMap&lt;&gt;(m, keyType, valueType);
3633     }
3634 
3635 
3636     /**
3637      * @serial include
3638      */
3639     private static class CheckedMap&lt;K,V&gt;
3640         implements Map&lt;K,V&gt;, Serializable
3641     {
<span class="line-added">3642         @java.io.Serial</span>
3643         private static final long serialVersionUID = 5742860141034234728L;
3644 
<span class="line-added">3645         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3646         private final Map&lt;K, V&gt; m;
<span class="line-added">3647         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3648         final Class&lt;K&gt; keyType;
<span class="line-added">3649         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
3650         final Class&lt;V&gt; valueType;
3651 
3652         private void typeCheck(Object key, Object value) {
3653             if (key != null &amp;&amp; !keyType.isInstance(key))
3654                 throw new ClassCastException(badKeyMsg(key));
3655 
3656             if (value != null &amp;&amp; !valueType.isInstance(value))
3657                 throw new ClassCastException(badValueMsg(value));
3658         }
3659 
3660         private BiFunction&lt;? super K, ? super V, ? extends V&gt; typeCheck(
3661                 BiFunction&lt;? super K, ? super V, ? extends V&gt; func) {
3662             Objects.requireNonNull(func);
3663             return (k, v) -&gt; {
3664                 V newValue = func.apply(k, v);
3665                 typeCheck(k, newValue);
3666                 return newValue;
3667             };
3668         }
3669 
</pre>
<hr />
<pre>
4025      * @param &lt;V&gt; the class of the map values
4026      * @param m the map for which a dynamically typesafe view is to be
4027      *          returned
4028      * @param keyType the type of key that {@code m} is permitted to hold
4029      * @param valueType the type of value that {@code m} is permitted to hold
4030      * @return a dynamically typesafe view of the specified map
4031      * @since 1.5
4032      */
4033     public static &lt;K,V&gt; SortedMap&lt;K,V&gt; checkedSortedMap(SortedMap&lt;K, V&gt; m,
4034                                                         Class&lt;K&gt; keyType,
4035                                                         Class&lt;V&gt; valueType) {
4036         return new CheckedSortedMap&lt;&gt;(m, keyType, valueType);
4037     }
4038 
4039     /**
4040      * @serial include
4041      */
4042     static class CheckedSortedMap&lt;K,V&gt; extends CheckedMap&lt;K,V&gt;
4043         implements SortedMap&lt;K,V&gt;, Serializable
4044     {
<span class="line-added">4045         @java.io.Serial</span>
4046         private static final long serialVersionUID = 1599671320688067438L;
4047 
<span class="line-added">4048         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4049         private final SortedMap&lt;K, V&gt; sm;
4050 
4051         CheckedSortedMap(SortedMap&lt;K, V&gt; m,
4052                          Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
4053             super(m, keyType, valueType);
4054             sm = m;
4055         }
4056 
4057         public Comparator&lt;? super K&gt; comparator() { return sm.comparator(); }
4058         public K firstKey()                       { return sm.firstKey(); }
4059         public K lastKey()                        { return sm.lastKey(); }
4060 
4061         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
4062             return checkedSortedMap(sm.subMap(fromKey, toKey),
4063                                     keyType, valueType);
4064         }
4065         public SortedMap&lt;K,V&gt; headMap(K toKey) {
4066             return checkedSortedMap(sm.headMap(toKey), keyType, valueType);
4067         }
4068         public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
</pre>
<hr />
<pre>
4101      * @param &lt;V&gt; type of map values
4102      * @param m the map for which a dynamically typesafe view is to be
4103      *          returned
4104      * @param keyType the type of key that {@code m} is permitted to hold
4105      * @param valueType the type of value that {@code m} is permitted to hold
4106      * @return a dynamically typesafe view of the specified map
4107      * @since 1.8
4108      */
4109     public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; checkedNavigableMap(NavigableMap&lt;K, V&gt; m,
4110                                                         Class&lt;K&gt; keyType,
4111                                                         Class&lt;V&gt; valueType) {
4112         return new CheckedNavigableMap&lt;&gt;(m, keyType, valueType);
4113     }
4114 
4115     /**
4116      * @serial include
4117      */
4118     static class CheckedNavigableMap&lt;K,V&gt; extends CheckedSortedMap&lt;K,V&gt;
4119         implements NavigableMap&lt;K,V&gt;, Serializable
4120     {
<span class="line-added">4121         @java.io.Serial</span>
4122         private static final long serialVersionUID = -4852462692372534096L;
4123 
<span class="line-added">4124         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4125         private final NavigableMap&lt;K, V&gt; nm;
4126 
4127         CheckedNavigableMap(NavigableMap&lt;K, V&gt; m,
4128                          Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
4129             super(m, keyType, valueType);
4130             nm = m;
4131         }
4132 
4133         public Comparator&lt;? super K&gt; comparator()   { return nm.comparator(); }
4134         public K firstKey()                           { return nm.firstKey(); }
4135         public K lastKey()                             { return nm.lastKey(); }
4136 
4137         public Entry&lt;K, V&gt; lowerEntry(K key) {
4138             Entry&lt;K,V&gt; lower = nm.lowerEntry(key);
4139             return (null != lower)
4140                 ? new CheckedMap.CheckedEntrySet.CheckedEntry&lt;&gt;(lower, valueType)
4141                 : null;
4142         }
4143 
4144         public K lowerKey(K key)                   { return nm.lowerKey(key); }
</pre>
<hr />
<pre>
4381      * field does not provide type safety.)
4382      *
4383      * @param  &lt;T&gt; the class of the objects in the set
4384      * @return the empty set
4385      *
4386      * @see #EMPTY_SET
4387      * @since 1.5
4388      */
4389     @SuppressWarnings(&quot;unchecked&quot;)
4390     public static final &lt;T&gt; Set&lt;T&gt; emptySet() {
4391         return (Set&lt;T&gt;) EMPTY_SET;
4392     }
4393 
4394     /**
4395      * @serial include
4396      */
4397     private static class EmptySet&lt;E&gt;
4398         extends AbstractSet&lt;E&gt;
4399         implements Serializable
4400     {
<span class="line-added">4401         @java.io.Serial</span>
4402         private static final long serialVersionUID = 1582296315990362920L;
4403 
4404         public Iterator&lt;E&gt; iterator() { return emptyIterator(); }
4405 
4406         public int size() {return 0;}
4407         public boolean isEmpty() {return true;}
4408         public void clear() {}
4409 
4410         public boolean contains(Object obj) {return false;}
4411         public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }
4412 
4413         public Object[] toArray() { return new Object[0]; }
4414 
4415         public &lt;T&gt; T[] toArray(T[] a) {
4416             if (a.length &gt; 0)
4417                 a[0] = null;
4418             return a;
4419         }
4420 
4421         // Override default methods in Collection
4422         @Override
4423         public void forEach(Consumer&lt;? super E&gt; action) {
4424             Objects.requireNonNull(action);
4425         }
4426         @Override
4427         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
4428             Objects.requireNonNull(filter);
4429             return false;
4430         }
4431         @Override
4432         public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
4433 
4434         // Preserves singleton property
<span class="line-added">4435         @java.io.Serial</span>
4436         private Object readResolve() {
4437             return EMPTY_SET;
4438         }
4439 
4440         @Override
4441         public int hashCode() {
4442             return 0;
4443         }
4444     }
4445 
4446     /**
4447      * Returns an empty sorted set (immutable).  This set is serializable.
4448      *
4449      * &lt;p&gt;This example illustrates the type-safe way to obtain an empty
4450      * sorted set:
4451      * &lt;pre&gt; {@code
4452      *     SortedSet&lt;String&gt; s = Collections.emptySortedSet();
4453      * }&lt;/pre&gt;
4454      *
4455      * @implNote Implementations of this method need not create a separate
</pre>
<hr />
<pre>
4507      * cost to using the like-named field.  (Unlike this method, the field does
4508      * not provide type safety.)
4509      *
4510      * @param &lt;T&gt; type of elements, if there were any, in the list
4511      * @return an empty immutable list
4512      *
4513      * @see #EMPTY_LIST
4514      * @since 1.5
4515      */
4516     @SuppressWarnings(&quot;unchecked&quot;)
4517     public static final &lt;T&gt; List&lt;T&gt; emptyList() {
4518         return (List&lt;T&gt;) EMPTY_LIST;
4519     }
4520 
4521     /**
4522      * @serial include
4523      */
4524     private static class EmptyList&lt;E&gt;
4525         extends AbstractList&lt;E&gt;
4526         implements RandomAccess, Serializable {
<span class="line-added">4527         @java.io.Serial</span>
4528         private static final long serialVersionUID = 8842843931221139166L;
4529 
4530         public Iterator&lt;E&gt; iterator() {
4531             return emptyIterator();
4532         }
4533         public ListIterator&lt;E&gt; listIterator() {
4534             return emptyListIterator();
4535         }
4536 
4537         public int size() {return 0;}
4538         public boolean isEmpty() {return true;}
4539         public void clear() {}
4540 
4541         public boolean contains(Object obj) {return false;}
4542         public boolean containsAll(Collection&lt;?&gt; c) { return c.isEmpty(); }
4543 
4544         public Object[] toArray() { return new Object[0]; }
4545 
4546         public &lt;T&gt; T[] toArray(T[] a) {
4547             if (a.length &gt; 0)
</pre>
<hr />
<pre>
4565             return false;
4566         }
4567         @Override
4568         public void replaceAll(UnaryOperator&lt;E&gt; operator) {
4569             Objects.requireNonNull(operator);
4570         }
4571         @Override
4572         public void sort(Comparator&lt;? super E&gt; c) {
4573         }
4574 
4575         // Override default methods in Collection
4576         @Override
4577         public void forEach(Consumer&lt;? super E&gt; action) {
4578             Objects.requireNonNull(action);
4579         }
4580 
4581         @Override
4582         public Spliterator&lt;E&gt; spliterator() { return Spliterators.emptySpliterator(); }
4583 
4584         // Preserves singleton property
<span class="line-added">4585         @java.io.Serial</span>
4586         private Object readResolve() {
4587             return EMPTY_LIST;
4588         }
4589     }
4590 
4591     /**
4592      * The empty map (immutable).  This map is serializable.
4593      *
4594      * @see #emptyMap()
4595      * @since 1.3
4596      */
4597     @SuppressWarnings(&quot;rawtypes&quot;)
4598     public static final Map EMPTY_MAP = new EmptyMap&lt;&gt;();
4599 
4600     /**
4601      * Returns an empty map (immutable).  This map is serializable.
4602      *
4603      * &lt;p&gt;This example illustrates the type-safe way to obtain an empty map:
4604      * &lt;pre&gt;
4605      *     Map&amp;lt;String, Date&amp;gt; s = Collections.emptyMap();
</pre>
<hr />
<pre>
4652      * @implNote Implementations of this method need not create a separate
4653      * {@code NavigableMap} object for each call.
4654      *
4655      * @param &lt;K&gt; the class of the map keys
4656      * @param &lt;V&gt; the class of the map values
4657      * @return an empty navigable map
4658      * @since 1.8
4659      */
4660     @SuppressWarnings(&quot;unchecked&quot;)
4661     public static final &lt;K,V&gt; NavigableMap&lt;K,V&gt; emptyNavigableMap() {
4662         return (NavigableMap&lt;K,V&gt;) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;
4663     }
4664 
4665     /**
4666      * @serial include
4667      */
4668     private static class EmptyMap&lt;K,V&gt;
4669         extends AbstractMap&lt;K,V&gt;
4670         implements Serializable
4671     {
<span class="line-added">4672         @java.io.Serial</span>
4673         private static final long serialVersionUID = 6428348081105594320L;
4674 
4675         public int size()                          {return 0;}
4676         public boolean isEmpty()                   {return true;}
4677         public void clear()                        {}
4678         public boolean containsKey(Object key)     {return false;}
4679         public boolean containsValue(Object value) {return false;}
4680         public V get(Object key)                   {return null;}
4681         public Set&lt;K&gt; keySet()                     {return emptySet();}
4682         public Collection&lt;V&gt; values()              {return emptySet();}
4683         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()      {return emptySet();}
4684 
4685         public boolean equals(Object o) {
4686             return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
4687         }
4688 
4689         public int hashCode()                      {return 0;}
4690 
4691         // Override default methods in Map
4692         @Override
</pre>
<hr />
<pre>
4733 
4734         @Override
4735         public V computeIfPresent(K key,
4736                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
4737             throw new UnsupportedOperationException();
4738         }
4739 
4740         @Override
4741         public V compute(K key,
4742                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
4743             throw new UnsupportedOperationException();
4744         }
4745 
4746         @Override
4747         public V merge(K key, V value,
4748                 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
4749             throw new UnsupportedOperationException();
4750         }
4751 
4752         // Preserves singleton property
<span class="line-added">4753         @java.io.Serial</span>
4754         private Object readResolve() {
4755             return EMPTY_MAP;
4756         }
4757     }
4758 
4759     // Singleton collections
4760 
4761     /**
4762      * Returns an immutable set containing only the specified object.
4763      * The returned set is serializable.
4764      *
4765      * @param  &lt;T&gt; the class of the objects in the set
4766      * @param o the sole object to be stored in the returned set.
4767      * @return an immutable set containing only the specified object.
4768      */
4769     public static &lt;T&gt; Set&lt;T&gt; singleton(T o) {
4770         return new SingletonSet&lt;&gt;(o);
4771     }
4772 
4773     static &lt;E&gt; Iterator&lt;E&gt; singletonIterator(final E e) {
</pre>
<hr />
<pre>
4833                 return est;
4834             }
4835 
4836             @Override
4837             public int characteristics() {
4838                 int value = (element != null) ? Spliterator.NONNULL : 0;
4839 
4840                 return value | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE |
4841                        Spliterator.DISTINCT | Spliterator.ORDERED;
4842             }
4843         };
4844     }
4845 
4846     /**
4847      * @serial include
4848      */
4849     private static class SingletonSet&lt;E&gt;
4850         extends AbstractSet&lt;E&gt;
4851         implements Serializable
4852     {
<span class="line-added">4853         @java.io.Serial</span>
4854         private static final long serialVersionUID = 3193687207550431679L;
4855 
<span class="line-added">4856         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4857         private final E element;
4858 
4859         SingletonSet(E e) {element = e;}
4860 
4861         public Iterator&lt;E&gt; iterator() {
4862             return singletonIterator(element);
4863         }
4864 
4865         public int size() {return 1;}
4866 
4867         public boolean contains(Object o) {return eq(o, element);}
4868 
4869         // Override default methods for Collection
4870         @Override
4871         public void forEach(Consumer&lt;? super E&gt; action) {
4872             action.accept(element);
4873         }
4874         @Override
4875         public Spliterator&lt;E&gt; spliterator() {
4876             return singletonSpliterator(element);
</pre>
<hr />
<pre>
4888     /**
4889      * Returns an immutable list containing only the specified object.
4890      * The returned list is serializable.
4891      *
4892      * @param  &lt;T&gt; the class of the objects in the list
4893      * @param o the sole object to be stored in the returned list.
4894      * @return an immutable list containing only the specified object.
4895      * @since 1.3
4896      */
4897     public static &lt;T&gt; List&lt;T&gt; singletonList(T o) {
4898         return new SingletonList&lt;&gt;(o);
4899     }
4900 
4901     /**
4902      * @serial include
4903      */
4904     private static class SingletonList&lt;E&gt;
4905         extends AbstractList&lt;E&gt;
4906         implements RandomAccess, Serializable {
4907 
<span class="line-added">4908         @java.io.Serial</span>
4909         private static final long serialVersionUID = 3093736618740652951L;
4910 
<span class="line-added">4911         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4912         private final E element;
4913 
4914         SingletonList(E obj)                {element = obj;}
4915 
4916         public Iterator&lt;E&gt; iterator() {
4917             return singletonIterator(element);
4918         }
4919 
4920         public int size()                   {return 1;}
4921 
4922         public boolean contains(Object obj) {return eq(obj, element);}
4923 
4924         public E get(int index) {
4925             if (index != 0)
4926               throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: 1&quot;);
4927             return element;
4928         }
4929 
4930         // Override default methods for Collection
4931         @Override
</pre>
<hr />
<pre>
4958      * specified value.  The returned map is serializable.
4959      *
4960      * @param &lt;K&gt; the class of the map keys
4961      * @param &lt;V&gt; the class of the map values
4962      * @param key the sole key to be stored in the returned map.
4963      * @param value the value to which the returned map maps {@code key}.
4964      * @return an immutable map containing only the specified key-value
4965      *         mapping.
4966      * @since 1.3
4967      */
4968     public static &lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value) {
4969         return new SingletonMap&lt;&gt;(key, value);
4970     }
4971 
4972     /**
4973      * @serial include
4974      */
4975     private static class SingletonMap&lt;K,V&gt;
4976           extends AbstractMap&lt;K,V&gt;
4977           implements Serializable {
<span class="line-added">4978         @java.io.Serial</span>
4979         private static final long serialVersionUID = -6979724477215052911L;
4980 
<span class="line-added">4981         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4982         private final K k;
<span class="line-added">4983         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4984         private final V v;
4985 
4986         SingletonMap(K key, V value) {
4987             k = key;
4988             v = value;
4989         }
4990 
4991         public int size()                                           {return 1;}
4992         public boolean isEmpty()                                {return false;}
4993         public boolean containsKey(Object key)             {return eq(key, k);}
4994         public boolean containsValue(Object value)       {return eq(value, v);}
4995         public V get(Object key)              {return (eq(key, k) ? v : null);}
4996 
4997         private transient Set&lt;K&gt; keySet;
4998         private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
4999         private transient Collection&lt;V&gt; values;
5000 
5001         public Set&lt;K&gt; keySet() {
5002             if (keySet==null)
5003                 keySet = singleton(k);
</pre>
<hr />
<pre>
5098      * @param  o the element to appear repeatedly in the returned list.
5099      * @return an immutable list consisting of {@code n} copies of the
5100      *         specified object.
5101      * @throws IllegalArgumentException if {@code n &lt; 0}
5102      * @see    List#addAll(Collection)
5103      * @see    List#addAll(int, Collection)
5104      */
5105     public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o) {
5106         if (n &lt; 0)
5107             throw new IllegalArgumentException(&quot;List length = &quot; + n);
5108         return new CopiesList&lt;&gt;(n, o);
5109     }
5110 
5111     /**
5112      * @serial include
5113      */
5114     private static class CopiesList&lt;E&gt;
5115         extends AbstractList&lt;E&gt;
5116         implements RandomAccess, Serializable
5117     {
<span class="line-added">5118         @java.io.Serial</span>
5119         private static final long serialVersionUID = 2739099268398711800L;
5120 
5121         final int n;
<span class="line-added">5122         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
5123         final E element;
5124 
5125         CopiesList(int n, E e) {
5126             assert n &gt;= 0;
5127             this.n = n;
5128             element = e;
5129         }
5130 
5131         public int size() {
5132             return n;
5133         }
5134 
5135         public boolean contains(Object obj) {
5136             return n != 0 &amp;&amp; eq(obj, element);
5137         }
5138 
5139         public int indexOf(Object o) {
5140             return contains(o) ? 0 : -1;
5141         }
5142 
</pre>
<hr />
<pre>
5230                 }
5231             }
5232             return remaining == 0 &amp;&amp; !itr.hasNext();
5233         }
5234 
5235         // Override default methods in Collection
5236         @Override
5237         public Stream&lt;E&gt; stream() {
5238             return IntStream.range(0, n).mapToObj(i -&gt; element);
5239         }
5240 
5241         @Override
5242         public Stream&lt;E&gt; parallelStream() {
5243             return IntStream.range(0, n).parallel().mapToObj(i -&gt; element);
5244         }
5245 
5246         @Override
5247         public Spliterator&lt;E&gt; spliterator() {
5248             return stream().spliterator();
5249         }
<span class="line-added">5250 </span>
<span class="line-added">5251         @java.io.Serial</span>
<span class="line-added">5252         private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {</span>
<span class="line-added">5253             ois.defaultReadObject();</span>
<span class="line-added">5254             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(ois, Object[].class, n);</span>
<span class="line-added">5255         }</span>
5256     }
5257 
5258     /**
5259      * Returns a comparator that imposes the reverse of the &lt;em&gt;natural
5260      * ordering&lt;/em&gt; on a collection of objects that implement the
5261      * {@code Comparable} interface.  (The natural ordering is the ordering
5262      * imposed by the objects&#39; own {@code compareTo} method.)  This enables a
5263      * simple idiom for sorting (or maintaining) collections (or arrays) of
5264      * objects that implement the {@code Comparable} interface in
5265      * reverse-natural-order.  For example, suppose {@code a} is an array of
5266      * strings. Then: &lt;pre&gt;
5267      *          Arrays.sort(a, Collections.reverseOrder());
5268      * &lt;/pre&gt; sorts the array in reverse-lexicographic (alphabetical) order.&lt;p&gt;
5269      *
5270      * The returned comparator is serializable.
5271      *
5272      * @param  &lt;T&gt; the class of the objects compared by the comparator
5273      * @return A comparator that imposes the reverse of the &lt;i&gt;natural
5274      *         ordering&lt;/i&gt; on a collection of objects that implement
5275      *         the {@code Comparable} interface.
5276      * @see Comparable
5277      */
5278     @SuppressWarnings(&quot;unchecked&quot;)
5279     public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() {
5280         return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5281     }
5282 
5283     /**
5284      * @serial include
5285      */
5286     private static class ReverseComparator
5287         implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {
5288 
<span class="line-added">5289         @java.io.Serial</span>
5290         private static final long serialVersionUID = 7207038068494060240L;
5291 
5292         static final ReverseComparator REVERSE_ORDER
5293             = new ReverseComparator();
5294 
5295         public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {
5296             return c2.compareTo(c1);
5297         }
5298 
<span class="line-added">5299         @java.io.Serial</span>
5300         private Object readResolve() { return Collections.reverseOrder(); }
5301 
5302         @Override
5303         public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {
5304             return Comparator.naturalOrder();
5305         }
5306     }
5307 
5308     /**
5309      * Returns a comparator that imposes the reverse ordering of the specified
5310      * comparator.  If the specified comparator is {@code null}, this method is
5311      * equivalent to {@link #reverseOrder()} (in other words, it returns a
5312      * comparator that imposes the reverse of the &lt;em&gt;natural ordering&lt;/em&gt; on
5313      * a collection of objects that implement the Comparable interface).
5314      *
5315      * &lt;p&gt;The returned comparator is serializable (assuming the specified
5316      * comparator is also serializable or {@code null}).
5317      *
5318      * @param &lt;T&gt; the class of the objects compared by the comparator
5319      * @param cmp a comparator who&#39;s ordering is to be reversed by the returned
</pre>
<hr />
<pre>
5326     public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) {
5327         if (cmp == null) {
5328             return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5329         } else if (cmp == ReverseComparator.REVERSE_ORDER) {
5330             return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;
5331         } else if (cmp == Comparators.NaturalOrderComparator.INSTANCE) {
5332             return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;
5333         } else if (cmp instanceof ReverseComparator2) {
5334             return ((ReverseComparator2&lt;T&gt;) cmp).cmp;
5335         } else {
5336             return new ReverseComparator2&lt;&gt;(cmp);
5337         }
5338     }
5339 
5340     /**
5341      * @serial include
5342      */
5343     private static class ReverseComparator2&lt;T&gt; implements Comparator&lt;T&gt;,
5344         Serializable
5345     {
<span class="line-added">5346         @java.io.Serial</span>
5347         private static final long serialVersionUID = 4374092139857L;
5348 
5349         /**
5350          * The comparator specified in the static factory.  This will never
5351          * be null, as the static factory returns a ReverseComparator
5352          * instance if its argument is null.
5353          *
5354          * @serial
5355          */
<span class="line-added">5356         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
5357         final Comparator&lt;T&gt; cmp;
5358 
5359         ReverseComparator2(Comparator&lt;T&gt; cmp) {
5360             assert cmp != null;
5361             this.cmp = cmp;
5362         }
5363 
5364         public int compare(T t1, T t2) {
5365             return cmp.compare(t2, t1);
5366         }
5367 
5368         public boolean equals(Object o) {
5369             return (o == this) ||
5370                 (o instanceof ReverseComparator2 &amp;&amp;
5371                  cmp.equals(((ReverseComparator2)o).cmp));
5372         }
5373 
5374         public int hashCode() {
5375             return cmp.hashCode() ^ Integer.MIN_VALUE;
5376         }
</pre>
<hr />
<pre>
5618      *        new WeakHashMap&amp;lt;Object, Boolean&amp;gt;());
5619      * &lt;/pre&gt;
5620      *
5621      * @param &lt;E&gt; the class of the map keys and of the objects in the
5622      *        returned set
5623      * @param map the backing map
5624      * @return the set backed by the map
5625      * @throws IllegalArgumentException if {@code map} is not empty
5626      * @since 1.6
5627      */
5628     public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
5629         return new SetFromMap&lt;&gt;(map);
5630     }
5631 
5632     /**
5633      * @serial include
5634      */
5635     private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
5636         implements Set&lt;E&gt;, Serializable
5637     {
<span class="line-added">5638         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
5639         private final Map&lt;E, Boolean&gt; m;  // The backing map
5640         private transient Set&lt;E&gt; s;       // Its keySet
5641 
5642         SetFromMap(Map&lt;E, Boolean&gt; map) {
5643             if (!map.isEmpty())
5644                 throw new IllegalArgumentException(&quot;Map is non-empty&quot;);
5645             m = map;
5646             s = map.keySet();
5647         }
5648 
5649         public void clear()               {        m.clear(); }
5650         public int size()                 { return m.size(); }
5651         public boolean isEmpty()          { return m.isEmpty(); }
5652         public boolean contains(Object o) { return m.containsKey(o); }
5653         public boolean remove(Object o)   { return m.remove(o) != null; }
5654         public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }
5655         public Iterator&lt;E&gt; iterator()     { return s.iterator(); }
5656         public Object[] toArray()         { return s.toArray(); }
5657         public &lt;T&gt; T[] toArray(T[] a)     { return s.toArray(a); }
5658         public String toString()          { return s.toString(); }
</pre>
<hr />
<pre>
5663         public boolean retainAll(Collection&lt;?&gt; c)   {return s.retainAll(c);}
5664         // addAll is the only inherited implementation
5665 
5666         // Override default methods in Collection
5667         @Override
5668         public void forEach(Consumer&lt;? super E&gt; action) {
5669             s.forEach(action);
5670         }
5671         @Override
5672         public boolean removeIf(Predicate&lt;? super E&gt; filter) {
5673             return s.removeIf(filter);
5674         }
5675 
5676         @Override
5677         public Spliterator&lt;E&gt; spliterator() {return s.spliterator();}
5678         @Override
5679         public Stream&lt;E&gt; stream()           {return s.stream();}
5680         @Override
5681         public Stream&lt;E&gt; parallelStream()   {return s.parallelStream();}
5682 
<span class="line-added">5683         @java.io.Serial</span>
5684         private static final long serialVersionUID = 2454657854757543876L;
5685 
<span class="line-added">5686         @java.io.Serial</span>
5687         private void readObject(java.io.ObjectInputStream stream)
5688             throws IOException, ClassNotFoundException
5689         {
5690             stream.defaultReadObject();
5691             s = m.keySet();
5692         }
5693     }
5694 
5695     /**
5696      * Returns a view of a {@link Deque} as a Last-in-first-out (Lifo)
5697      * {@link Queue}. Method {@code add} is mapped to {@code push},
5698      * {@code remove} is mapped to {@code pop} and so on. This
5699      * view can be useful when you would like to use a method
5700      * requiring a {@code Queue} but you need Lifo ordering.
5701      *
5702      * &lt;p&gt;Each method invocation on the queue returned by this method
5703      * results in exactly one method invocation on the backing deque, with
5704      * one exception.  The {@link Queue#addAll addAll} method is
5705      * implemented as a sequence of {@link Deque#addFirst addFirst}
5706      * invocations on the backing deque.
5707      *
5708      * @param  &lt;T&gt; the class of the objects in the deque
5709      * @param deque the deque
5710      * @return the queue
5711      * @since  1.6
5712      */
5713     public static &lt;T&gt; Queue&lt;T&gt; asLifoQueue(Deque&lt;T&gt; deque) {
5714         return new AsLIFOQueue&lt;&gt;(Objects.requireNonNull(deque));
5715     }
5716 
5717     /**
5718      * @serial include
5719      */
5720     static class AsLIFOQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
5721         implements Queue&lt;E&gt;, Serializable {
<span class="line-added">5722         @java.io.Serial</span>
5723         private static final long serialVersionUID = 1802017725587941708L;
<span class="line-added">5724         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
5725         private final Deque&lt;E&gt; q;
5726         AsLIFOQueue(Deque&lt;E&gt; q)                     { this.q = q; }
5727         public boolean add(E e)                     { q.addFirst(e); return true; }
5728         public boolean offer(E e)                   { return q.offerFirst(e); }
5729         public E poll()                             { return q.pollFirst(); }
5730         public E remove()                           { return q.removeFirst(); }
5731         public E peek()                             { return q.peekFirst(); }
5732         public E element()                          { return q.getFirst(); }
5733         public void clear()                         {        q.clear(); }
5734         public int size()                           { return q.size(); }
5735         public boolean isEmpty()                    { return q.isEmpty(); }
5736         public boolean contains(Object o)           { return q.contains(o); }
5737         public boolean remove(Object o)             { return q.remove(o); }
5738         public Iterator&lt;E&gt; iterator()               { return q.iterator(); }
5739         public Object[] toArray()                   { return q.toArray(); }
5740         public &lt;T&gt; T[] toArray(T[] a)               { return q.toArray(a); }
5741         public &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; f)  { return q.toArray(f); }
5742         public String toString()                    { return q.toString(); }
5743         public boolean containsAll(Collection&lt;?&gt; c) { return q.containsAll(c); }
5744         public boolean removeAll(Collection&lt;?&gt; c)   { return q.removeAll(c); }
</pre>
</td>
</tr>
</table>
<center><a href="Collection.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Comparators.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
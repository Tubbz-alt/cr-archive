<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/jar/Manifest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaUtilJarAccessImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/jar/Manifest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.jar;
 27 
 28 import java.io.DataOutputStream;
 29 import java.io.FilterInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.OutputStream;
 33 import java.util.HashMap;
 34 import java.util.Map;
 35 

 36 import sun.security.util.SecurityProperties;
 37 
<span class="line-removed"> 38 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-removed"> 39 </span>
 40 /**
 41  * The Manifest class is used to maintain Manifest entry names and their
 42  * associated Attributes. There are main Manifest Attributes as well as
 43  * per-entry Attributes. For information on the Manifest format, please
 44  * see the
 45  * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;
 46  * Manifest format specification&lt;/a&gt;.
 47  *
 48  * @author  David Connelly
 49  * @see     Attributes
 50  * @since   1.2
 51  */
 52 public class Manifest implements Cloneable {
 53 
 54     // manifest main attributes
 55     private final Attributes attr = new Attributes();
 56 
 57     // manifest entries
 58     private final Map&lt;String, Attributes&gt; entries = new HashMap&lt;&gt;();
 59 
</pre>
<hr />
<pre>
178         if (result != null &amp;&amp; jv != null &amp;&amp; ! jv.isTrustedManifestEntry(name)) {
179             throw new SecurityException(&quot;Untrusted manifest entry: &quot; + name);
180         }
181         return result;
182     }
183 
184     /**
185      * Clears the main Attributes as well as the entries in this Manifest.
186      */
187     public void clear() {
188         attr.clear();
189         entries.clear();
190     }
191 
192     /**
193      * Writes the Manifest to the specified OutputStream.
194      * Attributes.Name.MANIFEST_VERSION must be set in
195      * MainAttributes prior to invoking this method.
196      *
197      * @param out the output stream
<span class="line-modified">198      * @exception IOException if an I/O error has occurred</span>
199      * @see #getMainAttributes
200      */
201     public void write(OutputStream out) throws IOException {
202         DataOutputStream dos = new DataOutputStream(out);
203         // Write out the main attributes for the manifest
204         attr.writeMain(dos);
205         // Now write out the per-entry attributes
206         StringBuilder buffer = entries.isEmpty() ? null : new StringBuilder(72);
207         for (Map.Entry&lt;String, Attributes&gt; e : entries.entrySet()) {
208             buffer.setLength(0);
209             buffer.append(&quot;Name: &quot;);
210             buffer.append(e.getKey());
211             println72(dos, buffer.toString());
212             e.getValue().write(dos);
213         }
214         dos.flush();
215     }
216 
217     /**
218      * Adds line breaks to enforce a maximum of 72 bytes per line.
</pre>
<hr />
<pre>
220      * @deprecation Replaced with {@link #println72}.
221      */
222     @Deprecated(since = &quot;13&quot;)
223     static void make72Safe(StringBuffer line) {
224         int length = line.length();
225         int index = 72;
226         while (index &lt; length) {
227             line.insert(index, &quot;\r\n &quot;);
228             index += 74; // + line width + line break (&quot;\r\n&quot;)
229             length += 3; // + line break (&quot;\r\n&quot;) and space
230         }
231     }
232 
233     /**
234      * Writes {@code line} to {@code out} with line breaks and continuation
235      * spaces within the limits of 72 bytes of contents per line followed
236      * by a line break.
237      */
238     static void println72(OutputStream out, String line) throws IOException {
239         if (!line.isEmpty()) {
<span class="line-modified">240             byte[] lineBytes = line.getBytes(UTF_8);</span>
241             int length = lineBytes.length;
242             // first line can hold one byte more than subsequent lines which
243             // start with a continuation line break space
244             out.write(lineBytes[0]);
245             int pos = 1;
246             while (length - pos &gt; 71) {
247                 out.write(lineBytes, pos, 71);
248                 pos += 71;
249                 println(out);
250                 out.write(&#39; &#39;);
251             }
252             out.write(lineBytes, pos, length - pos);
253         }
254         println(out);
255     }
256 
257     /**
258      * Writes a line break to {@code out}.
259      */
260     static void println(OutputStream out) throws IOException {
261         out.write(&#39;\r&#39;);
262         out.write(&#39;\n&#39;);
263     }
264 
265     static String getErrorPosition(String filename, final int lineNumber) {
266         if (filename == null ||
267                 !SecurityProperties.INCLUDE_JAR_NAME_IN_EXCEPTIONS) {
268             return &quot;line &quot; + lineNumber;
269         }
270         return &quot;manifest of &quot; + filename + &quot;:&quot; + lineNumber;
271     }
272 
273     /**
274      * Reads the Manifest from the specified InputStream. The entry
275      * names and attributes read will be merged in with the current
276      * manifest entries.
277      *
278      * @param is the input stream
<span class="line-modified">279      * @exception IOException if an I/O error has occurred</span>
280      */
281     public void read(InputStream is) throws IOException {
282         read(is, null);
283     }
284 
285     private void read(InputStream is, String jarFilename) throws IOException {
286         // Buffered input stream for reading manifest data
287         FastInputStream fis = new FastInputStream(is);
288         // Line buffer
289         byte[] lbuf = new byte[512];
290         // Read the main attributes for the manifest
291         int lineNumber = attr.read(fis, lbuf, jarFilename, 0);
292         // Total number of entries, attributes read
293         int ecount = 0, acount = 0;
294         // Average size of entry attributes
295         int asize = 2;
296         // Now parse the manifest entries
297         int len;
298         String name = null;
299         boolean skipEmptyLines = true;
</pre>
<hr />
<pre>
320                 if (name == null) {
321                     throw new IOException(&quot;invalid manifest format (&quot;
322                               + getErrorPosition(jarFilename, lineNumber) + &quot;)&quot;);
323                 }
324                 if (fis.peek() == &#39; &#39;) {
325                     // name is wrapped
326                     lastline = new byte[len - 6];
327                     System.arraycopy(lbuf, 6, lastline, 0, len - 6);
328                     continue;
329                 }
330             } else {
331                 // continuation line
332                 byte[] buf = new byte[lastline.length + len - 1];
333                 System.arraycopy(lastline, 0, buf, 0, lastline.length);
334                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
335                 if (fis.peek() == &#39; &#39;) {
336                     // name is wrapped
337                     lastline = buf;
338                     continue;
339                 }
<span class="line-modified">340                 name = new String(buf, 0, buf.length, UTF_8);</span>
341                 lastline = null;
342             }
343             Attributes attr = getAttributes(name);
344             if (attr == null) {
345                 attr = new Attributes(asize);
346                 entries.put(name, attr);
347             }
348             lineNumber = attr.read(fis, lbuf, jarFilename, lineNumber);
349             ecount++;
350             acount += attr.size();
351             //XXX: Fix for when the average is 0. When it is 0,
352             // you get an Attributes object with an initial
353             // capacity of 0, which tickles a bug in HashMap.
354             asize = Math.max(2, acount / ecount);
355 
356             name = null;
357             skipEmptyLines = true;
358         }
359     }
360 
361     private String parseName(byte[] lbuf, int len) {
362         if (toLower(lbuf[0]) == &#39;n&#39; &amp;&amp; toLower(lbuf[1]) == &#39;a&#39; &amp;&amp;
363             toLower(lbuf[2]) == &#39;m&#39; &amp;&amp; toLower(lbuf[3]) == &#39;e&#39; &amp;&amp;
364             lbuf[4] == &#39;:&#39; &amp;&amp; lbuf[5] == &#39; &#39;) {
<span class="line-modified">365             try {</span>
<span class="line-removed">366                 return new String(lbuf, 6, len - 6, UTF_8);</span>
<span class="line-removed">367             }</span>
<span class="line-removed">368             catch (Exception e) {</span>
<span class="line-removed">369             }</span>
370         }
371         return null;
372     }
373 
374     private int toLower(int c) {
375         return (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? &#39;a&#39; + (c - &#39;A&#39;) : c;
376     }
377 
378     /**
379      * Returns true if the specified Object is also a Manifest and has
380      * the same main Attributes and entries.
381      *
382      * @param o the object to be compared
383      * @return true if the specified Object is also a Manifest and has
384      * the same main Attributes and entries
385      */
386     public boolean equals(Object o) {
387         if (o instanceof Manifest) {
388             Manifest m = (Manifest)o;
389             return attr.equals(m.getMainAttributes()) &amp;&amp;
</pre>
</td>
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.jar;
 27 
 28 import java.io.DataOutputStream;
 29 import java.io.FilterInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.OutputStream;
 33 import java.util.HashMap;
 34 import java.util.Map;
 35 
<span class="line-added"> 36 import sun.nio.cs.UTF_8;</span>
 37 import sun.security.util.SecurityProperties;
 38 


 39 /**
 40  * The Manifest class is used to maintain Manifest entry names and their
 41  * associated Attributes. There are main Manifest Attributes as well as
 42  * per-entry Attributes. For information on the Manifest format, please
 43  * see the
 44  * &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html&quot;&gt;
 45  * Manifest format specification&lt;/a&gt;.
 46  *
 47  * @author  David Connelly
 48  * @see     Attributes
 49  * @since   1.2
 50  */
 51 public class Manifest implements Cloneable {
 52 
 53     // manifest main attributes
 54     private final Attributes attr = new Attributes();
 55 
 56     // manifest entries
 57     private final Map&lt;String, Attributes&gt; entries = new HashMap&lt;&gt;();
 58 
</pre>
<hr />
<pre>
177         if (result != null &amp;&amp; jv != null &amp;&amp; ! jv.isTrustedManifestEntry(name)) {
178             throw new SecurityException(&quot;Untrusted manifest entry: &quot; + name);
179         }
180         return result;
181     }
182 
183     /**
184      * Clears the main Attributes as well as the entries in this Manifest.
185      */
186     public void clear() {
187         attr.clear();
188         entries.clear();
189     }
190 
191     /**
192      * Writes the Manifest to the specified OutputStream.
193      * Attributes.Name.MANIFEST_VERSION must be set in
194      * MainAttributes prior to invoking this method.
195      *
196      * @param out the output stream
<span class="line-modified">197      * @throws    IOException if an I/O error has occurred</span>
198      * @see #getMainAttributes
199      */
200     public void write(OutputStream out) throws IOException {
201         DataOutputStream dos = new DataOutputStream(out);
202         // Write out the main attributes for the manifest
203         attr.writeMain(dos);
204         // Now write out the per-entry attributes
205         StringBuilder buffer = entries.isEmpty() ? null : new StringBuilder(72);
206         for (Map.Entry&lt;String, Attributes&gt; e : entries.entrySet()) {
207             buffer.setLength(0);
208             buffer.append(&quot;Name: &quot;);
209             buffer.append(e.getKey());
210             println72(dos, buffer.toString());
211             e.getValue().write(dos);
212         }
213         dos.flush();
214     }
215 
216     /**
217      * Adds line breaks to enforce a maximum of 72 bytes per line.
</pre>
<hr />
<pre>
219      * @deprecation Replaced with {@link #println72}.
220      */
221     @Deprecated(since = &quot;13&quot;)
222     static void make72Safe(StringBuffer line) {
223         int length = line.length();
224         int index = 72;
225         while (index &lt; length) {
226             line.insert(index, &quot;\r\n &quot;);
227             index += 74; // + line width + line break (&quot;\r\n&quot;)
228             length += 3; // + line break (&quot;\r\n&quot;) and space
229         }
230     }
231 
232     /**
233      * Writes {@code line} to {@code out} with line breaks and continuation
234      * spaces within the limits of 72 bytes of contents per line followed
235      * by a line break.
236      */
237     static void println72(OutputStream out, String line) throws IOException {
238         if (!line.isEmpty()) {
<span class="line-modified">239             byte[] lineBytes = line.getBytes(UTF_8.INSTANCE);</span>
240             int length = lineBytes.length;
241             // first line can hold one byte more than subsequent lines which
242             // start with a continuation line break space
243             out.write(lineBytes[0]);
244             int pos = 1;
245             while (length - pos &gt; 71) {
246                 out.write(lineBytes, pos, 71);
247                 pos += 71;
248                 println(out);
249                 out.write(&#39; &#39;);
250             }
251             out.write(lineBytes, pos, length - pos);
252         }
253         println(out);
254     }
255 
256     /**
257      * Writes a line break to {@code out}.
258      */
259     static void println(OutputStream out) throws IOException {
260         out.write(&#39;\r&#39;);
261         out.write(&#39;\n&#39;);
262     }
263 
264     static String getErrorPosition(String filename, final int lineNumber) {
265         if (filename == null ||
266                 !SecurityProperties.INCLUDE_JAR_NAME_IN_EXCEPTIONS) {
267             return &quot;line &quot; + lineNumber;
268         }
269         return &quot;manifest of &quot; + filename + &quot;:&quot; + lineNumber;
270     }
271 
272     /**
273      * Reads the Manifest from the specified InputStream. The entry
274      * names and attributes read will be merged in with the current
275      * manifest entries.
276      *
277      * @param is the input stream
<span class="line-modified">278      * @throws    IOException if an I/O error has occurred</span>
279      */
280     public void read(InputStream is) throws IOException {
281         read(is, null);
282     }
283 
284     private void read(InputStream is, String jarFilename) throws IOException {
285         // Buffered input stream for reading manifest data
286         FastInputStream fis = new FastInputStream(is);
287         // Line buffer
288         byte[] lbuf = new byte[512];
289         // Read the main attributes for the manifest
290         int lineNumber = attr.read(fis, lbuf, jarFilename, 0);
291         // Total number of entries, attributes read
292         int ecount = 0, acount = 0;
293         // Average size of entry attributes
294         int asize = 2;
295         // Now parse the manifest entries
296         int len;
297         String name = null;
298         boolean skipEmptyLines = true;
</pre>
<hr />
<pre>
319                 if (name == null) {
320                     throw new IOException(&quot;invalid manifest format (&quot;
321                               + getErrorPosition(jarFilename, lineNumber) + &quot;)&quot;);
322                 }
323                 if (fis.peek() == &#39; &#39;) {
324                     // name is wrapped
325                     lastline = new byte[len - 6];
326                     System.arraycopy(lbuf, 6, lastline, 0, len - 6);
327                     continue;
328                 }
329             } else {
330                 // continuation line
331                 byte[] buf = new byte[lastline.length + len - 1];
332                 System.arraycopy(lastline, 0, buf, 0, lastline.length);
333                 System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);
334                 if (fis.peek() == &#39; &#39;) {
335                     // name is wrapped
336                     lastline = buf;
337                     continue;
338                 }
<span class="line-modified">339                 name = new String(buf, 0, buf.length, UTF_8.INSTANCE);</span>
340                 lastline = null;
341             }
342             Attributes attr = getAttributes(name);
343             if (attr == null) {
344                 attr = new Attributes(asize);
345                 entries.put(name, attr);
346             }
347             lineNumber = attr.read(fis, lbuf, jarFilename, lineNumber);
348             ecount++;
349             acount += attr.size();
350             //XXX: Fix for when the average is 0. When it is 0,
351             // you get an Attributes object with an initial
352             // capacity of 0, which tickles a bug in HashMap.
353             asize = Math.max(2, acount / ecount);
354 
355             name = null;
356             skipEmptyLines = true;
357         }
358     }
359 
360     private String parseName(byte[] lbuf, int len) {
361         if (toLower(lbuf[0]) == &#39;n&#39; &amp;&amp; toLower(lbuf[1]) == &#39;a&#39; &amp;&amp;
362             toLower(lbuf[2]) == &#39;m&#39; &amp;&amp; toLower(lbuf[3]) == &#39;e&#39; &amp;&amp;
363             lbuf[4] == &#39;:&#39; &amp;&amp; lbuf[5] == &#39; &#39;) {
<span class="line-modified">364             return new String(lbuf, 6, len - 6, UTF_8.INSTANCE);</span>




365         }
366         return null;
367     }
368 
369     private int toLower(int c) {
370         return (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? &#39;a&#39; + (c - &#39;A&#39;) : c;
371     }
372 
373     /**
374      * Returns true if the specified Object is also a Manifest and has
375      * the same main Attributes and entries.
376      *
377      * @param o the object to be compared
378      * @return true if the specified Object is also a Manifest and has
379      * the same main Attributes and entries
380      */
381     public boolean equals(Object o) {
382         if (o instanceof Manifest) {
383             Manifest m = (Manifest)o;
384             return attr.equals(m.getMainAttributes()) &amp;&amp;
</pre>
</td>
</tr>
</table>
<center><a href="JavaUtilJarAccessImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/StringUTF16.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringLatin1.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SuppressWarnings.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/StringUTF16.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.util.Arrays;
  29 import java.util.Locale;
  30 import java.util.Spliterator;
  31 import java.util.function.Consumer;
  32 import java.util.function.IntConsumer;
  33 import java.util.stream.Stream;
  34 import java.util.stream.StreamSupport;
  35 import jdk.internal.HotSpotIntrinsicCandidate;

  36 import jdk.internal.vm.annotation.ForceInline;
  37 import jdk.internal.vm.annotation.DontInline;
  38 
  39 import static java.lang.String.UTF16;
  40 import static java.lang.String.LATIN1;
  41 
  42 final class StringUTF16 {
  43 
  44     public static byte[] newBytesFor(int len) {
  45         if (len &lt; 0) {
  46             throw new NegativeArraySizeException();
  47         }
  48         if (len &gt; MAX_LENGTH) {
  49             throw new OutOfMemoryError(&quot;UTF16 String size is &quot; + len +
  50                                        &quot;, should be less than &quot; + MAX_LENGTH);
  51         }
  52         return new byte[len &lt;&lt; 1];
  53     }
  54 
  55     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
 471     }
 472 
 473     private static int indexOfCharUnsafe(byte[] value, int ch, int fromIndex, int max) {
 474         for (int i = fromIndex; i &lt; max; i++) {
 475             if (getChar(value, i) == ch) {
 476                 return i;
 477             }
 478         }
 479         return -1;
 480     }
 481 
 482     /**
 483      * Handles (rare) calls of indexOf with a supplementary character.
 484      */
 485     private static int indexOfSupplementary(byte[] value, int ch, int fromIndex, int max) {
 486         if (Character.isValidCodePoint(ch)) {
 487             final char hi = Character.highSurrogate(ch);
 488             final char lo = Character.lowSurrogate(ch);
 489             checkBoundsBeginEnd(fromIndex, max, value);
 490             for (int i = fromIndex; i &lt; max - 1; i++) {
<span class="line-modified"> 491                 if (getChar(value, i) == hi &amp;&amp; getChar(value, i + 1 ) == lo) {</span>
 492                     return i;
 493                 }
 494             }
 495         }
 496         return -1;
 497     }
 498 
 499     // srcCoder == UTF16 &amp;&amp; tgtCoder == UTF16
 500     public static int lastIndexOf(byte[] src, int srcCount,
 501                                   byte[] tgt, int tgtCount, int fromIndex) {
 502         assert fromIndex &gt;= 0;
 503         assert tgtCount &gt; 0;
 504         assert tgtCount &lt;= length(tgt);
 505         int min = tgtCount - 1;
 506         int i = min + fromIndex;
 507         int strLastIndex = tgtCount - 1;
 508 
 509         checkIndex(strLastIndex, tgt);
 510         char strLastChar = getChar(tgt, strLastIndex);
 511 
</pre>
<hr />
<pre>
 557             char lo = Character.lowSurrogate(ch);
 558             int i = Math.min(fromIndex, (value.length &gt;&gt; 1) - 2);
 559             for (; i &gt;= 0; i--) {
 560                 if (getChar(value, i) == hi &amp;&amp; getChar(value, i + 1) == lo) {
 561                     return i;
 562                 }
 563             }
 564         }
 565         return -1;
 566     }
 567 
 568     public static String replace(byte[] value, char oldChar, char newChar) {
 569         int len = value.length &gt;&gt; 1;
 570         int i = -1;
 571         while (++i &lt; len) {
 572             if (getChar(value, i) == oldChar) {
 573                 break;
 574             }
 575         }
 576         if (i &lt; len) {
<span class="line-modified"> 577             byte buf[] = new byte[value.length];</span>
 578             for (int j = 0; j &lt; i; j++) {
 579                 putChar(buf, j, getChar(value, j)); // TBD:arraycopy?
 580             }
 581             while (i &lt; len) {
 582                 char c = getChar(value, i);
 583                 putChar(buf, i, c == oldChar ? newChar : c);
 584                 i++;
<span class="line-modified"> 585            }</span>
<span class="line-modified"> 586            // Check if we should try to compress to latin1</span>
<span class="line-modified"> 587            if (String.COMPACT_STRINGS &amp;&amp;</span>
<span class="line-modified"> 588                !StringLatin1.canEncode(oldChar) &amp;&amp;</span>
<span class="line-modified"> 589                StringLatin1.canEncode(newChar)) {</span>
<span class="line-modified"> 590                byte[] val = compress(buf, 0, len);</span>
<span class="line-modified"> 591                if (val != null) {</span>
<span class="line-modified"> 592                    return new String(val, LATIN1);</span>
<span class="line-modified"> 593                }</span>
<span class="line-modified"> 594            }</span>
<span class="line-modified"> 595            return new String(buf, UTF16);</span>
 596         }
 597         return null;
 598     }
 599 




















































































































 600     public static boolean regionMatchesCI(byte[] value, int toffset,
 601                                           byte[] other, int ooffset, int len) {
 602         int last = toffset + len;
 603         assert toffset &gt;= 0 &amp;&amp; ooffset &gt;= 0;
 604         assert ooffset + len &lt;= length(other);
 605         assert last &lt;= length(value);
 606         while (toffset &lt; last) {
 607             char c1 = getChar(value, toffset++);
 608             char c2 = getChar(other, ooffset++);
 609             if (c1 == c2) {
 610                 continue;
 611             }
 612             // try converting both characters to uppercase.
 613             // If the results match, then the comparison scan should
 614             // continue.
 615             char u1 = Character.toUpperCase(c1);
 616             char u2 = Character.toUpperCase(c2);
 617             if (u1 == u2) {
 618                 continue;
 619             }
</pre>
<hr />
<pre>
 985                 int start = index;
 986                 index = mid;
 987                 return new LinesSpliterator(value, start, mid - start);
 988             }
 989             return null;
 990         }
 991 
 992         @Override
 993         public long estimateSize() {
 994             return fence - index + 1;
 995         }
 996 
 997         @Override
 998         public int characteristics() {
 999             return Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL;
1000         }
1001 
1002         static LinesSpliterator spliterator(byte[] value) {
1003             return new LinesSpliterator(value, 0, value.length &gt;&gt;&gt; 1);
1004         }
<span class="line-removed">1005 </span>
<span class="line-removed">1006         static LinesSpliterator spliterator(byte[] value, int leading, int trailing) {</span>
<span class="line-removed">1007             int length = value.length &gt;&gt;&gt; 1;</span>
<span class="line-removed">1008             int left = 0;</span>
<span class="line-removed">1009             int index;</span>
<span class="line-removed">1010             for (int l = 0; l &lt; leading; l++) {</span>
<span class="line-removed">1011                 index = skipBlankForward(value, left, length);</span>
<span class="line-removed">1012                 if (index == left) {</span>
<span class="line-removed">1013                     break;</span>
<span class="line-removed">1014                 }</span>
<span class="line-removed">1015                 left = index;</span>
<span class="line-removed">1016             }</span>
<span class="line-removed">1017             int right = length;</span>
<span class="line-removed">1018             for (int t = 0; t &lt; trailing; t++) {</span>
<span class="line-removed">1019                 index = skipBlankBackward(value, left, right);</span>
<span class="line-removed">1020                 if (index == right) {</span>
<span class="line-removed">1021                     break;</span>
<span class="line-removed">1022                 }</span>
<span class="line-removed">1023                 right = index;</span>
<span class="line-removed">1024             }</span>
<span class="line-removed">1025             return new LinesSpliterator(value, left, right - left);</span>
<span class="line-removed">1026         }</span>
<span class="line-removed">1027 </span>
<span class="line-removed">1028         private static int skipBlankForward(byte[] value, int start, int length) {</span>
<span class="line-removed">1029             int index = start;</span>
<span class="line-removed">1030             while (index &lt; length) {</span>
<span class="line-removed">1031                 char ch = getChar(value, index++);</span>
<span class="line-removed">1032                 if (ch == &#39;\n&#39;) {</span>
<span class="line-removed">1033                     return index;</span>
<span class="line-removed">1034                 }</span>
<span class="line-removed">1035                 if (ch == &#39;\r&#39;) {</span>
<span class="line-removed">1036                     if (index &lt; length &amp;&amp; getChar(value, index) == &#39;\n&#39;) {</span>
<span class="line-removed">1037                         return index + 1;</span>
<span class="line-removed">1038                     }</span>
<span class="line-removed">1039                     return index;</span>
<span class="line-removed">1040                 }</span>
<span class="line-removed">1041                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
<span class="line-removed">1042                     return start;</span>
<span class="line-removed">1043                 }</span>
<span class="line-removed">1044             }</span>
<span class="line-removed">1045             return length;</span>
<span class="line-removed">1046         }</span>
<span class="line-removed">1047 </span>
<span class="line-removed">1048         private static int skipBlankBackward(byte[] value, int start, int fence) {</span>
<span class="line-removed">1049             int index = fence;</span>
<span class="line-removed">1050             if (start &lt; index &amp;&amp; getChar(value, index - 1) == &#39;\n&#39;) {</span>
<span class="line-removed">1051                 index--;</span>
<span class="line-removed">1052             }</span>
<span class="line-removed">1053             if (start &lt; index &amp;&amp; getChar(value, index - 1) == &#39;\r&#39;) {</span>
<span class="line-removed">1054                 index--;</span>
<span class="line-removed">1055             }</span>
<span class="line-removed">1056             while (start &lt; index) {</span>
<span class="line-removed">1057                 char ch = getChar(value, --index);</span>
<span class="line-removed">1058                 if (ch == &#39;\r&#39; || ch == &#39;\n&#39;) {</span>
<span class="line-removed">1059                     return index + 1;</span>
<span class="line-removed">1060                 }</span>
<span class="line-removed">1061                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; !Character.isWhitespace(ch)) {</span>
<span class="line-removed">1062                     return fence;</span>
<span class="line-removed">1063                 }</span>
<span class="line-removed">1064             }</span>
<span class="line-removed">1065             return start;</span>
<span class="line-removed">1066         }</span>
1067     }
1068 
<span class="line-modified">1069     static Stream&lt;String&gt; lines(byte[] value, int leading, int trailing) {</span>
<span class="line-modified">1070         if (leading == 0 &amp;&amp; trailing == 0) {</span>
<span class="line-removed">1071             return StreamSupport.stream(LinesSpliterator.spliterator(value), false);</span>
<span class="line-removed">1072         } else {</span>
<span class="line-removed">1073             return StreamSupport.stream(LinesSpliterator.spliterator(value, leading, trailing), false);</span>
<span class="line-removed">1074         }</span>
1075     }
1076 
1077     private static void putChars(byte[] val, int index, char[] str, int off, int end) {
1078         while (off &lt; end) {
1079             putChar(val, index++, str[off++]);
1080         }
1081     }
1082 
1083     public static String newString(byte[] val, int index, int len) {
1084         if (String.COMPACT_STRINGS) {
1085             byte[] buf = compress(val, index, len);
1086             if (buf != null) {
1087                 return new String(buf, LATIN1);
1088             }
1089         }
1090         int last = index + len;
1091         return new String(Arrays.copyOfRange(val, index &lt;&lt; 1, last &lt;&lt; 1), UTF16);
1092     }
1093 
1094     public static void fillNull(byte[] val, int index, int end) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.util.Arrays;
  29 import java.util.Locale;
  30 import java.util.Spliterator;
  31 import java.util.function.Consumer;
  32 import java.util.function.IntConsumer;
  33 import java.util.stream.Stream;
  34 import java.util.stream.StreamSupport;
  35 import jdk.internal.HotSpotIntrinsicCandidate;
<span class="line-added">  36 import jdk.internal.util.ArraysSupport;</span>
  37 import jdk.internal.vm.annotation.ForceInline;
  38 import jdk.internal.vm.annotation.DontInline;
  39 
  40 import static java.lang.String.UTF16;
  41 import static java.lang.String.LATIN1;
  42 
  43 final class StringUTF16 {
  44 
  45     public static byte[] newBytesFor(int len) {
  46         if (len &lt; 0) {
  47             throw new NegativeArraySizeException();
  48         }
  49         if (len &gt; MAX_LENGTH) {
  50             throw new OutOfMemoryError(&quot;UTF16 String size is &quot; + len +
  51                                        &quot;, should be less than &quot; + MAX_LENGTH);
  52         }
  53         return new byte[len &lt;&lt; 1];
  54     }
  55 
  56     @HotSpotIntrinsicCandidate
</pre>
<hr />
<pre>
 472     }
 473 
 474     private static int indexOfCharUnsafe(byte[] value, int ch, int fromIndex, int max) {
 475         for (int i = fromIndex; i &lt; max; i++) {
 476             if (getChar(value, i) == ch) {
 477                 return i;
 478             }
 479         }
 480         return -1;
 481     }
 482 
 483     /**
 484      * Handles (rare) calls of indexOf with a supplementary character.
 485      */
 486     private static int indexOfSupplementary(byte[] value, int ch, int fromIndex, int max) {
 487         if (Character.isValidCodePoint(ch)) {
 488             final char hi = Character.highSurrogate(ch);
 489             final char lo = Character.lowSurrogate(ch);
 490             checkBoundsBeginEnd(fromIndex, max, value);
 491             for (int i = fromIndex; i &lt; max - 1; i++) {
<span class="line-modified"> 492                 if (getChar(value, i) == hi &amp;&amp; getChar(value, i + 1) == lo) {</span>
 493                     return i;
 494                 }
 495             }
 496         }
 497         return -1;
 498     }
 499 
 500     // srcCoder == UTF16 &amp;&amp; tgtCoder == UTF16
 501     public static int lastIndexOf(byte[] src, int srcCount,
 502                                   byte[] tgt, int tgtCount, int fromIndex) {
 503         assert fromIndex &gt;= 0;
 504         assert tgtCount &gt; 0;
 505         assert tgtCount &lt;= length(tgt);
 506         int min = tgtCount - 1;
 507         int i = min + fromIndex;
 508         int strLastIndex = tgtCount - 1;
 509 
 510         checkIndex(strLastIndex, tgt);
 511         char strLastChar = getChar(tgt, strLastIndex);
 512 
</pre>
<hr />
<pre>
 558             char lo = Character.lowSurrogate(ch);
 559             int i = Math.min(fromIndex, (value.length &gt;&gt; 1) - 2);
 560             for (; i &gt;= 0; i--) {
 561                 if (getChar(value, i) == hi &amp;&amp; getChar(value, i + 1) == lo) {
 562                     return i;
 563                 }
 564             }
 565         }
 566         return -1;
 567     }
 568 
 569     public static String replace(byte[] value, char oldChar, char newChar) {
 570         int len = value.length &gt;&gt; 1;
 571         int i = -1;
 572         while (++i &lt; len) {
 573             if (getChar(value, i) == oldChar) {
 574                 break;
 575             }
 576         }
 577         if (i &lt; len) {
<span class="line-modified"> 578             byte[] buf = new byte[value.length];</span>
 579             for (int j = 0; j &lt; i; j++) {
 580                 putChar(buf, j, getChar(value, j)); // TBD:arraycopy?
 581             }
 582             while (i &lt; len) {
 583                 char c = getChar(value, i);
 584                 putChar(buf, i, c == oldChar ? newChar : c);
 585                 i++;
<span class="line-modified"> 586             }</span>
<span class="line-modified"> 587             // Check if we should try to compress to latin1</span>
<span class="line-modified"> 588             if (String.COMPACT_STRINGS &amp;&amp;</span>
<span class="line-modified"> 589                 !StringLatin1.canEncode(oldChar) &amp;&amp;</span>
<span class="line-modified"> 590                 StringLatin1.canEncode(newChar)) {</span>
<span class="line-modified"> 591                 byte[] val = compress(buf, 0, len);</span>
<span class="line-modified"> 592                 if (val != null) {</span>
<span class="line-modified"> 593                     return new String(val, LATIN1);</span>
<span class="line-modified"> 594                 }</span>
<span class="line-modified"> 595             }</span>
<span class="line-modified"> 596             return new String(buf, UTF16);</span>
 597         }
 598         return null;
 599     }
 600 
<span class="line-added"> 601     public static String replace(byte[] value, int valLen, boolean valLat1,</span>
<span class="line-added"> 602                                  byte[] targ, int targLen, boolean targLat1,</span>
<span class="line-added"> 603                                  byte[] repl, int replLen, boolean replLat1)</span>
<span class="line-added"> 604     {</span>
<span class="line-added"> 605         assert targLen &gt; 0;</span>
<span class="line-added"> 606         assert !valLat1 || !targLat1 || !replLat1;</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608         //  Possible combinations of the arguments/result encodings:</span>
<span class="line-added"> 609         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 610         //  | # | VALUE  | TARGET | REPL   | RESULT                |</span>
<span class="line-added"> 611         //  +===+========+========+========+=======================+</span>
<span class="line-added"> 612         //  | 1 | Latin1 | Latin1 |  UTF16 | null or UTF16         |</span>
<span class="line-added"> 613         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 614         //  | 2 | Latin1 |  UTF16 | Latin1 | null                  |</span>
<span class="line-added"> 615         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 616         //  | 3 | Latin1 |  UTF16 |  UTF16 | null                  |</span>
<span class="line-added"> 617         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 618         //  | 4 |  UTF16 | Latin1 | Latin1 | null or UTF16         |</span>
<span class="line-added"> 619         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 620         //  | 5 |  UTF16 | Latin1 |  UTF16 | null or UTF16         |</span>
<span class="line-added"> 621         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 622         //  | 6 |  UTF16 |  UTF16 | Latin1 | null, Latin1 or UTF16 |</span>
<span class="line-added"> 623         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 624         //  | 7 |  UTF16 |  UTF16 |  UTF16 | null or UTF16         |</span>
<span class="line-added"> 625         //  +---+--------+--------+--------+-----------------------+</span>
<span class="line-added"> 626 </span>
<span class="line-added"> 627         if (String.COMPACT_STRINGS &amp;&amp; valLat1 &amp;&amp; !targLat1) {</span>
<span class="line-added"> 628             // combinations 2 or 3</span>
<span class="line-added"> 629             return null; // for string to return this;</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         int i = (String.COMPACT_STRINGS &amp;&amp; valLat1)</span>
<span class="line-added"> 633                         ? StringLatin1.indexOf(value, targ) :</span>
<span class="line-added"> 634                 (String.COMPACT_STRINGS &amp;&amp; targLat1)</span>
<span class="line-added"> 635                         ? indexOfLatin1(value, targ)</span>
<span class="line-added"> 636                         : indexOf(value, targ);</span>
<span class="line-added"> 637         if (i &lt; 0) {</span>
<span class="line-added"> 638             return null; // for string to return this;</span>
<span class="line-added"> 639         }</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641         // find and store indices of substrings to replace</span>
<span class="line-added"> 642         int j, p = 0;</span>
<span class="line-added"> 643         int[] pos = new int[16];</span>
<span class="line-added"> 644         pos[0] = i;</span>
<span class="line-added"> 645         i += targLen;</span>
<span class="line-added"> 646         while ((j = ((String.COMPACT_STRINGS &amp;&amp; valLat1)</span>
<span class="line-added"> 647                             ? StringLatin1.indexOf(value, valLen, targ, targLen, i) :</span>
<span class="line-added"> 648                      (String.COMPACT_STRINGS &amp;&amp; targLat1)</span>
<span class="line-added"> 649                             ? indexOfLatin1(value, valLen, targ, targLen, i)</span>
<span class="line-added"> 650                             : indexOf(value, valLen, targ, targLen, i))) &gt; 0)</span>
<span class="line-added"> 651         {</span>
<span class="line-added"> 652             if (++p == pos.length) {</span>
<span class="line-added"> 653                 pos = Arrays.copyOf(pos, ArraysSupport.newLength(p, 1, p &gt;&gt; 1));</span>
<span class="line-added"> 654             }</span>
<span class="line-added"> 655             pos[p] = j;</span>
<span class="line-added"> 656             i = j + targLen;</span>
<span class="line-added"> 657         }</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659         int resultLen;</span>
<span class="line-added"> 660         try {</span>
<span class="line-added"> 661             resultLen = Math.addExact(valLen,</span>
<span class="line-added"> 662                     Math.multiplyExact(++p, replLen - targLen));</span>
<span class="line-added"> 663         } catch (ArithmeticException ignored) {</span>
<span class="line-added"> 664             throw new OutOfMemoryError();</span>
<span class="line-added"> 665         }</span>
<span class="line-added"> 666         if (resultLen == 0) {</span>
<span class="line-added"> 667             return &quot;&quot;;</span>
<span class="line-added"> 668         }</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670         byte[] result = newBytesFor(resultLen);</span>
<span class="line-added"> 671         int posFrom = 0, posTo = 0;</span>
<span class="line-added"> 672         for (int q = 0; q &lt; p; ++q) {</span>
<span class="line-added"> 673             int nextPos = pos[q];</span>
<span class="line-added"> 674             if (String.COMPACT_STRINGS &amp;&amp; valLat1) {</span>
<span class="line-added"> 675                 while (posFrom &lt; nextPos) {</span>
<span class="line-added"> 676                     char c = (char)(value[posFrom++] &amp; 0xff);</span>
<span class="line-added"> 677                     putChar(result, posTo++, c);</span>
<span class="line-added"> 678                 }</span>
<span class="line-added"> 679             } else {</span>
<span class="line-added"> 680                 while (posFrom &lt; nextPos) {</span>
<span class="line-added"> 681                     putChar(result, posTo++, getChar(value, posFrom++));</span>
<span class="line-added"> 682                 }</span>
<span class="line-added"> 683             }</span>
<span class="line-added"> 684             posFrom += targLen;</span>
<span class="line-added"> 685             if (String.COMPACT_STRINGS &amp;&amp; replLat1) {</span>
<span class="line-added"> 686                 for (int k = 0; k &lt; replLen; ++k) {</span>
<span class="line-added"> 687                     char c = (char)(repl[k] &amp; 0xff);</span>
<span class="line-added"> 688                     putChar(result, posTo++, c);</span>
<span class="line-added"> 689                 }</span>
<span class="line-added"> 690             } else {</span>
<span class="line-added"> 691                 for (int k = 0; k &lt; replLen; ++k) {</span>
<span class="line-added"> 692                     putChar(result, posTo++, getChar(repl, k));</span>
<span class="line-added"> 693                 }</span>
<span class="line-added"> 694             }</span>
<span class="line-added"> 695         }</span>
<span class="line-added"> 696         if (String.COMPACT_STRINGS &amp;&amp; valLat1) {</span>
<span class="line-added"> 697             while (posFrom &lt; valLen) {</span>
<span class="line-added"> 698                 char c = (char)(value[posFrom++] &amp; 0xff);</span>
<span class="line-added"> 699                 putChar(result, posTo++, c);</span>
<span class="line-added"> 700             }</span>
<span class="line-added"> 701         } else {</span>
<span class="line-added"> 702             while (posFrom &lt; valLen) {</span>
<span class="line-added"> 703                 putChar(result, posTo++, getChar(value, posFrom++));</span>
<span class="line-added"> 704             }</span>
<span class="line-added"> 705         }</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         if (String.COMPACT_STRINGS &amp;&amp; replLat1 &amp;&amp; !targLat1) {</span>
<span class="line-added"> 708             // combination 6</span>
<span class="line-added"> 709             byte[] lat1Result = compress(result, 0, resultLen);</span>
<span class="line-added"> 710             if (lat1Result != null) {</span>
<span class="line-added"> 711                 return new String(lat1Result, LATIN1);</span>
<span class="line-added"> 712             }</span>
<span class="line-added"> 713         }</span>
<span class="line-added"> 714         return new String(result, UTF16);</span>
<span class="line-added"> 715     }</span>
<span class="line-added"> 716 </span>
 717     public static boolean regionMatchesCI(byte[] value, int toffset,
 718                                           byte[] other, int ooffset, int len) {
 719         int last = toffset + len;
 720         assert toffset &gt;= 0 &amp;&amp; ooffset &gt;= 0;
 721         assert ooffset + len &lt;= length(other);
 722         assert last &lt;= length(value);
 723         while (toffset &lt; last) {
 724             char c1 = getChar(value, toffset++);
 725             char c2 = getChar(other, ooffset++);
 726             if (c1 == c2) {
 727                 continue;
 728             }
 729             // try converting both characters to uppercase.
 730             // If the results match, then the comparison scan should
 731             // continue.
 732             char u1 = Character.toUpperCase(c1);
 733             char u2 = Character.toUpperCase(c2);
 734             if (u1 == u2) {
 735                 continue;
 736             }
</pre>
<hr />
<pre>
1102                 int start = index;
1103                 index = mid;
1104                 return new LinesSpliterator(value, start, mid - start);
1105             }
1106             return null;
1107         }
1108 
1109         @Override
1110         public long estimateSize() {
1111             return fence - index + 1;
1112         }
1113 
1114         @Override
1115         public int characteristics() {
1116             return Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL;
1117         }
1118 
1119         static LinesSpliterator spliterator(byte[] value) {
1120             return new LinesSpliterator(value, 0, value.length &gt;&gt;&gt; 1);
1121         }






























































1122     }
1123 
<span class="line-modified">1124     static Stream&lt;String&gt; lines(byte[] value) {</span>
<span class="line-modified">1125         return StreamSupport.stream(LinesSpliterator.spliterator(value), false);</span>




1126     }
1127 
1128     private static void putChars(byte[] val, int index, char[] str, int off, int end) {
1129         while (off &lt; end) {
1130             putChar(val, index++, str[off++]);
1131         }
1132     }
1133 
1134     public static String newString(byte[] val, int index, int len) {
1135         if (String.COMPACT_STRINGS) {
1136             byte[] buf = compress(val, index, len);
1137             if (buf != null) {
1138                 return new String(buf, LATIN1);
1139             }
1140         }
1141         int last = index + len;
1142         return new String(Arrays.copyOfRange(val, index &lt;&lt; 1, last &lt;&lt; 1), UTF16);
1143     }
1144 
1145     public static void fillNull(byte[] val, int index, int end) {
</pre>
</td>
</tr>
</table>
<center><a href="StringLatin1.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SuppressWarnings.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
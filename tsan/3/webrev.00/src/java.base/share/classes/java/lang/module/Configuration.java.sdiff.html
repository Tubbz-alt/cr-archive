<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/module/Configuration.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../invoke/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FindException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/module/Configuration.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 58  * modules()} method to get the set of resolved modules in the graph. {@code
 59  * ResolvedModule} defines the {@link ResolvedModule#reads() reads()} method to
 60  * get the set of modules that a resolved module reads. The modules that are
 61  * read may be in the same configuration or may be in {@link #parents() parent}
 62  * configurations. &lt;/p&gt;
 63  *
 64  * &lt;p&gt; Configuration defines the {@link #resolve(ModuleFinder,List,ModuleFinder,Collection)
 65  * resolve} method to resolve a collection of root modules, and the {@link
 66  * #resolveAndBind(ModuleFinder,List,ModuleFinder,Collection) resolveAndBind}
 67  * method to do resolution with service binding. There are instance and
 68  * static variants of both methods. The instance methods create a configuration
 69  * with the receiver as the parent configuration. The static methods are for
 70  * more advanced cases where there can be more than one parent configuration. &lt;/p&gt;
 71  *
 72  * &lt;p&gt; Each {@link java.lang.ModuleLayer layer} of modules in the Java virtual
 73  * machine is created from a configuration. The configuration for the {@link
 74  * java.lang.ModuleLayer#boot() boot} layer is obtained by invoking {@code
 75  * ModuleLayer.boot().configuration()}. The configuration for the boot layer
 76  * will often be the parent when creating new configurations. &lt;/p&gt;
 77  *
<span class="line-modified"> 78  * &lt;h3&gt; Example &lt;/h3&gt;</span>
 79  *
 80  * &lt;p&gt; The following example uses the {@link
 81  * #resolve(ModuleFinder,ModuleFinder,Collection) resolve} method to resolve a
 82  * module named &lt;em&gt;myapp&lt;/em&gt; with the configuration for the boot layer as the
 83  * parent configuration. It prints the name of each resolved module and the
 84  * names of the modules that each module reads. &lt;/p&gt;
 85  *
 86  * &lt;pre&gt;{@code
 87  *    ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
 88  *
 89  *    Configuration parent = ModuleLayer.boot().configuration();
 90  *
 91  *    Configuration cf = parent.resolve(finder, ModuleFinder.of(), Set.of(&quot;myapp&quot;));
 92  *    cf.modules().forEach(m -&gt; {
 93  *        System.out.format(&quot;%s -&gt; %s%n&quot;,
 94  *            m.name(),
 95  *            m.reads().stream()
 96  *                .map(ResolvedModule::name)
 97  *                .collect(Collectors.joining(&quot;, &quot;)));
 98  *    });
</pre>
<hr />
<pre>
295     public Configuration resolveAndBind(ModuleFinder before,
296                                         ModuleFinder after,
297                                         Collection&lt;String&gt; roots)
298     {
299         return resolveAndBind(before, List.of(this), after, roots);
300     }
301 
302 
303     /**
304      * Resolves a collection of root modules, with service binding, and with
305      * the empty configuration as its parent.
306      *
307      * This method is used to create the configuration for the boot layer.
308      */
309     static Configuration resolveAndBind(ModuleFinder finder,
310                                         Collection&lt;String&gt; roots,
311                                         PrintStream traceOutput)
312     {
313         List&lt;Configuration&gt; parents = List.of(empty());
314         Resolver resolver = new Resolver(finder, parents, ModuleFinder.of(), traceOutput);
<span class="line-modified">315         resolver.resolve(roots).bind();</span>
316         return new Configuration(parents, resolver);
317     }
318 
319     /**
320      * Resolves a collection of root modules to create a configuration.
321      *
322      * &lt;p&gt; Each root module is located using the given {@code before} module
323      * finder. If a module is not found then it is located in the parent
324      * configuration as if by invoking the {@link #findModule(String)
325      * findModule} method on each parent in iteration order. If not found then
326      * the module is located using the given {@code after} module finder. The
327      * same search order is used to locate transitive dependences. Root modules
328      * or dependences that are located in a parent configuration are resolved
329      * no further and are not included in the resulting configuration. &lt;/p&gt;
330      *
331      * &lt;p&gt; When all modules have been enumerated then a readability graph
332      * is computed, and in conjunction with the module exports and service use,
333      * checked for consistency. &lt;/p&gt;
334      *
335      * &lt;p&gt; Resolution may fail with {@code FindException} for the following
</pre>
<hr />
<pre>
558                     .filter(Objects::nonNull)
559                     .findFirst();
560         }
561 
562         return Optional.empty();
563     }
564 
565 
566     Set&lt;ModuleDescriptor&gt; descriptors() {
567         if (modules.isEmpty()) {
568             return Set.of();
569         } else {
570             return modules.stream()
571                     .map(ResolvedModule::reference)
572                     .map(ModuleReference::descriptor)
573                     .collect(Collectors.toSet());
574         }
575     }
576 
577     Set&lt;ResolvedModule&gt; reads(ResolvedModule m) {
<span class="line-modified">578         return Collections.unmodifiableSet(graph.get(m));</span>

579     }
580 
581     /**
582      * Returns an ordered stream of configurations. The first element is this
583      * configuration, the remaining elements are the parent configurations
584      * in DFS order.
585      *
586      * @implNote For now, the assumption is that the number of elements will
587      * be very low and so this method does not use a specialized spliterator.
588      */
589     Stream&lt;Configuration&gt; configurations() {
590         List&lt;Configuration&gt; allConfigurations = this.allConfigurations;
591         if (allConfigurations == null) {
592             allConfigurations = new ArrayList&lt;&gt;();
593             Set&lt;Configuration&gt; visited = new HashSet&lt;&gt;();
594             Deque&lt;Configuration&gt; stack = new ArrayDeque&lt;&gt;();
595             visited.add(this);
596             stack.push(this);
597             while (!stack.isEmpty()) {
598                 Configuration layer = stack.pop();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 58  * modules()} method to get the set of resolved modules in the graph. {@code
 59  * ResolvedModule} defines the {@link ResolvedModule#reads() reads()} method to
 60  * get the set of modules that a resolved module reads. The modules that are
 61  * read may be in the same configuration or may be in {@link #parents() parent}
 62  * configurations. &lt;/p&gt;
 63  *
 64  * &lt;p&gt; Configuration defines the {@link #resolve(ModuleFinder,List,ModuleFinder,Collection)
 65  * resolve} method to resolve a collection of root modules, and the {@link
 66  * #resolveAndBind(ModuleFinder,List,ModuleFinder,Collection) resolveAndBind}
 67  * method to do resolution with service binding. There are instance and
 68  * static variants of both methods. The instance methods create a configuration
 69  * with the receiver as the parent configuration. The static methods are for
 70  * more advanced cases where there can be more than one parent configuration. &lt;/p&gt;
 71  *
 72  * &lt;p&gt; Each {@link java.lang.ModuleLayer layer} of modules in the Java virtual
 73  * machine is created from a configuration. The configuration for the {@link
 74  * java.lang.ModuleLayer#boot() boot} layer is obtained by invoking {@code
 75  * ModuleLayer.boot().configuration()}. The configuration for the boot layer
 76  * will often be the parent when creating new configurations. &lt;/p&gt;
 77  *
<span class="line-modified"> 78  * &lt;h2&gt; Example &lt;/h2&gt;</span>
 79  *
 80  * &lt;p&gt; The following example uses the {@link
 81  * #resolve(ModuleFinder,ModuleFinder,Collection) resolve} method to resolve a
 82  * module named &lt;em&gt;myapp&lt;/em&gt; with the configuration for the boot layer as the
 83  * parent configuration. It prints the name of each resolved module and the
 84  * names of the modules that each module reads. &lt;/p&gt;
 85  *
 86  * &lt;pre&gt;{@code
 87  *    ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);
 88  *
 89  *    Configuration parent = ModuleLayer.boot().configuration();
 90  *
 91  *    Configuration cf = parent.resolve(finder, ModuleFinder.of(), Set.of(&quot;myapp&quot;));
 92  *    cf.modules().forEach(m -&gt; {
 93  *        System.out.format(&quot;%s -&gt; %s%n&quot;,
 94  *            m.name(),
 95  *            m.reads().stream()
 96  *                .map(ResolvedModule::name)
 97  *                .collect(Collectors.joining(&quot;, &quot;)));
 98  *    });
</pre>
<hr />
<pre>
295     public Configuration resolveAndBind(ModuleFinder before,
296                                         ModuleFinder after,
297                                         Collection&lt;String&gt; roots)
298     {
299         return resolveAndBind(before, List.of(this), after, roots);
300     }
301 
302 
303     /**
304      * Resolves a collection of root modules, with service binding, and with
305      * the empty configuration as its parent.
306      *
307      * This method is used to create the configuration for the boot layer.
308      */
309     static Configuration resolveAndBind(ModuleFinder finder,
310                                         Collection&lt;String&gt; roots,
311                                         PrintStream traceOutput)
312     {
313         List&lt;Configuration&gt; parents = List.of(empty());
314         Resolver resolver = new Resolver(finder, parents, ModuleFinder.of(), traceOutput);
<span class="line-modified">315         resolver.resolve(roots).bind(/*bindIncubatorModules*/false);</span>
316         return new Configuration(parents, resolver);
317     }
318 
319     /**
320      * Resolves a collection of root modules to create a configuration.
321      *
322      * &lt;p&gt; Each root module is located using the given {@code before} module
323      * finder. If a module is not found then it is located in the parent
324      * configuration as if by invoking the {@link #findModule(String)
325      * findModule} method on each parent in iteration order. If not found then
326      * the module is located using the given {@code after} module finder. The
327      * same search order is used to locate transitive dependences. Root modules
328      * or dependences that are located in a parent configuration are resolved
329      * no further and are not included in the resulting configuration. &lt;/p&gt;
330      *
331      * &lt;p&gt; When all modules have been enumerated then a readability graph
332      * is computed, and in conjunction with the module exports and service use,
333      * checked for consistency. &lt;/p&gt;
334      *
335      * &lt;p&gt; Resolution may fail with {@code FindException} for the following
</pre>
<hr />
<pre>
558                     .filter(Objects::nonNull)
559                     .findFirst();
560         }
561 
562         return Optional.empty();
563     }
564 
565 
566     Set&lt;ModuleDescriptor&gt; descriptors() {
567         if (modules.isEmpty()) {
568             return Set.of();
569         } else {
570             return modules.stream()
571                     .map(ResolvedModule::reference)
572                     .map(ModuleReference::descriptor)
573                     .collect(Collectors.toSet());
574         }
575     }
576 
577     Set&lt;ResolvedModule&gt; reads(ResolvedModule m) {
<span class="line-modified">578         // The sets stored in the graph are already immutable sets</span>
<span class="line-added">579         return Set.copyOf(graph.get(m));</span>
580     }
581 
582     /**
583      * Returns an ordered stream of configurations. The first element is this
584      * configuration, the remaining elements are the parent configurations
585      * in DFS order.
586      *
587      * @implNote For now, the assumption is that the number of elements will
588      * be very low and so this method does not use a specialized spliterator.
589      */
590     Stream&lt;Configuration&gt; configurations() {
591         List&lt;Configuration&gt; allConfigurations = this.allConfigurations;
592         if (allConfigurations == null) {
593             allConfigurations = new ArrayList&lt;&gt;();
594             Set&lt;Configuration&gt; visited = new HashSet&lt;&gt;();
595             Deque&lt;Configuration&gt; stack = new ArrayDeque&lt;&gt;();
596             visited.add(this);
597             stack.push(this);
598             while (!stack.isEmpty()) {
599                 Configuration layer = stack.pop();
</pre>
</td>
</tr>
</table>
<center><a href="../invoke/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FindException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
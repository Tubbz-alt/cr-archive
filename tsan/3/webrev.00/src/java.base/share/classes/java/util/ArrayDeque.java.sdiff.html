<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/ArrayDeque.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ArrayDeque.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1140     }
1141 
1142     // *** Object methods ***
1143 
1144     /**
1145      * Returns a copy of this deque.
1146      *
1147      * @return a copy of this deque
1148      */
1149     public ArrayDeque&lt;E&gt; clone() {
1150         try {
1151             @SuppressWarnings(&quot;unchecked&quot;)
1152             ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) super.clone();
1153             result.elements = Arrays.copyOf(elements, elements.length);
1154             return result;
1155         } catch (CloneNotSupportedException e) {
1156             throw new AssertionError();
1157         }
1158     }
1159 

1160     private static final long serialVersionUID = 2340985798034038923L;
1161 
1162     /**
1163      * Saves this deque to a stream (that is, serializes it).
1164      *
1165      * @param s the stream
1166      * @throws java.io.IOException if an I/O error occurs
1167      * @serialData The current size ({@code int}) of the deque,
1168      * followed by all of its elements (each an object reference) in
1169      * first-to-last order.
1170      */

1171     private void writeObject(java.io.ObjectOutputStream s)
1172             throws java.io.IOException {
1173         s.defaultWriteObject();
1174 
1175         // Write out size
1176         s.writeInt(size());
1177 
1178         // Write out elements in order.
1179         final Object[] es = elements;
1180         for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length;
1181              ; i = 0, to = end) {
1182             for (; i &lt; to; i++)
1183                 s.writeObject(es[i]);
1184             if (to == end) break;
1185         }
1186     }
1187 
1188     /**
1189      * Reconstitutes this deque from a stream (that is, deserializes it).
1190      * @param s the stream
1191      * @throws ClassNotFoundException if the class of a serialized object
1192      *         could not be found
1193      * @throws java.io.IOException if an I/O error occurs
1194      */

1195     private void readObject(java.io.ObjectInputStream s)
1196             throws java.io.IOException, ClassNotFoundException {
1197         s.defaultReadObject();
1198 
1199         // Read in size and allocate array
1200         int size = s.readInt();
1201         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size + 1);
1202         elements = new Object[size + 1];
1203         this.tail = size;
1204 
1205         // Read in all elements in the proper order.
1206         for (int i = 0; i &lt; size; i++)
1207             elements[i] = s.readObject();
1208     }
1209 
1210     /** debugging */
1211     void checkInvariants() {
1212         // Use head and tail fields with empty slot at tail strategy.
1213         // head == tail disambiguates to &quot;empty&quot;.
1214         try {
</pre>
</td>
<td>
<hr />
<pre>
1140     }
1141 
1142     // *** Object methods ***
1143 
1144     /**
1145      * Returns a copy of this deque.
1146      *
1147      * @return a copy of this deque
1148      */
1149     public ArrayDeque&lt;E&gt; clone() {
1150         try {
1151             @SuppressWarnings(&quot;unchecked&quot;)
1152             ArrayDeque&lt;E&gt; result = (ArrayDeque&lt;E&gt;) super.clone();
1153             result.elements = Arrays.copyOf(elements, elements.length);
1154             return result;
1155         } catch (CloneNotSupportedException e) {
1156             throw new AssertionError();
1157         }
1158     }
1159 
<span class="line-added">1160     @java.io.Serial</span>
1161     private static final long serialVersionUID = 2340985798034038923L;
1162 
1163     /**
1164      * Saves this deque to a stream (that is, serializes it).
1165      *
1166      * @param s the stream
1167      * @throws java.io.IOException if an I/O error occurs
1168      * @serialData The current size ({@code int}) of the deque,
1169      * followed by all of its elements (each an object reference) in
1170      * first-to-last order.
1171      */
<span class="line-added">1172     @java.io.Serial</span>
1173     private void writeObject(java.io.ObjectOutputStream s)
1174             throws java.io.IOException {
1175         s.defaultWriteObject();
1176 
1177         // Write out size
1178         s.writeInt(size());
1179 
1180         // Write out elements in order.
1181         final Object[] es = elements;
1182         for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length;
1183              ; i = 0, to = end) {
1184             for (; i &lt; to; i++)
1185                 s.writeObject(es[i]);
1186             if (to == end) break;
1187         }
1188     }
1189 
1190     /**
1191      * Reconstitutes this deque from a stream (that is, deserializes it).
1192      * @param s the stream
1193      * @throws ClassNotFoundException if the class of a serialized object
1194      *         could not be found
1195      * @throws java.io.IOException if an I/O error occurs
1196      */
<span class="line-added">1197     @java.io.Serial</span>
1198     private void readObject(java.io.ObjectInputStream s)
1199             throws java.io.IOException, ClassNotFoundException {
1200         s.defaultReadObject();
1201 
1202         // Read in size and allocate array
1203         int size = s.readInt();
1204         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size + 1);
1205         elements = new Object[size + 1];
1206         this.tail = size;
1207 
1208         // Read in all elements in the proper order.
1209         for (int i = 0; i &lt; size; i++)
1210             elements[i] = s.readObject();
1211     }
1212 
1213     /** debugging */
1214     void checkInvariants() {
1215         // Use head and tail fields with empty slot at tail strategy.
1216         // head == tail disambiguates to &quot;empty&quot;.
1217         try {
</pre>
</td>
</tr>
</table>
<center><a href="AbstractMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArrayList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
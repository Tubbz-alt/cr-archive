<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Arrays.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Base64.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ArraysParallelSortHelpers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,11 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  package java.util;
  
<span class="line-removed">- import java.util.concurrent.RecursiveAction;</span>
  import java.util.concurrent.CountedCompleter;
  
  /**
   * Helper utilities for the parallel sort methods in Arrays.parallelSort.
   *
<span class="line-new-header">--- 22,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
   * contain the Sorter and Merger implementations for that type:
   *
   * Sorter classes based mainly on CilkSort
   * &lt;A href=&quot;http://supertech.lcs.mit.edu/cilk/&quot;&gt; Cilk&lt;/A&gt;:
   * Basic algorithm:
<span class="line-modified">!  * if array size is small, just use a sequential quicksort (via Arrays.sort)</span>
   *         Otherwise:
   *         1. Break array in half.
   *         2. For each half,
   *             a. break the half in half (i.e., quarters),
   *             b. sort the quarters
<span class="line-new-header">--- 33,11 ---</span>
   * contain the Sorter and Merger implementations for that type:
   *
   * Sorter classes based mainly on CilkSort
   * &lt;A href=&quot;http://supertech.lcs.mit.edu/cilk/&quot;&gt; Cilk&lt;/A&gt;:
   * Basic algorithm:
<span class="line-modified">!  * if array size is small, just use a sequential sort (via Arrays.sort)</span>
   *         Otherwise:
   *         1. Break array in half.
   *         2. For each half,
   *             a. break the half in half (i.e., quarters),
   *             b. sort the quarters
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,18 ***</span>
   * requires some little tasks to serve as place holders for triggering
   * completion tasks.  These classes (EmptyCompleter and Relay) don&#39;t
   * need to keep track of the arrays, and are never themselves forked,
   * so don&#39;t hold any task state.
   *
<span class="line-removed">-  * The primitive class versions (FJByte... FJDouble) are</span>
<span class="line-removed">-  * identical to each other except for type declarations.</span>
<span class="line-removed">-  *</span>
   * The base sequential sorts rely on non-public versions of TimSort,
<span class="line-modified">!  * ComparableTimSort, and DualPivotQuicksort sort methods that accept</span>
<span class="line-modified">!  * temp workspace array slices that we will have already allocated, so</span>
<span class="line-modified">!  * avoids redundant allocation. (Except for DualPivotQuicksort byte[]</span>
<span class="line-removed">-  * sort, that does not ever use a workspace array.)</span>
   */
  /*package*/ class ArraysParallelSortHelpers {
  
      /*
       * Style note: The task classes have a lot of parameters, that are
<span class="line-new-header">--- 60,14 ---</span>
   * requires some little tasks to serve as place holders for triggering
   * completion tasks.  These classes (EmptyCompleter and Relay) don&#39;t
   * need to keep track of the arrays, and are never themselves forked,
   * so don&#39;t hold any task state.
   *
   * The base sequential sorts rely on non-public versions of TimSort,
<span class="line-modified">!  * ComparableTimSort sort methods that accept temp workspace array</span>
<span class="line-modified">!  * slices that we will have already allocated, so avoids redundant</span>
<span class="line-modified">!  * allocation.</span>
   */
  /*package*/ class ArraysParallelSortHelpers {
  
      /*
       * Style note: The task classes have a lot of parameters, that are
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,19 ***</span>
<span class="line-new-header">--- 80,21 ---</span>
      /**
       * A placeholder task for Sorters, used for the lowest
       * quartile task, that does not need to maintain array state.
       */
      static final class EmptyCompleter extends CountedCompleter&lt;Void&gt; {
<span class="line-added">+         @java.io.Serial</span>
          static final long serialVersionUID = 2446542900576103244L;
          EmptyCompleter(CountedCompleter&lt;?&gt; p) { super(p); }
          public final void compute() { }
      }
  
      /**
       * A trigger for secondary merge of two merges
       */
      static final class Relay extends CountedCompleter&lt;Void&gt; {
<span class="line-added">+         @java.io.Serial</span>
          static final long serialVersionUID = 2446542900576103244L;
          final CountedCompleter&lt;?&gt; task;
          Relay(CountedCompleter&lt;?&gt; task) {
              super(null, 1);
              this.task = task;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,13 ***</span>
      }
  
      /** Object + Comparator support class */
      static final class FJObject {
          static final class Sorter&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
              static final long serialVersionUID = 2446542900576103244L;
<span class="line-modified">!             final T[] a, w;</span>
              final int base, size, wbase, gran;
              Comparator&lt;? super T&gt; comparator;
              Sorter(CountedCompleter&lt;?&gt; par, T[] a, T[] w, int base, int size,
                     int wbase, int gran,
                     Comparator&lt;? super T&gt; comparator) {
                  super(par);
<span class="line-new-header">--- 106,18 ---</span>
      }
  
      /** Object + Comparator support class */
      static final class FJObject {
          static final class Sorter&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
<span class="line-added">+             @java.io.Serial</span>
              static final long serialVersionUID = 2446542900576103244L;
<span class="line-modified">!             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
<span class="line-added">+             final T[] a;</span>
<span class="line-added">+             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
<span class="line-added">+             final T[] w;</span>
              final int base, size, wbase, gran;
<span class="line-added">+             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
              Comparator&lt;? super T&gt; comparator;
              Sorter(CountedCompleter&lt;?&gt; par, T[] a, T[] w, int base, int size,
                     int wbase, int gran,
                     Comparator&lt;? super T&gt; comparator) {
                  super(par);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
                      Relay fc = new Relay(new Merger&lt;&gt;(s, w, a, wb, h,
                                                        wb+h, n-h, b, g, c));
                      Relay rc = new Relay(new Merger&lt;&gt;(fc, a, w, b+h, q,
                                                        b+u, n-u, wb+h, g, c));
                      new Sorter&lt;&gt;(rc, a, w, b+u, n-u, wb+u, g, c).fork();
<span class="line-modified">!                     new Sorter&lt;&gt;(rc, a, w, b+h, q, wb+h, g, c).fork();;</span>
                      Relay bc = new Relay(new Merger&lt;&gt;(fc, a, w, b, q,
                                                        b+q, h-q, wb, g, c));
                      new Sorter&lt;&gt;(bc, a, w, b+q, h-q, wb+q, g, c).fork();
                      s = new EmptyCompleter(bc);
                      n = q;
<span class="line-new-header">--- 135,11 ---</span>
                      Relay fc = new Relay(new Merger&lt;&gt;(s, w, a, wb, h,
                                                        wb+h, n-h, b, g, c));
                      Relay rc = new Relay(new Merger&lt;&gt;(fc, a, w, b+h, q,
                                                        b+u, n-u, wb+h, g, c));
                      new Sorter&lt;&gt;(rc, a, w, b+u, n-u, wb+u, g, c).fork();
<span class="line-modified">!                     new Sorter&lt;&gt;(rc, a, w, b+h, q, wb+h, g, c).fork();</span>
                      Relay bc = new Relay(new Merger&lt;&gt;(fc, a, w, b, q,
                                                        b+q, h-q, wb, g, c));
                      new Sorter&lt;&gt;(bc, a, w, b+q, h-q, wb+q, g, c).fork();
                      s = new EmptyCompleter(bc);
                      n = q;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,13 ***</span>
                  s.tryComplete();
              }
          }
  
          static final class Merger&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
              static final long serialVersionUID = 2446542900576103244L;
<span class="line-modified">!             final T[] a, w; // main and workspace arrays</span>
              final int lbase, lsize, rbase, rsize, wbase, gran;
              Comparator&lt;? super T&gt; comparator;
              Merger(CountedCompleter&lt;?&gt; par, T[] a, T[] w,
                     int lbase, int lsize, int rbase,
                     int rsize, int wbase, int gran,
                     Comparator&lt;? super T&gt; comparator) {
<span class="line-new-header">--- 148,19 ---</span>
                  s.tryComplete();
              }
          }
  
          static final class Merger&lt;T&gt; extends CountedCompleter&lt;Void&gt; {
<span class="line-added">+             @java.io.Serial</span>
              static final long serialVersionUID = 2446542900576103244L;
<span class="line-modified">!              // main and workspace arrays</span>
<span class="line-added">+             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
<span class="line-added">+             final T[] a;</span>
<span class="line-added">+             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
<span class="line-added">+             final T[] w;</span>
              final int lbase, lsize, rbase, rsize, wbase, gran;
<span class="line-added">+             @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
              Comparator&lt;? super T&gt; comparator;
              Merger(CountedCompleter&lt;?&gt; par, T[] a, T[] w,
                     int lbase, int lsize, int rbase,
                     int rsize, int wbase, int gran,
                     Comparator&lt;? super T&gt; comparator) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,787 ***</span>
                  else if (lb &lt; lf)
                      System.arraycopy(a, lb, w, k, lf - lb);
  
                  tryComplete();
              }
<span class="line-removed">- </span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJObject</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** byte support class */</span>
<span class="line-removed">-     static final class FJByte {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final byte[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, byte[] a, byte[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 byte[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final byte[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, byte[] a, byte[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 byte[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         byte split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         byte split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     byte t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJByte</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** char support class */</span>
<span class="line-removed">-     static final class FJChar {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final char[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, char[] a, char[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 char[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final char[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, char[] a, char[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 char[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         char split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         char split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     char t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJChar</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** short support class */</span>
<span class="line-removed">-     static final class FJShort {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final short[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, short[] a, short[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 short[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final short[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, short[] a, short[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 short[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         short split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         short split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     short t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJShort</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** int support class */</span>
<span class="line-removed">-     static final class FJInt {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final int[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, int[] a, int[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 int[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">! </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final int[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, int[] a, int[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 int[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         int split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         int split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     int t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJInt</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** long support class */</span>
<span class="line-removed">-     static final class FJLong {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final long[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, long[] a, long[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 long[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final long[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, long[] a, long[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 long[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         long split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         long split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     long t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJLong</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** float support class */</span>
<span class="line-removed">-     static final class FJFloat {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final float[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, float[] a, float[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 float[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final float[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, float[] a, float[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 float[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         float split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         float split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     float t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJFloat</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** double support class */</span>
<span class="line-removed">-     static final class FJDouble {</span>
<span class="line-removed">-         static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final double[] a, w;</span>
<span class="line-removed">-             final int base, size, wbase, gran;</span>
<span class="line-removed">-             Sorter(CountedCompleter&lt;?&gt; par, double[] a, double[] w, int base,</span>
<span class="line-removed">-                    int size, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w; this.base = base; this.size = size;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 CountedCompleter&lt;?&gt; s = this;</span>
<span class="line-removed">-                 double[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int b = this.base, n = this.size, wb = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 while (n &gt; g) {</span>
<span class="line-removed">-                     int h = n &gt;&gt;&gt; 1, q = h &gt;&gt;&gt; 1, u = h + q; // quartiles</span>
<span class="line-removed">-                     Relay fc = new Relay(new Merger(s, w, a, wb, h,</span>
<span class="line-removed">-                                                     wb+h, n-h, b, g));</span>
<span class="line-removed">-                     Relay rc = new Relay(new Merger(fc, a, w, b+h, q,</span>
<span class="line-removed">-                                                     b+u, n-u, wb+h, g));</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span>
<span class="line-removed">-                     new Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span>
<span class="line-removed">-                     Relay bc = new Relay(new Merger(fc, a, w, b, q,</span>
<span class="line-removed">-                                                     b+q, h-q, wb, g));</span>
<span class="line-removed">-                     new Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span>
<span class="line-removed">-                     s = new EmptyCompleter(bc);</span>
<span class="line-removed">-                     n = q;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 DualPivotQuicksort.sort(a, b, b + n - 1, w, wb, n);</span>
<span class="line-removed">-                 s.tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-removed">-             static final long serialVersionUID = 2446542900576103244L;</span>
<span class="line-removed">-             final double[] a, w; // main and workspace arrays</span>
<span class="line-removed">-             final int lbase, lsize, rbase, rsize, wbase, gran;</span>
<span class="line-removed">-             Merger(CountedCompleter&lt;?&gt; par, double[] a, double[] w,</span>
<span class="line-removed">-                    int lbase, int lsize, int rbase,</span>
<span class="line-removed">-                    int rsize, int wbase, int gran) {</span>
<span class="line-removed">-                 super(par);</span>
<span class="line-removed">-                 this.a = a; this.w = w;</span>
<span class="line-removed">-                 this.lbase = lbase; this.lsize = lsize;</span>
<span class="line-removed">-                 this.rbase = rbase; this.rsize = rsize;</span>
<span class="line-removed">-                 this.wbase = wbase; this.gran = gran;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             public final void compute() {</span>
<span class="line-removed">-                 double[] a = this.a, w = this.w; // localize all params</span>
<span class="line-removed">-                 int lb = this.lbase, ln = this.lsize, rb = this.rbase,</span>
<span class="line-removed">-                     rn = this.rsize, k = this.wbase, g = this.gran;</span>
<span class="line-removed">-                 if (a == null || w == null || lb &lt; 0 || rb &lt; 0 || k &lt; 0)</span>
<span class="line-removed">-                     throw new IllegalStateException(); // hoist checks</span>
<span class="line-removed">-                 for (int lh, rh;;) {  // split larger, find point in smaller</span>
<span class="line-removed">-                     if (ln &gt;= rn) {</span>
<span class="line-removed">-                         if (ln &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         rh = rn;</span>
<span class="line-removed">-                         double split = a[(lh = ln &gt;&gt;&gt; 1) + lb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; rh; ) {</span>
<span class="line-removed">-                             int rm = (lo + rh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[rm + rb])</span>
<span class="line-removed">-                                 rh = rm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = rm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         if (rn &lt;= g)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         lh = ln;</span>
<span class="line-removed">-                         double split = a[(rh = rn &gt;&gt;&gt; 1) + rb];</span>
<span class="line-removed">-                         for (int lo = 0; lo &lt; lh; ) {</span>
<span class="line-removed">-                             int lm = (lo + lh) &gt;&gt;&gt; 1;</span>
<span class="line-removed">-                             if (split &lt;= a[lm + lb])</span>
<span class="line-removed">-                                 lh = lm;</span>
<span class="line-removed">-                             else</span>
<span class="line-removed">-                                 lo = lm + 1;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     Merger m = new Merger(this, a, w, lb + lh, ln - lh,</span>
<span class="line-removed">-                                           rb + rh, rn - rh,</span>
<span class="line-removed">-                                           k + lh + rh, g);</span>
<span class="line-removed">-                     rn = rh;</span>
<span class="line-removed">-                     ln = lh;</span>
<span class="line-removed">-                     addToPendingCount(1);</span>
<span class="line-removed">-                     m.fork();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 int lf = lb + ln, rf = rb + rn; // index bounds</span>
<span class="line-removed">-                 while (lb &lt; lf &amp;&amp; rb &lt; rf) {</span>
<span class="line-removed">-                     double t, al, ar;</span>
<span class="line-removed">-                     if ((al = a[lb]) &lt;= (ar = a[rb])) {</span>
<span class="line-removed">-                         lb++; t = al;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     else {</span>
<span class="line-removed">-                         rb++; t = ar;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     w[k++] = t;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (rb &lt; rf)</span>
<span class="line-removed">-                     System.arraycopy(a, rb, w, k, rf - rb);</span>
<span class="line-removed">-                 else if (lb &lt; lf)</span>
<span class="line-removed">-                     System.arraycopy(a, lb, w, k, lf - lb);</span>
<span class="line-removed">-                 tryComplete();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } // FJDouble</span>
<span class="line-removed">- </span>
  }
<span class="line-new-header">--- 232,8 ---</span>
                  else if (lb &lt; lf)
                      System.arraycopy(a, lb, w, k, lf - lb);
  
                  tryComplete();
              }
          }
<span class="line-modified">!     }</span>
  }
</pre>
<center><a href="Arrays.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Base64.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/ObjectOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamClass.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,10 ***</span>
<span class="line-new-header">--- 148,14 ---</span>
   * filled up to 1024 bytes, or be written whenever there is a termination of
   * block-data mode.  Calls to the ObjectOutputStream methods writeObject,
   * defaultWriteObject and writeFields initially terminate any existing
   * block-data record.
   *
<span class="line-added">+  * @implSpec</span>
<span class="line-added">+  * Records are serialized differently than ordinary serializable or externalizable</span>
<span class="line-added">+  * objects, see &lt;a href=&quot;ObjectInputStream.html#record-serialization&quot;&gt;record serialization&lt;/a&gt;.</span>
<span class="line-added">+  *</span>
   * @author      Mike Warres
   * @author      Roger Riggs
   * @see java.io.DataOutput
   * @see java.io.ObjectInputStream
   * @see java.io.Serializable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
       *
       * @param   out output stream to write to
       * @throws  IOException if an I/O error occurs while writing stream header
       * @throws  SecurityException if untrusted subclass illegally overrides
       *          security-sensitive methods
<span class="line-modified">!      * @throws  NullPointerException if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
       * @since   1.4
       * @see     ObjectOutputStream#ObjectOutputStream()
       * @see     ObjectOutputStream#putFields()
       * @see     ObjectInputStream#ObjectInputStream(InputStream)
       */
<span class="line-new-header">--- 234,11 ---</span>
       *
       * @param   out output stream to write to
       * @throws  IOException if an I/O error occurs while writing stream header
       * @throws  SecurityException if untrusted subclass illegally overrides
       *          security-sensitive methods
<span class="line-modified">!      * @throws  NullPointerException if {@code out} is {@code null}</span>
       * @since   1.4
       * @see     ObjectOutputStream#ObjectOutputStream()
       * @see     ObjectOutputStream#putFields()
       * @see     ObjectInputStream#ObjectInputStream(InputStream)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,16 ***</span>
       * Provide a way for subclasses that are completely reimplementing
       * ObjectOutputStream to not have to allocate private data just used by
       * this implementation of ObjectOutputStream.
       *
       * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified">!      * security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method with a</span>
<span class="line-modified">!      * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;</span>
       * permission to ensure it&#39;s ok to enable subclassing.
       *
       * @throws  SecurityException if a security manager exists and its
<span class="line-modified">!      *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling</span>
       *          subclassing.
       * @throws  IOException if an I/O error occurs while creating this stream
       * @see SecurityManager#checkPermission
       * @see java.io.SerializablePermission
       */
<span class="line-new-header">--- 261,16 ---</span>
       * Provide a way for subclasses that are completely reimplementing
       * ObjectOutputStream to not have to allocate private data just used by
       * this implementation of ObjectOutputStream.
       *
       * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified">!      * security manager&#39;s {@code checkPermission} method with a</span>
<span class="line-modified">!      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}</span>
       * permission to ensure it&#39;s ok to enable subclassing.
       *
       * @throws  SecurityException if a security manager exists and its
<span class="line-modified">!      *          {@code checkPermission} method denies enabling</span>
       *          subclassing.
       * @throws  IOException if an I/O error occurs while creating this stream
       * @see SecurityManager#checkPermission
       * @see java.io.SerializablePermission
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,12 ***</span>
          }
      }
  
      /**
       * Method used by subclasses to override the default writeObject method.
<span class="line-modified">!      * This method is called by trusted subclasses of ObjectInputStream that</span>
<span class="line-modified">!      * constructed ObjectInputStream using the protected no-arg constructor.</span>
       * The subclass is expected to provide an override method with the modifier
       * &quot;final&quot;.
       *
       * @param   obj object to be written to the underlying stream
       * @throws  IOException if there are I/O errors while writing to the
<span class="line-new-header">--- 359,12 ---</span>
          }
      }
  
      /**
       * Method used by subclasses to override the default writeObject method.
<span class="line-modified">!      * This method is called by trusted subclasses of ObjectOutputStream that</span>
<span class="line-modified">!      * constructed ObjectOutputStream using the protected no-arg constructor.</span>
       * The subclass is expected to provide an override method with the modifier
       * &quot;final&quot;.
       *
       * @param   obj object to be written to the underlying stream
       * @throws  IOException if there are I/O errors while writing to the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,11 ***</span>
       * this stream.  This may only be called from the writeObject method of the
       * class being serialized. It will throw the NotActiveException if it is
       * called otherwise.
       *
       * @throws  IOException if I/O errors occur while writing to the underlying
<span class="line-modified">!      *          &lt;code&gt;OutputStream&lt;/code&gt;</span>
       */
      public void defaultWriteObject() throws IOException {
          SerialCallbackContext ctx = curContext;
          if (ctx == null) {
              throw new NotActiveException(&quot;not in call to writeObject&quot;);
<span class="line-new-header">--- 431,11 ---</span>
       * this stream.  This may only be called from the writeObject method of the
       * class being serialized. It will throw the NotActiveException if it is
       * called otherwise.
       *
       * @throws  IOException if I/O errors occur while writing to the underlying
<span class="line-modified">!      *          {@code OutputStream}</span>
       */
      public void defaultWriteObject() throws IOException {
          SerialCallbackContext ctx = curContext;
          if (ctx == null) {
              throw new NotActiveException(&quot;not in call to writeObject&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,22 ***</span>
       * Subclasses may implement this method to store custom data in the stream
       * along with descriptors for dynamic proxy classes.
       *
       * &lt;p&gt;This method is called exactly once for each unique proxy class
       * descriptor in the stream.  The default implementation of this method in
<span class="line-modified">!      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is</span>
<span class="line-modified">!      * &lt;code&gt;resolveProxyClass&lt;/code&gt;.  For a given subclass of</span>
<span class="line-modified">!      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the</span>
<span class="line-modified">!      * &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of</span>
<span class="line-modified">!      * &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by</span>
<span class="line-modified">!      * &lt;code&gt;annotateProxyClass&lt;/code&gt;.</span>
       *
       * @param   cl the proxy class to annotate custom data for
       * @throws  IOException any exception thrown by the underlying
<span class="line-modified">!      *          &lt;code&gt;OutputStream&lt;/code&gt;</span>
       * @see ObjectInputStream#resolveProxyClass(String[])
       * @since   1.3
       */
      protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
      }
<span class="line-new-header">--- 531,22 ---</span>
       * Subclasses may implement this method to store custom data in the stream
       * along with descriptors for dynamic proxy classes.
       *
       * &lt;p&gt;This method is called exactly once for each unique proxy class
       * descriptor in the stream.  The default implementation of this method in
<span class="line-modified">!      * {@code ObjectOutputStream} does nothing.</span>
       *
<span class="line-modified">!      * &lt;p&gt;The corresponding method in {@code ObjectInputStream} is</span>
<span class="line-modified">!      * {@code resolveProxyClass}.  For a given subclass of</span>
<span class="line-modified">!      * {@code ObjectOutputStream} that overrides this method, the</span>
<span class="line-modified">!      * {@code resolveProxyClass} method in the corresponding subclass of</span>
<span class="line-modified">!      * {@code ObjectInputStream} must read any data or objects written by</span>
<span class="line-modified">!      * {@code annotateProxyClass}.</span>
       *
       * @param   cl the proxy class to annotate custom data for
       * @throws  IOException any exception thrown by the underlying
<span class="line-modified">!      *          {@code OutputStream}</span>
       * @see ObjectInputStream#resolveProxyClass(String[])
       * @since   1.3
       */
      protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,20 ***</span>
       * Write the specified class descriptor to the ObjectOutputStream.  Class
       * descriptors are used to identify the classes of objects written to the
       * stream.  Subclasses of ObjectOutputStream may override this method to
       * customize the way in which class descriptors are written to the
       * serialization stream.  The corresponding method in ObjectInputStream,
<span class="line-modified">!      * &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to</span>
       * reconstitute the class descriptor from its custom stream representation.
       * By default, this method writes class descriptors according to the format
       * defined in the Object Serialization specification.
       *
       * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
       * is not using the old serialization stream format (set by calling
<span class="line-modified">!      * ObjectOutputStream&#39;s &lt;code&gt;useProtocolVersion&lt;/code&gt; method).  If this</span>
       * serialization stream is using the old format
<span class="line-modified">!      * (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written</span>
       * internally in a manner that cannot be overridden or customized.
       *
       * @param   desc class descriptor to write to the stream
       * @throws  IOException If an I/O error has occurred.
       * @see java.io.ObjectInputStream#readClassDescriptor()
<span class="line-new-header">--- 648,20 ---</span>
       * Write the specified class descriptor to the ObjectOutputStream.  Class
       * descriptors are used to identify the classes of objects written to the
       * stream.  Subclasses of ObjectOutputStream may override this method to
       * customize the way in which class descriptors are written to the
       * serialization stream.  The corresponding method in ObjectInputStream,
<span class="line-modified">!      * {@code readClassDescriptor}, should then be overridden to</span>
       * reconstitute the class descriptor from its custom stream representation.
       * By default, this method writes class descriptors according to the format
       * defined in the Object Serialization specification.
       *
       * &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
       * is not using the old serialization stream format (set by calling
<span class="line-modified">!      * ObjectOutputStream&#39;s {@code useProtocolVersion} method).  If this</span>
       * serialization stream is using the old format
<span class="line-modified">!      * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written</span>
       * internally in a manner that cannot be overridden or customized.
       *
       * @param   desc class descriptor to write to the stream
       * @throws  IOException If an I/O error has occurred.
       * @see java.io.ObjectInputStream#readClassDescriptor()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,135 ***</span>
       * to ObjectOutput.
       *
       * @since 1.2
       */
      public abstract static class PutField {
  
          /**
           * Put the value of the named boolean field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;boolean&lt;/code&gt;</span>
           */
          public abstract void put(String name, boolean val);
  
          /**
           * Put the value of the named byte field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;byte&lt;/code&gt;</span>
           */
          public abstract void put(String name, byte val);
  
          /**
           * Put the value of the named char field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;char&lt;/code&gt;</span>
           */
          public abstract void put(String name, char val);
  
          /**
           * Put the value of the named short field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;short&lt;/code&gt;</span>
           */
          public abstract void put(String name, short val);
  
          /**
           * Put the value of the named int field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;int&lt;/code&gt;</span>
           */
          public abstract void put(String name, int val);
  
          /**
           * Put the value of the named long field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;long&lt;/code&gt;</span>
           */
          public abstract void put(String name, long val);
  
          /**
           * Put the value of the named float field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;float&lt;/code&gt;</span>
           */
          public abstract void put(String name, float val);
  
          /**
           * Put the value of the named double field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * &lt;code&gt;double&lt;/code&gt;</span>
           */
          public abstract void put(String name, double val);
  
          /**
           * Put the value of the named Object field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          *         (which may be &lt;code&gt;null&lt;/code&gt;)</span>
<span class="line-modified">!          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not a
           * reference type
           */
          public abstract void put(String name, Object val);
  
          /**
           * Write the data and fields to the specified ObjectOutput stream,
           * which must be the same stream that produced this
<span class="line-modified">!          * &lt;code&gt;PutField&lt;/code&gt; object.</span>
           *
           * @param  out the stream to write the data and fields to
           * @throws IOException if I/O errors occur while writing to the
           *         underlying stream
           * @throws IllegalArgumentException if the specified stream is not
<span class="line-modified">!          *         the same stream that produced this &lt;code&gt;PutField&lt;/code&gt;</span>
           *         object
           * @deprecated This method does not write the values contained by this
<span class="line-modified">!          *         &lt;code&gt;PutField&lt;/code&gt; object in a proper format, and may</span>
           *         result in corruption of the serialization stream.  The
<span class="line-modified">!          *         correct way to write &lt;code&gt;PutField&lt;/code&gt; data is by</span>
           *         calling the {@link java.io.ObjectOutputStream#writeFields()}
           *         method.
           */
          @Deprecated
          public abstract void write(ObjectOutput out) throws IOException;
<span class="line-new-header">--- 881,139 ---</span>
       * to ObjectOutput.
       *
       * @since 1.2
       */
      public abstract static class PutField {
<span class="line-added">+         /**</span>
<span class="line-added">+          * Constructor for subclasses to call.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public PutField() {}</span>
  
          /**
           * Put the value of the named boolean field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code boolean}</span>
           */
          public abstract void put(String name, boolean val);
  
          /**
           * Put the value of the named byte field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code byte}</span>
           */
          public abstract void put(String name, byte val);
  
          /**
           * Put the value of the named char field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code char}</span>
           */
          public abstract void put(String name, char val);
  
          /**
           * Put the value of the named short field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code short}</span>
           */
          public abstract void put(String name, short val);
  
          /**
           * Put the value of the named int field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code int}</span>
           */
          public abstract void put(String name, int val);
  
          /**
           * Put the value of the named long field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code long}</span>
           */
          public abstract void put(String name, long val);
  
          /**
           * Put the value of the named float field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code float}</span>
           */
          public abstract void put(String name, float val);
  
          /**
           * Put the value of the named double field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not
<span class="line-modified">!          * {@code double}</span>
           */
          public abstract void put(String name, double val);
  
          /**
           * Put the value of the named Object field into the persistent field.
           *
           * @param  name the name of the serializable field
           * @param  val the value to assign to the field
<span class="line-modified">!          *         (which may be {@code null})</span>
<span class="line-modified">!          * @throws IllegalArgumentException if {@code name} does not</span>
           * match the name of a serializable field for the class whose fields
           * are being written, or if the type of the named field is not a
           * reference type
           */
          public abstract void put(String name, Object val);
  
          /**
           * Write the data and fields to the specified ObjectOutput stream,
           * which must be the same stream that produced this
<span class="line-modified">!          * {@code PutField} object.</span>
           *
           * @param  out the stream to write the data and fields to
           * @throws IOException if I/O errors occur while writing to the
           *         underlying stream
           * @throws IllegalArgumentException if the specified stream is not
<span class="line-modified">!          *         the same stream that produced this {@code PutField}</span>
           *         object
           * @deprecated This method does not write the values contained by this
<span class="line-modified">!          *         {@code PutField} object in a proper format, and may</span>
           *         result in corruption of the serialization stream.  The
<span class="line-modified">!          *         correct way to write {@code PutField} data is by</span>
           *         calling the {@link java.io.ObjectOutputStream#writeFields()}
           *         method.
           */
          @Deprecated
          public abstract void write(ObjectOutput out) throws IOException;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1425,11 ***</span>
              desc.checkSerialize();
  
              bout.writeByte(TC_OBJECT);
              writeClassDesc(desc, false);
              handles.assign(unshared ? null : obj);
<span class="line-modified">!             if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>
                  writeExternalData((Externalizable) obj);
              } else {
                  writeSerialData(obj, desc);
              }
          } finally {
<span class="line-new-header">--- 1433,14 ---</span>
              desc.checkSerialize();
  
              bout.writeByte(TC_OBJECT);
              writeClassDesc(desc, false);
              handles.assign(unshared ? null : obj);
<span class="line-modified">! </span>
<span class="line-added">+             if (desc.isRecord()) {</span>
<span class="line-added">+                 writeRecordData(obj, desc);</span>
<span class="line-added">+             } else if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {</span>
                  writeExternalData((Externalizable) obj);
              } else {
                  writeSerialData(obj, desc);
              }
          } finally {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1469,10 ***</span>
<span class="line-new-header">--- 1480,25 ---</span>
          }
  
          curPut = oldPut;
      }
  
<span class="line-added">+     /** Writes the record component values for the given record object. */</span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private void writeRecordData(Object obj, ObjectStreamClass desc)</span>
<span class="line-added">+         throws IOException</span>
<span class="line-added">+     {</span>
<span class="line-added">+         assert obj.getClass().isRecord();</span>
<span class="line-added">+         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="line-added">+         if (slots.length != 1) {</span>
<span class="line-added">+             throw new InvalidClassException(</span>
<span class="line-added">+                     &quot;expected a single record slot length, but found: &quot; + slots.length);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Writes instance data for each serializable class of given object, from
       * superclass to subclass.
       */
      private void writeSerialData(Object obj, ObjectStreamClass desc)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1585,26 ***</span>
          } finally {
              bout.setBlockDataMode(oldMode);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Converts specified span of float values into byte values.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     // REMIND: remove once hotspot inlines Float.floatToIntBits</span>
<span class="line-removed">-     private static native void floatsToBytes(float[] src, int srcpos,</span>
<span class="line-removed">-                                              byte[] dst, int dstpos,</span>
<span class="line-removed">-                                              int nfloats);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Converts specified span of double values into byte values.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     // REMIND: remove once hotspot inlines Double.doubleToLongBits</span>
<span class="line-removed">-     private static native void doublesToBytes(double[] src, int srcpos,</span>
<span class="line-removed">-                                               byte[] dst, int dstpos,</span>
<span class="line-removed">-                                               int ndoubles);</span>
<span class="line-removed">- </span>
      /**
       * Default PutField implementation.
       */
      private class PutFieldImpl extends PutField {
  
<span class="line-new-header">--- 1611,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2090,14 ***</span>
              int limit = MAX_BLOCK_SIZE - 4;
              int endoff = off + len;
              while (off &lt; endoff) {
                  if (pos &lt;= limit) {
                      int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
<span class="line-modified">!                     int chunklen = Math.min(endoff - off, avail);</span>
<span class="line-modified">!                     floatsToBytes(v, off, buf, pos, chunklen);</span>
<span class="line-modified">!                     off += chunklen;</span>
<span class="line-modified">!                     pos += chunklen &lt;&lt; 2;</span>
                  } else {
                      dout.writeFloat(v[off++]);
                  }
              }
          }
<span class="line-new-header">--- 2100,15 ---</span>
              int limit = MAX_BLOCK_SIZE - 4;
              int endoff = off + len;
              while (off &lt; endoff) {
                  if (pos &lt;= limit) {
                      int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 2;
<span class="line-modified">!                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">!                     while (off &lt; stop) {</span>
<span class="line-modified">!                         Bits.putFloat(buf, pos, v[off++]);</span>
<span class="line-modified">!                         pos += 4;</span>
<span class="line-added">+                     }</span>
                  } else {
                      dout.writeFloat(v[off++]);
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2123,14 ***</span>
              int limit = MAX_BLOCK_SIZE - 8;
              int endoff = off + len;
              while (off &lt; endoff) {
                  if (pos &lt;= limit) {
                      int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
<span class="line-modified">!                     int chunklen = Math.min(endoff - off, avail);</span>
<span class="line-modified">!                     doublesToBytes(v, off, buf, pos, chunklen);</span>
<span class="line-modified">!                     off += chunklen;</span>
<span class="line-modified">!                     pos += chunklen &lt;&lt; 3;</span>
                  } else {
                      dout.writeDouble(v[off++]);
                  }
              }
          }
<span class="line-new-header">--- 2134,15 ---</span>
              int limit = MAX_BLOCK_SIZE - 8;
              int endoff = off + len;
              while (off &lt; endoff) {
                  if (pos &lt;= limit) {
                      int avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; 3;
<span class="line-modified">!                     int stop = Math.min(endoff, off + avail);</span>
<span class="line-modified">!                     while (off &lt; stop) {</span>
<span class="line-modified">!                         Bits.putDouble(buf, pos, v[off++]);</span>
<span class="line-modified">!                         pos += 8;</span>
<span class="line-added">+                     }</span>
                  } else {
                      dout.writeDouble(v[off++]);
                  }
              }
          }
</pre>
<center><a href="ObjectOutput.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamClass.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
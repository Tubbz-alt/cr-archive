<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/nio/file/Files.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileSystems.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvalidPathException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/file/Files.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 75,11 ***</span>
<span class="line-new-header">--- 75,13 ---</span>
  import java.util.Spliterators;
  import java.util.function.BiPredicate;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  
<span class="line-added">+ import jdk.internal.util.ArraysSupport;</span>
  import sun.nio.ch.FileChannelImpl;
<span class="line-added">+ import sun.nio.cs.UTF_8;</span>
  import sun.nio.fs.AbstractFileSystemProvider;
  
  /**
   * This class consists exclusively of static methods that operate on files,
   * directories, or other types of files.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2941,11 ***</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static BufferedReader newBufferedReader(Path path) throws IOException {
<span class="line-modified">!         return newBufferedReader(path, StandardCharsets.UTF_8);</span>
      }
  
      /**
       * Opens or creates a file for writing, returning a {@code BufferedWriter}
       * that may be used to write text to the file in an efficient manner.
<span class="line-new-header">--- 2943,11 ---</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static BufferedReader newBufferedReader(Path path) throws IOException {
<span class="line-modified">!         return newBufferedReader(path, UTF_8.INSTANCE);</span>
      }
  
      /**
       * Opens or creates a file for writing, returning a {@code BufferedWriter}
       * that may be used to write text to the file in an efficient manner.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3033,11 ***</span>
       * @since 1.8
       */
      public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
          throws IOException
      {
<span class="line-modified">!         return newBufferedWriter(path, StandardCharsets.UTF_8, options);</span>
      }
  
      /**
       * Copies all bytes from an input stream to a file. On return, the input
       * stream will be at end of stream.
<span class="line-new-header">--- 3035,11 ---</span>
       * @since 1.8
       */
      public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)
          throws IOException
      {
<span class="line-modified">!         return newBufferedWriter(path, UTF_8.INSTANCE, options);</span>
      }
  
      /**
       * Copies all bytes from an input stream to a file. On return, the input
       * stream will be at end of stream.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3194,18 ***</span>
          try (InputStream in = newInputStream(source)) {
              return in.transferTo(out);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The maximum size of array to allocate.</span>
<span class="line-removed">-      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">-      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">-      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">- </span>
      private static final jdk.internal.access.JavaLangAccess JLA =
              jdk.internal.access.SharedSecrets.getJavaLangAccess();
  
      /**
       * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
<span class="line-new-header">--- 3196,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3238,17 ***</span>
              // otherwise, try to read one more byte; if that failed we&#39;re done too
              if (n &lt; 0 || (n = source.read()) &lt; 0)
                  break;
  
              // one more byte was read; need to allocate a larger buffer
<span class="line-modified">!             if (capacity &lt;= MAX_BUFFER_SIZE - capacity) {</span>
<span class="line-modified">!                 capacity = Math.max(capacity &lt;&lt; 1, BUFFER_SIZE);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (capacity == MAX_BUFFER_SIZE)</span>
<span class="line-removed">-                     throw new OutOfMemoryError(&quot;Required array size too large&quot;);</span>
<span class="line-removed">-                 capacity = MAX_BUFFER_SIZE;</span>
<span class="line-removed">-             }</span>
              buf = Arrays.copyOf(buf, capacity);
              buf[nread++] = (byte)n;
          }
          return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
      }
<span class="line-new-header">--- 3232,14 ---</span>
              // otherwise, try to read one more byte; if that failed we&#39;re done too
              if (n &lt; 0 || (n = source.read()) &lt; 0)
                  break;
  
              // one more byte was read; need to allocate a larger buffer
<span class="line-modified">!             capacity = Math.max(ArraysSupport.newLength(capacity,</span>
<span class="line-modified">!                                                         1,       /* minimum growth */</span>
<span class="line-modified">!                                                         capacity /* preferred growth */),</span>
<span class="line-modified">!                                 BUFFER_SIZE);</span>
              buf = Arrays.copyOf(buf, capacity);
              buf[nread++] = (byte)n;
          }
          return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3281,11 ***</span>
          try (SeekableByteChannel sbc = Files.newByteChannel(path);
               InputStream in = Channels.newInputStream(sbc)) {
              if (sbc instanceof FileChannelImpl)
                  ((FileChannelImpl) sbc).setUninterruptible();
              long size = sbc.size();
<span class="line-modified">!             if (size &gt; (long) MAX_BUFFER_SIZE)</span>
                  throw new OutOfMemoryError(&quot;Required array size too large&quot;);
              return read(in, (int)size);
          }
      }
  
<span class="line-new-header">--- 3272,11 ---</span>
          try (SeekableByteChannel sbc = Files.newByteChannel(path);
               InputStream in = Channels.newInputStream(sbc)) {
              if (sbc instanceof FileChannelImpl)
                  ((FileChannelImpl) sbc).setUninterruptible();
              long size = sbc.size();
<span class="line-modified">!             if (size &gt; (long) Integer.MAX_VALUE)</span>
                  throw new OutOfMemoryError(&quot;Required array size too large&quot;);
              return read(in, (int)size);
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3313,11 ***</span>
       *          method is invoked to check read access to the file.
       *
       * @since 11
       */
      public static String readString(Path path) throws IOException {
<span class="line-modified">!         return readString(path, StandardCharsets.UTF_8);</span>
      }
  
      /**
       * Reads all characters from a file into a string, decoding from bytes to characters
       * using the specified {@linkplain Charset charset}.
<span class="line-new-header">--- 3304,11 ---</span>
       *          method is invoked to check read access to the file.
       *
       * @since 11
       */
      public static String readString(Path path) throws IOException {
<span class="line-modified">!         return readString(path, UTF_8.INSTANCE);</span>
      }
  
      /**
       * Reads all characters from a file into a string, decoding from bytes to characters
       * using the specified {@linkplain Charset charset}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3355,10 ***</span>
<span class="line-new-header">--- 3346,12 ---</span>
      public static String readString(Path path, Charset cs) throws IOException {
          Objects.requireNonNull(path);
          Objects.requireNonNull(cs);
  
          byte[] ba = readAllBytes(path);
<span class="line-added">+         if (path.getClass().getModule() != Object.class.getModule())</span>
<span class="line-added">+             ba = ba.clone();</span>
          return JLA.newStringNoRepl(ba, cs);
      }
  
      /**
       * Read all lines from a file. This method ensures that the file is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3438,11 ***</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static List&lt;String&gt; readAllLines(Path path) throws IOException {
<span class="line-modified">!         return readAllLines(path, StandardCharsets.UTF_8);</span>
      }
  
      /**
       * Writes bytes to a file. The {@code options} parameter specifies how
       * the file is created or opened. If no options are present then this method
<span class="line-new-header">--- 3431,11 ---</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static List&lt;String&gt; readAllLines(Path path) throws IOException {
<span class="line-modified">!         return readAllLines(path, UTF_8.INSTANCE);</span>
      }
  
      /**
       * Writes bytes to a file. The {@code options} parameter specifies how
       * the file is created or opened. If no options are present then this method
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3558,12 ***</span>
          throws IOException
      {
          // ensure lines is not null before opening file
          Objects.requireNonNull(lines);
          CharsetEncoder encoder = cs.newEncoder();
<span class="line-modified">!         OutputStream out = newOutputStream(path, options);</span>
<span class="line-modified">!         try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {</span>
              for (CharSequence line: lines) {
                  writer.append(line);
                  writer.newLine();
              }
          }
<span class="line-new-header">--- 3551,12 ---</span>
          throws IOException
      {
          // ensure lines is not null before opening file
          Objects.requireNonNull(lines);
          CharsetEncoder encoder = cs.newEncoder();
<span class="line-modified">!         try (OutputStream out = newOutputStream(path, options);</span>
<span class="line-modified">!              BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {</span>
              for (CharSequence line: lines) {
                  writer.append(line);
                  writer.newLine();
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3609,11 ***</span>
      public static Path write(Path path,
                               Iterable&lt;? extends CharSequence&gt; lines,
                               OpenOption... options)
          throws IOException
      {
<span class="line-modified">!         return write(path, lines, StandardCharsets.UTF_8, options);</span>
      }
  
      /**
       * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
       * Characters are encoded into bytes using the
<span class="line-new-header">--- 3602,11 ---</span>
      public static Path write(Path path,
                               Iterable&lt;? extends CharSequence&gt; lines,
                               OpenOption... options)
          throws IOException
      {
<span class="line-modified">!         return write(path, lines, UTF_8.INSTANCE, options);</span>
      }
  
      /**
       * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
       * Characters are encoded into bytes using the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3649,11 ***</span>
       * @since 11
       */
      public static Path writeString(Path path, CharSequence csq, OpenOption... options)
              throws IOException
      {
<span class="line-modified">!         return writeString(path, csq, StandardCharsets.UTF_8, options);</span>
      }
  
      /**
       * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
       * Characters are encoded into bytes using the specified
<span class="line-new-header">--- 3642,11 ---</span>
       * @since 11
       */
      public static Path writeString(Path path, CharSequence csq, OpenOption... options)
              throws IOException
      {
<span class="line-modified">!         return writeString(path, csq, UTF_8.INSTANCE, options);</span>
      }
  
      /**
       * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.
       * Characters are encoded into bytes using the specified
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4196,8 ***</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static Stream&lt;String&gt; lines(Path path) throws IOException {
<span class="line-modified">!         return lines(path, StandardCharsets.UTF_8);</span>
      }
  }
<span class="line-new-header">--- 4189,8 ---</span>
       *          method is invoked to check read access to the file.
       *
       * @since 1.8
       */
      public static Stream&lt;String&gt; lines(Path path) throws IOException {
<span class="line-modified">!         return lines(path, UTF_8.INSTANCE);</span>
      }
  }
</pre>
<center><a href="FileSystems.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvalidPathException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/Properties.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PriorityQueue.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyPermission.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Properties.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,12 ***</span>
<span class="line-new-header">--- 44,16 ---</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.function.BiConsumer;
  import java.util.function.BiFunction;
  import java.util.function.Function;
  
<span class="line-added">+ import sun.nio.cs.ISO_8859_1;</span>
<span class="line-added">+ import sun.nio.cs.UTF_8;</span>
<span class="line-added">+ </span>
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.misc.Unsafe;
<span class="line-added">+ import jdk.internal.util.ArraysSupport;</span>
  import jdk.internal.util.xml.PropertiesDefaultHandler;
  
  /**
   * The {@code Properties} class represents a persistent set of
   * properties. The {@code Properties} can be saved to a stream
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,15 ***</span>
   * @author  Arthur van Hoff
   * @author  Michael McCloskey
   * @author  Xueming Shen
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class Properties extends Hashtable&lt;Object,Object&gt; {</span>
      /**
       * use serialVersionUID from JDK 1.1.X for interoperability
       */
      private static final long serialVersionUID = 4112578634029874840L;
  
      private static final Unsafe UNSAFE = Unsafe.getUnsafe();
  
      /**
<span class="line-new-header">--- 138,15 ---</span>
   * @author  Arthur van Hoff
   * @author  Michael McCloskey
   * @author  Xueming Shen
   * @since   1.0
   */
<span class="line-modified">! public class Properties extends Hashtable&lt;Object,Object&gt; {</span>
      /**
       * use serialVersionUID from JDK 1.1.X for interoperability
       */
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 4112578634029874840L;
  
      private static final Unsafe UNSAFE = Unsafe.getUnsafe();
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,11 ***</span>
       * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
       * &lt;p&gt;
       * The specified stream remains open after this method returns.
       *
       * @param      inStream   the input stream.
<span class="line-modified">!      * @exception  IOException  if an error occurred when reading from the</span>
       *             input stream.
       * @throws     IllegalArgumentException if the input stream contains a
       *             malformed Unicode escape sequence.
       * @throws     NullPointerException if {@code inStream} is null.
       * @since 1.2
<span class="line-new-header">--- 394,11 ---</span>
       * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
       * &lt;p&gt;
       * The specified stream remains open after this method returns.
       *
       * @param      inStream   the input stream.
<span class="line-modified">!      * @throws     IOException  if an error occurred when reading from the</span>
       *             input stream.
       * @throws     IllegalArgumentException if the input stream contains a
       *             malformed Unicode escape sequence.
       * @throws     NullPointerException if {@code inStream} is null.
       * @since 1.2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,29 ***</span>
      public synchronized void load(InputStream inStream) throws IOException {
          Objects.requireNonNull(inStream, &quot;inStream parameter is null&quot;);
          load0(new LineReader(inStream));
      }
  
<span class="line-modified">!     private void load0 (LineReader lr) throws IOException {</span>
<span class="line-modified">!         char[] convtBuf = new char[1024];</span>
          int limit;
          int keyLen;
          int valueStart;
<span class="line-removed">-         char c;</span>
          boolean hasSep;
          boolean precedingBackslash;
  
          while ((limit = lr.readLine()) &gt;= 0) {
<span class="line-removed">-             c = 0;</span>
              keyLen = 0;
              valueStart = limit;
              hasSep = false;
  
              //System.out.println(&quot;line=&lt;&quot; + new String(lineBuf, 0, limit) + &quot;&gt;&quot;);
              precedingBackslash = false;
              while (keyLen &lt; limit) {
<span class="line-modified">!                 c = lr.lineBuf[keyLen];</span>
                  //need check if escaped.
                  if ((c == &#39;=&#39; ||  c == &#39;:&#39;) &amp;&amp; !precedingBackslash) {
                      valueStart = keyLen + 1;
                      hasSep = true;
                      break;
<span class="line-new-header">--- 406,27 ---</span>
      public synchronized void load(InputStream inStream) throws IOException {
          Objects.requireNonNull(inStream, &quot;inStream parameter is null&quot;);
          load0(new LineReader(inStream));
      }
  
<span class="line-modified">!     private void load0(LineReader lr) throws IOException {</span>
<span class="line-modified">!         StringBuilder outBuffer = new StringBuilder();</span>
          int limit;
          int keyLen;
          int valueStart;
          boolean hasSep;
          boolean precedingBackslash;
  
          while ((limit = lr.readLine()) &gt;= 0) {
              keyLen = 0;
              valueStart = limit;
              hasSep = false;
  
              //System.out.println(&quot;line=&lt;&quot; + new String(lineBuf, 0, limit) + &quot;&gt;&quot;);
              precedingBackslash = false;
              while (keyLen &lt; limit) {
<span class="line-modified">!                 char c = lr.lineBuf[keyLen];</span>
                  //need check if escaped.
                  if ((c == &#39;=&#39; ||  c == &#39;:&#39;) &amp;&amp; !precedingBackslash) {
                      valueStart = keyLen + 1;
                      hasSep = true;
                      break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,174 ***</span>
                      precedingBackslash = false;
                  }
                  keyLen++;
              }
              while (valueStart &lt; limit) {
<span class="line-modified">!                 c = lr.lineBuf[valueStart];</span>
                  if (c != &#39; &#39; &amp;&amp; c != &#39;\t&#39; &amp;&amp;  c != &#39;\f&#39;) {
                      if (!hasSep &amp;&amp; (c == &#39;=&#39; ||  c == &#39;:&#39;)) {
                          hasSep = true;
                      } else {
                          break;
                      }
                  }
                  valueStart++;
              }
<span class="line-modified">!             String key = loadConvert(lr.lineBuf, 0, keyLen, convtBuf);</span>
<span class="line-modified">!             String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);</span>
              put(key, value);
          }
      }
  
      /* Read in a &quot;logical line&quot; from an InputStream/Reader, skip all comment
       * and blank lines and filter out those leading whitespace characters
       * (\u0020, \u0009 and \u000c) from the beginning of a &quot;natural line&quot;.
       * Method returns the char length of the &quot;logical line&quot; and stores
       * the line in &quot;lineBuf&quot;.
       */
<span class="line-modified">!     class LineReader {</span>
<span class="line-modified">!         public LineReader(InputStream inStream) {</span>
              this.inStream = inStream;
              inByteBuf = new byte[8192];
          }
  
<span class="line-modified">!         public LineReader(Reader reader) {</span>
              this.reader = reader;
              inCharBuf = new char[8192];
          }
  
<span class="line-removed">-         byte[] inByteBuf;</span>
<span class="line-removed">-         char[] inCharBuf;</span>
          char[] lineBuf = new char[1024];
<span class="line-modified">!         int inLimit = 0;</span>
<span class="line-modified">!         int inOff = 0;</span>
<span class="line-modified">!         InputStream inStream;</span>
<span class="line-modified">!         Reader reader;</span>
  
          int readLine() throws IOException {
              int len = 0;
<span class="line-modified">!             char c = 0;</span>
  
              boolean skipWhiteSpace = true;
<span class="line-removed">-             boolean isCommentLine = false;</span>
<span class="line-removed">-             boolean isNewLine = true;</span>
              boolean appendedLineBegin = false;
              boolean precedingBackslash = false;
<span class="line-modified">!             boolean skipLF = false;</span>
  
              while (true) {
<span class="line-modified">!                 if (inOff &gt;= inLimit) {</span>
<span class="line-modified">!                     inLimit = (inStream==null)?reader.read(inCharBuf)</span>
<span class="line-modified">!                                               :inStream.read(inByteBuf);</span>
<span class="line-modified">!                     inOff = 0;</span>
<span class="line-modified">!                     if (inLimit &lt;= 0) {</span>
<span class="line-removed">-                         if (len == 0 || isCommentLine) {</span>
                              return -1;
                          }
<span class="line-modified">!                         if (precedingBackslash) {</span>
<span class="line-removed">-                             len--;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         return len;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (inStream != null) {</span>
<span class="line-removed">-                     //The line below is equivalent to calling a</span>
<span class="line-removed">-                     //ISO8859-1 decoder.</span>
<span class="line-removed">-                     c = (char)(inByteBuf[inOff++] &amp; 0xFF);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     c = inCharBuf[inOff++];</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (skipLF) {</span>
<span class="line-removed">-                     skipLF = false;</span>
<span class="line-removed">-                     if (c == &#39;\n&#39;) {</span>
<span class="line-removed">-                         continue;</span>
                      }
                  }
                  if (skipWhiteSpace) {
                      if (c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\f&#39;) {
                          continue;
                      }
                      if (!appendedLineBegin &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;)) {
                          continue;
                      }
                      skipWhiteSpace = false;
                      appendedLineBegin = false;
                  }
<span class="line-modified">!                 if (isNewLine) {</span>
<span class="line-removed">-                     isNewLine = false;</span>
                      if (c == &#39;#&#39; || c == &#39;!&#39;) {
<span class="line-modified">!                         // Comment, quickly consume the rest of the line,</span>
<span class="line-modified">!                         // resume on line-break and backslash.</span>
<span class="line-modified">!                         if (inStream != null) {</span>
<span class="line-modified">!                             while (inOff &lt; inLimit) {</span>
<span class="line-modified">!                                 byte b = inByteBuf[inOff++];</span>
<span class="line-modified">!                                 if (b == &#39;\n&#39; || b == &#39;\r&#39; || b == &#39;\\&#39;) {</span>
<span class="line-modified">!                                     c = (char)(b &amp; 0xFF);</span>
<span class="line-modified">!                                     break;</span>
                                  }
<span class="line-modified">!                             }</span>
<span class="line-modified">!                         } else {</span>
<span class="line-modified">!                             while (inOff &lt; inLimit) {</span>
<span class="line-modified">!                                 c = inCharBuf[inOff++];</span>
<span class="line-modified">!                                 if (c == &#39;\n&#39; || c == &#39;\r&#39; || c == &#39;\\&#39;) {</span>
<span class="line-modified">!                                     break;</span>
                                  }
                              }
                          }
<span class="line-modified">!                         isCommentLine = true;</span>
                      }
                  }
  
                  if (c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
                      lineBuf[len++] = c;
                      if (len == lineBuf.length) {
<span class="line-modified">!                         int newLength = lineBuf.length * 2;</span>
<span class="line-modified">!                         if (newLength &lt; 0) {</span>
<span class="line-modified">!                             newLength = Integer.MAX_VALUE;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         char[] buf = new char[newLength];</span>
<span class="line-removed">-                         System.arraycopy(lineBuf, 0, buf, 0, lineBuf.length);</span>
<span class="line-removed">-                         lineBuf = buf;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     //flip the preceding backslash flag</span>
<span class="line-removed">-                     if (c == &#39;\\&#39;) {</span>
<span class="line-removed">-                         precedingBackslash = !precedingBackslash;</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         precedingBackslash = false;</span>
                      }
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 else {</span>
                      // reached EOL
<span class="line-modified">!                     if (isCommentLine || len == 0) {</span>
<span class="line-removed">-                         isCommentLine = false;</span>
<span class="line-removed">-                         isNewLine = true;</span>
                          skipWhiteSpace = true;
<span class="line-removed">-                         len = 0;</span>
                          continue;
                      }
<span class="line-modified">!                     if (inOff &gt;= inLimit) {</span>
<span class="line-modified">!                         inLimit = (inStream==null)</span>
<span class="line-modified">!                                   ?reader.read(inCharBuf)</span>
<span class="line-modified">!                                   :inStream.read(inByteBuf);</span>
<span class="line-modified">!                         inOff = 0;</span>
<span class="line-modified">!                         if (inLimit &lt;= 0) {</span>
<span class="line-removed">-                             if (precedingBackslash) {</span>
<span class="line-removed">-                                 len--;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             return len;</span>
                          }
                      }
                      if (precedingBackslash) {
                          len -= 1;
<span class="line-modified">!                         //skip the leading whitespace characters in following line</span>
                          skipWhiteSpace = true;
                          appendedLineBegin = true;
                          precedingBackslash = false;
                          if (c == &#39;\r&#39;) {
<span class="line-modified">!                             skipLF = true;</span>
                          }
                      } else {
                          return len;
                      }
                  }
              }
          }
<span class="line-new-header">--- 440,179 ---</span>
                      precedingBackslash = false;
                  }
                  keyLen++;
              }
              while (valueStart &lt; limit) {
<span class="line-modified">!                 char c = lr.lineBuf[valueStart];</span>
                  if (c != &#39; &#39; &amp;&amp; c != &#39;\t&#39; &amp;&amp;  c != &#39;\f&#39;) {
                      if (!hasSep &amp;&amp; (c == &#39;=&#39; ||  c == &#39;:&#39;)) {
                          hasSep = true;
                      } else {
                          break;
                      }
                  }
                  valueStart++;
              }
<span class="line-modified">!             String key = loadConvert(lr.lineBuf, 0, keyLen, outBuffer);</span>
<span class="line-modified">!             String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);</span>
              put(key, value);
          }
      }
  
      /* Read in a &quot;logical line&quot; from an InputStream/Reader, skip all comment
       * and blank lines and filter out those leading whitespace characters
       * (\u0020, \u0009 and \u000c) from the beginning of a &quot;natural line&quot;.
       * Method returns the char length of the &quot;logical line&quot; and stores
       * the line in &quot;lineBuf&quot;.
       */
<span class="line-modified">!     private static class LineReader {</span>
<span class="line-modified">!         LineReader(InputStream inStream) {</span>
              this.inStream = inStream;
              inByteBuf = new byte[8192];
          }
  
<span class="line-modified">!         LineReader(Reader reader) {</span>
              this.reader = reader;
              inCharBuf = new char[8192];
          }
  
          char[] lineBuf = new char[1024];
<span class="line-modified">!         private byte[] inByteBuf;</span>
<span class="line-modified">!         private char[] inCharBuf;</span>
<span class="line-modified">!         private int inLimit = 0;</span>
<span class="line-modified">!         private int inOff = 0;</span>
<span class="line-added">+         private InputStream inStream;</span>
<span class="line-added">+         private Reader reader;</span>
  
          int readLine() throws IOException {
<span class="line-added">+             // use locals to optimize for interpreted performance</span>
              int len = 0;
<span class="line-modified">!             int off = inOff;</span>
<span class="line-added">+             int limit = inLimit;</span>
  
              boolean skipWhiteSpace = true;
              boolean appendedLineBegin = false;
              boolean precedingBackslash = false;
<span class="line-modified">!             boolean fromStream = inStream != null;</span>
<span class="line-added">+             byte[] byteBuf = inByteBuf;</span>
<span class="line-added">+             char[] charBuf = inCharBuf;</span>
<span class="line-added">+             char[] lineBuf = this.lineBuf;</span>
<span class="line-added">+             char c;</span>
  
              while (true) {
<span class="line-modified">!                 if (off &gt;= limit) {</span>
<span class="line-modified">!                     inLimit = limit = fromStream ? inStream.read(byteBuf)</span>
<span class="line-modified">!                                                  : reader.read(charBuf);</span>
<span class="line-modified">!                     if (limit &lt;= 0) {</span>
<span class="line-modified">!                         if (len == 0) {</span>
                              return -1;
                          }
<span class="line-modified">!                         return precedingBackslash ? len - 1 : len;</span>
                      }
<span class="line-added">+                     off = 0;</span>
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 // (char)(byte &amp; 0xFF) is equivalent to calling a ISO8859-1 decoder.</span>
<span class="line-added">+                 c = (fromStream) ? (char)(byteBuf[off++] &amp; 0xFF) : charBuf[off++];</span>
<span class="line-added">+ </span>
                  if (skipWhiteSpace) {
                      if (c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\f&#39;) {
                          continue;
                      }
                      if (!appendedLineBegin &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;)) {
                          continue;
                      }
                      skipWhiteSpace = false;
                      appendedLineBegin = false;
<span class="line-added">+ </span>
                  }
<span class="line-modified">!                 if (len == 0) { // Still on a new logical line</span>
                      if (c == &#39;#&#39; || c == &#39;!&#39;) {
<span class="line-modified">!                         // Comment, quickly consume the rest of the line</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         // When checking for new line characters a range check,</span>
<span class="line-modified">!                         // starting with the higher bound (&#39;\r&#39;) means one less</span>
<span class="line-modified">!                         // branch in the common case.</span>
<span class="line-modified">!                         commentLoop: while (true) {</span>
<span class="line-modified">!                             if (fromStream) {</span>
<span class="line-modified">!                                 byte b;</span>
<span class="line-added">+                                 while (off &lt; limit) {</span>
<span class="line-added">+                                     b = byteBuf[off++];</span>
<span class="line-added">+                                     if (b &lt;= &#39;\r&#39; &amp;&amp; (b == &#39;\r&#39; || b == &#39;\n&#39;))</span>
<span class="line-added">+                                         break commentLoop;</span>
                                  }
<span class="line-modified">!                                 if (off == limit) {</span>
<span class="line-modified">!                                     inLimit = limit = inStream.read(byteBuf);</span>
<span class="line-modified">!                                     if (limit &lt;= 0) { // EOF</span>
<span class="line-modified">!                                         return -1;</span>
<span class="line-modified">!                                     }</span>
<span class="line-modified">!                                     off = 0;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                             } else {</span>
<span class="line-added">+                                 while (off &lt; limit) {</span>
<span class="line-added">+                                     c = charBuf[off++];</span>
<span class="line-added">+                                     if (c &lt;= &#39;\r&#39; &amp;&amp; (c == &#39;\r&#39; || c == &#39;\n&#39;))</span>
<span class="line-added">+                                         break commentLoop;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                                 if (off == limit) {</span>
<span class="line-added">+                                     inLimit = limit = reader.read(charBuf);</span>
<span class="line-added">+                                     if (limit &lt;= 0) { // EOF</span>
<span class="line-added">+                                         return -1;</span>
<span class="line-added">+                                     }</span>
<span class="line-added">+                                     off = 0;</span>
                                  }
                              }
                          }
<span class="line-modified">!                         skipWhiteSpace = true;</span>
<span class="line-added">+                         continue;</span>
                      }
                  }
  
                  if (c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
                      lineBuf[len++] = c;
                      if (len == lineBuf.length) {
<span class="line-modified">!                         lineBuf = new char[ArraysSupport.newLength(len, 1, len)];</span>
<span class="line-modified">!                         System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);</span>
<span class="line-modified">!                         this.lineBuf = lineBuf;</span>
                      }
<span class="line-modified">!                     // flip the preceding backslash flag</span>
<span class="line-modified">!                     precedingBackslash = (c == &#39;\\&#39;) ? !precedingBackslash : false;</span>
<span class="line-added">+                 } else {</span>
                      // reached EOL
<span class="line-modified">!                     if (len == 0) {</span>
                          skipWhiteSpace = true;
                          continue;
                      }
<span class="line-modified">!                     if (off &gt;= limit) {</span>
<span class="line-modified">!                         inLimit = limit = fromStream ? inStream.read(byteBuf)</span>
<span class="line-modified">!                                                      : reader.read(charBuf);</span>
<span class="line-modified">!                         off = 0;</span>
<span class="line-modified">!                         if (limit &lt;= 0) { // EOF</span>
<span class="line-modified">!                             return precedingBackslash ? len - 1 : len;</span>
                          }
                      }
                      if (precedingBackslash) {
<span class="line-added">+                         // backslash at EOL is not part of the line</span>
                          len -= 1;
<span class="line-modified">!                         // skip leading whitespace characters in the following line</span>
                          skipWhiteSpace = true;
                          appendedLineBegin = true;
                          precedingBackslash = false;
<span class="line-added">+                         // take care not to include any subsequent \n</span>
                          if (c == &#39;\r&#39;) {
<span class="line-modified">!                             if (fromStream) {</span>
<span class="line-added">+                                 if (byteBuf[off] == &#39;\n&#39;) {</span>
<span class="line-added">+                                     off++;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                             } else {</span>
<span class="line-added">+                                 if (charBuf[off] == &#39;\n&#39;) {</span>
<span class="line-added">+                                     off++;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                             }</span>
                          }
                      } else {
<span class="line-added">+                         inOff = off;</span>
                          return len;
                      }
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,31 ***</span>
  
      /*
       * Converts encoded &amp;#92;uxxxx to unicode chars
       * and changes special saved chars to their original forms
       */
<span class="line-modified">!     private String loadConvert (char[] in, int off, int len, char[] convtBuf) {</span>
<span class="line-removed">-         if (convtBuf.length &lt; len) {</span>
<span class="line-removed">-             int newLen = len * 2;</span>
<span class="line-removed">-             if (newLen &lt; 0) {</span>
<span class="line-removed">-                 newLen = Integer.MAX_VALUE;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             convtBuf = new char[newLen];</span>
<span class="line-removed">-         }</span>
          char aChar;
<span class="line-removed">-         char[] out = convtBuf;</span>
<span class="line-removed">-         int outLen = 0;</span>
          int end = off + len;
  
          while (off &lt; end) {
              aChar = in[off++];
              if (aChar == &#39;\\&#39;) {
                  aChar = in[off++];
                  if(aChar == &#39;u&#39;) {
                      // Read the xxxx
<span class="line-modified">!                     int value=0;</span>
<span class="line-modified">!                     for (int i=0; i&lt;4; i++) {</span>
                          aChar = in[off++];
                          switch (aChar) {
                            case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
                            case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
                               value = (value &lt;&lt; 4) + aChar - &#39;0&#39;;
<span class="line-new-header">--- 620,42 ---</span>
  
      /*
       * Converts encoded &amp;#92;uxxxx to unicode chars
       * and changes special saved chars to their original forms
       */
<span class="line-modified">!     private String loadConvert(char[] in, int off, int len, StringBuilder out) {</span>
          char aChar;
          int end = off + len;
<span class="line-added">+         int start = off;</span>
<span class="line-added">+         while (off &lt; end) {</span>
<span class="line-added">+             aChar = in[off++];</span>
<span class="line-added">+             if (aChar == &#39;\\&#39;) {</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (off == end) { // No backslash</span>
<span class="line-added">+             return new String(in, start, len);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // backslash found at off - 1, reset the shared buffer, rewind offset</span>
<span class="line-added">+         out.setLength(0);</span>
<span class="line-added">+         off--;</span>
<span class="line-added">+         out.append(in, start, off - start);</span>
  
          while (off &lt; end) {
              aChar = in[off++];
              if (aChar == &#39;\\&#39;) {
<span class="line-added">+                 // No need to bounds check since LineReader::readLine excludes</span>
<span class="line-added">+                 // unescaped \s at the end of the line</span>
                  aChar = in[off++];
                  if(aChar == &#39;u&#39;) {
                      // Read the xxxx
<span class="line-modified">!                     if (off &gt; end - 4)</span>
<span class="line-modified">!                         throw new IllegalArgumentException(</span>
<span class="line-added">+                                      &quot;Malformed \\uxxxx encoding.&quot;);</span>
<span class="line-added">+                     int value = 0;</span>
<span class="line-added">+                     for (int i = 0; i &lt; 4; i++) {</span>
                          aChar = in[off++];
                          switch (aChar) {
                            case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
                            case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
                               value = (value &lt;&lt; 4) + aChar - &#39;0&#39;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,24 ***</span>
                               break;
                            default:
                                throw new IllegalArgumentException(
                                             &quot;Malformed \\uxxxx encoding.&quot;);
                          }
<span class="line-modified">!                      }</span>
<span class="line-modified">!                     out[outLen++] = (char)value;</span>
                  } else {
                      if (aChar == &#39;t&#39;) aChar = &#39;\t&#39;;
                      else if (aChar == &#39;r&#39;) aChar = &#39;\r&#39;;
                      else if (aChar == &#39;n&#39;) aChar = &#39;\n&#39;;
                      else if (aChar == &#39;f&#39;) aChar = &#39;\f&#39;;
<span class="line-modified">!                     out[outLen++] = aChar;</span>
                  }
              } else {
<span class="line-modified">!                 out[outLen++] = aChar;</span>
              }
          }
<span class="line-modified">!         return new String (out, 0, outLen);</span>
      }
  
      /*
       * Converts unicodes to encoded &amp;#92;uxxxx and escapes
       * special characters with a preceding slash
<span class="line-new-header">--- 670,24 ---</span>
                               break;
                            default:
                                throw new IllegalArgumentException(
                                             &quot;Malformed \\uxxxx encoding.&quot;);
                          }
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     out.append((char)value);</span>
                  } else {
                      if (aChar == &#39;t&#39;) aChar = &#39;\t&#39;;
                      else if (aChar == &#39;r&#39;) aChar = &#39;\r&#39;;
                      else if (aChar == &#39;n&#39;) aChar = &#39;\n&#39;;
                      else if (aChar == &#39;f&#39;) aChar = &#39;\f&#39;;
<span class="line-modified">!                     out.append(aChar);</span>
                  }
              } else {
<span class="line-modified">!                 out.append(aChar);</span>
              }
          }
<span class="line-modified">!         return out.toString();</span>
      }
  
      /*
       * Converts unicodes to encoded &amp;#92;uxxxx and escapes
       * special characters with a preceding slash
</pre>
<hr />
<pre>
<span class="line-old-header">*** 783,11 ***</span>
       * String comments)} method or the
       * {@code storeToXML(OutputStream os, String comment)} method.
       *
       * @param   out      an output stream.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @exception  ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not
       *             {@code Strings}.
       */
      @Deprecated
      public void save(OutputStream out, String comments)  {
<span class="line-new-header">--- 801,11 ---</span>
       * String comments)} method or the
       * {@code storeToXML(OutputStream os, String comment)} method.
       *
       * @param   out      an output stream.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @throws     ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not
       *             {@code Strings}.
       */
      @Deprecated
      public void save(OutputStream out, String comments)  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,15 ***</span>
       * After the entries have been written, the output stream is flushed.
       * The output stream remains open after this method returns.
       *
       * @param   writer      an output character stream writer.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @exception  IOException if writing this property list to the specified</span>
       *             output stream throws an {@code IOException}.
<span class="line-modified">!      * @exception  ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not {@code Strings}.
<span class="line-modified">!      * @exception  NullPointerException  if {@code writer} is null.</span>
       * @since 1.6
       */
      public void store(Writer writer, String comments)
          throws IOException
      {
<span class="line-new-header">--- 853,15 ---</span>
       * After the entries have been written, the output stream is flushed.
       * The output stream remains open after this method returns.
       *
       * @param   writer      an output character stream writer.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @throws     IOException if writing this property list to the specified</span>
       *             output stream throws an {@code IOException}.
<span class="line-modified">!      * @throws     ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not {@code Strings}.
<span class="line-modified">!      * @throws     NullPointerException  if {@code writer} is null.</span>
       * @since 1.6
       */
      public void store(Writer writer, String comments)
          throws IOException
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 882,21 ***</span>
       * After the entries have been written, the output stream is flushed.
       * The output stream remains open after this method returns.
       *
       * @param   out      an output stream.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @exception  IOException if writing this property list to the specified</span>
       *             output stream throws an {@code IOException}.
<span class="line-modified">!      * @exception  ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not {@code Strings}.
<span class="line-modified">!      * @exception  NullPointerException  if {@code out} is null.</span>
       * @since 1.2
       */
      public void store(OutputStream out, String comments)
          throws IOException
      {
<span class="line-modified">!         store0(new BufferedWriter(new OutputStreamWriter(out, &quot;8859_1&quot;)),</span>
                 comments,
                 true);
      }
  
      private void store0(BufferedWriter bw, String comments, boolean escUnicode)
<span class="line-new-header">--- 900,21 ---</span>
       * After the entries have been written, the output stream is flushed.
       * The output stream remains open after this method returns.
       *
       * @param   out      an output stream.
       * @param   comments   a description of the property list.
<span class="line-modified">!      * @throws     IOException if writing this property list to the specified</span>
       *             output stream throws an {@code IOException}.
<span class="line-modified">!      * @throws     ClassCastException  if this {@code Properties} object</span>
       *             contains any keys or values that are not {@code Strings}.
<span class="line-modified">!      * @throws     NullPointerException  if {@code out} is null.</span>
       * @since 1.2
       */
      public void store(OutputStream out, String comments)
          throws IOException
      {
<span class="line-modified">!         store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),</span>
                 comments,
                 true);
      }
  
      private void store0(BufferedWriter bw, String comments, boolean escUnicode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,11 ***</span>
       * @since 1.5
       */
      public void storeToXML(OutputStream os, String comment)
          throws IOException
      {
<span class="line-modified">!         storeToXML(os, comment, &quot;UTF-8&quot;);</span>
      }
  
      /**
       * Emits an XML document representing all of the properties contained
       * in this table, using the specified encoding.
<span class="line-new-header">--- 1002,11 ---</span>
       * @since 1.5
       */
      public void storeToXML(OutputStream os, String comment)
          throws IOException
      {
<span class="line-modified">!         storeToXML(os, comment, UTF_8.INSTANCE);</span>
      }
  
      /**
       * Emits an XML document representing all of the properties contained
       * in this table, using the specified encoding.
</pre>
<center><a href="PriorityQueue.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyPermission.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
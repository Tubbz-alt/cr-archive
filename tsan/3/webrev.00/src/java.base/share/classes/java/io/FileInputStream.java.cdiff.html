<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/FileInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileNotFoundException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/FileInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,17 ***</span>
  import java.nio.channels.FileChannel;
  import sun.nio.ch.FileChannelImpl;
  
  
  /**
<span class="line-modified">!  * A &lt;code&gt;FileInputStream&lt;/code&gt; obtains input bytes</span>
   * from a file in a file system. What files
   * are  available depends on the host environment.
   *
<span class="line-modified">!  * &lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt; is meant for reading streams of raw bytes</span>
   * such as image data. For reading streams of characters, consider using
<span class="line-modified">!  * &lt;code&gt;FileReader&lt;/code&gt;.</span>
   *
   * @apiNote
   * To release resources used by this stream {@link #close} should be called
   * directly or by try-with-resources. Subclasses are responsible for the cleanup
   * of resources acquired by the subclass.
<span class="line-new-header">--- 28,17 ---</span>
  import java.nio.channels.FileChannel;
  import sun.nio.ch.FileChannelImpl;
  
  
  /**
<span class="line-modified">!  * A {@code FileInputStream} obtains input bytes</span>
   * from a file in a file system. What files
   * are  available depends on the host environment.
   *
<span class="line-modified">!  * &lt;p&gt;{@code FileInputStream} is meant for reading streams of raw bytes</span>
   * such as image data. For reading streams of characters, consider using
<span class="line-modified">!  * {@code FileReader}.</span>
   *
   * @apiNote
   * To release resources used by this stream {@link #close} should be called
   * directly or by try-with-resources. Subclasses are responsible for the cleanup
   * of resources acquired by the subclass.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,12 ***</span>
   * @see     java.io.FileDescriptor
   * @see     java.io.FileOutputStream
   * @see     java.nio.file.Files#newInputStream
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class FileInputStream extends InputStream</span>
  {
      /* File Descriptor - handle to the open file */
      private final FileDescriptor fd;
  
      /**
<span class="line-new-header">--- 59,11 ---</span>
   * @see     java.io.FileDescriptor
   * @see     java.io.FileOutputStream
   * @see     java.nio.file.Files#newInputStream
   * @since   1.0
   */
<span class="line-modified">! public class FileInputStream extends InputStream</span>
  {
      /* File Descriptor - handle to the open file */
      private final FileDescriptor fd;
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,64 ***</span>
      private final Object closeLock = new Object();
  
      private volatile boolean closed;
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by</span>
       * opening a connection to an actual file,
<span class="line-modified">!      * the file named by the path name &lt;code&gt;name&lt;/code&gt;</span>
<span class="line-modified">!      * in the file system.  A new &lt;code&gt;FileDescriptor&lt;/code&gt;</span>
       * object is created to represent this file
       * connection.
       * &lt;p&gt;
       * First, if there is a security
<span class="line-modified">!      * manager, its &lt;code&gt;checkRead&lt;/code&gt; method</span>
<span class="line-modified">!      * is called with the &lt;code&gt;name&lt;/code&gt; argument</span>
       * as its argument.
       * &lt;p&gt;
       * If the named file does not exist, is a directory rather than a regular
       * file, or for some other reason cannot be opened for reading then a
<span class="line-modified">!      * &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
       *
       * @param      name   the system-dependent file name.
<span class="line-modified">!      * @exception  FileNotFoundException  if the file does not exist,</span>
<span class="line-modified">!      *                   is a directory rather than a regular file,</span>
<span class="line-modified">!      *                   or for some other reason cannot be opened for</span>
<span class="line-modified">!      *                   reading.</span>
<span class="line-modified">!      * @exception  SecurityException      if a security manager exists and its</span>
<span class="line-modified">!      *               &lt;code&gt;checkRead&lt;/code&gt; method denies read access</span>
<span class="line-modified">!      *               to the file.</span>
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       */
      public FileInputStream(String name) throws FileNotFoundException {
          this(name != null ? new File(name) : null);
      }
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by</span>
       * opening a connection to an actual file,
<span class="line-modified">!      * the file named by the &lt;code&gt;File&lt;/code&gt;</span>
<span class="line-modified">!      * object &lt;code&gt;file&lt;/code&gt; in the file system.</span>
<span class="line-modified">!      * A new &lt;code&gt;FileDescriptor&lt;/code&gt; object</span>
       * is created to represent this file connection.
       * &lt;p&gt;
       * First, if there is a security manager,
<span class="line-modified">!      * its &lt;code&gt;checkRead&lt;/code&gt; method  is called</span>
<span class="line-modified">!      * with the path represented by the &lt;code&gt;file&lt;/code&gt;</span>
       * argument as its argument.
       * &lt;p&gt;
       * If the named file does not exist, is a directory rather than a regular
       * file, or for some other reason cannot be opened for reading then a
<span class="line-modified">!      * &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
       *
       * @param      file   the file to be opened for reading.
<span class="line-modified">!      * @exception  FileNotFoundException  if the file does not exist,</span>
<span class="line-modified">!      *                   is a directory rather than a regular file,</span>
<span class="line-modified">!      *                   or for some other reason cannot be opened for</span>
<span class="line-modified">!      *                   reading.</span>
<span class="line-modified">!      * @exception  SecurityException      if a security manager exists and its</span>
<span class="line-modified">!      *               &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the file.</span>
       * @see        java.io.File#getPath()
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       */
      public FileInputStream(File file) throws FileNotFoundException {
          String name = (file != null ? file.getPath() : null);
<span class="line-new-header">--- 77,64 ---</span>
      private final Object closeLock = new Object();
  
      private volatile boolean closed;
  
      /**
<span class="line-modified">!      * Creates a {@code FileInputStream} by</span>
       * opening a connection to an actual file,
<span class="line-modified">!      * the file named by the path name {@code name}</span>
<span class="line-modified">!      * in the file system.  A new {@code FileDescriptor}</span>
       * object is created to represent this file
       * connection.
       * &lt;p&gt;
       * First, if there is a security
<span class="line-modified">!      * manager, its {@code checkRead} method</span>
<span class="line-modified">!      * is called with the {@code name} argument</span>
       * as its argument.
       * &lt;p&gt;
       * If the named file does not exist, is a directory rather than a regular
       * file, or for some other reason cannot be opened for reading then a
<span class="line-modified">!      * {@code FileNotFoundException} is thrown.</span>
       *
       * @param      name   the system-dependent file name.
<span class="line-modified">!      * @throws     FileNotFoundException  if the file does not exist,</span>
<span class="line-modified">!      *             is a directory rather than a regular file,</span>
<span class="line-modified">!      *             or for some other reason cannot be opened for</span>
<span class="line-modified">!      *             reading.</span>
<span class="line-modified">!      * @throws     SecurityException      if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkRead} method denies read access</span>
<span class="line-modified">!      *             to the file.</span>
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       */
      public FileInputStream(String name) throws FileNotFoundException {
          this(name != null ? new File(name) : null);
      }
  
      /**
<span class="line-modified">!      * Creates a {@code FileInputStream} by</span>
       * opening a connection to an actual file,
<span class="line-modified">!      * the file named by the {@code File}</span>
<span class="line-modified">!      * object {@code file} in the file system.</span>
<span class="line-modified">!      * A new {@code FileDescriptor} object</span>
       * is created to represent this file connection.
       * &lt;p&gt;
       * First, if there is a security manager,
<span class="line-modified">!      * its {@code checkRead} method  is called</span>
<span class="line-modified">!      * with the path represented by the {@code file}</span>
       * argument as its argument.
       * &lt;p&gt;
       * If the named file does not exist, is a directory rather than a regular
       * file, or for some other reason cannot be opened for reading then a
<span class="line-modified">!      * {@code FileNotFoundException} is thrown.</span>
       *
       * @param      file   the file to be opened for reading.
<span class="line-modified">!      * @throws     FileNotFoundException  if the file does not exist,</span>
<span class="line-modified">!      *             is a directory rather than a regular file,</span>
<span class="line-modified">!      *             or for some other reason cannot be opened for</span>
<span class="line-modified">!      *             reading.</span>
<span class="line-modified">!      * @throws     SecurityException      if a security manager exists and its</span>
<span class="line-modified">!      *             {@code checkRead} method denies read access to the file.</span>
       * @see        java.io.File#getPath()
       * @see        java.lang.SecurityManager#checkRead(java.lang.String)
       */
      public FileInputStream(File file) throws FileNotFoundException {
          String name = (file != null ? file.getPath() : null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,31 ***</span>
          open(name);
          FileCleanable.register(fd);       // open set the fd, register the cleanup
      }
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by using the file descriptor</span>
<span class="line-modified">!      * &lt;code&gt;fdObj&lt;/code&gt;, which represents an existing connection to an</span>
       * actual file in the file system.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is</span>
<span class="line-modified">!      * called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to</span>
       * see if it&#39;s ok to read the file descriptor. If read access is denied
<span class="line-modified">!      * to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</span>
       * &lt;p&gt;
<span class="line-modified">!      * If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt;</span>
       * is thrown.
       * &lt;p&gt;
<span class="line-modified">!      * This constructor does not throw an exception if &lt;code&gt;fdObj&lt;/code&gt;</span>
       * is {@link java.io.FileDescriptor#valid() invalid}.
       * However, if the methods are invoked on the resulting stream to attempt
<span class="line-modified">!      * I/O on the stream, an &lt;code&gt;IOException&lt;/code&gt; is thrown.</span>
       *
       * @param      fdObj   the file descriptor to be opened for reading.
       * @throws     SecurityException      if a security manager exists and its
<span class="line-modified">!      *                 &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the</span>
<span class="line-modified">!      *                 file descriptor.</span>
       * @see        SecurityManager#checkRead(java.io.FileDescriptor)
       */
      public FileInputStream(FileDescriptor fdObj) {
          SecurityManager security = System.getSecurityManager();
          if (fdObj == null) {
<span class="line-new-header">--- 154,31 ---</span>
          open(name);
          FileCleanable.register(fd);       // open set the fd, register the cleanup
      }
  
      /**
<span class="line-modified">!      * Creates a {@code FileInputStream} by using the file descriptor</span>
<span class="line-modified">!      * {@code fdObj}, which represents an existing connection to an</span>
       * actual file in the file system.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, its {@code checkRead} method is</span>
<span class="line-modified">!      * called with the file descriptor {@code fdObj} as its argument to</span>
       * see if it&#39;s ok to read the file descriptor. If read access is denied
<span class="line-modified">!      * to the file descriptor a {@code SecurityException} is thrown.</span>
       * &lt;p&gt;
<span class="line-modified">!      * If {@code fdObj} is null then a {@code NullPointerException}</span>
       * is thrown.
       * &lt;p&gt;
<span class="line-modified">!      * This constructor does not throw an exception if {@code fdObj}</span>
       * is {@link java.io.FileDescriptor#valid() invalid}.
       * However, if the methods are invoked on the resulting stream to attempt
<span class="line-modified">!      * I/O on the stream, an {@code IOException} is thrown.</span>
       *
       * @param      fdObj   the file descriptor to be opened for reading.
       * @throws     SecurityException      if a security manager exists and its
<span class="line-modified">!      *             {@code checkRead} method denies read access to the</span>
<span class="line-modified">!      *             file descriptor.</span>
       * @see        SecurityManager#checkRead(java.io.FileDescriptor)
       */
      public FileInputStream(FileDescriptor fdObj) {
          SecurityManager security = System.getSecurityManager();
          if (fdObj == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,75 ***</span>
  
      /**
       * Reads a byte of data from this input stream. This method blocks
       * if no input is yet available.
       *
<span class="line-modified">!      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
       *             file is reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public int read() throws IOException {
          return read0();
      }
  
      private native int read0() throws IOException;
  
      /**
       * Reads a subarray as a sequence of bytes.
<span class="line-modified">!      * @param b the data to be written</span>
<span class="line-modified">!      * @param off the start offset in the data</span>
<span class="line-modified">!      * @param len the number of bytes that are written</span>
<span class="line-modified">!      * @exception IOException If an I/O error has occurred.</span>
       */
      private native int readBytes(byte b[], int off, int len) throws IOException;
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;b.length&lt;/code&gt; bytes of data from this input</span>
       * stream into an array of bytes. This method blocks until some input
       * is available.
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the file has been reached.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public int read(byte b[]) throws IOException {
          return readBytes(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream</span>
<span class="line-modified">!      * into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not zero, the method</span>
       * blocks until some input is available; otherwise, no
<span class="line-modified">!      * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span>
       *             the file has been reached.
<span class="line-modified">!      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">!      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">!      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">!      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public int read(byte b[], int off, int len) throws IOException {
          return readBytes(b, off, len);
      }
  
      /**
<span class="line-modified">!      * Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from the</span>
       * input stream.
       *
<span class="line-modified">!      * &lt;p&gt;The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of</span>
       * reasons, end up skipping over some smaller number of bytes,
<span class="line-modified">!      * possibly &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is negative, the method</span>
       * will try to skip backwards. In case the backing file does not support
<span class="line-modified">!      * backward skip at its current position, an &lt;code&gt;IOException&lt;/code&gt; is</span>
       * thrown. The actual number of bytes skipped is returned. If it skips
       * forwards, it returns a positive value. If it skips backwards, it
       * returns a negative value.
       *
       * &lt;p&gt;This method may skip more bytes than what are remaining in the
<span class="line-new-header">--- 214,75 ---</span>
  
      /**
       * Reads a byte of data from this input stream. This method blocks
       * if no input is yet available.
       *
<span class="line-modified">!      * @return     the next byte of data, or {@code -1} if the end of the</span>
       *             file is reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public int read() throws IOException {
          return read0();
      }
  
      private native int read0() throws IOException;
  
      /**
       * Reads a subarray as a sequence of bytes.
<span class="line-modified">!      * @param     b the data to be written</span>
<span class="line-modified">!      * @param     off the start offset in the data</span>
<span class="line-modified">!      * @param     len the number of bytes that are written</span>
<span class="line-modified">!      * @throws    IOException If an I/O error has occurred.</span>
       */
      private native int readBytes(byte b[], int off, int len) throws IOException;
  
      /**
<span class="line-modified">!      * Reads up to {@code b.length} bytes of data from this input</span>
       * stream into an array of bytes. This method blocks until some input
       * is available.
       *
       * @param      b   the buffer into which the data is read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the file has been reached.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public int read(byte b[]) throws IOException {
          return readBytes(b, 0, b.length);
      }
  
      /**
<span class="line-modified">!      * Reads up to {@code len} bytes of data from this input stream</span>
<span class="line-modified">!      * into an array of bytes. If {@code len} is not zero, the method</span>
       * blocks until some input is available; otherwise, no
<span class="line-modified">!      * bytes are read and {@code 0} is returned.</span>
       *
       * @param      b     the buffer into which the data is read.
<span class="line-modified">!      * @param      off   the start offset in the destination array {@code b}</span>
       * @param      len   the maximum number of bytes read.
       * @return     the total number of bytes read into the buffer, or
<span class="line-modified">!      *             {@code -1} if there is no more data because the end of</span>
       *             the file has been reached.
<span class="line-modified">!      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">!      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">!      *             {@code len} is negative, or {@code len} is greater than</span>
<span class="line-modified">!      *             {@code b.length - off}</span>
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public int read(byte b[], int off, int len) throws IOException {
          return readBytes(b, off, len);
      }
  
      /**
<span class="line-modified">!      * Skips over and discards {@code n} bytes of data from the</span>
       * input stream.
       *
<span class="line-modified">!      * &lt;p&gt;The {@code skip} method may, for a variety of</span>
       * reasons, end up skipping over some smaller number of bytes,
<span class="line-modified">!      * possibly {@code 0}. If {@code n} is negative, the method</span>
       * will try to skip backwards. In case the backing file does not support
<span class="line-modified">!      * backward skip at its current position, an {@code IOException} is</span>
       * thrown. The actual number of bytes skipped is returned. If it skips
       * forwards, it returns a positive value. If it skips backwards, it
       * returns a negative value.
       *
       * &lt;p&gt;This method may skip more bytes than what are remaining in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,11 ***</span>
       * backing file. Attempting to read from the stream after skipping past
       * the end will result in -1 indicating the end of the file.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @exception  IOException  if n is negative, if the stream does not</span>
       *             support seek, or if an I/O error occurs.
       */
      public long skip(long n) throws IOException {
          return skip0(n);
      }
<span class="line-new-header">--- 291,11 ---</span>
       * backing file. Attempting to read from the stream after skipping past
       * the end will result in -1 indicating the end of the file.
       *
       * @param      n   the number of bytes to be skipped.
       * @return     the actual number of bytes skipped.
<span class="line-modified">!      * @throws     IOException  if n is negative, if the stream does not</span>
       *             support seek, or if an I/O error occurs.
       */
      public long skip(long n) throws IOException {
          return skip0(n);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,11 ***</span>
       * blocked when it is merely slow, for example when reading large
       * files over slow networks.
       *
       * @return     an estimate of the number of remaining bytes that can be read
       *             (or skipped over) from this input stream without blocking.
<span class="line-modified">!      * @exception  IOException  if this file input stream has been closed by calling</span>
       *             {@code close} or an I/O error occurs.
       */
      public int available() throws IOException {
          return available0();
      }
<span class="line-new-header">--- 314,11 ---</span>
       * blocked when it is merely slow, for example when reading large
       * files over slow networks.
       *
       * @return     an estimate of the number of remaining bytes that can be read
       *             (or skipped over) from this input stream without blocking.
<span class="line-modified">!      * @throws     IOException  if this file input stream has been closed by calling</span>
       *             {@code close} or an I/O error occurs.
       */
      public int available() throws IOException {
          return available0();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,11 ***</span>
       * Do not depend on finalization to invoke {@code close};
       * finalization is not reliable and is deprecated.
       * If cleanup of native resources is needed, other mechanisms such as
       * {@linkplain java.lang.ref.Cleaner} should be used.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() throws IOException {
<span class="line-new-header">--- 338,11 ---</span>
       * Do not depend on finalization to invoke {@code close};
       * finalization is not reliable and is deprecated.
       * If cleanup of native resources is needed, other mechanisms such as
       * {@linkplain java.lang.ref.Cleaner} should be used.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       *
       * @revised 1.4
       * @spec JSR-51
       */
      public void close() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,17 ***</span>
             }
          });
      }
  
      /**
<span class="line-modified">!      * Returns the &lt;code&gt;FileDescriptor&lt;/code&gt;</span>
       * object  that represents the connection to
       * the actual file in the file system being
<span class="line-modified">!      * used by this &lt;code&gt;FileInputStream&lt;/code&gt;.</span>
       *
       * @return     the file descriptor object associated with this stream.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       * @see        java.io.FileDescriptor
       */
      public final FileDescriptor getFD() throws IOException {
          if (fd != null) {
              return fd;
<span class="line-new-header">--- 369,17 ---</span>
             }
          });
      }
  
      /**
<span class="line-modified">!      * Returns the {@code FileDescriptor}</span>
       * object  that represents the connection to
       * the actual file in the file system being
<span class="line-modified">!      * used by this {@code FileInputStream}.</span>
       *
       * @return     the file descriptor object associated with this stream.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       * @see        java.io.FileDescriptor
       */
      public final FileDescriptor getFD() throws IOException {
          if (fd != null) {
              return fd;
</pre>
<center><a href="FileFilter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileNotFoundException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
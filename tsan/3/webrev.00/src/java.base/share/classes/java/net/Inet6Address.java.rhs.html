<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/Inet6Address.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.io.InvalidObjectException;
 30 import java.io.ObjectInputStream;
 31 import java.io.ObjectOutputStream;
 32 import java.io.ObjectStreamField;
 33 import java.util.Enumeration;
 34 import java.util.Arrays;
 35 
 36 /**
 37  * This class represents an Internet Protocol version 6 (IPv6) address.
 38  * Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;
 39  * &lt;i&gt;RFC&amp;nbsp;2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.
 40  *
<a name="2" id="anc2"></a><span class="line-modified"> 41  * &lt;h2&gt; &lt;a id=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h2&gt;</span>
 42  *
 43  * Textual representation of IPv6 address used as input to methods
 44  * takes one of the following forms:
 45  *
 46  * &lt;ol&gt;
 47  *   &lt;li&gt;&lt;p&gt; &lt;a id=&quot;lform&quot;&gt;The preferred form&lt;/a&gt; is x:x:x:x:x:x:x:x,
 48  *   where the &#39;x&#39;s are
 49  *   the hexadecimal values of the eight 16-bit pieces of the
 50  *   address. This is the full form.  For example,
 51  *
 52  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 53  *   &lt;li&gt;{@code 1080:0:0:0:8:800:200C:417A}&lt;/li&gt;
 54  *   &lt;/ul&gt;&lt;/blockquote&gt;
 55  *
 56  *   &lt;p&gt; Note that it is not necessary to write the leading zeros in
 57  *   an individual field. However, there must be at least one numeral
 58  *   in every field, except as described below.&lt;/li&gt;
 59  *
 60  *   &lt;li&gt;&lt;p&gt; Due to some methods of allocating certain styles of IPv6
 61  *   addresses, it will be common for addresses to contain long
 62  *   strings of zero bits. In order to make writing addresses
 63  *   containing zero bits easier, a special syntax is available to
 64  *   compress the zeros. The use of &quot;::&quot; indicates multiple groups
 65  *   of 16-bits of zeros. The &quot;::&quot; can only appear once in an address.
 66  *   The &quot;::&quot; can also be used to compress the leading and/or trailing
 67  *   zeros in an address. For example,
 68  *
 69  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 70  *   &lt;li&gt;{@code 1080::8:800:200C:417A}&lt;/li&gt;
 71  *   &lt;/ul&gt;&lt;/blockquote&gt;
 72  *
 73  *   &lt;li&gt;&lt;p&gt; An alternative form that is sometimes more convenient
 74  *   when dealing with a mixed environment of IPv4 and IPv6 nodes is
 75  *   x:x:x:x:x:x:d.d.d.d, where the &#39;x&#39;s are the hexadecimal values
 76  *   of the six high-order 16-bit pieces of the address, and the &#39;d&#39;s
 77  *   are the decimal values of the four low-order 8-bit pieces of the
 78  *   standard IPv4 representation address, for example,
 79  *
 80  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 81  *   &lt;li&gt;{@code ::FFFF:129.144.52.38}&lt;/li&gt;
 82  *   &lt;li&gt;{@code ::129.144.52.38}&lt;/li&gt;
 83  *   &lt;/ul&gt;&lt;/blockquote&gt;
 84  *
 85  *   &lt;p&gt; where &quot;::FFFF:d.d.d.d&quot; and &quot;::d.d.d.d&quot; are, respectively, the
 86  *   general forms of an IPv4-mapped IPv6 address and an
 87  *   IPv4-compatible IPv6 address. Note that the IPv4 portion must be
 88  *   in the &quot;d.d.d.d&quot; form. The following forms are invalid:
 89  *
 90  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 91  *   &lt;li&gt;{@code ::FFFF:d.d.d}&lt;/li&gt;
 92  *   &lt;li&gt;{@code ::FFFF:d.d}&lt;/li&gt;
 93  *   &lt;li&gt;{@code ::d.d.d}&lt;/li&gt;
 94  *   &lt;li&gt;{@code ::d.d}&lt;/li&gt;
 95  *   &lt;/ul&gt;&lt;/blockquote&gt;
 96  *
 97  *   &lt;p&gt; The following form:
 98  *
 99  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
100  *   &lt;li&gt;{@code ::FFFF:d}&lt;/li&gt;
101  *   &lt;/ul&gt;&lt;/blockquote&gt;
102  *
103  *   &lt;p&gt; is valid, however it is an unconventional representation of
104  *   the IPv4-compatible IPv6 address,
105  *
106  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
107  *   &lt;li&gt;{@code ::255.255.0.d}&lt;/li&gt;
108  *   &lt;/ul&gt;&lt;/blockquote&gt;
109  *
110  *   &lt;p&gt; while &quot;::d&quot; corresponds to the general IPv6 address
111  *   &quot;0:0:0:0:0:0:0:d&quot;.&lt;/li&gt;
112  * &lt;/ol&gt;
113  *
114  * &lt;p&gt; For methods that return a textual representation as output
115  * value, the full form is used. Inet6Address will return the full
116  * form because it is unambiguous when used in combination with other
117  * textual data.
118  *
<a name="3" id="anc3"></a><span class="line-modified">119  * &lt;h3&gt; Special IPv6 address &lt;/h3&gt;</span>
120  *
121  * &lt;blockquote&gt;
122  * &lt;table class=&quot;borderless&quot;&gt;
123  * &lt;caption style=&quot;display:none&quot;&gt;Description of IPv4-mapped address&lt;/caption&gt;
124  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; padding-right:2px&quot;&gt;&lt;i&gt;IPv4-mapped address&lt;/i&gt;&lt;/th&gt;
125  *         &lt;td&gt;Of the form ::ffff:w.x.y.z, this IPv6 address is used to
126  *         represent an IPv4 address. It allows the native program to
127  *         use the same address data structure and also the same
128  *         socket when communicating with both IPv4 and IPv6 nodes.
129  *
130  *         &lt;p&gt;In InetAddress and Inet6Address, it is used for internal
131  *         representation; it has no functional role. Java will never
132  *         return an IPv4-mapped address.  These classes can take an
133  *         IPv4-mapped address as input, both in byte array and text
134  *         representation. However, it will be converted into an IPv4
135  *         address.&lt;/td&gt;&lt;/tr&gt;
136  * &lt;/table&gt;&lt;/blockquote&gt;
137  *
<a name="4" id="anc4"></a><span class="line-modified">138  * &lt;h3&gt;&lt;a id=&quot;scoped&quot;&gt;Textual representation of IPv6 scoped addresses&lt;/a&gt;&lt;/h3&gt;</span>
139  *
140  * &lt;p&gt; The textual representation of IPv6 addresses as described above can be
141  * extended to specify IPv6 scoped addresses. This extension to the basic
142  * addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].
143  *
144  * &lt;p&gt; Because link-local and site-local addresses are non-global, it is possible
145  * that different hosts may have the same destination address and may be
146  * reachable through different interfaces on the same originating system. In
147  * this case, the originating system is said to be connected to multiple zones
148  * of the same scope. In order to disambiguate which is the intended destination
149  * zone, it is possible to append a zone identifier (or &lt;i&gt;scope_id&lt;/i&gt;) to an
150  * IPv6 address.
151  *
152  * &lt;p&gt; The general format for specifying the &lt;i&gt;scope_id&lt;/i&gt; is the following:
153  *
154  * &lt;blockquote&gt;&lt;i&gt;IPv6-address&lt;/i&gt;%&lt;i&gt;scope_id&lt;/i&gt;&lt;/blockquote&gt;
155  * &lt;p&gt; The IPv6-address is a literal IPv6 address as described above.
156  * The &lt;i&gt;scope_id&lt;/i&gt; refers to an interface on the local system, and it can be
157  * specified in two ways.
158  * &lt;ol&gt;&lt;li&gt;&lt;i&gt;As a numeric identifier.&lt;/i&gt; This must be a positive integer
159  * that identifies the particular interface and scope as understood by the
160  * system. Usually, the numeric values can be determined through administration
161  * tools on the system. Each interface may have multiple values, one for each
162  * scope. If the scope is unspecified, then the default value used is zero.&lt;/li&gt;
163  * &lt;li&gt;&lt;i&gt;As a string.&lt;/i&gt; This must be the exact string that is returned by
164  * {@link java.net.NetworkInterface#getName()} for the particular interface in
165  * question. When an Inet6Address is created in this way, the numeric scope-id
166  * is determined at the time the object is created by querying the relevant
167  * NetworkInterface.&lt;/li&gt;&lt;/ol&gt;
168  *
169  * &lt;p&gt; Note also, that the numeric &lt;i&gt;scope_id&lt;/i&gt; can be retrieved from
170  * Inet6Address instances returned from the NetworkInterface class. This can be
171  * used to find out the current scope ids configured on the system.
172  * @since 1.4
173  */
174 
175 public final
176 class Inet6Address extends InetAddress {
177     static final int INADDRSZ = 16;
178 
<a name="5" id="anc5"></a>




179     private class Inet6AddressHolder {
180 
181         private Inet6AddressHolder() {
182             ipaddress = new byte[INADDRSZ];
183         }
184 
185         private Inet6AddressHolder(
186             byte[] ipaddress, int scope_id, boolean scope_id_set,
187             NetworkInterface ifname, boolean scope_ifname_set)
188         {
189             this.ipaddress = ipaddress;
190             this.scope_id = scope_id;
191             this.scope_id_set = scope_id_set;
192             this.scope_ifname_set = scope_ifname_set;
193             this.scope_ifname = ifname;
194         }
195 
196         /**
197          * Holds a 128-bit (16 bytes) IPv6 address.
198          */
199         byte[] ipaddress;
200 
201         /**
202          * scope_id. The scope specified when the object is created. If the object
203          * is created with an interface name, then the scope_id is not determined
204          * until the time it is needed.
205          */
206         int scope_id;  // 0
207 
208         /**
209          * This will be set to true when the scope_id field contains a valid
210          * integer scope_id.
211          */
212         boolean scope_id_set;  // false
213 
214         /**
215          * scoped interface. scope_id is derived from this as the scope_id of the first
216          * address whose scope is the same as this address for the named interface.
217          */
218         NetworkInterface scope_ifname;  // null
219 
220         /**
221          * set if the object is constructed with a scoped
222          * interface instead of a numeric scope id.
223          */
224         boolean scope_ifname_set; // false;
225 
226         void setAddr(byte addr[]) {
227             if (addr.length == INADDRSZ) { // normal IPv6 address
228                 System.arraycopy(addr, 0, ipaddress, 0, INADDRSZ);
229             }
230         }
231 
232         void init(byte addr[], int scope_id) {
233             setAddr(addr);
234 
235             if (scope_id &gt;= 0) {
236                 this.scope_id = scope_id;
237                 this.scope_id_set = true;
238             }
239         }
240 
241         void init(byte addr[], NetworkInterface nif)
242             throws UnknownHostException
243         {
244             setAddr(addr);
245 
246             if (nif != null) {
247                 this.scope_id = deriveNumericScope(ipaddress, nif);
248                 this.scope_id_set = true;
249                 this.scope_ifname = nif;
250                 this.scope_ifname_set = true;
251             }
252         }
253 
254         String getHostAddress() {
255             String s = numericToTextFormat(ipaddress);
256             if (scope_ifname != null) { /* must check this first */
257                 s = s + &quot;%&quot; + scope_ifname.getName();
258             } else if (scope_id_set) {
259                 s = s + &quot;%&quot; + scope_id;
260             }
261             return s;
262         }
263 
264         public boolean equals(Object o) {
265             if (! (o instanceof Inet6AddressHolder)) {
266                 return false;
267             }
268             Inet6AddressHolder that = (Inet6AddressHolder)o;
269 
270             return Arrays.equals(this.ipaddress, that.ipaddress);
271         }
272 
273         public int hashCode() {
274             if (ipaddress != null) {
275 
276                 int hash = 0;
277                 int i=0;
278                 while (i&lt;INADDRSZ) {
279                     int j=0;
280                     int component=0;
281                     while (j&lt;4 &amp;&amp; i&lt;INADDRSZ) {
282                         component = (component &lt;&lt; 8) + ipaddress[i];
283                         j++;
284                         i++;
285                     }
286                     hash += component;
287                 }
288                 return hash;
289 
290             } else {
291                 return 0;
292             }
293         }
294 
295         boolean isIPv4CompatibleAddress() {
296             if ((ipaddress[0] == 0x00) &amp;&amp; (ipaddress[1] == 0x00) &amp;&amp;
297                 (ipaddress[2] == 0x00) &amp;&amp; (ipaddress[3] == 0x00) &amp;&amp;
298                 (ipaddress[4] == 0x00) &amp;&amp; (ipaddress[5] == 0x00) &amp;&amp;
299                 (ipaddress[6] == 0x00) &amp;&amp; (ipaddress[7] == 0x00) &amp;&amp;
300                 (ipaddress[8] == 0x00) &amp;&amp; (ipaddress[9] == 0x00) &amp;&amp;
301                 (ipaddress[10] == 0x00) &amp;&amp; (ipaddress[11] == 0x00))  {
302                 return true;
303             }
304             return false;
305         }
306 
307         boolean isMulticastAddress() {
308             return ((ipaddress[0] &amp; 0xff) == 0xff);
309         }
310 
311         boolean isAnyLocalAddress() {
312             byte test = 0x00;
313             for (int i = 0; i &lt; INADDRSZ; i++) {
314                 test |= ipaddress[i];
315             }
316             return (test == 0x00);
317         }
318 
319         boolean isLoopbackAddress() {
320             byte test = 0x00;
321             for (int i = 0; i &lt; 15; i++) {
322                 test |= ipaddress[i];
323             }
324             return (test == 0x00) &amp;&amp; (ipaddress[15] == 0x01);
325         }
326 
327         boolean isLinkLocalAddress() {
328             return ((ipaddress[0] &amp; 0xff) == 0xfe
329                     &amp;&amp; (ipaddress[1] &amp; 0xc0) == 0x80);
330         }
331 
332 
333         boolean isSiteLocalAddress() {
334             return ((ipaddress[0] &amp; 0xff) == 0xfe
335                     &amp;&amp; (ipaddress[1] &amp; 0xc0) == 0xc0);
336         }
337 
338         boolean isMCGlobal() {
339             return ((ipaddress[0] &amp; 0xff) == 0xff
340                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x0e);
341         }
342 
343         boolean isMCNodeLocal() {
344             return ((ipaddress[0] &amp; 0xff) == 0xff
345                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x01);
346         }
347 
348         boolean isMCLinkLocal() {
349             return ((ipaddress[0] &amp; 0xff) == 0xff
350                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x02);
351         }
352 
353         boolean isMCSiteLocal() {
354             return ((ipaddress[0] &amp; 0xff) == 0xff
355                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x05);
356         }
357 
358         boolean isMCOrgLocal() {
359             return ((ipaddress[0] &amp; 0xff) == 0xff
360                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x08);
361         }
362     }
363 
364     private final transient Inet6AddressHolder holder6;
365 
<a name="6" id="anc6"></a><span class="line-added">366     @java.io.Serial</span>
367     private static final long serialVersionUID = 6880410070516793377L;
368 
369     // Perform native initialization
370     static { init(); }
371 
372     Inet6Address() {
373         super();
374         holder.init(null, IPv6);
375         holder6 = new Inet6AddressHolder();
376     }
377 
378     /* checking of value for scope_id should be done by caller
379      * scope_id must be &gt;= 0, or -1 to indicate not being set
380      */
381     Inet6Address(String hostName, byte addr[], int scope_id) {
382         holder.init(hostName, IPv6);
383         holder6 = new Inet6AddressHolder();
384         holder6.init(addr, scope_id);
385     }
386 
387     Inet6Address(String hostName, byte addr[]) {
388         holder6 = new Inet6AddressHolder();
389         try {
390             initif (hostName, addr, null);
391         } catch (UnknownHostException e) {} /* cant happen if ifname is null */
392     }
393 
394     Inet6Address (String hostName, byte addr[], NetworkInterface nif)
395         throws UnknownHostException
396     {
397         holder6 = new Inet6AddressHolder();
398         initif (hostName, addr, nif);
399     }
400 
401     Inet6Address (String hostName, byte addr[], String ifname)
402         throws UnknownHostException
403     {
404         holder6 = new Inet6AddressHolder();
405         initstr (hostName, addr, ifname);
406     }
407 
408     /**
409      * Create an Inet6Address in the exact manner of {@link
410      * InetAddress#getByAddress(String,byte[])} except that the IPv6 scope_id is
411      * set to the value corresponding to the given interface for the address
412      * type specified in {@code addr}. The call will fail with an
413      * UnknownHostException if the given interface does not have a numeric
414      * scope_id assigned for the given address type (e.g. link-local or site-local).
415      * See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
416      * scoped addresses.
417      *
418      * @param host the specified host
419      * @param addr the raw IP address in network byte order
420      * @param nif an interface this address must be associated with.
421      * @return  an Inet6Address object created from the raw IP address.
422      * @throws  UnknownHostException
423      *          if IP address is of illegal length, or if the interface does not
424      *          have a numeric scope_id assigned for the given address type.
425      *
426      * @since 1.5
427      */
428     public static Inet6Address getByAddress(String host, byte[] addr,
429                                             NetworkInterface nif)
430         throws UnknownHostException
431     {
432         if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
433             if (host.charAt(host.length()-1) == &#39;]&#39;) {
434                 host = host.substring(1, host.length() -1);
435             }
436         }
437         if (addr != null) {
438             if (addr.length == Inet6Address.INADDRSZ) {
439                 return new Inet6Address(host, addr, nif);
440             }
441         }
442         throw new UnknownHostException(&quot;addr is of illegal length&quot;);
443     }
444 
445     /**
446      * Create an Inet6Address in the exact manner of {@link
447      * InetAddress#getByAddress(String,byte[])} except that the IPv6 scope_id is
448      * set to the given numeric value. The scope_id is not checked to determine
449      * if it corresponds to any interface on the system.
450      * See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
451      * scoped addresses.
452      *
453      * @param host the specified host
454      * @param addr the raw IP address in network byte order
455      * @param scope_id the numeric scope_id for the address.
456      * @return  an Inet6Address object created from the raw IP address.
457      * @throws  UnknownHostException  if IP address is of illegal length.
458      *
459      * @since 1.5
460      */
461     public static Inet6Address getByAddress(String host, byte[] addr,
462                                             int scope_id)
463         throws UnknownHostException
464     {
465         if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
466             if (host.charAt(host.length()-1) == &#39;]&#39;) {
467                 host = host.substring(1, host.length() -1);
468             }
469         }
470         if (addr != null) {
471             if (addr.length == Inet6Address.INADDRSZ) {
472                 return new Inet6Address(host, addr, scope_id);
473             }
474         }
475         throw new UnknownHostException(&quot;addr is of illegal length&quot;);
476     }
477 
478     private void initstr(String hostName, byte addr[], String ifname)
479         throws UnknownHostException
480     {
481         try {
482             NetworkInterface nif = NetworkInterface.getByName (ifname);
483             if (nif == null) {
484                 throw new UnknownHostException (&quot;no such interface &quot; + ifname);
485             }
486             initif (hostName, addr, nif);
487         } catch (SocketException e) {
488             throw new UnknownHostException (&quot;SocketException thrown&quot; + ifname);
489         }
490     }
491 
492     private void initif(String hostName, byte addr[], NetworkInterface nif)
493         throws UnknownHostException
494     {
495         int family = -1;
496         holder6.init(addr, nif);
497 
498         if (addr.length == INADDRSZ) { // normal IPv6 address
499             family = IPv6;
500         }
501         holder.init(hostName, family);
502     }
503 
504     /* check the two Ipv6 addresses and return false if they are both
505      * non global address types, but not the same.
506      * (i.e. one is site-local and the other link-local)
507      * return true otherwise.
508      */
509 
510     private static boolean isDifferentLocalAddressType(
511         byte[] thisAddr, byte[] otherAddr) {
512 
513         if (Inet6Address.isLinkLocalAddress(thisAddr) &amp;&amp;
514                 !Inet6Address.isLinkLocalAddress(otherAddr)) {
515             return false;
516         }
517         if (Inet6Address.isSiteLocalAddress(thisAddr) &amp;&amp;
518                 !Inet6Address.isSiteLocalAddress(otherAddr)) {
519             return false;
520         }
521         return true;
522     }
523 
524     private static int deriveNumericScope (byte[] thisAddr, NetworkInterface ifc) throws UnknownHostException {
525         Enumeration&lt;InetAddress&gt; addresses = ifc.getInetAddresses();
526         while (addresses.hasMoreElements()) {
527             InetAddress addr = addresses.nextElement();
528             if (!(addr instanceof Inet6Address)) {
529                 continue;
530             }
531             Inet6Address ia6_addr = (Inet6Address)addr;
532             /* check if site or link local prefixes match */
533             if (!isDifferentLocalAddressType(thisAddr, ia6_addr.getAddress())){
534                 /* type not the same, so carry on searching */
535                 continue;
536             }
537             /* found a matching address - return its scope_id */
538             return ia6_addr.getScopeId();
539         }
540         throw new UnknownHostException (&quot;no scope_id found&quot;);
541     }
542 
543     private int deriveNumericScope (String ifname) throws UnknownHostException {
544         Enumeration&lt;NetworkInterface&gt; en;
545         try {
546             en = NetworkInterface.getNetworkInterfaces();
547         } catch (SocketException e) {
548             throw new UnknownHostException (&quot;could not enumerate local network interfaces&quot;);
549         }
550         while (en.hasMoreElements()) {
551             NetworkInterface ifc = en.nextElement();
552             if (ifc.getName().equals (ifname)) {
553                 return deriveNumericScope(holder6.ipaddress, ifc);
554             }
555         }
556         throw new UnknownHostException (&quot;No matching address found for interface : &quot; +ifname);
557     }
558 
559     /**
560      * @serialField ipaddress byte[]
561      * @serialField scope_id int
562      * @serialField scope_id_set boolean
563      * @serialField scope_ifname_set boolean
564      * @serialField ifname String
565      */
<a name="7" id="anc7"></a><span class="line-modified">566     @java.io.Serial</span>
567     private static final ObjectStreamField[] serialPersistentFields = {
568          new ObjectStreamField(&quot;ipaddress&quot;, byte[].class),
569          new ObjectStreamField(&quot;scope_id&quot;, int.class),
570          new ObjectStreamField(&quot;scope_id_set&quot;, boolean.class),
571          new ObjectStreamField(&quot;scope_ifname_set&quot;, boolean.class),
572          new ObjectStreamField(&quot;ifname&quot;, String.class)
573     };
574 
575     private static final jdk.internal.misc.Unsafe UNSAFE
576             = jdk.internal.misc.Unsafe.getUnsafe();
577     private static final long FIELDS_OFFSET = UNSAFE.objectFieldOffset(
578                 Inet6Address.class, &quot;holder6&quot;);
579 
580     /**
581      * restore the state of this object from stream
582      * including the scope information, only if the
583      * scoped interface name is valid on this system
584      */
<a name="8" id="anc8"></a><span class="line-added">585     @java.io.Serial</span>
586     private void readObject(ObjectInputStream s)
587         throws IOException, ClassNotFoundException {
588         NetworkInterface scope_ifname = null;
589 
590         if (getClass().getClassLoader() != null) {
591             throw new SecurityException (&quot;invalid address type&quot;);
592         }
593 
594         ObjectInputStream.GetField gf = s.readFields();
595         byte[] ipaddress = (byte[])gf.get(&quot;ipaddress&quot;, new byte[0]);
596         int scope_id = gf.get(&quot;scope_id&quot;, -1);
597         boolean scope_id_set = gf.get(&quot;scope_id_set&quot;, false);
598         boolean scope_ifname_set = gf.get(&quot;scope_ifname_set&quot;, false);
599         String ifname = (String)gf.get(&quot;ifname&quot;, null);
600 
601         if (ifname != null &amp;&amp; !ifname.isEmpty()) {
602             try {
603                 scope_ifname = NetworkInterface.getByName(ifname);
604                 if (scope_ifname == null) {
605                     /* the interface does not exist on this system, so we clear
606                      * the scope information completely */
607                     scope_id_set = false;
608                     scope_ifname_set = false;
609                     scope_id = 0;
610                 } else {
611                     scope_ifname_set = true;
612                     try {
613                         scope_id = deriveNumericScope (ipaddress, scope_ifname);
614                     } catch (UnknownHostException e) {
615                         // typically should not happen, but it may be that
616                         // the machine being used for deserialization has
617                         // the same interface name but without IPv6 configured.
618                     }
619                 }
620             } catch (SocketException e) {}
621         }
622 
623         /* if ifname was not supplied, then the numeric info is used */
624 
625         ipaddress = ipaddress.clone();
626 
627         // Check that our invariants are satisfied
628         if (ipaddress.length != INADDRSZ) {
629             throw new InvalidObjectException(&quot;invalid address length: &quot;+
630                                              ipaddress.length);
631         }
632 
633         if (holder.getFamily() != IPv6) {
634             throw new InvalidObjectException(&quot;invalid address family type&quot;);
635         }
636 
637         Inet6AddressHolder h = new Inet6AddressHolder(
638             ipaddress, scope_id, scope_id_set, scope_ifname, scope_ifname_set
639         );
640 
641         UNSAFE.putReference(this, FIELDS_OFFSET, h);
642     }
643 
644     /**
645      * default behavior is overridden in order to write the
646      * scope_ifname field as a String, rather than a NetworkInterface
647      * which is not serializable
648      */
<a name="9" id="anc9"></a><span class="line-added">649     @java.io.Serial</span>
650     private synchronized void writeObject(ObjectOutputStream s)
651         throws IOException
652     {
653             String ifname = null;
654 
655         if (holder6.scope_ifname != null) {
656             ifname = holder6.scope_ifname.getName();
657             holder6.scope_ifname_set = true;
658         }
659         ObjectOutputStream.PutField pfields = s.putFields();
660         pfields.put(&quot;ipaddress&quot;, holder6.ipaddress);
661         pfields.put(&quot;scope_id&quot;, holder6.scope_id);
662         pfields.put(&quot;scope_id_set&quot;, holder6.scope_id_set);
663         pfields.put(&quot;scope_ifname_set&quot;, holder6.scope_ifname_set);
664         pfields.put(&quot;ifname&quot;, ifname);
665         s.writeFields();
666     }
667 
668     /**
669      * Utility routine to check if the InetAddress is an IP multicast
670      * address. 11111111 at the start of the address identifies the
671      * address as being a multicast address.
672      *
673      * @return a {@code boolean} indicating if the InetAddress is an IP
674      *         multicast address
675      */
676     @Override
677     public boolean isMulticastAddress() {
678         return holder6.isMulticastAddress();
679     }
680 
681     /**
682      * Utility routine to check if the InetAddress is a wildcard address.
683      *
684      * @return a {@code boolean} indicating if the InetAddress is
685      *         a wildcard address.
686      */
687     @Override
688     public boolean isAnyLocalAddress() {
689         return holder6.isAnyLocalAddress();
690     }
691 
692     /**
693      * Utility routine to check if the InetAddress is a loopback address.
694      *
695      * @return a {@code boolean} indicating if the InetAddress is a loopback
696      *         address; or false otherwise.
697      */
698     @Override
699     public boolean isLoopbackAddress() {
700         return holder6.isLoopbackAddress();
701     }
702 
703     /**
704      * Utility routine to check if the InetAddress is an link local address.
705      *
706      * @return a {@code boolean} indicating if the InetAddress is a link local
707      *         address; or false if address is not a link local unicast address.
708      */
709     @Override
710     public boolean isLinkLocalAddress() {
711         return holder6.isLinkLocalAddress();
712     }
713 
714     /* static version of above */
715     static boolean isLinkLocalAddress(byte[] ipaddress) {
716         return ((ipaddress[0] &amp; 0xff) == 0xfe
717                 &amp;&amp; (ipaddress[1] &amp; 0xc0) == 0x80);
718     }
719 
720     /**
721      * Utility routine to check if the InetAddress is a site local address.
722      *
723      * @return a {@code boolean} indicating if the InetAddress is a site local
724      *         address; or false if address is not a site local unicast address.
725      */
726     @Override
727     public boolean isSiteLocalAddress() {
728         return holder6.isSiteLocalAddress();
729     }
730 
731     /* static version of above */
732     static boolean isSiteLocalAddress(byte[] ipaddress) {
733         return ((ipaddress[0] &amp; 0xff) == 0xfe
734                 &amp;&amp; (ipaddress[1] &amp; 0xc0) == 0xc0);
735     }
736 
737     /**
738      * Utility routine to check if the multicast address has global scope.
739      *
740      * @return a {@code boolean} indicating if the address has is a multicast
741      *         address of global scope, false if it is not of global scope or
742      *         it is not a multicast address
743      */
744     @Override
745     public boolean isMCGlobal() {
746         return holder6.isMCGlobal();
747     }
748 
749     /**
750      * Utility routine to check if the multicast address has node scope.
751      *
752      * @return a {@code boolean} indicating if the address has is a multicast
753      *         address of node-local scope, false if it is not of node-local
754      *         scope or it is not a multicast address
755      */
756     @Override
757     public boolean isMCNodeLocal() {
758         return holder6.isMCNodeLocal();
759     }
760 
761     /**
762      * Utility routine to check if the multicast address has link scope.
763      *
764      * @return a {@code boolean} indicating if the address has is a multicast
765      *         address of link-local scope, false if it is not of link-local
766      *         scope or it is not a multicast address
767      */
768     @Override
769     public boolean isMCLinkLocal() {
770         return holder6.isMCLinkLocal();
771     }
772 
773     /**
774      * Utility routine to check if the multicast address has site scope.
775      *
776      * @return a {@code boolean} indicating if the address has is a multicast
777      *         address of site-local scope, false if it is not  of site-local
778      *         scope or it is not a multicast address
779      */
780     @Override
781     public boolean isMCSiteLocal() {
782         return holder6.isMCSiteLocal();
783     }
784 
785     /**
786      * Utility routine to check if the multicast address has organization scope.
787      *
788      * @return a {@code boolean} indicating if the address has is a multicast
789      *         address of organization-local scope, false if it is not of
790      *         organization-local scope or it is not a multicast address
791      */
792     @Override
793     public boolean isMCOrgLocal() {
794         return holder6.isMCOrgLocal();
795     }
<a name="10" id="anc10"></a><span class="line-added">796 </span>
797     /**
798      * Returns the raw IP address of this {@code InetAddress} object. The result
799      * is in network byte order: the highest order byte of the address is in
800      * {@code getAddress()[0]}.
801      *
802      * @return  the raw IP address of this object.
803      */
804     @Override
805     public byte[] getAddress() {
806         return holder6.ipaddress.clone();
807     }
808 
<a name="11" id="anc11"></a><span class="line-added">809     /**</span>
<span class="line-added">810      * Returns a reference to the byte[] with the IPv6 address.</span>
<span class="line-added">811      */</span>
<span class="line-added">812     byte[] addressBytes() {</span>
<span class="line-added">813         return holder6.ipaddress;</span>
<span class="line-added">814     }</span>
<span class="line-added">815 </span>
816     /**
817      * Returns the numeric scopeId, if this instance is associated with
818      * an interface. If no scoped_id is set, the returned value is zero.
819      *
820      * @return the scopeId, or zero if not set.
821      *
822      * @since 1.5
823      */
824      public int getScopeId() {
<a name="12" id="anc12"></a><span class="line-modified">825          return holder6.scope_id;</span>
826      }
827 
828     /**
829      * Returns the scoped interface, if this instance was created with
830      * a scoped interface.
831      *
832      * @return the scoped interface, or null if not set.
833      * @since 1.5
834      */
835      public NetworkInterface getScopedInterface() {
<a name="13" id="anc13"></a><span class="line-modified">836          return holder6.scope_ifname;</span>
837      }
838 
839     /**
840      * Returns the IP address string in textual presentation. If the instance
841      * was created specifying a scope identifier then the scope id is appended
842      * to the IP address preceded by a &quot;%&quot; (per-cent) character. This can be
843      * either a numeric value or a string, depending on which was used to create
844      * the instance.
845      *
846      * @return  the raw IP address in a string format.
847      */
848     @Override
849     public String getHostAddress() {
850         return holder6.getHostAddress();
851     }
852 
853     /**
854      * Returns a hashcode for this IP address.
855      *
856      * @return  a hash code value for this IP address.
857      */
858     @Override
859     public int hashCode() {
860         return holder6.hashCode();
861     }
862 
863     /**
864      * Compares this object against the specified object. The result is {@code
865      * true} if and only if the argument is not {@code null} and it represents
866      * the same IP address as this object.
867      *
868      * &lt;p&gt; Two instances of {@code InetAddress} represent the same IP address
869      * if the length of the byte arrays returned by {@code getAddress} is the
870      * same for both, and each of the array components is the same for the byte
871      * arrays.
872      *
873      * @param   obj   the object to compare against.
874      *
875      * @return  {@code true} if the objects are the same; {@code false} otherwise.
876      *
877      * @see     java.net.InetAddress#getAddress()
878      */
879     @Override
880     public boolean equals(Object obj) {
881         if (obj == null || !(obj instanceof Inet6Address))
882             return false;
883 
884         Inet6Address inetAddr = (Inet6Address)obj;
885 
886         return holder6.equals(inetAddr.holder6);
887     }
888 
889     /**
890      * Utility routine to check if the InetAddress is an
891      * IPv4 compatible IPv6 address.
892      *
893      * @return a {@code boolean} indicating if the InetAddress is an IPv4
894      *         compatible IPv6 address; or false if address is IPv4 address.
895      */
896     public boolean isIPv4CompatibleAddress() {
897         return holder6.isIPv4CompatibleAddress();
898     }
899 
900     // Utilities
901 
902     private static final int INT16SZ = 2;
903 
904     /**
905      * Convert IPv6 binary address into presentation (printable) format.
906      *
907      * @param src a byte array representing the IPv6 numeric address
908      * @return a String representing an IPv6 address in
909      *         textual representation format
910      */
911     static String numericToTextFormat(byte[] src) {
912         StringBuilder sb = new StringBuilder(39);
913         for (int i = 0; i &lt; (INADDRSZ / INT16SZ); i++) {
914             sb.append(Integer.toHexString(((src[i&lt;&lt;1]&lt;&lt;8) &amp; 0xff00)
915                                           | (src[(i&lt;&lt;1)+1] &amp; 0xff)));
916             if (i &lt; (INADDRSZ / INT16SZ) -1 ) {
917                sb.append(&quot;:&quot;);
918             }
919         }
920         return sb.toString();
921     }
922 
923     /**
924      * Perform class load-time initializations.
925      */
926     private static native void init();
927 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
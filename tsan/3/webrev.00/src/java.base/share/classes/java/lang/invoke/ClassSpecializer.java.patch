diff a/src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java b/src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java
--- a/src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java
+++ b/src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,10 +23,11 @@
  * questions.
  */
 
 package java.lang.invoke;
 
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.loader.BootLoader;
 import jdk.internal.org.objectweb.asm.ClassWriter;
 import jdk.internal.org.objectweb.asm.FieldVisitor;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.vm.annotation.Stable;
@@ -35,10 +36,11 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
@@ -454,10 +456,15 @@
     /**
      * Code generation support for instances.
      * Subclasses can modify the behavior.
      */
     public class Factory {
+        /**
+         * Constructs a factory.
+         */
+        Factory() {}
+
         /**
          * Get a concrete subclass of the top class for a given combination of bound types.
          *
          * @param speciesData the species requiring the class, not yet linked
          * @return a linked version of the same species
@@ -535,35 +542,37 @@
          *
          * For example, a concrete species for two references and one integral bound value
          * has a shape like the following:
          *
          * <pre>
-         * class TopClass { ... private static
-         * final class Species_LLI extends TopClass {
-         *     final Object argL0;
-         *     final Object argL1;
-         *     final int argI2;
-         *     private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {
-         *         super(ctarg, ...);
-         *         this.argL0 = argL0;
-         *         this.argL1 = argL1;
-         *         this.argI2 = argI2;
-         *     }
-         *     final SpeciesData speciesData() { return BMH_SPECIES; }
-         *     &#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards
-         *     static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {
-         *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);
-         *     }
-         *     final TopClass copyWith(CT ctarg, ...) {
-         *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);
-         *     }
-         *     // two transforms, for the sake of illustration:
-         *     final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {
-         *         return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);
-         *     }
-         *     final TopClass copyWithExtendI(CT ctarg, ..., int narg) {
-         *         return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);
+         * class TopClass {
+         *     ...
+         *     private static final class Species_LLI extends TopClass {
+         *         final Object argL0;
+         *         final Object argL1;
+         *         final int argI2;
+         *         private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {
+         *             super(ctarg, ...);
+         *             this.argL0 = argL0;
+         *             this.argL1 = argL1;
+         *             this.argI2 = argI2;
+         *         }
+         *         final SpeciesData speciesData() { return BMH_SPECIES; }
+         *         &#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards
+         *         static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {
+         *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);
+         *         }
+         *         final TopClass copyWith(CT ctarg, ...) {
+         *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);
+         *         }
+         *         // two transforms, for the sake of illustration:
+         *         final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {
+         *             return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);
+         *         }
+         *         final TopClass copyWithExtendI(CT ctarg, ..., int narg) {
+         *             return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);
+         *         }
          *     }
          * }
          * </pre>
          *
          * @param className of the species
@@ -573,23 +582,23 @@
         Class<? extends T> generateConcreteSpeciesCode(String className, ClassSpecializer<T,K,S>.SpeciesData speciesData) {
             byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
 
             // load class
             InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
-            Class<?> speciesCode;
-
-            MethodHandles.Lookup lookup = IMPL_LOOKUP.in(topClass());
-            speciesCode = AccessController.doPrivileged(new PrivilegedAction<>() {
-                @Override
-                public Class<?> run() {
-                    try {
-                        return lookup.defineClass(classFile);
-                    } catch (Exception ex) {
-                        throw newInternalError(ex);
-                    }
-                }
-            });
+            ClassLoader cl = topClass.getClassLoader();
+            ProtectionDomain pd = null;
+            if (cl != null) {
+                pd = AccessController.doPrivileged(
+                        new PrivilegedAction<>() {
+                            @Override
+                            public ProtectionDomain run() {
+                                return topClass().getProtectionDomain();
+                            }
+                        });
+            }
+            Class<?> speciesCode = SharedSecrets.getJavaLangAccess()
+                    .defineClass(cl, className, classFile, pd, "_ClassSpecializer_generateConcreteSpeciesCode");
             return speciesCode.asSubclass(topClass());
         }
 
         // These are named like constants because there is only one per specialization scheme:
         private final String SPECIES_DATA = classBCName(metaType);
@@ -615,11 +624,12 @@
             TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
             TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
         }
         private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
 
-        /*non-public*/ byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer<T,K,S>.SpeciesData speciesData) {
+        /*non-public*/
+        byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer<T,K,S>.SpeciesData speciesData) {
             final String className = classBCName(className0);
             final String superClassName = classBCName(speciesData.deriveSuperClass());
 
             final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
             final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/nio/channels/FileChannel.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramChannel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReadableByteChannel.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/channels/FileChannel.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 702      * starting at the given file position.
 703      *
 704      * &lt;p&gt; This method works in the same manner as the {@link
 705      * #read(ByteBuffer)} method, except that bytes are read starting at the
 706      * given file position rather than at the channel&#39;s current position.  This
 707      * method does not modify this channel&#39;s position.  If the given position
 708      * is greater than the file&#39;s current size then no bytes are read.  &lt;/p&gt;
 709      *
 710      * @param  dst
 711      *         The buffer into which bytes are to be transferred
 712      *
 713      * @param  position
 714      *         The file position at which the transfer is to begin;
 715      *         must be non-negative
 716      *
 717      * @return  The number of bytes read, possibly zero, or {@code -1} if the
 718      *          given position is greater than or equal to the file&#39;s current
 719      *          size
 720      *
 721      * @throws  IllegalArgumentException
<span class="line-modified"> 722      *          If the position is negative</span>
 723      *
 724      * @throws  NonReadableChannelException
 725      *          If this channel was not opened for reading
 726      *
 727      * @throws  ClosedChannelException
 728      *          If this channel is closed
 729      *
 730      * @throws  AsynchronousCloseException
 731      *          If another thread closes this channel
 732      *          while the read operation is in progress
 733      *
 734      * @throws  ClosedByInterruptException
 735      *          If another thread interrupts the current thread
 736      *          while the read operation is in progress, thereby
 737      *          closing the channel and setting the current thread&#39;s
 738      *          interrupt status
 739      *
 740      * @throws  IOException
 741      *          If some other I/O error occurs
 742      */
</pre>
<hr />
<pre>
 774      *
 775      * @throws  AsynchronousCloseException
 776      *          If another thread closes this channel
 777      *          while the write operation is in progress
 778      *
 779      * @throws  ClosedByInterruptException
 780      *          If another thread interrupts the current thread
 781      *          while the write operation is in progress, thereby
 782      *          closing the channel and setting the current thread&#39;s
 783      *          interrupt status
 784      *
 785      * @throws  IOException
 786      *          If some other I/O error occurs
 787      */
 788     public abstract int write(ByteBuffer src, long position) throws IOException;
 789 
 790 
 791     // -- Memory-mapped buffers --
 792 
 793     /**
<span class="line-modified"> 794      * A typesafe enumeration for file-mapping modes.</span>
 795      *
 796      * @since 1.4
 797      *
 798      * @see java.nio.channels.FileChannel#map
 799      */
 800     public static class MapMode {
 801 
 802         /**
 803          * Mode for a read-only mapping.
 804          */
 805         public static final MapMode READ_ONLY
 806             = new MapMode(&quot;READ_ONLY&quot;);
 807 
 808         /**
 809          * Mode for a read/write mapping.
 810          */
 811         public static final MapMode READ_WRITE
 812             = new MapMode(&quot;READ_WRITE&quot;);
 813 
 814         /**
 815          * Mode for a private (copy-on-write) mapping.
 816          */
 817         public static final MapMode PRIVATE
 818             = new MapMode(&quot;PRIVATE&quot;);
 819 
 820         private final String name;
 821 






 822         private MapMode(String name) {
 823             this.name = name;
 824         }
 825 
 826         /**
 827          * Returns a string describing this file-mapping mode.
 828          *
 829          * @return  A descriptive string
 830          */
 831         public String toString() {
 832             return name;
 833         }
 834 
 835     }
 836 
 837     /**
 838      * Maps a region of this channel&#39;s file directly into memory.
 839      *
<span class="line-modified"> 840      * &lt;p&gt; A region of a file may be mapped into memory in one of three modes:</span>
<span class="line-modified"> 841      * &lt;/p&gt;</span>
 842      *
 843      * &lt;ul&gt;
 844      *
 845      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read-only:&lt;/i&gt; Any attempt to modify the resulting buffer
 846      *   will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.
 847      *   ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) &lt;/p&gt;&lt;/li&gt;
 848      *
 849      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read/write:&lt;/i&gt; Changes made to the resulting buffer will
 850      *   eventually be propagated to the file; they may or may not be made
 851      *   visible to other programs that have mapped the same file.  ({@link
 852      *   MapMode#READ_WRITE MapMode.READ_WRITE}) &lt;/p&gt;&lt;/li&gt;
 853      *
 854      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Private:&lt;/i&gt; Changes made to the resulting buffer will not
 855      *   be propagated to the file and will not be visible to other programs
 856      *   that have mapped the same file; instead, they will cause private
 857      *   copies of the modified portions of the buffer to be created.  ({@link
 858      *   MapMode#PRIVATE MapMode.PRIVATE}) &lt;/p&gt;&lt;/li&gt;
 859      *
 860      * &lt;/ul&gt;
 861      *


 862      * &lt;p&gt; For a read-only mapping, this channel must have been opened for
 863      * reading; for a read/write or private mapping, this channel must have
 864      * been opened for both reading and writing.
 865      *
 866      * &lt;p&gt; The {@link MappedByteBuffer &lt;i&gt;mapped byte buffer&lt;/i&gt;}
 867      * returned by this method will have a position of zero and a limit and
 868      * capacity of {@code size}; its mark will be undefined.  The buffer and
 869      * the mapping that it represents will remain valid until the buffer itself
 870      * is garbage-collected.
 871      *
 872      * &lt;p&gt; A mapping, once established, is not dependent upon the file channel
 873      * that was used to create it.  Closing the channel, in particular, has no
 874      * effect upon the validity of the mapping.
 875      *
 876      * &lt;p&gt; Many of the details of memory-mapped files are inherently dependent
 877      * upon the underlying operating system and are therefore unspecified.  The
 878      * behavior of this method when the requested region is not completely
 879      * contained within this channel&#39;s file is unspecified.  Whether changes
 880      * made to the content or size of the underlying file, by this program or
 881      * another, are propagated to the buffer is unspecified.  The rate at which
 882      * changes to the buffer are propagated to the file is unspecified.
 883      *
 884      * &lt;p&gt; For most operating systems, mapping a file into memory is more
 885      * expensive than reading or writing a few tens of kilobytes of data via
 886      * the usual {@link #read read} and {@link #write write} methods.  From the
 887      * standpoint of performance it is generally only worth mapping relatively
 888      * large files into memory.  &lt;/p&gt;
 889      *
 890      * @param  mode
 891      *         One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link
 892      *         MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE
 893      *         PRIVATE} defined in the {@link MapMode} class, according to
 894      *         whether the file is to be mapped read-only, read/write, or
<span class="line-modified"> 895      *         privately (copy-on-write), respectively</span>

 896      *
 897      * @param  position
 898      *         The position within the file at which the mapped region
 899      *         is to start; must be non-negative
 900      *
 901      * @param  size
 902      *         The size of the region to be mapped; must be non-negative and
 903      *         no greater than {@link java.lang.Integer#MAX_VALUE}
 904      *
 905      * @return  The mapped byte buffer
 906      *
 907      * @throws NonReadableChannelException
<span class="line-modified"> 908      *         If the {@code mode} is {@link MapMode#READ_ONLY READ_ONLY} but</span>
<span class="line-modified"> 909      *         this channel was not opened for reading</span>

 910      *
 911      * @throws NonWritableChannelException
<span class="line-modified"> 912      *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE} or</span>
<span class="line-modified"> 913      *         {@link MapMode#PRIVATE PRIVATE} but this channel was not opened</span>
<span class="line-modified"> 914      *         for both reading and writing</span>

 915      *
 916      * @throws IllegalArgumentException
 917      *         If the preconditions on the parameters do not hold
 918      *



 919      * @throws IOException
 920      *         If some other I/O error occurs
 921      *
 922      * @see java.nio.channels.FileChannel.MapMode
 923      * @see java.nio.MappedByteBuffer
 924      */
<span class="line-modified"> 925     public abstract MappedByteBuffer map(MapMode mode,</span>
<span class="line-removed"> 926                                          long position, long size)</span>
 927         throws IOException;
 928 
 929 
 930     // -- Locks --
 931 
 932     /**
 933      * Acquires a lock on the given region of this channel&#39;s file.
 934      *
 935      * &lt;p&gt; An invocation of this method will block until the region can be
 936      * locked, this channel is closed, or the invoking thread is interrupted,
 937      * whichever comes first.
 938      *
 939      * &lt;p&gt; If this channel is closed by another thread during an invocation of
 940      * this method then an {@link AsynchronousCloseException} will be thrown.
 941      *
 942      * &lt;p&gt; If the invoking thread is interrupted while waiting to acquire the
 943      * lock then its interrupt status will be set and a {@link
 944      * FileLockInterruptionException} will be thrown.  If the invoker&#39;s
 945      * interrupt status is set when this method is invoked then that exception
 946      * will be thrown immediately; the thread&#39;s interrupt status will not be
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 702      * starting at the given file position.
 703      *
 704      * &lt;p&gt; This method works in the same manner as the {@link
 705      * #read(ByteBuffer)} method, except that bytes are read starting at the
 706      * given file position rather than at the channel&#39;s current position.  This
 707      * method does not modify this channel&#39;s position.  If the given position
 708      * is greater than the file&#39;s current size then no bytes are read.  &lt;/p&gt;
 709      *
 710      * @param  dst
 711      *         The buffer into which bytes are to be transferred
 712      *
 713      * @param  position
 714      *         The file position at which the transfer is to begin;
 715      *         must be non-negative
 716      *
 717      * @return  The number of bytes read, possibly zero, or {@code -1} if the
 718      *          given position is greater than or equal to the file&#39;s current
 719      *          size
 720      *
 721      * @throws  IllegalArgumentException
<span class="line-modified"> 722      *          If the position is negative or the buffer is read-only</span>
 723      *
 724      * @throws  NonReadableChannelException
 725      *          If this channel was not opened for reading
 726      *
 727      * @throws  ClosedChannelException
 728      *          If this channel is closed
 729      *
 730      * @throws  AsynchronousCloseException
 731      *          If another thread closes this channel
 732      *          while the read operation is in progress
 733      *
 734      * @throws  ClosedByInterruptException
 735      *          If another thread interrupts the current thread
 736      *          while the read operation is in progress, thereby
 737      *          closing the channel and setting the current thread&#39;s
 738      *          interrupt status
 739      *
 740      * @throws  IOException
 741      *          If some other I/O error occurs
 742      */
</pre>
<hr />
<pre>
 774      *
 775      * @throws  AsynchronousCloseException
 776      *          If another thread closes this channel
 777      *          while the write operation is in progress
 778      *
 779      * @throws  ClosedByInterruptException
 780      *          If another thread interrupts the current thread
 781      *          while the write operation is in progress, thereby
 782      *          closing the channel and setting the current thread&#39;s
 783      *          interrupt status
 784      *
 785      * @throws  IOException
 786      *          If some other I/O error occurs
 787      */
 788     public abstract int write(ByteBuffer src, long position) throws IOException;
 789 
 790 
 791     // -- Memory-mapped buffers --
 792 
 793     /**
<span class="line-modified"> 794      * A file-mapping mode.</span>
 795      *
 796      * @since 1.4
 797      *
 798      * @see java.nio.channels.FileChannel#map
 799      */
 800     public static class MapMode {
 801 
 802         /**
 803          * Mode for a read-only mapping.
 804          */
 805         public static final MapMode READ_ONLY
 806             = new MapMode(&quot;READ_ONLY&quot;);
 807 
 808         /**
 809          * Mode for a read/write mapping.
 810          */
 811         public static final MapMode READ_WRITE
 812             = new MapMode(&quot;READ_WRITE&quot;);
 813 
 814         /**
 815          * Mode for a private (copy-on-write) mapping.
 816          */
 817         public static final MapMode PRIVATE
 818             = new MapMode(&quot;PRIVATE&quot;);
 819 
 820         private final String name;
 821 
<span class="line-added"> 822         /**</span>
<span class="line-added"> 823          * Constructs an instance of this class. This constructor may be used</span>
<span class="line-added"> 824          * by code in java.base to create file mapping modes beyond the file</span>
<span class="line-added"> 825          * mapping modes defined here.</span>
<span class="line-added"> 826          * @param name the name of the map mode</span>
<span class="line-added"> 827          */</span>
 828         private MapMode(String name) {
 829             this.name = name;
 830         }
 831 
 832         /**
 833          * Returns a string describing this file-mapping mode.
 834          *
 835          * @return  A descriptive string
 836          */
 837         public String toString() {
 838             return name;
 839         }
 840 
 841     }
 842 
 843     /**
 844      * Maps a region of this channel&#39;s file directly into memory.
 845      *
<span class="line-modified"> 846      * &lt;p&gt; The {@code mode} parameter specifies how the region of the file is</span>
<span class="line-modified"> 847      * mapped and may be one of the following modes:</span>
 848      *
 849      * &lt;ul&gt;
 850      *
 851      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read-only:&lt;/i&gt; Any attempt to modify the resulting buffer
 852      *   will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.
 853      *   ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) &lt;/p&gt;&lt;/li&gt;
 854      *
 855      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Read/write:&lt;/i&gt; Changes made to the resulting buffer will
 856      *   eventually be propagated to the file; they may or may not be made
 857      *   visible to other programs that have mapped the same file.  ({@link
 858      *   MapMode#READ_WRITE MapMode.READ_WRITE}) &lt;/p&gt;&lt;/li&gt;
 859      *
 860      *   &lt;li&gt;&lt;p&gt; &lt;i&gt;Private:&lt;/i&gt; Changes made to the resulting buffer will not
 861      *   be propagated to the file and will not be visible to other programs
 862      *   that have mapped the same file; instead, they will cause private
 863      *   copies of the modified portions of the buffer to be created.  ({@link
 864      *   MapMode#PRIVATE MapMode.PRIVATE}) &lt;/p&gt;&lt;/li&gt;
 865      *
 866      * &lt;/ul&gt;
 867      *
<span class="line-added"> 868      * &lt;p&gt; An implementation may support additional map modes.</span>
<span class="line-added"> 869      *</span>
 870      * &lt;p&gt; For a read-only mapping, this channel must have been opened for
 871      * reading; for a read/write or private mapping, this channel must have
 872      * been opened for both reading and writing.
 873      *
 874      * &lt;p&gt; The {@link MappedByteBuffer &lt;i&gt;mapped byte buffer&lt;/i&gt;}
 875      * returned by this method will have a position of zero and a limit and
 876      * capacity of {@code size}; its mark will be undefined.  The buffer and
 877      * the mapping that it represents will remain valid until the buffer itself
 878      * is garbage-collected.
 879      *
 880      * &lt;p&gt; A mapping, once established, is not dependent upon the file channel
 881      * that was used to create it.  Closing the channel, in particular, has no
 882      * effect upon the validity of the mapping.
 883      *
 884      * &lt;p&gt; Many of the details of memory-mapped files are inherently dependent
 885      * upon the underlying operating system and are therefore unspecified.  The
 886      * behavior of this method when the requested region is not completely
 887      * contained within this channel&#39;s file is unspecified.  Whether changes
 888      * made to the content or size of the underlying file, by this program or
 889      * another, are propagated to the buffer is unspecified.  The rate at which
 890      * changes to the buffer are propagated to the file is unspecified.
 891      *
 892      * &lt;p&gt; For most operating systems, mapping a file into memory is more
 893      * expensive than reading or writing a few tens of kilobytes of data via
 894      * the usual {@link #read read} and {@link #write write} methods.  From the
 895      * standpoint of performance it is generally only worth mapping relatively
 896      * large files into memory.  &lt;/p&gt;
 897      *
 898      * @param  mode
 899      *         One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link
 900      *         MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE
 901      *         PRIVATE} defined in the {@link MapMode} class, according to
 902      *         whether the file is to be mapped read-only, read/write, or
<span class="line-modified"> 903      *         privately (copy-on-write), respectively, or an implementation</span>
<span class="line-added"> 904      *         specific map mode</span>
 905      *
 906      * @param  position
 907      *         The position within the file at which the mapped region
 908      *         is to start; must be non-negative
 909      *
 910      * @param  size
 911      *         The size of the region to be mapped; must be non-negative and
 912      *         no greater than {@link java.lang.Integer#MAX_VALUE}
 913      *
 914      * @return  The mapped byte buffer
 915      *
 916      * @throws NonReadableChannelException
<span class="line-modified"> 917      *         If the {@code mode} is {@link MapMode#READ_ONLY READ_ONLY} or</span>
<span class="line-modified"> 918      *         an implementation specific map mode requiring read access</span>
<span class="line-added"> 919      *         but this channel was not opened for reading</span>
 920      *
 921      * @throws NonWritableChannelException
<span class="line-modified"> 922      *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE}.</span>
<span class="line-modified"> 923      *         {@link MapMode#PRIVATE PRIVATE} or an implementation specific</span>
<span class="line-modified"> 924      *         map mode requiring write access but this channel was not</span>
<span class="line-added"> 925      *         opened for both reading and writing</span>
 926      *
 927      * @throws IllegalArgumentException
 928      *         If the preconditions on the parameters do not hold
 929      *
<span class="line-added"> 930      * @throws UnsupportedOperationException</span>
<span class="line-added"> 931      *         If an unsupported map mode is specified</span>
<span class="line-added"> 932      *</span>
 933      * @throws IOException
 934      *         If some other I/O error occurs
 935      *
 936      * @see java.nio.channels.FileChannel.MapMode
 937      * @see java.nio.MappedByteBuffer
 938      */
<span class="line-modified"> 939     public abstract MappedByteBuffer map(MapMode mode, long position, long size)</span>

 940         throws IOException;
 941 
 942 
 943     // -- Locks --
 944 
 945     /**
 946      * Acquires a lock on the given region of this channel&#39;s file.
 947      *
 948      * &lt;p&gt; An invocation of this method will block until the region can be
 949      * locked, this channel is closed, or the invoking thread is interrupted,
 950      * whichever comes first.
 951      *
 952      * &lt;p&gt; If this channel is closed by another thread during an invocation of
 953      * this method then an {@link AsynchronousCloseException} will be thrown.
 954      *
 955      * &lt;p&gt; If the invoking thread is interrupted while waiting to acquire the
 956      * lock then its interrupt status will be set and a {@link
 957      * FileLockInterruptionException} will be thrown.  If the invoker&#39;s
 958      * interrupt status is set when this method is invoked then that exception
 959      * will be thrown immediately; the thread&#39;s interrupt status will not be
</pre>
</td>
</tr>
</table>
<center><a href="DatagramChannel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReadableByteChannel.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
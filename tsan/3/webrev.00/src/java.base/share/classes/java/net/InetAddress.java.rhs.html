<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/InetAddress.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.util.NavigableSet;
  29 import java.util.ArrayList;
  30 import java.util.Objects;
  31 import java.util.Scanner;
  32 import java.security.AccessController;
  33 import java.io.File;
<a name="1" id="anc1"></a>
  34 import java.io.ObjectStreamException;
  35 import java.io.ObjectStreamField;
  36 import java.io.IOException;
  37 import java.io.InvalidObjectException;
  38 import java.io.ObjectInputStream;
  39 import java.io.ObjectInputStream.GetField;
  40 import java.io.ObjectOutputStream;
  41 import java.io.ObjectOutputStream.PutField;
  42 import java.lang.annotation.Native;
  43 import java.util.concurrent.ConcurrentHashMap;
  44 import java.util.concurrent.ConcurrentMap;
  45 import java.util.concurrent.ConcurrentSkipListSet;
  46 import java.util.concurrent.atomic.AtomicLong;
<a name="2" id="anc2"></a><span class="line-added">  47 import java.util.Arrays;</span>
  48 
  49 import jdk.internal.access.JavaNetInetAddressAccess;
  50 import jdk.internal.access.SharedSecrets;
  51 import sun.security.action.*;
  52 import sun.net.InetAddressCachePolicy;
  53 import sun.net.util.IPAddressUtil;
<a name="3" id="anc3"></a><span class="line-added">  54 import sun.nio.cs.UTF_8;</span>
  55 
  56 /**
  57  * This class represents an Internet Protocol (IP) address.
  58  *
  59  * &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
  60  * used by IP, a lower-level protocol on which protocols like UDP and
  61  * TCP are built. The IP address architecture is defined by &lt;a
  62  * href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;790:
  63  * Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
  64  * href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;1918:
  65  * Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
  66  * href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
  67  * Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
  68  * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
  69  * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
  70  * InetAddress consists of an IP address and possibly its
  71  * corresponding host name (depending on whether it is constructed
  72  * with a host name or whether it has already done reverse host name
  73  * resolution).
  74  *
<a name="4" id="anc4"></a><span class="line-modified">  75  * &lt;h2&gt; Address types &lt;/h2&gt;</span>
  76  *
  77  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
  78  *   &lt;caption style=&quot;display:none&quot;&gt;Description of unicast and multicast address types&lt;/caption&gt;
  79  *   &lt;thead&gt;
  80  *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Address Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
  81  *   &lt;/thead&gt;
  82  *   &lt;tbody&gt;
  83  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;unicast&lt;/th&gt;
  84  *       &lt;td&gt;An identifier for a single interface. A packet sent to
  85  *         a unicast address is delivered to the interface identified by
  86  *         that address.
  87  *
  88  *         &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
  89  *         address. It must never be assigned to any node. It indicates the
  90  *         absence of an address. One example of its use is as the target of
  91  *         bind, which allows a server to accept a client connection on any
  92  *         interface, in case the server host has multiple interfaces.
  93  *
  94  *         &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
  95  *         the destination address of an IP packet.
  96  *
  97  *         &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
  98  *         assigned to the loopback interface. Anything sent to this
  99  *         IP address loops around and becomes IP input on the local
 100  *         host. This address is often used when testing a
 101  *         client.&lt;/td&gt;&lt;/tr&gt;
 102  *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;multicast&lt;/th&gt;
 103  *       &lt;td&gt;An identifier for a set of interfaces (typically belonging
 104  *         to different nodes). A packet sent to a multicast address is
 105  *         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
 106  * &lt;/tbody&gt;
 107  * &lt;/table&gt;
 108  *
<a name="5" id="anc5"></a><span class="line-modified"> 109  * &lt;h3&gt; IP address scope &lt;/h3&gt;</span>
 110  *
 111  * &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
 112  * on a single link for purposes such as auto-address configuration,
 113  * neighbor discovery, or when no routers are present.
 114  *
 115  * &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
 116  * inside of a site without the need for a global prefix.
 117  *
 118  * &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.
 119  *
<a name="6" id="anc6"></a><span class="line-modified"> 120  * &lt;h3&gt; Textual representation of IP addresses &lt;/h3&gt;</span>
 121  *
 122  * The textual representation of an IP address is address family specific.
 123  *
 124  * &lt;p&gt;
 125  *
 126  * For IPv4 address format, please refer to &lt;A
 127  * HREF=&quot;Inet4Address.html#format&quot;&gt;Inet4Address#format&lt;/A&gt;; For IPv6
 128  * address format, please refer to &lt;A
 129  * HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.
 130  *
 131  * &lt;P&gt;There is a &lt;a href=&quot;doc-files/net-properties.html#Ipv4IPv6&quot;&gt;couple of
 132  * System Properties&lt;/a&gt; affecting how IPv4 and IPv6 addresses are used.&lt;/P&gt;
 133  *
<a name="7" id="anc7"></a><span class="line-modified"> 134  * &lt;h3&gt; Host Name Resolution &lt;/h3&gt;</span>
 135  *
 136  * Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
 137  * the use of a combination of local machine configuration information
 138  * and network naming services such as the Domain Name System (DNS)
 139  * and Network Information Service(NIS). The particular naming
 140  * services(s) being used is by default the local machine configured
 141  * one. For any host name, its corresponding IP address is returned.
 142  *
 143  * &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
 144  * the host associated with the IP address is returned.
 145  *
 146  * &lt;p&gt; The InetAddress class provides methods to resolve host names to
 147  * their IP addresses and vice versa.
 148  *
<a name="8" id="anc8"></a><span class="line-modified"> 149  * &lt;h3&gt; InetAddress Caching &lt;/h3&gt;</span>
 150  *
 151  * The InetAddress class has a cache to store successful as well as
 152  * unsuccessful host name resolutions.
 153  *
 154  * &lt;p&gt; By default, when a security manager is installed, in order to
 155  * protect against DNS spoofing attacks,
 156  * the result of positive host name resolutions are
 157  * cached forever. When a security manager is not installed, the default
 158  * behavior is to cache entries for a finite (implementation dependent)
 159  * period of time. The result of unsuccessful host
 160  * name resolution is cached for a very short period of time (10
 161  * seconds) to improve performance.
 162  *
 163  * &lt;p&gt; If the default behavior is not desired, then a Java security property
 164  * can be set to a different Time-to-live (TTL) value for positive
 165  * caching. Likewise, a system admin can configure a different
 166  * negative caching TTL value when needed.
 167  *
 168  * &lt;p&gt; Two Java security properties control the TTL values used for
 169  *  positive and negative host name resolution caching:
 170  *
 171  * &lt;dl style=&quot;margin-left:2em&quot;&gt;
 172  * &lt;dt&gt;&lt;b&gt;networkaddress.cache.ttl&lt;/b&gt;&lt;/dt&gt;
 173  * &lt;dd&gt;Indicates the caching policy for successful name lookups from
 174  * the name service. The value is specified as an integer to indicate
 175  * the number of seconds to cache the successful lookup. The default
 176  * setting is to cache for an implementation specific period of time.
 177  * &lt;p&gt;
 178  * A value of -1 indicates &quot;cache forever&quot;.
 179  * &lt;/dd&gt;
 180  * &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
 181  * &lt;dd&gt;Indicates the caching policy for un-successful name lookups
 182  * from the name service. The value is specified as an integer to
 183  * indicate the number of seconds to cache the failure for
 184  * un-successful lookups.
 185  * &lt;p&gt;
 186  * A value of 0 indicates &quot;never cache&quot;.
 187  * A value of -1 indicates &quot;cache forever&quot;.
 188  * &lt;/dd&gt;
 189  * &lt;/dl&gt;
 190  *
 191  * @author  Chris Warth
 192  * @see     java.net.InetAddress#getByAddress(byte[])
 193  * @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])
 194  * @see     java.net.InetAddress#getAllByName(java.lang.String)
 195  * @see     java.net.InetAddress#getByName(java.lang.String)
 196  * @see     java.net.InetAddress#getLocalHost()
 197  * @since 1.0
 198  */
<a name="9" id="anc9"></a><span class="line-modified"> 199 public class InetAddress implements java.io.Serializable {</span>

 200 
 201     @Native static final int PREFER_IPV4_VALUE = 0;
 202     @Native static final int PREFER_IPV6_VALUE = 1;
 203     @Native static final int PREFER_SYSTEM_VALUE = 2;
 204 
 205     /**
 206      * Specify the address family: Internet Protocol, Version 4
 207      * @since 1.4
 208      */
 209     @Native static final int IPv4 = 1;
 210 
 211     /**
 212      * Specify the address family: Internet Protocol, Version 6
 213      * @since 1.4
 214      */
 215     @Native static final int IPv6 = 2;
 216 
 217     /* Specify address family preference */
 218     static transient final int preferIPv6Address;
 219 
 220     static class InetAddressHolder {
 221         /**
 222          * Reserve the original application specified hostname.
 223          *
 224          * The original hostname is useful for domain-based endpoint
 225          * identification (see RFC 2818 and RFC 6125).  If an address
 226          * was created with a raw IP address, a reverse name lookup
 227          * may introduce endpoint identification security issue via
 228          * DNS forging.
 229          *
 230          * Oracle JSSE provider is using this original hostname, via
 231          * jdk.internal.misc.JavaNetAccess, for SSL/TLS endpoint identification.
 232          *
 233          * Note: May define a new public method in the future if necessary.
 234          */
 235         String originalHostName;
 236 
 237         InetAddressHolder() {}
 238 
 239         InetAddressHolder(String hostName, int address, int family) {
 240             this.originalHostName = hostName;
 241             this.hostName = hostName;
 242             this.address = address;
 243             this.family = family;
 244         }
 245 
 246         void init(String hostName, int family) {
 247             this.originalHostName = hostName;
 248             this.hostName = hostName;
 249             if (family != -1) {
 250                 this.family = family;
 251             }
 252         }
 253 
 254         String hostName;
 255 
 256         String getHostName() {
 257             return hostName;
 258         }
 259 
 260         String getOriginalHostName() {
 261             return originalHostName;
 262         }
 263 
 264         /**
 265          * Holds a 32-bit IPv4 address.
 266          */
 267         int address;
 268 
 269         int getAddress() {
 270             return address;
 271         }
 272 
 273         /**
 274          * Specifies the address family type, for instance, &#39;1&#39; for IPv4
 275          * addresses, and &#39;2&#39; for IPv6 addresses.
 276          */
 277         int family;
 278 
 279         int getFamily() {
 280             return family;
 281         }
 282     }
 283 
 284     /* Used to store the serializable fields of InetAddress */
 285     final transient InetAddressHolder holder;
 286 
 287     InetAddressHolder holder() {
 288         return holder;
 289     }
 290 
 291     /* Used to store the name service provider */
<a name="10" id="anc10"></a><span class="line-modified"> 292     private static transient NameService nameService;</span>
 293 
 294     /**
 295      * Used to store the best available hostname.
 296      * Lazily initialized via a data race; safe because Strings are immutable.
 297      */
 298     private transient String canonicalHostName = null;
 299 
 300     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<a name="11" id="anc11"></a><span class="line-added"> 301     @java.io.Serial</span>
 302     private static final long serialVersionUID = 3286316764910316507L;
 303 
 304     /*
 305      * Load net library into runtime, and perform initializations.
 306      */
 307     static {
<a name="12" id="anc12"></a><span class="line-modified"> 308         String str = GetPropertyAction.privilegedGetProperty(&quot;java.net.preferIPv6Addresses&quot;);</span>

 309         if (str == null) {
 310             preferIPv6Address = PREFER_IPV4_VALUE;
 311         } else if (str.equalsIgnoreCase(&quot;true&quot;)) {
 312             preferIPv6Address = PREFER_IPV6_VALUE;
 313         } else if (str.equalsIgnoreCase(&quot;false&quot;)) {
 314             preferIPv6Address = PREFER_IPV4_VALUE;
 315         } else if (str.equalsIgnoreCase(&quot;system&quot;)) {
 316             preferIPv6Address = PREFER_SYSTEM_VALUE;
 317         } else {
 318             preferIPv6Address = PREFER_IPV4_VALUE;
 319         }
<a name="13" id="anc13"></a><span class="line-modified"> 320         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 321         SharedSecrets.setJavaNetInetAddressAccess(
 322                 new JavaNetInetAddressAccess() {
 323                     public String getOriginalHostName(InetAddress ia) {
 324                         return ia.holder.getOriginalHostName();
 325                     }
 326 
 327                     public InetAddress getByName(String hostName,
 328                                                  InetAddress hostAddress)
<a name="14" id="anc14"></a><span class="line-modified"> 329                         throws UnknownHostException</span>
 330                     {
 331                         return InetAddress.getByName(hostName, hostAddress);
 332                     }
<a name="15" id="anc15"></a><span class="line-added"> 333 </span>
<span class="line-added"> 334                     public int addressValue(Inet4Address inet4Address) {</span>
<span class="line-added"> 335                         return inet4Address.addressValue();</span>
<span class="line-added"> 336                     }</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338                     public byte[] addressBytes(Inet6Address inet6Address) {</span>
<span class="line-added"> 339                         return inet6Address.addressBytes();</span>
<span class="line-added"> 340                     }</span>
 341                 }
 342         );
 343         init();
 344     }
 345 
 346     /**
 347      * Constructor for the Socket.accept() method.
 348      * This creates an empty InetAddress, which is filled in by
 349      * the accept() method.  This InetAddress, however, is not
 350      * put in the address cache, since it is not created by name.
 351      */
 352     InetAddress() {
 353         holder = new InetAddressHolder();
 354     }
 355 
 356     /**
 357      * Replaces the de-serialized object with an Inet4Address object.
 358      *
 359      * @return the alternate object to the de-serialized object.
 360      *
 361      * @throws ObjectStreamException if a new object replacing this
 362      * object could not be created
 363      */
<a name="16" id="anc16"></a><span class="line-added"> 364     @java.io.Serial</span>
 365     private Object readResolve() throws ObjectStreamException {
 366         // will replace the deserialized &#39;this&#39; object
 367         return new Inet4Address(holder().getHostName(), holder().getAddress());
 368     }
 369 
 370     /**
 371      * Utility routine to check if the InetAddress is an
 372      * IP multicast address.
 373      * @return a {@code boolean} indicating if the InetAddress is
 374      * an IP multicast address
 375      * @since   1.1
 376      */
 377     public boolean isMulticastAddress() {
 378         return false;
 379     }
 380 
 381     /**
 382      * Utility routine to check if the InetAddress is a wildcard address.
 383      * @return a {@code boolean} indicating if the InetAddress is
 384      *         a wildcard address.
 385      * @since 1.4
 386      */
 387     public boolean isAnyLocalAddress() {
 388         return false;
 389     }
 390 
 391     /**
 392      * Utility routine to check if the InetAddress is a loopback address.
 393      *
 394      * @return a {@code boolean} indicating if the InetAddress is
 395      * a loopback address; or false otherwise.
 396      * @since 1.4
 397      */
 398     public boolean isLoopbackAddress() {
 399         return false;
 400     }
 401 
 402     /**
 403      * Utility routine to check if the InetAddress is an link local address.
 404      *
 405      * @return a {@code boolean} indicating if the InetAddress is
 406      * a link local address; or false if address is not a link local unicast address.
 407      * @since 1.4
 408      */
 409     public boolean isLinkLocalAddress() {
 410         return false;
 411     }
 412 
 413     /**
 414      * Utility routine to check if the InetAddress is a site local address.
 415      *
 416      * @return a {@code boolean} indicating if the InetAddress is
 417      * a site local address; or false if address is not a site local unicast address.
 418      * @since 1.4
 419      */
 420     public boolean isSiteLocalAddress() {
 421         return false;
 422     }
 423 
 424     /**
 425      * Utility routine to check if the multicast address has global scope.
 426      *
 427      * @return a {@code boolean} indicating if the address has
 428      *         is a multicast address of global scope, false if it is not
 429      *         of global scope or it is not a multicast address
 430      * @since 1.4
 431      */
 432     public boolean isMCGlobal() {
 433         return false;
 434     }
 435 
 436     /**
 437      * Utility routine to check if the multicast address has node scope.
 438      *
 439      * @return a {@code boolean} indicating if the address has
 440      *         is a multicast address of node-local scope, false if it is not
 441      *         of node-local scope or it is not a multicast address
 442      * @since 1.4
 443      */
 444     public boolean isMCNodeLocal() {
 445         return false;
 446     }
 447 
 448     /**
 449      * Utility routine to check if the multicast address has link scope.
 450      *
 451      * @return a {@code boolean} indicating if the address has
 452      *         is a multicast address of link-local scope, false if it is not
 453      *         of link-local scope or it is not a multicast address
 454      * @since 1.4
 455      */
 456     public boolean isMCLinkLocal() {
 457         return false;
 458     }
 459 
 460     /**
 461      * Utility routine to check if the multicast address has site scope.
 462      *
 463      * @return a {@code boolean} indicating if the address has
 464      *         is a multicast address of site-local scope, false if it is not
 465      *         of site-local scope or it is not a multicast address
 466      * @since 1.4
 467      */
 468     public boolean isMCSiteLocal() {
 469         return false;
 470     }
 471 
 472     /**
 473      * Utility routine to check if the multicast address has organization scope.
 474      *
 475      * @return a {@code boolean} indicating if the address has
 476      *         is a multicast address of organization-local scope,
 477      *         false if it is not of organization-local scope
 478      *         or it is not a multicast address
 479      * @since 1.4
 480      */
 481     public boolean isMCOrgLocal() {
 482         return false;
 483     }
 484 
 485 
 486     /**
 487      * Test whether that address is reachable. Best effort is made by the
 488      * implementation to try to reach the host, but firewalls and server
 489      * configuration may block requests resulting in a unreachable status
 490      * while some specific ports may be accessible.
 491      * A typical implementation will use ICMP ECHO REQUESTs if the
 492      * privilege can be obtained, otherwise it will try to establish
 493      * a TCP connection on port 7 (Echo) of the destination host.
 494      * &lt;p&gt;
 495      * The timeout value, in milliseconds, indicates the maximum amount of time
 496      * the try should take. If the operation times out before getting an
 497      * answer, the host is deemed unreachable. A negative value will result
 498      * in an IllegalArgumentException being thrown.
 499      *
 500      * @param   timeout the time, in milliseconds, before the call aborts
 501      * @return a {@code boolean} indicating if the address is reachable.
 502      * @throws IOException if a network error occurs
 503      * @throws  IllegalArgumentException if {@code timeout} is negative.
 504      * @since 1.5
 505      */
 506     public boolean isReachable(int timeout) throws IOException {
 507         return isReachable(null, 0 , timeout);
 508     }
 509 
 510     /**
 511      * Test whether that address is reachable. Best effort is made by the
 512      * implementation to try to reach the host, but firewalls and server
 513      * configuration may block requests resulting in a unreachable status
 514      * while some specific ports may be accessible.
 515      * A typical implementation will use ICMP ECHO REQUESTs if the
 516      * privilege can be obtained, otherwise it will try to establish
 517      * a TCP connection on port 7 (Echo) of the destination host.
 518      * &lt;p&gt;
 519      * The {@code network interface} and {@code ttl} parameters
 520      * let the caller specify which network interface the test will go through
 521      * and the maximum number of hops the packets should go through.
 522      * A negative value for the {@code ttl} will result in an
 523      * IllegalArgumentException being thrown.
 524      * &lt;p&gt;
 525      * The timeout value, in milliseconds, indicates the maximum amount of time
 526      * the try should take. If the operation times out before getting an
 527      * answer, the host is deemed unreachable. A negative value will result
 528      * in an IllegalArgumentException being thrown.
 529      *
 530      * @param   netif   the NetworkInterface through which the
 531      *                    test will be done, or null for any interface
 532      * @param   ttl     the maximum numbers of hops to try or 0 for the
 533      *                  default
 534      * @param   timeout the time, in milliseconds, before the call aborts
 535      * @throws  IllegalArgumentException if either {@code timeout}
 536      *                          or {@code ttl} are negative.
 537      * @return a {@code boolean} indicating if the address is reachable.
 538      * @throws IOException if a network error occurs
 539      * @since 1.5
 540      */
 541     public boolean isReachable(NetworkInterface netif, int ttl,
 542                                int timeout) throws IOException {
 543         if (ttl &lt; 0)
 544             throw new IllegalArgumentException(&quot;ttl can&#39;t be negative&quot;);
 545         if (timeout &lt; 0)
 546             throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);
 547 
 548         return impl.isReachable(this, timeout, netif, ttl);
 549     }
 550 
 551     /**
 552      * Gets the host name for this IP address.
 553      *
 554      * &lt;p&gt;If this InetAddress was created with a host name,
 555      * this host name will be remembered and returned;
 556      * otherwise, a reverse name lookup will be performed
 557      * and the result will be returned based on the system
 558      * configured name lookup service. If a lookup of the name service
 559      * is required, call
 560      * {@link #getCanonicalHostName() getCanonicalHostName}.
 561      *
 562      * &lt;p&gt;If there is a security manager, its
 563      * {@code checkConnect} method is first called
 564      * with the hostname and {@code -1}
 565      * as its arguments to see if the operation is allowed.
 566      * If the operation is not allowed, it will return
 567      * the textual representation of the IP address.
 568      *
 569      * @return  the host name for this IP address, or if the operation
 570      *    is not allowed by the security check, the textual
 571      *    representation of the IP address.
 572      *
 573      * @see InetAddress#getCanonicalHostName
 574      * @see SecurityManager#checkConnect
 575      */
 576     public String getHostName() {
 577         return getHostName(true);
 578     }
 579 
 580     /**
 581      * Returns the hostname for this address.
 582      * If the host is equal to null, then this address refers to any
 583      * of the local machine&#39;s available network addresses.
 584      * this is package private so SocketPermission can make calls into
 585      * here without a security check.
 586      *
 587      * &lt;p&gt;If there is a security manager, this method first
 588      * calls its {@code checkConnect} method
 589      * with the hostname and {@code -1}
 590      * as its arguments to see if the calling code is allowed to know
 591      * the hostname for this IP address, i.e., to connect to the host.
 592      * If the operation is not allowed, it will return
 593      * the textual representation of the IP address.
 594      *
 595      * @return  the host name for this IP address, or if the operation
 596      *    is not allowed by the security check, the textual
 597      *    representation of the IP address.
 598      *
 599      * @param check make security check if true
 600      *
 601      * @see SecurityManager#checkConnect
 602      */
 603     String getHostName(boolean check) {
 604         if (holder().getHostName() == null) {
 605             holder().hostName = InetAddress.getHostFromNameService(this, check);
 606         }
 607         return holder().getHostName();
 608     }
 609 
 610     /**
 611      * Gets the fully qualified domain name for this IP address.
 612      * Best effort method, meaning we may not be able to return
 613      * the FQDN depending on the underlying system configuration.
 614      *
 615      * &lt;p&gt;If there is a security manager, this method first
 616      * calls its {@code checkConnect} method
 617      * with the hostname and {@code -1}
 618      * as its arguments to see if the calling code is allowed to know
 619      * the hostname for this IP address, i.e., to connect to the host.
 620      * If the operation is not allowed, it will return
 621      * the textual representation of the IP address.
 622      *
 623      * @return  the fully qualified domain name for this IP address,
 624      *    or if the operation is not allowed by the security check,
 625      *    the textual representation of the IP address.
 626      *
 627      * @see SecurityManager#checkConnect
 628      *
 629      * @since 1.4
 630      */
 631     public String getCanonicalHostName() {
 632         String value = canonicalHostName;
 633         if (value == null)
 634             canonicalHostName = value =
 635                 InetAddress.getHostFromNameService(this, true);
 636         return value;
 637     }
 638 
 639     /**
 640      * Returns the hostname for this address.
 641      *
 642      * &lt;p&gt;If there is a security manager, this method first
 643      * calls its {@code checkConnect} method
 644      * with the hostname and {@code -1}
 645      * as its arguments to see if the calling code is allowed to know
 646      * the hostname for this IP address, i.e., to connect to the host.
 647      * If the operation is not allowed, it will return
 648      * the textual representation of the IP address.
 649      *
 650      * @return  the host name for this IP address, or if the operation
 651      *    is not allowed by the security check, the textual
 652      *    representation of the IP address.
 653      *
 654      * @param check make security check if true
 655      *
 656      * @see SecurityManager#checkConnect
 657      */
 658     private static String getHostFromNameService(InetAddress addr, boolean check) {
 659         String host = null;
 660             try {
 661                 // first lookup the hostname
 662                 host = nameService.getHostByAddr(addr.getAddress());
 663 
 664                 /* check to see if calling code is allowed to know
 665                  * the hostname for this IP address, ie, connect to the host
 666                  */
 667                 if (check) {
 668                     SecurityManager sec = System.getSecurityManager();
 669                     if (sec != null) {
 670                         sec.checkConnect(host, -1);
 671                     }
 672                 }
 673 
 674                 /* now get all the IP addresses for this hostname,
 675                  * and make sure one of them matches the original IP
 676                  * address. We do this to try and prevent spoofing.
 677                  */
 678 
 679                 InetAddress[] arr = InetAddress.getAllByName0(host, check);
 680                 boolean ok = false;
 681 
 682                 if(arr != null) {
 683                     for(int i = 0; !ok &amp;&amp; i &lt; arr.length; i++) {
 684                         ok = addr.equals(arr[i]);
 685                     }
 686                 }
 687 
 688                 //XXX: if it looks a spoof just return the address?
 689                 if (!ok) {
 690                     host = addr.getHostAddress();
 691                     return host;
 692                 }
 693             } catch (SecurityException e) {
 694                 host = addr.getHostAddress();
 695             } catch (UnknownHostException e) {
 696                 host = addr.getHostAddress();
 697                 // let next provider resolve the hostname
 698             }
 699         return host;
 700     }
 701 
 702     /**
 703      * Returns the raw IP address of this {@code InetAddress}
 704      * object. The result is in network byte order: the highest order
 705      * byte of the address is in {@code getAddress()[0]}.
 706      *
 707      * @return  the raw IP address of this object.
 708      */
 709     public byte[] getAddress() {
 710         return null;
 711     }
 712 
 713     /**
 714      * Returns the IP address string in textual presentation.
 715      *
 716      * @return  the raw IP address in a string format.
 717      * @since   1.0.2
 718      */
 719     public String getHostAddress() {
 720         return null;
 721      }
 722 
 723     /**
 724      * Returns a hashcode for this IP address.
 725      *
 726      * @return  a hash code value for this IP address.
 727      */
 728     public int hashCode() {
 729         return -1;
 730     }
 731 
 732     /**
 733      * Compares this object against the specified object.
 734      * The result is {@code true} if and only if the argument is
 735      * not {@code null} and it represents the same IP address as
 736      * this object.
 737      * &lt;p&gt;
 738      * Two instances of {@code InetAddress} represent the same IP
 739      * address if the length of the byte arrays returned by
 740      * {@code getAddress} is the same for both, and each of the
 741      * array components is the same for the byte arrays.
 742      *
 743      * @param   obj   the object to compare against.
 744      * @return  {@code true} if the objects are the same;
 745      *          {@code false} otherwise.
 746      * @see     java.net.InetAddress#getAddress()
 747      */
 748     public boolean equals(Object obj) {
 749         return false;
 750     }
 751 
 752     /**
 753      * Converts this IP address to a {@code String}. The
 754      * string returned is of the form: hostname / literal IP
 755      * address.
 756      *
 757      * If the host name is unresolved, no reverse name service lookup
 758      * is performed. The hostname part will be represented by an empty string.
 759      *
 760      * @return  a string representation of this IP address.
 761      */
 762     public String toString() {
 763         String hostName = holder().getHostName();
 764         return Objects.toString(hostName, &quot;&quot;)
 765             + &quot;/&quot; + getHostAddress();
 766     }
 767 
 768     // mapping from host name to Addresses - either NameServiceAddresses (while
 769     // still being looked-up by NameService(s)) or CachedAddresses when cached
 770     private static final ConcurrentMap&lt;String, Addresses&gt; cache =
 771         new ConcurrentHashMap&lt;&gt;();
 772 
 773     // CachedAddresses that have to expire are kept ordered in this NavigableSet
 774     // which is scanned on each access
 775     private static final NavigableSet&lt;CachedAddresses&gt; expirySet =
 776         new ConcurrentSkipListSet&lt;&gt;();
 777 
 778     // common interface
 779     private interface Addresses {
 780         InetAddress[] get() throws UnknownHostException;
 781     }
 782 
 783     // a holder for cached addresses with required metadata
 784     private static final class CachedAddresses  implements Addresses, Comparable&lt;CachedAddresses&gt; {
 785         private static final AtomicLong seq = new AtomicLong();
 786         final String host;
 787         final InetAddress[] inetAddresses;
 788         final long expiryTime; // time of expiry (in terms of System.nanoTime())
 789         final long id = seq.incrementAndGet(); // each instance is unique
 790 
 791         CachedAddresses(String host, InetAddress[] inetAddresses, long expiryTime) {
 792             this.host = host;
 793             this.inetAddresses = inetAddresses;
 794             this.expiryTime = expiryTime;
 795         }
 796 
 797         @Override
 798         public InetAddress[] get() throws UnknownHostException {
 799             if (inetAddresses == null) {
 800                 throw new UnknownHostException(host);
 801             }
 802             return inetAddresses;
 803         }
 804 
 805         @Override
 806         public int compareTo(CachedAddresses other) {
 807             // natural order is expiry time -
 808             // compare difference of expiry times rather than
 809             // expiry times directly, to avoid possible overflow.
 810             // (see System.nanoTime() recommendations...)
 811             long diff = this.expiryTime - other.expiryTime;
 812             if (diff &lt; 0L) return -1;
 813             if (diff &gt; 0L) return 1;
 814             // ties are broken using unique id
 815             return Long.compare(this.id, other.id);
 816         }
 817     }
 818 
 819     // a name service lookup based Addresses implementation which replaces itself
 820     // in cache when the result is obtained
 821     private static final class NameServiceAddresses implements Addresses {
 822         private final String host;
 823         private final InetAddress reqAddr;
 824 
 825         NameServiceAddresses(String host, InetAddress reqAddr) {
 826             this.host = host;
 827             this.reqAddr = reqAddr;
 828         }
 829 
 830         @Override
 831         public InetAddress[] get() throws UnknownHostException {
 832             Addresses addresses;
 833             // only one thread is doing lookup to name service
 834             // for particular host at any time.
 835             synchronized (this) {
 836                 // re-check that we are still us + re-install us if slot empty
 837                 addresses = cache.putIfAbsent(host, this);
 838                 if (addresses == null) {
 839                     // this can happen when we were replaced by CachedAddresses in
 840                     // some other thread, then CachedAddresses expired and were
 841                     // removed from cache while we were waiting for lock...
 842                     addresses = this;
 843                 }
 844                 // still us ?
 845                 if (addresses == this) {
 846                     // lookup name services
 847                     InetAddress[] inetAddresses;
 848                     UnknownHostException ex;
 849                     int cachePolicy;
 850                     try {
 851                         inetAddresses = getAddressesFromNameService(host, reqAddr);
 852                         ex = null;
 853                         cachePolicy = InetAddressCachePolicy.get();
 854                     } catch (UnknownHostException uhe) {
 855                         inetAddresses = null;
 856                         ex = uhe;
 857                         cachePolicy = InetAddressCachePolicy.getNegative();
 858                     }
 859                     // remove or replace us with cached addresses according to cachePolicy
 860                     if (cachePolicy == InetAddressCachePolicy.NEVER) {
 861                         cache.remove(host, this);
 862                     } else {
 863                         CachedAddresses cachedAddresses = new CachedAddresses(
 864                             host,
 865                             inetAddresses,
 866                             cachePolicy == InetAddressCachePolicy.FOREVER
 867                             ? 0L
 868                             // cachePolicy is in [s] - we need [ns]
 869                             : System.nanoTime() + 1000_000_000L * cachePolicy
 870                         );
 871                         if (cache.replace(host, this, cachedAddresses) &amp;&amp;
 872                             cachePolicy != InetAddressCachePolicy.FOREVER) {
 873                             // schedule expiry
 874                             expirySet.add(cachedAddresses);
 875                         }
 876                     }
 877                     if (inetAddresses == null) {
 878                         throw ex == null ? new UnknownHostException(host) : ex;
 879                     }
 880                     return inetAddresses;
 881                 }
 882                 // else addresses != this
 883             }
 884             // delegate to different addresses when we are already replaced
 885             // but outside of synchronized block to avoid any chance of dead-locking
 886             return addresses.get();
 887         }
 888     }
 889 
 890     /**
 891      * NameService provides host and address lookup service
 892      *
 893      * @since 9
 894      */
 895     private interface NameService {
 896 
 897         /**
 898          * Lookup a host mapping by name. Retrieve the IP addresses
 899          * associated with a host
 900          *
 901          * @param host the specified hostname
 902          * @return array of IP addresses for the requested host
 903          * @throws UnknownHostException
 904          *             if no IP address for the {@code host} could be found
 905          */
 906         InetAddress[] lookupAllHostAddr(String host)
 907                 throws UnknownHostException;
 908 
 909         /**
 910          * Lookup the host corresponding to the IP address provided
 911          *
 912          * @param addr byte array representing an IP address
 913          * @return {@code String} representing the host name mapping
 914          * @throws UnknownHostException
 915          *             if no host found for the specified IP address
 916          */
 917         String getHostByAddr(byte[] addr) throws UnknownHostException;
 918 
 919     }
 920 
 921     /**
 922      * The default NameService implementation, which delegates to the underlying
 923      * OS network libraries to resolve host address mappings.
 924      *
 925      * @since 9
 926      */
 927     private static final class PlatformNameService implements NameService {
 928 
 929         public InetAddress[] lookupAllHostAddr(String host)
 930             throws UnknownHostException
 931         {
 932             return impl.lookupAllHostAddr(host);
 933         }
 934 
 935         public String getHostByAddr(byte[] addr)
 936             throws UnknownHostException
 937         {
 938             return impl.getHostByAddr(addr);
 939         }
 940     }
 941 
 942     /**
 943      * The HostsFileNameService provides host address mapping
 944      * by reading the entries in a hosts file, which is specified by
 945      * {@code jdk.net.hosts.file} system property
 946      *
 947      * &lt;p&gt;The file format is that which corresponds with the /etc/hosts file
 948      * IP Address host alias list.
 949      *
 950      * &lt;p&gt;When the file lookup is enabled it replaces the default NameService
 951      * implementation
 952      *
 953      * @since 9
 954      */
 955     private static final class HostsFileNameService implements NameService {
 956 
 957         private final String hostsFile;
 958 
 959         public HostsFileNameService (String hostsFileName) {
 960             this.hostsFile = hostsFileName;
 961         }
 962 
 963         private  String addrToString(byte addr[]) {
 964           String stringifiedAddress = null;
 965 
 966             if (addr.length == Inet4Address.INADDRSZ) {
 967                 stringifiedAddress = Inet4Address.numericToTextFormat(addr);
 968             } else { // treat as an IPV6 jobby
 969                 byte[] newAddr
 970                     = IPAddressUtil.convertFromIPv4MappedAddress(addr);
 971                 if (newAddr != null) {
 972                    stringifiedAddress = Inet4Address.numericToTextFormat(addr);
 973                 } else {
 974                     stringifiedAddress = Inet6Address.numericToTextFormat(addr);
 975                 }
 976             }
 977             return stringifiedAddress;
 978         }
 979 
 980         /**
 981          * Lookup the host name  corresponding to the IP address provided.
 982          * Search the configured host file a host name corresponding to
 983          * the specified IP address.
 984          *
 985          * @param addr byte array representing an IP address
 986          * @return {@code String} representing the host name mapping
 987          * @throws UnknownHostException
 988          *             if no host found for the specified IP address
 989          */
 990         @Override
 991         public String getHostByAddr(byte[] addr) throws UnknownHostException {
 992             String hostEntry;
 993             String host = null;
 994 
<a name="17" id="anc17"></a><span class="line-modified"> 995             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="line-modified"> 996                                                         UTF_8.INSTANCE))</span>
<span class="line-added"> 997             {</span>
 998                 while (hostsFileScanner.hasNextLine()) {
 999                     hostEntry = hostsFileScanner.nextLine();
1000                     if (!hostEntry.startsWith(&quot;#&quot;)) {
1001                         hostEntry = removeComments(hostEntry);
<a name="18" id="anc18"></a><span class="line-modified">1002                         String[] mapping = hostEntry.split(&quot;\\s+&quot;);</span>
<span class="line-modified">1003                         if (mapping.length &gt;= 2 &amp;&amp;</span>
<span class="line-modified">1004                             Arrays.equals(addr, createAddressByteArray(mapping[0]))) {</span>
<span class="line-modified">1005                             host = mapping[1];</span>
<span class="line-modified">1006                             break;</span>
1007                         }
1008                     }
1009                 }
<a name="19" id="anc19"></a><span class="line-modified">1010             } catch (IOException e) {</span>
1011                 throw new UnknownHostException(&quot;Unable to resolve address &quot;
<a name="20" id="anc20"></a><span class="line-modified">1012                         + Arrays.toString(addr) + &quot; as hosts file &quot; + hostsFile</span>
1013                         + &quot; not found &quot;);
1014             }
1015 
1016             if ((host == null) || (host.isEmpty()) || (host.equals(&quot; &quot;))) {
1017                 throw new UnknownHostException(&quot;Requested address &quot;
<a name="21" id="anc21"></a><span class="line-modified">1018                         + Arrays.toString(addr)</span>
1019                         + &quot; resolves to an invalid entry in hosts file &quot;
1020                         + hostsFile);
1021             }
1022             return host;
1023         }
1024 
1025         /**
1026          * &lt;p&gt;Lookup a host mapping by name. Retrieve the IP addresses
1027          * associated with a host.
1028          *
1029          * &lt;p&gt;Search the configured hosts file for the addresses associated
1030          * with the specified host name.
1031          *
1032          * @param host the specified hostname
1033          * @return array of IP addresses for the requested host
1034          * @throws UnknownHostException
1035          *             if no IP address for the {@code host} could be found
1036          */
1037         public InetAddress[] lookupAllHostAddr(String host)
1038                 throws UnknownHostException {
1039             String hostEntry;
1040             String addrStr = null;
1041             InetAddress[] res = null;
1042             byte addr[] = new byte[4];
1043             ArrayList&lt;InetAddress&gt; inetAddresses = null;
1044 
1045             // lookup the file and create a list InetAddress for the specified host
<a name="22" id="anc22"></a><span class="line-modified">1046             try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),</span>
<span class="line-added">1047                                                         UTF_8.INSTANCE))</span>
<span class="line-added">1048             {</span>
1049                 while (hostsFileScanner.hasNextLine()) {
1050                     hostEntry = hostsFileScanner.nextLine();
1051                     if (!hostEntry.startsWith(&quot;#&quot;)) {
1052                         hostEntry = removeComments(hostEntry);
1053                         if (hostEntry.contains(host)) {
1054                             addrStr = extractHostAddr(hostEntry, host);
1055                             if ((addrStr != null) &amp;&amp; (!addrStr.isEmpty())) {
1056                                 addr = createAddressByteArray(addrStr);
1057                                 if (inetAddresses == null) {
1058                                     inetAddresses = new ArrayList&lt;&gt;(1);
1059                                 }
1060                                 if (addr != null) {
1061                                     inetAddresses.add(InetAddress.getByAddress(host, addr));
1062                                 }
1063                             }
1064                         }
1065                     }
1066                 }
<a name="23" id="anc23"></a><span class="line-modified">1067             } catch (IOException e) {</span>
1068                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1069                         + &quot; as hosts file &quot; + hostsFile + &quot; not found &quot;);
1070             }
1071 
1072             if (inetAddresses != null) {
1073                 res = inetAddresses.toArray(new InetAddress[inetAddresses.size()]);
1074             } else {
1075                 throw new UnknownHostException(&quot;Unable to resolve host &quot; + host
1076                         + &quot; in hosts file &quot; + hostsFile);
1077             }
1078             return res;
1079         }
1080 
1081         private String removeComments(String hostsEntry) {
1082             String filteredEntry = hostsEntry;
1083             int hashIndex;
1084 
1085             if ((hashIndex = hostsEntry.indexOf(&quot;#&quot;)) != -1) {
1086                 filteredEntry = hostsEntry.substring(0, hashIndex);
1087             }
1088             return filteredEntry;
1089         }
1090 
1091         private byte [] createAddressByteArray(String addrStr) {
1092             byte[] addrArray;
1093             // check if IPV4 address - most likely
1094             addrArray = IPAddressUtil.textToNumericFormatV4(addrStr);
1095             if (addrArray == null) {
1096                 addrArray = IPAddressUtil.textToNumericFormatV6(addrStr);
1097             }
1098             return addrArray;
1099         }
1100 
1101         /** host to ip address mapping */
1102         private String extractHostAddr(String hostEntry, String host) {
1103             String[] mapping = hostEntry.split(&quot;\\s+&quot;);
1104             String hostAddr = null;
1105 
1106             if (mapping.length &gt;= 2) {
1107                 // look at the host aliases
1108                 for (int i = 1; i &lt; mapping.length; i++) {
1109                     if (mapping[i].equalsIgnoreCase(host)) {
1110                         hostAddr = mapping[0];
1111                     }
1112                 }
1113             }
1114             return hostAddr;
1115         }
<a name="24" id="anc24"></a>















1116     }
1117 
1118     static final InetAddressImpl  impl;
1119 
1120     static {
1121         // create the impl
1122         impl = InetAddressImplFactory.create();
1123 
1124         // create name service
1125         nameService = createNameService();
1126         }
1127 
1128     /**
1129      * Create an instance of the NameService interface based on
1130      * the setting of the {@code jdk.net.hosts.file} system property.
1131      *
1132      * &lt;p&gt;The default NameService is the PlatformNameService, which typically
1133      * delegates name and address resolution calls to the underlying
1134      * OS network libraries.
1135      *
1136      * &lt;p&gt; A HostsFileNameService is created if the {@code jdk.net.hosts.file}
1137      * system property is set. If the specified file doesn&#39;t exist, the name or
1138      * address lookup will result in an UnknownHostException. Thus, non existent
1139      * hosts file is handled as if the file is empty.
1140      *
1141      * @return a NameService
1142      */
1143     private static NameService createNameService() {
1144 
1145         String hostsFileName =
1146                 GetPropertyAction.privilegedGetProperty(&quot;jdk.net.hosts.file&quot;);
1147         NameService theNameService;
1148         if (hostsFileName != null) {
1149             theNameService = new HostsFileNameService(hostsFileName);
1150         } else {
1151             theNameService = new PlatformNameService();
1152         }
1153         return theNameService;
1154     }
1155 
1156     /**
1157      * Creates an InetAddress based on the provided host name and IP address.
1158      * No name service is checked for the validity of the address.
1159      *
1160      * &lt;p&gt; The host name can either be a machine name, such as
1161      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1162      * address.
1163      * &lt;p&gt; No validity checking is done on the host name either.
1164      *
1165      * &lt;p&gt; If addr specifies an IPv4 address an instance of Inet4Address
1166      * will be returned; otherwise, an instance of Inet6Address
1167      * will be returned.
1168      *
1169      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1170      * must be 16 bytes long
1171      *
1172      * @param host the specified host
1173      * @param addr the raw IP address in network byte order
1174      * @return  an InetAddress object created from the raw IP address.
<a name="25" id="anc25"></a><span class="line-modified">1175      * @throws     UnknownHostException  if IP address is of illegal length</span>
1176      * @since 1.4
1177      */
1178     public static InetAddress getByAddress(String host, byte[] addr)
1179         throws UnknownHostException {
1180         if (host != null &amp;&amp; !host.isEmpty() &amp;&amp; host.charAt(0) == &#39;[&#39;) {
1181             if (host.charAt(host.length()-1) == &#39;]&#39;) {
1182                 host = host.substring(1, host.length() -1);
1183             }
1184         }
1185         if (addr != null) {
1186             if (addr.length == Inet4Address.INADDRSZ) {
1187                 return new Inet4Address(host, addr);
1188             } else if (addr.length == Inet6Address.INADDRSZ) {
1189                 byte[] newAddr
1190                     = IPAddressUtil.convertFromIPv4MappedAddress(addr);
1191                 if (newAddr != null) {
1192                     return new Inet4Address(host, newAddr);
1193                 } else {
1194                     return new Inet6Address(host, addr);
1195                 }
1196             }
1197         }
1198         throw new UnknownHostException(&quot;addr is of illegal length&quot;);
1199     }
1200 
1201 
1202     /**
1203      * Determines the IP address of a host, given the host&#39;s name.
1204      *
1205      * &lt;p&gt; The host name can either be a machine name, such as
1206      * &quot;{@code www.example.com}&quot;, or a textual representation of its
1207      * IP address. If a literal IP address is supplied, only the
1208      * validity of the address format is checked.
1209      *
1210      * &lt;p&gt; For {@code host} specified in literal IPv6 address,
1211      * either the form defined in RFC 2732 or the literal IPv6 address
1212      * format defined in RFC 2373 is accepted. IPv6 scoped addresses are also
1213      * supported. See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
1214      * scoped addresses.
1215      *
1216      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1217      * to zero, then an {@code InetAddress} representing an address of the
1218      * loopback interface is returned.
1219      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1220      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1221      * section&amp;nbsp;2.5.3.
1222      *
1223      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1224      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1225      * {@code checkConnect} method is called with the hostname and {@code -1}
1226      * as its arguments to determine if the operation is allowed.
1227      *
1228      * @param      host   the specified host, or {@code null}.
1229      * @return     an IP address for the given host name.
<a name="26" id="anc26"></a><span class="line-modified">1230      * @throws     UnknownHostException  if no IP address for the</span>
1231      *               {@code host} could be found, or if a scope_id was specified
1232      *               for a global IPv6 address.
<a name="27" id="anc27"></a><span class="line-modified">1233      * @throws     SecurityException if a security manager exists</span>
1234      *             and its checkConnect method doesn&#39;t allow the operation
1235      */
1236     public static InetAddress getByName(String host)
1237         throws UnknownHostException {
1238         return InetAddress.getAllByName(host)[0];
1239     }
1240 
1241     // called from deployment cache manager
1242     private static InetAddress getByName(String host, InetAddress reqAddr)
1243         throws UnknownHostException {
1244         return InetAddress.getAllByName(host, reqAddr)[0];
1245     }
1246 
1247     /**
1248      * Given the name of a host, returns an array of its IP addresses,
1249      * based on the configured name service on the system.
1250      *
1251      * &lt;p&gt; The host name can either be a machine name, such as
1252      * &quot;{@code www.example.com}&quot;, or a textual representation of its IP
1253      * address. If a literal IP address is supplied, only the
1254      * validity of the address format is checked.
1255      *
1256      * &lt;p&gt; For {@code host} specified in &lt;i&gt;literal IPv6 address&lt;/i&gt;,
1257      * either the form defined in RFC 2732 or the literal IPv6 address
1258      * format defined in RFC 2373 is accepted. A literal IPv6 address may
1259      * also be qualified by appending a scoped zone identifier or scope_id.
1260      * The syntax and usage of scope_ids is described
1261      * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
1262      *
1263      * &lt;p&gt; If the host is {@code null} or {@code host.length()} is equal
1264      * to zero, then an {@code InetAddress} representing an address of the
1265      * loopback interface is returned.
1266      * See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
1267      * section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
1268      * section&amp;nbsp;2.5.3. &lt;/p&gt;
1269      *
1270      * &lt;p&gt; If there is a security manager, and {@code host} is not {@code null}
1271      * or {@code host.length() } is not equal to zero, the security manager&#39;s
1272      * {@code checkConnect} method is called with the hostname and {@code -1}
1273      * as its arguments to determine if the operation is allowed.
1274      *
1275      * @param      host   the name of the host, or {@code null}.
1276      * @return     an array of all the IP addresses for a given host name.
1277      *
<a name="28" id="anc28"></a><span class="line-modified">1278      * @throws     UnknownHostException  if no IP address for the</span>
1279      *               {@code host} could be found, or if a scope_id was specified
1280      *               for a global IPv6 address.
<a name="29" id="anc29"></a><span class="line-modified">1281      * @throws     SecurityException  if a security manager exists and its</span>
1282      *               {@code checkConnect} method doesn&#39;t allow the operation.
1283      *
1284      * @see SecurityManager#checkConnect
1285      */
1286     public static InetAddress[] getAllByName(String host)
1287         throws UnknownHostException {
1288         return getAllByName(host, null);
1289     }
1290 
1291     private static InetAddress[] getAllByName(String host, InetAddress reqAddr)
1292         throws UnknownHostException {
1293 
1294         if (host == null || host.isEmpty()) {
1295             InetAddress[] ret = new InetAddress[1];
1296             ret[0] = impl.loopbackAddress();
1297             return ret;
1298         }
1299 
1300         boolean ipv6Expected = false;
1301         if (host.charAt(0) == &#39;[&#39;) {
1302             // This is supposed to be an IPv6 literal
1303             if (host.length() &gt; 2 &amp;&amp; host.charAt(host.length()-1) == &#39;]&#39;) {
1304                 host = host.substring(1, host.length() -1);
1305                 ipv6Expected = true;
1306             } else {
1307                 // This was supposed to be a IPv6 address, but it&#39;s not!
1308                 throw new UnknownHostException(host + &quot;: invalid IPv6 address&quot;);
1309             }
1310         }
1311 
1312         // if host is an IP address, we won&#39;t do further lookup
1313         if (Character.digit(host.charAt(0), 16) != -1
1314             || (host.charAt(0) == &#39;:&#39;)) {
1315             byte[] addr = null;
1316             int numericZone = -1;
1317             String ifname = null;
1318             // see if it is IPv4 address
1319             addr = IPAddressUtil.textToNumericFormatV4(host);
1320             if (addr == null) {
1321                 // This is supposed to be an IPv6 literal
1322                 // Check if a numeric or string zone id is present
1323                 int pos;
1324                 if ((pos=host.indexOf (&#39;%&#39;)) != -1) {
1325                     numericZone = checkNumericZone (host);
1326                     if (numericZone == -1) { /* remainder of string must be an ifname */
1327                         ifname = host.substring (pos+1);
1328                     }
1329                 }
1330                 if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &amp;&amp; host.contains(&quot;:&quot;)) {
1331                     throw new UnknownHostException(host + &quot;: invalid IPv6 address&quot;);
1332                 }
1333             } else if (ipv6Expected) {
1334                 // Means an IPv4 literal between brackets!
1335                 throw new UnknownHostException(&quot;[&quot;+host+&quot;]&quot;);
1336             }
1337             InetAddress[] ret = new InetAddress[1];
1338             if(addr != null) {
1339                 if (addr.length == Inet4Address.INADDRSZ) {
1340                     ret[0] = new Inet4Address(null, addr);
1341                 } else {
1342                     if (ifname != null) {
1343                         ret[0] = new Inet6Address(null, addr, ifname);
1344                     } else {
1345                         ret[0] = new Inet6Address(null, addr, numericZone);
1346                     }
1347                 }
1348                 return ret;
1349             }
1350         } else if (ipv6Expected) {
1351             // We were expecting an IPv6 Literal, but got something else
1352             throw new UnknownHostException(&quot;[&quot;+host+&quot;]&quot;);
1353         }
1354         return getAllByName0(host, reqAddr, true, true);
1355     }
1356 
1357     /**
1358      * Returns the loopback address.
1359      * &lt;p&gt;
1360      * The InetAddress returned will represent the IPv4
1361      * loopback address, 127.0.0.1, or the IPv6 loopback
1362      * address, ::1. The IPv4 loopback address returned
1363      * is only one of many in the form 127.*.*.*
1364      *
1365      * @return  the InetAddress loopback instance.
1366      * @since 1.7
1367      */
1368     public static InetAddress getLoopbackAddress() {
1369         return impl.loopbackAddress();
1370     }
1371 
1372 
1373     /**
1374      * check if the literal address string has %nn appended
1375      * returns -1 if not, or the numeric value otherwise.
1376      *
1377      * %nn may also be a string that represents the displayName of
1378      * a currently available NetworkInterface.
1379      */
1380     private static int checkNumericZone (String s) throws UnknownHostException {
1381         int percent = s.indexOf (&#39;%&#39;);
1382         int slen = s.length();
1383         int digit, zone=0;
1384         if (percent == -1) {
1385             return -1;
1386         }
1387         for (int i=percent+1; i&lt;slen; i++) {
1388             char c = s.charAt(i);
1389             if (c == &#39;]&#39;) {
1390                 if (i == percent+1) {
1391                     /* empty per-cent field */
1392                     return -1;
1393                 }
1394                 break;
1395             }
1396             if ((digit = Character.digit (c, 10)) &lt; 0) {
1397                 return -1;
1398             }
1399             zone = (zone * 10) + digit;
1400         }
1401         return zone;
1402     }
1403 
1404     private static InetAddress[] getAllByName0 (String host)
1405         throws UnknownHostException
1406     {
1407         return getAllByName0(host, true);
1408     }
1409 
1410     /**
1411      * package private so SocketPermission can call it
1412      */
1413     static InetAddress[] getAllByName0 (String host, boolean check)
1414         throws UnknownHostException  {
1415         return getAllByName0 (host, null, check, true);
1416     }
1417 
1418     /**
1419      * Designated lookup method.
1420      *
1421      * @param host host name to look up
1422      * @param reqAddr requested address to be the 1st in returned array
1423      * @param check perform security check
1424      * @param useCache use cached value if not expired else always
1425      *                 perform name service lookup (and cache the result)
1426      * @return array of InetAddress(es)
1427      * @throws UnknownHostException if host name is not found
1428      */
1429     private static InetAddress[] getAllByName0(String host,
1430                                                InetAddress reqAddr,
1431                                                boolean check,
1432                                                boolean useCache)
1433         throws UnknownHostException  {
1434 
1435         /* If it gets here it is presumed to be a hostname */
1436 
1437         /* make sure the connection to the host is allowed, before we
1438          * give out a hostname
1439          */
1440         if (check) {
1441             SecurityManager security = System.getSecurityManager();
1442             if (security != null) {
1443                 security.checkConnect(host, -1);
1444             }
1445         }
1446 
1447         // remove expired addresses from cache - expirySet keeps them ordered
1448         // by expiry time so we only need to iterate the prefix of the NavigableSet...
1449         long now = System.nanoTime();
1450         for (CachedAddresses caddrs : expirySet) {
1451             // compare difference of time instants rather than
1452             // time instants directly, to avoid possible overflow.
1453             // (see System.nanoTime() recommendations...)
1454             if ((caddrs.expiryTime - now) &lt; 0L) {
1455                 // ConcurrentSkipListSet uses weakly consistent iterator,
1456                 // so removing while iterating is OK...
1457                 if (expirySet.remove(caddrs)) {
1458                     // ... remove from cache
1459                     cache.remove(caddrs.host, caddrs);
1460                 }
1461             } else {
1462                 // we encountered 1st element that expires in future
1463                 break;
1464             }
1465         }
1466 
1467         // look-up or remove from cache
1468         Addresses addrs;
1469         if (useCache) {
1470             addrs = cache.get(host);
1471         } else {
1472             addrs = cache.remove(host);
1473             if (addrs != null) {
1474                 if (addrs instanceof CachedAddresses) {
1475                     // try removing from expirySet too if CachedAddresses
1476                     expirySet.remove(addrs);
1477                 }
1478                 addrs = null;
1479             }
1480         }
1481 
1482         if (addrs == null) {
1483             // create a NameServiceAddresses instance which will look up
1484             // the name service and install it within cache...
1485             Addresses oldAddrs = cache.putIfAbsent(
1486                 host,
1487                 addrs = new NameServiceAddresses(host, reqAddr)
1488             );
1489             if (oldAddrs != null) { // lost putIfAbsent race
1490                 addrs = oldAddrs;
1491             }
1492         }
1493 
1494         // ask Addresses to get an array of InetAddress(es) and clone it
1495         return addrs.get().clone();
1496     }
1497 
1498     static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)
1499         throws UnknownHostException
1500     {
1501         InetAddress[] addresses = null;
1502         UnknownHostException ex = null;
1503 
1504             try {
1505                 addresses = nameService.lookupAllHostAddr(host);
1506             } catch (UnknownHostException uhe) {
1507                 if (host.equalsIgnoreCase(&quot;localhost&quot;)) {
1508                     addresses = new InetAddress[] { impl.loopbackAddress() };
1509                 }
1510                 else {
1511                     ex = uhe;
1512                 }
1513             }
1514 
1515         if (addresses == null) {
1516             throw ex == null ? new UnknownHostException(host) : ex;
1517         }
1518 
1519         // More to do?
1520         if (reqAddr != null &amp;&amp; addresses.length &gt; 1 &amp;&amp; !addresses[0].equals(reqAddr)) {
1521             // Find it?
1522             int i = 1;
1523             for (; i &lt; addresses.length; i++) {
1524                 if (addresses[i].equals(reqAddr)) {
1525                     break;
1526                 }
1527             }
1528             // Rotate
1529             if (i &lt; addresses.length) {
1530                 InetAddress tmp, tmp2 = reqAddr;
1531                 for (int j = 0; j &lt; i; j++) {
1532                     tmp = addresses[j];
1533                     addresses[j] = tmp2;
1534                     tmp2 = tmp;
1535                 }
1536                 addresses[i] = tmp2;
1537             }
1538         }
1539 
1540         return addresses;
1541     }
1542 
1543     /**
1544      * Returns an {@code InetAddress} object given the raw IP address .
1545      * The argument is in network byte order: the highest order
1546      * byte of the address is in {@code getAddress()[0]}.
1547      *
1548      * &lt;p&gt; This method doesn&#39;t block, i.e. no reverse name service lookup
1549      * is performed.
1550      *
1551      * &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
1552      * must be 16 bytes long
1553      *
1554      * @param addr the raw IP address in network byte order
1555      * @return  an InetAddress object created from the raw IP address.
<a name="30" id="anc30"></a><span class="line-modified">1556      * @throws     UnknownHostException  if IP address is of illegal length</span>
1557      * @since 1.4
1558      */
1559     public static InetAddress getByAddress(byte[] addr)
1560         throws UnknownHostException {
1561         return getByAddress(null, addr);
1562     }
1563 
1564     private static final class CachedLocalHost {
1565         final String host;
1566         final InetAddress addr;
1567         final long expiryTime = System.nanoTime() + 5000_000_000L; // now + 5s;
1568 
1569         CachedLocalHost(String host, InetAddress addr) {
1570             this.host = host;
1571             this.addr = addr;
1572         }
1573     }
1574 
1575     private static volatile CachedLocalHost cachedLocalHost;
1576 
1577     /**
1578      * Returns the address of the local host. This is achieved by retrieving
1579      * the name of the host from the system, then resolving that name into
1580      * an {@code InetAddress}.
1581      *
1582      * &lt;P&gt;Note: The resolved address may be cached for a short period of time.
1583      * &lt;/P&gt;
1584      *
1585      * &lt;p&gt;If there is a security manager, its
1586      * {@code checkConnect} method is called
1587      * with the local host name and {@code -1}
1588      * as its arguments to see if the operation is allowed.
1589      * If the operation is not allowed, an InetAddress representing
1590      * the loopback address is returned.
1591      *
1592      * @return     the address of the local host.
1593      *
<a name="31" id="anc31"></a><span class="line-modified">1594      * @throws     UnknownHostException  if the local host name could not</span>
1595      *             be resolved into an address.
1596      *
1597      * @see SecurityManager#checkConnect
1598      * @see java.net.InetAddress#getByName(java.lang.String)
1599      */
1600     public static InetAddress getLocalHost() throws UnknownHostException {
1601 
1602         SecurityManager security = System.getSecurityManager();
1603         try {
1604             // is cached data still valid?
1605             CachedLocalHost clh = cachedLocalHost;
1606             if (clh != null &amp;&amp; (clh.expiryTime - System.nanoTime()) &gt;= 0L) {
1607                 if (security != null) {
1608                     security.checkConnect(clh.host, -1);
1609                 }
1610                 return clh.addr;
1611             }
1612 
1613             String local = impl.getLocalHostName();
1614 
1615             if (security != null) {
1616                 security.checkConnect(local, -1);
1617             }
1618 
1619             InetAddress localAddr;
1620             if (local.equals(&quot;localhost&quot;)) {
1621                 // shortcut for &quot;localhost&quot; host name
1622                 localAddr = impl.loopbackAddress();
1623             } else {
1624                 // call getAllByName0 without security checks and
1625                 // without using cached data
1626                 try {
1627                     localAddr = getAllByName0(local, null, false, false)[0];
1628                 } catch (UnknownHostException uhe) {
1629                     // Rethrow with a more informative error message.
1630                     UnknownHostException uhe2 =
1631                         new UnknownHostException(local + &quot;: &quot; +
1632                                                  uhe.getMessage());
1633                     uhe2.initCause(uhe);
1634                     throw uhe2;
1635                 }
1636             }
1637             cachedLocalHost = new CachedLocalHost(local, localAddr);
1638             return localAddr;
1639         } catch (java.lang.SecurityException e) {
1640             return impl.loopbackAddress();
1641         }
1642     }
1643 
1644     /**
1645      * Perform class load-time initializations.
1646      */
1647     private static native void init();
1648 
1649 
1650     /*
1651      * Returns the InetAddress representing anyLocalAddress
1652      * (typically 0.0.0.0 or ::0)
1653      */
1654     static InetAddress anyLocalAddress() {
1655         return impl.anyLocalAddress();
1656     }
1657 
1658     /*
1659      * Load and instantiate an underlying impl class
1660      */
1661     static InetAddressImpl loadImpl(String implName) {
1662         Object impl = null;
1663 
1664         /*
1665          * Property &quot;impl.prefix&quot; will be prepended to the classname
1666          * of the implementation object we instantiate, to which we
1667          * delegate the real work (like native methods).  This
1668          * property can vary across implementations of the java.
1669          * classes.  The default is an empty String &quot;&quot;.
1670          */
1671         String prefix = GetPropertyAction.privilegedGetProperty(&quot;impl.prefix&quot;, &quot;&quot;);
1672         try {
1673             @SuppressWarnings(&quot;deprecation&quot;)
1674             Object tmp = Class.forName(&quot;java.net.&quot; + prefix + implName).newInstance();
1675             impl = tmp;
1676         } catch (ClassNotFoundException e) {
1677             System.err.println(&quot;Class not found: java.net.&quot; + prefix +
1678                                implName + &quot;:\ncheck impl.prefix property &quot; +
1679                                &quot;in your properties file.&quot;);
1680         } catch (InstantiationException e) {
1681             System.err.println(&quot;Could not instantiate: java.net.&quot; + prefix +
1682                                implName + &quot;:\ncheck impl.prefix property &quot; +
1683                                &quot;in your properties file.&quot;);
1684         } catch (IllegalAccessException e) {
1685             System.err.println(&quot;Cannot access class: java.net.&quot; + prefix +
1686                                implName + &quot;:\ncheck impl.prefix property &quot; +
1687                                &quot;in your properties file.&quot;);
1688         }
1689 
1690         if (impl == null) {
1691             try {
1692                 @SuppressWarnings(&quot;deprecation&quot;)
1693                 Object tmp = Class.forName(implName).newInstance();
1694                 impl = tmp;
1695             } catch (Exception e) {
1696                 throw new Error(&quot;System property impl.prefix incorrect&quot;);
1697             }
1698         }
1699 
1700         return (InetAddressImpl) impl;
1701     }
1702 
<a name="32" id="anc32"></a><span class="line-added">1703     @java.io.Serial</span>
1704     private void readObjectNoData () {
1705         if (getClass().getClassLoader() != null) {
1706             throw new SecurityException (&quot;invalid address type&quot;);
1707         }
1708     }
1709 
1710     private static final jdk.internal.misc.Unsafe UNSAFE
1711             = jdk.internal.misc.Unsafe.getUnsafe();
1712     private static final long FIELDS_OFFSET
1713             = UNSAFE.objectFieldOffset(InetAddress.class, &quot;holder&quot;);
1714 
<a name="33" id="anc33"></a><span class="line-added">1715     @java.io.Serial</span>
1716     private void readObject (ObjectInputStream s) throws
1717                          IOException, ClassNotFoundException {
1718         if (getClass().getClassLoader() != null) {
1719             throw new SecurityException (&quot;invalid address type&quot;);
1720         }
1721         GetField gf = s.readFields();
1722         String host = (String)gf.get(&quot;hostName&quot;, null);
1723         int address = gf.get(&quot;address&quot;, 0);
1724         int family = gf.get(&quot;family&quot;, 0);
1725         if (family != IPv4 &amp;&amp; family != IPv6) {
1726             throw new InvalidObjectException(&quot;invalid address family type: &quot; + family);
1727         }
1728         InetAddressHolder h = new InetAddressHolder(host, address, family);
1729         UNSAFE.putReference(this, FIELDS_OFFSET, h);
1730     }
1731 
1732     /* needed because the serializable fields no longer exist */
1733 
1734     /**
1735      * @serialField hostName String
1736      * @serialField address int
1737      * @serialField family int
1738      */
<a name="34" id="anc34"></a><span class="line-added">1739     @java.io.Serial</span>
1740     private static final ObjectStreamField[] serialPersistentFields = {
1741         new ObjectStreamField(&quot;hostName&quot;, String.class),
1742         new ObjectStreamField(&quot;address&quot;, int.class),
1743         new ObjectStreamField(&quot;family&quot;, int.class),
1744     };
1745 
<a name="35" id="anc35"></a><span class="line-added">1746     @java.io.Serial</span>
1747     private void writeObject (ObjectOutputStream s) throws
1748                         IOException {
1749         if (getClass().getClassLoader() != null) {
1750             throw new SecurityException (&quot;invalid address type&quot;);
1751         }
1752         PutField pf = s.putFields();
1753         pf.put(&quot;hostName&quot;, holder().getHostName());
1754         pf.put(&quot;address&quot;, holder().getAddress());
1755         pf.put(&quot;family&quot;, holder().getFamily());
1756         s.writeFields();
1757     }
1758 }
1759 
1760 /*
1761  * Simple factory to create the impl
1762  */
1763 class InetAddressImplFactory {
1764 
1765     static InetAddressImpl create() {
1766         return InetAddress.loadImpl(isIPv6Supported() ?
1767                                     &quot;Inet6AddressImpl&quot; : &quot;Inet4AddressImpl&quot;);
1768     }
1769 
1770     static native boolean isIPv6Supported();
1771 }
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/Duration.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time;
  63 
  64 import static java.time.LocalTime.MINUTES_PER_HOUR;
  65 import static java.time.LocalTime.NANOS_PER_MILLI;
  66 import static java.time.LocalTime.NANOS_PER_SECOND;
  67 import static java.time.LocalTime.SECONDS_PER_DAY;
  68 import static java.time.LocalTime.SECONDS_PER_HOUR;
  69 import static java.time.LocalTime.SECONDS_PER_MINUTE;
  70 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  71 import static java.time.temporal.ChronoUnit.DAYS;
  72 import static java.time.temporal.ChronoUnit.NANOS;
  73 import static java.time.temporal.ChronoUnit.SECONDS;
  74 
  75 import java.io.DataInput;
  76 import java.io.DataOutput;
  77 import java.io.IOException;
  78 import java.io.InvalidObjectException;
  79 import java.io.ObjectInputStream;
  80 import java.io.Serializable;
  81 import java.math.BigDecimal;
  82 import java.math.BigInteger;
  83 import java.math.RoundingMode;
  84 import java.time.format.DateTimeParseException;
  85 import java.time.temporal.ChronoField;
  86 import java.time.temporal.ChronoUnit;
  87 import java.time.temporal.Temporal;
  88 import java.time.temporal.TemporalAmount;
  89 import java.time.temporal.TemporalUnit;
  90 import java.time.temporal.UnsupportedTemporalTypeException;
  91 import java.util.List;
  92 import java.util.Objects;
  93 import java.util.regex.Matcher;
  94 import java.util.regex.Pattern;
  95 
  96 /**
  97  * A time-based amount of time, such as &#39;34.5 seconds&#39;.
  98  * &lt;p&gt;
  99  * This class models a quantity or amount of time in terms of seconds and nanoseconds.
 100  * It can be accessed using other duration-based units, such as minutes and hours.
 101  * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
 102  * exactly equal to 24 hours, thus ignoring daylight savings effects.
 103  * See {@link Period} for the date-based equivalent to this class.
 104  * &lt;p&gt;
 105  * A physical duration could be of infinite length.
 106  * For practicality, the duration is stored with constraints similar to {@link Instant}.
 107  * The duration uses nanosecond resolution with a maximum value of the seconds that can
 108  * be held in a {@code long}. This is greater than the current estimated age of the universe.
 109  * &lt;p&gt;
 110  * The range of a duration requires the storage of a number larger than a {@code long}.
 111  * To achieve this, the class stores a {@code long} representing seconds and an {@code int}
 112  * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 113  * The model is of a directed duration, meaning that the duration may be negative.
 114  * &lt;p&gt;
 115  * The duration is measured in &quot;seconds&quot;, but these are not necessarily identical to
 116  * the scientific &quot;SI second&quot; definition based on atomic clocks.
 117  * This difference only impacts durations measured near a leap-second and should not affect
 118  * most applications.
 119  * See {@link Instant} for a discussion as to the meaning of the second and time-scales.
 120  *
 121  * &lt;p&gt;
 122  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 123  * class; use of identity-sensitive operations (including reference equality
 124  * ({@code ==}), identity hash code, or synchronization) on instances of
 125  * {@code Duration} may have unpredictable results and should be avoided.
 126  * The {@code equals} method should be used for comparisons.
 127  *
 128  * @implSpec
 129  * This class is immutable and thread-safe.
 130  *
 131  * @since 1.8
 132  */
 133 public final class Duration
 134         implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable {
 135 
 136     /**
 137      * Constant for a duration of zero.
 138      */
 139     public static final Duration ZERO = new Duration(0, 0);
 140     /**
 141      * Serialization version.
 142      */
<a name="2" id="anc2"></a><span class="line-added"> 143     @java.io.Serial</span>
 144     private static final long serialVersionUID = 3078945930695997490L;
 145     /**
 146      * Constant for nanos per second.
 147      */
 148     private static final BigInteger BI_NANOS_PER_SECOND = BigInteger.valueOf(NANOS_PER_SECOND);
 149     /**
 150      * The pattern for parsing.
 151      */
 152     private static class Lazy {
 153         static final Pattern PATTERN =
 154             Pattern.compile(&quot;([-+]?)P(?:([-+]?[0-9]+)D)?&quot; +
 155                     &quot;(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?&quot;,
 156                     Pattern.CASE_INSENSITIVE);
 157     }
 158 
 159     /**
 160      * The number of seconds in the duration.
 161      */
 162     private final long seconds;
 163     /**
 164      * The number of nanoseconds in the duration, expressed as a fraction of the
 165      * number of seconds. This is always positive, and never exceeds 999,999,999.
 166      */
 167     private final int nanos;
 168 
 169     //-----------------------------------------------------------------------
 170     /**
 171      * Obtains a {@code Duration} representing a number of standard 24 hour days.
 172      * &lt;p&gt;
 173      * The seconds are calculated based on the standard definition of a day,
 174      * where each day is 86400 seconds which implies a 24 hour day.
 175      * The nanosecond in second field is set to zero.
 176      *
 177      * @param days  the number of days, positive or negative
 178      * @return a {@code Duration}, not null
 179      * @throws ArithmeticException if the input days exceeds the capacity of {@code Duration}
 180      */
 181     public static Duration ofDays(long days) {
 182         return create(Math.multiplyExact(days, SECONDS_PER_DAY), 0);
 183     }
 184 
 185     /**
 186      * Obtains a {@code Duration} representing a number of standard hours.
 187      * &lt;p&gt;
 188      * The seconds are calculated based on the standard definition of an hour,
 189      * where each hour is 3600 seconds.
 190      * The nanosecond in second field is set to zero.
 191      *
 192      * @param hours  the number of hours, positive or negative
 193      * @return a {@code Duration}, not null
 194      * @throws ArithmeticException if the input hours exceeds the capacity of {@code Duration}
 195      */
 196     public static Duration ofHours(long hours) {
 197         return create(Math.multiplyExact(hours, SECONDS_PER_HOUR), 0);
 198     }
 199 
 200     /**
 201      * Obtains a {@code Duration} representing a number of standard minutes.
 202      * &lt;p&gt;
 203      * The seconds are calculated based on the standard definition of a minute,
 204      * where each minute is 60 seconds.
 205      * The nanosecond in second field is set to zero.
 206      *
 207      * @param minutes  the number of minutes, positive or negative
 208      * @return a {@code Duration}, not null
 209      * @throws ArithmeticException if the input minutes exceeds the capacity of {@code Duration}
 210      */
 211     public static Duration ofMinutes(long minutes) {
 212         return create(Math.multiplyExact(minutes, SECONDS_PER_MINUTE), 0);
 213     }
 214 
 215     //-----------------------------------------------------------------------
 216     /**
 217      * Obtains a {@code Duration} representing a number of seconds.
 218      * &lt;p&gt;
 219      * The nanosecond in second field is set to zero.
 220      *
 221      * @param seconds  the number of seconds, positive or negative
 222      * @return a {@code Duration}, not null
 223      */
 224     public static Duration ofSeconds(long seconds) {
 225         return create(seconds, 0);
 226     }
 227 
 228     /**
 229      * Obtains a {@code Duration} representing a number of seconds and an
 230      * adjustment in nanoseconds.
 231      * &lt;p&gt;
 232      * This method allows an arbitrary number of nanoseconds to be passed in.
 233      * The factory will alter the values of the second and nanosecond in order
 234      * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
 235      * For example, the following will result in exactly the same duration:
 236      * &lt;pre&gt;
 237      *  Duration.ofSeconds(3, 1);
 238      *  Duration.ofSeconds(4, -999_999_999);
 239      *  Duration.ofSeconds(2, 1000_000_001);
 240      * &lt;/pre&gt;
 241      *
 242      * @param seconds  the number of seconds, positive or negative
 243      * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
 244      * @return a {@code Duration}, not null
 245      * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@code Duration}
 246      */
 247     public static Duration ofSeconds(long seconds, long nanoAdjustment) {
 248         long secs = Math.addExact(seconds, Math.floorDiv(nanoAdjustment, NANOS_PER_SECOND));
 249         int nos = (int) Math.floorMod(nanoAdjustment, NANOS_PER_SECOND);
 250         return create(secs, nos);
 251     }
 252 
 253     //-----------------------------------------------------------------------
 254     /**
 255      * Obtains a {@code Duration} representing a number of milliseconds.
 256      * &lt;p&gt;
 257      * The seconds and nanoseconds are extracted from the specified milliseconds.
 258      *
 259      * @param millis  the number of milliseconds, positive or negative
 260      * @return a {@code Duration}, not null
 261      */
 262     public static Duration ofMillis(long millis) {
 263         long secs = millis / 1000;
 264         int mos = (int) (millis % 1000);
 265         if (mos &lt; 0) {
 266             mos += 1000;
 267             secs--;
 268         }
 269         return create(secs, mos * 1000_000);
 270     }
 271 
 272     //-----------------------------------------------------------------------
 273     /**
 274      * Obtains a {@code Duration} representing a number of nanoseconds.
 275      * &lt;p&gt;
 276      * The seconds and nanoseconds are extracted from the specified nanoseconds.
 277      *
 278      * @param nanos  the number of nanoseconds, positive or negative
 279      * @return a {@code Duration}, not null
 280      */
 281     public static Duration ofNanos(long nanos) {
 282         long secs = nanos / NANOS_PER_SECOND;
 283         int nos = (int) (nanos % NANOS_PER_SECOND);
 284         if (nos &lt; 0) {
 285             nos += NANOS_PER_SECOND;
 286             secs--;
 287         }
 288         return create(secs, nos);
 289     }
 290 
 291     //-----------------------------------------------------------------------
 292     /**
 293      * Obtains a {@code Duration} representing an amount in the specified unit.
 294      * &lt;p&gt;
 295      * The parameters represent the two parts of a phrase like &#39;6 Hours&#39;. For example:
 296      * &lt;pre&gt;
 297      *  Duration.of(3, SECONDS);
 298      *  Duration.of(465, HOURS);
 299      * &lt;/pre&gt;
 300      * Only a subset of units are accepted by this method.
 301      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 302      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 303      *
 304      * @param amount  the amount of the duration, measured in terms of the unit, positive or negative
 305      * @param unit  the unit that the duration is measured in, must have an exact duration, not null
 306      * @return a {@code Duration}, not null
 307      * @throws DateTimeException if the period unit has an estimated duration
 308      * @throws ArithmeticException if a numeric overflow occurs
 309      */
 310     public static Duration of(long amount, TemporalUnit unit) {
 311         return ZERO.plus(amount, unit);
 312     }
 313 
 314     //-----------------------------------------------------------------------
 315     /**
 316      * Obtains an instance of {@code Duration} from a temporal amount.
 317      * &lt;p&gt;
 318      * This obtains a duration based on the specified amount.
 319      * A {@code TemporalAmount} represents an  amount of time, which may be
 320      * date-based or time-based, which this factory extracts to a duration.
 321      * &lt;p&gt;
 322      * The conversion loops around the set of units from the amount and uses
 323      * the {@linkplain TemporalUnit#getDuration() duration} of the unit to
 324      * calculate the total {@code Duration}.
 325      * Only a subset of units are accepted by this method. The unit must either
 326      * have an {@linkplain TemporalUnit#isDurationEstimated() exact duration}
 327      * or be {@link ChronoUnit#DAYS} which is treated as 24 hours.
 328      * If any other units are found then an exception is thrown.
 329      *
 330      * @param amount  the temporal amount to convert, not null
 331      * @return the equivalent duration, not null
 332      * @throws DateTimeException if unable to convert to a {@code Duration}
 333      * @throws ArithmeticException if numeric overflow occurs
 334      */
 335     public static Duration from(TemporalAmount amount) {
 336         Objects.requireNonNull(amount, &quot;amount&quot;);
 337         Duration duration = ZERO;
 338         for (TemporalUnit unit : amount.getUnits()) {
 339             duration = duration.plus(amount.get(unit), unit);
 340         }
 341         return duration;
 342     }
 343 
 344     //-----------------------------------------------------------------------
 345     /**
 346      * Obtains a {@code Duration} from a text string such as {@code PnDTnHnMn.nS}.
 347      * &lt;p&gt;
 348      * This will parse a textual representation of a duration, including the
 349      * string produced by {@code toString()}. The formats accepted are based
 350      * on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days
 351      * considered to be exactly 24 hours.
 352      * &lt;p&gt;
 353      * The string starts with an optional sign, denoted by the ASCII negative
 354      * or positive symbol. If negative, the whole period is negated.
 355      * The ASCII letter &quot;P&quot; is next in upper or lower case.
 356      * There are then four sections, each consisting of a number and a suffix.
 357      * The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for
 358      * days, hours, minutes and seconds, accepted in upper or lower case.
 359      * The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before
 360      * the first occurrence, if any, of an hour, minute or second section.
 361      * At least one of the four sections must be present, and if &quot;T&quot; is present
 362      * there must be at least one section after the &quot;T&quot;.
 363      * The number part of each section must consist of one or more ASCII digits.
 364      * The number may be prefixed by the ASCII negative or positive symbol.
 365      * The number of days, hours and minutes must parse to a {@code long}.
 366      * The number of seconds must parse to a {@code long} with optional fraction.
 367      * The decimal point may be either a dot or a comma.
 368      * The fractional part may have from zero to 9 digits.
 369      * &lt;p&gt;
 370      * The leading plus/minus sign, and negative values for other units are
 371      * not part of the ISO-8601 standard.
 372      * &lt;p&gt;
 373      * Examples:
 374      * &lt;pre&gt;
 375      *    &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;
 376      *    &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)
 377      *    &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)
 378      *    &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)
 379      *    &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;
 380      *    &quot;PT-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;
 381      *    &quot;-PT6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;
 382      *    &quot;-PT-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;
 383      * &lt;/pre&gt;
 384      *
 385      * @param text  the text to parse, not null
 386      * @return the parsed duration, not null
 387      * @throws DateTimeParseException if the text cannot be parsed to a duration
 388      */
 389     public static Duration parse(CharSequence text) {
 390         Objects.requireNonNull(text, &quot;text&quot;);
 391         Matcher matcher = Lazy.PATTERN.matcher(text);
 392         if (matcher.matches()) {
 393             // check for letter T but no time sections
 394             if (!charMatch(text, matcher.start(3), matcher.end(3), &#39;T&#39;)) {
 395                 boolean negate = charMatch(text, matcher.start(1), matcher.end(1), &#39;-&#39;);
 396 
 397                 int dayStart = matcher.start(2), dayEnd = matcher.end(2);
 398                 int hourStart = matcher.start(4), hourEnd = matcher.end(4);
 399                 int minuteStart = matcher.start(5), minuteEnd = matcher.end(5);
 400                 int secondStart = matcher.start(6), secondEnd = matcher.end(6);
 401                 int fractionStart = matcher.start(7), fractionEnd = matcher.end(7);
 402 
 403                 if (dayStart &gt;= 0 || hourStart &gt;= 0 || minuteStart &gt;= 0 || secondStart &gt;= 0) {
 404                     long daysAsSecs = parseNumber(text, dayStart, dayEnd, SECONDS_PER_DAY, &quot;days&quot;);
 405                     long hoursAsSecs = parseNumber(text, hourStart, hourEnd, SECONDS_PER_HOUR, &quot;hours&quot;);
 406                     long minsAsSecs = parseNumber(text, minuteStart, minuteEnd, SECONDS_PER_MINUTE, &quot;minutes&quot;);
 407                     long seconds = parseNumber(text, secondStart, secondEnd, 1, &quot;seconds&quot;);
 408                     boolean negativeSecs = secondStart &gt;= 0 &amp;&amp; text.charAt(secondStart) == &#39;-&#39;;
 409                     int nanos = parseFraction(text, fractionStart, fractionEnd, negativeSecs ? -1 : 1);
 410                     try {
 411                         return create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
 412                     } catch (ArithmeticException ex) {
 413                         throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: overflow&quot;, text, 0).initCause(ex);
 414                     }
 415                 }
 416             }
 417         }
 418         throw new DateTimeParseException(&quot;Text cannot be parsed to a Duration&quot;, text, 0);
 419     }
 420 
 421     private static boolean charMatch(CharSequence text, int start, int end, char c) {
 422         return (start &gt;= 0 &amp;&amp; end == start + 1 &amp;&amp; text.charAt(start) == c);
 423     }
 424 
 425     private static long parseNumber(CharSequence text, int start, int end, int multiplier, String errorText) {
 426         // regex limits to [-+]?[0-9]+
 427         if (start &lt; 0 || end &lt; 0) {
 428             return 0;
 429         }
 430         try {
 431             long val = Long.parseLong(text, start, end, 10);
 432             return Math.multiplyExact(val, multiplier);
 433         } catch (NumberFormatException | ArithmeticException ex) {
 434             throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: &quot; + errorText, text, 0).initCause(ex);
 435         }
 436     }
 437 
 438     private static int parseFraction(CharSequence text, int start, int end, int negate) {
 439         // regex limits to [0-9]{0,9}
 440         if (start &lt; 0 || end &lt; 0 || end - start == 0) {
 441             return 0;
 442         }
 443         try {
 444             int fraction = Integer.parseInt(text, start, end, 10);
 445 
 446             // for number strings smaller than 9 digits, interpret as if there
 447             // were trailing zeros
 448             for (int i = end - start; i &lt; 9; i++) {
 449                 fraction *= 10;
 450             }
 451             return fraction * negate;
 452         } catch (NumberFormatException | ArithmeticException ex) {
 453             throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: fraction&quot;, text, 0).initCause(ex);
 454         }
 455     }
 456 
 457     private static Duration create(boolean negate, long daysAsSecs, long hoursAsSecs, long minsAsSecs, long secs, int nanos) {
 458         long seconds = Math.addExact(daysAsSecs, Math.addExact(hoursAsSecs, Math.addExact(minsAsSecs, secs)));
 459         if (negate) {
 460             return ofSeconds(seconds, nanos).negated();
 461         }
 462         return ofSeconds(seconds, nanos);
 463     }
 464 
 465     //-----------------------------------------------------------------------
 466     /**
 467      * Obtains a {@code Duration} representing the duration between two temporal objects.
 468      * &lt;p&gt;
 469      * This calculates the duration between two temporal objects. If the objects
 470      * are of different types, then the duration is calculated based on the type
 471      * of the first object. For example, if the first argument is a {@code LocalTime}
 472      * then the second argument is converted to a {@code LocalTime}.
 473      * &lt;p&gt;
 474      * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.
 475      * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the
 476      * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.
 477      * &lt;p&gt;
 478      * The result of this method can be a negative period if the end is before the start.
 479      * To guarantee to obtain a positive duration call {@link #abs()} on the result.
 480      *
 481      * @param startInclusive  the start instant, inclusive, not null
 482      * @param endExclusive  the end instant, exclusive, not null
 483      * @return a {@code Duration}, not null
 484      * @throws DateTimeException if the seconds between the temporals cannot be obtained
 485      * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}
 486      */
 487     public static Duration between(Temporal startInclusive, Temporal endExclusive) {
 488         try {
 489             return ofNanos(startInclusive.until(endExclusive, NANOS));
 490         } catch (DateTimeException | ArithmeticException ex) {
 491             long secs = startInclusive.until(endExclusive, SECONDS);
 492             long nanos;
 493             try {
 494                 nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);
 495                 if (secs &gt; 0 &amp;&amp; nanos &lt; 0) {
 496                     secs++;
 497                 } else if (secs &lt; 0 &amp;&amp; nanos &gt; 0) {
 498                     secs--;
 499                 }
 500             } catch (DateTimeException ex2) {
 501                 nanos = 0;
 502             }
 503             return ofSeconds(secs, nanos);
 504         }
 505     }
 506 
 507     //-----------------------------------------------------------------------
 508     /**
 509      * Obtains an instance of {@code Duration} using seconds and nanoseconds.
 510      *
 511      * @param seconds  the length of the duration in seconds, positive or negative
 512      * @param nanoAdjustment  the nanosecond adjustment within the second, from 0 to 999,999,999
 513      */
 514     private static Duration create(long seconds, int nanoAdjustment) {
 515         if ((seconds | nanoAdjustment) == 0) {
 516             return ZERO;
 517         }
 518         return new Duration(seconds, nanoAdjustment);
 519     }
 520 
 521     /**
 522      * Constructs an instance of {@code Duration} using seconds and nanoseconds.
 523      *
 524      * @param seconds  the length of the duration in seconds, positive or negative
 525      * @param nanos  the nanoseconds within the second, from 0 to 999,999,999
 526      */
 527     private Duration(long seconds, int nanos) {
 528         super();
 529         this.seconds = seconds;
 530         this.nanos = nanos;
 531     }
 532 
 533     //-----------------------------------------------------------------------
 534     /**
 535      * Gets the value of the requested unit.
 536      * &lt;p&gt;
 537      * This returns a value for each of the two supported units,
 538      * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.
 539      * All other units throw an exception.
 540      *
 541      * @param unit the {@code TemporalUnit} for which to return the value
 542      * @return the long value of the unit
 543      * @throws DateTimeException if the unit is not supported
 544      * @throws UnsupportedTemporalTypeException if the unit is not supported
 545      */
 546     @Override
 547     public long get(TemporalUnit unit) {
 548         if (unit == SECONDS) {
 549             return seconds;
 550         } else if (unit == NANOS) {
 551             return nanos;
 552         } else {
 553             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
 554         }
 555     }
 556 
 557     /**
 558      * Gets the set of units supported by this duration.
 559      * &lt;p&gt;
 560      * The supported units are {@link ChronoUnit#SECONDS SECONDS},
 561      * and {@link ChronoUnit#NANOS NANOS}.
 562      * They are returned in the order seconds, nanos.
 563      * &lt;p&gt;
 564      * This set can be used in conjunction with {@link #get(TemporalUnit)}
 565      * to access the entire state of the duration.
 566      *
 567      * @return a list containing the seconds and nanos units, not null
 568      */
 569     @Override
 570     public List&lt;TemporalUnit&gt; getUnits() {
 571         return DurationUnits.UNITS;
 572     }
 573 
 574     /**
 575      * Private class to delay initialization of this list until needed.
 576      * The circular dependency between Duration and ChronoUnit prevents
 577      * the simple initialization in Duration.
 578      */
 579     private static class DurationUnits {
 580         static final List&lt;TemporalUnit&gt; UNITS = List.of(SECONDS, NANOS);
 581     }
 582 
 583     //-----------------------------------------------------------------------
 584     /**
 585      * Checks if this duration is zero length.
 586      * &lt;p&gt;
 587      * A {@code Duration} represents a directed distance between two points on
 588      * the time-line and can therefore be positive, zero or negative.
 589      * This method checks whether the length is zero.
 590      *
 591      * @return true if this duration has a total length equal to zero
 592      */
 593     public boolean isZero() {
 594         return (seconds | nanos) == 0;
 595     }
 596 
 597     /**
 598      * Checks if this duration is negative, excluding zero.
 599      * &lt;p&gt;
 600      * A {@code Duration} represents a directed distance between two points on
 601      * the time-line and can therefore be positive, zero or negative.
 602      * This method checks whether the length is less than zero.
 603      *
 604      * @return true if this duration has a total length less than zero
 605      */
 606     public boolean isNegative() {
 607         return seconds &lt; 0;
 608     }
 609 
 610     //-----------------------------------------------------------------------
 611     /**
 612      * Gets the number of seconds in this duration.
 613      * &lt;p&gt;
 614      * The length of the duration is stored using two fields - seconds and nanoseconds.
 615      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
 616      * the length in seconds.
 617      * The total duration is defined by calling this method and {@link #getNano()}.
 618      * &lt;p&gt;
 619      * A {@code Duration} represents a directed distance between two points on the time-line.
 620      * A negative duration is expressed by the negative sign of the seconds part.
 621      * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
 622      *
 623      * @return the whole seconds part of the length of the duration, positive or negative
 624      */
 625     public long getSeconds() {
 626         return seconds;
 627     }
 628 
 629     /**
 630      * Gets the number of nanoseconds within the second in this duration.
 631      * &lt;p&gt;
 632      * The length of the duration is stored using two fields - seconds and nanoseconds.
 633      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
 634      * the length in seconds.
 635      * The total duration is defined by calling this method and {@link #getSeconds()}.
 636      * &lt;p&gt;
 637      * A {@code Duration} represents a directed distance between two points on the time-line.
 638      * A negative duration is expressed by the negative sign of the seconds part.
 639      * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
 640      *
 641      * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
 642      */
 643     public int getNano() {
 644         return nanos;
 645     }
 646 
 647     //-----------------------------------------------------------------------
 648     /**
 649      * Returns a copy of this duration with the specified amount of seconds.
 650      * &lt;p&gt;
 651      * This returns a duration with the specified seconds, retaining the
 652      * nano-of-second part of this duration.
 653      * &lt;p&gt;
 654      * This instance is immutable and unaffected by this method call.
 655      *
 656      * @param seconds  the seconds to represent, may be negative
 657      * @return a {@code Duration} based on this period with the requested seconds, not null
 658      */
 659     public Duration withSeconds(long seconds) {
 660         return create(seconds, nanos);
 661     }
 662 
 663     /**
 664      * Returns a copy of this duration with the specified nano-of-second.
 665      * &lt;p&gt;
 666      * This returns a duration with the specified nano-of-second, retaining the
 667      * seconds part of this duration.
 668      * &lt;p&gt;
 669      * This instance is immutable and unaffected by this method call.
 670      *
 671      * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
 672      * @return a {@code Duration} based on this period with the requested nano-of-second, not null
 673      * @throws DateTimeException if the nano-of-second is invalid
 674      */
 675     public Duration withNanos(int nanoOfSecond) {
 676         NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
 677         return create(seconds, nanoOfSecond);
 678     }
 679 
 680     //-----------------------------------------------------------------------
 681     /**
 682      * Returns a copy of this duration with the specified duration added.
 683      * &lt;p&gt;
 684      * This instance is immutable and unaffected by this method call.
 685      *
 686      * @param duration  the duration to add, positive or negative, not null
 687      * @return a {@code Duration} based on this duration with the specified duration added, not null
 688      * @throws ArithmeticException if numeric overflow occurs
 689      */
 690     public Duration plus(Duration duration) {
 691         return plus(duration.getSeconds(), duration.getNano());
 692      }
 693 
 694     /**
 695      * Returns a copy of this duration with the specified duration added.
 696      * &lt;p&gt;
 697      * The duration amount is measured in terms of the specified unit.
 698      * Only a subset of units are accepted by this method.
 699      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 700      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 701      * &lt;p&gt;
 702      * This instance is immutable and unaffected by this method call.
 703      *
 704      * @param amountToAdd  the amount to add, measured in terms of the unit, positive or negative
 705      * @param unit  the unit that the amount is measured in, must have an exact duration, not null
 706      * @return a {@code Duration} based on this duration with the specified duration added, not null
 707      * @throws UnsupportedTemporalTypeException if the unit is not supported
 708      * @throws ArithmeticException if numeric overflow occurs
 709      */
 710     public Duration plus(long amountToAdd, TemporalUnit unit) {
 711         Objects.requireNonNull(unit, &quot;unit&quot;);
 712         if (unit == DAYS) {
 713             return plus(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY), 0);
 714         }
 715         if (unit.isDurationEstimated()) {
 716             throw new UnsupportedTemporalTypeException(&quot;Unit must not have an estimated duration&quot;);
 717         }
 718         if (amountToAdd == 0) {
 719             return this;
 720         }
 721         if (unit instanceof ChronoUnit) {
 722             switch ((ChronoUnit) unit) {
 723                 case NANOS: return plusNanos(amountToAdd);
 724                 case MICROS: return plusSeconds((amountToAdd / (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);
 725                 case MILLIS: return plusMillis(amountToAdd);
 726                 case SECONDS: return plusSeconds(amountToAdd);
 727             }
 728             return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));
 729         }
 730         Duration duration = unit.getDuration().multipliedBy(amountToAdd);
 731         return plusSeconds(duration.getSeconds()).plusNanos(duration.getNano());
 732     }
 733 
 734     //-----------------------------------------------------------------------
 735     /**
 736      * Returns a copy of this duration with the specified duration in standard 24 hour days added.
 737      * &lt;p&gt;
 738      * The number of days is multiplied by 86400 to obtain the number of seconds to add.
 739      * This is based on the standard definition of a day as 24 hours.
 740      * &lt;p&gt;
 741      * This instance is immutable and unaffected by this method call.
 742      *
 743      * @param daysToAdd  the days to add, positive or negative
 744      * @return a {@code Duration} based on this duration with the specified days added, not null
 745      * @throws ArithmeticException if numeric overflow occurs
 746      */
 747     public Duration plusDays(long daysToAdd) {
 748         return plus(Math.multiplyExact(daysToAdd, SECONDS_PER_DAY), 0);
 749     }
 750 
 751     /**
 752      * Returns a copy of this duration with the specified duration in hours added.
 753      * &lt;p&gt;
 754      * This instance is immutable and unaffected by this method call.
 755      *
 756      * @param hoursToAdd  the hours to add, positive or negative
 757      * @return a {@code Duration} based on this duration with the specified hours added, not null
 758      * @throws ArithmeticException if numeric overflow occurs
 759      */
 760     public Duration plusHours(long hoursToAdd) {
 761         return plus(Math.multiplyExact(hoursToAdd, SECONDS_PER_HOUR), 0);
 762     }
 763 
 764     /**
 765      * Returns a copy of this duration with the specified duration in minutes added.
 766      * &lt;p&gt;
 767      * This instance is immutable and unaffected by this method call.
 768      *
 769      * @param minutesToAdd  the minutes to add, positive or negative
 770      * @return a {@code Duration} based on this duration with the specified minutes added, not null
 771      * @throws ArithmeticException if numeric overflow occurs
 772      */
 773     public Duration plusMinutes(long minutesToAdd) {
 774         return plus(Math.multiplyExact(minutesToAdd, SECONDS_PER_MINUTE), 0);
 775     }
 776 
 777     /**
 778      * Returns a copy of this duration with the specified duration in seconds added.
 779      * &lt;p&gt;
 780      * This instance is immutable and unaffected by this method call.
 781      *
 782      * @param secondsToAdd  the seconds to add, positive or negative
 783      * @return a {@code Duration} based on this duration with the specified seconds added, not null
 784      * @throws ArithmeticException if numeric overflow occurs
 785      */
 786     public Duration plusSeconds(long secondsToAdd) {
 787         return plus(secondsToAdd, 0);
 788     }
 789 
 790     /**
 791      * Returns a copy of this duration with the specified duration in milliseconds added.
 792      * &lt;p&gt;
 793      * This instance is immutable and unaffected by this method call.
 794      *
 795      * @param millisToAdd  the milliseconds to add, positive or negative
 796      * @return a {@code Duration} based on this duration with the specified milliseconds added, not null
 797      * @throws ArithmeticException if numeric overflow occurs
 798      */
 799     public Duration plusMillis(long millisToAdd) {
 800         return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);
 801     }
 802 
 803     /**
 804      * Returns a copy of this duration with the specified duration in nanoseconds added.
 805      * &lt;p&gt;
 806      * This instance is immutable and unaffected by this method call.
 807      *
 808      * @param nanosToAdd  the nanoseconds to add, positive or negative
 809      * @return a {@code Duration} based on this duration with the specified nanoseconds added, not null
 810      * @throws ArithmeticException if numeric overflow occurs
 811      */
 812     public Duration plusNanos(long nanosToAdd) {
 813         return plus(0, nanosToAdd);
 814     }
 815 
 816     /**
 817      * Returns a copy of this duration with the specified duration added.
 818      * &lt;p&gt;
 819      * This instance is immutable and unaffected by this method call.
 820      *
 821      * @param secondsToAdd  the seconds to add, positive or negative
 822      * @param nanosToAdd  the nanos to add, positive or negative
 823      * @return a {@code Duration} based on this duration with the specified seconds added, not null
 824      * @throws ArithmeticException if numeric overflow occurs
 825      */
 826     private Duration plus(long secondsToAdd, long nanosToAdd) {
 827         if ((secondsToAdd | nanosToAdd) == 0) {
 828             return this;
 829         }
 830         long epochSec = Math.addExact(seconds, secondsToAdd);
 831         epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);
 832         nanosToAdd = nanosToAdd % NANOS_PER_SECOND;
 833         long nanoAdjustment = nanos + nanosToAdd;  // safe int+NANOS_PER_SECOND
 834         return ofSeconds(epochSec, nanoAdjustment);
 835     }
 836 
 837     //-----------------------------------------------------------------------
 838     /**
 839      * Returns a copy of this duration with the specified duration subtracted.
 840      * &lt;p&gt;
 841      * This instance is immutable and unaffected by this method call.
 842      *
 843      * @param duration  the duration to subtract, positive or negative, not null
 844      * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
 845      * @throws ArithmeticException if numeric overflow occurs
 846      */
 847     public Duration minus(Duration duration) {
 848         long secsToSubtract = duration.getSeconds();
 849         int nanosToSubtract = duration.getNano();
 850         if (secsToSubtract == Long.MIN_VALUE) {
 851             return plus(Long.MAX_VALUE, -nanosToSubtract).plus(1, 0);
 852         }
 853         return plus(-secsToSubtract, -nanosToSubtract);
 854      }
 855 
 856     /**
 857      * Returns a copy of this duration with the specified duration subtracted.
 858      * &lt;p&gt;
 859      * The duration amount is measured in terms of the specified unit.
 860      * Only a subset of units are accepted by this method.
 861      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 862      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 863      * &lt;p&gt;
 864      * This instance is immutable and unaffected by this method call.
 865      *
 866      * @param amountToSubtract  the amount to subtract, measured in terms of the unit, positive or negative
 867      * @param unit  the unit that the amount is measured in, must have an exact duration, not null
 868      * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
 869      * @throws ArithmeticException if numeric overflow occurs
 870      */
 871     public Duration minus(long amountToSubtract, TemporalUnit unit) {
 872         return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
 873     }
 874 
 875     //-----------------------------------------------------------------------
 876     /**
 877      * Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.
 878      * &lt;p&gt;
 879      * The number of days is multiplied by 86400 to obtain the number of seconds to subtract.
 880      * This is based on the standard definition of a day as 24 hours.
 881      * &lt;p&gt;
 882      * This instance is immutable and unaffected by this method call.
 883      *
 884      * @param daysToSubtract  the days to subtract, positive or negative
 885      * @return a {@code Duration} based on this duration with the specified days subtracted, not null
 886      * @throws ArithmeticException if numeric overflow occurs
 887      */
 888     public Duration minusDays(long daysToSubtract) {
 889         return (daysToSubtract == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));
 890     }
 891 
 892     /**
 893      * Returns a copy of this duration with the specified duration in hours subtracted.
 894      * &lt;p&gt;
 895      * The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.
 896      * &lt;p&gt;
 897      * This instance is immutable and unaffected by this method call.
 898      *
 899      * @param hoursToSubtract  the hours to subtract, positive or negative
 900      * @return a {@code Duration} based on this duration with the specified hours subtracted, not null
 901      * @throws ArithmeticException if numeric overflow occurs
 902      */
 903     public Duration minusHours(long hoursToSubtract) {
 904         return (hoursToSubtract == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hoursToSubtract));
 905     }
 906 
 907     /**
 908      * Returns a copy of this duration with the specified duration in minutes subtracted.
 909      * &lt;p&gt;
 910      * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.
 911      * &lt;p&gt;
 912      * This instance is immutable and unaffected by this method call.
 913      *
 914      * @param minutesToSubtract  the minutes to subtract, positive or negative
 915      * @return a {@code Duration} based on this duration with the specified minutes subtracted, not null
 916      * @throws ArithmeticException if numeric overflow occurs
 917      */
 918     public Duration minusMinutes(long minutesToSubtract) {
 919         return (minutesToSubtract == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutesToSubtract));
 920     }
 921 
 922     /**
 923      * Returns a copy of this duration with the specified duration in seconds subtracted.
 924      * &lt;p&gt;
 925      * This instance is immutable and unaffected by this method call.
 926      *
 927      * @param secondsToSubtract  the seconds to subtract, positive or negative
 928      * @return a {@code Duration} based on this duration with the specified seconds subtracted, not null
 929      * @throws ArithmeticException if numeric overflow occurs
 930      */
 931     public Duration minusSeconds(long secondsToSubtract) {
 932         return (secondsToSubtract == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-secondsToSubtract));
 933     }
 934 
 935     /**
 936      * Returns a copy of this duration with the specified duration in milliseconds subtracted.
 937      * &lt;p&gt;
 938      * This instance is immutable and unaffected by this method call.
 939      *
 940      * @param millisToSubtract  the milliseconds to subtract, positive or negative
 941      * @return a {@code Duration} based on this duration with the specified milliseconds subtracted, not null
 942      * @throws ArithmeticException if numeric overflow occurs
 943      */
 944     public Duration minusMillis(long millisToSubtract) {
 945         return (millisToSubtract == Long.MIN_VALUE ? plusMillis(Long.MAX_VALUE).plusMillis(1) : plusMillis(-millisToSubtract));
 946     }
 947 
 948     /**
 949      * Returns a copy of this duration with the specified duration in nanoseconds subtracted.
 950      * &lt;p&gt;
 951      * This instance is immutable and unaffected by this method call.
 952      *
 953      * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
 954      * @return a {@code Duration} based on this duration with the specified nanoseconds subtracted, not null
 955      * @throws ArithmeticException if numeric overflow occurs
 956      */
 957     public Duration minusNanos(long nanosToSubtract) {
 958         return (nanosToSubtract == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanosToSubtract));
 959     }
 960 
 961     //-----------------------------------------------------------------------
 962     /**
 963      * Returns a copy of this duration multiplied by the scalar.
 964      * &lt;p&gt;
 965      * This instance is immutable and unaffected by this method call.
 966      *
 967      * @param multiplicand  the value to multiply the duration by, positive or negative
 968      * @return a {@code Duration} based on this duration multiplied by the specified scalar, not null
 969      * @throws ArithmeticException if numeric overflow occurs
 970      */
 971     public Duration multipliedBy(long multiplicand) {
 972         if (multiplicand == 0) {
 973             return ZERO;
 974         }
 975         if (multiplicand == 1) {
 976             return this;
 977         }
 978         return create(toBigDecimalSeconds().multiply(BigDecimal.valueOf(multiplicand)));
 979      }
 980 
 981     /**
 982      * Returns a copy of this duration divided by the specified value.
 983      * &lt;p&gt;
 984      * This instance is immutable and unaffected by this method call.
 985      *
 986      * @param divisor  the value to divide the duration by, positive or negative, not zero
 987      * @return a {@code Duration} based on this duration divided by the specified divisor, not null
 988      * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs
 989      */
 990     public Duration dividedBy(long divisor) {
 991         if (divisor == 0) {
 992             throw new ArithmeticException(&quot;Cannot divide by zero&quot;);
 993         }
 994         if (divisor == 1) {
 995             return this;
 996         }
 997         return create(toBigDecimalSeconds().divide(BigDecimal.valueOf(divisor), RoundingMode.DOWN));
 998      }
 999 
1000     /**
1001      * Returns number of whole times a specified Duration occurs within this Duration.
1002      * &lt;p&gt;
1003      * This instance is immutable and unaffected by this method call.
1004      *
1005      * @param divisor the value to divide the duration by, positive or negative, not null
1006      * @return number of whole times, rounded toward zero, a specified
1007      *         {@code Duration} occurs within this Duration, may be negative
1008      * @throws ArithmeticException if the divisor is zero, or if numeric overflow occurs
1009      * @since 9
1010      */
1011     public long dividedBy(Duration divisor) {
1012         Objects.requireNonNull(divisor, &quot;divisor&quot;);
1013         BigDecimal dividendBigD = toBigDecimalSeconds();
1014         BigDecimal divisorBigD = divisor.toBigDecimalSeconds();
1015         return dividendBigD.divideToIntegralValue(divisorBigD).longValueExact();
1016     }
1017 
1018     /**
1019      * Converts this duration to the total length in seconds and
1020      * fractional nanoseconds expressed as a {@code BigDecimal}.
1021      *
1022      * @return the total length of the duration in seconds, with a scale of 9, not null
1023      */
1024     private BigDecimal toBigDecimalSeconds() {
1025         return BigDecimal.valueOf(seconds).add(BigDecimal.valueOf(nanos, 9));
1026     }
1027 
1028     /**
1029      * Creates an instance of {@code Duration} from a number of seconds.
1030      *
1031      * @param seconds  the number of seconds, up to scale 9, positive or negative
1032      * @return a {@code Duration}, not null
1033      * @throws ArithmeticException if numeric overflow occurs
1034      */
1035     private static Duration create(BigDecimal seconds) {
1036         BigInteger nanos = seconds.movePointRight(9).toBigIntegerExact();
1037         BigInteger[] divRem = nanos.divideAndRemainder(BI_NANOS_PER_SECOND);
1038         if (divRem[0].bitLength() &gt; 63) {
1039             throw new ArithmeticException(&quot;Exceeds capacity of Duration: &quot; + nanos);
1040         }
1041         return ofSeconds(divRem[0].longValue(), divRem[1].intValue());
1042     }
1043 
1044     //-----------------------------------------------------------------------
1045     /**
1046      * Returns a copy of this duration with the length negated.
1047      * &lt;p&gt;
1048      * This method swaps the sign of the total length of this duration.
1049      * For example, {@code PT1.3S} will be returned as {@code PT-1.3S}.
1050      * &lt;p&gt;
1051      * This instance is immutable and unaffected by this method call.
1052      *
1053      * @return a {@code Duration} based on this duration with the amount negated, not null
1054      * @throws ArithmeticException if numeric overflow occurs
1055      */
1056     public Duration negated() {
1057         return multipliedBy(-1);
1058     }
1059 
1060     /**
1061      * Returns a copy of this duration with a positive length.
1062      * &lt;p&gt;
1063      * This method returns a positive duration by effectively removing the sign from any negative total length.
1064      * For example, {@code PT-1.3S} will be returned as {@code PT1.3S}.
1065      * &lt;p&gt;
1066      * This instance is immutable and unaffected by this method call.
1067      *
1068      * @return a {@code Duration} based on this duration with an absolute length, not null
1069      * @throws ArithmeticException if numeric overflow occurs
1070      */
1071     public Duration abs() {
1072         return isNegative() ? negated() : this;
1073     }
1074 
1075     //-------------------------------------------------------------------------
1076     /**
1077      * Adds this duration to the specified temporal object.
1078      * &lt;p&gt;
1079      * This returns a temporal object of the same observable type as the input
1080      * with this duration added.
1081      * &lt;p&gt;
1082      * In most cases, it is clearer to reverse the calling pattern by using
1083      * {@link Temporal#plus(TemporalAmount)}.
1084      * &lt;pre&gt;
1085      *   // these two lines are equivalent, but the second approach is recommended
1086      *   dateTime = thisDuration.addTo(dateTime);
1087      *   dateTime = dateTime.plus(thisDuration);
1088      * &lt;/pre&gt;
1089      * &lt;p&gt;
1090      * The calculation will add the seconds, then nanos.
1091      * Only non-zero amounts will be added.
1092      * &lt;p&gt;
1093      * This instance is immutable and unaffected by this method call.
1094      *
1095      * @param temporal  the temporal object to adjust, not null
1096      * @return an object of the same type with the adjustment made, not null
1097      * @throws DateTimeException if unable to add
1098      * @throws ArithmeticException if numeric overflow occurs
1099      */
1100     @Override
1101     public Temporal addTo(Temporal temporal) {
1102         if (seconds != 0) {
1103             temporal = temporal.plus(seconds, SECONDS);
1104         }
1105         if (nanos != 0) {
1106             temporal = temporal.plus(nanos, NANOS);
1107         }
1108         return temporal;
1109     }
1110 
1111     /**
1112      * Subtracts this duration from the specified temporal object.
1113      * &lt;p&gt;
1114      * This returns a temporal object of the same observable type as the input
1115      * with this duration subtracted.
1116      * &lt;p&gt;
1117      * In most cases, it is clearer to reverse the calling pattern by using
1118      * {@link Temporal#minus(TemporalAmount)}.
1119      * &lt;pre&gt;
1120      *   // these two lines are equivalent, but the second approach is recommended
1121      *   dateTime = thisDuration.subtractFrom(dateTime);
1122      *   dateTime = dateTime.minus(thisDuration);
1123      * &lt;/pre&gt;
1124      * &lt;p&gt;
1125      * The calculation will subtract the seconds, then nanos.
1126      * Only non-zero amounts will be added.
1127      * &lt;p&gt;
1128      * This instance is immutable and unaffected by this method call.
1129      *
1130      * @param temporal  the temporal object to adjust, not null
1131      * @return an object of the same type with the adjustment made, not null
1132      * @throws DateTimeException if unable to subtract
1133      * @throws ArithmeticException if numeric overflow occurs
1134      */
1135     @Override
1136     public Temporal subtractFrom(Temporal temporal) {
1137         if (seconds != 0) {
1138             temporal = temporal.minus(seconds, SECONDS);
1139         }
1140         if (nanos != 0) {
1141             temporal = temporal.minus(nanos, NANOS);
1142         }
1143         return temporal;
1144     }
1145 
1146     //-----------------------------------------------------------------------
1147     /**
1148      * Gets the number of days in this duration.
1149      * &lt;p&gt;
1150      * This returns the total number of days in the duration by dividing the
1151      * number of seconds by 86400.
1152      * This is based on the standard definition of a day as 24 hours.
1153      * &lt;p&gt;
1154      * This instance is immutable and unaffected by this method call.
1155      *
1156      * @return the number of days in the duration, may be negative
1157      */
1158     public long toDays() {
1159         return seconds / SECONDS_PER_DAY;
1160     }
1161 
1162     /**
1163      * Gets the number of hours in this duration.
1164      * &lt;p&gt;
1165      * This returns the total number of hours in the duration by dividing the
1166      * number of seconds by 3600.
1167      * &lt;p&gt;
1168      * This instance is immutable and unaffected by this method call.
1169      *
1170      * @return the number of hours in the duration, may be negative
1171      */
1172     public long toHours() {
1173         return seconds / SECONDS_PER_HOUR;
1174     }
1175 
1176     /**
1177      * Gets the number of minutes in this duration.
1178      * &lt;p&gt;
1179      * This returns the total number of minutes in the duration by dividing the
1180      * number of seconds by 60.
1181      * &lt;p&gt;
1182      * This instance is immutable and unaffected by this method call.
1183      *
1184      * @return the number of minutes in the duration, may be negative
1185      */
1186     public long toMinutes() {
1187         return seconds / SECONDS_PER_MINUTE;
1188     }
1189 
1190     /**
1191      * Gets the number of seconds in this duration.
1192      * &lt;p&gt;
1193      * This returns the total number of whole seconds in the duration.
1194      * &lt;p&gt;
1195      * This instance is immutable and unaffected by this method call.
1196      *
1197      * @return the whole seconds part of the length of the duration, positive or negative
1198      * @since 9
1199      */
1200     public long toSeconds() {
1201         return seconds;
1202     }
1203 
1204     /**
1205      * Converts this duration to the total length in milliseconds.
1206      * &lt;p&gt;
1207      * If this duration is too large to fit in a {@code long} milliseconds, then an
1208      * exception is thrown.
1209      * &lt;p&gt;
1210      * If this duration has greater than millisecond precision, then the conversion
1211      * will drop any excess precision information as though the amount in nanoseconds
1212      * was subject to integer division by one million.
1213      *
1214      * @return the total length of the duration in milliseconds
1215      * @throws ArithmeticException if numeric overflow occurs
1216      */
1217     public long toMillis() {
1218         long tempSeconds = seconds;
1219         long tempNanos = nanos;
1220         if (tempSeconds &lt; 0) {
1221             // change the seconds and nano value to
1222             // handle Long.MIN_VALUE case
1223             tempSeconds = tempSeconds + 1;
1224             tempNanos = tempNanos - NANOS_PER_SECOND;
1225         }
1226         long millis = Math.multiplyExact(tempSeconds, 1000);
1227         millis = Math.addExact(millis, tempNanos / NANOS_PER_MILLI);
1228         return millis;
1229     }
1230 
1231     /**
1232      * Converts this duration to the total length in nanoseconds expressed as a {@code long}.
1233      * &lt;p&gt;
1234      * If this duration is too large to fit in a {@code long} nanoseconds, then an
1235      * exception is thrown.
1236      *
1237      * @return the total length of the duration in nanoseconds
1238      * @throws ArithmeticException if numeric overflow occurs
1239      */
1240     public long toNanos() {
1241         long tempSeconds = seconds;
1242         long tempNanos = nanos;
1243         if (tempSeconds &lt; 0) {
1244             // change the seconds and nano value to
1245             // handle Long.MIN_VALUE case
1246             tempSeconds = tempSeconds + 1;
1247             tempNanos = tempNanos - NANOS_PER_SECOND;
1248         }
1249         long totalNanos = Math.multiplyExact(tempSeconds, NANOS_PER_SECOND);
1250         totalNanos = Math.addExact(totalNanos, tempNanos);
1251         return totalNanos;
1252     }
1253 
1254     /**
1255      * Extracts the number of days in the duration.
1256      * &lt;p&gt;
1257      * This returns the total number of days in the duration by dividing the
1258      * number of seconds by 86400.
1259      * This is based on the standard definition of a day as 24 hours.
1260      * &lt;p&gt;
1261      * This instance is immutable and unaffected by this method call.
1262      *
1263      * @return the number of days in the duration, may be negative
1264      * @since 9
1265      */
1266     public long toDaysPart(){
1267         return seconds / SECONDS_PER_DAY;
1268     }
1269 
1270     /**
1271      * Extracts the number of hours part in the duration.
1272      * &lt;p&gt;
1273      * This returns the number of remaining hours when dividing {@link #toHours}
1274      * by hours in a day.
1275      * This is based on the standard definition of a day as 24 hours.
1276      * &lt;p&gt;
1277      * This instance is immutable and unaffected by this method call.
1278      *
1279      * @return the number of hours part in the duration, may be negative
1280      * @since 9
1281      */
1282     public int toHoursPart(){
1283         return (int) (toHours() % 24);
1284     }
1285 
1286     /**
1287      * Extracts the number of minutes part in the duration.
1288      * &lt;p&gt;
1289      * This returns the number of remaining minutes when dividing {@link #toMinutes}
1290      * by minutes in an hour.
1291      * This is based on the standard definition of an hour as 60 minutes.
1292      * &lt;p&gt;
1293      * This instance is immutable and unaffected by this method call.
1294      *
1295      * @return the number of minutes parts in the duration, may be negative
1296      * @since 9
1297      */
1298     public int toMinutesPart(){
1299         return (int) (toMinutes() % MINUTES_PER_HOUR);
1300     }
1301 
1302     /**
1303      * Extracts the number of seconds part in the duration.
1304      * &lt;p&gt;
1305      * This returns the remaining seconds when dividing {@link #toSeconds}
1306      * by seconds in a minute.
1307      * This is based on the standard definition of a minute as 60 seconds.
1308      * &lt;p&gt;
1309      * This instance is immutable and unaffected by this method call.
1310      *
1311      * @return the number of seconds parts in the duration, may be negative
1312      * @since 9
1313      */
1314     public int toSecondsPart(){
1315         return (int) (seconds % SECONDS_PER_MINUTE);
1316     }
1317 
1318     /**
1319      * Extracts the number of milliseconds part of the duration.
1320      * &lt;p&gt;
1321      * This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.
1322      * The length of the duration is stored using two fields - seconds and nanoseconds.
1323      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
1324      * the length in seconds.
1325      * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
1326      * &lt;p&gt;
1327      * This instance is immutable and unaffected by this method call.
1328      *
1329      * @return the number of milliseconds part of the duration.
1330      * @since 9
1331      */
1332     public int toMillisPart(){
1333         return nanos / 1000_000;
1334     }
1335 
1336     /**
1337      * Get the nanoseconds part within seconds of the duration.
1338      * &lt;p&gt;
1339      * The length of the duration is stored using two fields - seconds and nanoseconds.
1340      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
1341      * the length in seconds.
1342      * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
1343      * &lt;p&gt;
1344      * This instance is immutable and unaffected by this method call.
1345      *
1346      * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
1347      * @since 9
1348      */
1349     public int toNanosPart(){
1350         return nanos;
1351     }
1352 
1353 
1354     //-----------------------------------------------------------------------
1355     /**
1356      * Returns a copy of this {@code Duration} truncated to the specified unit.
1357      * &lt;p&gt;
1358      * Truncating the duration returns a copy of the original with conceptual fields
1359      * smaller than the specified unit set to zero.
1360      * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
1361      * round down towards zero to the nearest minute, setting the seconds and
1362      * nanoseconds to zero.
1363      * &lt;p&gt;
1364      * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
1365      * that divides into the length of a standard day without remainder.
1366      * This includes all
1367      * {@linkplain ChronoUnit#isTimeBased() time-based units on {@code ChronoUnit}}
1368      * and {@link ChronoUnit#DAYS DAYS}. Other ChronoUnits throw an exception.
1369      * &lt;p&gt;
1370      * This instance is immutable and unaffected by this method call.
1371      *
1372      * @param unit the unit to truncate to, not null
1373      * @return a {@code Duration} based on this duration with the time truncated, not null
1374      * @throws DateTimeException if the unit is invalid for truncation
1375      * @throws UnsupportedTemporalTypeException if the unit is not supported
1376      * @since 9
1377      */
1378     public Duration truncatedTo(TemporalUnit unit) {
1379         Objects.requireNonNull(unit, &quot;unit&quot;);
1380         if (unit == ChronoUnit.SECONDS &amp;&amp; (seconds &gt;= 0 || nanos == 0)) {
1381             return new Duration(seconds, 0);
1382         } else if (unit == ChronoUnit.NANOS) {
1383             return this;
1384         }
1385         Duration unitDur = unit.getDuration();
1386         if (unitDur.getSeconds() &gt; LocalTime.SECONDS_PER_DAY) {
1387             throw new UnsupportedTemporalTypeException(&quot;Unit is too large to be used for truncation&quot;);
1388         }
1389         long dur = unitDur.toNanos();
1390         if ((LocalTime.NANOS_PER_DAY % dur) != 0) {
1391             throw new UnsupportedTemporalTypeException(&quot;Unit must divide into a standard day without remainder&quot;);
1392         }
1393         long nod = (seconds % LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + nanos;
1394         long result = (nod / dur) * dur;
1395         return plusNanos(result - nod);
1396     }
1397 
1398     //-----------------------------------------------------------------------
1399     /**
1400      * Compares this duration to the specified {@code Duration}.
1401      * &lt;p&gt;
1402      * The comparison is based on the total length of the durations.
1403      * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
1404      *
1405      * @param otherDuration the other duration to compare to, not null
1406      * @return the comparator value, negative if less, positive if greater
1407      */
1408     @Override
1409     public int compareTo(Duration otherDuration) {
1410         int cmp = Long.compare(seconds, otherDuration.seconds);
1411         if (cmp != 0) {
1412             return cmp;
1413         }
1414         return nanos - otherDuration.nanos;
1415     }
1416 
1417     //-----------------------------------------------------------------------
1418     /**
1419      * Checks if this duration is equal to the specified {@code Duration}.
1420      * &lt;p&gt;
1421      * The comparison is based on the total length of the durations.
1422      *
1423      * @param otherDuration the other duration, null returns false
1424      * @return true if the other duration is equal to this one
1425      */
1426     @Override
1427     public boolean equals(Object otherDuration) {
1428         if (this == otherDuration) {
1429             return true;
1430         }
1431         if (otherDuration instanceof Duration) {
1432             Duration other = (Duration) otherDuration;
1433             return this.seconds == other.seconds &amp;&amp;
1434                    this.nanos == other.nanos;
1435         }
1436         return false;
1437     }
1438 
1439     /**
1440      * A hash code for this duration.
1441      *
1442      * @return a suitable hash code
1443      */
1444     @Override
1445     public int hashCode() {
1446         return ((int) (seconds ^ (seconds &gt;&gt;&gt; 32))) + (51 * nanos);
1447     }
1448 
1449     //-----------------------------------------------------------------------
1450     /**
1451      * A string representation of this duration using ISO-8601 seconds
1452      * based representation, such as {@code PT8H6M12.345S}.
1453      * &lt;p&gt;
1454      * The format of the returned string will be {@code PTnHnMnS}, where n is
1455      * the relevant hours, minutes or seconds part of the duration.
1456      * Any fractional seconds are placed after a decimal point in the seconds section.
1457      * If a section has a zero value, it is omitted.
1458      * The hours, minutes and seconds will all have the same sign.
1459      * &lt;p&gt;
1460      * Examples:
1461      * &lt;pre&gt;
1462      *    &quot;20.345 seconds&quot;                 -- &quot;PT20.345S
1463      *    &quot;15 minutes&quot; (15 * 60 seconds)   -- &quot;PT15M&quot;
1464      *    &quot;10 hours&quot; (10 * 3600 seconds)   -- &quot;PT10H&quot;
1465      *    &quot;2 days&quot; (2 * 86400 seconds)     -- &quot;PT48H&quot;
1466      * &lt;/pre&gt;
1467      * Note that multiples of 24 hours are not output as days to avoid confusion
1468      * with {@code Period}.
1469      *
1470      * @return an ISO-8601 representation of this duration, not null
1471      */
1472     @Override
1473     public String toString() {
1474         if (this == ZERO) {
1475             return &quot;PT0S&quot;;
1476         }
1477         long effectiveTotalSecs = seconds;
1478         if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
1479             effectiveTotalSecs++;
1480         }
1481         long hours = effectiveTotalSecs / SECONDS_PER_HOUR;
1482         int minutes = (int) ((effectiveTotalSecs % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);
1483         int secs = (int) (effectiveTotalSecs % SECONDS_PER_MINUTE);
1484         StringBuilder buf = new StringBuilder(24);
1485         buf.append(&quot;PT&quot;);
1486         if (hours != 0) {
1487             buf.append(hours).append(&#39;H&#39;);
1488         }
1489         if (minutes != 0) {
1490             buf.append(minutes).append(&#39;M&#39;);
1491         }
1492         if (secs == 0 &amp;&amp; nanos == 0 &amp;&amp; buf.length() &gt; 2) {
1493             return buf.toString();
1494         }
1495         if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
1496             if (secs == 0) {
1497                 buf.append(&quot;-0&quot;);
1498             } else {
1499                 buf.append(secs);
1500             }
1501         } else {
1502             buf.append(secs);
1503         }
1504         if (nanos &gt; 0) {
1505             int pos = buf.length();
1506             if (seconds &lt; 0) {
1507                 buf.append(2 * NANOS_PER_SECOND - nanos);
1508             } else {
1509                 buf.append(nanos + NANOS_PER_SECOND);
1510             }
1511             while (buf.charAt(buf.length() - 1) == &#39;0&#39;) {
1512                 buf.setLength(buf.length() - 1);
1513             }
1514             buf.setCharAt(pos, &#39;.&#39;);
1515         }
1516         buf.append(&#39;S&#39;);
1517         return buf.toString();
1518     }
1519 
1520     //-----------------------------------------------------------------------
1521     /**
1522      * Writes the object using a
1523      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1524      * @serialData
1525      * &lt;pre&gt;
1526      *  out.writeByte(1);  // identifies a Duration
1527      *  out.writeLong(seconds);
1528      *  out.writeInt(nanos);
1529      * &lt;/pre&gt;
1530      *
1531      * @return the instance of {@code Ser}, not null
1532      */
<a name="3" id="anc3"></a><span class="line-added">1533     @java.io.Serial</span>
1534     private Object writeReplace() {
1535         return new Ser(Ser.DURATION_TYPE, this);
1536     }
1537 
1538     /**
1539      * Defend against malicious streams.
1540      *
1541      * @param s the stream to read
1542      * @throws InvalidObjectException always
1543      */
<a name="4" id="anc4"></a><span class="line-added">1544     @java.io.Serial</span>
1545     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1546         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1547     }
1548 
1549     void writeExternal(DataOutput out) throws IOException {
1550         out.writeLong(seconds);
1551         out.writeInt(nanos);
1552     }
1553 
1554     static Duration readExternal(DataInput in) throws IOException {
1555         long seconds = in.readLong();
1556         int nanos = in.readInt();
1557         return Duration.ofSeconds(seconds, nanos);
1558     }
1559 
1560 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/DataInput.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CharConversionException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/DataInput.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 31  * reconstructing from them data in any of
 32  * the Java primitive types. There is also
 33  * a
 34  * facility for reconstructing a {@code String}
 35  * from data in
 36  * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 37  * format.
 38  * &lt;p&gt;
 39  * It is generally true of all the reading
 40  * routines in this interface that if end of
 41  * file is reached before the desired number
 42  * of bytes has been read, an {@code EOFException}
 43  * (which is a kind of {@code IOException})
 44  * is thrown. If any byte cannot be read for
 45  * any reason other than end of file, an {@code IOException}
 46  * other than {@code EOFException} is
 47  * thrown. In particular, an {@code IOException}
 48  * may be thrown if the input stream has been
 49  * closed.
 50  *
<span class="line-modified"> 51  * &lt;h3&gt;&lt;a id=&quot;modified-utf-8&quot;&gt;Modified UTF-8&lt;/a&gt;&lt;/h3&gt;</span>
 52  * &lt;p&gt;
 53  * Implementations of the DataInput and DataOutput interfaces represent
 54  * Unicode strings in a format that is a slight modification of UTF-8.
 55  * (For information regarding the standard UTF-8 format, see section
 56  * &lt;i&gt;3.9 Unicode Encoding Forms&lt;/i&gt; of &lt;i&gt;The Unicode Standard, Version
 57  * 4.0&lt;/i&gt;)
 58  *
 59  * &lt;ul&gt;
 60  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0001&#39;} to
 61  *         {@code &#39;\u005Cu007F&#39;} are represented by a single byte.
 62  * &lt;li&gt;The null character {@code &#39;\u005Cu0000&#39;} and characters
 63  *         in the range {@code &#39;\u005Cu0080&#39;} to {@code &#39;\u005Cu07FF&#39;} are
 64  *         represented by a pair of bytes.
 65  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0800&#39;}
 66  *         to {@code &#39;\u005CuFFFF&#39;} are represented by three bytes.
 67  * &lt;/ul&gt;
 68  *
 69  *   &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em;&quot;&gt;
 70  *     &lt;caption&gt;Encoding of UTF-8 values&lt;/caption&gt;
 71  *     &lt;thead&gt;
</pre>
<hr />
<pre>
137  *     &lt;/tr&gt;
138  *     &lt;/tbody&gt;
139  *   &lt;/table&gt;
140  *
141  * &lt;p&gt;
142  * The differences between this format and the
143  * standard UTF-8 format are the following:
144  * &lt;ul&gt;
145  * &lt;li&gt;The null byte {@code &#39;\u005Cu0000&#39;} is encoded in 2-byte format
146  *     rather than 1-byte, so that the encoded strings never have
147  *     embedded nulls.
148  * &lt;li&gt;Only the 1-byte, 2-byte, and 3-byte formats are used.
149  * &lt;li&gt;&lt;a href=&quot;../lang/Character.html#unicode&quot;&gt;Supplementary characters&lt;/a&gt;
150  *     are represented in the form of surrogate pairs.
151  * &lt;/ul&gt;
152  * @author  Frank Yellin
153  * @see     java.io.DataInputStream
154  * @see     java.io.DataOutput
155  * @since   1.0
156  */
<span class="line-modified">157 public</span>
<span class="line-removed">158 interface DataInput {</span>
159     /**
160      * Reads some bytes from an input
161      * stream and stores them into the buffer
162      * array {@code b}. The number of bytes
163      * read is equal
164      * to the length of {@code b}.
165      * &lt;p&gt;
166      * This method blocks until one of the
167      * following conditions occurs:
168      * &lt;ul&gt;
169      * &lt;li&gt;{@code b.length}
170      * bytes of input data are available, in which
171      * case a normal return is made.
172      *
173      * &lt;li&gt;End of
174      * file is detected, in which case an {@code EOFException}
175      * is thrown.
176      *
177      * &lt;li&gt;An I/O error occurs, in
178      * which case an {@code IOException} other
</pre>
<hr />
<pre>
251 
252     /**
253      * Makes an attempt to skip over
254      * {@code n} bytes
255      * of data from the input
256      * stream, discarding the skipped bytes. However,
257      * it may skip
258      * over some smaller number of
259      * bytes, possibly zero. This may result from
260      * any of a
261      * number of conditions; reaching
262      * end of file before {@code n} bytes
263      * have been skipped is
264      * only one possibility.
265      * This method never throws an {@code EOFException}.
266      * The actual
267      * number of bytes skipped is returned.
268      *
269      * @param      n   the number of bytes to be skipped.
270      * @return     the number of bytes actually skipped.
<span class="line-modified">271      * @exception  IOException   if an I/O error occurs.</span>
272      */
273     int skipBytes(int n) throws IOException;
274 
275     /**
276      * Reads one input byte and returns
277      * {@code true} if that byte is nonzero,
278      * {@code false} if that byte is zero.
279      * This method is suitable for reading
280      * the byte written by the {@code writeBoolean}
281      * method of interface {@code DataOutput}.
282      *
283      * @return     the {@code boolean} value read.
<span class="line-modified">284      * @exception  EOFException  if this stream reaches the end before reading</span>
285      *               all the bytes.
<span class="line-modified">286      * @exception  IOException   if an I/O error occurs.</span>
287      */
288     boolean readBoolean() throws IOException;
289 
290     /**
291      * Reads and returns one input byte.
292      * The byte is treated as a signed value in
293      * the range {@code -128} through {@code 127},
294      * inclusive.
295      * This method is suitable for
296      * reading the byte written by the {@code writeByte}
297      * method of interface {@code DataOutput}.
298      *
299      * @return     the 8-bit value read.
<span class="line-modified">300      * @exception  EOFException  if this stream reaches the end before reading</span>
301      *               all the bytes.
<span class="line-modified">302      * @exception  IOException   if an I/O error occurs.</span>
303      */
304     byte readByte() throws IOException;
305 
306     /**
307      * Reads one input byte, zero-extends
308      * it to type {@code int}, and returns
309      * the result, which is therefore in the range
310      * {@code 0}
311      * through {@code 255}.
312      * This method is suitable for reading
313      * the byte written by the {@code writeByte}
314      * method of interface {@code DataOutput}
315      * if the argument to {@code writeByte}
316      * was intended to be a value in the range
317      * {@code 0} through {@code 255}.
318      *
319      * @return     the unsigned 8-bit value read.
<span class="line-modified">320      * @exception  EOFException  if this stream reaches the end before reading</span>
321      *               all the bytes.
<span class="line-modified">322      * @exception  IOException   if an I/O error occurs.</span>
323      */
324     int readUnsignedByte() throws IOException;
325 
326     /**
327      * Reads two input bytes and returns
328      * a {@code short} value. Let {@code a}
329      * be the first byte read and {@code b}
330      * be the second byte. The value
331      * returned
332      * is:
333      * &lt;pre&gt;{@code (short)((a &lt;&lt; 8) | (b &amp; 0xff))
334      * }&lt;/pre&gt;
335      * This method
336      * is suitable for reading the bytes written
337      * by the {@code writeShort} method of
338      * interface {@code DataOutput}.
339      *
340      * @return     the 16-bit value read.
<span class="line-modified">341      * @exception  EOFException  if this stream reaches the end before reading</span>
342      *               all the bytes.
<span class="line-modified">343      * @exception  IOException   if an I/O error occurs.</span>
344      */
345     short readShort() throws IOException;
346 
347     /**
348      * Reads two input bytes and returns
349      * an {@code int} value in the range {@code 0}
350      * through {@code 65535}. Let {@code a}
351      * be the first byte read and
352      * {@code b}
353      * be the second byte. The value returned is:
354      * &lt;pre&gt;{@code (((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
355      * }&lt;/pre&gt;
356      * This method is suitable for reading the bytes
357      * written by the {@code writeShort} method
358      * of interface {@code DataOutput}  if
359      * the argument to {@code writeShort}
360      * was intended to be a value in the range
361      * {@code 0} through {@code 65535}.
362      *
363      * @return     the unsigned 16-bit value read.
<span class="line-modified">364      * @exception  EOFException  if this stream reaches the end before reading</span>
365      *               all the bytes.
<span class="line-modified">366      * @exception  IOException   if an I/O error occurs.</span>
367      */
368     int readUnsignedShort() throws IOException;
369 
370     /**
371      * Reads two input bytes and returns a {@code char} value.
372      * Let {@code a}
373      * be the first byte read and {@code b}
374      * be the second byte. The value
375      * returned is:
376      * &lt;pre&gt;{@code (char)((a &lt;&lt; 8) | (b &amp; 0xff))
377      * }&lt;/pre&gt;
378      * This method
379      * is suitable for reading bytes written by
380      * the {@code writeChar} method of interface
381      * {@code DataOutput}.
382      *
383      * @return     the {@code char} value read.
<span class="line-modified">384      * @exception  EOFException  if this stream reaches the end before reading</span>
385      *               all the bytes.
<span class="line-modified">386      * @exception  IOException   if an I/O error occurs.</span>
387      */
388     char readChar() throws IOException;
389 
390     /**
391      * Reads four input bytes and returns an
392      * {@code int} value. Let {@code a-d}
393      * be the first through fourth bytes read. The value returned is:
394      * &lt;pre&gt;{@code
395      * (((a &amp; 0xff) &lt;&lt; 24) | ((b &amp; 0xff) &lt;&lt; 16) |
396      *  ((c &amp; 0xff) &lt;&lt;  8) | (d &amp; 0xff))
397      * }&lt;/pre&gt;
398      * This method is suitable
399      * for reading bytes written by the {@code writeInt}
400      * method of interface {@code DataOutput}.
401      *
402      * @return     the {@code int} value read.
<span class="line-modified">403      * @exception  EOFException  if this stream reaches the end before reading</span>
404      *               all the bytes.
<span class="line-modified">405      * @exception  IOException   if an I/O error occurs.</span>
406      */
407     int readInt() throws IOException;
408 
409     /**
410      * Reads eight input bytes and returns
411      * a {@code long} value. Let {@code a-h}
412      * be the first through eighth bytes read.
413      * The value returned is:
414      * &lt;pre&gt;{@code
415      * (((long)(a &amp; 0xff) &lt;&lt; 56) |
416      *  ((long)(b &amp; 0xff) &lt;&lt; 48) |
417      *  ((long)(c &amp; 0xff) &lt;&lt; 40) |
418      *  ((long)(d &amp; 0xff) &lt;&lt; 32) |
419      *  ((long)(e &amp; 0xff) &lt;&lt; 24) |
420      *  ((long)(f &amp; 0xff) &lt;&lt; 16) |
421      *  ((long)(g &amp; 0xff) &lt;&lt;  8) |
422      *  ((long)(h &amp; 0xff)))
423      * }&lt;/pre&gt;
424      * &lt;p&gt;
425      * This method is suitable
426      * for reading bytes written by the {@code writeLong}
427      * method of interface {@code DataOutput}.
428      *
429      * @return     the {@code long} value read.
<span class="line-modified">430      * @exception  EOFException  if this stream reaches the end before reading</span>
431      *               all the bytes.
<span class="line-modified">432      * @exception  IOException   if an I/O error occurs.</span>
433      */
434     long readLong() throws IOException;
435 
436     /**
437      * Reads four input bytes and returns
438      * a {@code float} value. It does this
439      * by first constructing an {@code int}
440      * value in exactly the manner
441      * of the {@code readInt}
442      * method, then converting this {@code int}
443      * value to a {@code float} in
444      * exactly the manner of the method {@code Float.intBitsToFloat}.
445      * This method is suitable for reading
446      * bytes written by the {@code writeFloat}
447      * method of interface {@code DataOutput}.
448      *
449      * @return     the {@code float} value read.
<span class="line-modified">450      * @exception  EOFException  if this stream reaches the end before reading</span>
451      *               all the bytes.
<span class="line-modified">452      * @exception  IOException   if an I/O error occurs.</span>
453      */
454     float readFloat() throws IOException;
455 
456     /**
457      * Reads eight input bytes and returns
458      * a {@code double} value. It does this
459      * by first constructing a {@code long}
460      * value in exactly the manner
461      * of the {@code readLong}
462      * method, then converting this {@code long}
463      * value to a {@code double} in exactly
464      * the manner of the method {@code Double.longBitsToDouble}.
465      * This method is suitable for reading
466      * bytes written by the {@code writeDouble}
467      * method of interface {@code DataOutput}.
468      *
469      * @return     the {@code double} value read.
<span class="line-modified">470      * @exception  EOFException  if this stream reaches the end before reading</span>
471      *               all the bytes.
<span class="line-modified">472      * @exception  IOException   if an I/O error occurs.</span>
473      */
474     double readDouble() throws IOException;
475 
476     /**
477      * Reads the next line of text from the input stream.
478      * It reads successive bytes, converting
479      * each byte separately into a character,
480      * until it encounters a line terminator or
481      * end of
482      * file; the characters read are then
483      * returned as a {@code String}. Note
484      * that because this
485      * method processes bytes,
486      * it does not support input of the full Unicode
487      * character set.
488      * &lt;p&gt;
489      * If end of file is encountered
490      * before even one byte can be read, then {@code null}
491      * is returned. Otherwise, each byte that is
492      * read is converted to type {@code char}
493      * by zero-extension. If the character {@code &#39;\n&#39;}
494      * is encountered, it is discarded and reading
495      * ceases. If the character {@code &#39;\r&#39;}
496      * is encountered, it is discarded and, if
497      * the following byte converts &amp;#32;to the
498      * character {@code &#39;\n&#39;}, then that is
499      * discarded also; reading then ceases. If
500      * end of file is encountered before either
501      * of the characters {@code &#39;\n&#39;} and
502      * {@code &#39;\r&#39;} is encountered, reading
503      * ceases. Once reading has ceased, a {@code String}
504      * is returned that contains all the characters
505      * read and not discarded, taken in order.
506      * Note that every character in this string
507      * will have a value less than {@code \u005Cu0100},
508      * that is, {@code (char)256}.
509      *
510      * @return the next line of text from the input stream,
511      *         or {@code null} if the end of file is
512      *         encountered before a byte can be read.
<span class="line-modified">513      * @exception  IOException  if an I/O error occurs.</span>
514      */
515     String readLine() throws IOException;
516 
517     /**
518      * Reads in a string that has been encoded using a
519      * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
520      * format.
521      * The general contract of {@code readUTF}
522      * is that it reads a representation of a Unicode
523      * character string encoded in modified
524      * UTF-8 format; this string of characters
525      * is then returned as a {@code String}.
526      * &lt;p&gt;
527      * First, two bytes are read and used to
528      * construct an unsigned 16-bit integer in
529      * exactly the manner of the {@code readUnsignedShort}
530      * method . This integer value is called the
531      * &lt;i&gt;UTF length&lt;/i&gt; and specifies the number
532      * of additional bytes to be read. These bytes
533      * are then converted to characters by considering
</pre>
<hr />
<pre>
576      * pattern {@code 1111xxxx} or the pattern
577      * {@code 10xxxxxx}, then a {@code UTFDataFormatException}
578      * is thrown.
579      * &lt;p&gt;
580      * If end of file is encountered
581      * at any time during this entire process,
582      * then an {@code EOFException} is thrown.
583      * &lt;p&gt;
584      * After every group has been converted to
585      * a character by this process, the characters
586      * are gathered, in the same order in which
587      * their corresponding groups were read from
588      * the input stream, to form a {@code String},
589      * which is returned.
590      * &lt;p&gt;
591      * The {@code writeUTF}
592      * method of interface {@code DataOutput}
593      * may be used to write data that is suitable
594      * for reading by this method.
595      * @return     a Unicode string.
<span class="line-modified">596      * @exception  EOFException            if this stream reaches the end</span>
597      *               before reading all the bytes.
<span class="line-modified">598      * @exception  IOException             if an I/O error occurs.</span>
<span class="line-modified">599      * @exception  UTFDataFormatException  if the bytes do not represent a</span>
600      *               valid modified UTF-8 encoding of a string.
601      */
602     String readUTF() throws IOException;
603 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 31  * reconstructing from them data in any of
 32  * the Java primitive types. There is also
 33  * a
 34  * facility for reconstructing a {@code String}
 35  * from data in
 36  * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 37  * format.
 38  * &lt;p&gt;
 39  * It is generally true of all the reading
 40  * routines in this interface that if end of
 41  * file is reached before the desired number
 42  * of bytes has been read, an {@code EOFException}
 43  * (which is a kind of {@code IOException})
 44  * is thrown. If any byte cannot be read for
 45  * any reason other than end of file, an {@code IOException}
 46  * other than {@code EOFException} is
 47  * thrown. In particular, an {@code IOException}
 48  * may be thrown if the input stream has been
 49  * closed.
 50  *
<span class="line-modified"> 51  * &lt;h2&gt;&lt;a id=&quot;modified-utf-8&quot;&gt;Modified UTF-8&lt;/a&gt;&lt;/h2&gt;</span>
 52  * &lt;p&gt;
 53  * Implementations of the DataInput and DataOutput interfaces represent
 54  * Unicode strings in a format that is a slight modification of UTF-8.
 55  * (For information regarding the standard UTF-8 format, see section
 56  * &lt;i&gt;3.9 Unicode Encoding Forms&lt;/i&gt; of &lt;i&gt;The Unicode Standard, Version
 57  * 4.0&lt;/i&gt;)
 58  *
 59  * &lt;ul&gt;
 60  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0001&#39;} to
 61  *         {@code &#39;\u005Cu007F&#39;} are represented by a single byte.
 62  * &lt;li&gt;The null character {@code &#39;\u005Cu0000&#39;} and characters
 63  *         in the range {@code &#39;\u005Cu0080&#39;} to {@code &#39;\u005Cu07FF&#39;} are
 64  *         represented by a pair of bytes.
 65  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0800&#39;}
 66  *         to {@code &#39;\u005CuFFFF&#39;} are represented by three bytes.
 67  * &lt;/ul&gt;
 68  *
 69  *   &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em;&quot;&gt;
 70  *     &lt;caption&gt;Encoding of UTF-8 values&lt;/caption&gt;
 71  *     &lt;thead&gt;
</pre>
<hr />
<pre>
137  *     &lt;/tr&gt;
138  *     &lt;/tbody&gt;
139  *   &lt;/table&gt;
140  *
141  * &lt;p&gt;
142  * The differences between this format and the
143  * standard UTF-8 format are the following:
144  * &lt;ul&gt;
145  * &lt;li&gt;The null byte {@code &#39;\u005Cu0000&#39;} is encoded in 2-byte format
146  *     rather than 1-byte, so that the encoded strings never have
147  *     embedded nulls.
148  * &lt;li&gt;Only the 1-byte, 2-byte, and 3-byte formats are used.
149  * &lt;li&gt;&lt;a href=&quot;../lang/Character.html#unicode&quot;&gt;Supplementary characters&lt;/a&gt;
150  *     are represented in the form of surrogate pairs.
151  * &lt;/ul&gt;
152  * @author  Frank Yellin
153  * @see     java.io.DataInputStream
154  * @see     java.io.DataOutput
155  * @since   1.0
156  */
<span class="line-modified">157 public interface DataInput {</span>

158     /**
159      * Reads some bytes from an input
160      * stream and stores them into the buffer
161      * array {@code b}. The number of bytes
162      * read is equal
163      * to the length of {@code b}.
164      * &lt;p&gt;
165      * This method blocks until one of the
166      * following conditions occurs:
167      * &lt;ul&gt;
168      * &lt;li&gt;{@code b.length}
169      * bytes of input data are available, in which
170      * case a normal return is made.
171      *
172      * &lt;li&gt;End of
173      * file is detected, in which case an {@code EOFException}
174      * is thrown.
175      *
176      * &lt;li&gt;An I/O error occurs, in
177      * which case an {@code IOException} other
</pre>
<hr />
<pre>
250 
251     /**
252      * Makes an attempt to skip over
253      * {@code n} bytes
254      * of data from the input
255      * stream, discarding the skipped bytes. However,
256      * it may skip
257      * over some smaller number of
258      * bytes, possibly zero. This may result from
259      * any of a
260      * number of conditions; reaching
261      * end of file before {@code n} bytes
262      * have been skipped is
263      * only one possibility.
264      * This method never throws an {@code EOFException}.
265      * The actual
266      * number of bytes skipped is returned.
267      *
268      * @param      n   the number of bytes to be skipped.
269      * @return     the number of bytes actually skipped.
<span class="line-modified">270      * @throws     IOException   if an I/O error occurs.</span>
271      */
272     int skipBytes(int n) throws IOException;
273 
274     /**
275      * Reads one input byte and returns
276      * {@code true} if that byte is nonzero,
277      * {@code false} if that byte is zero.
278      * This method is suitable for reading
279      * the byte written by the {@code writeBoolean}
280      * method of interface {@code DataOutput}.
281      *
282      * @return     the {@code boolean} value read.
<span class="line-modified">283      * @throws     EOFException  if this stream reaches the end before reading</span>
284      *               all the bytes.
<span class="line-modified">285      * @throws     IOException   if an I/O error occurs.</span>
286      */
287     boolean readBoolean() throws IOException;
288 
289     /**
290      * Reads and returns one input byte.
291      * The byte is treated as a signed value in
292      * the range {@code -128} through {@code 127},
293      * inclusive.
294      * This method is suitable for
295      * reading the byte written by the {@code writeByte}
296      * method of interface {@code DataOutput}.
297      *
298      * @return     the 8-bit value read.
<span class="line-modified">299      * @throws     EOFException  if this stream reaches the end before reading</span>
300      *               all the bytes.
<span class="line-modified">301      * @throws     IOException   if an I/O error occurs.</span>
302      */
303     byte readByte() throws IOException;
304 
305     /**
306      * Reads one input byte, zero-extends
307      * it to type {@code int}, and returns
308      * the result, which is therefore in the range
309      * {@code 0}
310      * through {@code 255}.
311      * This method is suitable for reading
312      * the byte written by the {@code writeByte}
313      * method of interface {@code DataOutput}
314      * if the argument to {@code writeByte}
315      * was intended to be a value in the range
316      * {@code 0} through {@code 255}.
317      *
318      * @return     the unsigned 8-bit value read.
<span class="line-modified">319      * @throws     EOFException  if this stream reaches the end before reading</span>
320      *               all the bytes.
<span class="line-modified">321      * @throws     IOException   if an I/O error occurs.</span>
322      */
323     int readUnsignedByte() throws IOException;
324 
325     /**
326      * Reads two input bytes and returns
327      * a {@code short} value. Let {@code a}
328      * be the first byte read and {@code b}
329      * be the second byte. The value
330      * returned
331      * is:
332      * &lt;pre&gt;{@code (short)((a &lt;&lt; 8) | (b &amp; 0xff))
333      * }&lt;/pre&gt;
334      * This method
335      * is suitable for reading the bytes written
336      * by the {@code writeShort} method of
337      * interface {@code DataOutput}.
338      *
339      * @return     the 16-bit value read.
<span class="line-modified">340      * @throws     EOFException  if this stream reaches the end before reading</span>
341      *               all the bytes.
<span class="line-modified">342      * @throws     IOException   if an I/O error occurs.</span>
343      */
344     short readShort() throws IOException;
345 
346     /**
347      * Reads two input bytes and returns
348      * an {@code int} value in the range {@code 0}
349      * through {@code 65535}. Let {@code a}
350      * be the first byte read and
351      * {@code b}
352      * be the second byte. The value returned is:
353      * &lt;pre&gt;{@code (((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
354      * }&lt;/pre&gt;
355      * This method is suitable for reading the bytes
356      * written by the {@code writeShort} method
357      * of interface {@code DataOutput}  if
358      * the argument to {@code writeShort}
359      * was intended to be a value in the range
360      * {@code 0} through {@code 65535}.
361      *
362      * @return     the unsigned 16-bit value read.
<span class="line-modified">363      * @throws     EOFException  if this stream reaches the end before reading</span>
364      *               all the bytes.
<span class="line-modified">365      * @throws     IOException   if an I/O error occurs.</span>
366      */
367     int readUnsignedShort() throws IOException;
368 
369     /**
370      * Reads two input bytes and returns a {@code char} value.
371      * Let {@code a}
372      * be the first byte read and {@code b}
373      * be the second byte. The value
374      * returned is:
375      * &lt;pre&gt;{@code (char)((a &lt;&lt; 8) | (b &amp; 0xff))
376      * }&lt;/pre&gt;
377      * This method
378      * is suitable for reading bytes written by
379      * the {@code writeChar} method of interface
380      * {@code DataOutput}.
381      *
382      * @return     the {@code char} value read.
<span class="line-modified">383      * @throws     EOFException  if this stream reaches the end before reading</span>
384      *               all the bytes.
<span class="line-modified">385      * @throws     IOException   if an I/O error occurs.</span>
386      */
387     char readChar() throws IOException;
388 
389     /**
390      * Reads four input bytes and returns an
391      * {@code int} value. Let {@code a-d}
392      * be the first through fourth bytes read. The value returned is:
393      * &lt;pre&gt;{@code
394      * (((a &amp; 0xff) &lt;&lt; 24) | ((b &amp; 0xff) &lt;&lt; 16) |
395      *  ((c &amp; 0xff) &lt;&lt;  8) | (d &amp; 0xff))
396      * }&lt;/pre&gt;
397      * This method is suitable
398      * for reading bytes written by the {@code writeInt}
399      * method of interface {@code DataOutput}.
400      *
401      * @return     the {@code int} value read.
<span class="line-modified">402      * @throws     EOFException  if this stream reaches the end before reading</span>
403      *               all the bytes.
<span class="line-modified">404      * @throws     IOException   if an I/O error occurs.</span>
405      */
406     int readInt() throws IOException;
407 
408     /**
409      * Reads eight input bytes and returns
410      * a {@code long} value. Let {@code a-h}
411      * be the first through eighth bytes read.
412      * The value returned is:
413      * &lt;pre&gt;{@code
414      * (((long)(a &amp; 0xff) &lt;&lt; 56) |
415      *  ((long)(b &amp; 0xff) &lt;&lt; 48) |
416      *  ((long)(c &amp; 0xff) &lt;&lt; 40) |
417      *  ((long)(d &amp; 0xff) &lt;&lt; 32) |
418      *  ((long)(e &amp; 0xff) &lt;&lt; 24) |
419      *  ((long)(f &amp; 0xff) &lt;&lt; 16) |
420      *  ((long)(g &amp; 0xff) &lt;&lt;  8) |
421      *  ((long)(h &amp; 0xff)))
422      * }&lt;/pre&gt;
423      * &lt;p&gt;
424      * This method is suitable
425      * for reading bytes written by the {@code writeLong}
426      * method of interface {@code DataOutput}.
427      *
428      * @return     the {@code long} value read.
<span class="line-modified">429      * @throws     EOFException  if this stream reaches the end before reading</span>
430      *               all the bytes.
<span class="line-modified">431      * @throws     IOException   if an I/O error occurs.</span>
432      */
433     long readLong() throws IOException;
434 
435     /**
436      * Reads four input bytes and returns
437      * a {@code float} value. It does this
438      * by first constructing an {@code int}
439      * value in exactly the manner
440      * of the {@code readInt}
441      * method, then converting this {@code int}
442      * value to a {@code float} in
443      * exactly the manner of the method {@code Float.intBitsToFloat}.
444      * This method is suitable for reading
445      * bytes written by the {@code writeFloat}
446      * method of interface {@code DataOutput}.
447      *
448      * @return     the {@code float} value read.
<span class="line-modified">449      * @throws     EOFException  if this stream reaches the end before reading</span>
450      *               all the bytes.
<span class="line-modified">451      * @throws     IOException   if an I/O error occurs.</span>
452      */
453     float readFloat() throws IOException;
454 
455     /**
456      * Reads eight input bytes and returns
457      * a {@code double} value. It does this
458      * by first constructing a {@code long}
459      * value in exactly the manner
460      * of the {@code readLong}
461      * method, then converting this {@code long}
462      * value to a {@code double} in exactly
463      * the manner of the method {@code Double.longBitsToDouble}.
464      * This method is suitable for reading
465      * bytes written by the {@code writeDouble}
466      * method of interface {@code DataOutput}.
467      *
468      * @return     the {@code double} value read.
<span class="line-modified">469      * @throws     EOFException  if this stream reaches the end before reading</span>
470      *               all the bytes.
<span class="line-modified">471      * @throws     IOException   if an I/O error occurs.</span>
472      */
473     double readDouble() throws IOException;
474 
475     /**
476      * Reads the next line of text from the input stream.
477      * It reads successive bytes, converting
478      * each byte separately into a character,
479      * until it encounters a line terminator or
480      * end of
481      * file; the characters read are then
482      * returned as a {@code String}. Note
483      * that because this
484      * method processes bytes,
485      * it does not support input of the full Unicode
486      * character set.
487      * &lt;p&gt;
488      * If end of file is encountered
489      * before even one byte can be read, then {@code null}
490      * is returned. Otherwise, each byte that is
491      * read is converted to type {@code char}
492      * by zero-extension. If the character {@code &#39;\n&#39;}
493      * is encountered, it is discarded and reading
494      * ceases. If the character {@code &#39;\r&#39;}
495      * is encountered, it is discarded and, if
496      * the following byte converts &amp;#32;to the
497      * character {@code &#39;\n&#39;}, then that is
498      * discarded also; reading then ceases. If
499      * end of file is encountered before either
500      * of the characters {@code &#39;\n&#39;} and
501      * {@code &#39;\r&#39;} is encountered, reading
502      * ceases. Once reading has ceased, a {@code String}
503      * is returned that contains all the characters
504      * read and not discarded, taken in order.
505      * Note that every character in this string
506      * will have a value less than {@code \u005Cu0100},
507      * that is, {@code (char)256}.
508      *
509      * @return the next line of text from the input stream,
510      *         or {@code null} if the end of file is
511      *         encountered before a byte can be read.
<span class="line-modified">512      * @throws IOException  if an I/O error occurs.</span>
513      */
514     String readLine() throws IOException;
515 
516     /**
517      * Reads in a string that has been encoded using a
518      * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
519      * format.
520      * The general contract of {@code readUTF}
521      * is that it reads a representation of a Unicode
522      * character string encoded in modified
523      * UTF-8 format; this string of characters
524      * is then returned as a {@code String}.
525      * &lt;p&gt;
526      * First, two bytes are read and used to
527      * construct an unsigned 16-bit integer in
528      * exactly the manner of the {@code readUnsignedShort}
529      * method . This integer value is called the
530      * &lt;i&gt;UTF length&lt;/i&gt; and specifies the number
531      * of additional bytes to be read. These bytes
532      * are then converted to characters by considering
</pre>
<hr />
<pre>
575      * pattern {@code 1111xxxx} or the pattern
576      * {@code 10xxxxxx}, then a {@code UTFDataFormatException}
577      * is thrown.
578      * &lt;p&gt;
579      * If end of file is encountered
580      * at any time during this entire process,
581      * then an {@code EOFException} is thrown.
582      * &lt;p&gt;
583      * After every group has been converted to
584      * a character by this process, the characters
585      * are gathered, in the same order in which
586      * their corresponding groups were read from
587      * the input stream, to form a {@code String},
588      * which is returned.
589      * &lt;p&gt;
590      * The {@code writeUTF}
591      * method of interface {@code DataOutput}
592      * may be used to write data that is suitable
593      * for reading by this method.
594      * @return     a Unicode string.
<span class="line-modified">595      * @throws     EOFException            if this stream reaches the end</span>
596      *               before reading all the bytes.
<span class="line-modified">597      * @throws     IOException             if an I/O error occurs.</span>
<span class="line-modified">598      * @throws     UTFDataFormatException  if the bytes do not represent a</span>
599      *               valid modified UTF-8 encoding of a string.
600      */
601     String readUTF() throws IOException;
602 }
</pre>
</td>
</tr>
</table>
<center><a href="CharConversionException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DataInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
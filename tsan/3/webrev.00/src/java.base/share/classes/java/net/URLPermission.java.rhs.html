<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/URLPermission.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.ObjectInputStream;
 29 import java.io.IOException;
 30 import java.util.List;
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.security.Permission;
 34 
 35 /**
 36  * Represents permission to access a resource or set of resources defined by a
 37  * given url, and for a given set of user-settable request methods
 38  * and request headers. The &lt;i&gt;name&lt;/i&gt; of the permission is the url string.
 39  * The &lt;i&gt;actions&lt;/i&gt; string is a concatenation of the request methods and headers.
 40  * The range of method and header names is not restricted by this class.
 41  * &lt;p&gt;&lt;b&gt;The url&lt;/b&gt;&lt;p&gt;
 42  * The url string has the following expected structure.
 43  * &lt;pre&gt;
 44  *     scheme : // authority [ / path ] [ ignored-query-or-fragment ]
 45  * &lt;/pre&gt;
 46  * &lt;i&gt;scheme&lt;/i&gt; will typically be http or https, but is not restricted by this
 47  * class.
 48  * &lt;i&gt;authority&lt;/i&gt; is specified as:
 49  * &lt;pre&gt;
 50  *     authority = [ userinfo @ ] hostrange [ : portrange ]
 51  *     portrange = portnumber | -portnumber | portnumber-[portnumber] | *
 52  *     hostrange = ([*.] dnsname) | IPv4address | IPv6address
 53  * &lt;/pre&gt;
 54  * &lt;i&gt;dnsname&lt;/i&gt; is a standard DNS host or domain name, i.e. one or more labels
 55  * separated by &quot;.&quot;. &lt;i&gt;IPv4address&lt;/i&gt; is a standard literal IPv4 address and
 56  * &lt;i&gt;IPv6address&lt;/i&gt; is as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;
 57  * RFC 2732&lt;/a&gt;. Literal IPv6 addresses must however, be enclosed in &#39;[]&#39; characters.
 58  * The &lt;i&gt;dnsname&lt;/i&gt; specification can be preceded by &quot;*.&quot; which means
 59  * the name will match any hostname whose right-most domain labels are the same as
 60  * this name. For example, &quot;*.example.com&quot; matches &quot;foo.bar.example.com&quot;
 61  * &lt;p&gt;
 62  * &lt;i&gt;portrange&lt;/i&gt; is used to specify a port number, or a bounded or unbounded range of ports
 63  * that this permission applies to. If portrange is absent or invalid, then a default
 64  * port number is assumed if the scheme is {@code http} (default 80) or {@code https}
 65  * (default 443). No default is assumed for other schemes. A wildcard may be specified
 66  * which means all ports.
 67  * &lt;p&gt;
 68  * &lt;i&gt;userinfo&lt;/i&gt; is optional. A userinfo component if present, is ignored when
 69  * creating a URLPermission, and has no effect on any other methods defined by this class.
 70  * &lt;p&gt;
 71  * The &lt;i&gt;path&lt;/i&gt; component comprises a sequence of path segments,
 72  * separated by &#39;/&#39; characters. &lt;i&gt;path&lt;/i&gt; may also be empty. The path is specified
 73  * in a similar way to the path in {@link java.io.FilePermission}. There are
 74  * three different ways as the following examples show:
 75  * &lt;table class=&quot;striped&quot;&gt;
 76  * &lt;caption&gt;URL Examples&lt;/caption&gt;
 77  * &lt;thead&gt;
 78  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Example url&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 79  * &lt;/thead&gt;
 80  * &lt;tbody style=&quot;text-align:left&quot;&gt;
 81  * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;white-space:nowrap;&quot;&gt;http://www.example.com/a/b/c.html&lt;/th&gt;
 82  *   &lt;td&gt;A url which identifies a specific (single) resource&lt;/td&gt;
 83  * &lt;/tr&gt;
 84  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;http://www.example.com/a/b/*&lt;/th&gt;
 85  *   &lt;td&gt;The &#39;*&#39; character refers to all resources in the same &quot;directory&quot; - in
 86  *       other words all resources with the same number of path components, and
 87  *       which only differ in the final path component, represented by the &#39;*&#39;.
 88  *   &lt;/td&gt;
 89  * &lt;/tr&gt;
 90  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;http://www.example.com/a/b/-&lt;/th&gt;
 91  *   &lt;td&gt;The &#39;-&#39; character refers to all resources recursively below the
 92  *       preceding path (e.g. http://www.example.com/a/b/c/d/e.html matches this
 93  *       example).
 94  *   &lt;/td&gt;
 95  * &lt;/tr&gt;
 96  * &lt;/tbody&gt;
 97  * &lt;/table&gt;
 98  * &lt;p&gt;
 99  * The &#39;*&#39; and &#39;-&#39; may only be specified in the final segment of a path and must be
100  * the only character in that segment. Any query or fragment components of the
101  * url are ignored when constructing URLPermissions.
102  * &lt;p&gt;
103  * As a special case, urls of the form, &quot;scheme:*&quot; are accepted to
104  * mean any url of the given scheme.
105  * &lt;p&gt;
106  * The &lt;i&gt;scheme&lt;/i&gt; and &lt;i&gt;authority&lt;/i&gt; components of the url string are handled
107  * without regard to case. This means {@link #equals(Object)},
108  * {@link #hashCode()} and {@link #implies(Permission)} are case insensitive with respect
109  * to these components. If the &lt;i&gt;authority&lt;/i&gt; contains a literal IP address,
110  * then the address is normalized for comparison. The path component is case sensitive.
111  * &lt;p&gt;
112  * &lt;i&gt;ignored-query-or-fragment&lt;/i&gt; refers to any query or fragment which appears after the
113  * path component, and which is ignored by the constructors of this class. It is defined as:
114  * &lt;pre&gt;
115  *     ignored-query-or-fragment = [ ? query ] [ # fragment ]
116  * &lt;/pre&gt;
117  * where &lt;i&gt;query&lt;/i&gt; and &lt;i&gt;fragment&lt;/i&gt; are as defined in
118  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2296.txt&quot;&gt;RFC2396&lt;/a&gt;. {@link #getName() getName()} therefore returns
119  * only the &lt;i&gt;scheme&lt;/i&gt;, &lt;i&gt;authority&lt;/i&gt; and &lt;i&gt;path&lt;/i&gt; components of the url string that
120  * the permission was created with.
121  * &lt;p&gt;&lt;b&gt;The actions string&lt;/b&gt;&lt;p&gt;
122  * The actions string of a URLPermission is a concatenation of the &lt;i&gt;method list&lt;/i&gt;
123  * and the &lt;i&gt;request headers list&lt;/i&gt;. These are lists of the permitted request
124  * methods and permitted request headers of the permission (respectively). The two lists
125  * are separated by a colon &#39;:&#39; character and elements of each list are comma separated.
126  * Some examples are:
127  * &lt;ul&gt;
128  * &lt;li&gt;&quot;POST,GET,DELETE&quot;
129  * &lt;li&gt;&quot;GET:X-Foo-Request,X-Bar-Request&quot;
130  * &lt;li&gt;&quot;POST,GET:Header1,Header2&quot;
131  * &lt;/ul&gt;
132  * &lt;p&gt;
133  * The first example specifies the methods: POST, GET and DELETE, but no request headers.
134  * The second example specifies one request method and two headers. The third
135  * example specifies two request methods, and two headers.
136  * &lt;p&gt;
137  * The colon separator need not be present if the request headers list is empty.
138  * No white-space is permitted in the actions string. The action strings supplied to
139  * the URLPermission constructors are case-insensitive and are normalized by converting
140  * method names to upper-case and header names to the form defines in RFC2616 (lower case
141  * with initial letter of each word capitalized). Either list can contain a wild-card &#39;*&#39;
142  * character which signifies all request methods or headers respectively.
143  * &lt;p&gt;
144  * Note. Depending on the context of use, some request methods and headers may be permitted
145  * at all times, and others may not be permitted at any time. For example, the
146  * HTTP protocol handler might disallow certain headers such as Content-Length
147  * from being set by application code, regardless of whether the security policy
148  * in force, permits it.
149  *
150  * @since 1.8
151  */
152 public final class URLPermission extends Permission {
153 
<a name="2" id="anc2"></a><span class="line-added">154     @java.io.Serial</span>
155     private static final long serialVersionUID = -2702463814894478682L;
156 
157     private transient String scheme;
158     private transient String ssp;                 // scheme specific part
159     private transient String path;
160     private transient List&lt;String&gt; methods;
161     private transient List&lt;String&gt; requestHeaders;
162     private transient Authority authority;
163 
164     // serialized field
165     private String actions;
166 
167     /**
168      * Creates a new URLPermission from a url string and which permits the given
169      * request methods and user-settable request headers.
170      * The name of the permission is the url string it was created with. Only the scheme,
171      * authority and path components of the url are used internally. Any fragment or query
172      * components are ignored. The permissions action string is as specified above.
173      *
174      * @param url the url string
175      *
176      * @param actions the actions string
177      *
<a name="3" id="anc3"></a><span class="line-modified">178      * @throws    IllegalArgumentException if url is invalid or if actions contains white-space.</span>
179      */
180     public URLPermission(String url, String actions) {
181         super(normalize(url));
182         init(actions);
183     }
184 
185     /**
186      * Remove any query or fragment from url string
187      */
188     private static String normalize(String url) {
189         int index = url.indexOf(&#39;?&#39;);
190         if (index &gt;= 0) {
191             url = url.substring(0, index);
192         } else {
193             index = url.indexOf(&#39;#&#39;);
194             if (index &gt;= 0) {
195                 url = url.substring(0, index);
196             }
197         }
198         return url;
199     }
200 
201     private void init(String actions) {
202         parseURI(getName());
203         int colon = actions.indexOf(&#39;:&#39;);
204         if (actions.lastIndexOf(&#39;:&#39;) != colon) {
205             throw new IllegalArgumentException(
206                 &quot;Invalid actions string: \&quot;&quot; + actions + &quot;\&quot;&quot;);
207         }
208 
209         String methods, headers;
210         if (colon == -1) {
211             methods = actions;
212             headers = &quot;&quot;;
213         } else {
214             methods = actions.substring(0, colon);
215             headers = actions.substring(colon+1);
216         }
217 
218         List&lt;String&gt; l = normalizeMethods(methods);
219         Collections.sort(l);
220         this.methods = Collections.unmodifiableList(l);
221 
222         l = normalizeHeaders(headers);
223         Collections.sort(l);
224         this.requestHeaders = Collections.unmodifiableList(l);
225 
226         this.actions = actions();
227     }
228 
229     /**
230      * Creates a URLPermission with the given url string and unrestricted
231      * methods and request headers by invoking the two argument
232      * constructor as follows: URLPermission(url, &quot;*:*&quot;)
233      *
234      * @param url the url string
235      *
236      * @throws    IllegalArgumentException if url does not result in a valid {@link URI}
237      */
238     public URLPermission(String url) {
239         this(url, &quot;*:*&quot;);
240     }
241 
242     /**
243      * Returns the normalized method list and request
244      * header list, in the form:
245      * &lt;pre&gt;
246      *      &quot;method-names : header-names&quot;
247      * &lt;/pre&gt;
248      * &lt;p&gt;
249      * where method-names is the list of methods separated by commas
250      * and header-names is the list of permitted headers separated by commas.
251      * There is no white space in the returned String. If header-names is empty
252      * then the colon separator may not be present.
253      */
254     public String getActions() {
255         return actions;
256     }
257 
258     /**
259      * Checks if this URLPermission implies the given permission.
260      * Specifically, the following checks are done as if in the
261      * following sequence:
262      * &lt;ul&gt;
263      * &lt;li&gt;if &#39;p&#39; is not an instance of URLPermission return false&lt;/li&gt;
264      * &lt;li&gt;if any of p&#39;s methods are not in this&#39;s method list, and if
265      *     this&#39;s method list is not equal to &quot;*&quot;, then return false.&lt;/li&gt;
266      * &lt;li&gt;if any of p&#39;s headers are not in this&#39;s request header list, and if
267      *     this&#39;s request header list is not equal to &quot;*&quot;, then return false.&lt;/li&gt;
268      * &lt;li&gt;if this&#39;s url scheme is not equal to p&#39;s url scheme return false&lt;/li&gt;
269      * &lt;li&gt;if the scheme specific part of this&#39;s url is &#39;*&#39; return true&lt;/li&gt;
270      * &lt;li&gt;if the set of hosts defined by p&#39;s url hostrange is not a subset of
271      *     this&#39;s url hostrange then return false. For example, &quot;*.foo.example.com&quot;
272      *     is a subset of &quot;*.example.com&quot;. &quot;foo.bar.example.com&quot; is not
273      *     a subset of &quot;*.foo.example.com&quot;&lt;/li&gt;
274      * &lt;li&gt;if the portrange defined by p&#39;s url is not a subset of the
275      *     portrange defined by this&#39;s url then return false.
276      * &lt;li&gt;if the path or paths specified by p&#39;s url are contained in the
277      *     set of paths specified by this&#39;s url, then return true
278      * &lt;li&gt;otherwise, return false&lt;/li&gt;
279      * &lt;/ul&gt;
280      * &lt;p&gt;Some examples of how paths are matched are shown below:
281      * &lt;table class=&quot;plain&quot;&gt;
282      * &lt;caption&gt;Examples of Path Matching&lt;/caption&gt;
283      * &lt;thead&gt;
284      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;this&#39;s path&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;p&#39;s path&lt;/th&gt;&lt;th&gt;match&lt;/th&gt;&lt;/tr&gt;
285      * &lt;/thead&gt;
286      * &lt;tbody style=&quot;text-align:left&quot;&gt;
287      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;/a/b&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
288      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot;&gt;/a/b/*&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b/c&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
289      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/d&lt;/th&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
290      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/-&lt;/th&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
291      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot;&gt;/a/b/-&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;/a/b/c/d&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
292      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/d/e&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
293      * &lt;tr&gt;  &lt;th scope=&quot;row&quot;&gt;/a/b/c/*&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
294      * &lt;/tbody&gt;
295      * &lt;/table&gt;
296      */
297     public boolean implies(Permission p) {
298         if (! (p instanceof URLPermission)) {
299             return false;
300         }
301 
302         URLPermission that = (URLPermission)p;
303 
304         if (this.methods.isEmpty() &amp;&amp; !that.methods.isEmpty()) {
305             return false;
306         }
307 
308         if (!this.methods.isEmpty() &amp;&amp;
309             !this.methods.get(0).equals(&quot;*&quot;) &amp;&amp;
310             Collections.indexOfSubList(this.methods,
311                                        that.methods) == -1) {
312             return false;
313         }
314 
315         if (this.requestHeaders.isEmpty() &amp;&amp; !that.requestHeaders.isEmpty()) {
316             return false;
317         }
318 
319         if (!this.requestHeaders.isEmpty() &amp;&amp;
320             !this.requestHeaders.get(0).equals(&quot;*&quot;) &amp;&amp;
321              Collections.indexOfSubList(this.requestHeaders,
322                                         that.requestHeaders) == -1) {
323             return false;
324         }
325 
326         if (!this.scheme.equals(that.scheme)) {
327             return false;
328         }
329 
330         if (this.ssp.equals(&quot;*&quot;)) {
331             return true;
332         }
333 
334         if (!this.authority.implies(that.authority)) {
335             return false;
336         }
337 
338         if (this.path == null) {
339             return that.path == null;
340         }
341         if (that.path == null) {
342             return false;
343         }
344 
345         if (this.path.endsWith(&quot;/-&quot;)) {
346             String thisprefix = this.path.substring(0, this.path.length() - 1);
347             return that.path.startsWith(thisprefix);
348             }
349 
350         if (this.path.endsWith(&quot;/*&quot;)) {
351             String thisprefix = this.path.substring(0, this.path.length() - 1);
352             if (!that.path.startsWith(thisprefix)) {
353                 return false;
354             }
355             String thatsuffix = that.path.substring(thisprefix.length());
356             // suffix must not contain &#39;/&#39; chars
357             if (thatsuffix.indexOf(&#39;/&#39;) != -1) {
358                 return false;
359             }
360             if (thatsuffix.equals(&quot;-&quot;)) {
361                 return false;
362             }
363             return true;
364         }
365         return this.path.equals(that.path);
366     }
367 
368 
369     /**
370      * Returns true if, this.getActions().equals(p.getActions())
371      * and p&#39;s url equals this&#39;s url.  Returns false otherwise.
372      */
373     public boolean equals(Object p) {
374         if (!(p instanceof URLPermission)) {
375             return false;
376         }
377         URLPermission that = (URLPermission)p;
378         if (!this.scheme.equals(that.scheme)) {
379             return false;
380         }
381         if (!this.getActions().equals(that.getActions())) {
382             return false;
383         }
384         if (!this.authority.equals(that.authority)) {
385             return false;
386         }
387         if (this.path != null) {
388             return this.path.equals(that.path);
389         } else {
390             return that.path == null;
391         }
392     }
393 
394     /**
395      * Returns a hashcode calculated from the hashcode of the
396      * actions String and the url string.
397      */
398     public int hashCode() {
399         return getActions().hashCode()
400             + scheme.hashCode()
401             + authority.hashCode()
402             + (path == null ? 0 : path.hashCode());
403     }
404 
405 
406     private List&lt;String&gt; normalizeMethods(String methods) {
407         List&lt;String&gt; l = new ArrayList&lt;&gt;();
408         StringBuilder b = new StringBuilder();
409         for (int i=0; i&lt;methods.length(); i++) {
410             char c = methods.charAt(i);
411             if (c == &#39;,&#39;) {
412                 String s = b.toString();
413                 if (!s.isEmpty())
414                     l.add(s);
415                 b = new StringBuilder();
416             } else if (c == &#39; &#39; || c == &#39;\t&#39;) {
417                 throw new IllegalArgumentException(
418                     &quot;White space not allowed in methods: \&quot;&quot; + methods + &quot;\&quot;&quot;);
419             } else {
420                 if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
421                     c += &#39;A&#39; - &#39;a&#39;;
422                 }
423                 b.append(c);
424             }
425         }
426         String s = b.toString();
427         if (!s.isEmpty())
428             l.add(s);
429         return l;
430     }
431 
432     private List&lt;String&gt; normalizeHeaders(String headers) {
433         List&lt;String&gt; l = new ArrayList&lt;&gt;();
434         StringBuilder b = new StringBuilder();
435         boolean capitalizeNext = true;
436         for (int i=0; i&lt;headers.length(); i++) {
437             char c = headers.charAt(i);
438             if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
439                 if (capitalizeNext) {
440                     c += &#39;A&#39; - &#39;a&#39;;
441                     capitalizeNext = false;
442                 }
443                 b.append(c);
444             } else if (c == &#39; &#39; || c == &#39;\t&#39;) {
445                 throw new IllegalArgumentException(
446                     &quot;White space not allowed in headers: \&quot;&quot; + headers + &quot;\&quot;&quot;);
447             } else if (c == &#39;-&#39;) {
448                     capitalizeNext = true;
449                 b.append(c);
450             } else if (c == &#39;,&#39;) {
451                 String s = b.toString();
452                 if (!s.isEmpty())
453                     l.add(s);
454                 b = new StringBuilder();
455                 capitalizeNext = true;
456             } else {
457                 capitalizeNext = false;
458                 b.append(c);
459             }
460         }
461         String s = b.toString();
462         if (!s.isEmpty())
463             l.add(s);
464         return l;
465     }
466 
467     private void parseURI(String url) {
468         int len = url.length();
469         int delim = url.indexOf(&#39;:&#39;);
470         if (delim == -1 || delim + 1 == len) {
471             throw new IllegalArgumentException(
472                 &quot;Invalid URL string: \&quot;&quot; + url + &quot;\&quot;&quot;);
473         }
474         scheme = url.substring(0, delim).toLowerCase();
475         this.ssp = url.substring(delim + 1);
476 
477         if (!ssp.startsWith(&quot;//&quot;)) {
478             if (!ssp.equals(&quot;*&quot;)) {
479                 throw new IllegalArgumentException(
480                     &quot;Invalid URL string: \&quot;&quot; + url + &quot;\&quot;&quot;);
481             }
482             this.authority = new Authority(scheme, &quot;*&quot;);
483             return;
484         }
485         String authpath = ssp.substring(2);
486 
487         delim = authpath.indexOf(&#39;/&#39;);
488         String auth;
489         if (delim == -1) {
490             this.path = &quot;&quot;;
491             auth = authpath;
492         } else {
493             auth = authpath.substring(0, delim);
494             this.path = authpath.substring(delim);
495         }
496         this.authority = new Authority(scheme, auth.toLowerCase());
497     }
498 
499     private String actions() {
500         // The colon separator is optional when the request headers list is
501         // empty.This implementation chooses to include it even when the request
502         // headers list is empty.
503         return String.join(&quot;,&quot;, methods) + &quot;:&quot; + String.join(&quot;,&quot;, requestHeaders);
504     }
505 
506     /**
507      * restore the state of this object from stream
508      */
<a name="4" id="anc4"></a><span class="line-added">509     @java.io.Serial</span>
510     private void readObject(ObjectInputStream s)
511         throws IOException, ClassNotFoundException {
512         ObjectInputStream.GetField fields = s.readFields();
513         String actions = (String)fields.get(&quot;actions&quot;, null);
514 
515         init(actions);
516     }
517 
518     static class Authority {
519         HostPortrange p;
520 
521         Authority(String scheme, String authority) {
522             int at = authority.indexOf(&#39;@&#39;);
523             if (at == -1) {
524                     p = new HostPortrange(scheme, authority);
525             } else {
526                     p = new HostPortrange(scheme, authority.substring(at+1));
527             }
528         }
529 
530         boolean implies(Authority other) {
531             return impliesHostrange(other) &amp;&amp; impliesPortrange(other);
532         }
533 
534         private boolean impliesHostrange(Authority that) {
535             String thishost = this.p.hostname();
536             String thathost = that.p.hostname();
537 
538             if (p.wildcard() &amp;&amp; thishost.isEmpty()) {
539                 // this &quot;*&quot; implies all others
540                 return true;
541             }
542             if (that.p.wildcard() &amp;&amp; thathost.isEmpty()) {
543                 // that &quot;*&quot; can only be implied by this &quot;*&quot;
544                 return false;
545             }
546             if (thishost.equals(thathost)) {
547                 // covers all cases of literal IP addresses and fixed
548                 // domain names.
549                 return true;
550             }
551             if (this.p.wildcard()) {
552                 // this &quot;*.foo.com&quot; implies &quot;bub.bar.foo.com&quot;
553                 return thathost.endsWith(thishost);
554             }
555             return false;
556         }
557 
558         private boolean impliesPortrange(Authority that) {
559             int[] thisrange = this.p.portrange();
560             int[] thatrange = that.p.portrange();
561             if (thisrange[0] == -1) {
562                 /* port not specified non http/s URL */
563                 return true;
564             }
565             return thisrange[0] &lt;= thatrange[0] &amp;&amp;
566                         thisrange[1] &gt;= thatrange[1];
567         }
568 
569         boolean equals(Authority that) {
570             return this.p.equals(that.p);
571         }
572 
573         public int hashCode() {
574             return p.hashCode();
575         }
576     }
577 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
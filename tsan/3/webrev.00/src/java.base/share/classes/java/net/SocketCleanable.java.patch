diff a/src/java.base/share/classes/java/net/SocketCleanable.java b/src/java.base/share/classes/java/net/SocketCleanable.java
--- a/src/java.base/share/classes/java/net/SocketCleanable.java
+++ b/src/java.base/share/classes/java/net/SocketCleanable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -32,10 +32,11 @@
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.lang.ref.Cleaner;
 
+import sun.net.ResourceManager;
 
 /**
  * Cleanable for a socket/datagramsocket FileDescriptor when it becomes phantom reachable.
  * Create a cleanup if the raw fd != -1. Windows closes sockets using the fd.
  * Subclassed from {@code PhantomCleanable} so that {@code clear} can be
@@ -54,21 +55,26 @@
     private static native void cleanupClose0(int fd) throws IOException;
 
     // The raw fd to close
     private final int fd;
 
+    // true for socket, false for datagram socket
+    private final boolean stream;
+
     /**
      * Register a socket specific Cleanable with the FileDescriptor
      * if the FileDescriptor is non-null and the raw fd is != -1.
      *
-     * @param fdo the FileDescriptor; may be null
+     * @param fdo     the FileDescriptor; may be null
+     * @param stream  false for datagram socket
      */
-    static void register(FileDescriptor fdo) {
+    static void register(FileDescriptor fdo, boolean stream) {
         if (fdo != null && fdo.valid()) {
             int fd = fdAccess.get(fdo);
             fdAccess.registerCleanup(fdo,
-                    new SocketCleanable(fdo, CleanerFactory.cleaner(), fd));
+                    new SocketCleanable(fdo, CleanerFactory.cleaner(),
+                                        fd, stream));
         }
     }
 
     /**
      * Unregister a Cleanable from the FileDescriptor.
@@ -84,14 +90,17 @@
      * Constructor for a phantom cleanable reference.
      *
      * @param obj     the object to monitor
      * @param cleaner the cleaner
      * @param fd      file descriptor to close
+     * @param stream  false for datagram socket
      */
-    private SocketCleanable(FileDescriptor obj, Cleaner cleaner, int fd) {
+    private SocketCleanable(FileDescriptor obj, Cleaner cleaner,
+                            int fd, boolean stream) {
         super(obj, cleaner);
         this.fd = fd;
+        this.stream = stream;
     }
 
     /**
      * Close the native handle or fd.
      */
@@ -99,8 +108,12 @@
     protected void performCleanup() {
         try {
             cleanupClose0(fd);
         } catch (IOException ioe) {
             throw new UncheckedIOException("close", ioe);
+        } finally {
+            if (!stream) {
+                ResourceManager.afterUdpClose();
+            }
         }
     }
 }

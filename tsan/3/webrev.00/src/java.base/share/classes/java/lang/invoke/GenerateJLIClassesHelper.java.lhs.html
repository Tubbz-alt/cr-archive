<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/GenerateJLIClassesHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.org.objectweb.asm.ClassWriter;
 29 import jdk.internal.org.objectweb.asm.Opcodes;
 30 import sun.invoke.util.Wrapper;
 31 
 32 import java.util.ArrayList;
 33 import java.util.HashSet;
<a name="2" id="anc2"></a><span class="line-removed"> 34 import java.util.List;</span>
 35 import java.util.Map;
 36 
<a name="3" id="anc3"></a>


 37 /**
 38  * Helper class to assist the GenerateJLIClassesPlugin to get access to
 39  * generate classes ahead of time.
 40  */
 41 class GenerateJLIClassesHelper {
 42 
 43     static byte[] generateBasicFormsClassBytes(String className) {
 44         ArrayList&lt;LambdaForm&gt; forms = new ArrayList&lt;&gt;();
 45         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
 46         HashSet&lt;String&gt; dedupSet = new HashSet&lt;&gt;();
 47         for (LambdaForm.BasicType type : LambdaForm.BasicType.values()) {
 48             LambdaForm zero = LambdaForm.zeroForm(type);
 49             String name = zero.kind.defaultLambdaName
 50                    + &quot;_&quot; + zero.returnType().basicTypeChar();
 51             if (dedupSet.add(name)) {
 52                 names.add(name);
 53                 forms.add(zero);
 54             }
 55 
 56             LambdaForm identity = LambdaForm.identityForm(type);
 57             name = identity.kind.defaultLambdaName
 58                    + &quot;_&quot; + identity.returnType().basicTypeChar();
 59             if (dedupSet.add(name)) {
 60                 names.add(name);
 61                 forms.add(identity);
 62             }
 63         }
 64         return generateCodeBytesForLFs(className,
 65                 names.toArray(new String[0]),
 66                 forms.toArray(new LambdaForm[0]));
 67     }
 68 
 69     static byte[] generateDirectMethodHandleHolderClassBytes(String className,
 70             MethodType[] methodTypes, int[] types) {
 71         ArrayList&lt;LambdaForm&gt; forms = new ArrayList&lt;&gt;();
 72         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
 73         for (int i = 0; i &lt; methodTypes.length; i++) {
<a name="4" id="anc4"></a><span class="line-modified"> 74             LambdaForm form = DirectMethodHandle</span>
<span class="line-modified"> 75                     .makePreparedLambdaForm(methodTypes[i], types[i]);</span>











 76             forms.add(form);
 77             names.add(form.kind.defaultLambdaName);
 78         }
 79         for (Wrapper wrapper : Wrapper.values()) {
 80             if (wrapper == Wrapper.VOID) {
 81                 continue;
 82             }
 83             for (byte b = DirectMethodHandle.AF_GETFIELD; b &lt; DirectMethodHandle.AF_LIMIT; b++) {
 84                 int ftype = DirectMethodHandle.ftypeKind(wrapper.primitiveType());
 85                 LambdaForm form = DirectMethodHandle
 86                         .makePreparedFieldLambdaForm(b, /*isVolatile*/false, ftype);
 87                 if (form.kind != LambdaForm.Kind.GENERIC) {
 88                     forms.add(form);
 89                     names.add(form.kind.defaultLambdaName);
 90                 }
 91                 // volatile
 92                 form = DirectMethodHandle
 93                         .makePreparedFieldLambdaForm(b, /*isVolatile*/true, ftype);
 94                 if (form.kind != LambdaForm.Kind.GENERIC) {
 95                     forms.add(form);
 96                     names.add(form.kind.defaultLambdaName);
 97                 }
 98             }
 99         }
100         return generateCodeBytesForLFs(className,
101                 names.toArray(new String[0]),
102                 forms.toArray(new LambdaForm[0]));
103     }
104 
105     static byte[] generateDelegatingMethodHandleHolderClassBytes(String className,
106             MethodType[] methodTypes) {
107 
108         HashSet&lt;MethodType&gt; dedupSet = new HashSet&lt;&gt;();
109         ArrayList&lt;LambdaForm&gt; forms = new ArrayList&lt;&gt;();
110         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
111         for (int i = 0; i &lt; methodTypes.length; i++) {
112             // generate methods representing the DelegatingMethodHandle
113             if (dedupSet.add(methodTypes[i])) {
114                 // reinvokers are variant with the associated SpeciesData
115                 // and shape of the target LF, but we can easily pregenerate
116                 // the basic reinvokers associated with Species_L. Ultimately we
117                 // may want to consider pregenerating more of these, which will
118                 // require an even more complex naming scheme
119                 LambdaForm reinvoker = makeReinvokerFor(methodTypes[i]);
120                 forms.add(reinvoker);
121                 String speciesSig = BoundMethodHandle.speciesDataFor(reinvoker).key();
122                 assert(speciesSig.equals(&quot;L&quot;));
123                 names.add(reinvoker.kind.defaultLambdaName + &quot;_&quot; + speciesSig);
124 
125                 LambdaForm delegate = makeDelegateFor(methodTypes[i]);
126                 forms.add(delegate);
127                 names.add(delegate.kind.defaultLambdaName);
128             }
129         }
130         return generateCodeBytesForLFs(className,
131                 names.toArray(new String[0]),
132                 forms.toArray(new LambdaForm[0]));
133     }
134 
135     static byte[] generateInvokersHolderClassBytes(String className,
136             MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {
137 
138         HashSet&lt;MethodType&gt; dedupSet = new HashSet&lt;&gt;();
139         ArrayList&lt;LambdaForm&gt; forms = new ArrayList&lt;&gt;();
140         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
141         int[] types = {
142             MethodTypeForm.LF_EX_LINKER,
143             MethodTypeForm.LF_EX_INVOKER,
144             MethodTypeForm.LF_GEN_LINKER,
145             MethodTypeForm.LF_GEN_INVOKER
146         };
147 
148         for (int i = 0; i &lt; invokerMethodTypes.length; i++) {
149             // generate methods representing invokers of the specified type
150             if (dedupSet.add(invokerMethodTypes[i])) {
151                 for (int type : types) {
152                     LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],
153                             /*customized*/false, type);
154                     forms.add(invokerForm);
155                     names.add(invokerForm.kind.defaultLambdaName);
156                 }
157             }
158         }
159 
160         dedupSet = new HashSet&lt;&gt;();
161         for (int i = 0; i &lt; callSiteMethodTypes.length; i++) {
162             // generate methods representing invokers of the specified type
163             if (dedupSet.add(callSiteMethodTypes[i])) {
164                 LambdaForm callSiteForm = Invokers.callSiteForm(callSiteMethodTypes[i], true);
165                 forms.add(callSiteForm);
166                 names.add(callSiteForm.kind.defaultLambdaName);
167 
168                 LambdaForm methodHandleForm = Invokers.callSiteForm(callSiteMethodTypes[i], false);
169                 forms.add(methodHandleForm);
170                 names.add(methodHandleForm.kind.defaultLambdaName);
171             }
172         }
173 
174         return generateCodeBytesForLFs(className,
175                 names.toArray(new String[0]),
176                 forms.toArray(new LambdaForm[0]));
177     }
178 
179     /*
180      * Generate customized code for a set of LambdaForms of specified types into
181      * a class with a specified name.
182      */
183     private static byte[] generateCodeBytesForLFs(String className,
184             String[] names, LambdaForm[] forms) {
185 
186         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
187         cw.visit(Opcodes.V1_8, Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
188                 className, null, InvokerBytecodeGenerator.INVOKER_SUPER_NAME, null);
189         cw.visitSource(className.substring(className.lastIndexOf(&#39;/&#39;) + 1), null);
190 
191         for (int i = 0; i &lt; forms.length; i++) {
192             addMethod(className, names[i], forms[i],
193                     forms[i].methodType(), cw);
194         }
195         return cw.toByteArray();
196     }
197 
198     private static void addMethod(String className, String methodName, LambdaForm form,
199             MethodType type, ClassWriter cw) {
200         InvokerBytecodeGenerator g
201                 = new InvokerBytecodeGenerator(className, methodName, form, type);
202         g.setClassWriter(cw);
203         g.addMethod();
204     }
205 
206     private static LambdaForm makeReinvokerFor(MethodType type) {
207         MethodHandle emptyHandle = MethodHandles.empty(type);
208         return DelegatingMethodHandle.makeReinvokerForm(emptyHandle,
209                 MethodTypeForm.LF_REBIND,
210                 BoundMethodHandle.speciesData_L(),
211                 BoundMethodHandle.speciesData_L().getterFunction(0));
212     }
213 
214     private static LambdaForm makeDelegateFor(MethodType type) {
215         MethodHandle handle = MethodHandles.empty(type);
216         return DelegatingMethodHandle.makeReinvokerForm(
217                 handle,
218                 MethodTypeForm.LF_DELEGATE,
219                 DelegatingMethodHandle.class,
220                 DelegatingMethodHandle.NF_getTarget);
221     }
222 
223     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
224     static Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(final String types) {
225         for (char c : types.toCharArray()) {
226             if (&quot;LIJFD&quot;.indexOf(c) &lt; 0) {
227                 throw new IllegalArgumentException(&quot;All characters must &quot;
228                         + &quot;correspond to a basic field type: LIJFD&quot;);
229             }
230         }
231         final BoundMethodHandle.SpeciesData species = BoundMethodHandle.SPECIALIZER.findSpecies(types);
232         final String className = species.speciesCode().getName();
233         final ClassSpecializer.Factory factory = BoundMethodHandle.SPECIALIZER.factory();
234         final byte[] code = factory.generateConcreteSpeciesCodeFile(className, species);
235         return Map.entry(className.replace(&#39;.&#39;, &#39;/&#39;), code);
236     }
237 
238 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConstantBootstraps.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/ClassSpecializer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 

  28 import jdk.internal.loader.BootLoader;
  29 import jdk.internal.org.objectweb.asm.ClassWriter;
  30 import jdk.internal.org.objectweb.asm.FieldVisitor;
  31 import jdk.internal.org.objectweb.asm.MethodVisitor;
  32 import jdk.internal.vm.annotation.Stable;
  33 import sun.invoke.util.BytecodeName;
  34 
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Field;
  37 import java.lang.reflect.Modifier;
  38 import java.security.AccessController;
  39 import java.security.PrivilegedAction;

  40 import java.util.ArrayList;
  41 import java.util.Collections;
  42 import java.util.List;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.function.Function;
  46 
  47 import static java.lang.invoke.LambdaForm.*;
  48 import static java.lang.invoke.MethodHandleNatives.Constants.REF_getStatic;
  49 import static java.lang.invoke.MethodHandleNatives.Constants.REF_putStatic;
  50 import static java.lang.invoke.MethodHandleStatics.*;
  51 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  52 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  53 
  54 /**
  55  * Class specialization code.
  56  * @param &lt;T&gt; top class under which species classes are created.
  57  * @param &lt;K&gt; key which identifies individual specializations.
  58  * @param &lt;S&gt; species data type.
  59  */
</pre>
<hr />
<pre>
 439                 }
 440                 if (!topClassIsSuper) {
 441                     throw newInternalError(&quot;must override if the top class cannot serve as a super class&quot;);
 442                 }
 443             }
 444             return topc;
 445         }
 446     }
 447 
 448     protected abstract S newSpeciesData(K key);
 449 
 450     protected K topSpeciesKey() {
 451         return null;  // null means don&#39;t report a top species
 452     }
 453 
 454     /**
 455      * Code generation support for instances.
 456      * Subclasses can modify the behavior.
 457      */
 458     public class Factory {





 459         /**
 460          * Get a concrete subclass of the top class for a given combination of bound types.
 461          *
 462          * @param speciesData the species requiring the class, not yet linked
 463          * @return a linked version of the same species
 464          */
 465         S loadSpecies(S speciesData) {
 466             String className = speciesData.deriveClassName();
 467             assert(className.indexOf(&#39;/&#39;) &lt; 0) : className;
 468             Class&lt;?&gt; salvage = null;
 469             try {
 470                 salvage = BootLoader.loadClassOrNull(className);
 471                 if (TRACE_RESOLVE &amp;&amp; salvage != null) {
 472                     // Used by jlink species pregeneration plugin, see
 473                     // jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin
 474                     System.out.println(&quot;[SPECIES_RESOLVE] &quot; + className + &quot; (salvaged)&quot;);
 475                 }
 476             } catch (Error ex) {
 477                 if (TRACE_RESOLVE) {
 478                     System.out.println(&quot;[SPECIES_FRESOLVE] &quot; + className + &quot; (Error) &quot; + ex.getMessage());
</pre>
<hr />
<pre>
 520          *
 521          * &lt;pre&gt;
 522          * class Species_[[types]] extends [[T]] {
 523          *     final [[S]] speciesData() { return ... }
 524          *     static [[T]] make([[fields]]) { return ... }
 525          *     [[fields]]
 526          *     final [[T]] transform([[args]]) { return ... }
 527          * }
 528          * &lt;/pre&gt;
 529          *
 530          * The {@code [[types]]} signature is precisely the key for the species.
 531          *
 532          * The {@code [[fields]]} section consists of one field definition per character in
 533          * the type signature, adhering to the naming schema described in the definition of
 534          * {@link #chooseFieldName}.
 535          *
 536          * For example, a concrete species for two references and one integral bound value
 537          * has a shape like the following:
 538          *
 539          * &lt;pre&gt;
<span class="line-modified"> 540          * class TopClass { ... private static</span>
<span class="line-modified"> 541          * final class Species_LLI extends TopClass {</span>
<span class="line-modified"> 542          *     final Object argL0;</span>
<span class="line-modified"> 543          *     final Object argL1;</span>
<span class="line-modified"> 544          *     final int argI2;</span>
<span class="line-modified"> 545          *     private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 546          *         super(ctarg, ...);</span>
<span class="line-modified"> 547          *         this.argL0 = argL0;</span>
<span class="line-modified"> 548          *         this.argL1 = argL1;</span>
<span class="line-modified"> 549          *         this.argI2 = argI2;</span>
<span class="line-modified"> 550          *     }</span>
<span class="line-modified"> 551          *     final SpeciesData speciesData() { return BMH_SPECIES; }</span>
<span class="line-modified"> 552          *     &amp;#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards</span>
<span class="line-modified"> 553          *     static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 554          *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 555          *     }</span>
<span class="line-modified"> 556          *     final TopClass copyWith(CT ctarg, ...) {</span>
<span class="line-modified"> 557          *         return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 558          *     }</span>
<span class="line-modified"> 559          *     // two transforms, for the sake of illustration:</span>
<span class="line-modified"> 560          *     final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {</span>
<span class="line-modified"> 561          *         return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-modified"> 562          *     }</span>
<span class="line-modified"> 563          *     final TopClass copyWithExtendI(CT ctarg, ..., int narg) {</span>
<span class="line-modified"> 564          *         return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>


 565          *     }
 566          * }
 567          * &lt;/pre&gt;
 568          *
 569          * @param className of the species
 570          * @param speciesData what species we are generating
 571          * @return the generated concrete TopClass class
 572          */
 573         Class&lt;? extends T&gt; generateConcreteSpeciesCode(String className, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {
 574             byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
 575 
 576             // load class
 577             InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
<span class="line-modified"> 578             Class&lt;?&gt; speciesCode;</span>
<span class="line-modified"> 579 </span>
<span class="line-modified"> 580             MethodHandles.Lookup lookup = IMPL_LOOKUP.in(topClass());</span>
<span class="line-modified"> 581             speciesCode = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {</span>
<span class="line-modified"> 582                 @Override</span>
<span class="line-modified"> 583                 public Class&lt;?&gt; run() {</span>
<span class="line-modified"> 584                     try {</span>
<span class="line-modified"> 585                         return lookup.defineClass(classFile);</span>
<span class="line-modified"> 586                     } catch (Exception ex) {</span>
<span class="line-modified"> 587                         throw newInternalError(ex);</span>
<span class="line-modified"> 588                     }</span>
<span class="line-modified"> 589                 }</span>
<span class="line-modified"> 590             });</span>
 591             return speciesCode.asSubclass(topClass());
 592         }
 593 
 594         // These are named like constants because there is only one per specialization scheme:
 595         private final String SPECIES_DATA = classBCName(metaType);
 596         private final String SPECIES_DATA_SIG = classSig(SPECIES_DATA);
 597         private final String SPECIES_DATA_NAME = sdAccessor.getName();
 598         private final int SPECIES_DATA_MODS = sdAccessor.getModifiers();
 599         private final List&lt;String&gt; TRANSFORM_NAMES;  // derived from transformMethods
 600         private final List&lt;MethodType&gt; TRANSFORM_TYPES;
 601         private final List&lt;Integer&gt; TRANSFORM_MODS;
 602         {
 603             // Tear apart transformMethods to get the names, types, and modifiers.
 604             List&lt;String&gt; tns = new ArrayList&lt;&gt;();
 605             List&lt;MethodType&gt; tts = new ArrayList&lt;&gt;();
 606             List&lt;Integer&gt; tms = new ArrayList&lt;&gt;();
 607             for (int i = 0; i &lt; transformMethods.size(); i++) {
 608                 MemberName tm = transformMethods.get(i);
 609                 tns.add(tm.getName());
 610                 final MethodType tt = tm.getMethodType();
 611                 tts.add(tt);
 612                 tms.add(tm.getModifiers());
 613             }
 614             TRANSFORM_NAMES = List.of(tns.toArray(new String[0]));
 615             TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
 616             TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
 617         }
 618         private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
 619 
<span class="line-modified"> 620         /*non-public*/ byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {</span>

 621             final String className = classBCName(className0);
 622             final String superClassName = classBCName(speciesData.deriveSuperClass());
 623 
 624             final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 625             final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
 626             cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);
 627 
 628             final String sourceFile = className.substring(className.lastIndexOf(&#39;.&#39;)+1);
 629             cw.visitSource(sourceFile, null);
 630 
 631             // emit static types and BMH_SPECIES fields
 632             FieldVisitor fw = cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, sdFieldName, SPECIES_DATA_SIG, null, null);
 633             fw.visitAnnotation(STABLE_SIG, true);
 634             fw.visitEnd();
 635 
 636             // handy holder for dealing with groups of typed values (ctor arguments and fields)
 637             class Var {
 638                 final int index;
 639                 final String name;
 640                 final Class&lt;?&gt; type;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
<span class="line-added">  28 import jdk.internal.access.SharedSecrets;</span>
  29 import jdk.internal.loader.BootLoader;
  30 import jdk.internal.org.objectweb.asm.ClassWriter;
  31 import jdk.internal.org.objectweb.asm.FieldVisitor;
  32 import jdk.internal.org.objectweb.asm.MethodVisitor;
  33 import jdk.internal.vm.annotation.Stable;
  34 import sun.invoke.util.BytecodeName;
  35 
  36 import java.lang.reflect.Constructor;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
<span class="line-added">  41 import java.security.ProtectionDomain;</span>
  42 import java.util.ArrayList;
  43 import java.util.Collections;
  44 import java.util.List;
  45 import java.util.Objects;
  46 import java.util.concurrent.ConcurrentHashMap;
  47 import java.util.function.Function;
  48 
  49 import static java.lang.invoke.LambdaForm.*;
  50 import static java.lang.invoke.MethodHandleNatives.Constants.REF_getStatic;
  51 import static java.lang.invoke.MethodHandleNatives.Constants.REF_putStatic;
  52 import static java.lang.invoke.MethodHandleStatics.*;
  53 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
  54 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  55 
  56 /**
  57  * Class specialization code.
  58  * @param &lt;T&gt; top class under which species classes are created.
  59  * @param &lt;K&gt; key which identifies individual specializations.
  60  * @param &lt;S&gt; species data type.
  61  */
</pre>
<hr />
<pre>
 441                 }
 442                 if (!topClassIsSuper) {
 443                     throw newInternalError(&quot;must override if the top class cannot serve as a super class&quot;);
 444                 }
 445             }
 446             return topc;
 447         }
 448     }
 449 
 450     protected abstract S newSpeciesData(K key);
 451 
 452     protected K topSpeciesKey() {
 453         return null;  // null means don&#39;t report a top species
 454     }
 455 
 456     /**
 457      * Code generation support for instances.
 458      * Subclasses can modify the behavior.
 459      */
 460     public class Factory {
<span class="line-added"> 461         /**</span>
<span class="line-added"> 462          * Constructs a factory.</span>
<span class="line-added"> 463          */</span>
<span class="line-added"> 464         Factory() {}</span>
<span class="line-added"> 465 </span>
 466         /**
 467          * Get a concrete subclass of the top class for a given combination of bound types.
 468          *
 469          * @param speciesData the species requiring the class, not yet linked
 470          * @return a linked version of the same species
 471          */
 472         S loadSpecies(S speciesData) {
 473             String className = speciesData.deriveClassName();
 474             assert(className.indexOf(&#39;/&#39;) &lt; 0) : className;
 475             Class&lt;?&gt; salvage = null;
 476             try {
 477                 salvage = BootLoader.loadClassOrNull(className);
 478                 if (TRACE_RESOLVE &amp;&amp; salvage != null) {
 479                     // Used by jlink species pregeneration plugin, see
 480                     // jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin
 481                     System.out.println(&quot;[SPECIES_RESOLVE] &quot; + className + &quot; (salvaged)&quot;);
 482                 }
 483             } catch (Error ex) {
 484                 if (TRACE_RESOLVE) {
 485                     System.out.println(&quot;[SPECIES_FRESOLVE] &quot; + className + &quot; (Error) &quot; + ex.getMessage());
</pre>
<hr />
<pre>
 527          *
 528          * &lt;pre&gt;
 529          * class Species_[[types]] extends [[T]] {
 530          *     final [[S]] speciesData() { return ... }
 531          *     static [[T]] make([[fields]]) { return ... }
 532          *     [[fields]]
 533          *     final [[T]] transform([[args]]) { return ... }
 534          * }
 535          * &lt;/pre&gt;
 536          *
 537          * The {@code [[types]]} signature is precisely the key for the species.
 538          *
 539          * The {@code [[fields]]} section consists of one field definition per character in
 540          * the type signature, adhering to the naming schema described in the definition of
 541          * {@link #chooseFieldName}.
 542          *
 543          * For example, a concrete species for two references and one integral bound value
 544          * has a shape like the following:
 545          *
 546          * &lt;pre&gt;
<span class="line-modified"> 547          * class TopClass {</span>
<span class="line-modified"> 548          *     ...</span>
<span class="line-modified"> 549          *     private static final class Species_LLI extends TopClass {</span>
<span class="line-modified"> 550          *         final Object argL0;</span>
<span class="line-modified"> 551          *         final Object argL1;</span>
<span class="line-modified"> 552          *         final int argI2;</span>
<span class="line-modified"> 553          *         private Species_LLI(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 554          *             super(ctarg, ...);</span>
<span class="line-modified"> 555          *             this.argL0 = argL0;</span>
<span class="line-modified"> 556          *             this.argL1 = argL1;</span>
<span class="line-modified"> 557          *             this.argI2 = argI2;</span>
<span class="line-modified"> 558          *         }</span>
<span class="line-modified"> 559          *         final SpeciesData speciesData() { return BMH_SPECIES; }</span>
<span class="line-modified"> 560          *         &amp;#64;Stable static SpeciesData BMH_SPECIES; // injected afterwards</span>
<span class="line-modified"> 561          *         static TopClass make(CT ctarg, ..., Object argL0, Object argL1, int argI2) {</span>
<span class="line-modified"> 562          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 563          *         }</span>
<span class="line-modified"> 564          *         final TopClass copyWith(CT ctarg, ...) {</span>
<span class="line-modified"> 565          *             return new Species_LLI(ctarg, ..., argL0, argL1, argI2);</span>
<span class="line-modified"> 566          *         }</span>
<span class="line-modified"> 567          *         // two transforms, for the sake of illustration:</span>
<span class="line-modified"> 568          *         final TopClass copyWithExtendL(CT ctarg, ..., Object narg) {</span>
<span class="line-modified"> 569          *             return BMH_SPECIES.transform(L_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-modified"> 570          *         }</span>
<span class="line-modified"> 571          *         final TopClass copyWithExtendI(CT ctarg, ..., int narg) {</span>
<span class="line-added"> 572          *             return BMH_SPECIES.transform(I_TYPE).invokeBasic(ctarg, ..., argL0, argL1, argI2, narg);</span>
<span class="line-added"> 573          *         }</span>
 574          *     }
 575          * }
 576          * &lt;/pre&gt;
 577          *
 578          * @param className of the species
 579          * @param speciesData what species we are generating
 580          * @return the generated concrete TopClass class
 581          */
 582         Class&lt;? extends T&gt; generateConcreteSpeciesCode(String className, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {
 583             byte[] classFile = generateConcreteSpeciesCodeFile(className, speciesData);
 584 
 585             // load class
 586             InvokerBytecodeGenerator.maybeDump(classBCName(className), classFile);
<span class="line-modified"> 587             ClassLoader cl = topClass.getClassLoader();</span>
<span class="line-modified"> 588             ProtectionDomain pd = null;</span>
<span class="line-modified"> 589             if (cl != null) {</span>
<span class="line-modified"> 590                 pd = AccessController.doPrivileged(</span>
<span class="line-modified"> 591                         new PrivilegedAction&lt;&gt;() {</span>
<span class="line-modified"> 592                             @Override</span>
<span class="line-modified"> 593                             public ProtectionDomain run() {</span>
<span class="line-modified"> 594                                 return topClass().getProtectionDomain();</span>
<span class="line-modified"> 595                             }</span>
<span class="line-modified"> 596                         });</span>
<span class="line-modified"> 597             }</span>
<span class="line-modified"> 598             Class&lt;?&gt; speciesCode = SharedSecrets.getJavaLangAccess()</span>
<span class="line-modified"> 599                     .defineClass(cl, className, classFile, pd, &quot;_ClassSpecializer_generateConcreteSpeciesCode&quot;);</span>
 600             return speciesCode.asSubclass(topClass());
 601         }
 602 
 603         // These are named like constants because there is only one per specialization scheme:
 604         private final String SPECIES_DATA = classBCName(metaType);
 605         private final String SPECIES_DATA_SIG = classSig(SPECIES_DATA);
 606         private final String SPECIES_DATA_NAME = sdAccessor.getName();
 607         private final int SPECIES_DATA_MODS = sdAccessor.getModifiers();
 608         private final List&lt;String&gt; TRANSFORM_NAMES;  // derived from transformMethods
 609         private final List&lt;MethodType&gt; TRANSFORM_TYPES;
 610         private final List&lt;Integer&gt; TRANSFORM_MODS;
 611         {
 612             // Tear apart transformMethods to get the names, types, and modifiers.
 613             List&lt;String&gt; tns = new ArrayList&lt;&gt;();
 614             List&lt;MethodType&gt; tts = new ArrayList&lt;&gt;();
 615             List&lt;Integer&gt; tms = new ArrayList&lt;&gt;();
 616             for (int i = 0; i &lt; transformMethods.size(); i++) {
 617                 MemberName tm = transformMethods.get(i);
 618                 tns.add(tm.getName());
 619                 final MethodType tt = tm.getMethodType();
 620                 tts.add(tt);
 621                 tms.add(tm.getModifiers());
 622             }
 623             TRANSFORM_NAMES = List.of(tns.toArray(new String[0]));
 624             TRANSFORM_TYPES = List.of(tts.toArray(new MethodType[0]));
 625             TRANSFORM_MODS = List.of(tms.toArray(new Integer[0]));
 626         }
 627         private static final int ACC_PPP = ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED;
 628 
<span class="line-modified"> 629         /*non-public*/</span>
<span class="line-added"> 630         byte[] generateConcreteSpeciesCodeFile(String className0, ClassSpecializer&lt;T,K,S&gt;.SpeciesData speciesData) {</span>
 631             final String className = classBCName(className0);
 632             final String superClassName = classBCName(speciesData.deriveSuperClass());
 633 
 634             final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 635             final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
 636             cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);
 637 
 638             final String sourceFile = className.substring(className.lastIndexOf(&#39;.&#39;)+1);
 639             cw.visitSource(sourceFile, null);
 640 
 641             // emit static types and BMH_SPECIES fields
 642             FieldVisitor fw = cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, sdFieldName, SPECIES_DATA_SIG, null, null);
 643             fw.visitAnnotation(STABLE_SIG, true);
 644             fw.visitEnd();
 645 
 646             // handy holder for dealing with groups of typed values (ctor arguments and fields)
 647             class Var {
 648                 final int index;
 649                 final String name;
 650                 final Class&lt;?&gt; type;
</pre>
</td>
</tr>
</table>
<center><a href="CallSite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConstantBootstraps.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
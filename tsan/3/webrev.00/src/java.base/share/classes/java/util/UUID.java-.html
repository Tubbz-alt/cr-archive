<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/UUID.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.security.*;
 29 
 30 import jdk.internal.access.JavaLangAccess;
 31 import jdk.internal.access.SharedSecrets;
 32 
 33 /**
 34  * A class that represents an immutable universally unique identifier (UUID).
 35  * A UUID represents a 128-bit value.
 36  *
 37  * &lt;p&gt; There exist different variants of these global identifiers.  The methods
 38  * of this class are for manipulating the Leach-Salz variant, although the
 39  * constructors allow the creation of any variant of UUID (described below).
 40  *
 41  * &lt;p&gt; The layout of a variant 2 (Leach-Salz) UUID is as follows:
 42  *
 43  * The most significant long consists of the following unsigned fields:
 44  * &lt;pre&gt;
 45  * 0xFFFFFFFF00000000 time_low
 46  * 0x00000000FFFF0000 time_mid
 47  * 0x000000000000F000 version
 48  * 0x0000000000000FFF time_hi
 49  * &lt;/pre&gt;
 50  * The least significant long consists of the following unsigned fields:
 51  * &lt;pre&gt;
 52  * 0xC000000000000000 variant
 53  * 0x3FFF000000000000 clock_seq
 54  * 0x0000FFFFFFFFFFFF node
 55  * &lt;/pre&gt;
 56  *
 57  * &lt;p&gt; The variant field contains a value which identifies the layout of the
 58  * {@code UUID}.  The bit layout described above is valid only for a {@code
 59  * UUID} with a variant value of 2, which indicates the Leach-Salz variant.
 60  *
 61  * &lt;p&gt; The version field holds a value that describes the type of this {@code
 62  * UUID}.  There are four different basic types of UUIDs: time-based, DCE
 63  * security, name-based, and randomly generated UUIDs.  These types have a
 64  * version value of 1, 2, 3 and 4, respectively.
 65  *
 66  * &lt;p&gt; For more information including algorithms used to create {@code UUID}s,
 67  * see &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;4122: A
 68  * Universally Unique IDentifier (UUID) URN Namespace&lt;/i&gt;&lt;/a&gt;, section 4.2
 69  * &amp;quot;Algorithms for Creating a Time-Based UUID&amp;quot;.
 70  *
 71  * @since   1.5
 72  */
 73 public final class UUID implements java.io.Serializable, Comparable&lt;UUID&gt; {
 74 
 75     /**
 76      * Explicit serialVersionUID for interoperability.
 77      */
 78     private static final long serialVersionUID = -4856846361193249489L;
 79 
 80     /*
 81      * The most significant 64 bits of this UUID.
 82      *
 83      * @serial
 84      */
 85     private final long mostSigBits;
 86 
 87     /*
 88      * The least significant 64 bits of this UUID.
 89      *
 90      * @serial
 91      */
 92     private final long leastSigBits;
 93 
 94     private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
 95 
 96     /*
 97      * The random number generator used by this class to create random
 98      * based UUIDs. In a holder class to defer initialization until needed.
 99      */
100     private static class Holder {
101         static final SecureRandom numberGenerator = new SecureRandom();
102     }
103 
104     // Constructors and Factories
105 
106     /*
107      * Private constructor which uses a byte array to construct the new UUID.
108      */
109     private UUID(byte[] data) {
110         long msb = 0;
111         long lsb = 0;
112         assert data.length == 16 : &quot;data must be 16 bytes in length&quot;;
113         for (int i=0; i&lt;8; i++)
114             msb = (msb &lt;&lt; 8) | (data[i] &amp; 0xff);
115         for (int i=8; i&lt;16; i++)
116             lsb = (lsb &lt;&lt; 8) | (data[i] &amp; 0xff);
117         this.mostSigBits = msb;
118         this.leastSigBits = lsb;
119     }
120 
121     /**
122      * Constructs a new {@code UUID} using the specified data.  {@code
123      * mostSigBits} is used for the most significant 64 bits of the {@code
124      * UUID} and {@code leastSigBits} becomes the least significant 64 bits of
125      * the {@code UUID}.
126      *
127      * @param  mostSigBits
128      *         The most significant bits of the {@code UUID}
129      *
130      * @param  leastSigBits
131      *         The least significant bits of the {@code UUID}
132      */
133     public UUID(long mostSigBits, long leastSigBits) {
134         this.mostSigBits = mostSigBits;
135         this.leastSigBits = leastSigBits;
136     }
137 
138     /**
139      * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
140      *
141      * The {@code UUID} is generated using a cryptographically strong pseudo
142      * random number generator.
143      *
144      * @return  A randomly generated {@code UUID}
145      */
146     public static UUID randomUUID() {
147         SecureRandom ng = Holder.numberGenerator;
148 
149         byte[] randomBytes = new byte[16];
150         ng.nextBytes(randomBytes);
151         randomBytes[6]  &amp;= 0x0f;  /* clear version        */
152         randomBytes[6]  |= 0x40;  /* set to version 4     */
153         randomBytes[8]  &amp;= 0x3f;  /* clear variant        */
154         randomBytes[8]  |= 0x80;  /* set to IETF variant  */
155         return new UUID(randomBytes);
156     }
157 
158     /**
159      * Static factory to retrieve a type 3 (name based) {@code UUID} based on
160      * the specified byte array.
161      *
162      * @param  name
163      *         A byte array to be used to construct a {@code UUID}
164      *
165      * @return  A {@code UUID} generated from the specified array
166      */
167     public static UUID nameUUIDFromBytes(byte[] name) {
168         MessageDigest md;
169         try {
170             md = MessageDigest.getInstance(&quot;MD5&quot;);
171         } catch (NoSuchAlgorithmException nsae) {
172             throw new InternalError(&quot;MD5 not supported&quot;, nsae);
173         }
174         byte[] md5Bytes = md.digest(name);
175         md5Bytes[6]  &amp;= 0x0f;  /* clear version        */
176         md5Bytes[6]  |= 0x30;  /* set to version 3     */
177         md5Bytes[8]  &amp;= 0x3f;  /* clear variant        */
178         md5Bytes[8]  |= 0x80;  /* set to IETF variant  */
179         return new UUID(md5Bytes);
180     }
181 
182     /**
183      * Creates a {@code UUID} from the string standard representation as
184      * described in the {@link #toString} method.
185      *
186      * @param  name
187      *         A string that specifies a {@code UUID}
188      *
189      * @return  A {@code UUID} with the specified value
190      *
191      * @throws  IllegalArgumentException
192      *          If name does not conform to the string representation as
193      *          described in {@link #toString}
194      *
195      */
196     public static UUID fromString(String name) {
197         int len = name.length();
198         if (len &gt; 36) {
199             throw new IllegalArgumentException(&quot;UUID string too large&quot;);
200         }
201 
202         int dash1 = name.indexOf(&#39;-&#39;, 0);
203         int dash2 = name.indexOf(&#39;-&#39;, dash1 + 1);
204         int dash3 = name.indexOf(&#39;-&#39;, dash2 + 1);
205         int dash4 = name.indexOf(&#39;-&#39;, dash3 + 1);
206         int dash5 = name.indexOf(&#39;-&#39;, dash4 + 1);
207 
208         // For any valid input, dash1 through dash4 will be positive and dash5
209         // negative, but it&#39;s enough to check dash4 and dash5:
210         // - if dash1 is -1, dash4 will be -1
211         // - if dash1 is positive but dash2 is -1, dash4 will be -1
212         // - if dash1 and dash2 is positive, dash3 will be -1, dash4 will be
213         //   positive, but so will dash5
214         if (dash4 &lt; 0 || dash5 &gt;= 0) {
215             throw new IllegalArgumentException(&quot;Invalid UUID string: &quot; + name);
216         }
217 
218         long mostSigBits = Long.parseLong(name, 0, dash1, 16) &amp; 0xffffffffL;
219         mostSigBits &lt;&lt;= 16;
220         mostSigBits |= Long.parseLong(name, dash1 + 1, dash2, 16) &amp; 0xffffL;
221         mostSigBits &lt;&lt;= 16;
222         mostSigBits |= Long.parseLong(name, dash2 + 1, dash3, 16) &amp; 0xffffL;
223         long leastSigBits = Long.parseLong(name, dash3 + 1, dash4, 16) &amp; 0xffffL;
224         leastSigBits &lt;&lt;= 48;
225         leastSigBits |= Long.parseLong(name, dash4 + 1, len, 16) &amp; 0xffffffffffffL;
226 
227         return new UUID(mostSigBits, leastSigBits);
228     }
229 
230     // Field Accessor Methods
231 
232     /**
233      * Returns the least significant 64 bits of this UUID&#39;s 128 bit value.
234      *
235      * @return  The least significant 64 bits of this UUID&#39;s 128 bit value
236      */
237     public long getLeastSignificantBits() {
238         return leastSigBits;
239     }
240 
241     /**
242      * Returns the most significant 64 bits of this UUID&#39;s 128 bit value.
243      *
244      * @return  The most significant 64 bits of this UUID&#39;s 128 bit value
245      */
246     public long getMostSignificantBits() {
247         return mostSigBits;
248     }
249 
250     /**
251      * The version number associated with this {@code UUID}.  The version
252      * number describes how this {@code UUID} was generated.
253      *
254      * The version number has the following meaning:
255      * &lt;ul&gt;
256      * &lt;li&gt;1    Time-based UUID
257      * &lt;li&gt;2    DCE security UUID
258      * &lt;li&gt;3    Name-based UUID
259      * &lt;li&gt;4    Randomly generated UUID
260      * &lt;/ul&gt;
261      *
262      * @return  The version number of this {@code UUID}
263      */
264     public int version() {
265         // Version is bits masked by 0x000000000000F000 in MS long
266         return (int)((mostSigBits &gt;&gt; 12) &amp; 0x0f);
267     }
268 
269     /**
270      * The variant number associated with this {@code UUID}.  The variant
271      * number describes the layout of the {@code UUID}.
272      *
273      * The variant number has the following meaning:
274      * &lt;ul&gt;
275      * &lt;li&gt;0    Reserved for NCS backward compatibility
276      * &lt;li&gt;2    &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;IETF&amp;nbsp;RFC&amp;nbsp;4122&lt;/a&gt;
277      * (Leach-Salz), used by this class
278      * &lt;li&gt;6    Reserved, Microsoft Corporation backward compatibility
279      * &lt;li&gt;7    Reserved for future definition
280      * &lt;/ul&gt;
281      *
282      * @return  The variant number of this {@code UUID}
283      */
284     public int variant() {
285         // This field is composed of a varying number of bits.
286         // 0    -    -    Reserved for NCS backward compatibility
287         // 1    0    -    The IETF aka Leach-Salz variant (used by this class)
288         // 1    1    0    Reserved, Microsoft backward compatibility
289         // 1    1    1    Reserved for future definition.
290         return (int) ((leastSigBits &gt;&gt;&gt; (64 - (leastSigBits &gt;&gt;&gt; 62)))
291                       &amp; (leastSigBits &gt;&gt; 63));
292     }
293 
294     /**
295      * The timestamp value associated with this UUID.
296      *
297      * &lt;p&gt; The 60 bit timestamp value is constructed from the time_low,
298      * time_mid, and time_hi fields of this {@code UUID}.  The resulting
299      * timestamp is measured in 100-nanosecond units since midnight,
300      * October 15, 1582 UTC.
301      *
302      * &lt;p&gt; The timestamp value is only meaningful in a time-based UUID, which
303      * has version type 1.  If this {@code UUID} is not a time-based UUID then
304      * this method throws UnsupportedOperationException.
305      *
306      * @throws UnsupportedOperationException
307      *         If this UUID is not a version 1 UUID
308      * @return The timestamp of this {@code UUID}.
309      */
310     public long timestamp() {
311         if (version() != 1) {
312             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
313         }
314 
315         return (mostSigBits &amp; 0x0FFFL) &lt;&lt; 48
316              | ((mostSigBits &gt;&gt; 16) &amp; 0x0FFFFL) &lt;&lt; 32
317              | mostSigBits &gt;&gt;&gt; 32;
318     }
319 
320     /**
321      * The clock sequence value associated with this UUID.
322      *
323      * &lt;p&gt; The 14 bit clock sequence value is constructed from the clock
324      * sequence field of this UUID.  The clock sequence field is used to
325      * guarantee temporal uniqueness in a time-based UUID.
326      *
327      * &lt;p&gt; The {@code clockSequence} value is only meaningful in a time-based
328      * UUID, which has version type 1.  If this UUID is not a time-based UUID
329      * then this method throws UnsupportedOperationException.
330      *
331      * @return  The clock sequence of this {@code UUID}
332      *
333      * @throws  UnsupportedOperationException
334      *          If this UUID is not a version 1 UUID
335      */
336     public int clockSequence() {
337         if (version() != 1) {
338             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
339         }
340 
341         return (int)((leastSigBits &amp; 0x3FFF000000000000L) &gt;&gt;&gt; 48);
342     }
343 
344     /**
345      * The node value associated with this UUID.
346      *
347      * &lt;p&gt; The 48 bit node value is constructed from the node field of this
348      * UUID.  This field is intended to hold the IEEE 802 address of the machine
349      * that generated this UUID to guarantee spatial uniqueness.
350      *
351      * &lt;p&gt; The node value is only meaningful in a time-based UUID, which has
352      * version type 1.  If this UUID is not a time-based UUID then this method
353      * throws UnsupportedOperationException.
354      *
355      * @return  The node value of this {@code UUID}
356      *
357      * @throws  UnsupportedOperationException
358      *          If this UUID is not a version 1 UUID
359      */
360     public long node() {
361         if (version() != 1) {
362             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
363         }
364 
365         return leastSigBits &amp; 0x0000FFFFFFFFFFFFL;
366     }
367 
368     // Object Inherited Methods
369 
370     /**
371      * Returns a {@code String} object representing this {@code UUID}.
372      *
373      * &lt;p&gt; The UUID string representation is as described by this BNF:
374      * &lt;blockquote&gt;&lt;pre&gt;
375      * {@code
376      * UUID                   = &lt;time_low&gt; &quot;-&quot; &lt;time_mid&gt; &quot;-&quot;
377      *                          &lt;time_high_and_version&gt; &quot;-&quot;
378      *                          &lt;variant_and_sequence&gt; &quot;-&quot;
379      *                          &lt;node&gt;
380      * time_low               = 4*&lt;hexOctet&gt;
381      * time_mid               = 2*&lt;hexOctet&gt;
382      * time_high_and_version  = 2*&lt;hexOctet&gt;
383      * variant_and_sequence   = 2*&lt;hexOctet&gt;
384      * node                   = 6*&lt;hexOctet&gt;
385      * hexOctet               = &lt;hexDigit&gt;&lt;hexDigit&gt;
386      * hexDigit               =
387      *       &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
388      *       | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
389      *       | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
390      * }&lt;/pre&gt;&lt;/blockquote&gt;
391      *
392      * @return  A string representation of this {@code UUID}
393      */
394     public String toString() {
395         return jla.fastUUID(leastSigBits, mostSigBits);
396     }
397 
398     /**
399      * Returns a hash code for this {@code UUID}.
400      *
401      * @return  A hash code value for this {@code UUID}
402      */
403     public int hashCode() {
404         long hilo = mostSigBits ^ leastSigBits;
405         return ((int)(hilo &gt;&gt; 32)) ^ (int) hilo;
406     }
407 
408     /**
409      * Compares this object to the specified object.  The result is {@code
410      * true} if and only if the argument is not {@code null}, is a {@code UUID}
411      * object, has the same variant, and contains the same value, bit for bit,
412      * as this {@code UUID}.
413      *
414      * @param  obj
415      *         The object to be compared
416      *
417      * @return  {@code true} if the objects are the same; {@code false}
418      *          otherwise
419      */
420     public boolean equals(Object obj) {
421         if ((null == obj) || (obj.getClass() != UUID.class))
422             return false;
423         UUID id = (UUID)obj;
424         return (mostSigBits == id.mostSigBits &amp;&amp;
425                 leastSigBits == id.leastSigBits);
426     }
427 
428     // Comparison Operations
429 
430     /**
431      * Compares this UUID with the specified UUID.
432      *
433      * &lt;p&gt; The first of two UUIDs is greater than the second if the most
434      * significant field in which the UUIDs differ is greater for the first
435      * UUID.
436      *
437      * @param  val
438      *         {@code UUID} to which this {@code UUID} is to be compared
439      *
440      * @return  -1, 0 or 1 as this {@code UUID} is less than, equal to, or
441      *          greater than {@code val}
442      *
443      */
444     public int compareTo(UUID val) {
445         // The ordering is intentionally set up so that the UUIDs
446         // can simply be numerically compared as two numbers
447         return (this.mostSigBits &lt; val.mostSigBits ? -1 :
448                 (this.mostSigBits &gt; val.mostSigBits ? 1 :
449                  (this.leastSigBits &lt; val.leastSigBits ? -1 :
450                   (this.leastSigBits &gt; val.leastSigBits ? 1 :
451                    0))));
452     }
453 }
    </pre>
  </body>
</html>
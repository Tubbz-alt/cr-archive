diff a/src/java.base/share/classes/java/nio/Buffer.java b/src/java.base/share/classes/java/nio/Buffer.java
--- a/src/java.base/share/classes/java/nio/Buffer.java
+++ b/src/java.base/share/classes/java/nio/Buffer.java
@@ -26,11 +26,13 @@
 package java.nio;
 
 import jdk.internal.HotSpotIntrinsicCandidate;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.Unsafe;
+import jdk.internal.vm.annotation.ForceInline;
 
 import java.util.Spliterator;
 
 /**
  * A container for data of a specific primitive type.
@@ -211,17 +213,30 @@
     // using JNI, see NewDirectByteBuffer(void*, long).
     // Should ideally be declared final
     // NOTE: hoisted here for speed in JNI GetDirectBufferAddress
     long address;
 
+    // Used by buffers generated by the memory access API (JEP-370)
+    final MemorySegmentProxy segment;
+
+
+    // Creates a new buffer with given address and capacity.
+    //
+    Buffer(long addr, int cap, MemorySegmentProxy segment) {
+        this.address = addr;
+        this.capacity = cap;
+        this.segment = segment;
+    }
+
     // Creates a new buffer with the given mark, position, limit, and capacity,
     // after checking invariants.
     //
-    Buffer(int mark, int pos, int lim, int cap) {       // package-private
+    Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) {       // package-private
         if (cap < 0)
             throw createCapacityException(cap);
         this.capacity = cap;
+        this.segment = segment;
         limit(lim);
         position(pos);
         if (mark >= 0) {
             if (mark > pos)
                 throw new IllegalArgumentException("mark > position: ("
@@ -247,12 +262,12 @@
      * Verify that the capacity is nonnegative.
      *
      * @param  capacity
      *         The new buffer's capacity, in $type$s
      *
-     * @throws  IllegalArgumentException
-     *          If the {@code capacity} is a negative integer
+     * @throws IllegalArgumentException
+     *         If the {@code capacity} is a negative integer
      */
     static IllegalArgumentException createCapacityException(int capacity) {
         assert capacity < 0 : "capacity expected to be negative";
         return new IllegalArgumentException("capacity < 0: ("
             + capacity + " < 0)");
@@ -729,22 +744,49 @@
 
     final void discardMark() {                          // package-private
         mark = -1;
     }
 
-    static void checkBounds(int off, int len, int size) { // package-private
-        if ((off | len | (off + len) | (size - (off + len))) < 0)
-            throw new IndexOutOfBoundsException();
+    @ForceInline
+    final void checkSegment() {
+        if (segment != null) {
+            segment.checkValidState();
+        }
     }
 
     static {
         // setup access to this package in SharedSecrets
         SharedSecrets.setJavaNioAccess(
             new JavaNioAccess() {
                 @Override
                 public JavaNioAccess.BufferPool getDirectBufferPool() {
                     return Bits.BUFFER_POOL;
                 }
+
+                @Override
+                public ByteBuffer newDirectByteBuffer(long addr, int cap, Object obj, MemorySegmentProxy segment) {
+                    return new DirectByteBuffer(addr, cap, obj, segment);
+                }
+
+                @Override
+                public ByteBuffer newHeapByteBuffer(byte[] hb, int offset, int capacity, MemorySegmentProxy segment) {
+                    return new HeapByteBuffer(hb, offset, capacity, segment);
+                }
+
+                @Override
+                public Object getBufferBase(ByteBuffer bb) {
+                    return bb.base();
+                }
+
+                @Override
+                public long getBufferAddress(ByteBuffer bb) {
+                    return bb.address;
+                }
+
+                @Override
+                public void checkSegment(Buffer buffer) {
+                    buffer.checkSegment();
+                }
             });
     }
 
 }

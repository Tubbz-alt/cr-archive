<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleInfo.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 150,12 ***</span>
      // private constructors, or interfaces with multiple but related
      // entry points, must be covered by hand-written or automatically
      // generated adapter classes.
      //
      @CallerSensitive
<span class="line-modified">!     public static</span>
<span class="line-removed">-     &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>
          if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
              throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
          final MethodHandle mh;
          if (System.getSecurityManager() != null) {
              final Class&lt;?&gt; caller = Reflection.getCallerClass();
<span class="line-new-header">--- 150,11 ---</span>
      // private constructors, or interfaces with multiple but related
      // entry points, must be covered by hand-written or automatically
      // generated adapter classes.
      //
      @CallerSensitive
<span class="line-modified">!     public static &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>
          if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
              throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
          final MethodHandle mh;
          if (System.getSecurityManager() != null) {
              final Class&lt;?&gt; caller = Reflection.getCallerClass();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,12 ***</span>
      /**
       * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
       * @param x any reference
       * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     boolean isWrapperInstance(Object x) {</span>
          return x instanceof WrapperInstance;
      }
  
      private static WrapperInstance asWrapperInstance(Object x) {
          try {
<span class="line-new-header">--- 232,11 ---</span>
      /**
       * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
       * @param x any reference
       * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
       */
<span class="line-modified">!     public static boolean isWrapperInstance(Object x) {</span>
          return x instanceof WrapperInstance;
      }
  
      private static WrapperInstance asWrapperInstance(Object x) {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,12 ***</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return a method handle implementing the unique method
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     MethodHandle wrapperInstanceTarget(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceTarget();
      }
  
      /**
       * Recovers the unique single-method interface type for which this wrapper instance was created.
<span class="line-new-header">--- 254,11 ---</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return a method handle implementing the unique method
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="line-modified">!     public static MethodHandle wrapperInstanceTarget(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceTarget();
      }
  
      /**
       * Recovers the unique single-method interface type for which this wrapper instance was created.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,17 ***</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return the single-method interface type for which the wrapper was created
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="line-modified">!     public static</span>
<span class="line-removed">-     Class&lt;?&gt; wrapperInstanceType(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceType();
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     boolean isObjectMethod(Method m) {</span>
          switch (m.getName()) {
          case &quot;toString&quot;:
              return (m.getReturnType() == String.class
                      &amp;&amp; m.getParameterTypes().length == 0);
          case &quot;hashCode&quot;:
<span class="line-new-header">--- 266,15 ---</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return the single-method interface type for which the wrapper was created
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="line-modified">!     public static Class&lt;?&gt; wrapperInstanceType(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceType();
      }
  
<span class="line-modified">!     private static boolean isObjectMethod(Method m) {</span>
          switch (m.getName()) {
          case &quot;toString&quot;:
              return (m.getReturnType() == String.class
                      &amp;&amp; m.getParameterTypes().length == 0);
          case &quot;hashCode&quot;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,12 ***</span>
                      &amp;&amp; m.getParameterTypes()[0] == Object.class);
          }
          return false;
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     Object callObjectMethod(Object self, Method m, Object[] args) {</span>
          assert(isObjectMethod(m)) : m;
          switch (m.getName()) {
          case &quot;toString&quot;:
              return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
          case &quot;hashCode&quot;:
<span class="line-new-header">--- 286,11 ---</span>
                      &amp;&amp; m.getParameterTypes()[0] == Object.class);
          }
          return false;
      }
  
<span class="line-modified">!     private static Object callObjectMethod(Object self, Method m, Object[] args) {</span>
          assert(isObjectMethod(m)) : m;
          switch (m.getName()) {
          case &quot;toString&quot;:
              return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
          case &quot;hashCode&quot;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,12 ***</span>
              return (self == args[0]);
          }
          return null;
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>
          ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
          String uniqueName = null;
          for (Method m : intfc.getMethods()) {
              if (isObjectMethod(m))  continue;
              if (!Modifier.isAbstract(m.getModifiers()))  continue;
<span class="line-new-header">--- 299,11 ---</span>
              return (self == args[0]);
          }
          return null;
      }
  
<span class="line-modified">!     private static Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>
          ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
          String uniqueName = null;
          for (Method m : intfc.getMethods()) {
              if (isObjectMethod(m))  continue;
              if (!Modifier.isAbstract(m.getModifiers()))  continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,28 ***</span>
          }
          if (uniqueName == null)  return null;
          return methods.toArray(new Method[methods.size()]);
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     boolean isDefaultMethod(Method m) {</span>
          return !Modifier.isAbstract(m.getModifiers());
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>
          for (Method m : intfc.getMethods()) {
              if (!isObjectMethod(m) &amp;&amp;
                  !Modifier.isAbstract(m.getModifiers())) {
                  return true;
              }
          }
          return false;
      }
  
<span class="line-modified">!     private static</span>
<span class="line-removed">-     Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>
                               Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
          assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
  
          // Lazily compute the associated method handle from the method
          MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
<span class="line-new-header">--- 316,25 ---</span>
          }
          if (uniqueName == null)  return null;
          return methods.toArray(new Method[methods.size()]);
      }
  
<span class="line-modified">!     private static boolean isDefaultMethod(Method m) {</span>
          return !Modifier.isAbstract(m.getModifiers());
      }
  
<span class="line-modified">!     private static boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>
          for (Method m : intfc.getMethods()) {
              if (!isObjectMethod(m) &amp;&amp;
                  !Modifier.isAbstract(m.getModifiers())) {
                  return true;
              }
          }
          return false;
      }
  
<span class="line-modified">!     private static Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>
                               Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
          assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
  
          // Lazily compute the associated method handle from the method
          MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
</pre>
<center><a href="MethodHandleInfo.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
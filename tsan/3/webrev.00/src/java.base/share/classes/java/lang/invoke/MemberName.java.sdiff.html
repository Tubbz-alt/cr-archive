<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MemberName.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MemberName.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  53  * A member name may also have non-zero modifier flags.
  54  * Finally, a member name may be either resolved or unresolved.
  55  * If it is resolved, the existence of the named member has been determined by the JVM.
  56  * &lt;p&gt;
  57  * Whether resolved or not, a member name provides no access rights or
  58  * invocation capability to its possessor.  It is merely a compact
  59  * representation of all symbolic information necessary to link to
  60  * and properly use the named member.
  61  * &lt;p&gt;
  62  * When resolved, a member name&#39;s internal implementation may include references to JVM metadata.
  63  * This representation is stateless and only descriptive.
  64  * It provides no private information and no capability to use the member.
  65  * &lt;p&gt;
  66  * By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
  67  * about the internals of a method (except its bytecodes) and also
  68  * allows invocation.  A MemberName is much lighter than a Method,
  69  * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
  70  * and those seven fields omit much of the information in Method.
  71  * @author jrose
  72  */
<span class="line-modified">  73 /*non-public*/ final class ResolvedMethodName {</span>

  74     //@Injected JVM_Method* vmtarget;
  75     //@Injected Class&lt;?&gt;    vmholder;
  76 };
  77 
<span class="line-modified">  78 /*non-public*/ final class MemberName implements Member, Cloneable {</span>

  79     private Class&lt;?&gt; clazz;       // class in which the member is defined
  80     private String   name;        // may be null if not yet materialized
  81     private Object   type;        // may be null if not yet materialized
  82     private int      flags;       // modifier bits; see reflect.Modifier
  83     private ResolvedMethodName method;    // cached resolved method information
  84     //@Injected intptr_t       vmindex;   // vtable index or offset of resolved member
  85     Object   resolution;  // if null, this guy is resolved
  86 
  87     /** Return the declaring class of this member.
  88      *  In the case of a bare name and type, the declaring class will be null.
  89      */
  90     public Class&lt;?&gt; getDeclaringClass() {
  91         return clazz;
  92     }
  93 
  94     /** Utility method producing the class loader of the declaring class. */
  95     public ClassLoader getClassLoader() {
  96         return clazz.getClassLoader();
  97     }
  98 
</pre>
<hr />
<pre>
 293                 assert(refKind == REF_invokeInterface ||
 294                        refKind == REF_invokeStatic    ||
 295                        refKind == REF_invokeSpecial   ||
 296                        refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());
 297         } else {
 298             assert(false);
 299         }
 300         return true;
 301     }
 302     private boolean isObjectPublicMethod() {
 303         if (clazz == Object.class)  return true;
 304         MethodType mtype = getMethodType();
 305         if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)
 306             return true;
 307         if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)
 308             return true;
 309         if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)
 310             return true;
 311         return false;
 312     }
<span class="line-modified"> 313     /*non-public*/ boolean referenceKindIsConsistentWith(int originalRefKind) {</span>


 314         int refKind = getReferenceKind();
 315         if (refKind == originalRefKind)  return true;
 316         switch (originalRefKind) {
 317         case REF_invokeInterface:
 318             // Looking up an interface method, can get (e.g.) Object.hashCode
 319             assert(refKind == REF_invokeVirtual ||
 320                    refKind == REF_invokeSpecial) : this;
 321             return true;
 322         case REF_invokeVirtual:
 323         case REF_newInvokeSpecial:
 324             // Looked up a virtual, can get (e.g.) final String.hashCode.
 325             assert(refKind == REF_invokeSpecial) : this;
 326             return true;
 327         }
 328         assert(false) : this+&quot; != &quot;+MethodHandleNatives.refKindName((byte)originalRefKind);
 329         return true;
 330     }
 331     private boolean staticIsConsistent() {
 332         byte refKind = getReferenceKind();
 333         return MethodHandleNatives.refKindIsStatic(refKind) == isStatic() || getModifiers() == 0;
</pre>
<hr />
<pre>
 504     public boolean isField() {
 505         return testAllFlags(IS_FIELD);
 506     }
 507     /** Query whether this member is a type. */
 508     public boolean isType() {
 509         return testAllFlags(IS_TYPE);
 510     }
 511     /** Utility method to query whether this member is neither public, private, nor protected. */
 512     public boolean isPackage() {
 513         return !testAnyFlags(ALL_ACCESS);
 514     }
 515     /** Query whether this member has a CallerSensitive annotation. */
 516     public boolean isCallerSensitive() {
 517         return testAllFlags(CALLER_SENSITIVE);
 518     }
 519 
 520     /** Utility method to query whether this member is accessible from a given lookup class. */
 521     public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
 522         int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
 523         return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
<span class="line-modified"> 524                                                lookupClass, mode);</span>
 525     }
 526 
 527     /**
 528      * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
 529      */
 530     public boolean refersTo(Class&lt;?&gt; declc, String n) {
 531         return clazz == declc &amp;&amp; getName().equals(n);
 532     }
 533 
 534     /** Initialize a query.   It is not resolved. */
 535     private void init(Class&lt;?&gt; defClass, String name, Object type, int flags) {
 536         // defining class is allowed to be null (for a naked name/type pair)
 537         //name.toString();  // null check
 538         //type.equals(type);  // null check
 539         // fill in fields:
 540         this.clazz = defClass;
 541         this.name = name;
 542         this.type = type;
 543         this.flags = flags;
 544         assert(testAnyFlags(ALL_KINDS));
</pre>
<hr />
<pre>
 913         if (refKind != REF_NONE) {
 914             buf.append(&#39;/&#39;);
 915             buf.append(MethodHandleNatives.refKindName(refKind));
 916         }
 917         //buf.append(&quot;#&quot;).append(System.identityHashCode(this));
 918         return buf.toString();
 919     }
 920     private static String getName(Object obj) {
 921         if (obj instanceof Class&lt;?&gt;)
 922             return ((Class&lt;?&gt;)obj).getName();
 923         return String.valueOf(obj);
 924     }
 925 
 926     public IllegalAccessException makeAccessException(String message, Object from) {
 927         message = message + &quot;: &quot;+ toString();
 928         if (from != null)  {
 929             if (from == MethodHandles.publicLookup()) {
 930                 message += &quot;, from public Lookup&quot;;
 931             } else {
 932                 Module m;

 933                 if (from instanceof MethodHandles.Lookup) {
 934                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;

 935                     m = lookup.lookupClass().getModule();

 936                 } else {
<span class="line-modified"> 937                     m = from.getClass().getModule();</span>

 938                 }
 939                 message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;




 940             }
 941         }
 942         return new IllegalAccessException(message);
 943     }
 944     private String message() {
 945         if (isResolved())
 946             return &quot;no access&quot;;
 947         else if (isConstructor())
 948             return &quot;no such constructor&quot;;
 949         else if (isMethod())
 950             return &quot;no such method&quot;;
 951         else
 952             return &quot;no such field&quot;;
 953     }
 954     public ReflectiveOperationException makeAccessException() {
 955         String message = message() + &quot;: &quot;+ toString();
 956         ReflectiveOperationException ex;
 957         if (isResolved() || !(resolution instanceof NoSuchMethodError ||
 958                               resolution instanceof NoSuchFieldError))
 959             ex = new IllegalAccessException(message);
 960         else if (isConstructor())
 961             ex = new NoSuchMethodException(message);
 962         else if (isMethod())
 963             ex = new NoSuchMethodException(message);
 964         else
 965             ex = new NoSuchFieldException(message);
 966         if (resolution instanceof Throwable)
 967             ex.initCause((Throwable) resolution);
 968         return ex;
 969     }
 970 
 971     /** Actually making a query requires an access check. */
<span class="line-modified"> 972     /*non-public*/ static Factory getFactory() {</span>

 973         return Factory.INSTANCE;
 974     }
 975     /** A factory type for resolving member names with the help of the VM.
 976      *  TBD: Define access-safe public constructors for this factory.
 977      */
<span class="line-modified"> 978     /*non-public*/ static class Factory {</span>

 979         private Factory() { } // singleton pattern
 980         static Factory INSTANCE = new Factory();
 981 
 982         private static int ALLOWED_FLAGS = ALL_KINDS;
 983 
 984         /// Queries
 985         List&lt;MemberName&gt; getMembers(Class&lt;?&gt; defc,
 986                 String matchName, Object matchType,
 987                 int matchFlags, Class&lt;?&gt; lookupClass) {
 988             matchFlags &amp;= ALLOWED_FLAGS;
 989             String matchSig = null;
 990             if (matchType != null) {
 991                 matchSig = BytecodeDescriptor.unparse(matchType);
 992                 if (matchSig.startsWith(&quot;(&quot;))
 993                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_INVOCABLE);
 994                 else
 995                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_FIELD);
 996             }
 997             final int BUF_MAX = 0x2000;
 998             int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;
</pre>
<hr />
<pre>
1073                 }
1074                 m.checkForTypeAlias(m.getDeclaringClass());
1075                 m.resolution = null;
1076             } catch (ClassNotFoundException | LinkageError ex) {
1077                 // JVM reports that the &quot;bytecode behavior&quot; would get an error
1078                 assert(!m.isResolved());
1079                 m.resolution = ex;
1080                 return m;
1081             }
1082             assert(m.referenceKindIsConsistent());
1083             m.initResolved(true);
1084             assert(m.vminfoIsConsistent());
1085             return m;
1086         }
1087         /** Produce a resolved version of the given member.
1088          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1089          *  Access checking is performed on behalf of the given {@code lookupClass}.
1090          *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
1091          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1092          */
<span class="line-modified">1093         public</span>
<span class="line-modified">1094         &lt;NoSuchMemberException extends ReflectiveOperationException&gt;</span>
<span class="line-removed">1095         MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,</span>
1096                                  Class&lt;NoSuchMemberException&gt; nsmClass)
1097                 throws IllegalAccessException, NoSuchMemberException {
1098             MemberName result = resolve(refKind, m, lookupClass, false);
1099             if (result.isResolved())
1100                 return result;
1101             ReflectiveOperationException ex = result.makeAccessException();
1102             if (ex instanceof IllegalAccessException)  throw (IllegalAccessException) ex;
1103             throw nsmClass.cast(ex);
1104         }
1105         /** Produce a resolved version of the given member.
1106          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1107          *  Access checking is performed on behalf of the given {@code lookupClass}.
1108          *  If lookup fails or access is not permitted, return null.
1109          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1110          */
<span class="line-modified">1111         public</span>
<span class="line-removed">1112         MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {</span>
1113             MemberName result = resolve(refKind, m, lookupClass, true);
1114             if (result != null &amp;&amp; result.isResolved())
1115                 return result;
1116             return null;
1117         }
1118         /** Return a list of all methods defined by the given class.
1119          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1120          *  Access checking is performed on behalf of the given {@code lookupClass}.
1121          *  Inaccessible members are not added to the last.
1122          */
1123         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1124                 Class&lt;?&gt; lookupClass) {
1125             return getMethods(defc, searchSupers, null, null, lookupClass);
1126         }
1127         /** Return a list of matching methods defined by the given class.
1128          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1129          *  Returned methods will match the name (if not null) and the type (if not null).
1130          *  Access checking is performed on behalf of the given {@code lookupClass}.
1131          *  Inaccessible members are not added to the last.
1132          */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  53  * A member name may also have non-zero modifier flags.
  54  * Finally, a member name may be either resolved or unresolved.
  55  * If it is resolved, the existence of the named member has been determined by the JVM.
  56  * &lt;p&gt;
  57  * Whether resolved or not, a member name provides no access rights or
  58  * invocation capability to its possessor.  It is merely a compact
  59  * representation of all symbolic information necessary to link to
  60  * and properly use the named member.
  61  * &lt;p&gt;
  62  * When resolved, a member name&#39;s internal implementation may include references to JVM metadata.
  63  * This representation is stateless and only descriptive.
  64  * It provides no private information and no capability to use the member.
  65  * &lt;p&gt;
  66  * By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
  67  * about the internals of a method (except its bytecodes) and also
  68  * allows invocation.  A MemberName is much lighter than a Method,
  69  * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
  70  * and those seven fields omit much of the information in Method.
  71  * @author jrose
  72  */
<span class="line-modified">  73 /*non-public*/</span>
<span class="line-added">  74 final class ResolvedMethodName {</span>
  75     //@Injected JVM_Method* vmtarget;
  76     //@Injected Class&lt;?&gt;    vmholder;
  77 };
  78 
<span class="line-modified">  79 /*non-public*/</span>
<span class="line-added">  80 final class MemberName implements Member, Cloneable {</span>
  81     private Class&lt;?&gt; clazz;       // class in which the member is defined
  82     private String   name;        // may be null if not yet materialized
  83     private Object   type;        // may be null if not yet materialized
  84     private int      flags;       // modifier bits; see reflect.Modifier
  85     private ResolvedMethodName method;    // cached resolved method information
  86     //@Injected intptr_t       vmindex;   // vtable index or offset of resolved member
  87     Object   resolution;  // if null, this guy is resolved
  88 
  89     /** Return the declaring class of this member.
  90      *  In the case of a bare name and type, the declaring class will be null.
  91      */
  92     public Class&lt;?&gt; getDeclaringClass() {
  93         return clazz;
  94     }
  95 
  96     /** Utility method producing the class loader of the declaring class. */
  97     public ClassLoader getClassLoader() {
  98         return clazz.getClassLoader();
  99     }
 100 
</pre>
<hr />
<pre>
 295                 assert(refKind == REF_invokeInterface ||
 296                        refKind == REF_invokeStatic    ||
 297                        refKind == REF_invokeSpecial   ||
 298                        refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());
 299         } else {
 300             assert(false);
 301         }
 302         return true;
 303     }
 304     private boolean isObjectPublicMethod() {
 305         if (clazz == Object.class)  return true;
 306         MethodType mtype = getMethodType();
 307         if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)
 308             return true;
 309         if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)
 310             return true;
 311         if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)
 312             return true;
 313         return false;
 314     }
<span class="line-modified"> 315 </span>
<span class="line-added"> 316     /*non-public*/</span>
<span class="line-added"> 317     boolean referenceKindIsConsistentWith(int originalRefKind) {</span>
 318         int refKind = getReferenceKind();
 319         if (refKind == originalRefKind)  return true;
 320         switch (originalRefKind) {
 321         case REF_invokeInterface:
 322             // Looking up an interface method, can get (e.g.) Object.hashCode
 323             assert(refKind == REF_invokeVirtual ||
 324                    refKind == REF_invokeSpecial) : this;
 325             return true;
 326         case REF_invokeVirtual:
 327         case REF_newInvokeSpecial:
 328             // Looked up a virtual, can get (e.g.) final String.hashCode.
 329             assert(refKind == REF_invokeSpecial) : this;
 330             return true;
 331         }
 332         assert(false) : this+&quot; != &quot;+MethodHandleNatives.refKindName((byte)originalRefKind);
 333         return true;
 334     }
 335     private boolean staticIsConsistent() {
 336         byte refKind = getReferenceKind();
 337         return MethodHandleNatives.refKindIsStatic(refKind) == isStatic() || getModifiers() == 0;
</pre>
<hr />
<pre>
 508     public boolean isField() {
 509         return testAllFlags(IS_FIELD);
 510     }
 511     /** Query whether this member is a type. */
 512     public boolean isType() {
 513         return testAllFlags(IS_TYPE);
 514     }
 515     /** Utility method to query whether this member is neither public, private, nor protected. */
 516     public boolean isPackage() {
 517         return !testAnyFlags(ALL_ACCESS);
 518     }
 519     /** Query whether this member has a CallerSensitive annotation. */
 520     public boolean isCallerSensitive() {
 521         return testAllFlags(CALLER_SENSITIVE);
 522     }
 523 
 524     /** Utility method to query whether this member is accessible from a given lookup class. */
 525     public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
 526         int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
 527         return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
<span class="line-modified"> 528                                                lookupClass, null, mode);</span>
 529     }
 530 
 531     /**
 532      * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
 533      */
 534     public boolean refersTo(Class&lt;?&gt; declc, String n) {
 535         return clazz == declc &amp;&amp; getName().equals(n);
 536     }
 537 
 538     /** Initialize a query.   It is not resolved. */
 539     private void init(Class&lt;?&gt; defClass, String name, Object type, int flags) {
 540         // defining class is allowed to be null (for a naked name/type pair)
 541         //name.toString();  // null check
 542         //type.equals(type);  // null check
 543         // fill in fields:
 544         this.clazz = defClass;
 545         this.name = name;
 546         this.type = type;
 547         this.flags = flags;
 548         assert(testAnyFlags(ALL_KINDS));
</pre>
<hr />
<pre>
 917         if (refKind != REF_NONE) {
 918             buf.append(&#39;/&#39;);
 919             buf.append(MethodHandleNatives.refKindName(refKind));
 920         }
 921         //buf.append(&quot;#&quot;).append(System.identityHashCode(this));
 922         return buf.toString();
 923     }
 924     private static String getName(Object obj) {
 925         if (obj instanceof Class&lt;?&gt;)
 926             return ((Class&lt;?&gt;)obj).getName();
 927         return String.valueOf(obj);
 928     }
 929 
 930     public IllegalAccessException makeAccessException(String message, Object from) {
 931         message = message + &quot;: &quot;+ toString();
 932         if (from != null)  {
 933             if (from == MethodHandles.publicLookup()) {
 934                 message += &quot;, from public Lookup&quot;;
 935             } else {
 936                 Module m;
<span class="line-added"> 937                 Class&lt;?&gt; plc;</span>
 938                 if (from instanceof MethodHandles.Lookup) {
 939                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
<span class="line-added"> 940                     from = lookup.lookupClass();</span>
 941                     m = lookup.lookupClass().getModule();
<span class="line-added"> 942                     plc = lookup.previousLookupClass();</span>
 943                 } else {
<span class="line-modified"> 944                     m = ((Class&lt;?&gt;)from).getModule();</span>
<span class="line-added"> 945                     plc = null;</span>
 946                 }
 947                 message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
<span class="line-added"> 948                 if (plc != null) {</span>
<span class="line-added"> 949                     message += &quot;, previous lookup &quot; +</span>
<span class="line-added"> 950                         plc.getName() + &quot; (&quot; + plc.getModule() + &quot;)&quot;;</span>
<span class="line-added"> 951                 }</span>
 952             }
 953         }
 954         return new IllegalAccessException(message);
 955     }
 956     private String message() {
 957         if (isResolved())
 958             return &quot;no access&quot;;
 959         else if (isConstructor())
 960             return &quot;no such constructor&quot;;
 961         else if (isMethod())
 962             return &quot;no such method&quot;;
 963         else
 964             return &quot;no such field&quot;;
 965     }
 966     public ReflectiveOperationException makeAccessException() {
 967         String message = message() + &quot;: &quot;+ toString();
 968         ReflectiveOperationException ex;
 969         if (isResolved() || !(resolution instanceof NoSuchMethodError ||
 970                               resolution instanceof NoSuchFieldError))
 971             ex = new IllegalAccessException(message);
 972         else if (isConstructor())
 973             ex = new NoSuchMethodException(message);
 974         else if (isMethod())
 975             ex = new NoSuchMethodException(message);
 976         else
 977             ex = new NoSuchFieldException(message);
 978         if (resolution instanceof Throwable)
 979             ex.initCause((Throwable) resolution);
 980         return ex;
 981     }
 982 
 983     /** Actually making a query requires an access check. */
<span class="line-modified"> 984     /*non-public*/</span>
<span class="line-added"> 985     static Factory getFactory() {</span>
 986         return Factory.INSTANCE;
 987     }
 988     /** A factory type for resolving member names with the help of the VM.
 989      *  TBD: Define access-safe public constructors for this factory.
 990      */
<span class="line-modified"> 991     /*non-public*/</span>
<span class="line-added"> 992     static class Factory {</span>
 993         private Factory() { } // singleton pattern
 994         static Factory INSTANCE = new Factory();
 995 
 996         private static int ALLOWED_FLAGS = ALL_KINDS;
 997 
 998         /// Queries
 999         List&lt;MemberName&gt; getMembers(Class&lt;?&gt; defc,
1000                 String matchName, Object matchType,
1001                 int matchFlags, Class&lt;?&gt; lookupClass) {
1002             matchFlags &amp;= ALLOWED_FLAGS;
1003             String matchSig = null;
1004             if (matchType != null) {
1005                 matchSig = BytecodeDescriptor.unparse(matchType);
1006                 if (matchSig.startsWith(&quot;(&quot;))
1007                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_INVOCABLE);
1008                 else
1009                     matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_FIELD);
1010             }
1011             final int BUF_MAX = 0x2000;
1012             int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;
</pre>
<hr />
<pre>
1087                 }
1088                 m.checkForTypeAlias(m.getDeclaringClass());
1089                 m.resolution = null;
1090             } catch (ClassNotFoundException | LinkageError ex) {
1091                 // JVM reports that the &quot;bytecode behavior&quot; would get an error
1092                 assert(!m.isResolved());
1093                 m.resolution = ex;
1094                 return m;
1095             }
1096             assert(m.referenceKindIsConsistent());
1097             m.initResolved(true);
1098             assert(m.vminfoIsConsistent());
1099             return m;
1100         }
1101         /** Produce a resolved version of the given member.
1102          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1103          *  Access checking is performed on behalf of the given {@code lookupClass}.
1104          *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
1105          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1106          */
<span class="line-modified">1107         public &lt;NoSuchMemberException extends ReflectiveOperationException&gt;</span>
<span class="line-modified">1108                 MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,</span>

1109                                  Class&lt;NoSuchMemberException&gt; nsmClass)
1110                 throws IllegalAccessException, NoSuchMemberException {
1111             MemberName result = resolve(refKind, m, lookupClass, false);
1112             if (result.isResolved())
1113                 return result;
1114             ReflectiveOperationException ex = result.makeAccessException();
1115             if (ex instanceof IllegalAccessException)  throw (IllegalAccessException) ex;
1116             throw nsmClass.cast(ex);
1117         }
1118         /** Produce a resolved version of the given member.
1119          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1120          *  Access checking is performed on behalf of the given {@code lookupClass}.
1121          *  If lookup fails or access is not permitted, return null.
1122          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
1123          */
<span class="line-modified">1124         public MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {</span>

1125             MemberName result = resolve(refKind, m, lookupClass, true);
1126             if (result != null &amp;&amp; result.isResolved())
1127                 return result;
1128             return null;
1129         }
1130         /** Return a list of all methods defined by the given class.
1131          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1132          *  Access checking is performed on behalf of the given {@code lookupClass}.
1133          *  Inaccessible members are not added to the last.
1134          */
1135         public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
1136                 Class&lt;?&gt; lookupClass) {
1137             return getMethods(defc, searchSupers, null, null, lookupClass);
1138         }
1139         /** Return a list of matching methods defined by the given class.
1140          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
1141          *  Returned methods will match the name (if not null) and the type (if not null).
1142          *  Access checking is performed on behalf of the given {@code lookupClass}.
1143          *  Inaccessible members are not added to the last.
1144          */
</pre>
</td>
</tr>
</table>
<center><a href="LambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
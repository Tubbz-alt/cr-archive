<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 import static java.util.Locale.ENGLISH;
  31 import java.lang.ref.*;
  32 import java.lang.reflect.*;
  33 import java.util.function.BiConsumer;
  34 import java.util.function.BiFunction;
  35 import java.util.function.Function;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 
  38 /**
  39  * This class represents a &quot;provider&quot; for the
  40  * Java Security API, where a provider implements some or all parts of
  41  * Java Security. Services that a provider may implement include:
  42  *
  43  * &lt;ul&gt;
  44  *
  45  * &lt;li&gt;Algorithms (such as DSA, RSA, or SHA-256).
  46  *
  47  * &lt;li&gt;Key generation, conversion, and management facilities (such as for
  48  * algorithm-specific keys).
  49  *
  50  * &lt;/ul&gt;
  51  *
  52  * &lt;p&gt;Some provider implementations may encounter unrecoverable internal
  53  * errors during their operation, for example a failure to communicate with a
  54  * security token. A {@link ProviderException} should be used to indicate
  55  * such errors.
  56  *
  57  * &lt;p&gt;Please note that a provider can be used to implement any security
  58  * service in Java that uses a pluggable architecture with a choice
  59  * of implementations that fit underneath.
  60  *
  61  * &lt;p&gt;The service type {@code Provider} is reserved for use by the
  62  * security framework. Services of this type cannot be added, removed,
  63  * or modified by applications.
  64  * The following attributes are automatically placed in each Provider object:
  65  * &lt;table class=&quot;striped&quot;&gt;
  66  * &lt;caption&gt;&lt;b&gt;Attributes Automatically Placed in a Provider Object&lt;/b&gt;&lt;/caption&gt;
  67  * &lt;thead&gt;
  68  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Name&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Value&lt;/th&gt;
  69  * &lt;/thead&gt;
  70  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  71  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id name}&lt;/th&gt;
  72  *     &lt;td&gt;{@code String.valueOf(provider.getName())}&lt;/td&gt;
  73  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id version}&lt;/th&gt;
  74  *     &lt;td&gt;{@code String.valueOf(provider.getVersionStr())}&lt;/td&gt;
  75  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id info}&lt;/th&gt;
  76  *     &lt;td&gt;{@code String.valueOf(provider.getInfo())}&lt;/td&gt;
  77  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Provider.id className}&lt;/th&gt;
  78  *     &lt;td&gt;{@code provider.getClass().getName()}&lt;/td&gt;
  79  * &lt;/tbody&gt;
  80  * &lt;/table&gt;
  81  *
  82  * &lt;p&gt;Each provider has a name and a version string. A provider normally
  83  * identifies itself with a file named {@code java.security.Provider}
  84  * in the resource directory {@code META-INF/services}.
  85  * Security providers are looked up via the {@link ServiceLoader} mechanism
  86  * using the {@link ClassLoader#getSystemClassLoader application class loader}.
  87  *
  88  * &lt;p&gt;Providers may be configured such that they are automatically
  89  * installed and made available at runtime via the
  90  * {@link Security#getProviders() Security.getProviders()} method.
  91  * The mechanism for configuring and installing security providers is
  92  * implementation-specific.
  93  *
  94  * @implNote
  95  * The JDK implementation supports static registration of the security
  96  * providers via the {@code conf/security/java.security} file in the Java
  97  * installation directory. These providers are automatically installed by
  98  * the JDK runtime, see {@extLink security_guide_jca_provider
  99  * The Provider Class}
 100  * in the Java Cryptography Architecture (JCA) Reference Guide
 101  * for information about how a particular type of provider, the cryptographic
 102  * service provider, works and is installed.
 103  *
 104  * @author Benjamin Renaud
 105  * @author Andreas Sterbenz
 106  * @since 1.1
 107  */
 108 public abstract class Provider extends Properties {
 109 
 110     // Declare serialVersionUID to be compatible with JDK1.1
 111     private static final long serialVersionUID = -4298000515446427739L;
 112 
 113     private static final sun.security.util.Debug debug =
 114         sun.security.util.Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 115 
 116     /**
 117      * The provider name.
 118      *
 119      * @serial
 120      */
 121     private String name;
 122 
 123     /**
 124      * A description of the provider and its services.
 125      *
 126      * @serial
 127      */
 128     private String info;
 129 
 130     /**
 131      * The provider version number.
 132      *
 133      * @serial
 134      */
 135     private double version;
 136 
 137     /**
 138      * The provider version string.
 139      *
 140      * @serial
 141      */
 142     private String versionStr;
 143 
 144     private transient Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet = null;
 145     private transient int entrySetCallCount = 0;
 146 
 147     private transient boolean initialized;
 148 
 149     private static Object newInstanceUtil(final Class&lt;?&gt; clazz,
 150         final Class&lt;?&gt; ctrParamClz, final Object ctorParamObj)
 151         throws Exception {
 152         if (ctrParamClz == null) {
 153             Constructor&lt;?&gt; con = clazz.getConstructor();
 154             return con.newInstance();
 155         } else {
 156             // Looking for the constructor with a params first and fallback
 157             // to one without if not found. This is to support the enhanced
 158             // SecureRandom where both styles of constructors are supported.
 159             // Before jdk9, there was no params support (only getInstance(alg))
 160             // and an impl only had the params-less constructor. Since jdk9,
 161             // there is getInstance(alg,params) and an impl can contain
 162             // an Impl(params) constructor.
 163             try {
 164                 Constructor&lt;?&gt; con = clazz.getConstructor(ctrParamClz);
 165                 return con.newInstance(ctorParamObj);
 166             } catch (NoSuchMethodException nsme) {
 167                 // For pre-jdk9 SecureRandom implementations, they only
 168                 // have params-less constructors which still works when
 169                 // the input ctorParamObj is null.
 170                 //
 171                 // For other primitives using params, ctorParamObj should not
 172                 // be null and nsme is thrown, just like before.
 173                 if (ctorParamObj == null) {
 174                     try {
 175                         Constructor&lt;?&gt; con = clazz.getConstructor();
 176                         return con.newInstance();
 177                     } catch (NoSuchMethodException nsme2) {
 178                         nsme.addSuppressed(nsme2);
 179                         throw nsme;
 180                     }
 181                 } else {
 182                     throw nsme;
 183                 }
 184             }
 185         }
 186     }
 187 
 188     private static double parseVersionStr(String s) {
 189         try {
 190             int firstDotIdx = s.indexOf(&#39;.&#39;);
 191             int nextDotIdx = s.indexOf(&#39;.&#39;, firstDotIdx + 1);
 192             if (nextDotIdx != -1) {
 193                 s = s.substring(0, nextDotIdx);
 194             }
 195             int endIdx = s.indexOf(&#39;-&#39;);
 196             if (endIdx &gt; 0) {
 197                 s = s.substring(0, endIdx);
 198             }
 199             endIdx = s.indexOf(&#39;+&#39;);
 200             if (endIdx &gt; 0) {
 201                 s = s.substring(0, endIdx);
 202             }
 203             return Double.parseDouble(s);
 204         } catch (NullPointerException | NumberFormatException e) {
 205             return 0d;
 206         }
 207     }
 208 
 209     /**
 210      * Constructs a provider with the specified name, version number,
 211      * and information. Calling this constructor is equivalent to call the
 212      * {@link #Provider(String, String, String)} with {@code name}
 213      * name, {@code Double.toString(version)}, and {@code info}.
 214      *
 215      * @param name the provider name.
 216      *
 217      * @param version the provider version number.
 218      *
 219      * @param info a description of the provider and its services.
 220      *
 221      * @deprecated use {@link #Provider(String, String, String)} instead.
 222      */
 223     @Deprecated(since=&quot;9&quot;)
 224     protected Provider(String name, double version, String info) {
 225         this.name = name;
 226         this.version = version;
 227         this.versionStr = Double.toString(version);
 228         this.info = info;
 229         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 230         putId();
 231         initialized = true;
 232     }
 233 
 234     /**
 235      * Constructs a provider with the specified name, version string,
 236      * and information.
 237      *
 238      * &lt;p&gt;The version string contains a version number optionally followed
 239      * by other information separated by one of the characters of &#39;+&#39;, &#39;-&#39;.
 240      *
 241      * The format for the version number is:
 242      *
 243      * &lt;blockquote&gt;&lt;pre&gt;
 244      *     ^[0-9]+(\.[0-9]+)*
 245      * &lt;/pre&gt;&lt;/blockquote&gt;
 246      *
 247      * &lt;p&gt;In order to return the version number in a double, when there are
 248      * more than two components (separated by &#39;.&#39; as defined above), only
 249      * the first two components are retained. The resulting string is then
 250      * passed to {@link Double#valueOf(String)} to generate version number,
 251      * i.e. {@link #getVersion}.
 252      * &lt;p&gt;If the conversion failed, value 0 will be used.
 253      *
 254      * @param name the provider name.
 255      *
 256      * @param versionStr the provider version string.
 257      *
 258      * @param info a description of the provider and its services.
 259      *
 260      * @since 9
 261      */
 262     protected Provider(String name, String versionStr, String info) {
 263         this.name = name;
 264         this.versionStr = versionStr;
 265         this.version = parseVersionStr(versionStr);
 266         this.info = info;
 267         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 268         putId();
 269         initialized = true;
 270     }
 271 
 272     /**
 273      * Apply the supplied configuration argument to this provider instance
 274      * and return the configured provider. Note that if this provider cannot
 275      * be configured in-place, a new provider will be created and returned.
 276      * Therefore, callers should always use the returned provider.
 277      *
 278      * @implSpec
 279      * The default implementation throws {@code UnsupportedOperationException}.
 280      * Subclasses should override this method only if a configuration argument
 281      * is supported.
 282      *
 283      * @param configArg the configuration information for configuring this
 284      *         provider.
 285      *
 286      * @throws UnsupportedOperationException if a configuration argument is
 287      *         not supported.
 288      * @throws NullPointerException if the supplied configuration argument is
 289                null.
 290      * @throws InvalidParameterException if the supplied configuration argument
 291      *         is invalid.
 292      * @return a provider configured with the supplied configuration argument.
 293      *
 294      * @since 9
 295      */
 296     public Provider configure(String configArg) {
 297         throw new UnsupportedOperationException(&quot;configure is not supported&quot;);
 298     }
 299 
 300     /**
 301      * Check if this provider instance has been configured.
 302      *
 303      * @implSpec
 304      * The default implementation returns true.
 305      * Subclasses should override this method if the provider instance requires
 306      * an explicit {@code configure} call after being constructed.
 307      *
 308      * @return true if no further configuration is needed, false otherwise.
 309      *
 310      * @since 9
 311      */
 312     public boolean isConfigured() {
 313         return true;
 314     }
 315 
 316 
 317     /**
 318      * Returns the name of this provider.
 319      *
 320      * @return the name of this provider.
 321      */
 322     public String getName() {
 323         return name;
 324     }
 325 
 326     /**
 327      * Returns the version number for this provider.
 328      *
 329      * @return the version number for this provider.
 330      *
 331      * @deprecated use {@link #getVersionStr} instead.
 332      */
 333     @Deprecated(since=&quot;9&quot;)
 334     public double getVersion() {
 335         return version;
 336     }
 337 
 338     /**
 339      * Returns the version string for this provider.
 340      *
 341      * @return the version string for this provider.
 342      *
 343      * @since 9
 344      */
 345     public String getVersionStr() {
 346         return versionStr;
 347     }
 348 
 349     /**
 350      * Returns a human-readable description of the provider and its
 351      * services.  This may return an HTML page, with relevant links.
 352      *
 353      * @return a description of the provider and its services.
 354      */
 355     public String getInfo() {
 356         return info;
 357     }
 358 
 359     /**
 360      * Returns a string with the name and the version string
 361      * of this provider.
 362      *
 363      * @return the string with the name and the version string
 364      * for this provider.
 365      */
 366     public String toString() {
 367         return name + &quot; version &quot; + versionStr;
 368     }
 369 
 370     /*
 371      * override the following methods to ensure that provider
 372      * information can only be changed if the caller has the appropriate
 373      * permissions.
 374      */
 375 
 376     /**
 377      * Clears this provider so that it no longer contains the properties
 378      * used to look up facilities implemented by the provider.
 379      *
 380      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 381      * method is called with the string {@code &quot;clearProviderProperties.&quot;+name}
 382      * (where {@code name} is the provider name) to see if it&#39;s ok to clear
 383      * this provider.
 384      *
 385      * @throws  SecurityException
 386      *          if a security manager exists and its {@link
 387      *          java.lang.SecurityManager#checkSecurityAccess} method
 388      *          denies access to clear this provider
 389      *
 390      * @since 1.2
 391      */
 392     @Override
 393     public synchronized void clear() {
 394         check(&quot;clearProviderProperties.&quot;+name);
 395         if (debug != null) {
 396             debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);
 397         }
 398         implClear();
 399     }
 400 
 401     /**
 402      * Reads a property list (key and element pairs) from the input stream.
 403      *
 404      * @param inStream the input stream.
 405      * @exception IOException if an error occurred when reading from the
 406      *               input stream.
 407      * @see java.util.Properties#load
 408      */
 409     @Override
 410     public synchronized void load(InputStream inStream) throws IOException {
 411         check(&quot;putProviderProperty.&quot;+name);
 412         if (debug != null) {
 413             debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);
 414         }
 415         Properties tempProperties = new Properties();
 416         tempProperties.load(inStream);
 417         implPutAll(tempProperties);
 418     }
 419 
 420     /**
 421      * Copies all of the mappings from the specified Map to this provider.
 422      * These mappings will replace any properties that this provider had
 423      * for any of the keys currently in the specified Map.
 424      *
 425      * @since 1.2
 426      */
 427     @Override
 428     public synchronized void putAll(Map&lt;?,?&gt; t) {
 429         check(&quot;putProviderProperty.&quot;+name);
 430         if (debug != null) {
 431             debug.println(&quot;Put all &quot; + name + &quot; provider properties&quot;);
 432         }
 433         implPutAll(t);
 434     }
 435 
 436     /**
 437      * Returns an unmodifiable Set view of the property entries contained
 438      * in this Provider.
 439      *
 440      * @see   java.util.Map.Entry
 441      * @since 1.2
 442      */
 443     @Override
 444     public synchronized Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
 445         checkInitialized();
 446         if (entrySet == null) {
 447             if (entrySetCallCount++ == 0)  // Initial call
 448                 entrySet = Collections.unmodifiableMap(this).entrySet();
 449             else
 450                 return super.entrySet();   // Recursive call
 451         }
 452 
 453         // This exception will be thrown if the implementation of
 454         // Collections.unmodifiableMap.entrySet() is changed such that it
 455         // no longer calls entrySet() on the backing Map.  (Provider&#39;s
 456         // entrySet implementation depends on this &quot;implementation detail&quot;,
 457         // which is unlikely to change.
 458         if (entrySetCallCount != 2)
 459             throw new RuntimeException(&quot;Internal error.&quot;);
 460 
 461         return entrySet;
 462     }
 463 
 464     /**
 465      * Returns an unmodifiable Set view of the property keys contained in
 466      * this provider.
 467      *
 468      * @since 1.2
 469      */
 470     @Override
 471     public Set&lt;Object&gt; keySet() {
 472         checkInitialized();
 473         return Collections.unmodifiableSet(super.keySet());
 474     }
 475 
 476     /**
 477      * Returns an unmodifiable Collection view of the property values
 478      * contained in this provider.
 479      *
 480      * @since 1.2
 481      */
 482     @Override
 483     public Collection&lt;Object&gt; values() {
 484         checkInitialized();
 485         return Collections.unmodifiableCollection(super.values());
 486     }
 487 
 488     /**
 489      * Sets the {@code key} property to have the specified
 490      * {@code value}.
 491      *
 492      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 493      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 494      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 495      * provider&#39;s property values.
 496      *
 497      * @throws  SecurityException
 498      *          if a security manager exists and its {@link
 499      *          java.lang.SecurityManager#checkSecurityAccess} method
 500      *          denies access to set property values.
 501      *
 502      * @since 1.2
 503      */
 504     @Override
 505     public synchronized Object put(Object key, Object value) {
 506         check(&quot;putProviderProperty.&quot;+name);
 507         if (debug != null) {
 508             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 509                           key + &quot;/&quot; + value +&quot;]&quot;);
 510         }
 511         return implPut(key, value);
 512     }
 513 
 514     /**
 515      * If the specified key is not already associated with a value (or is mapped
 516      * to {@code null}) associates it with the given value and returns
 517      * {@code null}, else returns the current value.
 518      *
 519      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 520      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 521      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 522      * provider&#39;s property values.
 523      *
 524      * @throws  SecurityException
 525      *          if a security manager exists and its {@link
 526      *          java.lang.SecurityManager#checkSecurityAccess} method
 527      *          denies access to set property values.
 528      *
 529      * @since 1.8
 530      */
 531     @Override
 532     public synchronized Object putIfAbsent(Object key, Object value) {
 533         check(&quot;putProviderProperty.&quot;+name);
 534         if (debug != null) {
 535             debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +
 536                           key + &quot;/&quot; + value +&quot;]&quot;);
 537         }
 538         return implPutIfAbsent(key, value);
 539     }
 540 
 541     /**
 542      * Removes the {@code key} property (and its corresponding
 543      * {@code value}).
 544      *
 545      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 546      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 547      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 548      * provider&#39;s properties.
 549      *
 550      * @throws  SecurityException
 551      *          if a security manager exists and its {@link
 552      *          java.lang.SecurityManager#checkSecurityAccess} method
 553      *          denies access to remove this provider&#39;s properties.
 554      *
 555      * @since 1.2
 556      */
 557     @Override
 558     public synchronized Object remove(Object key) {
 559         check(&quot;removeProviderProperty.&quot;+name);
 560         if (debug != null) {
 561             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 562         }
 563         return implRemove(key);
 564     }
 565 
 566     /**
 567      * Removes the entry for the specified key only if it is currently
 568      * mapped to the specified value.
 569      *
 570      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 571      * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
 572      * where {@code name} is the provider name, to see if it&#39;s ok to remove this
 573      * provider&#39;s properties.
 574      *
 575      * @throws  SecurityException
 576      *          if a security manager exists and its {@link
 577      *          java.lang.SecurityManager#checkSecurityAccess} method
 578      *          denies access to remove this provider&#39;s properties.
 579      *
 580      * @since 1.8
 581      */
 582     @Override
 583     public synchronized boolean remove(Object key, Object value) {
 584         check(&quot;removeProviderProperty.&quot;+name);
 585         if (debug != null) {
 586             debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);
 587         }
 588         return implRemove(key, value);
 589     }
 590 
 591     /**
 592      * Replaces the entry for the specified key only if currently
 593      * mapped to the specified value.
 594      *
 595      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 596      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 597      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 598      * provider&#39;s property values.
 599      *
 600      * @throws  SecurityException
 601      *          if a security manager exists and its {@link
 602      *          java.lang.SecurityManager#checkSecurityAccess} method
 603      *          denies access to set property values.
 604      *
 605      * @since 1.8
 606      */
 607     @Override
 608     public synchronized boolean replace(Object key, Object oldValue,
 609             Object newValue) {
 610         check(&quot;putProviderProperty.&quot; + name);
 611 
 612         if (debug != null) {
 613             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 614         }
 615         return implReplace(key, oldValue, newValue);
 616     }
 617 
 618     /**
 619      * Replaces the entry for the specified key only if it is
 620      * currently mapped to some value.
 621      *
 622      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 623      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 624      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 625      * provider&#39;s property values.
 626      *
 627      * @throws  SecurityException
 628      *          if a security manager exists and its {@link
 629      *          java.lang.SecurityManager#checkSecurityAccess} method
 630      *          denies access to set property values.
 631      *
 632      * @since 1.8
 633      */
 634     @Override
 635     public synchronized Object replace(Object key, Object value) {
 636         check(&quot;putProviderProperty.&quot; + name);
 637 
 638         if (debug != null) {
 639             debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);
 640         }
 641         return implReplace(key, value);
 642     }
 643 
 644     /**
 645      * Replaces each entry&#39;s value with the result of invoking the given
 646      * function on that entry, in the order entries are returned by an entry
 647      * set iterator, until all entries have been processed or the function
 648      * throws an exception.
 649      *
 650      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 651      * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
 652      * where {@code name} is the provider name, to see if it&#39;s ok to set this
 653      * provider&#39;s property values.
 654      *
 655      * @throws  SecurityException
 656      *          if a security manager exists and its {@link
 657      *          java.lang.SecurityManager#checkSecurityAccess} method
 658      *          denies access to set property values.
 659      *
 660      * @since 1.8
 661      */
 662     @Override
 663     public synchronized void replaceAll(BiFunction&lt;? super Object,
 664             ? super Object, ? extends Object&gt; function) {
 665         check(&quot;putProviderProperty.&quot; + name);
 666 
 667         if (debug != null) {
 668             debug.println(&quot;ReplaceAll &quot; + name + &quot; provider property &quot;);
 669         }
 670         implReplaceAll(function);
 671     }
 672 
 673     /**
 674      * Attempts to compute a mapping for the specified key and its
 675      * current mapped value (or {@code null} if there is no current
 676      * mapping).
 677      *
 678      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 679      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 680      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 681      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 682      * and remove this provider&#39;s properties.
 683      *
 684      * @throws  SecurityException
 685      *          if a security manager exists and its {@link
 686      *          java.lang.SecurityManager#checkSecurityAccess} method
 687      *          denies access to set property values or remove properties.
 688      *
 689      * @since 1.8
 690      */
 691     @Override
 692     public synchronized Object compute(Object key, BiFunction&lt;? super Object,
 693             ? super Object, ? extends Object&gt; remappingFunction) {
 694         check(&quot;putProviderProperty.&quot; + name);
 695         check(&quot;removeProviderProperty.&quot; + name);
 696 
 697         if (debug != null) {
 698             debug.println(&quot;Compute &quot; + name + &quot; provider property &quot; + key);
 699         }
 700         return implCompute(key, remappingFunction);
 701     }
 702 
 703     /**
 704      * If the specified key is not already associated with a value (or
 705      * is mapped to {@code null}), attempts to compute its value using
 706      * the given mapping function and enters it into this map unless
 707      * {@code null}.
 708      *
 709      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 710      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 711      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 712      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 713      * and remove this provider&#39;s properties.
 714      *
 715      * @throws  SecurityException
 716      *          if a security manager exists and its {@link
 717      *          java.lang.SecurityManager#checkSecurityAccess} method
 718      *          denies access to set property values and remove properties.
 719      *
 720      * @since 1.8
 721      */
 722     @Override
 723     public synchronized Object computeIfAbsent(Object key, Function&lt;? super Object,
 724             ? extends Object&gt; mappingFunction) {
 725         check(&quot;putProviderProperty.&quot; + name);
 726         check(&quot;removeProviderProperty.&quot; + name);
 727 
 728         if (debug != null) {
 729             debug.println(&quot;ComputeIfAbsent &quot; + name + &quot; provider property &quot; +
 730                     key);
 731         }
 732         return implComputeIfAbsent(key, mappingFunction);
 733     }
 734 
 735     /**
 736      * If the value for the specified key is present and non-null, attempts to
 737      * compute a new mapping given the key and its current mapped value.
 738      *
 739      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 740      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 741      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 742      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 743      * and remove this provider&#39;s properties.
 744      *
 745      * @throws  SecurityException
 746      *          if a security manager exists and its {@link
 747      *          java.lang.SecurityManager#checkSecurityAccess} method
 748      *          denies access to set property values or remove properties.
 749      *
 750      * @since 1.8
 751      */
 752     @Override
 753     public synchronized Object computeIfPresent(Object key, BiFunction&lt;? super Object,
 754             ? super Object, ? extends Object&gt; remappingFunction) {
 755         check(&quot;putProviderProperty.&quot; + name);
 756         check(&quot;removeProviderProperty.&quot; + name);
 757 
 758         if (debug != null) {
 759             debug.println(&quot;ComputeIfPresent &quot; + name + &quot; provider property &quot; +
 760                     key);
 761         }
 762         return implComputeIfPresent(key, remappingFunction);
 763     }
 764 
 765     /**
 766      * If the specified key is not already associated with a value or is
 767      * associated with null, associates it with the given value. Otherwise,
 768      * replaces the value with the results of the given remapping function,
 769      * or removes if the result is null. This method may be of use when
 770      * combining multiple mapped values for a key.
 771      *
 772      * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
 773      * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
 774      * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
 775      * provider name, to see if it&#39;s ok to set this provider&#39;s property values
 776      * and remove this provider&#39;s properties.
 777      *
 778      * @throws  SecurityException
 779      *          if a security manager exists and its {@link
 780      *          java.lang.SecurityManager#checkSecurityAccess} method
 781      *          denies access to set property values or remove properties.
 782      *
 783      * @since 1.8
 784      */
 785     @Override
 786     public synchronized Object merge(Object key, Object value,  BiFunction&lt;? super Object,
 787             ? super Object, ? extends Object&gt;  remappingFunction) {
 788         check(&quot;putProviderProperty.&quot; + name);
 789         check(&quot;removeProviderProperty.&quot; + name);
 790 
 791         if (debug != null) {
 792             debug.println(&quot;Merge &quot; + name + &quot; provider property &quot; + key);
 793         }
 794         return implMerge(key, value, remappingFunction);
 795     }
 796 
 797     // let javadoc show doc from superclass
 798     @Override
 799     public Object get(Object key) {
 800         checkInitialized();
 801         return super.get(key);
 802     }
 803     /**
 804      * @since 1.8
 805      */
 806     @Override
 807     public synchronized Object getOrDefault(Object key, Object defaultValue) {
 808         checkInitialized();
 809         return super.getOrDefault(key, defaultValue);
 810     }
 811 
 812     /**
 813      * @since 1.8
 814      */
 815     @Override
 816     public synchronized void forEach(BiConsumer&lt;? super Object, ? super Object&gt; action) {
 817         checkInitialized();
 818         super.forEach(action);
 819     }
 820 
 821     // let javadoc show doc from superclass
 822     @Override
 823     public Enumeration&lt;Object&gt; keys() {
 824         checkInitialized();
 825         return super.keys();
 826     }
 827 
 828     // let javadoc show doc from superclass
 829     @Override
 830     public Enumeration&lt;Object&gt; elements() {
 831         checkInitialized();
 832         return super.elements();
 833     }
 834 
 835     // let javadoc show doc from superclass
 836     public String getProperty(String key) {
 837         checkInitialized();
 838         return super.getProperty(key);
 839     }
 840 
 841     private void checkInitialized() {
 842         if (!initialized) {
 843             throw new IllegalStateException();
 844         }
 845     }
 846 
 847     private void check(String directive) {
 848         checkInitialized();
 849         SecurityManager security = System.getSecurityManager();
 850         if (security != null) {
 851             security.checkSecurityAccess(directive);
 852         }
 853     }
 854 
 855     // legacy properties changed since last call to any services method?
 856     private transient boolean legacyChanged;
 857     // serviceMap changed since last call to getServices()
 858     private volatile transient boolean servicesChanged;
 859 
 860     // Map&lt;ServiceKey,Service&gt;
 861     // used for services added via putService(), initialized on demand
 862     private transient Map&lt;ServiceKey,Service&gt; serviceMap;
 863 
 864     // Map&lt;ServiceKey,Service&gt;
 865     // used for services added via legacy methods, init on demand
 866     private transient Map&lt;ServiceKey,Service&gt; legacyMap;
 867 
 868     // Set&lt;Service&gt;
 869     // Unmodifiable set of all services. Initialized on demand.
 870     private transient Set&lt;Service&gt; serviceSet;
 871 
 872     // register the id attributes for this provider
 873     // this is to ensure that equals() and hashCode() do not incorrectly
 874     // report to different provider objects as the same
 875     private void putId() {
 876         // note: name and info may be null
 877         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 878         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 879         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 880         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 881     }
 882 
 883    /**
 884     * Reads the {@code ObjectInputStream} for the default serializable fields.
 885     * If the serialized field {@code versionStr} is found in the STREAM FIELDS,
 886     * its String value will be used to populate both the version string and
 887     * version number. If {@code versionStr} is not found, but {@code version}
 888     * is, then its double value will be used to populate both fields.
 889     *
 890     * @param in the {@code ObjectInputStream} to read
 891     * @serial
 892     */
 893     private void readObject(ObjectInputStream in)
 894                 throws IOException, ClassNotFoundException {
 895         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 896         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 897             copy.put(entry.getKey(), entry.getValue());
 898         }
 899         defaults = null;
 900         in.defaultReadObject();
 901         if (this.versionStr == null) {
 902             // set versionStr based on version when not found in serialized bytes
 903             this.versionStr = Double.toString(this.version);
 904         } else {
 905             // otherwise, set version based on versionStr
 906             this.version = parseVersionStr(this.versionStr);
 907         }
 908         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 909         implClear();
 910         initialized = true;
 911         putAll(copy);
 912     }
 913 
 914     private static boolean isProviderInfo(Object key) {
 915         String keyString = (String)key;
 916         if (keyString.startsWith(&quot;Provider.&quot;)) {
 917             return true;
 918         }
 919         return false;
 920     }
 921 
 922     /**
 923      * Copies all of the mappings from the specified Map to this provider.
 924      * Internal method to be called AFTER the security check has been
 925      * performed.
 926      */
 927     private void implPutAll(Map&lt;?,?&gt; t) {
 928         for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {
 929             implPut(e.getKey(), e.getValue());
 930         }
 931     }
 932 
 933     private Object implRemove(Object key) {
 934         if (key instanceof String) {
 935             if (isProviderInfo(key)) {
 936                 return null;
 937             }
 938             legacyChanged = true;
 939         }
 940         return super.remove(key);
 941     }
 942 
 943     private boolean implRemove(Object key, Object value) {
 944         if (key instanceof String &amp;&amp; value instanceof String) {
 945             if (isProviderInfo(key)) {
 946                 return false;
 947             }
 948             legacyChanged = true;
 949         }
 950         return super.remove(key, value);
 951     }
 952 
 953     private boolean implReplace(Object key, Object oldValue, Object newValue) {
 954         if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
 955                 (newValue instanceof String)) {
 956             if (isProviderInfo(key)) {
 957                 return false;
 958             }
 959             legacyChanged = true;
 960         }
 961         return super.replace(key, oldValue, newValue);
 962     }
 963 
 964     private Object implReplace(Object key, Object value) {
 965         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
 966             if (isProviderInfo(key)) {
 967                 return null;
 968             }
 969             legacyChanged = true;
 970         }
 971         return super.replace(key, value);
 972     }
 973 
 974     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 975     private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
 976             ? extends Object&gt; function) {
 977         legacyChanged = true;
 978         super.replaceAll(function);
 979     }
 980 
 981     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 982     private Object implMerge(Object key, Object value, BiFunction&lt;? super Object,
 983             ? super Object, ? extends Object&gt; remappingFunction) {
 984         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
 985             if (isProviderInfo(key)) {
 986                 return null;
 987             }
 988             legacyChanged = true;
 989         }
 990         return super.merge(key, value, remappingFunction);
 991     }
 992 
 993     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 994     private Object implCompute(Object key, BiFunction&lt;? super Object,
 995             ? super Object, ? extends Object&gt; remappingFunction) {
 996         if (key instanceof String) {
 997             if (isProviderInfo(key)) {
 998                 return null;
 999             }
1000             legacyChanged = true;
1001         }
1002         return super.compute(key, remappingFunction);
1003     }
1004 
1005     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1006     private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
1007             ? extends Object&gt; mappingFunction) {
1008         if (key instanceof String) {
1009             if (isProviderInfo(key)) {
1010                 return null;
1011             }
1012             legacyChanged = true;
1013         }
1014         return super.computeIfAbsent(key, mappingFunction);
1015     }
1016 
1017     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1018     private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
1019             ? super Object, ? extends Object&gt; remappingFunction) {
1020         if (key instanceof String) {
1021             if (isProviderInfo(key)) {
1022                 return null;
1023             }
1024             legacyChanged = true;
1025         }
1026         return super.computeIfPresent(key, remappingFunction);
1027     }
1028 
1029     private Object implPut(Object key, Object value) {
1030         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1031             if (isProviderInfo(key)) {
1032                 return null;
1033             }
1034             legacyChanged = true;
1035         }
1036         return super.put(key, value);
1037     }
1038 
1039     private Object implPutIfAbsent(Object key, Object value) {
1040         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
1041             if (isProviderInfo(key)) {
1042                 return null;
1043             }
1044             legacyChanged = true;
1045         }
1046         return super.putIfAbsent(key, value);
1047     }
1048 
1049     private void implClear() {
1050         if (legacyMap != null) {
1051             legacyMap.clear();
1052         }
1053         serviceMap.clear();
1054         legacyChanged = false;
1055         servicesChanged = false;
1056         serviceSet = null;
1057         super.clear();
1058         putId();
1059     }
1060 
1061     // used as key in the serviceMap and legacyMap HashMaps
1062     private static class ServiceKey {
1063         private final String type;
1064         private final String algorithm;
1065         private final String originalAlgorithm;
1066         private ServiceKey(String type, String algorithm, boolean intern) {
1067             this.type = type;
1068             this.originalAlgorithm = algorithm;
1069             algorithm = algorithm.toUpperCase(ENGLISH);
1070             this.algorithm = intern ? algorithm.intern() : algorithm;
1071         }
1072         public int hashCode() {
1073             return Objects.hash(type, algorithm);
1074         }
1075         public boolean equals(Object obj) {
1076             if (this == obj) {
1077                 return true;
1078             }
1079             if (!(obj instanceof ServiceKey)) {
1080                 return false;
1081             }
1082             ServiceKey other = (ServiceKey)obj;
1083             return this.type.equals(other.type)
1084                 &amp;&amp; this.algorithm.equals(other.algorithm);
1085         }
1086         boolean matches(String type, String algorithm) {
1087             return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);
1088         }
1089     }
1090 
1091     /**
1092      * Ensure all the legacy String properties are fully parsed into
1093      * service objects.
1094      */
1095     private void ensureLegacyParsed() {
1096         if (legacyChanged == false) {
1097             return;
1098         }
1099         serviceSet = null;
1100         if (legacyMap == null) {
1101             legacyMap = new ConcurrentHashMap&lt;&gt;();
1102         } else {
1103             legacyMap.clear();
1104         }
1105         for (Map.Entry&lt;?,?&gt; entry : super.entrySet()) {
1106             parseLegacyPut(entry.getKey(), entry.getValue());
1107         }
1108         removeInvalidServices(legacyMap);
1109         legacyChanged = false;
1110     }
1111 
1112     /**
1113      * Remove all invalid services from the Map. Invalid services can only
1114      * occur if the legacy properties are inconsistent or incomplete.
1115      */
1116     private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
1117         for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =
1118                 map.entrySet().iterator(); t.hasNext(); ) {
1119             Service s = t.next().getValue();
1120             if (s.isValid() == false) {
1121                 t.remove();
1122             }
1123         }
1124     }
1125 
1126     private String[] getTypeAndAlgorithm(String key) {
1127         int i = key.indexOf(&#39;.&#39;);
1128         if (i &lt; 1) {
1129             if (debug != null) {
1130                 debug.println(&quot;Ignoring invalid entry in provider &quot;
1131                         + name + &quot;:&quot; + key);
1132             }
1133             return null;
1134         }
1135         String type = key.substring(0, i);
1136         String alg = key.substring(i + 1);
1137         return new String[] {type, alg};
1138     }
1139 
1140     private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
1141     private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
1142     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
1143 
1144     private void parseLegacyPut(Object k, Object v) {
1145         if (!(k instanceof String) || !(v instanceof String)) {
1146             return;
1147         }
1148         String name = (String) k;
1149         String value = (String) v;
1150         if (isProviderInfo(name)) {
1151             return;
1152         }
1153         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
1154             // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
1155             // aliasKey ~ MessageDigest.SHA
1156             String stdAlg = value;
1157             String aliasKey = name.substring(ALIAS_LENGTH);
1158             String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);
1159             if (typeAndAlg == null) {
1160                 return;
1161             }
1162             String type = getEngineName(typeAndAlg[0]);
1163             String aliasAlg = typeAndAlg[1].intern();
1164             ServiceKey key = new ServiceKey(type, stdAlg, true);
1165             Service s = legacyMap.get(key);
1166             if (s == null) {
1167                 s = new Service(this);
1168                 s.type = type;
1169                 s.algorithm = stdAlg;
1170                 legacyMap.put(key, s);
1171             }
1172             legacyMap.put(new ServiceKey(type, aliasAlg, true), s);
1173             s.addAlias(aliasAlg);
1174         } else {
1175             String[] typeAndAlg = getTypeAndAlgorithm(name);
1176             if (typeAndAlg == null) {
1177                 return;
1178             }
1179             int i = typeAndAlg[1].indexOf(&#39; &#39;);
1180             if (i == -1) {
1181                 // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
1182                 String type = getEngineName(typeAndAlg[0]);
1183                 String stdAlg = typeAndAlg[1].intern();
1184                 String className = value;
1185                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1186                 Service s = legacyMap.get(key);
1187                 if (s == null) {
1188                     s = new Service(this);
1189                     s.type = type;
1190                     s.algorithm = stdAlg;
1191                     legacyMap.put(key, s);
1192                 }
1193                 s.className = className;
1194             } else { // attribute
1195                 // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
1196                 String attributeValue = value;
1197                 String type = getEngineName(typeAndAlg[0]);
1198                 String attributeString = typeAndAlg[1];
1199                 String stdAlg = attributeString.substring(0, i).intern();
1200                 String attributeName = attributeString.substring(i + 1);
1201                 // kill additional spaces
1202                 while (attributeName.startsWith(&quot; &quot;)) {
1203                     attributeName = attributeName.substring(1);
1204                 }
1205                 attributeName = attributeName.intern();
1206                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1207                 Service s = legacyMap.get(key);
1208                 if (s == null) {
1209                     s = new Service(this);
1210                     s.type = type;
1211                     s.algorithm = stdAlg;
1212                     legacyMap.put(key, s);
1213                 }
1214                 s.addAttribute(attributeName, attributeValue);
1215             }
1216         }
1217     }
1218 
1219     /**
1220      * Get the service describing this Provider&#39;s implementation of the
1221      * specified type of this algorithm or alias. If no such
1222      * implementation exists, this method returns null. If there are two
1223      * matching services, one added to this provider using
1224      * {@link #putService putService()} and one added via {@link #put put()},
1225      * the service added via {@link #putService putService()} is returned.
1226      *
1227      * @param type the type of {@link Service service} requested
1228      * (for example, {@code MessageDigest})
1229      * @param algorithm the case insensitive algorithm name (or alternate
1230      * alias) of the service requested (for example, {@code SHA-1})
1231      *
1232      * @return the service describing this Provider&#39;s matching service
1233      * or null if no such service exists
1234      *
1235      * @throws NullPointerException if type or algorithm is null
1236      *
1237      * @since 1.5
1238      */
1239     public Service getService(String type, String algorithm) {
1240         checkInitialized();
1241 
1242         // avoid allocating a new ServiceKey object if possible
1243         ServiceKey key = previousKey;
1244         if (key.matches(type, algorithm) == false) {
1245             key = new ServiceKey(type, algorithm, false);
1246             previousKey = key;
1247         }
1248         if (!serviceMap.isEmpty()) {
1249             Service s = serviceMap.get(key);
1250             if (s != null) {
1251                 return s;
1252             }
1253         }
1254         synchronized (this) {
1255             ensureLegacyParsed();
1256         }
1257         if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1258             return legacyMap.get(key);
1259         }
1260         return null;
1261     }
1262 
1263     // ServiceKey from previous getService() call
1264     // by re-using it if possible we avoid allocating a new object
1265     // and the toUpperCase() call.
1266     // re-use will occur e.g. as the framework traverses the provider
1267     // list and queries each provider with the same values until it finds
1268     // a matching service
1269     private static volatile ServiceKey previousKey =
1270                                             new ServiceKey(&quot;&quot;, &quot;&quot;, false);
1271 
1272     /**
1273      * Get an unmodifiable Set of all services supported by
1274      * this Provider.
1275      *
1276      * @return an unmodifiable Set of all services supported by
1277      * this Provider
1278      *
1279      * @since 1.5
1280      */
1281     public synchronized Set&lt;Service&gt; getServices() {
1282         checkInitialized();
1283         if (legacyChanged || servicesChanged) {
1284             serviceSet = null;
1285         }
1286         if (serviceSet == null) {
1287             ensureLegacyParsed();
1288             Set&lt;Service&gt; set = new LinkedHashSet&lt;&gt;();
1289             if (!serviceMap.isEmpty()) {
1290                 set.addAll(serviceMap.values());
1291             }
1292             if (legacyMap != null &amp;&amp; !legacyMap.isEmpty()) {
1293                 set.addAll(legacyMap.values());
1294             }
1295             serviceSet = Collections.unmodifiableSet(set);
1296             servicesChanged = false;
1297         }
1298         return serviceSet;
1299     }
1300 
1301     /**
1302      * Add a service. If a service of the same type with the same algorithm
1303      * name exists and it was added using {@link #putService putService()},
1304      * it is replaced by the new service.
1305      * This method also places information about this service
1306      * in the provider&#39;s Hashtable values in the format described in the
1307      * {@extLink security_guide_jca
1308      * Java Cryptography Architecture (JCA) Reference Guide}.
1309      *
1310      * &lt;p&gt;Also, if there is a security manager, its
1311      * {@code checkSecurityAccess} method is called with the string
1312      * {@code &quot;putProviderProperty.&quot;+name}, where {@code name} is
1313      * the provider name, to see if it&#39;s ok to set this provider&#39;s property
1314      * values. If the default implementation of {@code checkSecurityAccess}
1315      * is used (that is, that method is not overridden), then this results in
1316      * a call to the security manager&#39;s {@code checkPermission} method with
1317      * a {@code SecurityPermission(&quot;putProviderProperty.&quot;+name)}
1318      * permission.
1319      *
1320      * @param s the Service to add
1321      *
1322      * @throws SecurityException
1323      *      if a security manager exists and its {@link
1324      *      java.lang.SecurityManager#checkSecurityAccess} method denies
1325      *      access to set property values.
1326      * @throws NullPointerException if s is null
1327      *
1328      * @since 1.5
1329      */
1330     protected void putService(Service s) {
1331         check(&quot;putProviderProperty.&quot; + name);
1332         if (debug != null) {
1333             debug.println(name + &quot;.putService(): &quot; + s);
1334         }
1335         if (s == null) {
1336             throw new NullPointerException();
1337         }
1338         if (s.getProvider() != this) {
1339             throw new IllegalArgumentException
1340                     (&quot;service.getProvider() must match this Provider object&quot;);
1341         }
1342         String type = s.getType();
1343         String algorithm = s.getAlgorithm();
1344         ServiceKey key = new ServiceKey(type, algorithm, true);
1345         implRemoveService(serviceMap.get(key));
1346         serviceMap.put(key, s);
1347         for (String alias : s.getAliases()) {
1348             serviceMap.put(new ServiceKey(type, alias, true), s);
1349         }
1350         servicesChanged = true;
1351         synchronized (this) {
1352             putPropertyStrings(s);
1353         }
1354     }
1355 
1356     /**
1357      * Put the string properties for this Service in this Provider&#39;s
1358      * Hashtable.
1359      */
1360     private void putPropertyStrings(Service s) {
1361         String type = s.getType();
1362         String algorithm = s.getAlgorithm();
1363         // use super() to avoid permission check and other processing
1364         super.put(type + &quot;.&quot; + algorithm, s.getClassName());
1365         for (String alias : s.getAliases()) {
1366             super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);
1367         }
1368         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1369             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1370             super.put(key, entry.getValue());
1371         }
1372     }
1373 
1374     /**
1375      * Remove the string properties for this Service from this Provider&#39;s
1376      * Hashtable.
1377      */
1378     private void removePropertyStrings(Service s) {
1379         String type = s.getType();
1380         String algorithm = s.getAlgorithm();
1381         // use super() to avoid permission check and other processing
1382         super.remove(type + &quot;.&quot; + algorithm);
1383         for (String alias : s.getAliases()) {
1384             super.remove(ALIAS_PREFIX + type + &quot;.&quot; + alias);
1385         }
1386         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1387             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1388             super.remove(key);
1389         }
1390     }
1391 
1392     /**
1393      * Remove a service previously added using
1394      * {@link #putService putService()}. The specified service is removed from
1395      * this provider. It will no longer be returned by
1396      * {@link #getService getService()} and its information will be removed
1397      * from this provider&#39;s Hashtable.
1398      *
1399      * &lt;p&gt;Also, if there is a security manager, its
1400      * {@code checkSecurityAccess} method is called with the string
1401      * {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is
1402      * the provider name, to see if it&#39;s ok to remove this provider&#39;s
1403      * properties. If the default implementation of
1404      * {@code checkSecurityAccess} is used (that is, that method is not
1405      * overridden), then this results in a call to the security manager&#39;s
1406      * {@code checkPermission} method with a
1407      * {@code SecurityPermission(&quot;removeProviderProperty.&quot;+name)}
1408      * permission.
1409      *
1410      * @param s the Service to be removed
1411      *
1412      * @throws  SecurityException
1413      *          if a security manager exists and its {@link
1414      *          java.lang.SecurityManager#checkSecurityAccess} method denies
1415      *          access to remove this provider&#39;s properties.
1416      * @throws NullPointerException if s is null
1417      *
1418      * @since 1.5
1419      */
1420     protected void removeService(Service s) {
1421         check(&quot;removeProviderProperty.&quot; + name);
1422         if (debug != null) {
1423             debug.println(name + &quot;.removeService(): &quot; + s);
1424         }
1425         if (s == null) {
1426             throw new NullPointerException();
1427         }
1428         implRemoveService(s);
1429     }
1430 
1431     private void implRemoveService(Service s) {
1432         if ((s == null) || serviceMap.isEmpty()) {
1433             return;
1434         }
1435         String type = s.getType();
1436         String algorithm = s.getAlgorithm();
1437         ServiceKey key = new ServiceKey(type, algorithm, false);
1438         Service oldService = serviceMap.get(key);
1439         if (s != oldService) {
1440             return;
1441         }
1442         servicesChanged = true;
1443         serviceMap.remove(key);
1444         for (String alias : s.getAliases()) {
1445             serviceMap.remove(new ServiceKey(type, alias, false));
1446         }
1447         synchronized (this) {
1448             removePropertyStrings(s);
1449         }
1450     }
1451 
1452     // Wrapped String that behaves in a case insensitive way for equals/hashCode
1453     private static class UString {
1454         final String string;
1455         final String lowerString;
1456 
1457         UString(String s) {
1458             this.string = s;
1459             this.lowerString = s.toLowerCase(ENGLISH);
1460         }
1461 
1462         public int hashCode() {
1463             return lowerString.hashCode();
1464         }
1465 
1466         public boolean equals(Object obj) {
1467             if (this == obj) {
1468                 return true;
1469             }
1470             if (obj instanceof UString == false) {
1471                 return false;
1472             }
1473             UString other = (UString)obj;
1474             return lowerString.equals(other.lowerString);
1475         }
1476 
1477         public String toString() {
1478             return string;
1479         }
1480     }
1481 
1482     // describe relevant properties of a type of engine
1483     private static class EngineDescription {
1484         final String name;
1485         final boolean supportsParameter;
1486         final String constructorParameterClassName;
1487         private volatile Class&lt;?&gt; constructorParameterClass;
1488 
1489         EngineDescription(String name, boolean sp, String paramName) {
1490             this.name = name;
1491             this.supportsParameter = sp;
1492             this.constructorParameterClassName = paramName;
1493         }
1494         Class&lt;?&gt; getConstructorParameterClass() throws ClassNotFoundException {
1495             Class&lt;?&gt; clazz = constructorParameterClass;
1496             if (clazz == null) {
1497                 clazz = Class.forName(constructorParameterClassName);
1498                 constructorParameterClass = clazz;
1499             }
1500             return clazz;
1501         }
1502     }
1503 
1504     // built in knowledge of the engine types shipped as part of the JDK
1505     private static final Map&lt;String,EngineDescription&gt; knownEngines;
1506 
1507     private static void addEngine(String name, boolean sp, String paramName) {
1508         EngineDescription ed = new EngineDescription(name, sp, paramName);
1509         // also index by canonical name to avoid toLowerCase() for some lookups
1510         knownEngines.put(name.toLowerCase(ENGLISH), ed);
1511         knownEngines.put(name, ed);
1512     }
1513 
1514     static {
1515         knownEngines = new HashMap&lt;&gt;();
1516         // JCA
1517         addEngine(&quot;AlgorithmParameterGenerator&quot;,        false, null);
1518         addEngine(&quot;AlgorithmParameters&quot;,                false, null);
1519         addEngine(&quot;KeyFactory&quot;,                         false, null);
1520         addEngine(&quot;KeyPairGenerator&quot;,                   false, null);
1521         addEngine(&quot;KeyStore&quot;,                           false, null);
1522         addEngine(&quot;MessageDigest&quot;,                      false, null);
1523         addEngine(&quot;SecureRandom&quot;,                       false,
1524                 &quot;java.security.SecureRandomParameters&quot;);
1525         addEngine(&quot;Signature&quot;,                          true,  null);
1526         addEngine(&quot;CertificateFactory&quot;,                 false, null);
1527         addEngine(&quot;CertPathBuilder&quot;,                    false, null);
1528         addEngine(&quot;CertPathValidator&quot;,                  false, null);
1529         addEngine(&quot;CertStore&quot;,                          false,
1530                             &quot;java.security.cert.CertStoreParameters&quot;);
1531         // JCE
1532         addEngine(&quot;Cipher&quot;,                             true,  null);
1533         addEngine(&quot;ExemptionMechanism&quot;,                 false, null);
1534         addEngine(&quot;Mac&quot;,                                true,  null);
1535         addEngine(&quot;KeyAgreement&quot;,                       true,  null);
1536         addEngine(&quot;KeyGenerator&quot;,                       false, null);
1537         addEngine(&quot;SecretKeyFactory&quot;,                   false, null);
1538         // JSSE
1539         addEngine(&quot;KeyManagerFactory&quot;,                  false, null);
1540         addEngine(&quot;SSLContext&quot;,                         false, null);
1541         addEngine(&quot;TrustManagerFactory&quot;,                false, null);
1542         // JGSS
1543         addEngine(&quot;GssApiMechanism&quot;,                    false, null);
1544         // SASL
1545         addEngine(&quot;SaslClientFactory&quot;,                  false, null);
1546         addEngine(&quot;SaslServerFactory&quot;,                  false, null);
1547         // POLICY
1548         addEngine(&quot;Policy&quot;,                             false,
1549                             &quot;java.security.Policy$Parameters&quot;);
1550         // CONFIGURATION
1551         addEngine(&quot;Configuration&quot;,                      false,
1552                             &quot;javax.security.auth.login.Configuration$Parameters&quot;);
1553         // XML DSig
1554         addEngine(&quot;XMLSignatureFactory&quot;,                false, null);
1555         addEngine(&quot;KeyInfoFactory&quot;,                     false, null);
1556         addEngine(&quot;TransformService&quot;,                   false, null);
1557         // Smart Card I/O
1558         addEngine(&quot;TerminalFactory&quot;,                    false,
1559                             &quot;java.lang.Object&quot;);
1560     }
1561 
1562     // get the &quot;standard&quot; (mixed-case) engine name for arbitary case engine name
1563     // if there is no known engine by that name, return s
1564     private static String getEngineName(String s) {
1565         // try original case first, usually correct
1566         EngineDescription e = knownEngines.get(s);
1567         if (e == null) {
1568             e = knownEngines.get(s.toLowerCase(ENGLISH));
1569         }
1570         return (e == null) ? s : e.name;
1571     }
1572 
1573     /**
1574      * The description of a security service. It encapsulates the properties
1575      * of a service and contains a factory method to obtain new implementation
1576      * instances of this service.
1577      *
1578      * &lt;p&gt;Each service has a provider that offers the service, a type,
1579      * an algorithm name, and the name of the class that implements the
1580      * service. Optionally, it also includes a list of alternate algorithm
1581      * names for this service (aliases) and attributes, which are a map of
1582      * (name, value) String pairs.
1583      *
1584      * &lt;p&gt;This class defines the methods {@link #supportsParameter
1585      * supportsParameter()} and {@link #newInstance newInstance()}
1586      * which are used by the Java security framework when it searches for
1587      * suitable services and instantiates them. The valid arguments to those
1588      * methods depend on the type of service. For the service types defined
1589      * within Java SE, see the
1590      * {@extLink security_guide_jca
1591      * Java Cryptography Architecture (JCA) Reference Guide}
1592      * for the valid values.
1593      * Note that components outside of Java SE can define additional types of
1594      * services and their behavior.
1595      *
1596      * &lt;p&gt;Instances of this class are immutable.
1597      *
1598      * @since 1.5
1599      */
1600     public static class Service {
1601 
1602         private String type, algorithm, className;
1603         private final Provider provider;
1604         private List&lt;String&gt; aliases;
1605         private Map&lt;UString,String&gt; attributes;
1606 
1607         // Reference to the cached implementation Class object
1608         private volatile Reference&lt;Class&lt;?&gt;&gt; classRef;
1609 
1610         // flag indicating whether this service has its attributes for
1611         // supportedKeyFormats or supportedKeyClasses set
1612         // if null, the values have not been initialized
1613         // if TRUE, at least one of supportedFormats/Classes is non null
1614         private volatile Boolean hasKeyAttributes;
1615 
1616         // supported encoding formats
1617         private String[] supportedFormats;
1618 
1619         // names of the supported key (super) classes
1620         private Class&lt;?&gt;[] supportedClasses;
1621 
1622         // whether this service has been registered with the Provider
1623         private boolean registered;
1624 
1625         private static final Class&lt;?&gt;[] CLASS0 = new Class&lt;?&gt;[0];
1626 
1627         // this constructor and these methods are used for parsing
1628         // the legacy string properties.
1629 
1630         private Service(Provider provider) {
1631             this.provider = provider;
1632             aliases = Collections.&lt;String&gt;emptyList();
1633             attributes = Collections.&lt;UString,String&gt;emptyMap();
1634         }
1635 
1636         private boolean isValid() {
1637             return (type != null) &amp;&amp; (algorithm != null) &amp;&amp; (className != null);
1638         }
1639 
1640         private void addAlias(String alias) {
1641             if (aliases.isEmpty()) {
1642                 aliases = new ArrayList&lt;&gt;(2);
1643             }
1644             aliases.add(alias);
1645         }
1646 
1647         void addAttribute(String type, String value) {
1648             if (attributes.isEmpty()) {
1649                 attributes = new HashMap&lt;&gt;(8);
1650             }
1651             attributes.put(new UString(type), value);
1652         }
1653 
1654         /**
1655          * Construct a new service.
1656          *
1657          * @param provider the provider that offers this service
1658          * @param type the type of this service
1659          * @param algorithm the algorithm name
1660          * @param className the name of the class implementing this service
1661          * @param aliases List of aliases or null if algorithm has no aliases
1662          * @param attributes Map of attributes or null if this implementation
1663          *                   has no attributes
1664          *
1665          * @throws NullPointerException if provider, type, algorithm, or
1666          * className is null
1667          */
1668         public Service(Provider provider, String type, String algorithm,
1669                 String className, List&lt;String&gt; aliases,
1670                 Map&lt;String,String&gt; attributes) {
1671             if ((provider == null) || (type == null) ||
1672                     (algorithm == null) || (className == null)) {
1673                 throw new NullPointerException();
1674             }
1675             this.provider = provider;
1676             this.type = getEngineName(type);
1677             this.algorithm = algorithm;
1678             this.className = className;
1679             if (aliases == null) {
1680                 this.aliases = Collections.&lt;String&gt;emptyList();
1681             } else {
1682                 this.aliases = new ArrayList&lt;&gt;(aliases);
1683             }
1684             if (attributes == null) {
1685                 this.attributes = Collections.&lt;UString,String&gt;emptyMap();
1686             } else {
1687                 this.attributes = new HashMap&lt;&gt;();
1688                 for (Map.Entry&lt;String,String&gt; entry : attributes.entrySet()) {
1689                     this.attributes.put(new UString(entry.getKey()), entry.getValue());
1690                 }
1691             }
1692         }
1693 
1694         /**
1695          * Get the type of this service. For example, {@code MessageDigest}.
1696          *
1697          * @return the type of this service
1698          */
1699         public final String getType() {
1700             return type;
1701         }
1702 
1703         /**
1704          * Return the name of the algorithm of this service. For example,
1705          * {@code SHA-1}.
1706          *
1707          * @return the algorithm of this service
1708          */
1709         public final String getAlgorithm() {
1710             return algorithm;
1711         }
1712 
1713         /**
1714          * Return the Provider of this service.
1715          *
1716          * @return the Provider of this service
1717          */
1718         public final Provider getProvider() {
1719             return provider;
1720         }
1721 
1722         /**
1723          * Return the name of the class implementing this service.
1724          *
1725          * @return the name of the class implementing this service
1726          */
1727         public final String getClassName() {
1728             return className;
1729         }
1730 
1731         // internal only
1732         private final List&lt;String&gt; getAliases() {
1733             return aliases;
1734         }
1735 
1736         /**
1737          * Return the value of the specified attribute or null if this
1738          * attribute is not set for this Service.
1739          *
1740          * @param name the name of the requested attribute
1741          *
1742          * @return the value of the specified attribute or null if the
1743          *         attribute is not present
1744          *
1745          * @throws NullPointerException if name is null
1746          */
1747         public final String getAttribute(String name) {
1748             if (name == null) {
1749                 throw new NullPointerException();
1750             }
1751             return attributes.get(new UString(name));
1752         }
1753 
1754         /**
1755          * Return a new instance of the implementation described by this
1756          * service. The security provider framework uses this method to
1757          * construct implementations. Applications will typically not need
1758          * to call it.
1759          *
1760          * &lt;p&gt;The default implementation uses reflection to invoke the
1761          * standard constructor for this type of service.
1762          * Security providers can override this method to implement
1763          * instantiation in a different way.
1764          * For details and the values of constructorParameter that are
1765          * valid for the various types of services see the
1766          * {@extLink security_guide_jca
1767          * Java Cryptography Architecture (JCA) Reference Guide}.
1768          *
1769          * @param constructorParameter the value to pass to the constructor,
1770          * or null if this type of service does not use a constructorParameter.
1771          *
1772          * @return a new implementation of this service
1773          *
1774          * @throws InvalidParameterException if the value of
1775          * constructorParameter is invalid for this type of service.
1776          * @throws NoSuchAlgorithmException if instantiation failed for
1777          * any other reason.
1778          */
1779         public Object newInstance(Object constructorParameter)
1780                 throws NoSuchAlgorithmException {
1781             if (registered == false) {
1782                 if (provider.getService(type, algorithm) != this) {
1783                     throw new NoSuchAlgorithmException
1784                         (&quot;Service not registered with Provider &quot;
1785                         + provider.getName() + &quot;: &quot; + this);
1786                 }
1787                 registered = true;
1788             }
1789             Class&lt;?&gt; ctrParamClz;
1790             try {
1791                 EngineDescription cap = knownEngines.get(type);
1792                 if (cap == null) {
1793                     // unknown engine type, use generic code
1794                     // this is the code path future for non-core
1795                     // optional packages
1796                     ctrParamClz = constructorParameter == null?
1797                         null : constructorParameter.getClass();
1798                 } else {
1799                     ctrParamClz = cap.constructorParameterClassName == null?
1800                         null : Class.forName(cap.constructorParameterClassName);
1801                     if (constructorParameter != null) {
1802                         if (ctrParamClz == null) {
1803                             throw new InvalidParameterException
1804                                 (&quot;constructorParameter not used with &quot; + type
1805                                 + &quot; engines&quot;);
1806                         } else {
1807                             Class&lt;?&gt; argClass = constructorParameter.getClass();
1808                             if (ctrParamClz.isAssignableFrom(argClass) == false) {
1809                                 throw new InvalidParameterException
1810                                     (&quot;constructorParameter must be instanceof &quot;
1811                                     + cap.constructorParameterClassName.replace(&#39;$&#39;, &#39;.&#39;)
1812                                     + &quot; for engine type &quot; + type);
1813                             }
1814                         }
1815                     }
1816                 }
1817                 // constructorParameter can be null if not provided
1818                 return newInstanceUtil(getImplClass(), ctrParamClz, constructorParameter);
1819             } catch (NoSuchAlgorithmException e) {
1820                 throw e;
1821             } catch (InvocationTargetException e) {
1822                 throw new NoSuchAlgorithmException
1823                     (&quot;Error constructing implementation (algorithm: &quot;
1824                     + algorithm + &quot;, provider: &quot; + provider.getName()
1825                     + &quot;, class: &quot; + className + &quot;)&quot;, e.getCause());
1826             } catch (Exception e) {
1827                 throw new NoSuchAlgorithmException
1828                     (&quot;Error constructing implementation (algorithm: &quot;
1829                     + algorithm + &quot;, provider: &quot; + provider.getName()
1830                     + &quot;, class: &quot; + className + &quot;)&quot;, e);
1831             }
1832         }
1833 
1834         // return the implementation Class object for this service
1835         private Class&lt;?&gt; getImplClass() throws NoSuchAlgorithmException {
1836             try {
1837                 Reference&lt;Class&lt;?&gt;&gt; ref = classRef;
1838                 Class&lt;?&gt; clazz = (ref == null) ? null : ref.get();
1839                 if (clazz == null) {
1840                     ClassLoader cl = provider.getClass().getClassLoader();
1841                     if (cl == null) {
1842                         clazz = Class.forName(className);
1843                     } else {
1844                         clazz = cl.loadClass(className);
1845                     }
1846                     if (!Modifier.isPublic(clazz.getModifiers())) {
1847                         throw new NoSuchAlgorithmException
1848                             (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1849                             provider.getName() + &quot;) is not public.&quot;);
1850                     }
1851                     classRef = new WeakReference&lt;&gt;(clazz);
1852                 }
1853                 return clazz;
1854             } catch (ClassNotFoundException e) {
1855                 throw new NoSuchAlgorithmException
1856                     (&quot;class configured for &quot; + type + &quot; (provider: &quot; +
1857                     provider.getName() + &quot;) cannot be found.&quot;, e);
1858             }
1859         }
1860 
1861         /**
1862          * Test whether this Service can use the specified parameter.
1863          * Returns false if this service cannot use the parameter. Returns
1864          * true if this service can use the parameter, if a fast test is
1865          * infeasible, or if the status is unknown.
1866          *
1867          * &lt;p&gt;The security provider framework uses this method with
1868          * some types of services to quickly exclude non-matching
1869          * implementations for consideration.
1870          * Applications will typically not need to call it.
1871          *
1872          * &lt;p&gt;For details and the values of parameter that are valid for the
1873          * various types of services see the top of this class and the
1874          * {@extLink security_guide_jca
1875          * Java Cryptography Architecture (JCA) Reference Guide}.
1876          * Security providers can override it to implement their own test.
1877          *
1878          * @param parameter the parameter to test
1879          *
1880          * @return false if this service cannot use the specified
1881          * parameter; true if it can possibly use the parameter
1882          *
1883          * @throws InvalidParameterException if the value of parameter is
1884          * invalid for this type of service or if this method cannot be
1885          * used with this type of service
1886          */
1887         public boolean supportsParameter(Object parameter) {
1888             EngineDescription cap = knownEngines.get(type);
1889             if (cap == null) {
1890                 // unknown engine type, return true by default
1891                 return true;
1892             }
1893             if (cap.supportsParameter == false) {
1894                 throw new InvalidParameterException(&quot;supportsParameter() not &quot;
1895                     + &quot;used with &quot; + type + &quot; engines&quot;);
1896             }
1897             // allow null for keys without attributes for compatibility
1898             if ((parameter != null) &amp;&amp; (parameter instanceof Key == false)) {
1899                 throw new InvalidParameterException
1900                     (&quot;Parameter must be instanceof Key for engine &quot; + type);
1901             }
1902             if (hasKeyAttributes() == false) {
1903                 return true;
1904             }
1905             if (parameter == null) {
1906                 return false;
1907             }
1908             Key key = (Key)parameter;
1909             if (supportsKeyFormat(key)) {
1910                 return true;
1911             }
1912             if (supportsKeyClass(key)) {
1913                 return true;
1914             }
1915             return false;
1916         }
1917 
1918         /**
1919          * Return whether this service has its supported properties for
1920          * keys defined. Parses the attributes if not yet initialized.
1921          */
1922         private boolean hasKeyAttributes() {
1923             Boolean b = hasKeyAttributes;
1924             if (b == null) {
1925                 synchronized (this) {
1926                     String s;
1927                     s = getAttribute(&quot;SupportedKeyFormats&quot;);
1928                     if (s != null) {
1929                         supportedFormats = s.split(&quot;\\|&quot;);
1930                     }
1931                     s = getAttribute(&quot;SupportedKeyClasses&quot;);
1932                     if (s != null) {
1933                         String[] classNames = s.split(&quot;\\|&quot;);
1934                         List&lt;Class&lt;?&gt;&gt; classList =
1935                             new ArrayList&lt;&gt;(classNames.length);
1936                         for (String className : classNames) {
1937                             Class&lt;?&gt; clazz = getKeyClass(className);
1938                             if (clazz != null) {
1939                                 classList.add(clazz);
1940                             }
1941                         }
1942                         supportedClasses = classList.toArray(CLASS0);
1943                     }
1944                     boolean bool = (supportedFormats != null)
1945                         || (supportedClasses != null);
1946                     b = Boolean.valueOf(bool);
1947                     hasKeyAttributes = b;
1948                 }
1949             }
1950             return b.booleanValue();
1951         }
1952 
1953         // get the key class object of the specified name
1954         private Class&lt;?&gt; getKeyClass(String name) {
1955             try {
1956                 return Class.forName(name);
1957             } catch (ClassNotFoundException e) {
1958                 // ignore
1959             }
1960             try {
1961                 ClassLoader cl = provider.getClass().getClassLoader();
1962                 if (cl != null) {
1963                     return cl.loadClass(name);
1964                 }
1965             } catch (ClassNotFoundException e) {
1966                 // ignore
1967             }
1968             return null;
1969         }
1970 
1971         private boolean supportsKeyFormat(Key key) {
1972             if (supportedFormats == null) {
1973                 return false;
1974             }
1975             String format = key.getFormat();
1976             if (format == null) {
1977                 return false;
1978             }
1979             for (String supportedFormat : supportedFormats) {
1980                 if (supportedFormat.equals(format)) {
1981                     return true;
1982                 }
1983             }
1984             return false;
1985         }
1986 
1987         private boolean supportsKeyClass(Key key) {
1988             if (supportedClasses == null) {
1989                 return false;
1990             }
1991             Class&lt;?&gt; keyClass = key.getClass();
1992             for (Class&lt;?&gt; clazz : supportedClasses) {
1993                 if (clazz.isAssignableFrom(keyClass)) {
1994                     return true;
1995                 }
1996             }
1997             return false;
1998         }
1999 
2000         /**
2001          * Return a String representation of this service.
2002          *
2003          * @return a String representation of this service.
2004          */
2005         public String toString() {
2006             String aString = aliases.isEmpty()
2007                 ? &quot;&quot; : &quot;\r\n  aliases: &quot; + aliases.toString();
2008             String attrs = attributes.isEmpty()
2009                 ? &quot;&quot; : &quot;\r\n  attributes: &quot; + attributes.toString();
2010             return provider.getName() + &quot;: &quot; + type + &quot;.&quot; + algorithm
2011                 + &quot; -&gt; &quot; + className + aString + attrs + &quot;\r\n&quot;;
2012         }
2013     }
2014 }
    </pre>
  </body>
</html>
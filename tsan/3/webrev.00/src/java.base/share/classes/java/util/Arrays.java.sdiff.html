<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Arrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayPrefixHelpers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArraysParallelSortHelpers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Arrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  57  *
  58  * &lt;p&gt;The documentation for the methods contained in this class includes
  59  * brief descriptions of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
  60  * be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
  61  * &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
  62  * algorithms, so long as the specification itself is adhered to. (For
  63  * example, the algorithm used by {@code sort(Object[])} does not have to be
  64  * a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
  65  *
  66  * &lt;p&gt;This class is a member of the
  67  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  68  * Java Collections Framework&lt;/a&gt;.
  69  *
  70  * @author Josh Bloch
  71  * @author Neal Gafter
  72  * @author John Rose
  73  * @since  1.2
  74  */
  75 public class Arrays {
  76 
<span class="line-removed">  77     /**</span>
<span class="line-removed">  78      * The minimum array length below which a parallel sorting</span>
<span class="line-removed">  79      * algorithm will not further partition the sorting task. Using</span>
<span class="line-removed">  80      * smaller sizes typically results in memory contention across</span>
<span class="line-removed">  81      * tasks that makes parallel speedups unlikely.</span>
<span class="line-removed">  82      */</span>
<span class="line-removed">  83     private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;</span>
<span class="line-removed">  84 </span>
  85     // Suppresses default constructor, ensuring non-instantiability.
  86     private Arrays() {}
  87 
<span class="line-removed">  88     /**</span>
<span class="line-removed">  89      * A comparator that implements the natural ordering of a group of</span>
<span class="line-removed">  90      * mutually comparable elements. May be used when a supplied</span>
<span class="line-removed">  91      * comparator is null. To simplify code-sharing within underlying</span>
<span class="line-removed">  92      * implementations, the compare method only declares type Object</span>
<span class="line-removed">  93      * for its second argument.</span>
<span class="line-removed">  94      *</span>
<span class="line-removed">  95      * Arrays class implementor&#39;s note: It is an empirical matter</span>
<span class="line-removed">  96      * whether ComparableTimSort offers any performance benefit over</span>
<span class="line-removed">  97      * TimSort used with this comparator.  If not, you are better off</span>
<span class="line-removed">  98      * deleting or bypassing ComparableTimSort.  There is currently no</span>
<span class="line-removed">  99      * empirical case for separating them for parallel sorting, so all</span>
<span class="line-removed"> 100      * public Object parallelSort methods use the same comparator</span>
<span class="line-removed"> 101      * based implementation.</span>
<span class="line-removed"> 102      */</span>
<span class="line-removed"> 103     static final class NaturalOrder implements Comparator&lt;Object&gt; {</span>
<span class="line-removed"> 104         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed"> 105         public int compare(Object first, Object second) {</span>
<span class="line-removed"> 106             return ((Comparable&lt;Object&gt;)first).compareTo(second);</span>
<span class="line-removed"> 107         }</span>
<span class="line-removed"> 108         static final NaturalOrder INSTANCE = new NaturalOrder();</span>
<span class="line-removed"> 109     }</span>
<span class="line-removed"> 110 </span>
<span class="line-removed"> 111     /**</span>
<span class="line-removed"> 112      * Checks that {@code fromIndex} and {@code toIndex} are in</span>
<span class="line-removed"> 113      * the range and throws an exception if they aren&#39;t.</span>
<span class="line-removed"> 114      */</span>
<span class="line-removed"> 115     static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {</span>
<span class="line-removed"> 116         if (fromIndex &gt; toIndex) {</span>
<span class="line-removed"> 117             throw new IllegalArgumentException(</span>
<span class="line-removed"> 118                     &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span>
<span class="line-removed"> 119         }</span>
<span class="line-removed"> 120         if (fromIndex &lt; 0) {</span>
<span class="line-removed"> 121             throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="line-removed"> 122         }</span>
<span class="line-removed"> 123         if (toIndex &gt; arrayLength) {</span>
<span class="line-removed"> 124             throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="line-removed"> 125         }</span>
<span class="line-removed"> 126     }</span>
<span class="line-removed"> 127 </span>
 128     /*
 129      * Sorting methods. Note that all public &quot;sort&quot; methods take the
<span class="line-modified"> 130      * same form: Performing argument checks if necessary, and then</span>
 131      * expanding arguments into those required for the internal
 132      * implementation methods residing in other package-private
 133      * classes (except for legacyMergeSort, included in this class).
 134      */
 135 
 136     /**
 137      * Sorts the specified array into ascending numerical order.
 138      *
<span class="line-modified"> 139      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 140      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 141      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 142      * quicksorts to degrade to quadratic performance, and is typically</span>
 143      * faster than traditional (one-pivot) Quicksort implementations.
 144      *
 145      * @param a the array to be sorted
 146      */
 147     public static void sort(int[] a) {
<span class="line-modified"> 148         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 149     }
 150 
 151     /**
 152      * Sorts the specified range of the array into ascending order. The range
 153      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 154      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 155      * the range to be sorted is empty.
 156      *
<span class="line-modified"> 157      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 158      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 159      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 160      * quicksorts to degrade to quadratic performance, and is typically</span>
 161      * faster than traditional (one-pivot) Quicksort implementations.
 162      *
 163      * @param a the array to be sorted
 164      * @param fromIndex the index of the first element, inclusive, to be sorted
 165      * @param toIndex the index of the last element, exclusive, to be sorted
 166      *
 167      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 168      * @throws ArrayIndexOutOfBoundsException
 169      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 170      */
 171     public static void sort(int[] a, int fromIndex, int toIndex) {
 172         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 173         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 174     }
 175 
 176     /**
 177      * Sorts the specified array into ascending numerical order.
 178      *
<span class="line-modified"> 179      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 180      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 181      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 182      * quicksorts to degrade to quadratic performance, and is typically</span>
 183      * faster than traditional (one-pivot) Quicksort implementations.
 184      *
 185      * @param a the array to be sorted
 186      */
 187     public static void sort(long[] a) {
<span class="line-modified"> 188         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 189     }
 190 
 191     /**
 192      * Sorts the specified range of the array into ascending order. The range
 193      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 194      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 195      * the range to be sorted is empty.
 196      *
<span class="line-modified"> 197      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 198      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 199      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 200      * quicksorts to degrade to quadratic performance, and is typically</span>
 201      * faster than traditional (one-pivot) Quicksort implementations.
 202      *
 203      * @param a the array to be sorted
 204      * @param fromIndex the index of the first element, inclusive, to be sorted
 205      * @param toIndex the index of the last element, exclusive, to be sorted
 206      *
 207      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 208      * @throws ArrayIndexOutOfBoundsException
 209      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 210      */
 211     public static void sort(long[] a, int fromIndex, int toIndex) {
 212         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 213         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 214     }
 215 
 216     /**
 217      * Sorts the specified array into ascending numerical order.
 218      *
<span class="line-modified"> 219      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 220      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 221      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 222      * quicksorts to degrade to quadratic performance, and is typically</span>
 223      * faster than traditional (one-pivot) Quicksort implementations.
 224      *
 225      * @param a the array to be sorted
 226      */
 227     public static void sort(short[] a) {
<span class="line-modified"> 228         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 229     }
 230 
 231     /**
 232      * Sorts the specified range of the array into ascending order. The range
 233      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 234      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 235      * the range to be sorted is empty.
 236      *
<span class="line-modified"> 237      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 238      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 239      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 240      * quicksorts to degrade to quadratic performance, and is typically</span>
 241      * faster than traditional (one-pivot) Quicksort implementations.
 242      *
 243      * @param a the array to be sorted
 244      * @param fromIndex the index of the first element, inclusive, to be sorted
 245      * @param toIndex the index of the last element, exclusive, to be sorted
 246      *
 247      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 248      * @throws ArrayIndexOutOfBoundsException
 249      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 250      */
 251     public static void sort(short[] a, int fromIndex, int toIndex) {
 252         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 253         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 254     }
 255 
 256     /**
 257      * Sorts the specified array into ascending numerical order.
 258      *
<span class="line-modified"> 259      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 260      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 261      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 262      * quicksorts to degrade to quadratic performance, and is typically</span>
 263      * faster than traditional (one-pivot) Quicksort implementations.
 264      *
 265      * @param a the array to be sorted
 266      */
 267     public static void sort(char[] a) {
<span class="line-modified"> 268         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 269     }
 270 
 271     /**
 272      * Sorts the specified range of the array into ascending order. The range
 273      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 274      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 275      * the range to be sorted is empty.
 276      *
<span class="line-modified"> 277      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 278      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 279      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 280      * quicksorts to degrade to quadratic performance, and is typically</span>
 281      * faster than traditional (one-pivot) Quicksort implementations.
 282      *
 283      * @param a the array to be sorted
 284      * @param fromIndex the index of the first element, inclusive, to be sorted
 285      * @param toIndex the index of the last element, exclusive, to be sorted
 286      *
 287      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 288      * @throws ArrayIndexOutOfBoundsException
 289      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 290      */
 291     public static void sort(char[] a, int fromIndex, int toIndex) {
 292         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 293         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 294     }
 295 
 296     /**
 297      * Sorts the specified array into ascending numerical order.
 298      *
<span class="line-modified"> 299      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 300      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 301      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 302      * quicksorts to degrade to quadratic performance, and is typically</span>
 303      * faster than traditional (one-pivot) Quicksort implementations.
 304      *
 305      * @param a the array to be sorted
 306      */
 307     public static void sort(byte[] a) {
<span class="line-modified"> 308         DualPivotQuicksort.sort(a, 0, a.length - 1);</span>
 309     }
 310 
 311     /**
 312      * Sorts the specified range of the array into ascending order. The range
 313      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 314      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 315      * the range to be sorted is empty.
 316      *
<span class="line-modified"> 317      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 318      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 319      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 320      * quicksorts to degrade to quadratic performance, and is typically</span>
 321      * faster than traditional (one-pivot) Quicksort implementations.
 322      *
 323      * @param a the array to be sorted
 324      * @param fromIndex the index of the first element, inclusive, to be sorted
 325      * @param toIndex the index of the last element, exclusive, to be sorted
 326      *
 327      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 328      * @throws ArrayIndexOutOfBoundsException
 329      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 330      */
 331     public static void sort(byte[] a, int fromIndex, int toIndex) {
 332         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 333         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
 334     }
 335 
 336     /**
 337      * Sorts the specified array into ascending numerical order.
 338      *
 339      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 340      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 341      * value compares neither less than, greater than, nor equal to any value,
 342      * even itself. This method uses the total order imposed by the method
 343      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 344      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 345      * other value and all {@code Float.NaN} values are considered equal.
 346      *
<span class="line-modified"> 347      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 348      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 349      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 350      * quicksorts to degrade to quadratic performance, and is typically</span>
 351      * faster than traditional (one-pivot) Quicksort implementations.
 352      *
 353      * @param a the array to be sorted
 354      */
 355     public static void sort(float[] a) {
<span class="line-modified"> 356         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 357     }
 358 
 359     /**
 360      * Sorts the specified range of the array into ascending order. The range
 361      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 362      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 363      * the range to be sorted is empty.
 364      *
 365      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 366      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 367      * value compares neither less than, greater than, nor equal to any value,
 368      * even itself. This method uses the total order imposed by the method
 369      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 370      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 371      * other value and all {@code Float.NaN} values are considered equal.
 372      *
<span class="line-modified"> 373      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 374      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 375      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 376      * quicksorts to degrade to quadratic performance, and is typically</span>
 377      * faster than traditional (one-pivot) Quicksort implementations.
 378      *
 379      * @param a the array to be sorted
 380      * @param fromIndex the index of the first element, inclusive, to be sorted
 381      * @param toIndex the index of the last element, exclusive, to be sorted
 382      *
 383      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 384      * @throws ArrayIndexOutOfBoundsException
 385      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 386      */
 387     public static void sort(float[] a, int fromIndex, int toIndex) {
 388         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 389         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 390     }
 391 
 392     /**
 393      * Sorts the specified array into ascending numerical order.
 394      *
 395      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 396      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 397      * value compares neither less than, greater than, nor equal to any value,
 398      * even itself. This method uses the total order imposed by the method
 399      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 400      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 401      * other value and all {@code Double.NaN} values are considered equal.
 402      *
<span class="line-modified"> 403      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 404      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 405      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 406      * quicksorts to degrade to quadratic performance, and is typically</span>
 407      * faster than traditional (one-pivot) Quicksort implementations.
 408      *
 409      * @param a the array to be sorted
 410      */
 411     public static void sort(double[] a) {
<span class="line-modified"> 412         DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);</span>
 413     }
 414 
 415     /**
 416      * Sorts the specified range of the array into ascending order. The range
 417      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 418      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 419      * the range to be sorted is empty.
 420      *
 421      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 422      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 423      * value compares neither less than, greater than, nor equal to any value,
 424      * even itself. This method uses the total order imposed by the method
 425      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 426      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 427      * other value and all {@code Double.NaN} values are considered equal.
 428      *
<span class="line-modified"> 429      * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort</span>
 430      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 431      * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-removed"> 432      * quicksorts to degrade to quadratic performance, and is typically</span>
 433      * faster than traditional (one-pivot) Quicksort implementations.
 434      *
 435      * @param a the array to be sorted
 436      * @param fromIndex the index of the first element, inclusive, to be sorted
 437      * @param toIndex the index of the last element, exclusive, to be sorted
 438      *
 439      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 440      * @throws ArrayIndexOutOfBoundsException
 441      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 442      */
 443     public static void sort(double[] a, int fromIndex, int toIndex) {
 444         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 445         DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
 446     }
 447 
 448     /**
 449      * Sorts the specified array into ascending numerical order.
 450      *
<span class="line-modified"> 451      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 452      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 453      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 454      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</span>
<span class="line-removed"> 455      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 456      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 457      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 458      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 459      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 460      * execute any parallel tasks.</span>
 461      *
 462      * @param a the array to be sorted
 463      *
 464      * @since 1.8
 465      */
 466     public static void parallelSort(byte[] a) {
<span class="line-modified"> 467         int n = a.length, p, g;</span>
<span class="line-removed"> 468         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 469             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 470             DualPivotQuicksort.sort(a, 0, n - 1);</span>
<span class="line-removed"> 471         else</span>
<span class="line-removed"> 472             new ArraysParallelSortHelpers.FJByte.Sorter</span>
<span class="line-removed"> 473                 (null, a, new byte[n], 0, n, 0,</span>
<span class="line-removed"> 474                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 475                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 476     }
 477 
 478     /**
 479      * Sorts the specified range of the array into ascending numerical order.
 480      * The range to be sorted extends from the index {@code fromIndex},
 481      * inclusive, to the index {@code toIndex}, exclusive. If
 482      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 483      *
<span class="line-modified"> 484      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 485      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 486      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 487      * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort}</span>
<span class="line-removed"> 488      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 489      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 490      * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 491      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 492      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 493      * used to execute any parallel tasks.</span>
 494      *
 495      * @param a the array to be sorted
 496      * @param fromIndex the index of the first element, inclusive, to be sorted
 497      * @param toIndex the index of the last element, exclusive, to be sorted
 498      *
 499      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 500      * @throws ArrayIndexOutOfBoundsException
 501      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 502      *
 503      * @since 1.8
 504      */
 505     public static void parallelSort(byte[] a, int fromIndex, int toIndex) {
 506         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 507         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 508         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 509             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 510             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1);</span>
<span class="line-removed"> 511         else</span>
<span class="line-removed"> 512             new ArraysParallelSortHelpers.FJByte.Sorter</span>
<span class="line-removed"> 513                 (null, a, new byte[n], fromIndex, n, 0,</span>
<span class="line-removed"> 514                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 515                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 516     }
 517 
 518     /**
 519      * Sorts the specified array into ascending numerical order.
 520      *
<span class="line-modified"> 521      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 522      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 523      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 524      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</span>
<span class="line-removed"> 525      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 526      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 527      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 528      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 529      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 530      * execute any parallel tasks.</span>
 531      *
 532      * @param a the array to be sorted
 533      *
 534      * @since 1.8
 535      */
 536     public static void parallelSort(char[] a) {
<span class="line-modified"> 537         int n = a.length, p, g;</span>
<span class="line-removed"> 538         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 539             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 540             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 541         else</span>
<span class="line-removed"> 542             new ArraysParallelSortHelpers.FJChar.Sorter</span>
<span class="line-removed"> 543                 (null, a, new char[n], 0, n, 0,</span>
<span class="line-removed"> 544                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 545                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 546     }
 547 
 548     /**
 549      * Sorts the specified range of the array into ascending numerical order.
 550      * The range to be sorted extends from the index {@code fromIndex},
 551      * inclusive, to the index {@code toIndex}, exclusive. If
 552      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 553      *
<span class="line-modified"> 554       @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 555      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 556      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 557      * sorted using the appropriate {@link Arrays#sort(char[]) Arrays.sort}</span>
<span class="line-removed"> 558      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 559      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 560      * Arrays#sort(char[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 561      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 562      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 563      * used to execute any parallel tasks.</span>
 564      *
 565      * @param a the array to be sorted
 566      * @param fromIndex the index of the first element, inclusive, to be sorted
 567      * @param toIndex the index of the last element, exclusive, to be sorted
 568      *
 569      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 570      * @throws ArrayIndexOutOfBoundsException
 571      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 572      *
 573      * @since 1.8
 574      */
 575     public static void parallelSort(char[] a, int fromIndex, int toIndex) {
 576         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 577         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 578         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 579             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 580             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 581         else</span>
<span class="line-removed"> 582             new ArraysParallelSortHelpers.FJChar.Sorter</span>
<span class="line-removed"> 583                 (null, a, new char[n], fromIndex, n, 0,</span>
<span class="line-removed"> 584                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 585                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 586     }
 587 
 588     /**
 589      * Sorts the specified array into ascending numerical order.
 590      *
<span class="line-modified"> 591      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 592      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 593      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 594      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</span>
<span class="line-removed"> 595      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 596      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 597      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 598      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 599      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 600      * execute any parallel tasks.</span>
 601      *
 602      * @param a the array to be sorted
 603      *
 604      * @since 1.8
 605      */
 606     public static void parallelSort(short[] a) {
<span class="line-modified"> 607         int n = a.length, p, g;</span>
<span class="line-removed"> 608         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 609             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 610             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 611         else</span>
<span class="line-removed"> 612             new ArraysParallelSortHelpers.FJShort.Sorter</span>
<span class="line-removed"> 613                 (null, a, new short[n], 0, n, 0,</span>
<span class="line-removed"> 614                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 615                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 616     }
 617 
 618     /**
 619      * Sorts the specified range of the array into ascending numerical order.
 620      * The range to be sorted extends from the index {@code fromIndex},
 621      * inclusive, to the index {@code toIndex}, exclusive. If
 622      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 623      *
<span class="line-modified"> 624      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 625      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 626      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 627      * sorted using the appropriate {@link Arrays#sort(short[]) Arrays.sort}</span>
<span class="line-removed"> 628      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 629      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 630      * Arrays#sort(short[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 631      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 632      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 633      * used to execute any parallel tasks.</span>
 634      *
 635      * @param a the array to be sorted
 636      * @param fromIndex the index of the first element, inclusive, to be sorted
 637      * @param toIndex the index of the last element, exclusive, to be sorted
 638      *
 639      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 640      * @throws ArrayIndexOutOfBoundsException
 641      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 642      *
 643      * @since 1.8
 644      */
 645     public static void parallelSort(short[] a, int fromIndex, int toIndex) {
 646         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 647         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 648         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 649             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 650             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 651         else</span>
<span class="line-removed"> 652             new ArraysParallelSortHelpers.FJShort.Sorter</span>
<span class="line-removed"> 653                 (null, a, new short[n], fromIndex, n, 0,</span>
<span class="line-removed"> 654                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 655                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 656     }
 657 
 658     /**
 659      * Sorts the specified array into ascending numerical order.
 660      *
<span class="line-modified"> 661      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 662      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 663      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 664      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</span>
<span class="line-removed"> 665      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 666      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 667      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 668      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 669      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 670      * execute any parallel tasks.</span>
 671      *
 672      * @param a the array to be sorted
 673      *
 674      * @since 1.8
 675      */
 676     public static void parallelSort(int[] a) {
<span class="line-modified"> 677         int n = a.length, p, g;</span>
<span class="line-removed"> 678         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 679             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 680             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 681         else</span>
<span class="line-removed"> 682             new ArraysParallelSortHelpers.FJInt.Sorter</span>
<span class="line-removed"> 683                 (null, a, new int[n], 0, n, 0,</span>
<span class="line-removed"> 684                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 685                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 686     }
 687 
 688     /**
 689      * Sorts the specified range of the array into ascending numerical order.
 690      * The range to be sorted extends from the index {@code fromIndex},
 691      * inclusive, to the index {@code toIndex}, exclusive. If
 692      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 693      *
<span class="line-modified"> 694      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 695      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 696      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 697      * sorted using the appropriate {@link Arrays#sort(int[]) Arrays.sort}</span>
<span class="line-removed"> 698      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 699      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 700      * Arrays#sort(int[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 701      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 702      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 703      * used to execute any parallel tasks.</span>
 704      *
 705      * @param a the array to be sorted
 706      * @param fromIndex the index of the first element, inclusive, to be sorted
 707      * @param toIndex the index of the last element, exclusive, to be sorted
 708      *
 709      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 710      * @throws ArrayIndexOutOfBoundsException
 711      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 712      *
 713      * @since 1.8
 714      */
 715     public static void parallelSort(int[] a, int fromIndex, int toIndex) {
 716         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 717         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 718         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 719             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 720             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 721         else</span>
<span class="line-removed"> 722             new ArraysParallelSortHelpers.FJInt.Sorter</span>
<span class="line-removed"> 723                 (null, a, new int[n], fromIndex, n, 0,</span>
<span class="line-removed"> 724                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 725                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 726     }
 727 
 728     /**
 729      * Sorts the specified array into ascending numerical order.
 730      *
<span class="line-modified"> 731      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 732      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 733      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 734      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</span>
<span class="line-removed"> 735      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 736      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 737      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 738      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 739      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 740      * execute any parallel tasks.</span>
 741      *
 742      * @param a the array to be sorted
 743      *
 744      * @since 1.8
 745      */
 746     public static void parallelSort(long[] a) {
<span class="line-modified"> 747         int n = a.length, p, g;</span>
<span class="line-removed"> 748         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 749             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 750             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 751         else</span>
<span class="line-removed"> 752             new ArraysParallelSortHelpers.FJLong.Sorter</span>
<span class="line-removed"> 753                 (null, a, new long[n], 0, n, 0,</span>
<span class="line-removed"> 754                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 755                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 756     }
 757 
 758     /**
 759      * Sorts the specified range of the array into ascending numerical order.
 760      * The range to be sorted extends from the index {@code fromIndex},
 761      * inclusive, to the index {@code toIndex}, exclusive. If
 762      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 763      *
<span class="line-modified"> 764      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 765      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 766      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 767      * sorted using the appropriate {@link Arrays#sort(long[]) Arrays.sort}</span>
<span class="line-removed"> 768      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 769      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 770      * Arrays#sort(long[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 771      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 772      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 773      * used to execute any parallel tasks.</span>
 774      *
 775      * @param a the array to be sorted
 776      * @param fromIndex the index of the first element, inclusive, to be sorted
 777      * @param toIndex the index of the last element, exclusive, to be sorted
 778      *
 779      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 780      * @throws ArrayIndexOutOfBoundsException
 781      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 782      *
 783      * @since 1.8
 784      */
 785     public static void parallelSort(long[] a, int fromIndex, int toIndex) {
 786         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 787         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 788         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 789             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 790             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 791         else</span>
<span class="line-removed"> 792             new ArraysParallelSortHelpers.FJLong.Sorter</span>
<span class="line-removed"> 793                 (null, a, new long[n], fromIndex, n, 0,</span>
<span class="line-removed"> 794                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 795                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 796     }
 797 
 798     /**
 799      * Sorts the specified array into ascending numerical order.
 800      *
 801      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 802      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 803      * value compares neither less than, greater than, nor equal to any value,
 804      * even itself. This method uses the total order imposed by the method
 805      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 806      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 807      * other value and all {@code Float.NaN} values are considered equal.
 808      *
<span class="line-modified"> 809      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 810      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 811      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 812      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</span>
<span class="line-removed"> 813      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 814      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 815      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 816      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 817      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 818      * execute any parallel tasks.</span>
 819      *
 820      * @param a the array to be sorted
 821      *
 822      * @since 1.8
 823      */
 824     public static void parallelSort(float[] a) {
<span class="line-modified"> 825         int n = a.length, p, g;</span>
<span class="line-removed"> 826         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 827             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 828             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 829         else</span>
<span class="line-removed"> 830             new ArraysParallelSortHelpers.FJFloat.Sorter</span>
<span class="line-removed"> 831                 (null, a, new float[n], 0, n, 0,</span>
<span class="line-removed"> 832                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 833                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 834     }
 835 
 836     /**
 837      * Sorts the specified range of the array into ascending numerical order.
 838      * The range to be sorted extends from the index {@code fromIndex},
 839      * inclusive, to the index {@code toIndex}, exclusive. If
 840      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 841      *
 842      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 843      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 844      * value compares neither less than, greater than, nor equal to any value,
 845      * even itself. This method uses the total order imposed by the method
 846      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 847      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 848      * other value and all {@code Float.NaN} values are considered equal.
 849      *
<span class="line-modified"> 850      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 851      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 852      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 853      * sorted using the appropriate {@link Arrays#sort(float[]) Arrays.sort}</span>
<span class="line-removed"> 854      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 855      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 856      * Arrays#sort(float[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 857      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 858      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 859      * used to execute any parallel tasks.</span>
 860      *
 861      * @param a the array to be sorted
 862      * @param fromIndex the index of the first element, inclusive, to be sorted
 863      * @param toIndex the index of the last element, exclusive, to be sorted
 864      *
 865      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 866      * @throws ArrayIndexOutOfBoundsException
 867      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 868      *
 869      * @since 1.8
 870      */
 871     public static void parallelSort(float[] a, int fromIndex, int toIndex) {
 872         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 873         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 874         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 875             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 876             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 877         else</span>
<span class="line-removed"> 878             new ArraysParallelSortHelpers.FJFloat.Sorter</span>
<span class="line-removed"> 879                 (null, a, new float[n], fromIndex, n, 0,</span>
<span class="line-removed"> 880                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 881                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 882     }
 883 
 884     /**
 885      * Sorts the specified array into ascending numerical order.
 886      *
 887      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 888      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 889      * value compares neither less than, greater than, nor equal to any value,
 890      * even itself. This method uses the total order imposed by the method
 891      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 892      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 893      * other value and all {@code Double.NaN} values are considered equal.
 894      *
<span class="line-modified"> 895      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 896      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 897      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 898      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</span>
<span class="line-removed"> 899      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 900      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 901      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a</span>
<span class="line-removed"> 902      * working space no greater than the size of the original array. The</span>
<span class="line-removed"> 903      * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to</span>
<span class="line-removed"> 904      * execute any parallel tasks.</span>
 905      *
 906      * @param a the array to be sorted
 907      *
 908      * @since 1.8
 909      */
 910     public static void parallelSort(double[] a) {
<span class="line-modified"> 911         int n = a.length, p, g;</span>
<span class="line-removed"> 912         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 913             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 914             DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0);</span>
<span class="line-removed"> 915         else</span>
<span class="line-removed"> 916             new ArraysParallelSortHelpers.FJDouble.Sorter</span>
<span class="line-removed"> 917                 (null, a, new double[n], 0, n, 0,</span>
<span class="line-removed"> 918                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 919                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 920     }
 921 
 922     /**
 923      * Sorts the specified range of the array into ascending numerical order.
 924      * The range to be sorted extends from the index {@code fromIndex},
 925      * inclusive, to the index {@code toIndex}, exclusive. If
 926      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 927      *
 928      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 929      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 930      * value compares neither less than, greater than, nor equal to any value,
 931      * even itself. This method uses the total order imposed by the method
 932      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 933      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 934      * other value and all {@code Double.NaN} values are considered equal.
 935      *
<span class="line-modified"> 936      * @implNote The sorting algorithm is a parallel sort-merge that breaks the</span>
<span class="line-modified"> 937      * array into sub-arrays that are themselves sorted and then merged. When</span>
<span class="line-modified"> 938      * the sub-array length reaches a minimum granularity, the sub-array is</span>
<span class="line-modified"> 939      * sorted using the appropriate {@link Arrays#sort(double[]) Arrays.sort}</span>
<span class="line-removed"> 940      * method. If the length of the specified array is less than the minimum</span>
<span class="line-removed"> 941      * granularity, then it is sorted using the appropriate {@link</span>
<span class="line-removed"> 942      * Arrays#sort(double[]) Arrays.sort} method. The algorithm requires a working</span>
<span class="line-removed"> 943      * space no greater than the size of the specified range of the original</span>
<span class="line-removed"> 944      * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is</span>
<span class="line-removed"> 945      * used to execute any parallel tasks.</span>
 946      *
 947      * @param a the array to be sorted
 948      * @param fromIndex the index of the first element, inclusive, to be sorted
 949      * @param toIndex the index of the last element, exclusive, to be sorted
 950      *
 951      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 952      * @throws ArrayIndexOutOfBoundsException
 953      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 954      *
 955      * @since 1.8
 956      */
 957     public static void parallelSort(double[] a, int fromIndex, int toIndex) {
 958         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 959         int n = toIndex - fromIndex, p, g;</span>
<span class="line-removed"> 960         if (n &lt;= MIN_ARRAY_SORT_GRAN ||</span>
<span class="line-removed"> 961             (p = ForkJoinPool.getCommonPoolParallelism()) == 1)</span>
<span class="line-removed"> 962             DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);</span>
<span class="line-removed"> 963         else</span>
<span class="line-removed"> 964             new ArraysParallelSortHelpers.FJDouble.Sorter</span>
<span class="line-removed"> 965                 (null, a, new double[n], fromIndex, n, 0,</span>
<span class="line-removed"> 966                  ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span>
<span class="line-removed"> 967                  MIN_ARRAY_SORT_GRAN : g).invoke();</span>
 968     }
 969 
















































 970     /**
 971      * Sorts the specified array of objects into ascending order, according
 972      * to the {@linkplain Comparable natural ordering} of its elements.
 973      * All elements in the array must implement the {@link Comparable}
 974      * interface.  Furthermore, all elements in the array must be
 975      * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
 976      * not throw a {@code ClassCastException} for any elements {@code e1}
 977      * and {@code e2} in the array).
 978      *
 979      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 980      * not be reordered as a result of the sort.
 981      *
 982      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 983      * array into sub-arrays that are themselves sorted and then merged. When
 984      * the sub-array length reaches a minimum granularity, the sub-array is
 985      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
 986      * method. If the length of the specified array is less than the minimum
 987      * granularity, then it is sorted using the appropriate {@link
 988      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
 989      * working space no greater than the size of the original array. The
</pre>
<hr />
<pre>
2582             return false;
2583 
2584         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2585     }
2586 
2587     /**
2588      * Returns true if the two specified arrays of longs, over the specified
2589      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2590      *
2591      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2592      * each range is the same, and all corresponding pairs of elements over the
2593      * specified ranges in the two arrays are equal.  In other words, two arrays
2594      * are equal if they contain, over the specified ranges, the same elements
2595      * in the same order.
2596      *
2597      * @param a the first array to be tested for equality
2598      * @param aFromIndex the index (inclusive) of the first element in the
2599      *                   first array to be tested
2600      * @param aToIndex the index (exclusive) of the last element in the
2601      *                 first array to be tested
<span class="line-modified">2602      * @param b the second array to be tested fro equality</span>
2603      * @param bFromIndex the index (inclusive) of the first element in the
2604      *                   second array to be tested
2605      * @param bToIndex the index (exclusive) of the last element in the
2606      *                 second array to be tested
2607      * @return {@code true} if the two arrays, over the specified ranges, are
2608      *         equal
2609      * @throws IllegalArgumentException
2610      *         if {@code aFromIndex &gt; aToIndex} or
2611      *         if {@code bFromIndex &gt; bToIndex}
2612      * @throws ArrayIndexOutOfBoundsException
2613      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2614      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2615      * @throws NullPointerException
2616      *         if either array is {@code null}
2617      * @since 9
2618      */
2619     public static boolean equals(long[] a, int aFromIndex, int aToIndex,
2620                                  long[] b, int bFromIndex, int bToIndex) {
2621         rangeCheck(a.length, aFromIndex, aToIndex);
2622         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2654             return false;
2655 
2656         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2657     }
2658 
2659     /**
2660      * Returns true if the two specified arrays of ints, over the specified
2661      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2662      *
2663      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2664      * each range is the same, and all corresponding pairs of elements over the
2665      * specified ranges in the two arrays are equal.  In other words, two arrays
2666      * are equal if they contain, over the specified ranges, the same elements
2667      * in the same order.
2668      *
2669      * @param a the first array to be tested for equality
2670      * @param aFromIndex the index (inclusive) of the first element in the
2671      *                   first array to be tested
2672      * @param aToIndex the index (exclusive) of the last element in the
2673      *                 first array to be tested
<span class="line-modified">2674      * @param b the second array to be tested fro equality</span>
2675      * @param bFromIndex the index (inclusive) of the first element in the
2676      *                   second array to be tested
2677      * @param bToIndex the index (exclusive) of the last element in the
2678      *                 second array to be tested
2679      * @return {@code true} if the two arrays, over the specified ranges, are
2680      *         equal
2681      * @throws IllegalArgumentException
2682      *         if {@code aFromIndex &gt; aToIndex} or
2683      *         if {@code bFromIndex &gt; bToIndex}
2684      * @throws ArrayIndexOutOfBoundsException
2685      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2686      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2687      * @throws NullPointerException
2688      *         if either array is {@code null}
2689      * @since 9
2690      */
2691     public static boolean equals(int[] a, int aFromIndex, int aToIndex,
2692                                  int[] b, int bFromIndex, int bToIndex) {
2693         rangeCheck(a.length, aFromIndex, aToIndex);
2694         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2726             return false;
2727 
2728         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2729     }
2730 
2731     /**
2732      * Returns true if the two specified arrays of shorts, over the specified
2733      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2734      *
2735      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2736      * each range is the same, and all corresponding pairs of elements over the
2737      * specified ranges in the two arrays are equal.  In other words, two arrays
2738      * are equal if they contain, over the specified ranges, the same elements
2739      * in the same order.
2740      *
2741      * @param a the first array to be tested for equality
2742      * @param aFromIndex the index (inclusive) of the first element in the
2743      *                   first array to be tested
2744      * @param aToIndex the index (exclusive) of the last element in the
2745      *                 first array to be tested
<span class="line-modified">2746      * @param b the second array to be tested fro equality</span>
2747      * @param bFromIndex the index (inclusive) of the first element in the
2748      *                   second array to be tested
2749      * @param bToIndex the index (exclusive) of the last element in the
2750      *                 second array to be tested
2751      * @return {@code true} if the two arrays, over the specified ranges, are
2752      *         equal
2753      * @throws IllegalArgumentException
2754      *         if {@code aFromIndex &gt; aToIndex} or
2755      *         if {@code bFromIndex &gt; bToIndex}
2756      * @throws ArrayIndexOutOfBoundsException
2757      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2758      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2759      * @throws NullPointerException
2760      *         if either array is {@code null}
2761      * @since 9
2762      */
2763     public static boolean equals(short[] a, int aFromIndex, int aToIndex,
2764                                  short[] b, int bFromIndex, int bToIndex) {
2765         rangeCheck(a.length, aFromIndex, aToIndex);
2766         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2799             return false;
2800 
2801         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2802     }
2803 
2804     /**
2805      * Returns true if the two specified arrays of chars, over the specified
2806      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2807      *
2808      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2809      * each range is the same, and all corresponding pairs of elements over the
2810      * specified ranges in the two arrays are equal.  In other words, two arrays
2811      * are equal if they contain, over the specified ranges, the same elements
2812      * in the same order.
2813      *
2814      * @param a the first array to be tested for equality
2815      * @param aFromIndex the index (inclusive) of the first element in the
2816      *                   first array to be tested
2817      * @param aToIndex the index (exclusive) of the last element in the
2818      *                 first array to be tested
<span class="line-modified">2819      * @param b the second array to be tested fro equality</span>
2820      * @param bFromIndex the index (inclusive) of the first element in the
2821      *                   second array to be tested
2822      * @param bToIndex the index (exclusive) of the last element in the
2823      *                 second array to be tested
2824      * @return {@code true} if the two arrays, over the specified ranges, are
2825      *         equal
2826      * @throws IllegalArgumentException
2827      *         if {@code aFromIndex &gt; aToIndex} or
2828      *         if {@code bFromIndex &gt; bToIndex}
2829      * @throws ArrayIndexOutOfBoundsException
2830      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2831      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2832      * @throws NullPointerException
2833      *         if either array is {@code null}
2834      * @since 9
2835      */
2836     public static boolean equals(char[] a, int aFromIndex, int aToIndex,
2837                                  char[] b, int bFromIndex, int bToIndex) {
2838         rangeCheck(a.length, aFromIndex, aToIndex);
2839         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2872             return false;
2873 
2874         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2875     }
2876 
2877     /**
2878      * Returns true if the two specified arrays of bytes, over the specified
2879      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2880      *
2881      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2882      * each range is the same, and all corresponding pairs of elements over the
2883      * specified ranges in the two arrays are equal.  In other words, two arrays
2884      * are equal if they contain, over the specified ranges, the same elements
2885      * in the same order.
2886      *
2887      * @param a the first array to be tested for equality
2888      * @param aFromIndex the index (inclusive) of the first element in the
2889      *                   first array to be tested
2890      * @param aToIndex the index (exclusive) of the last element in the
2891      *                 first array to be tested
<span class="line-modified">2892      * @param b the second array to be tested fro equality</span>
2893      * @param bFromIndex the index (inclusive) of the first element in the
2894      *                   second array to be tested
2895      * @param bToIndex the index (exclusive) of the last element in the
2896      *                 second array to be tested
2897      * @return {@code true} if the two arrays, over the specified ranges, are
2898      *         equal
2899      * @throws IllegalArgumentException
2900      *         if {@code aFromIndex &gt; aToIndex} or
2901      *         if {@code bFromIndex &gt; bToIndex}
2902      * @throws ArrayIndexOutOfBoundsException
2903      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2904      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2905      * @throws NullPointerException
2906      *         if either array is {@code null}
2907      * @since 9
2908      */
2909     public static boolean equals(byte[] a, int aFromIndex, int aToIndex,
2910                                  byte[] b, int bFromIndex, int bToIndex) {
2911         rangeCheck(a.length, aFromIndex, aToIndex);
2912         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2944             return false;
2945 
2946         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2947     }
2948 
2949     /**
2950      * Returns true if the two specified arrays of booleans, over the specified
2951      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2952      *
2953      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2954      * each range is the same, and all corresponding pairs of elements over the
2955      * specified ranges in the two arrays are equal.  In other words, two arrays
2956      * are equal if they contain, over the specified ranges, the same elements
2957      * in the same order.
2958      *
2959      * @param a the first array to be tested for equality
2960      * @param aFromIndex the index (inclusive) of the first element in the
2961      *                   first array to be tested
2962      * @param aToIndex the index (exclusive) of the last element in the
2963      *                 first array to be tested
<span class="line-modified">2964      * @param b the second array to be tested fro equality</span>
2965      * @param bFromIndex the index (inclusive) of the first element in the
2966      *                   second array to be tested
2967      * @param bToIndex the index (exclusive) of the last element in the
2968      *                 second array to be tested
2969      * @return {@code true} if the two arrays, over the specified ranges, are
2970      *         equal
2971      * @throws IllegalArgumentException
2972      *         if {@code aFromIndex &gt; aToIndex} or
2973      *         if {@code bFromIndex &gt; bToIndex}
2974      * @throws ArrayIndexOutOfBoundsException
2975      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2976      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2977      * @throws NullPointerException
2978      *         if either array is {@code null}
2979      * @since 9
2980      */
2981     public static boolean equals(boolean[] a, int aFromIndex, int aToIndex,
2982                                  boolean[] b, int bFromIndex, int bToIndex) {
2983         rangeCheck(a.length, aFromIndex, aToIndex);
2984         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
3027     /**
3028      * Returns true if the two specified arrays of doubles, over the specified
3029      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3030      *
3031      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3032      * each range is the same, and all corresponding pairs of elements over the
3033      * specified ranges in the two arrays are equal.  In other words, two arrays
3034      * are equal if they contain, over the specified ranges, the same elements
3035      * in the same order.
3036      *
3037      * &lt;p&gt;Two doubles {@code d1} and {@code d2} are considered equal if:
3038      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
3039      * (Unlike the {@code ==} operator, this method considers
3040      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)
3041      *
3042      * @param a the first array to be tested for equality
3043      * @param aFromIndex the index (inclusive) of the first element in the
3044      *                   first array to be tested
3045      * @param aToIndex the index (exclusive) of the last element in the
3046      *                 first array to be tested
<span class="line-modified">3047      * @param b the second array to be tested fro equality</span>
3048      * @param bFromIndex the index (inclusive) of the first element in the
3049      *                   second array to be tested
3050      * @param bToIndex the index (exclusive) of the last element in the
3051      *                 second array to be tested
3052      * @return {@code true} if the two arrays, over the specified ranges, are
3053      *         equal
3054      * @throws IllegalArgumentException
3055      *         if {@code aFromIndex &gt; aToIndex} or
3056      *         if {@code bFromIndex &gt; bToIndex}
3057      * @throws ArrayIndexOutOfBoundsException
3058      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3059      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3060      * @throws NullPointerException
3061      *         if either array is {@code null}
3062      * @see Double#equals(Object)
3063      * @since 9
3064      */
3065     public static boolean equals(double[] a, int aFromIndex, int aToIndex,
3066                                  double[] b, int bFromIndex, int bToIndex) {
3067         rangeCheck(a.length, aFromIndex, aToIndex);
</pre>
<hr />
<pre>
3110     /**
3111      * Returns true if the two specified arrays of floats, over the specified
3112      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3113      *
3114      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3115      * each range is the same, and all corresponding pairs of elements over the
3116      * specified ranges in the two arrays are equal.  In other words, two arrays
3117      * are equal if they contain, over the specified ranges, the same elements
3118      * in the same order.
3119      *
3120      * &lt;p&gt;Two floats {@code f1} and {@code f2} are considered equal if:
3121      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
3122      * (Unlike the {@code ==} operator, this method considers
3123      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)
3124      *
3125      * @param a the first array to be tested for equality
3126      * @param aFromIndex the index (inclusive) of the first element in the
3127      *                   first array to be tested
3128      * @param aToIndex the index (exclusive) of the last element in the
3129      *                 first array to be tested
<span class="line-modified">3130      * @param b the second array to be tested fro equality</span>
3131      * @param bFromIndex the index (inclusive) of the first element in the
3132      *                   second array to be tested
3133      * @param bToIndex the index (exclusive) of the last element in the
3134      *                 second array to be tested
3135      * @return {@code true} if the two arrays, over the specified ranges, are
3136      *         equal
3137      * @throws IllegalArgumentException
3138      *         if {@code aFromIndex &gt; aToIndex} or
3139      *         if {@code bFromIndex &gt; bToIndex}
3140      * @throws ArrayIndexOutOfBoundsException
3141      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3142      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3143      * @throws NullPointerException
3144      *         if either array is {@code null}
3145      * @see Float#equals(Object)
3146      * @since 9
3147      */
3148     public static boolean equals(float[] a, int aFromIndex, int aToIndex,
3149                                  float[] b, int bFromIndex, int bToIndex) {
3150         rangeCheck(a.length, aFromIndex, aToIndex);
</pre>
<hr />
<pre>
3193     }
3194 
3195     /**
3196      * Returns true if the two specified arrays of Objects, over the specified
3197      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3198      *
3199      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3200      * each range is the same, and all corresponding pairs of elements over the
3201      * specified ranges in the two arrays are equal.  In other words, two arrays
3202      * are equal if they contain, over the specified ranges, the same elements
3203      * in the same order.
3204      *
3205      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if
3206      * {@code Objects.equals(e1, e2)}.
3207      *
3208      * @param a the first array to be tested for equality
3209      * @param aFromIndex the index (inclusive) of the first element in the
3210      *                   first array to be tested
3211      * @param aToIndex the index (exclusive) of the last element in the
3212      *                 first array to be tested
<span class="line-modified">3213      * @param b the second array to be tested fro equality</span>
3214      * @param bFromIndex the index (inclusive) of the first element in the
3215      *                   second array to be tested
3216      * @param bToIndex the index (exclusive) of the last element in the
3217      *                 second array to be tested
3218      * @return {@code true} if the two arrays, over the specified ranges, are
3219      *         equal
3220      * @throws IllegalArgumentException
3221      *         if {@code aFromIndex &gt; aToIndex} or
3222      *         if {@code bFromIndex &gt; bToIndex}
3223      * @throws ArrayIndexOutOfBoundsException
3224      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3225      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3226      * @throws NullPointerException
3227      *         if either array is {@code null}
3228      * @since 9
3229      */
3230     public static boolean equals(Object[] a, int aFromIndex, int aToIndex,
3231                                  Object[] b, int bFromIndex, int bToIndex) {
3232         rangeCheck(a.length, aFromIndex, aToIndex);
3233         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
3286     }
3287 
3288     /**
3289      * Returns true if the two specified arrays of Objects, over the specified
3290      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3291      *
3292      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3293      * each range is the same, and all corresponding pairs of elements over the
3294      * specified ranges in the two arrays are equal.  In other words, two arrays
3295      * are equal if they contain, over the specified ranges, the same elements
3296      * in the same order.
3297      *
3298      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if,
3299      * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
3300      *
3301      * @param a the first array to be tested for equality
3302      * @param aFromIndex the index (inclusive) of the first element in the
3303      *                   first array to be tested
3304      * @param aToIndex the index (exclusive) of the last element in the
3305      *                 first array to be tested
<span class="line-modified">3306      * @param b the second array to be tested fro equality</span>
3307      * @param bFromIndex the index (inclusive) of the first element in the
3308      *                   second array to be tested
3309      * @param bToIndex the index (exclusive) of the last element in the
3310      *                 second array to be tested
3311      * @param cmp the comparator to compare array elements
3312      * @param &lt;T&gt; the type of array elements
3313      * @return {@code true} if the two arrays, over the specified ranges, are
3314      *         equal
3315      * @throws IllegalArgumentException
3316      *         if {@code aFromIndex &gt; aToIndex} or
3317      *         if {@code bFromIndex &gt; bToIndex}
3318      * @throws ArrayIndexOutOfBoundsException
3319      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3320      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3321      * @throws NullPointerException
3322      *         if either array or the comparator is {@code null}
3323      * @since 9
3324      */
3325     public static &lt;T&gt; boolean equals(T[] a, int aFromIndex, int aToIndex,
3326                                      T[] b, int bFromIndex, int bToIndex,
</pre>
<hr />
<pre>
4320      * {@link Collections#unmodifiableList Collections.unmodifiableList}
4321      * or &lt;a href=&quot;List.html#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt;.
4322      *
4323      * @param &lt;T&gt; the class of the objects in the array
4324      * @param a the array by which the list will be backed
4325      * @return a list view of the specified array
4326      * @throws NullPointerException if the specified array is {@code null}
4327      */
4328     @SafeVarargs
4329     @SuppressWarnings(&quot;varargs&quot;)
4330     public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
4331         return new ArrayList&lt;&gt;(a);
4332     }
4333 
4334     /**
4335      * @serial include
4336      */
4337     private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
4338         implements RandomAccess, java.io.Serializable
4339     {

4340         private static final long serialVersionUID = -2764017481108945198L;

4341         private final E[] a;
4342 
4343         ArrayList(E[] array) {
4344             a = Objects.requireNonNull(array);
4345         }
4346 
4347         @Override
4348         public int size() {
4349             return a.length;
4350         }
4351 
4352         @Override
4353         public Object[] toArray() {
4354             return Arrays.copyOf(a, a.length, Object[].class);
4355         }
4356 
4357         @Override
4358         @SuppressWarnings(&quot;unchecked&quot;)
4359         public &lt;T&gt; T[] toArray(T[] a) {
4360             int size = size();
</pre>
<hr />
<pre>
7308     // Compare objects
7309 
7310     /**
7311      * Compares two {@code Object} arrays, within comparable elements,
7312      * lexicographically.
7313      *
7314      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7315      * comparison is the result of comparing two elements of type {@code T} at
7316      * an index {@code i} within the respective arrays that is the prefix
7317      * length, as if by:
7318      * &lt;pre&gt;{@code
7319      *     Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
7320      *         compare(a[i], b[i])
7321      * }&lt;/pre&gt;
7322      * Otherwise, one array is a proper prefix of the other and, lexicographic
7323      * comparison is the result of comparing the two array lengths.
7324      * (See {@link #mismatch(Object[], Object[])} for the definition of a common
7325      * and proper prefix.)
7326      *
7327      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
<span class="line-modified">7328      * than a non-{@code null} array reference.  Two {@code null} array</span>
7329      * references are considered equal.
<span class="line-modified">7330      * A {@code null} array element is considered lexicographically than a</span>
<span class="line-modified">7331      * non-{@code null} array element.  Two {@code null} array elements are</span>
7332      * considered equal.
7333      *
7334      * &lt;p&gt;The comparison is consistent with {@link #equals(Object[], Object[]) equals},
7335      * more specifically the following holds for arrays {@code a} and {@code b}:
7336      * &lt;pre&gt;{@code
7337      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
7338      * }&lt;/pre&gt;
7339      *
7340      * @apiNote
7341      * &lt;p&gt;This method behaves as if (for non-{@code null} array references
7342      * and elements):
7343      * &lt;pre&gt;{@code
7344      *     int i = Arrays.mismatch(a, b);
7345      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7346      *         return a[i].compareTo(b[i]);
7347      *     return a.length - b.length;
7348      * }&lt;/pre&gt;
7349      *
7350      * @param a the first array to compare
7351      * @param b the second array to compare
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  57  *
  58  * &lt;p&gt;The documentation for the methods contained in this class includes
  59  * brief descriptions of the &lt;i&gt;implementations&lt;/i&gt;. Such descriptions should
  60  * be regarded as &lt;i&gt;implementation notes&lt;/i&gt;, rather than parts of the
  61  * &lt;i&gt;specification&lt;/i&gt;. Implementors should feel free to substitute other
  62  * algorithms, so long as the specification itself is adhered to. (For
  63  * example, the algorithm used by {@code sort(Object[])} does not have to be
  64  * a MergeSort, but it does have to be &lt;i&gt;stable&lt;/i&gt;.)
  65  *
  66  * &lt;p&gt;This class is a member of the
  67  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  68  * Java Collections Framework&lt;/a&gt;.
  69  *
  70  * @author Josh Bloch
  71  * @author Neal Gafter
  72  * @author John Rose
  73  * @since  1.2
  74  */
  75 public class Arrays {
  76 








  77     // Suppresses default constructor, ensuring non-instantiability.
  78     private Arrays() {}
  79 








































  80     /*
  81      * Sorting methods. Note that all public &quot;sort&quot; methods take the
<span class="line-modified">  82      * same form: performing argument checks if necessary, and then</span>
  83      * expanding arguments into those required for the internal
  84      * implementation methods residing in other package-private
  85      * classes (except for legacyMergeSort, included in this class).
  86      */
  87 
  88     /**
  89      * Sorts the specified array into ascending numerical order.
  90      *
<span class="line-modified">  91      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
  92      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified">  93      * offers O(n log(n)) performance on all data sets, and is typically</span>

  94      * faster than traditional (one-pivot) Quicksort implementations.
  95      *
  96      * @param a the array to be sorted
  97      */
  98     public static void sort(int[] a) {
<span class="line-modified">  99         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
 100     }
 101 
 102     /**
 103      * Sorts the specified range of the array into ascending order. The range
 104      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 105      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 106      * the range to be sorted is empty.
 107      *
<span class="line-modified"> 108      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 109      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 110      * offers O(n log(n)) performance on all data sets, and is typically</span>

 111      * faster than traditional (one-pivot) Quicksort implementations.
 112      *
 113      * @param a the array to be sorted
 114      * @param fromIndex the index of the first element, inclusive, to be sorted
 115      * @param toIndex the index of the last element, exclusive, to be sorted
 116      *
 117      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 118      * @throws ArrayIndexOutOfBoundsException
 119      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 120      */
 121     public static void sort(int[] a, int fromIndex, int toIndex) {
 122         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 123         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
 124     }
 125 
 126     /**
 127      * Sorts the specified array into ascending numerical order.
 128      *
<span class="line-modified"> 129      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 130      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 131      * offers O(n log(n)) performance on all data sets, and is typically</span>

 132      * faster than traditional (one-pivot) Quicksort implementations.
 133      *
 134      * @param a the array to be sorted
 135      */
 136     public static void sort(long[] a) {
<span class="line-modified"> 137         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
 138     }
 139 
 140     /**
 141      * Sorts the specified range of the array into ascending order. The range
 142      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 143      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 144      * the range to be sorted is empty.
 145      *
<span class="line-modified"> 146      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 147      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 148      * offers O(n log(n)) performance on all data sets, and is typically</span>

 149      * faster than traditional (one-pivot) Quicksort implementations.
 150      *
 151      * @param a the array to be sorted
 152      * @param fromIndex the index of the first element, inclusive, to be sorted
 153      * @param toIndex the index of the last element, exclusive, to be sorted
 154      *
 155      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 156      * @throws ArrayIndexOutOfBoundsException
 157      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 158      */
 159     public static void sort(long[] a, int fromIndex, int toIndex) {
 160         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 161         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
 162     }
 163 
 164     /**
 165      * Sorts the specified array into ascending numerical order.
 166      *
<span class="line-modified"> 167      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 168      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 169      * offers O(n log(n)) performance on all data sets, and is typically</span>

 170      * faster than traditional (one-pivot) Quicksort implementations.
 171      *
 172      * @param a the array to be sorted
 173      */
 174     public static void sort(short[] a) {
<span class="line-modified"> 175         DualPivotQuicksort.sort(a, 0, a.length);</span>
 176     }
 177 
 178     /**
 179      * Sorts the specified range of the array into ascending order. The range
 180      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 181      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 182      * the range to be sorted is empty.
 183      *
<span class="line-modified"> 184      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 185      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 186      * offers O(n log(n)) performance on all data sets, and is typically</span>

 187      * faster than traditional (one-pivot) Quicksort implementations.
 188      *
 189      * @param a the array to be sorted
 190      * @param fromIndex the index of the first element, inclusive, to be sorted
 191      * @param toIndex the index of the last element, exclusive, to be sorted
 192      *
 193      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 194      * @throws ArrayIndexOutOfBoundsException
 195      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 196      */
 197     public static void sort(short[] a, int fromIndex, int toIndex) {
 198         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 199         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
 200     }
 201 
 202     /**
 203      * Sorts the specified array into ascending numerical order.
 204      *
<span class="line-modified"> 205      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 206      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 207      * offers O(n log(n)) performance on all data sets, and is typically</span>

 208      * faster than traditional (one-pivot) Quicksort implementations.
 209      *
 210      * @param a the array to be sorted
 211      */
 212     public static void sort(char[] a) {
<span class="line-modified"> 213         DualPivotQuicksort.sort(a, 0, a.length);</span>
 214     }
 215 
 216     /**
 217      * Sorts the specified range of the array into ascending order. The range
 218      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 219      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 220      * the range to be sorted is empty.
 221      *
<span class="line-modified"> 222      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 223      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 224      * offers O(n log(n)) performance on all data sets, and is typically</span>

 225      * faster than traditional (one-pivot) Quicksort implementations.
 226      *
 227      * @param a the array to be sorted
 228      * @param fromIndex the index of the first element, inclusive, to be sorted
 229      * @param toIndex the index of the last element, exclusive, to be sorted
 230      *
 231      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 232      * @throws ArrayIndexOutOfBoundsException
 233      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 234      */
 235     public static void sort(char[] a, int fromIndex, int toIndex) {
 236         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 237         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
 238     }
 239 
 240     /**
 241      * Sorts the specified array into ascending numerical order.
 242      *
<span class="line-modified"> 243      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 244      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 245      * offers O(n log(n)) performance on all data sets, and is typically</span>

 246      * faster than traditional (one-pivot) Quicksort implementations.
 247      *
 248      * @param a the array to be sorted
 249      */
 250     public static void sort(byte[] a) {
<span class="line-modified"> 251         DualPivotQuicksort.sort(a, 0, a.length);</span>
 252     }
 253 
 254     /**
 255      * Sorts the specified range of the array into ascending order. The range
 256      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 257      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 258      * the range to be sorted is empty.
 259      *
<span class="line-modified"> 260      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 261      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 262      * offers O(n log(n)) performance on all data sets, and is typically</span>

 263      * faster than traditional (one-pivot) Quicksort implementations.
 264      *
 265      * @param a the array to be sorted
 266      * @param fromIndex the index of the first element, inclusive, to be sorted
 267      * @param toIndex the index of the last element, exclusive, to be sorted
 268      *
 269      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 270      * @throws ArrayIndexOutOfBoundsException
 271      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 272      */
 273     public static void sort(byte[] a, int fromIndex, int toIndex) {
 274         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 275         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>
 276     }
 277 
 278     /**
 279      * Sorts the specified array into ascending numerical order.
 280      *
 281      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 282      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 283      * value compares neither less than, greater than, nor equal to any value,
 284      * even itself. This method uses the total order imposed by the method
 285      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 286      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 287      * other value and all {@code Float.NaN} values are considered equal.
 288      *
<span class="line-modified"> 289      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 290      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 291      * offers O(n log(n)) performance on all data sets, and is typically</span>

 292      * faster than traditional (one-pivot) Quicksort implementations.
 293      *
 294      * @param a the array to be sorted
 295      */
 296     public static void sort(float[] a) {
<span class="line-modified"> 297         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
 298     }
 299 
 300     /**
 301      * Sorts the specified range of the array into ascending order. The range
 302      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 303      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 304      * the range to be sorted is empty.
 305      *
 306      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 307      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 308      * value compares neither less than, greater than, nor equal to any value,
 309      * even itself. This method uses the total order imposed by the method
 310      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 311      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 312      * other value and all {@code Float.NaN} values are considered equal.
 313      *
<span class="line-modified"> 314      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 315      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 316      * offers O(n log(n)) performance on all data sets, and is typically</span>

 317      * faster than traditional (one-pivot) Quicksort implementations.
 318      *
 319      * @param a the array to be sorted
 320      * @param fromIndex the index of the first element, inclusive, to be sorted
 321      * @param toIndex the index of the last element, exclusive, to be sorted
 322      *
 323      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 324      * @throws ArrayIndexOutOfBoundsException
 325      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 326      */
 327     public static void sort(float[] a, int fromIndex, int toIndex) {
 328         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 329         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
 330     }
 331 
 332     /**
 333      * Sorts the specified array into ascending numerical order.
 334      *
 335      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 336      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 337      * value compares neither less than, greater than, nor equal to any value,
 338      * even itself. This method uses the total order imposed by the method
 339      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 340      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 341      * other value and all {@code Double.NaN} values are considered equal.
 342      *
<span class="line-modified"> 343      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 344      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 345      * offers O(n log(n)) performance on all data sets, and is typically</span>

 346      * faster than traditional (one-pivot) Quicksort implementations.
 347      *
 348      * @param a the array to be sorted
 349      */
 350     public static void sort(double[] a) {
<span class="line-modified"> 351         DualPivotQuicksort.sort(a, 0, 0, a.length);</span>
 352     }
 353 
 354     /**
 355      * Sorts the specified range of the array into ascending order. The range
 356      * to be sorted extends from the index {@code fromIndex}, inclusive, to
 357      * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},
 358      * the range to be sorted is empty.
 359      *
 360      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 361      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 362      * value compares neither less than, greater than, nor equal to any value,
 363      * even itself. This method uses the total order imposed by the method
 364      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 365      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 366      * other value and all {@code Double.NaN} values are considered equal.
 367      *
<span class="line-modified"> 368      * @implNote The sorting algorithm is a Dual-Pivot Quicksort</span>
 369      * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
<span class="line-modified"> 370      * offers O(n log(n)) performance on all data sets, and is typically</span>

 371      * faster than traditional (one-pivot) Quicksort implementations.
 372      *
 373      * @param a the array to be sorted
 374      * @param fromIndex the index of the first element, inclusive, to be sorted
 375      * @param toIndex the index of the last element, exclusive, to be sorted
 376      *
 377      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 378      * @throws ArrayIndexOutOfBoundsException
 379      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 380      */
 381     public static void sort(double[] a, int fromIndex, int toIndex) {
 382         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 383         DualPivotQuicksort.sort(a, 0, fromIndex, toIndex);</span>
 384     }
 385 
 386     /**
 387      * Sorts the specified array into ascending numerical order.
 388      *
<span class="line-modified"> 389      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 390      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 391      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 392      * faster than traditional (one-pivot) Quicksort implementations.</span>






 393      *
 394      * @param a the array to be sorted
 395      *
 396      * @since 1.8
 397      */
 398     public static void parallelSort(byte[] a) {
<span class="line-modified"> 399         DualPivotQuicksort.sort(a, 0, a.length);</span>








 400     }
 401 
 402     /**
 403      * Sorts the specified range of the array into ascending numerical order.
 404      * The range to be sorted extends from the index {@code fromIndex},
 405      * inclusive, to the index {@code toIndex}, exclusive. If
 406      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 407      *
<span class="line-modified"> 408      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 409      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 410      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 411      * faster than traditional (one-pivot) Quicksort implementations.</span>






 412      *
 413      * @param a the array to be sorted
 414      * @param fromIndex the index of the first element, inclusive, to be sorted
 415      * @param toIndex the index of the last element, exclusive, to be sorted
 416      *
 417      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 418      * @throws ArrayIndexOutOfBoundsException
 419      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 420      *
 421      * @since 1.8
 422      */
 423     public static void parallelSort(byte[] a, int fromIndex, int toIndex) {
 424         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 425         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>








 426     }
 427 
 428     /**
 429      * Sorts the specified array into ascending numerical order.
 430      *
<span class="line-modified"> 431      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 432      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 433      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 434      * faster than traditional (one-pivot) Quicksort implementations.</span>






 435      *
 436      * @param a the array to be sorted
 437      *
 438      * @since 1.8
 439      */
 440     public static void parallelSort(char[] a) {
<span class="line-modified"> 441         DualPivotQuicksort.sort(a, 0, a.length);</span>








 442     }
 443 
 444     /**
 445      * Sorts the specified range of the array into ascending numerical order.
 446      * The range to be sorted extends from the index {@code fromIndex},
 447      * inclusive, to the index {@code toIndex}, exclusive. If
 448      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 449      *
<span class="line-modified"> 450      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 451      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 452      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 453      * faster than traditional (one-pivot) Quicksort implementations.</span>






 454      *
 455      * @param a the array to be sorted
 456      * @param fromIndex the index of the first element, inclusive, to be sorted
 457      * @param toIndex the index of the last element, exclusive, to be sorted
 458      *
 459      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 460      * @throws ArrayIndexOutOfBoundsException
 461      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 462      *
 463      * @since 1.8
 464      */
 465     public static void parallelSort(char[] a, int fromIndex, int toIndex) {
 466         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 467         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>








 468     }
 469 
 470     /**
 471      * Sorts the specified array into ascending numerical order.
 472      *
<span class="line-modified"> 473      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 474      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 475      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 476      * faster than traditional (one-pivot) Quicksort implementations.</span>






 477      *
 478      * @param a the array to be sorted
 479      *
 480      * @since 1.8
 481      */
 482     public static void parallelSort(short[] a) {
<span class="line-modified"> 483         DualPivotQuicksort.sort(a, 0, a.length);</span>








 484     }
 485 
 486     /**
 487      * Sorts the specified range of the array into ascending numerical order.
 488      * The range to be sorted extends from the index {@code fromIndex},
 489      * inclusive, to the index {@code toIndex}, exclusive. If
 490      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 491      *
<span class="line-modified"> 492      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 493      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 494      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 495      * faster than traditional (one-pivot) Quicksort implementations.</span>






 496      *
 497      * @param a the array to be sorted
 498      * @param fromIndex the index of the first element, inclusive, to be sorted
 499      * @param toIndex the index of the last element, exclusive, to be sorted
 500      *
 501      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 502      * @throws ArrayIndexOutOfBoundsException
 503      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 504      *
 505      * @since 1.8
 506      */
 507     public static void parallelSort(short[] a, int fromIndex, int toIndex) {
 508         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 509         DualPivotQuicksort.sort(a, fromIndex, toIndex);</span>








 510     }
 511 
 512     /**
 513      * Sorts the specified array into ascending numerical order.
 514      *
<span class="line-modified"> 515      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 516      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 517      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 518      * faster than traditional (one-pivot) Quicksort implementations.</span>






 519      *
 520      * @param a the array to be sorted
 521      *
 522      * @since 1.8
 523      */
 524     public static void parallelSort(int[] a) {
<span class="line-modified"> 525         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>








 526     }
 527 
 528     /**
 529      * Sorts the specified range of the array into ascending numerical order.
 530      * The range to be sorted extends from the index {@code fromIndex},
 531      * inclusive, to the index {@code toIndex}, exclusive. If
 532      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 533      *
<span class="line-modified"> 534      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 535      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 536      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 537      * faster than traditional (one-pivot) Quicksort implementations.</span>






 538      *
 539      * @param a the array to be sorted
 540      * @param fromIndex the index of the first element, inclusive, to be sorted
 541      * @param toIndex the index of the last element, exclusive, to be sorted
 542      *
 543      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 544      * @throws ArrayIndexOutOfBoundsException
 545      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 546      *
 547      * @since 1.8
 548      */
 549     public static void parallelSort(int[] a, int fromIndex, int toIndex) {
 550         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 551         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>








 552     }
 553 
 554     /**
 555      * Sorts the specified array into ascending numerical order.
 556      *
<span class="line-modified"> 557      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 558      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 559      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 560      * faster than traditional (one-pivot) Quicksort implementations.</span>






 561      *
 562      * @param a the array to be sorted
 563      *
 564      * @since 1.8
 565      */
 566     public static void parallelSort(long[] a) {
<span class="line-modified"> 567         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>








 568     }
 569 
 570     /**
 571      * Sorts the specified range of the array into ascending numerical order.
 572      * The range to be sorted extends from the index {@code fromIndex},
 573      * inclusive, to the index {@code toIndex}, exclusive. If
 574      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 575      *
<span class="line-modified"> 576      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 577      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 578      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 579      * faster than traditional (one-pivot) Quicksort implementations.</span>






 580      *
 581      * @param a the array to be sorted
 582      * @param fromIndex the index of the first element, inclusive, to be sorted
 583      * @param toIndex the index of the last element, exclusive, to be sorted
 584      *
 585      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 586      * @throws ArrayIndexOutOfBoundsException
 587      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 588      *
 589      * @since 1.8
 590      */
 591     public static void parallelSort(long[] a, int fromIndex, int toIndex) {
 592         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 593         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>








 594     }
 595 
 596     /**
 597      * Sorts the specified array into ascending numerical order.
 598      *
 599      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 600      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 601      * value compares neither less than, greater than, nor equal to any value,
 602      * even itself. This method uses the total order imposed by the method
 603      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 604      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 605      * other value and all {@code Float.NaN} values are considered equal.
 606      *
<span class="line-modified"> 607      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 608      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 609      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 610      * faster than traditional (one-pivot) Quicksort implementations.</span>






 611      *
 612      * @param a the array to be sorted
 613      *
 614      * @since 1.8
 615      */
 616     public static void parallelSort(float[] a) {
<span class="line-modified"> 617         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>








 618     }
 619 
 620     /**
 621      * Sorts the specified range of the array into ascending numerical order.
 622      * The range to be sorted extends from the index {@code fromIndex},
 623      * inclusive, to the index {@code toIndex}, exclusive. If
 624      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 625      *
 626      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all float
 627      * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}
 628      * value compares neither less than, greater than, nor equal to any value,
 629      * even itself. This method uses the total order imposed by the method
 630      * {@link Float#compareTo}: {@code -0.0f} is treated as less than value
 631      * {@code 0.0f} and {@code Float.NaN} is considered greater than any
 632      * other value and all {@code Float.NaN} values are considered equal.
 633      *
<span class="line-modified"> 634      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 635      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 636      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 637      * faster than traditional (one-pivot) Quicksort implementations.</span>






 638      *
 639      * @param a the array to be sorted
 640      * @param fromIndex the index of the first element, inclusive, to be sorted
 641      * @param toIndex the index of the last element, exclusive, to be sorted
 642      *
 643      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 644      * @throws ArrayIndexOutOfBoundsException
 645      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 646      *
 647      * @since 1.8
 648      */
 649     public static void parallelSort(float[] a, int fromIndex, int toIndex) {
 650         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 651         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>








 652     }
 653 
 654     /**
 655      * Sorts the specified array into ascending numerical order.
 656      *
 657      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 658      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 659      * value compares neither less than, greater than, nor equal to any value,
 660      * even itself. This method uses the total order imposed by the method
 661      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 662      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 663      * other value and all {@code Double.NaN} values are considered equal.
 664      *
<span class="line-modified"> 665      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 666      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 667      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 668      * faster than traditional (one-pivot) Quicksort implementations.</span>






 669      *
 670      * @param a the array to be sorted
 671      *
 672      * @since 1.8
 673      */
 674     public static void parallelSort(double[] a) {
<span class="line-modified"> 675         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), 0, a.length);</span>








 676     }
 677 
 678     /**
 679      * Sorts the specified range of the array into ascending numerical order.
 680      * The range to be sorted extends from the index {@code fromIndex},
 681      * inclusive, to the index {@code toIndex}, exclusive. If
 682      * {@code fromIndex == toIndex}, the range to be sorted is empty.
 683      *
 684      * &lt;p&gt;The {@code &lt;} relation does not provide a total order on all double
 685      * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}
 686      * value compares neither less than, greater than, nor equal to any value,
 687      * even itself. This method uses the total order imposed by the method
 688      * {@link Double#compareTo}: {@code -0.0d} is treated as less than value
 689      * {@code 0.0d} and {@code Double.NaN} is considered greater than any
 690      * other value and all {@code Double.NaN} values are considered equal.
 691      *
<span class="line-modified"> 692      * @implNote The sorting algorithm is a Dual-Pivot Quicksort by</span>
<span class="line-modified"> 693      * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified"> 694      * offers O(n log(n)) performance on all data sets, and is typically</span>
<span class="line-modified"> 695      * faster than traditional (one-pivot) Quicksort implementations.</span>






 696      *
 697      * @param a the array to be sorted
 698      * @param fromIndex the index of the first element, inclusive, to be sorted
 699      * @param toIndex the index of the last element, exclusive, to be sorted
 700      *
 701      * @throws IllegalArgumentException if {@code fromIndex &gt; toIndex}
 702      * @throws ArrayIndexOutOfBoundsException
 703      *     if {@code fromIndex &lt; 0} or {@code toIndex &gt; a.length}
 704      *
 705      * @since 1.8
 706      */
 707     public static void parallelSort(double[] a, int fromIndex, int toIndex) {
 708         rangeCheck(a.length, fromIndex, toIndex);
<span class="line-modified"> 709         DualPivotQuicksort.sort(a, ForkJoinPool.getCommonPoolParallelism(), fromIndex, toIndex);</span>








 710     }
 711 
<span class="line-added"> 712     /**</span>
<span class="line-added"> 713      * Checks that {@code fromIndex} and {@code toIndex} are in</span>
<span class="line-added"> 714      * the range and throws an exception if they aren&#39;t.</span>
<span class="line-added"> 715      */</span>
<span class="line-added"> 716     static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {</span>
<span class="line-added"> 717         if (fromIndex &gt; toIndex) {</span>
<span class="line-added"> 718             throw new IllegalArgumentException(</span>
<span class="line-added"> 719                 &quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);</span>
<span class="line-added"> 720         }</span>
<span class="line-added"> 721         if (fromIndex &lt; 0) {</span>
<span class="line-added"> 722             throw new ArrayIndexOutOfBoundsException(fromIndex);</span>
<span class="line-added"> 723         }</span>
<span class="line-added"> 724         if (toIndex &gt; arrayLength) {</span>
<span class="line-added"> 725             throw new ArrayIndexOutOfBoundsException(toIndex);</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727     }</span>
<span class="line-added"> 728 </span>
<span class="line-added"> 729     /**</span>
<span class="line-added"> 730      * A comparator that implements the natural ordering of a group of</span>
<span class="line-added"> 731      * mutually comparable elements. May be used when a supplied</span>
<span class="line-added"> 732      * comparator is null. To simplify code-sharing within underlying</span>
<span class="line-added"> 733      * implementations, the compare method only declares type Object</span>
<span class="line-added"> 734      * for its second argument.</span>
<span class="line-added"> 735      *</span>
<span class="line-added"> 736      * Arrays class implementor&#39;s note: It is an empirical matter</span>
<span class="line-added"> 737      * whether ComparableTimSort offers any performance benefit over</span>
<span class="line-added"> 738      * TimSort used with this comparator.  If not, you are better off</span>
<span class="line-added"> 739      * deleting or bypassing ComparableTimSort.  There is currently no</span>
<span class="line-added"> 740      * empirical case for separating them for parallel sorting, so all</span>
<span class="line-added"> 741      * public Object parallelSort methods use the same comparator</span>
<span class="line-added"> 742      * based implementation.</span>
<span class="line-added"> 743      */</span>
<span class="line-added"> 744     static final class NaturalOrder implements Comparator&lt;Object&gt; {</span>
<span class="line-added"> 745         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added"> 746         public int compare(Object first, Object second) {</span>
<span class="line-added"> 747             return ((Comparable&lt;Object&gt;)first).compareTo(second);</span>
<span class="line-added"> 748         }</span>
<span class="line-added"> 749         static final NaturalOrder INSTANCE = new NaturalOrder();</span>
<span class="line-added"> 750     }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     /**</span>
<span class="line-added"> 753      * The minimum array length below which a parallel sorting</span>
<span class="line-added"> 754      * algorithm will not further partition the sorting task. Using</span>
<span class="line-added"> 755      * smaller sizes typically results in memory contention across</span>
<span class="line-added"> 756      * tasks that makes parallel speedups unlikely.</span>
<span class="line-added"> 757      */</span>
<span class="line-added"> 758     private static final int MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13;</span>
<span class="line-added"> 759 </span>
 760     /**
 761      * Sorts the specified array of objects into ascending order, according
 762      * to the {@linkplain Comparable natural ordering} of its elements.
 763      * All elements in the array must implement the {@link Comparable}
 764      * interface.  Furthermore, all elements in the array must be
 765      * &lt;i&gt;mutually comparable&lt;/i&gt; (that is, {@code e1.compareTo(e2)} must
 766      * not throw a {@code ClassCastException} for any elements {@code e1}
 767      * and {@code e2} in the array).
 768      *
 769      * &lt;p&gt;This sort is guaranteed to be &lt;i&gt;stable&lt;/i&gt;:  equal elements will
 770      * not be reordered as a result of the sort.
 771      *
 772      * @implNote The sorting algorithm is a parallel sort-merge that breaks the
 773      * array into sub-arrays that are themselves sorted and then merged. When
 774      * the sub-array length reaches a minimum granularity, the sub-array is
 775      * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}
 776      * method. If the length of the specified array is less than the minimum
 777      * granularity, then it is sorted using the appropriate {@link
 778      * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a
 779      * working space no greater than the size of the original array. The
</pre>
<hr />
<pre>
2372             return false;
2373 
2374         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2375     }
2376 
2377     /**
2378      * Returns true if the two specified arrays of longs, over the specified
2379      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2380      *
2381      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2382      * each range is the same, and all corresponding pairs of elements over the
2383      * specified ranges in the two arrays are equal.  In other words, two arrays
2384      * are equal if they contain, over the specified ranges, the same elements
2385      * in the same order.
2386      *
2387      * @param a the first array to be tested for equality
2388      * @param aFromIndex the index (inclusive) of the first element in the
2389      *                   first array to be tested
2390      * @param aToIndex the index (exclusive) of the last element in the
2391      *                 first array to be tested
<span class="line-modified">2392      * @param b the second array to be tested for equality</span>
2393      * @param bFromIndex the index (inclusive) of the first element in the
2394      *                   second array to be tested
2395      * @param bToIndex the index (exclusive) of the last element in the
2396      *                 second array to be tested
2397      * @return {@code true} if the two arrays, over the specified ranges, are
2398      *         equal
2399      * @throws IllegalArgumentException
2400      *         if {@code aFromIndex &gt; aToIndex} or
2401      *         if {@code bFromIndex &gt; bToIndex}
2402      * @throws ArrayIndexOutOfBoundsException
2403      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2404      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2405      * @throws NullPointerException
2406      *         if either array is {@code null}
2407      * @since 9
2408      */
2409     public static boolean equals(long[] a, int aFromIndex, int aToIndex,
2410                                  long[] b, int bFromIndex, int bToIndex) {
2411         rangeCheck(a.length, aFromIndex, aToIndex);
2412         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2444             return false;
2445 
2446         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2447     }
2448 
2449     /**
2450      * Returns true if the two specified arrays of ints, over the specified
2451      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2452      *
2453      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2454      * each range is the same, and all corresponding pairs of elements over the
2455      * specified ranges in the two arrays are equal.  In other words, two arrays
2456      * are equal if they contain, over the specified ranges, the same elements
2457      * in the same order.
2458      *
2459      * @param a the first array to be tested for equality
2460      * @param aFromIndex the index (inclusive) of the first element in the
2461      *                   first array to be tested
2462      * @param aToIndex the index (exclusive) of the last element in the
2463      *                 first array to be tested
<span class="line-modified">2464      * @param b the second array to be tested for equality</span>
2465      * @param bFromIndex the index (inclusive) of the first element in the
2466      *                   second array to be tested
2467      * @param bToIndex the index (exclusive) of the last element in the
2468      *                 second array to be tested
2469      * @return {@code true} if the two arrays, over the specified ranges, are
2470      *         equal
2471      * @throws IllegalArgumentException
2472      *         if {@code aFromIndex &gt; aToIndex} or
2473      *         if {@code bFromIndex &gt; bToIndex}
2474      * @throws ArrayIndexOutOfBoundsException
2475      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2476      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2477      * @throws NullPointerException
2478      *         if either array is {@code null}
2479      * @since 9
2480      */
2481     public static boolean equals(int[] a, int aFromIndex, int aToIndex,
2482                                  int[] b, int bFromIndex, int bToIndex) {
2483         rangeCheck(a.length, aFromIndex, aToIndex);
2484         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2516             return false;
2517 
2518         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2519     }
2520 
2521     /**
2522      * Returns true if the two specified arrays of shorts, over the specified
2523      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2524      *
2525      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2526      * each range is the same, and all corresponding pairs of elements over the
2527      * specified ranges in the two arrays are equal.  In other words, two arrays
2528      * are equal if they contain, over the specified ranges, the same elements
2529      * in the same order.
2530      *
2531      * @param a the first array to be tested for equality
2532      * @param aFromIndex the index (inclusive) of the first element in the
2533      *                   first array to be tested
2534      * @param aToIndex the index (exclusive) of the last element in the
2535      *                 first array to be tested
<span class="line-modified">2536      * @param b the second array to be tested for equality</span>
2537      * @param bFromIndex the index (inclusive) of the first element in the
2538      *                   second array to be tested
2539      * @param bToIndex the index (exclusive) of the last element in the
2540      *                 second array to be tested
2541      * @return {@code true} if the two arrays, over the specified ranges, are
2542      *         equal
2543      * @throws IllegalArgumentException
2544      *         if {@code aFromIndex &gt; aToIndex} or
2545      *         if {@code bFromIndex &gt; bToIndex}
2546      * @throws ArrayIndexOutOfBoundsException
2547      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2548      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2549      * @throws NullPointerException
2550      *         if either array is {@code null}
2551      * @since 9
2552      */
2553     public static boolean equals(short[] a, int aFromIndex, int aToIndex,
2554                                  short[] b, int bFromIndex, int bToIndex) {
2555         rangeCheck(a.length, aFromIndex, aToIndex);
2556         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2589             return false;
2590 
2591         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2592     }
2593 
2594     /**
2595      * Returns true if the two specified arrays of chars, over the specified
2596      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2597      *
2598      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2599      * each range is the same, and all corresponding pairs of elements over the
2600      * specified ranges in the two arrays are equal.  In other words, two arrays
2601      * are equal if they contain, over the specified ranges, the same elements
2602      * in the same order.
2603      *
2604      * @param a the first array to be tested for equality
2605      * @param aFromIndex the index (inclusive) of the first element in the
2606      *                   first array to be tested
2607      * @param aToIndex the index (exclusive) of the last element in the
2608      *                 first array to be tested
<span class="line-modified">2609      * @param b the second array to be tested for equality</span>
2610      * @param bFromIndex the index (inclusive) of the first element in the
2611      *                   second array to be tested
2612      * @param bToIndex the index (exclusive) of the last element in the
2613      *                 second array to be tested
2614      * @return {@code true} if the two arrays, over the specified ranges, are
2615      *         equal
2616      * @throws IllegalArgumentException
2617      *         if {@code aFromIndex &gt; aToIndex} or
2618      *         if {@code bFromIndex &gt; bToIndex}
2619      * @throws ArrayIndexOutOfBoundsException
2620      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2621      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2622      * @throws NullPointerException
2623      *         if either array is {@code null}
2624      * @since 9
2625      */
2626     public static boolean equals(char[] a, int aFromIndex, int aToIndex,
2627                                  char[] b, int bFromIndex, int bToIndex) {
2628         rangeCheck(a.length, aFromIndex, aToIndex);
2629         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2662             return false;
2663 
2664         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2665     }
2666 
2667     /**
2668      * Returns true if the two specified arrays of bytes, over the specified
2669      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2670      *
2671      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2672      * each range is the same, and all corresponding pairs of elements over the
2673      * specified ranges in the two arrays are equal.  In other words, two arrays
2674      * are equal if they contain, over the specified ranges, the same elements
2675      * in the same order.
2676      *
2677      * @param a the first array to be tested for equality
2678      * @param aFromIndex the index (inclusive) of the first element in the
2679      *                   first array to be tested
2680      * @param aToIndex the index (exclusive) of the last element in the
2681      *                 first array to be tested
<span class="line-modified">2682      * @param b the second array to be tested for equality</span>
2683      * @param bFromIndex the index (inclusive) of the first element in the
2684      *                   second array to be tested
2685      * @param bToIndex the index (exclusive) of the last element in the
2686      *                 second array to be tested
2687      * @return {@code true} if the two arrays, over the specified ranges, are
2688      *         equal
2689      * @throws IllegalArgumentException
2690      *         if {@code aFromIndex &gt; aToIndex} or
2691      *         if {@code bFromIndex &gt; bToIndex}
2692      * @throws ArrayIndexOutOfBoundsException
2693      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2694      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2695      * @throws NullPointerException
2696      *         if either array is {@code null}
2697      * @since 9
2698      */
2699     public static boolean equals(byte[] a, int aFromIndex, int aToIndex,
2700                                  byte[] b, int bFromIndex, int bToIndex) {
2701         rangeCheck(a.length, aFromIndex, aToIndex);
2702         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2734             return false;
2735 
2736         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2737     }
2738 
2739     /**
2740      * Returns true if the two specified arrays of booleans, over the specified
2741      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2742      *
2743      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2744      * each range is the same, and all corresponding pairs of elements over the
2745      * specified ranges in the two arrays are equal.  In other words, two arrays
2746      * are equal if they contain, over the specified ranges, the same elements
2747      * in the same order.
2748      *
2749      * @param a the first array to be tested for equality
2750      * @param aFromIndex the index (inclusive) of the first element in the
2751      *                   first array to be tested
2752      * @param aToIndex the index (exclusive) of the last element in the
2753      *                 first array to be tested
<span class="line-modified">2754      * @param b the second array to be tested for equality</span>
2755      * @param bFromIndex the index (inclusive) of the first element in the
2756      *                   second array to be tested
2757      * @param bToIndex the index (exclusive) of the last element in the
2758      *                 second array to be tested
2759      * @return {@code true} if the two arrays, over the specified ranges, are
2760      *         equal
2761      * @throws IllegalArgumentException
2762      *         if {@code aFromIndex &gt; aToIndex} or
2763      *         if {@code bFromIndex &gt; bToIndex}
2764      * @throws ArrayIndexOutOfBoundsException
2765      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2766      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2767      * @throws NullPointerException
2768      *         if either array is {@code null}
2769      * @since 9
2770      */
2771     public static boolean equals(boolean[] a, int aFromIndex, int aToIndex,
2772                                  boolean[] b, int bFromIndex, int bToIndex) {
2773         rangeCheck(a.length, aFromIndex, aToIndex);
2774         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
2817     /**
2818      * Returns true if the two specified arrays of doubles, over the specified
2819      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2820      *
2821      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2822      * each range is the same, and all corresponding pairs of elements over the
2823      * specified ranges in the two arrays are equal.  In other words, two arrays
2824      * are equal if they contain, over the specified ranges, the same elements
2825      * in the same order.
2826      *
2827      * &lt;p&gt;Two doubles {@code d1} and {@code d2} are considered equal if:
2828      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
2829      * (Unlike the {@code ==} operator, this method considers
2830      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)
2831      *
2832      * @param a the first array to be tested for equality
2833      * @param aFromIndex the index (inclusive) of the first element in the
2834      *                   first array to be tested
2835      * @param aToIndex the index (exclusive) of the last element in the
2836      *                 first array to be tested
<span class="line-modified">2837      * @param b the second array to be tested for equality</span>
2838      * @param bFromIndex the index (inclusive) of the first element in the
2839      *                   second array to be tested
2840      * @param bToIndex the index (exclusive) of the last element in the
2841      *                 second array to be tested
2842      * @return {@code true} if the two arrays, over the specified ranges, are
2843      *         equal
2844      * @throws IllegalArgumentException
2845      *         if {@code aFromIndex &gt; aToIndex} or
2846      *         if {@code bFromIndex &gt; bToIndex}
2847      * @throws ArrayIndexOutOfBoundsException
2848      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2849      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2850      * @throws NullPointerException
2851      *         if either array is {@code null}
2852      * @see Double#equals(Object)
2853      * @since 9
2854      */
2855     public static boolean equals(double[] a, int aFromIndex, int aToIndex,
2856                                  double[] b, int bFromIndex, int bToIndex) {
2857         rangeCheck(a.length, aFromIndex, aToIndex);
</pre>
<hr />
<pre>
2900     /**
2901      * Returns true if the two specified arrays of floats, over the specified
2902      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2903      *
2904      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2905      * each range is the same, and all corresponding pairs of elements over the
2906      * specified ranges in the two arrays are equal.  In other words, two arrays
2907      * are equal if they contain, over the specified ranges, the same elements
2908      * in the same order.
2909      *
2910      * &lt;p&gt;Two floats {@code f1} and {@code f2} are considered equal if:
2911      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
2912      * (Unlike the {@code ==} operator, this method considers
2913      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)
2914      *
2915      * @param a the first array to be tested for equality
2916      * @param aFromIndex the index (inclusive) of the first element in the
2917      *                   first array to be tested
2918      * @param aToIndex the index (exclusive) of the last element in the
2919      *                 first array to be tested
<span class="line-modified">2920      * @param b the second array to be tested for equality</span>
2921      * @param bFromIndex the index (inclusive) of the first element in the
2922      *                   second array to be tested
2923      * @param bToIndex the index (exclusive) of the last element in the
2924      *                 second array to be tested
2925      * @return {@code true} if the two arrays, over the specified ranges, are
2926      *         equal
2927      * @throws IllegalArgumentException
2928      *         if {@code aFromIndex &gt; aToIndex} or
2929      *         if {@code bFromIndex &gt; bToIndex}
2930      * @throws ArrayIndexOutOfBoundsException
2931      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2932      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2933      * @throws NullPointerException
2934      *         if either array is {@code null}
2935      * @see Float#equals(Object)
2936      * @since 9
2937      */
2938     public static boolean equals(float[] a, int aFromIndex, int aToIndex,
2939                                  float[] b, int bFromIndex, int bToIndex) {
2940         rangeCheck(a.length, aFromIndex, aToIndex);
</pre>
<hr />
<pre>
2983     }
2984 
2985     /**
2986      * Returns true if the two specified arrays of Objects, over the specified
2987      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2988      *
2989      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2990      * each range is the same, and all corresponding pairs of elements over the
2991      * specified ranges in the two arrays are equal.  In other words, two arrays
2992      * are equal if they contain, over the specified ranges, the same elements
2993      * in the same order.
2994      *
2995      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if
2996      * {@code Objects.equals(e1, e2)}.
2997      *
2998      * @param a the first array to be tested for equality
2999      * @param aFromIndex the index (inclusive) of the first element in the
3000      *                   first array to be tested
3001      * @param aToIndex the index (exclusive) of the last element in the
3002      *                 first array to be tested
<span class="line-modified">3003      * @param b the second array to be tested for equality</span>
3004      * @param bFromIndex the index (inclusive) of the first element in the
3005      *                   second array to be tested
3006      * @param bToIndex the index (exclusive) of the last element in the
3007      *                 second array to be tested
3008      * @return {@code true} if the two arrays, over the specified ranges, are
3009      *         equal
3010      * @throws IllegalArgumentException
3011      *         if {@code aFromIndex &gt; aToIndex} or
3012      *         if {@code bFromIndex &gt; bToIndex}
3013      * @throws ArrayIndexOutOfBoundsException
3014      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3015      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3016      * @throws NullPointerException
3017      *         if either array is {@code null}
3018      * @since 9
3019      */
3020     public static boolean equals(Object[] a, int aFromIndex, int aToIndex,
3021                                  Object[] b, int bFromIndex, int bToIndex) {
3022         rangeCheck(a.length, aFromIndex, aToIndex);
3023         rangeCheck(b.length, bFromIndex, bToIndex);
</pre>
<hr />
<pre>
3076     }
3077 
3078     /**
3079      * Returns true if the two specified arrays of Objects, over the specified
3080      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
3081      *
3082      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
3083      * each range is the same, and all corresponding pairs of elements over the
3084      * specified ranges in the two arrays are equal.  In other words, two arrays
3085      * are equal if they contain, over the specified ranges, the same elements
3086      * in the same order.
3087      *
3088      * &lt;p&gt;Two objects {@code e1} and {@code e2} are considered &lt;i&gt;equal&lt;/i&gt; if,
3089      * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.
3090      *
3091      * @param a the first array to be tested for equality
3092      * @param aFromIndex the index (inclusive) of the first element in the
3093      *                   first array to be tested
3094      * @param aToIndex the index (exclusive) of the last element in the
3095      *                 first array to be tested
<span class="line-modified">3096      * @param b the second array to be tested for equality</span>
3097      * @param bFromIndex the index (inclusive) of the first element in the
3098      *                   second array to be tested
3099      * @param bToIndex the index (exclusive) of the last element in the
3100      *                 second array to be tested
3101      * @param cmp the comparator to compare array elements
3102      * @param &lt;T&gt; the type of array elements
3103      * @return {@code true} if the two arrays, over the specified ranges, are
3104      *         equal
3105      * @throws IllegalArgumentException
3106      *         if {@code aFromIndex &gt; aToIndex} or
3107      *         if {@code bFromIndex &gt; bToIndex}
3108      * @throws ArrayIndexOutOfBoundsException
3109      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
3110      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
3111      * @throws NullPointerException
3112      *         if either array or the comparator is {@code null}
3113      * @since 9
3114      */
3115     public static &lt;T&gt; boolean equals(T[] a, int aFromIndex, int aToIndex,
3116                                      T[] b, int bFromIndex, int bToIndex,
</pre>
<hr />
<pre>
4110      * {@link Collections#unmodifiableList Collections.unmodifiableList}
4111      * or &lt;a href=&quot;List.html#unmodifiable&quot;&gt;Unmodifiable Lists&lt;/a&gt;.
4112      *
4113      * @param &lt;T&gt; the class of the objects in the array
4114      * @param a the array by which the list will be backed
4115      * @return a list view of the specified array
4116      * @throws NullPointerException if the specified array is {@code null}
4117      */
4118     @SafeVarargs
4119     @SuppressWarnings(&quot;varargs&quot;)
4120     public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
4121         return new ArrayList&lt;&gt;(a);
4122     }
4123 
4124     /**
4125      * @serial include
4126      */
4127     private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
4128         implements RandomAccess, java.io.Serializable
4129     {
<span class="line-added">4130         @java.io.Serial</span>
4131         private static final long serialVersionUID = -2764017481108945198L;
<span class="line-added">4132         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4133         private final E[] a;
4134 
4135         ArrayList(E[] array) {
4136             a = Objects.requireNonNull(array);
4137         }
4138 
4139         @Override
4140         public int size() {
4141             return a.length;
4142         }
4143 
4144         @Override
4145         public Object[] toArray() {
4146             return Arrays.copyOf(a, a.length, Object[].class);
4147         }
4148 
4149         @Override
4150         @SuppressWarnings(&quot;unchecked&quot;)
4151         public &lt;T&gt; T[] toArray(T[] a) {
4152             int size = size();
</pre>
<hr />
<pre>
7100     // Compare objects
7101 
7102     /**
7103      * Compares two {@code Object} arrays, within comparable elements,
7104      * lexicographically.
7105      *
7106      * &lt;p&gt;If the two arrays share a common prefix then the lexicographic
7107      * comparison is the result of comparing two elements of type {@code T} at
7108      * an index {@code i} within the respective arrays that is the prefix
7109      * length, as if by:
7110      * &lt;pre&gt;{@code
7111      *     Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
7112      *         compare(a[i], b[i])
7113      * }&lt;/pre&gt;
7114      * Otherwise, one array is a proper prefix of the other and, lexicographic
7115      * comparison is the result of comparing the two array lengths.
7116      * (See {@link #mismatch(Object[], Object[])} for the definition of a common
7117      * and proper prefix.)
7118      *
7119      * &lt;p&gt;A {@code null} array reference is considered lexicographically less
<span class="line-modified">7120      * than a non-{@code null} array reference. Two {@code null} array</span>
7121      * references are considered equal.
<span class="line-modified">7122      * A {@code null} array element is considered lexicographically less than a</span>
<span class="line-modified">7123      * non-{@code null} array element. Two {@code null} array elements are</span>
7124      * considered equal.
7125      *
7126      * &lt;p&gt;The comparison is consistent with {@link #equals(Object[], Object[]) equals},
7127      * more specifically the following holds for arrays {@code a} and {@code b}:
7128      * &lt;pre&gt;{@code
7129      *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)
7130      * }&lt;/pre&gt;
7131      *
7132      * @apiNote
7133      * &lt;p&gt;This method behaves as if (for non-{@code null} array references
7134      * and elements):
7135      * &lt;pre&gt;{@code
7136      *     int i = Arrays.mismatch(a, b);
7137      *     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
7138      *         return a[i].compareTo(b[i]);
7139      *     return a.length - b.length;
7140      * }&lt;/pre&gt;
7141      *
7142      * @param a the first array to compare
7143      * @param b the second array to compare
</pre>
</td>
</tr>
</table>
<center><a href="ArrayPrefixHelpers.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ArraysParallelSortHelpers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
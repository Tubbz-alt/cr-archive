<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/net/SocksSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.io.OutputStream;
 30 import java.io.BufferedOutputStream;
 31 import java.nio.charset.StandardCharsets;
 32 import java.security.AccessController;
 33 import java.util.Iterator;
 34 
 35 import jdk.internal.util.StaticProperty;
 36 import sun.net.SocksProxy;
 37 import sun.net.spi.DefaultProxySelector;
 38 import sun.net.www.ParseUtil;
 39 
 40 /**
 41  * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
 42  */
 43 
 44 class SocksSocketImpl extends DelegatingSocketImpl implements SocksConsts {
 45     private String server = null;
 46     private int serverPort = DEFAULT_PORT;
 47     private InetSocketAddress external_address;
 48     private boolean useV4 = false;
 49     private Socket cmdsock = null;
 50     private InputStream cmdIn = null;
 51     private OutputStream cmdOut = null;
 52 
 53     SocksSocketImpl(SocketImpl delegate) {
 54         super(delegate);
 55     }
 56 
 57     SocksSocketImpl(Proxy proxy, SocketImpl delegate) {
 58         super(delegate);
 59         SocketAddress a = proxy.address();
 60         if (a instanceof InetSocketAddress) {
 61             InetSocketAddress ad = (InetSocketAddress) a;
 62             // Use getHostString() to avoid reverse lookups
 63             server = ad.getHostString();
 64             serverPort = ad.getPort();
 65         }
 66         useV4 = useV4(proxy);
 67     }
 68 
 69     private static boolean useV4(Proxy proxy) {
 70         if (proxy instanceof SocksProxy
 71             &amp;&amp; ((SocksProxy)proxy).protocolVersion() == 4) {
 72             return true;
 73         }
 74         return DefaultProxySelector.socksProxyVersion() == 4;
 75     }
 76 
 77     private synchronized void privilegedConnect(final String host,
 78                                               final int port,
 79                                               final int timeout)
 80         throws IOException
 81     {
 82         try {
 83             AccessController.doPrivileged(
 84                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
 85                     public Void run() throws IOException {
 86                               superConnectServer(host, port, timeout);
 87                               cmdIn = getInputStream();
 88                               cmdOut = getOutputStream();
 89                               return null;
 90                           }
 91                       });
 92         } catch (java.security.PrivilegedActionException pae) {
 93             throw (IOException) pae.getException();
 94         }
 95     }
 96 
 97     private void superConnectServer(String host, int port,
 98                                     int timeout) throws IOException {
 99         delegate.connect(new InetSocketAddress(host, port), timeout);
100     }
101 
102     private static int remainingMillis(long deadlineMillis) throws IOException {
103         if (deadlineMillis == 0L)
104             return 0;
105 
106         final long remaining = deadlineMillis - System.currentTimeMillis();
107         if (remaining &gt; 0)
108             return (int) remaining;
109 
110         throw new SocketTimeoutException();
111     }
112 
113     private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
114         int len = data.length;
115         int received = 0;
116         int originalTimeout = (int) getOption(SocketOptions.SO_TIMEOUT);
117         try {
118             while (received &lt; len) {
119                 int count;
120                 int remaining = remainingMillis(deadlineMillis);
121                 setOption(SocketOptions.SO_TIMEOUT, remaining);
122                 try {
123                     count = in.read(data, received, len - received);
124                 } catch (SocketTimeoutException e) {
125                     throw new SocketTimeoutException(&quot;Connect timed out&quot;);
126                 }
127                 if (count &lt; 0)
128                     throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);
129                 received += count;
130             }
131         } finally {
132             setOption(SocketOptions.SO_TIMEOUT, originalTimeout);
133         }
134         return received;
135     }
136 
137     private boolean authenticate(byte method, InputStream in,
138                                  BufferedOutputStream out,
139                                  long deadlineMillis) throws IOException {
140         // No Authentication required. We&#39;re done then!
141         if (method == NO_AUTH)
142             return true;
143         /*
144          * User/Password authentication. Try, in that order :
145          * - The application provided Authenticator, if any
146          * - the user.name &amp; no password (backward compatibility behavior).
147          */
148         if (method == USER_PASSW) {
149             String userName;
150             String password = null;
151             final InetAddress addr = InetAddress.getByName(server);
152             PasswordAuthentication pw =
153                 java.security.AccessController.doPrivileged(
154                     new java.security.PrivilegedAction&lt;&gt;() {
155                         public PasswordAuthentication run() {
156                                 return Authenticator.requestPasswordAuthentication(
157                                        server, addr, serverPort, &quot;SOCKS5&quot;, &quot;SOCKS authentication&quot;, null);
158                             }
159                         });
160             if (pw != null) {
161                 userName = pw.getUserName();
162                 password = new String(pw.getPassword());
163             } else {
164                 userName = StaticProperty.userName();
165             }
166             if (userName == null)
167                 return false;
168             out.write(1);
169             out.write(userName.length());
170             out.write(userName.getBytes(StandardCharsets.ISO_8859_1));
171             if (password != null) {
172                 out.write(password.length());
173                 out.write(password.getBytes(StandardCharsets.ISO_8859_1));
174             } else
175                 out.write(0);
176             out.flush();
177             byte[] data = new byte[2];
178             int i = readSocksReply(in, data, deadlineMillis);
179             if (i != 2 || data[1] != 0) {
180                 /* RFC 1929 specifies that the connection MUST be closed if
181                    authentication fails */
182                 out.close();
183                 in.close();
184                 return false;
185             }
186             /* Authentication succeeded */
187             return true;
188         }
189         return false;
190     }
191 
192     private void connectV4(InputStream in, OutputStream out,
193                            InetSocketAddress endpoint,
194                            long deadlineMillis) throws IOException {
195         if (!(endpoint.getAddress() instanceof Inet4Address)) {
196             throw new SocketException(&quot;SOCKS V4 requires IPv4 only addresses&quot;);
197         }
198         out.write(PROTO_VERS4);
199         out.write(CONNECT);
200         out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
201         out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
202         out.write(endpoint.getAddress().getAddress());
203         String userName = getUserName();
204         out.write(userName.getBytes(StandardCharsets.ISO_8859_1));
205         out.write(0);
206         out.flush();
207         byte[] data = new byte[8];
208         int n = readSocksReply(in, data, deadlineMillis);
209         if (n != 8)
210             throw new SocketException(&quot;Reply from SOCKS server has bad length: &quot; + n);
211         if (data[0] != 0 &amp;&amp; data[0] != 4)
212             throw new SocketException(&quot;Reply from SOCKS server has bad version&quot;);
213         SocketException ex = null;
214         switch (data[1]) {
215         case 90:
216             // Success!
217             external_address = endpoint;
218             break;
219         case 91:
220             ex = new SocketException(&quot;SOCKS request rejected&quot;);
221             break;
222         case 92:
223             ex = new SocketException(&quot;SOCKS server couldn&#39;t reach destination&quot;);
224             break;
225         case 93:
226             ex = new SocketException(&quot;SOCKS authentication failed&quot;);
227             break;
228         default:
229             ex = new SocketException(&quot;Reply from SOCKS server contains bad status&quot;);
230             break;
231         }
232         if (ex != null) {
233             in.close();
234             out.close();
235             throw ex;
236         }
237     }
238 
239     @Override
240     protected void connect(String host, int port) throws IOException {
241         connect(new InetSocketAddress(host, port), 0);
242     }
243 
244     @Override
245     protected void connect(InetAddress address, int port) throws IOException {
246         connect(new InetSocketAddress(address, port), 0);
247     }
248 
249     /**
250      * Connects the Socks Socket to the specified endpoint. It will first
251      * connect to the SOCKS proxy and negotiate the access. If the proxy
252      * grants the connections, then the connect is successful and all
253      * further traffic will go to the &quot;real&quot; endpoint.
254      *
255      * @param   endpoint        the {@code SocketAddress} to connect to.
256      * @param   timeout         the timeout value in milliseconds
257      * @throws  IOException     if the connection can&#39;t be established.
258      * @throws  SecurityException if there is a security manager and it
259      *                          doesn&#39;t allow the connection
260      * @throws  IllegalArgumentException if endpoint is null or a
261      *          SocketAddress subclass not supported by this socket
262      */
263     @Override
264     protected void connect(SocketAddress endpoint, int timeout) throws IOException {
265         final long deadlineMillis;
266 
267         if (timeout == 0) {
268             deadlineMillis = 0L;
269         } else {
270             long finish = System.currentTimeMillis() + timeout;
271             deadlineMillis = finish &lt; 0 ? Long.MAX_VALUE : finish;
272         }
273 
274         SecurityManager security = System.getSecurityManager();
275         if (endpoint == null || !(endpoint instanceof InetSocketAddress))
276             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
277         InetSocketAddress epoint = (InetSocketAddress) endpoint;
278         if (security != null) {
279             if (epoint.isUnresolved())
280                 security.checkConnect(epoint.getHostName(),
281                                       epoint.getPort());
282             else
283                 security.checkConnect(epoint.getAddress().getHostAddress(),
284                                       epoint.getPort());
285         }
286         if (server == null) {
287             // This is the general case
288             // server is not null only when the socket was created with a
289             // specified proxy in which case it does bypass the ProxySelector
290             ProxySelector sel = java.security.AccessController.doPrivileged(
291                 new java.security.PrivilegedAction&lt;&gt;() {
292                     public ProxySelector run() {
293                             return ProxySelector.getDefault();
294                         }
295                     });
296             if (sel == null) {
297                 /*
298                  * No default proxySelector --&gt; direct connection
299                  */
300                 delegate.connect(epoint, remainingMillis(deadlineMillis));
301                 return;
302             }
303             URI uri;
304             // Use getHostString() to avoid reverse lookups
305             String host = epoint.getHostString();
306             // IPv6 literal?
307             if (epoint.getAddress() instanceof Inet6Address &amp;&amp;
308                 (!host.startsWith(&quot;[&quot;)) &amp;&amp; (host.indexOf(&#39;:&#39;) &gt;= 0)) {
309                 host = &quot;[&quot; + host + &quot;]&quot;;
310             }
311             try {
312                 uri = new URI(&quot;socket://&quot; + ParseUtil.encodePath(host) + &quot;:&quot;+ epoint.getPort());
313             } catch (URISyntaxException e) {
314                 // This shouldn&#39;t happen
315                 assert false : e;
316                 uri = null;
317             }
318             Proxy p = null;
319             IOException savedExc = null;
320             final Iterator&lt;Proxy&gt; iProxy;
321             try {
322                 iProxy = sel.select(uri).iterator();
323             } catch (IllegalArgumentException iae) {
324                 throw new IOException(&quot;Failed to select a proxy&quot;, iae);
325             }
326             if (iProxy == null || !(iProxy.hasNext())) {
327                 delegate.connect(epoint, remainingMillis(deadlineMillis));
328                 return;
329             }
330             while (iProxy.hasNext()) {
331                 p = iProxy.next();
332                 if (p == null || p.type() != Proxy.Type.SOCKS) {
333                     delegate.connect(epoint, remainingMillis(deadlineMillis));
334                     return;
335                 }
336 
337                 if (!(p.address() instanceof InetSocketAddress))
338                     throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
339                 // Use getHostString() to avoid reverse lookups
340                 server = ((InetSocketAddress) p.address()).getHostString();
341                 serverPort = ((InetSocketAddress) p.address()).getPort();
342                 useV4 = useV4(p);
343 
344                 // Connects to the SOCKS server
345                 try {
346                     privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
347                     // Worked, let&#39;s get outta here
348                     break;
349                 } catch (IOException e) {
350                     // Ooops, let&#39;s notify the ProxySelector
351                     sel.connectFailed(uri,p.address(),e);
352                     server = null;
353                     serverPort = -1;
354                     savedExc = e;
355                     // Will continue the while loop and try the next proxy
356                 }
357             }
358 
359             /*
360              * If server is still null at this point, none of the proxy
361              * worked
362              */
363             if (server == null) {
364                 throw new SocketException(&quot;Can&#39;t connect to SOCKS proxy:&quot;
365                                           + savedExc.getMessage());
366             }
367         } else {
368             // Connects to the SOCKS server
369             try {
370                 privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
371             } catch (IOException e) {
372                 throw new SocketException(e.getMessage());
373             }
374         }
375 
376         // cmdIn &amp; cmdOut were initialized during the privilegedConnect() call
377         BufferedOutputStream out = new BufferedOutputStream(cmdOut, 512);
378         InputStream in = cmdIn;
379 
380         if (useV4) {
381             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
382             // DOMAIN type of addresses (unresolved addresses here)
383             if (epoint.isUnresolved())
384                 throw new UnknownHostException(epoint.toString());
385             connectV4(in, out, epoint, deadlineMillis);
386             return;
387         }
388 
389         // This is SOCKS V5
390         out.write(PROTO_VERS);
391         out.write(2);
392         out.write(NO_AUTH);
393         out.write(USER_PASSW);
394         out.flush();
395         byte[] data = new byte[2];
396         int i = readSocksReply(in, data, deadlineMillis);
397         if (i != 2 || ((int)data[0]) != PROTO_VERS) {
398             // Maybe it&#39;s not a V5 sever after all
399             // Let&#39;s try V4 before we give up
400             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
401             // DOMAIN type of addresses (unresolved addresses here)
402             if (epoint.isUnresolved())
403                 throw new UnknownHostException(epoint.toString());
404             connectV4(in, out, epoint, deadlineMillis);
405             return;
406         }
407         if (((int)data[1]) == NO_METHODS)
408             throw new SocketException(&quot;SOCKS : No acceptable methods&quot;);
409         if (!authenticate(data[1], in, out, deadlineMillis)) {
410             throw new SocketException(&quot;SOCKS : authentication failed&quot;);
411         }
412         out.write(PROTO_VERS);
413         out.write(CONNECT);
414         out.write(0);
415         /* Test for IPV4/IPV6/Unresolved */
416         if (epoint.isUnresolved()) {
417             out.write(DOMAIN_NAME);
418             out.write(epoint.getHostName().length());
419             out.write(epoint.getHostName().getBytes(StandardCharsets.ISO_8859_1));
420             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
421             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
422         } else if (epoint.getAddress() instanceof Inet6Address) {
423             out.write(IPV6);
424             out.write(epoint.getAddress().getAddress());
425             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
426             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
427         } else {
428             out.write(IPV4);
429             out.write(epoint.getAddress().getAddress());
430             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
431             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
432         }
433         out.flush();
434         data = new byte[4];
435         i = readSocksReply(in, data, deadlineMillis);
436         if (i != 4)
437             throw new SocketException(&quot;Reply from SOCKS server has bad length&quot;);
438         SocketException ex = null;
439         int len;
440         byte[] addr;
441         switch (data[1]) {
442         case REQUEST_OK:
443             // success!
444             switch(data[3]) {
445             case IPV4:
446                 addr = new byte[4];
447                 i = readSocksReply(in, addr, deadlineMillis);
448                 if (i != 4)
449                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
450                 data = new byte[2];
451                 i = readSocksReply(in, data, deadlineMillis);
452                 if (i != 2)
453                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
454                 break;
455             case DOMAIN_NAME:
456                 byte[] lenByte = new byte[1];
457                 i = readSocksReply(in, lenByte, deadlineMillis);
458                 if (i != 1)
459                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
460                 len = lenByte[0] &amp; 0xFF;
461                 byte[] host = new byte[len];
462                 i = readSocksReply(in, host, deadlineMillis);
463                 if (i != len)
464                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
465                 data = new byte[2];
466                 i = readSocksReply(in, data, deadlineMillis);
467                 if (i != 2)
468                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
469                 break;
470             case IPV6:
471                 len = 16;
472                 addr = new byte[len];
473                 i = readSocksReply(in, addr, deadlineMillis);
474                 if (i != len)
475                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
476                 data = new byte[2];
477                 i = readSocksReply(in, data, deadlineMillis);
478                 if (i != 2)
479                     throw new SocketException(&quot;Reply from SOCKS server badly formatted&quot;);
480                 break;
481             default:
482                 ex = new SocketException(&quot;Reply from SOCKS server contains wrong code&quot;);
483                 break;
484             }
485             break;
486         case GENERAL_FAILURE:
487             ex = new SocketException(&quot;SOCKS server general failure&quot;);
488             break;
489         case NOT_ALLOWED:
490             ex = new SocketException(&quot;SOCKS: Connection not allowed by ruleset&quot;);
491             break;
492         case NET_UNREACHABLE:
493             ex = new SocketException(&quot;SOCKS: Network unreachable&quot;);
494             break;
495         case HOST_UNREACHABLE:
496             ex = new SocketException(&quot;SOCKS: Host unreachable&quot;);
497             break;
498         case CONN_REFUSED:
499             ex = new SocketException(&quot;SOCKS: Connection refused&quot;);
500             break;
501         case TTL_EXPIRED:
502             ex =  new SocketException(&quot;SOCKS: TTL expired&quot;);
503             break;
504         case CMD_NOT_SUPPORTED:
505             ex = new SocketException(&quot;SOCKS: Command not supported&quot;);
506             break;
507         case ADDR_TYPE_NOT_SUP:
508             ex = new SocketException(&quot;SOCKS: address type not supported&quot;);
509             break;
510         }
511         if (ex != null) {
512             in.close();
513             out.close();
514             throw ex;
515         }
516         external_address = epoint;
517     }
518 
519     @Override
520     protected void listen(int backlog) {
521         throw new InternalError(&quot;should not get here&quot;);
522     }
523 
524     @Override
525     protected void accept(SocketImpl s) {
526         throw new InternalError(&quot;should not get here&quot;);
527     }
528 
529     /**
530      * Returns the value of this socket&#39;s {@code address} field.
531      *
532      * @return  the value of this socket&#39;s {@code address} field.
533      * @see     java.net.SocketImpl#address
534      */
535     @Override
536     protected InetAddress getInetAddress() {
537         if (external_address != null)
538             return external_address.getAddress();
539         else
540             return delegate.getInetAddress();
541     }
542 
543     /**
544      * Returns the value of this socket&#39;s {@code port} field.
545      *
546      * @return  the value of this socket&#39;s {@code port} field.
547      * @see     java.net.SocketImpl#port
548      */
549     @Override
550     protected int getPort() {
551         if (external_address != null)
552             return external_address.getPort();
553         else
554             return delegate.getPort();
555     }
556 
557     @Override
558     protected void close() throws IOException {
559         if (cmdsock != null)
560             cmdsock.close();
561         cmdsock = null;
562         delegate.close();
563     }
564 
565     private String getUserName() {
566         return StaticProperty.userName();
567     }
568 
569     @Override
570     void reset() {
571         throw new InternalError(&quot;should not get here&quot;);
572     }
573 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Throwable.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadGroup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TypeNotPresentException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Throwable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
<span class="line-modified">  28 import  java.io.*;</span>
<span class="line-modified">  29 import  java.util.*;</span>
  30 
  31 /**
  32  * The {@code Throwable} class is the superclass of all errors and
  33  * exceptions in the Java language. Only objects that are instances of this
  34  * class (or one of its subclasses) are thrown by the Java Virtual Machine or
  35  * can be thrown by the Java {@code throw} statement. Similarly, only
  36  * this class or one of its subclasses can be the argument type in a
  37  * {@code catch} clause.
  38  *
  39  * For the purposes of compile-time checking of exceptions, {@code
  40  * Throwable} and any subclass of {@code Throwable} that is not also a
  41  * subclass of either {@link RuntimeException} or {@link Error} are
  42  * regarded as checked exceptions.
  43  *
  44  * &lt;p&gt;Instances of two subclasses, {@link java.lang.Error} and
  45  * {@link java.lang.Exception}, are conventionally used to indicate
  46  * that exceptional situations have occurred. Typically, these instances
  47  * are freshly created in the context of the exceptional situation so
  48  * as to include relevant information (such as stack trace data).
  49  *
</pre>
<hr />
<pre>
  97  * implementation predates the addition of the exception chaining mechanism to
  98  * {@code Throwable}.
  99  *
 100  * &lt;p&gt;By convention, class {@code Throwable} and its subclasses have two
 101  * constructors, one that takes no arguments and one that takes a
 102  * {@code String} argument that can be used to produce a detail message.
 103  * Further, those subclasses that might likely have a cause associated with
 104  * them should have two more constructors, one that takes a
 105  * {@code Throwable} (the cause), and one that takes a
 106  * {@code String} (the detail message) and a {@code Throwable} (the
 107  * cause).
 108  *
 109  * @author  unascribed
 110  * @author  Josh Bloch (Added exception chaining and programmatic access to
 111  *          stack trace in 1.4.)
 112  * @jls 11.2 Compile-Time Checking of Exceptions
 113  * @since 1.0
 114  */
 115 public class Throwable implements Serializable {
 116     /** use serialVersionUID from JDK 1.0.2 for interoperability */

 117     private static final long serialVersionUID = -3042686055658047285L;
 118 
 119     /**
 120      * The JVM saves some indication of the stack backtrace in this slot.
 121      */
 122     private transient Object backtrace;
 123 
 124     /**
 125      * Specific details about the Throwable.  For example, for
 126      * {@code FileNotFoundException}, this contains the name of
 127      * the file that could not be found.
 128      *
 129      * @serial
 130      */
 131     private String detailMessage;
 132 
 133 
 134     /**
 135      * Holder class to defer initializing sentinel objects only used
 136      * for serialization.
</pre>
<hr />
<pre>
 212 
 213     /**
 214      * The JVM code sets the depth of the backtrace for later retrieval
 215      */
 216     private transient int depth;
 217 
 218     // Setting this static field introduces an acceptable
 219     // initialization dependency on a few java.util classes.
 220     private static final List&lt;Throwable&gt; SUPPRESSED_SENTINEL = Collections.emptyList();
 221 
 222     /**
 223      * The list of suppressed exceptions, as returned by {@link
 224      * #getSuppressed()}.  The list is initialized to a zero-element
 225      * unmodifiable sentinel list.  When a serialized Throwable is
 226      * read in, if the {@code suppressedExceptions} field points to a
 227      * zero-element list, the field is reset to the sentinel value.
 228      *
 229      * @serial
 230      * @since 1.7
 231      */

 232     private List&lt;Throwable&gt; suppressedExceptions = SUPPRESSED_SENTINEL;
 233 
 234     /** Message for trying to suppress a null exception. */
 235     private static final String NULL_CAUSE_MESSAGE = &quot;Cannot suppress a null exception.&quot;;
 236 
 237     /** Message for trying to suppress oneself. */
 238     private static final String SELF_SUPPRESSION_MESSAGE = &quot;Self-suppression not permitted&quot;;
 239 
 240     /** Caption  for labeling causative exception stack traces */
 241     private static final String CAUSE_CAPTION = &quot;Caused by: &quot;;
 242 
 243     /** Caption for labeling suppressed exception stack traces */
 244     private static final String SUPPRESSED_CAPTION = &quot;Suppressed: &quot;;
 245 
 246     /**
 247      * Constructs a new throwable with {@code null} as its detail message.
 248      * The cause is not initialized, and may subsequently be initialized by a
 249      * call to {@link #initCause}.
 250      *
 251      * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
</pre>
<hr />
<pre>
 676                 se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);
 677 
 678             // Print cause, if any
 679             Throwable ourCause = getCause();
 680             if (ourCause != null)
 681                 ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);
 682         }
 683     }
 684 
 685     /**
 686      * Print our stack trace as an enclosed exception for the specified
 687      * stack trace.
 688      */
 689     private void printEnclosedStackTrace(PrintStreamOrWriter s,
 690                                          StackTraceElement[] enclosingTrace,
 691                                          String caption,
 692                                          String prefix,
 693                                          Set&lt;Throwable&gt; dejaVu) {
 694         assert Thread.holdsLock(s.lock());
 695         if (dejaVu.contains(this)) {
<span class="line-modified"> 696             s.println(&quot;\t[CIRCULAR REFERENCE:&quot; + this + &quot;]&quot;);</span>
 697         } else {
 698             dejaVu.add(this);
 699             // Compute number of frames in common between this and enclosing trace
 700             StackTraceElement[] trace = getOurStackTrace();
 701             int m = trace.length - 1;
 702             int n = enclosingTrace.length - 1;
 703             while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(enclosingTrace[n])) {
 704                 m--; n--;
 705             }
 706             int framesInCommon = trace.length - 1 - m;
 707 
 708             // Print our stack trace
 709             s.println(prefix + caption + this);
 710             for (int i = 0; i &lt;= m; i++)
 711                 s.println(prefix + &quot;\tat &quot; + trace[i]);
 712             if (framesInCommon != 0)
 713                 s.println(prefix + &quot;\t... &quot; + framesInCommon + &quot; more&quot;);
 714 
 715             // Print suppressed exceptions, if any
 716             for (Throwable se : getSuppressed())
</pre>
<hr />
<pre>
 884                 return;
 885             this.stackTrace = defensiveCopy;
 886         }
 887     }
 888 
 889     /**
 890      * Reads a {@code Throwable} from a stream, enforcing
 891      * well-formedness constraints on fields.  Null entries and
 892      * self-pointers are not allowed in the list of {@code
 893      * suppressedExceptions}.  Null entries are not allowed for stack
 894      * trace elements.  A null stack trace in the serial form results
 895      * in a zero-length stack element array. A single-element stack
 896      * trace whose entry is equal to {@code new StackTraceElement(&quot;&quot;,
 897      * &quot;&quot;, null, Integer.MIN_VALUE)} results in a {@code null} {@code
 898      * stackTrace} field.
 899      *
 900      * Note that there are no constraints on the value the {@code
 901      * cause} field can hold; both {@code null} and {@code this} are
 902      * valid values for the field.
 903      */

 904     private void readObject(ObjectInputStream s)
 905         throws IOException, ClassNotFoundException {
 906         s.defaultReadObject();     // read in all fields
<span class="line-modified"> 907         if (suppressedExceptions != null) {</span>
<span class="line-modified"> 908             List&lt;Throwable&gt; suppressed = null;</span>
<span class="line-modified"> 909             if (suppressedExceptions.isEmpty()) {</span>
<span class="line-modified"> 910                 // Use the sentinel for a zero-length list</span>
<span class="line-modified"> 911                 suppressed = SUPPRESSED_SENTINEL;</span>
<span class="line-modified"> 912             } else { // Copy Throwables to new list</span>
<span class="line-modified"> 913                 suppressed = new ArrayList&lt;&gt;(1);</span>
<span class="line-modified"> 914                 for (Throwable t : suppressedExceptions) {</span>








 915                     // Enforce constraints on suppressed exceptions in
 916                     // case of corrupt or malicious stream.
 917                     Objects.requireNonNull(t, NULL_CAUSE_MESSAGE);
 918                     if (t == this)
 919                         throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE);
<span class="line-modified"> 920                     suppressed.add(t);</span>
 921                 }



 922             }
<span class="line-modified"> 923             suppressedExceptions = suppressed;</span>
<span class="line-modified"> 924         } // else a null suppressedExceptions field remains null</span>

 925 
 926         /*
 927          * For zero-length stack traces, use a clone of
 928          * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to
 929          * allow identity comparison against UNASSIGNED_STACK in
 930          * getOurStackTrace.  The identity of UNASSIGNED_STACK in
 931          * stackTrace indicates to the getOurStackTrace method that
 932          * the stackTrace needs to be constructed from the information
 933          * in backtrace.
 934          */
<span class="line-modified"> 935         if (stackTrace != null) {</span>
<span class="line-modified"> 936             if (stackTrace.length == 0) {</span>
<span class="line-modified"> 937                 stackTrace = UNASSIGNED_STACK.clone();</span>
<span class="line-modified"> 938             }  else if (stackTrace.length == 1 &amp;&amp;</span>


 939                         // Check for the marker of an immutable stack trace
<span class="line-modified"> 940                         SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(stackTrace[0])) {</span>
<span class="line-modified"> 941                 stackTrace = null;</span>
<span class="line-modified"> 942             } else { // Verify stack trace elements are non-null.</span>
<span class="line-modified"> 943                 for(StackTraceElement ste : stackTrace) {</span>
<span class="line-modified"> 944                     Objects.requireNonNull(ste, &quot;null StackTraceElement in serial stream.&quot;);</span>


 945                 }
 946             }













 947         } else {
<span class="line-modified"> 948             // A null stackTrace field in the serial form can result</span>
<span class="line-modified"> 949             // from an exception serialized without that field in</span>
<span class="line-modified"> 950             // older JDK releases; treat such exceptions as having</span>
<span class="line-modified"> 951             // empty stack traces.</span>
<span class="line-modified"> 952             stackTrace = UNASSIGNED_STACK.clone();</span>
 953         }
 954     }
 955 
 956     /**
 957      * Write a {@code Throwable} object to a stream.
 958      *
 959      * A {@code null} stack trace field is represented in the serial
 960      * form as a one-element array whose element is equal to {@code
 961      * new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.
 962      */

 963     private synchronized void writeObject(ObjectOutputStream s)
 964         throws IOException {
 965         // Ensure that the stackTrace field is initialized to a
 966         // non-null value, if appropriate.  As of JDK 7, a null stack
 967         // trace field is a valid value indicating the stack trace
 968         // should not be set.
 969         getOurStackTrace();
 970 
 971         StackTraceElement[] oldStackTrace = stackTrace;
 972         try {
 973             if (stackTrace == null)
 974                 stackTrace = SentinelHolder.STACK_TRACE_SENTINEL;
 975             s.defaultWriteObject();
 976         } finally {
 977             stackTrace = oldStackTrace;
 978         }
 979     }
 980 
 981     /**
 982      * Appends the specified exception to the exceptions that were
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
<span class="line-modified">  28 import java.io.*;</span>
<span class="line-modified">  29 import java.util.*;</span>
  30 
  31 /**
  32  * The {@code Throwable} class is the superclass of all errors and
  33  * exceptions in the Java language. Only objects that are instances of this
  34  * class (or one of its subclasses) are thrown by the Java Virtual Machine or
  35  * can be thrown by the Java {@code throw} statement. Similarly, only
  36  * this class or one of its subclasses can be the argument type in a
  37  * {@code catch} clause.
  38  *
  39  * For the purposes of compile-time checking of exceptions, {@code
  40  * Throwable} and any subclass of {@code Throwable} that is not also a
  41  * subclass of either {@link RuntimeException} or {@link Error} are
  42  * regarded as checked exceptions.
  43  *
  44  * &lt;p&gt;Instances of two subclasses, {@link java.lang.Error} and
  45  * {@link java.lang.Exception}, are conventionally used to indicate
  46  * that exceptional situations have occurred. Typically, these instances
  47  * are freshly created in the context of the exceptional situation so
  48  * as to include relevant information (such as stack trace data).
  49  *
</pre>
<hr />
<pre>
  97  * implementation predates the addition of the exception chaining mechanism to
  98  * {@code Throwable}.
  99  *
 100  * &lt;p&gt;By convention, class {@code Throwable} and its subclasses have two
 101  * constructors, one that takes no arguments and one that takes a
 102  * {@code String} argument that can be used to produce a detail message.
 103  * Further, those subclasses that might likely have a cause associated with
 104  * them should have two more constructors, one that takes a
 105  * {@code Throwable} (the cause), and one that takes a
 106  * {@code String} (the detail message) and a {@code Throwable} (the
 107  * cause).
 108  *
 109  * @author  unascribed
 110  * @author  Josh Bloch (Added exception chaining and programmatic access to
 111  *          stack trace in 1.4.)
 112  * @jls 11.2 Compile-Time Checking of Exceptions
 113  * @since 1.0
 114  */
 115 public class Throwable implements Serializable {
 116     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 117     @java.io.Serial</span>
 118     private static final long serialVersionUID = -3042686055658047285L;
 119 
 120     /**
 121      * The JVM saves some indication of the stack backtrace in this slot.
 122      */
 123     private transient Object backtrace;
 124 
 125     /**
 126      * Specific details about the Throwable.  For example, for
 127      * {@code FileNotFoundException}, this contains the name of
 128      * the file that could not be found.
 129      *
 130      * @serial
 131      */
 132     private String detailMessage;
 133 
 134 
 135     /**
 136      * Holder class to defer initializing sentinel objects only used
 137      * for serialization.
</pre>
<hr />
<pre>
 213 
 214     /**
 215      * The JVM code sets the depth of the backtrace for later retrieval
 216      */
 217     private transient int depth;
 218 
 219     // Setting this static field introduces an acceptable
 220     // initialization dependency on a few java.util classes.
 221     private static final List&lt;Throwable&gt; SUPPRESSED_SENTINEL = Collections.emptyList();
 222 
 223     /**
 224      * The list of suppressed exceptions, as returned by {@link
 225      * #getSuppressed()}.  The list is initialized to a zero-element
 226      * unmodifiable sentinel list.  When a serialized Throwable is
 227      * read in, if the {@code suppressedExceptions} field points to a
 228      * zero-element list, the field is reset to the sentinel value.
 229      *
 230      * @serial
 231      * @since 1.7
 232      */
<span class="line-added"> 233     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 234     private List&lt;Throwable&gt; suppressedExceptions = SUPPRESSED_SENTINEL;
 235 
 236     /** Message for trying to suppress a null exception. */
 237     private static final String NULL_CAUSE_MESSAGE = &quot;Cannot suppress a null exception.&quot;;
 238 
 239     /** Message for trying to suppress oneself. */
 240     private static final String SELF_SUPPRESSION_MESSAGE = &quot;Self-suppression not permitted&quot;;
 241 
 242     /** Caption  for labeling causative exception stack traces */
 243     private static final String CAUSE_CAPTION = &quot;Caused by: &quot;;
 244 
 245     /** Caption for labeling suppressed exception stack traces */
 246     private static final String SUPPRESSED_CAPTION = &quot;Suppressed: &quot;;
 247 
 248     /**
 249      * Constructs a new throwable with {@code null} as its detail message.
 250      * The cause is not initialized, and may subsequently be initialized by a
 251      * call to {@link #initCause}.
 252      *
 253      * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
</pre>
<hr />
<pre>
 678                 se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);
 679 
 680             // Print cause, if any
 681             Throwable ourCause = getCause();
 682             if (ourCause != null)
 683                 ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);
 684         }
 685     }
 686 
 687     /**
 688      * Print our stack trace as an enclosed exception for the specified
 689      * stack trace.
 690      */
 691     private void printEnclosedStackTrace(PrintStreamOrWriter s,
 692                                          StackTraceElement[] enclosingTrace,
 693                                          String caption,
 694                                          String prefix,
 695                                          Set&lt;Throwable&gt; dejaVu) {
 696         assert Thread.holdsLock(s.lock());
 697         if (dejaVu.contains(this)) {
<span class="line-modified"> 698             s.println(prefix + caption + &quot;[CIRCULAR REFERENCE: &quot; + this + &quot;]&quot;);</span>
 699         } else {
 700             dejaVu.add(this);
 701             // Compute number of frames in common between this and enclosing trace
 702             StackTraceElement[] trace = getOurStackTrace();
 703             int m = trace.length - 1;
 704             int n = enclosingTrace.length - 1;
 705             while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(enclosingTrace[n])) {
 706                 m--; n--;
 707             }
 708             int framesInCommon = trace.length - 1 - m;
 709 
 710             // Print our stack trace
 711             s.println(prefix + caption + this);
 712             for (int i = 0; i &lt;= m; i++)
 713                 s.println(prefix + &quot;\tat &quot; + trace[i]);
 714             if (framesInCommon != 0)
 715                 s.println(prefix + &quot;\t... &quot; + framesInCommon + &quot; more&quot;);
 716 
 717             // Print suppressed exceptions, if any
 718             for (Throwable se : getSuppressed())
</pre>
<hr />
<pre>
 886                 return;
 887             this.stackTrace = defensiveCopy;
 888         }
 889     }
 890 
 891     /**
 892      * Reads a {@code Throwable} from a stream, enforcing
 893      * well-formedness constraints on fields.  Null entries and
 894      * self-pointers are not allowed in the list of {@code
 895      * suppressedExceptions}.  Null entries are not allowed for stack
 896      * trace elements.  A null stack trace in the serial form results
 897      * in a zero-length stack element array. A single-element stack
 898      * trace whose entry is equal to {@code new StackTraceElement(&quot;&quot;,
 899      * &quot;&quot;, null, Integer.MIN_VALUE)} results in a {@code null} {@code
 900      * stackTrace} field.
 901      *
 902      * Note that there are no constraints on the value the {@code
 903      * cause} field can hold; both {@code null} and {@code this} are
 904      * valid values for the field.
 905      */
<span class="line-added"> 906     @java.io.Serial</span>
 907     private void readObject(ObjectInputStream s)
 908         throws IOException, ClassNotFoundException {
 909         s.defaultReadObject();     // read in all fields
<span class="line-modified"> 910 </span>
<span class="line-modified"> 911         // Set suppressed exceptions and stack trace elements fields</span>
<span class="line-modified"> 912         // to marker values until the contents from the serial stream</span>
<span class="line-modified"> 913         // are validated.</span>
<span class="line-modified"> 914         List&lt;Throwable&gt; candidateSuppressedExceptions = suppressedExceptions;</span>
<span class="line-modified"> 915         suppressedExceptions = SUPPRESSED_SENTINEL;</span>
<span class="line-modified"> 916 </span>
<span class="line-modified"> 917         StackTraceElement[] candidateStackTrace = stackTrace;</span>
<span class="line-added"> 918         stackTrace = UNASSIGNED_STACK.clone();</span>
<span class="line-added"> 919 </span>
<span class="line-added"> 920         if (candidateSuppressedExceptions != null) {</span>
<span class="line-added"> 921             int suppressedSize = validateSuppressedExceptionsList(candidateSuppressedExceptions);</span>
<span class="line-added"> 922             if (suppressedSize &gt; 0) { // Copy valid Throwables to new list</span>
<span class="line-added"> 923                 var suppList  = new ArrayList&lt;Throwable&gt;(Math.min(100, suppressedSize));</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925                 for (Throwable t : candidateSuppressedExceptions) {</span>
 926                     // Enforce constraints on suppressed exceptions in
 927                     // case of corrupt or malicious stream.
 928                     Objects.requireNonNull(t, NULL_CAUSE_MESSAGE);
 929                     if (t == this)
 930                         throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE);
<span class="line-modified"> 931                     suppList.add(t);</span>
 932                 }
<span class="line-added"> 933                 // If there are any invalid suppressed exceptions,</span>
<span class="line-added"> 934                 // implicitly use the sentinel value assigned earlier.</span>
<span class="line-added"> 935                 suppressedExceptions = suppList;</span>
 936             }
<span class="line-modified"> 937         } else {</span>
<span class="line-modified"> 938             suppressedExceptions = null;</span>
<span class="line-added"> 939         }</span>
 940 
 941         /*
 942          * For zero-length stack traces, use a clone of
 943          * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to
 944          * allow identity comparison against UNASSIGNED_STACK in
 945          * getOurStackTrace.  The identity of UNASSIGNED_STACK in
 946          * stackTrace indicates to the getOurStackTrace method that
 947          * the stackTrace needs to be constructed from the information
 948          * in backtrace.
 949          */
<span class="line-modified"> 950         if (candidateStackTrace != null) {</span>
<span class="line-modified"> 951             // Work from a clone of the candidateStackTrace to ensure</span>
<span class="line-modified"> 952             // consistency of checks.</span>
<span class="line-modified"> 953             candidateStackTrace = candidateStackTrace.clone();</span>
<span class="line-added"> 954             if (candidateStackTrace.length &gt;= 1) {</span>
<span class="line-added"> 955                 if (candidateStackTrace.length == 1 &amp;&amp;</span>
 956                         // Check for the marker of an immutable stack trace
<span class="line-modified"> 957                         SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(candidateStackTrace[0])) {</span>
<span class="line-modified"> 958                     stackTrace = null;</span>
<span class="line-modified"> 959                 } else { // Verify stack trace elements are non-null.</span>
<span class="line-modified"> 960                     for (StackTraceElement ste : candidateStackTrace) {</span>
<span class="line-modified"> 961                         Objects.requireNonNull(ste, &quot;null StackTraceElement in serial stream.&quot;);</span>
<span class="line-added"> 962                     }</span>
<span class="line-added"> 963                     stackTrace = candidateStackTrace;</span>
 964                 }
 965             }
<span class="line-added"> 966         }</span>
<span class="line-added"> 967         // A null stackTrace field in the serial form can result from</span>
<span class="line-added"> 968         // an exception serialized without that field in older JDK</span>
<span class="line-added"> 969         // releases; treat such exceptions as having empty stack</span>
<span class="line-added"> 970         // traces by leaving stackTrace assigned to a clone of</span>
<span class="line-added"> 971         // UNASSIGNED_STACK.</span>
<span class="line-added"> 972     }</span>
<span class="line-added"> 973 </span>
<span class="line-added"> 974     private int validateSuppressedExceptionsList(List&lt;Throwable&gt; deserSuppressedExceptions)</span>
<span class="line-added"> 975         throws IOException {</span>
<span class="line-added"> 976         if (!Object.class.getModule().</span>
<span class="line-added"> 977             equals(deserSuppressedExceptions.getClass().getModule())) {</span>
<span class="line-added"> 978             throw new StreamCorruptedException(&quot;List implementation not in base module.&quot;);</span>
 979         } else {
<span class="line-modified"> 980             int size = deserSuppressedExceptions.size();</span>
<span class="line-modified"> 981             if (size &lt; 0) {</span>
<span class="line-modified"> 982                 throw new StreamCorruptedException(&quot;Negative list size reported.&quot;);</span>
<span class="line-modified"> 983             }</span>
<span class="line-modified"> 984             return size;</span>
 985         }
 986     }
 987 
 988     /**
 989      * Write a {@code Throwable} object to a stream.
 990      *
 991      * A {@code null} stack trace field is represented in the serial
 992      * form as a one-element array whose element is equal to {@code
 993      * new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.
 994      */
<span class="line-added"> 995     @java.io.Serial</span>
 996     private synchronized void writeObject(ObjectOutputStream s)
 997         throws IOException {
 998         // Ensure that the stackTrace field is initialized to a
 999         // non-null value, if appropriate.  As of JDK 7, a null stack
1000         // trace field is a valid value indicating the stack trace
1001         // should not be set.
1002         getOurStackTrace();
1003 
1004         StackTraceElement[] oldStackTrace = stackTrace;
1005         try {
1006             if (stackTrace == null)
1007                 stackTrace = SentinelHolder.STACK_TRACE_SENTINEL;
1008             s.defaultWriteObject();
1009         } finally {
1010             stackTrace = oldStackTrace;
1011         }
1012     }
1013 
1014     /**
1015      * Appends the specified exception to the exceptions that were
</pre>
</td>
</tr>
</table>
<center><a href="ThreadGroup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TypeNotPresentException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
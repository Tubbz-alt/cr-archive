<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/text/Format.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.Serializable;
 42 
 43 /**
 44  * &lt;code&gt;Format&lt;/code&gt; is an abstract base class for formatting locale-sensitive
 45  * information such as dates, messages, and numbers.
 46  *
 47  * &lt;p&gt;
 48  * &lt;code&gt;Format&lt;/code&gt; defines the programming interface for formatting
 49  * locale-sensitive objects into &lt;code&gt;String&lt;/code&gt;s (the
 50  * &lt;code&gt;format&lt;/code&gt; method) and for parsing &lt;code&gt;String&lt;/code&gt;s back
 51  * into objects (the &lt;code&gt;parseObject&lt;/code&gt; method).
 52  *
 53  * &lt;p&gt;
 54  * Generally, a format&#39;s &lt;code&gt;parseObject&lt;/code&gt; method must be able to parse
 55  * any string formatted by its &lt;code&gt;format&lt;/code&gt; method. However, there may
 56  * be exceptional cases where this is not possible. For example, a
 57  * &lt;code&gt;format&lt;/code&gt; method might create two adjacent integer numbers with
 58  * no separator in between, and in this case the &lt;code&gt;parseObject&lt;/code&gt; could
 59  * not tell which digits belong to which number.
 60  *
 61  * &lt;h3&gt;Subclassing&lt;/h3&gt;
 62  *
 63  * &lt;p&gt;
 64  * The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;--
 65  * &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and
 66  * &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers,
 67  * respectively.
 68  * &lt;p&gt;
 69  * Concrete subclasses must implement three methods:
 70  * &lt;ol&gt;
 71  * &lt;li&gt; &lt;code&gt;format(Object obj, StringBuffer toAppendTo, FieldPosition pos)&lt;/code&gt;
 72  * &lt;li&gt; &lt;code&gt;formatToCharacterIterator(Object obj)&lt;/code&gt;
 73  * &lt;li&gt; &lt;code&gt;parseObject(String source, ParsePosition pos)&lt;/code&gt;
 74  * &lt;/ol&gt;
 75  * These general methods allow polymorphic parsing and formatting of objects
 76  * and are used, for example, by &lt;code&gt;MessageFormat&lt;/code&gt;.
 77  * Subclasses often also provide additional &lt;code&gt;format&lt;/code&gt; methods for
 78  * specific input types as well as &lt;code&gt;parse&lt;/code&gt; methods for specific
 79  * result types. Any &lt;code&gt;parse&lt;/code&gt; method that does not take a
 80  * &lt;code&gt;ParsePosition&lt;/code&gt; argument should throw &lt;code&gt;ParseException&lt;/code&gt;
 81  * when no text in the required format is at the beginning of the input text.
 82  *
 83  * &lt;p&gt;
 84  * Most subclasses will also implement the following factory methods:
 85  * &lt;ol&gt;
 86  * &lt;li&gt;
 87  * &lt;code&gt;getInstance&lt;/code&gt; for getting a useful format object appropriate
 88  * for the current locale
 89  * &lt;li&gt;
 90  * &lt;code&gt;getInstance(Locale)&lt;/code&gt; for getting a useful format
 91  * object appropriate for the specified locale
 92  * &lt;/ol&gt;
 93  * In addition, some subclasses may also implement other
 94  * &lt;code&gt;getXxxxInstance&lt;/code&gt; methods for more specialized control. For
 95  * example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides
 96  * &lt;code&gt;getPercentInstance&lt;/code&gt; and &lt;code&gt;getCurrencyInstance&lt;/code&gt;
 97  * methods for getting specialized number formatters.
 98  *
 99  * &lt;p&gt;
100  * Subclasses of &lt;code&gt;Format&lt;/code&gt; that allow programmers to create objects
101  * for locales (with &lt;code&gt;getInstance(Locale)&lt;/code&gt; for example)
102  * must also implement the following class method:
103  * &lt;blockquote&gt;
104  * &lt;pre&gt;
105  * public static Locale[] getAvailableLocales()
106  * &lt;/pre&gt;
107  * &lt;/blockquote&gt;
108  *
109  * &lt;p&gt;
110  * And finally subclasses may define a set of constants to identify the various
111  * fields in the formatted output. These constants are used to create a FieldPosition
112  * object which identifies what information is contained in the field and its
113  * position in the formatted result. These constants should be named
114  * &lt;code&gt;&lt;em&gt;item&lt;/em&gt;_FIELD&lt;/code&gt; where &lt;code&gt;&lt;em&gt;item&lt;/em&gt;&lt;/code&gt; identifies
115  * the field. For examples of these constants, see &lt;code&gt;ERA_FIELD&lt;/code&gt; and its
116  * friends in {@link DateFormat}.
117  *
118  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
119  *
120  * &lt;p&gt;
121  * Formats are generally not synchronized.
122  * It is recommended to create separate format instances for each thread.
123  * If multiple threads access a format concurrently, it must be synchronized
124  * externally.
125  *
126  * @see          java.text.ParsePosition
127  * @see          java.text.FieldPosition
128  * @see          java.text.NumberFormat
129  * @see          java.text.DateFormat
130  * @see          java.text.MessageFormat
131  * @author       Mark Davis
132  * @since 1.1
133  */
134 public abstract class Format implements Serializable, Cloneable {
135 
136     private static final long serialVersionUID = -299282585814624189L;
137 
138     /**
139      * Sole constructor.  (For invocation by subclass constructors, typically
140      * implicit.)
141      */
142     protected Format() {
143     }
144 
145     /**
146      * Formats an object to produce a string. This is equivalent to
147      * &lt;blockquote&gt;
148      * {@link #format(Object, StringBuffer, FieldPosition) format}&lt;code&gt;(obj,
149      *         new StringBuffer(), new FieldPosition(0)).toString();&lt;/code&gt;
150      * &lt;/blockquote&gt;
151      *
152      * @param obj    The object to format
153      * @return       Formatted string.
154      * @exception IllegalArgumentException if the Format cannot format the given
155      *            object
156      */
157     public final String format (Object obj) {
158         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
159     }
160 
161     /**
162      * Formats an object and appends the resulting text to a given string
163      * buffer.
164      * If the &lt;code&gt;pos&lt;/code&gt; argument identifies a field used by the format,
165      * then its indices are set to the beginning and end of the first such
166      * field encountered.
167      *
168      * @param obj    The object to format
169      * @param toAppendTo    where the text is to be appended
170      * @param pos    A &lt;code&gt;FieldPosition&lt;/code&gt; identifying a field
171      *               in the formatted text
172      * @return       the string buffer passed in as &lt;code&gt;toAppendTo&lt;/code&gt;,
173      *               with formatted text appended
174      * @exception NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
175      *            &lt;code&gt;pos&lt;/code&gt; is null
176      * @exception IllegalArgumentException if the Format cannot format the given
177      *            object
178      */
179     public abstract StringBuffer format(Object obj,
180                     StringBuffer toAppendTo,
181                     FieldPosition pos);
182 
183     /**
184      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
185      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
186      * to build the resulting String, as well as to determine information
187      * about the resulting String.
188      * &lt;p&gt;
189      * Each attribute key of the AttributedCharacterIterator will be of type
190      * &lt;code&gt;Field&lt;/code&gt;. It is up to each &lt;code&gt;Format&lt;/code&gt; implementation
191      * to define what the legal values are for each attribute in the
192      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;, but typically the attribute
193      * key is also used as the attribute value.
194      * &lt;p&gt;The default implementation creates an
195      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with no attributes. Subclasses
196      * that support fields should override this and create an
197      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; with meaningful attributes.
198      *
199      * @exception NullPointerException if obj is null.
200      * @exception IllegalArgumentException when the Format cannot format the
201      *            given object.
202      * @param obj The object to format
203      * @return AttributedCharacterIterator describing the formatted value.
204      * @since 1.4
205      */
206     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
207         return createAttributedCharacterIterator(format(obj));
208     }
209 
210     /**
211      * Parses text from a string to produce an object.
212      * &lt;p&gt;
213      * The method attempts to parse text starting at the index given by
214      * &lt;code&gt;pos&lt;/code&gt;.
215      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
216      * to the index after the last character used (parsing does not necessarily
217      * use all characters up to the end of the string), and the parsed
218      * object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
219      * indicate the starting point for the next call to this method.
220      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
221      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
222      * the character where the error occurred, and null is returned.
223      *
224      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
225      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
226      *            index information as described above.
227      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string. In case of
228      *         error, returns null.
229      * @throws NullPointerException if {@code source} or {@code pos} is null.
230      */
231     public abstract Object parseObject (String source, ParsePosition pos);
232 
233     /**
234      * Parses text from the beginning of the given string to produce an object.
235      * The method may not use the entire text of the given string.
236      *
237      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
238      * @return An &lt;code&gt;Object&lt;/code&gt; parsed from the string.
239      * @exception ParseException if the beginning of the specified string
240      *            cannot be parsed.
241      * @throws NullPointerException if {@code source} is null.
242      */
243     public Object parseObject(String source) throws ParseException {
244         ParsePosition pos = new ParsePosition(0);
245         Object result = parseObject(source, pos);
246         if (pos.index == 0) {
247             throw new ParseException(&quot;Format.parseObject(String) failed&quot;,
248                 pos.errorIndex);
249         }
250         return result;
251     }
252 
253     /**
254      * Creates and returns a copy of this object.
255      *
256      * @return a clone of this instance.
257      */
258     public Object clone() {
259         try {
260             return super.clone();
261         } catch (CloneNotSupportedException e) {
262             // will never happen
263             throw new InternalError(e);
264         }
265     }
266 
267     //
268     // Convenience methods for creating AttributedCharacterIterators from
269     // different parameters.
270     //
271 
272     /**
273      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String
274      * &lt;code&gt;s&lt;/code&gt;.
275      *
276      * @param s String to create AttributedCharacterIterator from
277      * @return AttributedCharacterIterator wrapping s
278      */
279     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
280         AttributedString as = new AttributedString(s);
281 
282         return as.getIterator();
283     }
284 
285     /**
286      * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; containing the
287      * concatenated contents of the passed in
288      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;s.
289      *
290      * @param iterators AttributedCharacterIterators used to create resulting
291      *                  AttributedCharacterIterators
292      * @return AttributedCharacterIterator wrapping passed in
293      *         AttributedCharacterIterators
294      */
295     AttributedCharacterIterator createAttributedCharacterIterator(
296                        AttributedCharacterIterator[] iterators) {
297         AttributedString as = new AttributedString(iterators);
298 
299         return as.getIterator();
300     }
301 
302     /**
303      * Returns an AttributedCharacterIterator with the String
304      * &lt;code&gt;string&lt;/code&gt; and additional key/value pair &lt;code&gt;key&lt;/code&gt;,
305      * &lt;code&gt;value&lt;/code&gt;.
306      *
307      * @param string String to create AttributedCharacterIterator from
308      * @param key Key for AttributedCharacterIterator
309      * @param value Value associated with key in AttributedCharacterIterator
310      * @return AttributedCharacterIterator wrapping args
311      */
312     AttributedCharacterIterator createAttributedCharacterIterator(
313                       String string, AttributedCharacterIterator.Attribute key,
314                       Object value) {
315         AttributedString as = new AttributedString(string);
316 
317         as.addAttribute(key, value);
318         return as.getIterator();
319     }
320 
321     /**
322      * Creates an AttributedCharacterIterator with the contents of
323      * &lt;code&gt;iterator&lt;/code&gt; and the additional attribute &lt;code&gt;key&lt;/code&gt;
324      * &lt;code&gt;value&lt;/code&gt;.
325      *
326      * @param iterator Initial AttributedCharacterIterator to add arg to
327      * @param key Key for AttributedCharacterIterator
328      * @param value Value associated with key in AttributedCharacterIterator
329      * @return AttributedCharacterIterator wrapping args
330      */
331     AttributedCharacterIterator createAttributedCharacterIterator(
332               AttributedCharacterIterator iterator,
333               AttributedCharacterIterator.Attribute key, Object value) {
334         AttributedString as = new AttributedString(iterator);
335 
336         as.addAttribute(key, value);
337         return as.getIterator();
338     }
339 
340 
341     /**
342      * Defines constants that are used as attribute keys in the
343      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
344      * from &lt;code&gt;Format.formatToCharacterIterator&lt;/code&gt; and as
345      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
346      *
347      * @since 1.4
348      */
349     public static class Field extends AttributedCharacterIterator.Attribute {
350 
351         // Proclaim serial compatibility with 1.4 FCS
352         private static final long serialVersionUID = 276966692217360283L;
353 
354         /**
355          * Creates a Field with the specified name.
356          *
357          * @param name Name of the attribute
358          */
359         protected Field(String name) {
360             super(name);
361         }
362     }
363 
364 
365     /**
366      * FieldDelegate is notified by the various &lt;code&gt;Format&lt;/code&gt;
367      * implementations as they are formatting the Objects. This allows for
368      * storage of the individual sections of the formatted String for
369      * later use, such as in a &lt;code&gt;FieldPosition&lt;/code&gt; or for an
370      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
371      * &lt;p&gt;
372      * Delegates should NOT assume that the &lt;code&gt;Format&lt;/code&gt; will notify
373      * the delegate of fields in any particular order.
374      *
375      * @see FieldPosition#getFieldDelegate
376      * @see CharacterIteratorFieldDelegate
377      */
378     interface FieldDelegate {
379         /**
380          * Notified when a particular region of the String is formatted. This
381          * method will be invoked if there is no corresponding integer field id
382          * matching &lt;code&gt;attr&lt;/code&gt;.
383          *
384          * @param attr Identifies the field matched
385          * @param value Value associated with the field
386          * @param start Beginning location of the field, will be &gt;= 0
387          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
388          * @param buffer Contains current formatted value, receiver should
389          *        NOT modify it.
390          */
391         public void formatted(Format.Field attr, Object value, int start,
392                               int end, StringBuffer buffer);
393 
394         /**
395          * Notified when a particular region of the String is formatted.
396          *
397          * @param fieldID Identifies the field by integer
398          * @param attr Identifies the field matched
399          * @param value Value associated with the field
400          * @param start Beginning location of the field, will be &gt;= 0
401          * @param end End of the field, will be &gt;= start and &lt;= buffer.length()
402          * @param buffer Contains current formatted value, receiver should
403          *        NOT modify it.
404          */
405         public void formatted(int fieldID, Format.Field attr, Object value,
406                               int start, int end, StringBuffer buffer);
407     }
408 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/ServerSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
<a name="2" id="anc2"></a><span class="line-removed">  28 import jdk.internal.access.JavaNetSocketAccess;</span>
<span class="line-removed">  29 import jdk.internal.access.SharedSecrets;</span>
<span class="line-removed">  30 </span>
  31 import java.io.FileDescriptor;
  32 import java.io.IOException;
<a name="3" id="anc3"></a><span class="line-removed">  33 import java.lang.reflect.Constructor;</span>
<span class="line-removed">  34 import java.lang.reflect.InvocationTargetException;</span>
  35 import java.nio.channels.ServerSocketChannel;
<a name="4" id="anc4"></a><span class="line-modified">  36 import java.security.AccessController;</span>
<span class="line-removed">  37 import java.security.PrivilegedExceptionAction;</span>
  38 import java.util.Set;
  39 import java.util.Collections;
  40 
<a name="5" id="anc5"></a>


  41 /**
  42  * This class implements server sockets. A server socket waits for
  43  * requests to come in over the network. It performs some operation
  44  * based on that request, and then possibly returns a result to the requester.
  45  * &lt;p&gt;
  46  * The actual work of the server socket is performed by an instance
  47  * of the {@code SocketImpl} class. An application can
  48  * change the socket factory that creates the socket
  49  * implementation to configure itself to create sockets
  50  * appropriate to the local firewall.
  51  *
<a name="6" id="anc6"></a>




























  52  * @author  unascribed
  53  * @see     java.net.SocketImpl
  54  * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
  55  * @see     java.nio.channels.ServerSocketChannel
  56  * @since   1.0
  57  */
<a name="7" id="anc7"></a><span class="line-modified">  58 public</span>
<span class="line-removed">  59 class ServerSocket implements java.io.Closeable {</span>
  60     /**
  61      * Various states of this socket.
  62      */
  63     private boolean created = false;
  64     private boolean bound = false;
  65     private boolean closed = false;
  66     private Object closeLock = new Object();
  67 
  68     /**
  69      * The implementation of this Socket.
  70      */
  71     private SocketImpl impl;
  72 
<a name="8" id="anc8"></a><span class="line-removed">  73     /**</span>
<span class="line-removed">  74      * Are we using an older SocketImpl?</span>
<span class="line-removed">  75      */</span>
<span class="line-removed">  76     private boolean oldImpl = false;</span>
<span class="line-removed">  77 </span>
  78     /**
  79      * Creates a server socket with a user-specified {@code SocketImpl}.
  80      *
  81      * @param      impl an instance of a SocketImpl to use on the ServerSocket.
  82      *
  83      * @throws     NullPointerException if impl is {@code null}.
  84      *
<a name="9" id="anc9"></a>


  85      * @since 12
  86      */
  87     protected ServerSocket(SocketImpl impl) {
<a name="10" id="anc10"></a>

  88         this.impl = impl;
<a name="11" id="anc11"></a><span class="line-modified">  89         impl.setServerSocket(this);</span>







  90     }
  91 
  92     /**
  93      * Creates an unbound server socket.
  94      *
<a name="12" id="anc12"></a><span class="line-modified">  95      * @exception IOException IO error when opening the socket.</span>
  96      * @revised 1.4
  97      */
  98     public ServerSocket() throws IOException {
  99         setImpl();
 100     }
 101 
 102     /**
 103      * Creates a server socket, bound to the specified port. A port number
 104      * of {@code 0} means that the port number is automatically
 105      * allocated, typically from an ephemeral port range. This port
 106      * number can then be retrieved by calling {@link #getLocalPort getLocalPort}.
 107      * &lt;p&gt;
 108      * The maximum queue length for incoming connection indications (a
 109      * request to connect) is set to {@code 50}. If a connection
 110      * indication arrives when the queue is full, the connection is refused.
 111      * &lt;p&gt;
<a name="13" id="anc13"></a><span class="line-modified"> 112      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 113      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 114      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 115      * &lt;p&gt;
 116      * If there is a security manager,
 117      * its {@code checkListen} method is called
 118      * with the {@code port} argument
 119      * as its argument to ensure the operation is allowed.
 120      * This could result in a SecurityException.
 121      *
 122      *
 123      * @param      port  the port number, or {@code 0} to use a port
 124      *                   number that is automatically allocated.
 125      *
<a name="14" id="anc14"></a><span class="line-modified"> 126      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 127      * @exception  SecurityException</span>
 128      * if a security manager exists and its {@code checkListen}
 129      * method doesn&#39;t allow the operation.
<a name="15" id="anc15"></a><span class="line-modified"> 130      * @exception  IllegalArgumentException if the port parameter is outside</span>
 131      *             the specified range of valid port values, which is between
 132      *             0 and 65535, inclusive.
 133      *
 134      * @see        java.net.SocketImpl
 135      * @see        java.net.SocketImplFactory#createSocketImpl()
 136      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 137      * @see        SecurityManager#checkListen
 138      */
 139     public ServerSocket(int port) throws IOException {
 140         this(port, 50, null);
 141     }
 142 
 143     /**
 144      * Creates a server socket and binds it to the specified local port
 145      * number, with the specified backlog.
 146      * A port number of {@code 0} means that the port number is
 147      * automatically allocated, typically from an ephemeral port range.
 148      * This port number can then be retrieved by calling
 149      * {@link #getLocalPort getLocalPort}.
 150      * &lt;p&gt;
 151      * The maximum queue length for incoming connection indications (a
 152      * request to connect) is set to the {@code backlog} parameter. If
 153      * a connection indication arrives when the queue is full, the
 154      * connection is refused.
 155      * &lt;p&gt;
<a name="16" id="anc16"></a><span class="line-modified"> 156      * If the application has specified a server socket factory, that</span>
<span class="line-modified"> 157      * factory&#39;s {@code createSocketImpl} method is called to create</span>
<span class="line-modified"> 158      * the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.</span>

 159      * &lt;p&gt;
 160      * If there is a security manager,
 161      * its {@code checkListen} method is called
 162      * with the {@code port} argument
 163      * as its argument to ensure the operation is allowed.
 164      * This could result in a SecurityException.
 165      *
 166      * The {@code backlog} argument is the requested maximum number of
 167      * pending connections on the socket. Its exact semantics are implementation
 168      * specific. In particular, an implementation may impose a maximum length
 169      * or may choose to ignore the parameter altogether. The value provided
 170      * should be greater than {@code 0}. If it is less than or equal to
 171      * {@code 0}, then an implementation specific default will be used.
 172      *
 173      * @param      port     the port number, or {@code 0} to use a port
 174      *                      number that is automatically allocated.
 175      * @param      backlog  requested maximum length of the queue of incoming
 176      *                      connections.
 177      *
<a name="17" id="anc17"></a><span class="line-modified"> 178      * @exception  IOException  if an I/O error occurs when opening the socket.</span>
<span class="line-modified"> 179      * @exception  SecurityException</span>
 180      * if a security manager exists and its {@code checkListen}
 181      * method doesn&#39;t allow the operation.
<a name="18" id="anc18"></a><span class="line-modified"> 182      * @exception  IllegalArgumentException if the port parameter is outside</span>
 183      *             the specified range of valid port values, which is between
 184      *             0 and 65535, inclusive.
 185      *
 186      * @see        java.net.SocketImpl
 187      * @see        java.net.SocketImplFactory#createSocketImpl()
 188      * @see        java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 189      * @see        SecurityManager#checkListen
 190      */
 191     public ServerSocket(int port, int backlog) throws IOException {
 192         this(port, backlog, null);
 193     }
 194 
 195     /**
 196      * Create a server with the specified port, listen backlog, and
 197      * local IP address to bind to.  The &lt;i&gt;bindAddr&lt;/i&gt; argument
 198      * can be used on a multi-homed host for a ServerSocket that
 199      * will only accept connect requests to one of its addresses.
 200      * If &lt;i&gt;bindAddr&lt;/i&gt; is null, it will default accepting
 201      * connections on any/all local addresses.
 202      * The port must be between 0 and 65535, inclusive.
 203      * A port number of {@code 0} means that the port number is
 204      * automatically allocated, typically from an ephemeral port range.
 205      * This port number can then be retrieved by calling
 206      * {@link #getLocalPort getLocalPort}.
 207      *
 208      * &lt;P&gt;If there is a security manager, this method
 209      * calls its {@code checkListen} method
 210      * with the {@code port} argument
 211      * as its argument to ensure the operation is allowed.
 212      * This could result in a SecurityException.
 213      *
 214      * The {@code backlog} argument is the requested maximum number of
 215      * pending connections on the socket. Its exact semantics are implementation
 216      * specific. In particular, an implementation may impose a maximum length
 217      * or may choose to ignore the parameter altogether. The value provided
 218      * should be greater than {@code 0}. If it is less than or equal to
 219      * {@code 0}, then an implementation specific default will be used.
 220      *
 221      * @param port  the port number, or {@code 0} to use a port
 222      *              number that is automatically allocated.
 223      * @param backlog requested maximum length of the queue of incoming
 224      *                connections.
 225      * @param bindAddr the local InetAddress the server will bind to
 226      *
 227      * @throws  SecurityException if a security manager exists and
 228      * its {@code checkListen} method doesn&#39;t allow the operation.
 229      *
 230      * @throws  IOException if an I/O error occurs when opening the socket.
<a name="19" id="anc19"></a><span class="line-modified"> 231      * @exception  IllegalArgumentException if the port parameter is outside</span>
 232      *             the specified range of valid port values, which is between
 233      *             0 and 65535, inclusive.
 234      *
 235      * @see SocketOptions
 236      * @see SocketImpl
 237      * @see SecurityManager#checkListen
 238      * @since   1.1
 239      */
 240     public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException {
 241         setImpl();
 242         if (port &lt; 0 || port &gt; 0xFFFF)
 243             throw new IllegalArgumentException(
 244                        &quot;Port value out of range: &quot; + port);
 245         if (backlog &lt; 1)
 246           backlog = 50;
 247         try {
 248             bind(new InetSocketAddress(bindAddr, port), backlog);
 249         } catch(SecurityException e) {
 250             close();
 251             throw e;
 252         } catch(IOException e) {
 253             close();
 254             throw e;
 255         }
 256     }
 257 
 258     /**
 259      * Get the {@code SocketImpl} attached to this socket, creating
 260      * it if necessary.
 261      *
 262      * @return  the {@code SocketImpl} attached to that ServerSocket.
 263      * @throws SocketException if creation fails.
 264      * @since 1.4
 265      */
 266     SocketImpl getImpl() throws SocketException {
 267         if (!created)
 268             createImpl();
 269         return impl;
 270     }
 271 
<a name="20" id="anc20"></a><span class="line-removed"> 272     private void checkOldImpl() {</span>
<span class="line-removed"> 273         if (impl == null)</span>
<span class="line-removed"> 274             return;</span>
<span class="line-removed"> 275         // SocketImpl.connect() is a protected method, therefore we need to use</span>
<span class="line-removed"> 276         // getDeclaredMethod, therefore we need permission to access the member</span>
<span class="line-removed"> 277         try {</span>
<span class="line-removed"> 278             AccessController.doPrivileged(</span>
<span class="line-removed"> 279                 new PrivilegedExceptionAction&lt;Void&gt;() {</span>
<span class="line-removed"> 280                     public Void run() throws NoSuchMethodException {</span>
<span class="line-removed"> 281                         impl.getClass().getDeclaredMethod(&quot;connect&quot;,</span>
<span class="line-removed"> 282                                                           SocketAddress.class,</span>
<span class="line-removed"> 283                                                           int.class);</span>
<span class="line-removed"> 284                         return null;</span>
<span class="line-removed"> 285                     }</span>
<span class="line-removed"> 286                 });</span>
<span class="line-removed"> 287         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed"> 288             oldImpl = true;</span>
<span class="line-removed"> 289         }</span>
<span class="line-removed"> 290     }</span>
<span class="line-removed"> 291 </span>
 292     private void setImpl() {
<a name="21" id="anc21"></a>
 293         if (factory != null) {
 294             impl = factory.createSocketImpl();
<a name="22" id="anc22"></a><span class="line-removed"> 295             checkOldImpl();</span>
 296         } else {
<a name="23" id="anc23"></a><span class="line-modified"> 297             // No need to do a checkOldImpl() here, we know it&#39;s an up to date</span>
<span class="line-removed"> 298             // SocketImpl!</span>
<span class="line-removed"> 299             impl = new SocksSocketImpl();</span>
 300         }
<a name="24" id="anc24"></a><span class="line-removed"> 301         if (impl != null)</span>
<span class="line-removed"> 302             impl.setServerSocket(this);</span>
 303     }
 304 
 305     /**
 306      * Creates the socket implementation.
 307      *
 308      * @throws IOException if creation fails
 309      * @since 1.4
 310      */
 311     void createImpl() throws SocketException {
 312         if (impl == null)
 313             setImpl();
 314         try {
 315             impl.create(true);
 316             created = true;
 317         } catch (IOException e) {
 318             throw new SocketException(e.getMessage());
 319         }
 320     }
 321 
 322     /**
 323      *
 324      * Binds the {@code ServerSocket} to a specific address
 325      * (IP address and port number).
 326      * &lt;p&gt;
 327      * If the address is {@code null}, then the system will pick up
 328      * an ephemeral port and a valid local address to bind the socket.
 329      *
 330      * @param   endpoint        The IP address and port number to bind to.
 331      * @throws  IOException if the bind operation fails, or if the socket
 332      *                     is already bound.
 333      * @throws  SecurityException       if a {@code SecurityManager} is present and
 334      * its {@code checkListen} method doesn&#39;t allow the operation.
 335      * @throws  IllegalArgumentException if endpoint is a
 336      *          SocketAddress subclass not supported by this socket
 337      * @since 1.4
 338      */
 339     public void bind(SocketAddress endpoint) throws IOException {
 340         bind(endpoint, 50);
 341     }
 342 
 343     /**
 344      *
 345      * Binds the {@code ServerSocket} to a specific address
 346      * (IP address and port number).
 347      * &lt;p&gt;
 348      * If the address is {@code null}, then the system will pick up
 349      * an ephemeral port and a valid local address to bind the socket.
 350      * &lt;P&gt;
 351      * The {@code backlog} argument is the requested maximum number of
 352      * pending connections on the socket. Its exact semantics are implementation
 353      * specific. In particular, an implementation may impose a maximum length
 354      * or may choose to ignore the parameter altogether. The value provided
 355      * should be greater than {@code 0}. If it is less than or equal to
 356      * {@code 0}, then an implementation specific default will be used.
 357      * @param   endpoint        The IP address and port number to bind to.
 358      * @param   backlog         requested maximum length of the queue of
 359      *                          incoming connections.
 360      * @throws  IOException if the bind operation fails, or if the socket
 361      *                     is already bound.
 362      * @throws  SecurityException       if a {@code SecurityManager} is present and
 363      * its {@code checkListen} method doesn&#39;t allow the operation.
 364      * @throws  IllegalArgumentException if endpoint is a
 365      *          SocketAddress subclass not supported by this socket
 366      * @since 1.4
 367      */
 368     public void bind(SocketAddress endpoint, int backlog) throws IOException {
 369         if (isClosed())
 370             throw new SocketException(&quot;Socket is closed&quot;);
<a name="25" id="anc25"></a><span class="line-modified"> 371         if (!oldImpl &amp;&amp; isBound())</span>
 372             throw new SocketException(&quot;Already bound&quot;);
 373         if (endpoint == null)
 374             endpoint = new InetSocketAddress(0);
 375         if (!(endpoint instanceof InetSocketAddress))
 376             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 377         InetSocketAddress epoint = (InetSocketAddress) endpoint;
 378         if (epoint.isUnresolved())
 379             throw new SocketException(&quot;Unresolved address&quot;);
 380         if (backlog &lt; 1)
 381           backlog = 50;
 382         try {
 383             SecurityManager security = System.getSecurityManager();
 384             if (security != null)
 385                 security.checkListen(epoint.getPort());
 386             getImpl().bind(epoint.getAddress(), epoint.getPort());
 387             getImpl().listen(backlog);
 388             bound = true;
 389         } catch(SecurityException e) {
 390             bound = false;
 391             throw e;
 392         } catch(IOException e) {
 393             bound = false;
 394             throw e;
 395         }
 396     }
 397 
 398     /**
 399      * Returns the local address of this server socket.
 400      * &lt;p&gt;
 401      * If the socket was bound prior to being {@link #close closed},
 402      * then this method will continue to return the local address
 403      * after the socket is closed.
 404      * &lt;p&gt;
 405      * If there is a security manager set, its {@code checkConnect} method is
 406      * called with the local address and {@code -1} as its arguments to see
 407      * if the operation is allowed. If the operation is not allowed,
 408      * the {@link InetAddress#getLoopbackAddress loopback} address is returned.
 409      *
 410      * @return  the address to which this socket is bound,
 411      *          or the loopback address if denied by the security manager,
 412      *          or {@code null} if the socket is unbound.
 413      *
 414      * @see SecurityManager#checkConnect
 415      */
 416     public InetAddress getInetAddress() {
 417         if (!isBound())
 418             return null;
 419         try {
 420             InetAddress in = getImpl().getInetAddress();
 421             SecurityManager sm = System.getSecurityManager();
 422             if (sm != null)
 423                 sm.checkConnect(in.getHostAddress(), -1);
 424             return in;
 425         } catch (SecurityException e) {
 426             return InetAddress.getLoopbackAddress();
 427         } catch (SocketException e) {
 428             // nothing
 429             // If we&#39;re bound, the impl has been created
 430             // so we shouldn&#39;t get here
 431         }
 432         return null;
 433     }
 434 
 435     /**
 436      * Returns the port number on which this socket is listening.
 437      * &lt;p&gt;
 438      * If the socket was bound prior to being {@link #close closed},
 439      * then this method will continue to return the port number
 440      * after the socket is closed.
 441      *
 442      * @return  the port number to which this socket is listening or
 443      *          -1 if the socket is not bound yet.
 444      */
 445     public int getLocalPort() {
 446         if (!isBound())
 447             return -1;
 448         try {
 449             return getImpl().getLocalPort();
 450         } catch (SocketException e) {
 451             // nothing
 452             // If we&#39;re bound, the impl has been created
 453             // so we shouldn&#39;t get here
 454         }
 455         return -1;
 456     }
 457 
 458     /**
 459      * Returns the address of the endpoint this socket is bound to.
 460      * &lt;p&gt;
 461      * If the socket was bound prior to being {@link #close closed},
 462      * then this method will continue to return the address of the endpoint
 463      * after the socket is closed.
 464      * &lt;p&gt;
 465      * If there is a security manager set, its {@code checkConnect} method is
 466      * called with the local address and {@code -1} as its arguments to see
 467      * if the operation is allowed. If the operation is not allowed,
 468      * a {@code SocketAddress} representing the
 469      * {@link InetAddress#getLoopbackAddress loopback} address and the local
 470      * port to which the socket is bound is returned.
 471      *
 472      * @return a {@code SocketAddress} representing the local endpoint of
 473      *         this socket, or a {@code SocketAddress} representing the
 474      *         loopback address if denied by the security manager,
 475      *         or {@code null} if the socket is not bound yet.
 476      *
 477      * @see #getInetAddress()
 478      * @see #getLocalPort()
 479      * @see #bind(SocketAddress)
 480      * @see SecurityManager#checkConnect
 481      * @since 1.4
 482      */
 483 
 484     public SocketAddress getLocalSocketAddress() {
 485         if (!isBound())
 486             return null;
 487         return new InetSocketAddress(getInetAddress(), getLocalPort());
 488     }
 489 
 490     /**
 491      * Listens for a connection to be made to this socket and accepts
 492      * it. The method blocks until a connection is made.
 493      *
 494      * &lt;p&gt;A new Socket {@code s} is created and, if there
 495      * is a security manager,
 496      * the security manager&#39;s {@code checkAccept} method is called
 497      * with {@code s.getInetAddress().getHostAddress()} and
 498      * {@code s.getPort()}
 499      * as its arguments to ensure the operation is allowed.
 500      * This could result in a SecurityException.
 501      *
<a name="26" id="anc26"></a><span class="line-modified"> 502      * @exception  IOException  if an I/O error occurs when waiting for a</span>






 503      *               connection.
<a name="27" id="anc27"></a><span class="line-modified"> 504      * @exception  SecurityException  if a security manager exists and its</span>
 505      *             {@code checkAccept} method doesn&#39;t allow the operation.
<a name="28" id="anc28"></a><span class="line-modified"> 506      * @exception  SocketTimeoutException if a timeout was previously set with setSoTimeout and</span>
 507      *             the timeout has been reached.
<a name="29" id="anc29"></a><span class="line-modified"> 508      * @exception  java.nio.channels.IllegalBlockingModeException</span>
 509      *             if this socket has an associated channel, the channel is in
 510      *             non-blocking mode, and there is no connection ready to be
 511      *             accepted
 512      *
 513      * @return the new Socket
 514      * @see SecurityManager#checkAccept
 515      * @revised 1.4
 516      * @spec JSR-51
 517      */
 518     public Socket accept() throws IOException {
 519         if (isClosed())
 520             throw new SocketException(&quot;Socket is closed&quot;);
 521         if (!isBound())
 522             throw new SocketException(&quot;Socket is not bound yet&quot;);
 523         Socket s = new Socket((SocketImpl) null);
 524         implAccept(s);
 525         return s;
 526     }
 527 
 528     /**
 529      * Subclasses of ServerSocket use this method to override accept()
 530      * to return their own subclass of socket.  So a FooServerSocket
<a name="30" id="anc30"></a><span class="line-modified"> 531      * will typically hand this method an &lt;i&gt;empty&lt;/i&gt; FooSocket.  On</span>
<span class="line-modified"> 532      * return from implAccept the FooSocket will be connected to a client.</span>
















 533      *
 534      * @param s the Socket
 535      * @throws java.nio.channels.IllegalBlockingModeException
 536      *         if this socket has an associated channel,
 537      *         and the channel is in non-blocking mode
 538      * @throws IOException if an I/O error occurs when waiting
<a name="31" id="anc31"></a><span class="line-modified"> 539      * for a connection.</span>


 540      * @since   1.1
 541      * @revised 1.4
 542      * @spec JSR-51
 543      */
 544     protected final void implAccept(Socket s) throws IOException {
<a name="32" id="anc32"></a><span class="line-modified"> 545         SocketImpl si = null;</span>
<span class="line-modified"> 546         try {</span>
<span class="line-modified"> 547             if (s.impl == null)</span>
<span class="line-modified"> 548               s.setImpl();</span>
<span class="line-modified"> 549             else {</span>
<span class="line-modified"> 550                 s.impl.reset();</span>






























 551             }
<a name="33" id="anc33"></a><span class="line-modified"> 552             si = s.impl;</span>
<span class="line-modified"> 553             s.impl = null;</span>
<span class="line-modified"> 554             si.address = new InetAddress();</span>
<span class="line-removed"> 555             si.fd = new FileDescriptor();</span>
<span class="line-removed"> 556             getImpl().accept(si);</span>
<span class="line-removed"> 557             SocketCleanable.register(si.fd);   // raw fd has been set</span>
 558 
<a name="34" id="anc34"></a><span class="line-modified"> 559             SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified"> 560             if (security != null) {</span>
<span class="line-modified"> 561                 security.checkAccept(si.getInetAddress().getHostAddress(),</span>
<span class="line-modified"> 562                                      si.getPort());</span>










 563             }
<a name="35" id="anc35"></a><span class="line-modified"> 564         } catch (IOException e) {</span>
<span class="line-modified"> 565             if (si != null)</span>
<span class="line-modified"> 566                 si.reset();</span>
<span class="line-modified"> 567             s.impl = si;</span>
<span class="line-modified"> 568             throw e;</span>
<span class="line-modified"> 569         } catch (SecurityException e) {</span>
<span class="line-modified"> 570             if (si != null)</span>
<span class="line-modified"> 571                 si.reset();</span>
<span class="line-modified"> 572             s.impl = si;</span>

























 573             throw e;
 574         }
<a name="36" id="anc36"></a><span class="line-modified"> 575         s.impl = si;</span>
<span class="line-modified"> 576         s.postAccept();</span>


































 577     }
 578 
 579     /**
 580      * Closes this socket.
 581      *
 582      * Any thread currently blocked in {@link #accept()} will throw
 583      * a {@link SocketException}.
 584      *
 585      * &lt;p&gt; If this socket has an associated channel then the channel is closed
 586      * as well.
 587      *
<a name="37" id="anc37"></a><span class="line-modified"> 588      * @exception  IOException  if an I/O error occurs when closing the socket.</span>
 589      * @revised 1.4
 590      * @spec JSR-51
 591      */
 592     public void close() throws IOException {
 593         synchronized(closeLock) {
 594             if (isClosed())
 595                 return;
 596             if (created)
 597                 impl.close();
 598             closed = true;
 599         }
 600     }
 601 
 602     /**
 603      * Returns the unique {@link java.nio.channels.ServerSocketChannel} object
 604      * associated with this socket, if any.
 605      *
 606      * &lt;p&gt; A server socket will have a channel if, and only if, the channel
 607      * itself was created via the {@link
 608      * java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}
 609      * method.
 610      *
 611      * @return  the server-socket channel associated with this socket,
 612      *          or {@code null} if this socket was not created
 613      *          for a channel
 614      *
 615      * @since 1.4
 616      * @spec JSR-51
 617      */
 618     public ServerSocketChannel getChannel() {
 619         return null;
 620     }
 621 
 622     /**
 623      * Returns the binding state of the ServerSocket.
<a name="38" id="anc38"></a>



 624      *
 625      * @return true if the ServerSocket successfully bound to an address
 626      * @since 1.4
 627      */
 628     public boolean isBound() {
<a name="39" id="anc39"></a><span class="line-modified"> 629         // Before 1.3 ServerSockets were always bound during creation</span>
<span class="line-removed"> 630         return bound || oldImpl;</span>
 631     }
 632 
 633     /**
 634      * Returns the closed state of the ServerSocket.
 635      *
 636      * @return true if the socket has been closed
 637      * @since 1.4
 638      */
 639     public boolean isClosed() {
 640         synchronized(closeLock) {
 641             return closed;
 642         }
 643     }
 644 
 645     /**
 646      * Enable/disable {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} with the
<a name="40" id="anc40"></a><span class="line-modified"> 647      * specified timeout, in milliseconds.  With this option set to a non-zero</span>
<span class="line-modified"> 648      * timeout, a call to accept() for this ServerSocket</span>
 649      * will block for only this amount of time.  If the timeout expires,
 650      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
<a name="41" id="anc41"></a><span class="line-modified"> 651      * ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="line-modified"> 652      * prior to entering the blocking operation to have effect.  The</span>
<span class="line-modified"> 653      * timeout must be {@code &gt; 0}.</span>
<span class="line-modified"> 654      * A timeout of zero is interpreted as an infinite timeout.</span>

 655      * @param timeout the specified timeout, in milliseconds
<a name="42" id="anc42"></a><span class="line-modified"> 656      * @exception SocketException if there is an error in</span>
<span class="line-modified"> 657      * the underlying protocol, such as a TCP error.</span>

 658      * @since   1.1
 659      * @see #getSoTimeout()
 660      */
 661     public synchronized void setSoTimeout(int timeout) throws SocketException {
 662         if (isClosed())
 663             throw new SocketException(&quot;Socket is closed&quot;);
<a name="43" id="anc43"></a>

 664         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
 665     }
 666 
 667     /**
 668      * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.
 669      * 0 returns implies that the option is disabled (i.e., timeout of infinity).
 670      * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value
<a name="44" id="anc44"></a><span class="line-modified"> 671      * @exception IOException if an I/O error occurs</span>
 672      * @since   1.1
 673      * @see #setSoTimeout(int)
 674      */
 675     public synchronized int getSoTimeout() throws IOException {
 676         if (isClosed())
 677             throw new SocketException(&quot;Socket is closed&quot;);
 678         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
 679         /* extra type safety */
 680         if (o instanceof Integer) {
 681             return ((Integer) o).intValue();
 682         } else {
 683             return 0;
 684         }
 685     }
 686 
 687     /**
 688      * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 689      * socket option.
 690      * &lt;p&gt;
 691      * When a TCP connection is closed the connection may remain
 692      * in a timeout state for a period of time after the connection
 693      * is closed (typically known as the {@code TIME_WAIT} state
 694      * or {@code 2MSL} wait state).
 695      * For applications using a well known socket address or port
 696      * it may not be possible to bind a socket to the required
 697      * {@code SocketAddress} if there is a connection in the
 698      * timeout state involving the socket address or port.
 699      * &lt;p&gt;
 700      * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} prior to
 701      * binding the socket using {@link #bind(SocketAddress)} allows the socket
 702      * to be bound even though a previous connection is in a timeout state.
 703      * &lt;p&gt;
 704      * When a {@code ServerSocket} is created the initial setting
 705      * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is not defined.
 706      * Applications can use {@link #getReuseAddress()} to determine the initial
 707      * setting of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}.
 708      * &lt;p&gt;
 709      * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is
 710      * enabled or disabled after a socket is bound (See {@link #isBound()})
 711      * is not defined.
 712      *
 713      * @param on  whether to enable or disable the socket option
<a name="45" id="anc45"></a><span class="line-modified"> 714      * @exception SocketException if an error occurs enabling or</span>
 715      *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}
 716      *            socket option, or the socket is closed.
 717      * @since 1.4
 718      * @see #getReuseAddress()
 719      * @see #bind(SocketAddress)
 720      * @see #isBound()
 721      * @see #isClosed()
 722      */
 723     public void setReuseAddress(boolean on) throws SocketException {
 724         if (isClosed())
 725             throw new SocketException(&quot;Socket is closed&quot;);
 726         getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
 727     }
 728 
 729     /**
 730      * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
 731      *
 732      * @return a {@code boolean} indicating whether or not
 733      *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.
<a name="46" id="anc46"></a><span class="line-modified"> 734      * @exception SocketException if there is an error</span>
 735      * in the underlying protocol, such as a TCP error.
 736      * @since   1.4
 737      * @see #setReuseAddress(boolean)
 738      */
 739     public boolean getReuseAddress() throws SocketException {
 740         if (isClosed())
 741             throw new SocketException(&quot;Socket is closed&quot;);
 742         return ((Boolean) (getImpl().getOption(SocketOptions.SO_REUSEADDR))).booleanValue();
 743     }
 744 
 745     /**
 746      * Returns the implementation address and implementation port of
 747      * this socket as a {@code String}.
 748      * &lt;p&gt;
<a name="47" id="anc47"></a><span class="line-modified"> 749      * If there is a security manager set, its {@code checkConnect} method is</span>

 750      * called with the local address and {@code -1} as its arguments to see
 751      * if the operation is allowed. If the operation is not allowed,
 752      * an {@code InetAddress} representing the
 753      * {@link InetAddress#getLoopbackAddress loopback} address is returned as
 754      * the implementation address.
 755      *
 756      * @return  a string representation of this socket.
 757      */
 758     public String toString() {
 759         if (!isBound())
 760             return &quot;ServerSocket[unbound]&quot;;
 761         InetAddress in;
 762         if (System.getSecurityManager() != null)
<a name="48" id="anc48"></a><span class="line-modified"> 763             in = InetAddress.getLoopbackAddress();</span>
 764         else
 765             in = impl.getInetAddress();
 766         return &quot;ServerSocket[addr=&quot; + in +
 767                 &quot;,localport=&quot; + impl.getLocalPort()  + &quot;]&quot;;
 768     }
 769 
<a name="49" id="anc49"></a><span class="line-removed"> 770     void setBound() {</span>
<span class="line-removed"> 771         bound = true;</span>
<span class="line-removed"> 772     }</span>
<span class="line-removed"> 773 </span>
<span class="line-removed"> 774     void setCreated() {</span>
<span class="line-removed"> 775         created = true;</span>
<span class="line-removed"> 776     }</span>
<span class="line-removed"> 777 </span>
 778     /**
 779      * The factory for all server sockets.
 780      */
<a name="50" id="anc50"></a><span class="line-modified"> 781     private static SocketImplFactory factory = null;</span>
 782 
 783     /**
 784      * Sets the server socket implementation factory for the
 785      * application. The factory can be specified only once.
 786      * &lt;p&gt;
 787      * When an application creates a new server socket, the socket
 788      * implementation factory&#39;s {@code createSocketImpl} method is
 789      * called to create the actual socket implementation.
 790      * &lt;p&gt;
 791      * Passing {@code null} to the method is a no-op unless the factory
 792      * was already set.
 793      * &lt;p&gt;
 794      * If there is a security manager, this method first calls
 795      * the security manager&#39;s {@code checkSetFactory} method
 796      * to ensure the operation is allowed.
 797      * This could result in a SecurityException.
 798      *
 799      * @param      fac   the desired factory.
<a name="51" id="anc51"></a><span class="line-modified"> 800      * @exception  IOException  if an I/O error occurs when setting the</span>
 801      *               socket factory.
<a name="52" id="anc52"></a><span class="line-modified"> 802      * @exception  SocketException  if the factory has already been defined.</span>
<span class="line-modified"> 803      * @exception  SecurityException  if a security manager exists and its</span>
 804      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 805      * @see        java.net.SocketImplFactory#createSocketImpl()
 806      * @see        SecurityManager#checkSetFactory
 807      */
 808     public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException {
 809         if (factory != null) {
 810             throw new SocketException(&quot;factory already defined&quot;);
 811         }
 812         SecurityManager security = System.getSecurityManager();
 813         if (security != null) {
 814             security.checkSetFactory();
 815         }
 816         factory = fac;
 817     }
 818 
 819     /**
 820      * Sets a default proposed value for the
 821      * {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option for sockets
 822      * accepted from this {@code ServerSocket}. The value actually set
 823      * in the accepted socket must be determined by calling
 824      * {@link Socket#getReceiveBufferSize()} after the socket
 825      * is returned by {@link #accept()}.
 826      * &lt;p&gt;
 827      * The value of {@link SocketOptions#SO_RCVBUF SO_RCVBUF} is used both to
 828      * set the size of the internal socket receive buffer, and to set the size
 829      * of the TCP receive window that is advertised to the remote peer.
 830      * &lt;p&gt;
 831      * It is possible to change the value subsequently, by calling
 832      * {@link Socket#setReceiveBufferSize(int)}. However, if the application
 833      * wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
 834      * then the proposed value must be set in the ServerSocket &lt;B&gt;before&lt;/B&gt;
 835      * it is bound to a local address. This implies, that the ServerSocket must be
 836      * created with the no-argument constructor, then setReceiveBufferSize() must
 837      * be called and lastly the ServerSocket is bound to an address by calling bind().
 838      * &lt;p&gt;
 839      * Failure to do this will not cause an error, and the buffer size may be set to the
 840      * requested value but the TCP receive window in sockets accepted from
 841      * this ServerSocket will be no larger than 64K bytes.
 842      *
<a name="53" id="anc53"></a><span class="line-modified"> 843      * @exception SocketException if there is an error</span>
 844      * in the underlying protocol, such as a TCP error.
 845      *
 846      * @param size the size to which to set the receive buffer
 847      * size. This value must be greater than 0.
 848      *
<a name="54" id="anc54"></a><span class="line-modified"> 849      * @exception IllegalArgumentException if the</span>
 850      * value is 0 or is negative.
 851      *
 852      * @since 1.4
 853      * @see #getReceiveBufferSize
 854      */
 855      public synchronized void setReceiveBufferSize (int size) throws SocketException {
 856         if (!(size &gt; 0)) {
 857             throw new IllegalArgumentException(&quot;negative receive size&quot;);
 858         }
 859         if (isClosed())
 860             throw new SocketException(&quot;Socket is closed&quot;);
 861         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
 862     }
 863 
 864     /**
 865      * Gets the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF} option
 866      * for this {@code ServerSocket}, that is the proposed buffer size that
 867      * will be used for Sockets accepted from this {@code ServerSocket}.
 868      *
 869      * &lt;p&gt;Note, the value actually set in the accepted socket is determined by
 870      * calling {@link Socket#getReceiveBufferSize()}.
 871      * @return the value of the {@link SocketOptions#SO_RCVBUF SO_RCVBUF}
 872      *         option for this {@code Socket}.
<a name="55" id="anc55"></a><span class="line-modified"> 873      * @exception SocketException if there is an error</span>
 874      *            in the underlying protocol, such as a TCP error.
 875      * @see #setReceiveBufferSize(int)
 876      * @since 1.4
 877      */
 878     public synchronized int getReceiveBufferSize()
 879     throws SocketException{
 880         if (isClosed())
 881             throw new SocketException(&quot;Socket is closed&quot;);
 882         int result = 0;
 883         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
 884         if (o instanceof Integer) {
 885             result = ((Integer)o).intValue();
 886         }
 887         return result;
 888     }
 889 
 890     /**
 891      * Sets performance preferences for this ServerSocket.
 892      *
 893      * &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
 894      * may offer alternative protocols which have different performance
 895      * characteristics than TCP/IP.  This method allows the application to
 896      * express its own preferences as to how these tradeoffs should be made
 897      * when the implementation chooses from the available protocols.
 898      *
 899      * &lt;p&gt; Performance preferences are described by three integers
 900      * whose values indicate the relative importance of short connection time,
 901      * low latency, and high bandwidth.  The absolute values of the integers
 902      * are irrelevant; in order to choose a protocol the values are simply
 903      * compared, with larger values indicating stronger preferences.  If the
 904      * application prefers short connection time over both low latency and high
 905      * bandwidth, for example, then it could invoke this method with the values
 906      * {@code (1, 0, 0)}.  If the application prefers high bandwidth above low
 907      * latency, and low latency above short connection time, then it could
 908      * invoke this method with the values {@code (0, 1, 2)}.
 909      *
 910      * &lt;p&gt; Invoking this method after this socket has been bound
 911      * will have no effect. This implies that in order to use this capability
 912      * requires the socket to be created with the no-argument constructor.
 913      *
 914      * @param  connectionTime
 915      *         An {@code int} expressing the relative importance of a short
 916      *         connection time
 917      *
 918      * @param  latency
 919      *         An {@code int} expressing the relative importance of low
 920      *         latency
 921      *
 922      * @param  bandwidth
 923      *         An {@code int} expressing the relative importance of high
 924      *         bandwidth
 925      *
 926      * @since 1.5
 927      */
 928     public void setPerformancePreferences(int connectionTime,
 929                                           int latency,
 930                                           int bandwidth)
 931     {
 932         /* Not implemented yet */
 933     }
 934 
 935     /**
 936      * Sets the value of a socket option.
 937      *
 938      * @param &lt;T&gt; The type of the socket option value
 939      * @param name The socket option
 940      * @param value The value of the socket option. A value of {@code null}
 941      *              may be valid for some options.
 942      * @return this ServerSocket
 943      *
 944      * @throws UnsupportedOperationException if the server socket does not
 945      *         support the option.
 946      *
 947      * @throws IllegalArgumentException if the value is not valid for
 948      *         the option.
 949      *
 950      * @throws IOException if an I/O error occurs, or if the socket is closed.
 951      *
 952      * @throws NullPointerException if name is {@code null}
 953      *
 954      * @throws SecurityException if a security manager is set and if the socket
 955      *         option requires a security permission and if the caller does
 956      *         not have the required permission.
 957      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
 958      *         do not require any security permission.
 959      *
 960      * @since 9
 961      */
 962     public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value)
 963         throws IOException
 964     {
<a name="56" id="anc56"></a>


 965         getImpl().setOption(name, value);
 966         return this;
 967     }
 968 
 969     /**
 970      * Returns the value of a socket option.
 971      *
 972      * @param &lt;T&gt; The type of the socket option value
 973      * @param name The socket option
 974      *
 975      * @return The value of the socket option.
 976      *
 977      * @throws UnsupportedOperationException if the server socket does not
 978      *         support the option.
 979      *
 980      * @throws IOException if an I/O error occurs, or if the socket is closed.
 981      *
 982      * @throws NullPointerException if name is {@code null}
 983      *
 984      * @throws SecurityException if a security manager is set and if the socket
 985      *         option requires a security permission and if the caller does
 986      *         not have the required permission.
 987      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
 988      *         do not require any security permission.
 989      *
 990      * @since 9
 991      */
 992     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<a name="57" id="anc57"></a>


 993         return getImpl().getOption(name);
 994     }
 995 
 996     // cache of unmodifiable impl options. Possibly set racy, in impl we trust
 997     private volatile Set&lt;SocketOption&lt;?&gt;&gt; options;
 998 
 999     /**
1000      * Returns a set of the socket options supported by this server socket.
1001      *
1002      * This method will continue to return the set of options even after
1003      * the socket has been closed.
1004      *
1005      * @return A set of the socket options supported by this socket. This set
1006      *         may be empty if the socket&#39;s SocketImpl cannot be created.
1007      *
1008      * @since 9
1009      */
1010     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1011         Set&lt;SocketOption&lt;?&gt;&gt; so = options;
1012         if (so != null)
1013             return so;
1014 
1015         try {
1016             SocketImpl impl = getImpl();
1017             options = Collections.unmodifiableSet(impl.supportedOptions());
1018         } catch (IOException e) {
1019             options = Collections.emptySet();
1020         }
1021         return options;
1022     }
<a name="58" id="anc58"></a><span class="line-removed">1023 </span>
<span class="line-removed">1024     static {</span>
<span class="line-removed">1025         SharedSecrets.setJavaNetSocketAccess(</span>
<span class="line-removed">1026             new JavaNetSocketAccess() {</span>
<span class="line-removed">1027                 @Override</span>
<span class="line-removed">1028                 public ServerSocket newServerSocket(SocketImpl impl) {</span>
<span class="line-removed">1029                     return new ServerSocket(impl);</span>
<span class="line-removed">1030                 }</span>
<span class="line-removed">1031 </span>
<span class="line-removed">1032                 @Override</span>
<span class="line-removed">1033                 public SocketImpl newSocketImpl(Class&lt;? extends SocketImpl&gt; implClass) {</span>
<span class="line-removed">1034                     try {</span>
<span class="line-removed">1035                         Constructor&lt;? extends SocketImpl&gt; ctor =</span>
<span class="line-removed">1036                             implClass.getDeclaredConstructor();</span>
<span class="line-removed">1037                         return ctor.newInstance();</span>
<span class="line-removed">1038                     } catch (NoSuchMethodException | InstantiationException |</span>
<span class="line-removed">1039                              IllegalAccessException | InvocationTargetException e) {</span>
<span class="line-removed">1040                         throw new AssertionError(e);</span>
<span class="line-removed">1041                     }</span>
<span class="line-removed">1042                 }</span>
<span class="line-removed">1043             }</span>
<span class="line-removed">1044         );</span>
<span class="line-removed">1045     }</span>
1046 }
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/FileOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.nio.channels.FileChannel;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.access.JavaIOFileDescriptorAccess;
 31 import sun.nio.ch.FileChannelImpl;
 32 
 33 
 34 /**
 35  * A file output stream is an output stream for writing data to a
<a name="2" id="anc2"></a><span class="line-modified"> 36  * &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;. Whether or not</span>
 37  * a file is available or may be created depends upon the underlying
 38  * platform.  Some platforms, in particular, allow a file to be opened
 39  * for writing by only one {@code FileOutputStream} (or other
 40  * file-writing object) at a time.  In such situations the constructors in
 41  * this class will fail if the file involved is already open.
 42  *
<a name="3" id="anc3"></a><span class="line-modified"> 43  * &lt;p&gt;&lt;code&gt;FileOutputStream&lt;/code&gt; is meant for writing streams of raw bytes</span>
 44  * such as image data. For writing streams of characters, consider using
<a name="4" id="anc4"></a><span class="line-modified"> 45  * &lt;code&gt;FileWriter&lt;/code&gt;.</span>
 46  *
 47  * @apiNote
 48  * To release resources used by this stream {@link #close} should be called
 49  * directly or by try-with-resources. Subclasses are responsible for the cleanup
 50  * of resources acquired by the subclass.
 51  * Subclasses that override {@link #finalize} in order to perform cleanup
 52  * should be modified to use alternative cleanup mechanisms such as
 53  * {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.
 54  *
 55  * @implSpec
 56  * If this FileOutputStream has been subclassed and the {@link #close}
 57  * method has been overridden, the {@link #close} method will be
 58  * called when the FileInputStream is unreachable.
 59  * Otherwise, it is implementation specific how the resource cleanup described in
 60  * {@link #close} is performed.
 61  *
 62  * @author  Arthur van Hoff
 63  * @see     java.io.File
 64  * @see     java.io.FileDescriptor
 65  * @see     java.io.FileInputStream
 66  * @see     java.nio.file.Files#newOutputStream
 67  * @since   1.0
 68  */
<a name="5" id="anc5"></a><span class="line-modified"> 69 public</span>
<span class="line-removed"> 70 class FileOutputStream extends OutputStream</span>
 71 {
 72     /**
 73      * Access to FileDescriptor internals.
 74      */
 75     private static final JavaIOFileDescriptorAccess fdAccess =
 76         SharedSecrets.getJavaIOFileDescriptorAccess();
 77 
 78     /**
 79      * The system dependent file descriptor.
 80      */
 81     private final FileDescriptor fd;
 82 
 83     /**
 84      * The associated channel, initialized lazily.
 85      */
 86     private volatile FileChannel channel;
 87 
 88     /**
 89      * The path of the referenced file
 90      * (null if the stream is created with a file descriptor)
 91      */
 92     private final String path;
 93 
 94     private final Object closeLock = new Object();
 95 
 96     private volatile boolean closed;
 97 
 98     /**
 99      * Creates a file output stream to write to the file with the
<a name="6" id="anc6"></a><span class="line-modified">100      * specified name. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is</span>
101      * created to represent this file connection.
102      * &lt;p&gt;
<a name="7" id="anc7"></a><span class="line-modified">103      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">104      * method is called with &lt;code&gt;name&lt;/code&gt; as its argument.</span>
105      * &lt;p&gt;
106      * If the file exists but is a directory rather than a regular file, does
107      * not exist but cannot be created, or cannot be opened for any other
<a name="8" id="anc8"></a><span class="line-modified">108      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
109      *
110      * @implSpec Invoking this constructor with the parameter {@code name} is
111      * equivalent to invoking {@link #FileOutputStream(String,boolean)
112      * new FileOutputStream(name, false)}.
113      *
114      * @param      name   the system-dependent filename
<a name="9" id="anc9"></a><span class="line-modified">115      * @exception  FileNotFoundException  if the file exists but is a directory</span>
116      *                   rather than a regular file, does not exist but cannot
117      *                   be created, or cannot be opened for any other reason
<a name="10" id="anc10"></a><span class="line-modified">118      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">119      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
120      *               to the file.
121      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
122      */
123     public FileOutputStream(String name) throws FileNotFoundException {
124         this(name != null ? new File(name) : null, false);
125     }
126 
127     /**
128      * Creates a file output stream to write to the file with the specified
<a name="11" id="anc11"></a><span class="line-modified">129      * name.  If the second argument is &lt;code&gt;true&lt;/code&gt;, then</span>
130      * bytes will be written to the end of the file rather than the beginning.
<a name="12" id="anc12"></a><span class="line-modified">131      * A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this</span>
132      * file connection.
133      * &lt;p&gt;
<a name="13" id="anc13"></a><span class="line-modified">134      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">135      * method is called with &lt;code&gt;name&lt;/code&gt; as its argument.</span>
136      * &lt;p&gt;
137      * If the file exists but is a directory rather than a regular file, does
138      * not exist but cannot be created, or cannot be opened for any other
<a name="14" id="anc14"></a><span class="line-modified">139      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
140      *
141      * @param     name        the system-dependent file name
<a name="15" id="anc15"></a><span class="line-modified">142      * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written</span>
143      *                   to the end of the file rather than the beginning
<a name="16" id="anc16"></a><span class="line-modified">144      * @exception  FileNotFoundException  if the file exists but is a directory</span>
145      *                   rather than a regular file, does not exist but cannot
146      *                   be created, or cannot be opened for any other reason.
<a name="17" id="anc17"></a><span class="line-modified">147      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">148      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
149      *               to the file.
150      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
151      * @since     1.1
152      */
153     public FileOutputStream(String name, boolean append)
154         throws FileNotFoundException
155     {
156         this(name != null ? new File(name) : null, append);
157     }
158 
159     /**
160      * Creates a file output stream to write to the file represented by
<a name="18" id="anc18"></a><span class="line-modified">161      * the specified &lt;code&gt;File&lt;/code&gt; object. A new</span>
<span class="line-modified">162      * &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this</span>
163      * file connection.
164      * &lt;p&gt;
<a name="19" id="anc19"></a><span class="line-modified">165      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">166      * method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;</span>
167      * argument as its argument.
168      * &lt;p&gt;
169      * If the file exists but is a directory rather than a regular file, does
170      * not exist but cannot be created, or cannot be opened for any other
<a name="20" id="anc20"></a><span class="line-modified">171      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
172      *
173      * @param      file               the file to be opened for writing.
<a name="21" id="anc21"></a><span class="line-modified">174      * @exception  FileNotFoundException  if the file exists but is a directory</span>
175      *                   rather than a regular file, does not exist but cannot
176      *                   be created, or cannot be opened for any other reason
<a name="22" id="anc22"></a><span class="line-modified">177      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">178      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
179      *               to the file.
180      * @see        java.io.File#getPath()
181      * @see        java.lang.SecurityException
182      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
183      */
184     public FileOutputStream(File file) throws FileNotFoundException {
185         this(file, false);
186     }
187 
188     /**
189      * Creates a file output stream to write to the file represented by
<a name="23" id="anc23"></a><span class="line-modified">190      * the specified &lt;code&gt;File&lt;/code&gt; object. If the second argument is</span>
<span class="line-modified">191      * &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file</span>
<span class="line-modified">192      * rather than the beginning. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is</span>
193      * created to represent this file connection.
194      * &lt;p&gt;
<a name="24" id="anc24"></a><span class="line-modified">195      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">196      * method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;</span>
197      * argument as its argument.
198      * &lt;p&gt;
199      * If the file exists but is a directory rather than a regular file, does
200      * not exist but cannot be created, or cannot be opened for any other
<a name="25" id="anc25"></a><span class="line-modified">201      * reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</span>
202      *
203      * @param      file               the file to be opened for writing.
<a name="26" id="anc26"></a><span class="line-modified">204      * @param     append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written</span>
205      *                   to the end of the file rather than the beginning
<a name="27" id="anc27"></a><span class="line-modified">206      * @exception  FileNotFoundException  if the file exists but is a directory</span>
207      *                   rather than a regular file, does not exist but cannot
208      *                   be created, or cannot be opened for any other reason
<a name="28" id="anc28"></a><span class="line-modified">209      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">210      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access</span>
211      *               to the file.
212      * @see        java.io.File#getPath()
213      * @see        java.lang.SecurityException
214      * @see        java.lang.SecurityManager#checkWrite(java.lang.String)
215      * @since 1.4
216      */
217     public FileOutputStream(File file, boolean append)
218         throws FileNotFoundException
219     {
220         String name = (file != null ? file.getPath() : null);
221         SecurityManager security = System.getSecurityManager();
222         if (security != null) {
223             security.checkWrite(name);
224         }
225         if (name == null) {
226             throw new NullPointerException();
227         }
228         if (file.isInvalid()) {
229             throw new FileNotFoundException(&quot;Invalid file path&quot;);
230         }
231         this.fd = new FileDescriptor();
232         fd.attach(this);
233         this.path = name;
234 
235         open(name, append);
236         FileCleanable.register(fd);   // open sets the fd, register the cleanup
237     }
238 
239     /**
240      * Creates a file output stream to write to the specified file
241      * descriptor, which represents an existing connection to an actual
242      * file in the file system.
243      * &lt;p&gt;
<a name="29" id="anc29"></a><span class="line-modified">244      * First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;</span>
<span class="line-modified">245      * method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt;</span>
246      * argument as its argument.
247      * &lt;p&gt;
<a name="30" id="anc30"></a><span class="line-modified">248      * If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt;</span>
249      * is thrown.
250      * &lt;p&gt;
<a name="31" id="anc31"></a><span class="line-modified">251      * This constructor does not throw an exception if &lt;code&gt;fdObj&lt;/code&gt;</span>
252      * is {@link java.io.FileDescriptor#valid() invalid}.
253      * However, if the methods are invoked on the resulting stream to attempt
<a name="32" id="anc32"></a><span class="line-modified">254      * I/O on the stream, an &lt;code&gt;IOException&lt;/code&gt; is thrown.</span>
255      *
256      * @param      fdObj   the file descriptor to be opened for writing
<a name="33" id="anc33"></a><span class="line-modified">257      * @exception  SecurityException  if a security manager exists and its</span>
<span class="line-modified">258      *               &lt;code&gt;checkWrite&lt;/code&gt; method denies</span>
259      *               write access to the file descriptor
260      * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)
261      */
262     public FileOutputStream(FileDescriptor fdObj) {
263         SecurityManager security = System.getSecurityManager();
264         if (fdObj == null) {
265             throw new NullPointerException();
266         }
267         if (security != null) {
268             security.checkWrite(fdObj);
269         }
270         this.fd = fdObj;
271         this.path = null;
272 
273         fd.attach(this);
274     }
275 
276     /**
277      * Opens a file, with the specified name, for overwriting or appending.
278      * @param name name of file to be opened
279      * @param append whether the file is to be opened in append mode
280      */
281     private native void open0(String name, boolean append)
282         throws FileNotFoundException;
283 
284     // wrap native call to allow instrumentation
285     /**
286      * Opens a file, with the specified name, for overwriting or appending.
287      * @param name name of file to be opened
288      * @param append whether the file is to be opened in append mode
289      */
290     private void open(String name, boolean append)
291         throws FileNotFoundException {
292         open0(name, append);
293     }
294 
295     /**
296      * Writes the specified byte to this file output stream.
297      *
298      * @param   b   the byte to be written.
299      * @param   append   {@code true} if the write operation first
300      *     advances the position to the end of file
301      */
302     private native void write(int b, boolean append) throws IOException;
303 
304     /**
305      * Writes the specified byte to this file output stream. Implements
<a name="34" id="anc34"></a><span class="line-modified">306      * the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</span>
307      *
308      * @param      b   the byte to be written.
<a name="35" id="anc35"></a><span class="line-modified">309      * @exception  IOException  if an I/O error occurs.</span>
310      */
311     public void write(int b) throws IOException {
312         write(b, fdAccess.getAppend(fd));
313     }
314 
315     /**
316      * Writes a sub array as a sequence of bytes.
317      * @param b the data to be written
318      * @param off the start offset in the data
319      * @param len the number of bytes that are written
320      * @param append {@code true} to first advance the position to the
321      *     end of file
<a name="36" id="anc36"></a><span class="line-modified">322      * @exception IOException If an I/O error has occurred.</span>
323      */
324     private native void writeBytes(byte b[], int off, int len, boolean append)
325         throws IOException;
326 
327     /**
<a name="37" id="anc37"></a><span class="line-modified">328      * Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array</span>
329      * to this file output stream.
330      *
331      * @param      b   the data.
<a name="38" id="anc38"></a><span class="line-modified">332      * @exception  IOException  if an I/O error occurs.</span>
333      */
334     public void write(byte b[]) throws IOException {
335         writeBytes(b, 0, b.length, fdAccess.getAppend(fd));
336     }
337 
338     /**
<a name="39" id="anc39"></a><span class="line-modified">339      * Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array</span>
<span class="line-modified">340      * starting at offset &lt;code&gt;off&lt;/code&gt; to this file output stream.</span>
341      *
342      * @param      b     the data.
343      * @param      off   the start offset in the data.
344      * @param      len   the number of bytes to write.
<a name="40" id="anc40"></a><span class="line-modified">345      * @exception  IOException  if an I/O error occurs.</span>
346      */
347     public void write(byte b[], int off, int len) throws IOException {
348         writeBytes(b, off, len, fdAccess.getAppend(fd));
349     }
350 
351     /**
352      * Closes this file output stream and releases any system resources
353      * associated with this stream. This file output stream may no longer
354      * be used for writing bytes.
355      *
356      * &lt;p&gt; If this stream has an associated channel then the channel is closed
357      * as well.
358      *
359      * @apiNote
360      * Overriding {@link #close} to perform cleanup actions is reliable
361      * only when called directly or when called by try-with-resources.
362      * Do not depend on finalization to invoke {@code close};
363      * finalization is not reliable and is deprecated.
364      * If cleanup of native resources is needed, other mechanisms such as
365      * {@linkplain java.lang.ref.Cleaner} should be used.
366      *
<a name="41" id="anc41"></a><span class="line-modified">367      * @exception  IOException  if an I/O error occurs.</span>
368      *
369      * @revised 1.4
370      * @spec JSR-51
371      */
372     public void close() throws IOException {
373         if (closed) {
374             return;
375         }
376         synchronized (closeLock) {
377             if (closed) {
378                 return;
379             }
380             closed = true;
381         }
382 
383         FileChannel fc = channel;
384         if (fc != null) {
385             // possible race with getChannel(), benign since
386             // FileChannel.close is final and idempotent
387             fc.close();
388         }
389 
390         fd.closeAll(new Closeable() {
391             public void close() throws IOException {
392                fd.close();
393            }
394         });
395     }
396 
397     /**
398      * Returns the file descriptor associated with this stream.
399      *
<a name="42" id="anc42"></a><span class="line-modified">400      * @return  the &lt;code&gt;FileDescriptor&lt;/code&gt; object that represents</span>
401      *          the connection to the file in the file system being used
<a name="43" id="anc43"></a><span class="line-modified">402      *          by this &lt;code&gt;FileOutputStream&lt;/code&gt; object.</span>
403      *
<a name="44" id="anc44"></a><span class="line-modified">404      * @exception  IOException  if an I/O error occurs.</span>
405      * @see        java.io.FileDescriptor
406      */
407      public final FileDescriptor getFD()  throws IOException {
408         if (fd != null) {
409             return fd;
410         }
411         throw new IOException();
412      }
413 
414     /**
415      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
416      * object associated with this file output stream.
417      *
418      * &lt;p&gt; The initial {@link java.nio.channels.FileChannel#position()
419      * position} of the returned channel will be equal to the
420      * number of bytes written to the file so far unless this stream is in
421      * append mode, in which case it will be equal to the size of the file.
422      * Writing bytes to this stream will increment the channel&#39;s position
423      * accordingly.  Changing the channel&#39;s position, either explicitly or by
424      * writing, will change this stream&#39;s file position.
425      *
426      * @return  the file channel associated with this file output stream
427      *
428      * @since 1.4
429      * @spec JSR-51
430      */
431     public FileChannel getChannel() {
432         FileChannel fc = this.channel;
433         if (fc == null) {
434             synchronized (this) {
435                 fc = this.channel;
436                 if (fc == null) {
437                     this.channel = fc = FileChannelImpl.open(fd, path, false,
438                         true, false, this);
439                     if (closed) {
440                         try {
441                             // possible race with close(), benign since
442                             // FileChannel.close is final and idempotent
443                             fc.close();
444                         } catch (IOException ioe) {
445                             throw new InternalError(ioe); // should not happen
446                         }
447                     }
448                 }
449             }
450         }
451         return fc;
452     }
453 
454     private static native void initIDs();
455 
456     static {
457         initIDs();
458     }
459 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
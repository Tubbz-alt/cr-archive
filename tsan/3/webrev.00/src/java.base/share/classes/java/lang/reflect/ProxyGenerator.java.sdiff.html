<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Proxy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
<span class="line-modified">  28 import java.io.ByteArrayOutputStream;</span>
<span class="line-modified">  29 import java.io.DataOutputStream;</span>
<span class="line-modified">  30 import java.io.File;</span>



  31 import java.io.IOException;
<span class="line-modified">  32 import java.io.OutputStream;</span>
<span class="line-removed">  33 import java.lang.reflect.Array;</span>
<span class="line-removed">  34 import java.lang.reflect.Method;</span>
  35 import java.nio.file.Files;
  36 import java.nio.file.Path;
  37 import java.util.ArrayList;

  38 import java.util.HashMap;

  39 import java.util.LinkedList;
  40 import java.util.List;
  41 import java.util.ListIterator;
  42 import java.util.Map;
<span class="line-modified">  43 import sun.security.action.GetBooleanAction;</span>

  44 
  45 /**
  46  * ProxyGenerator contains the code to generate a dynamic proxy class
  47  * for the java.lang.reflect.Proxy API.
<span class="line-modified">  48  *</span>
<span class="line-modified">  49  * The external interfaces to ProxyGenerator is the static</span>
  50  * &quot;generateProxyClass&quot; method.
<span class="line-removed">  51  *</span>
<span class="line-removed">  52  * @author      Peter Jones</span>
<span class="line-removed">  53  * @since       1.3</span>
  54  */
<span class="line-modified">  55 class ProxyGenerator {</span>
<span class="line-removed">  56     /*</span>
<span class="line-removed">  57      * In the comments below, &quot;JVMS&quot; refers to The Java Virtual Machine</span>
<span class="line-removed">  58      * Specification Second Edition and &quot;JLS&quot; refers to the original</span>
<span class="line-removed">  59      * version of The Java Language Specification, unless otherwise</span>
<span class="line-removed">  60      * specified.</span>
<span class="line-removed">  61      */</span>
  62 
<span class="line-modified">  63     /* generate 1.5-era class file version */</span>
<span class="line-modified">  64     private static final int CLASSFILE_MAJOR_VERSION = 49;</span>
<span class="line-modified">  65     private static final int CLASSFILE_MINOR_VERSION = 0;</span>




  66 
<span class="line-modified">  67     /*</span>
<span class="line-modified">  68      * beginning of constants copied from</span>
<span class="line-modified">  69      * sun.tools.java.RuntimeConstants (which no longer exists):</span>
<span class="line-removed">  70      */</span>
  71 
<span class="line-modified">  72     /* constant pool tags */</span>
<span class="line-modified">  73     private static final int CONSTANT_UTF8              = 1;</span>
<span class="line-modified">  74     private static final int CONSTANT_UNICODE           = 2;</span>
<span class="line-removed">  75     private static final int CONSTANT_INTEGER           = 3;</span>
<span class="line-removed">  76     private static final int CONSTANT_FLOAT             = 4;</span>
<span class="line-removed">  77     private static final int CONSTANT_LONG              = 5;</span>
<span class="line-removed">  78     private static final int CONSTANT_DOUBLE            = 6;</span>
<span class="line-removed">  79     private static final int CONSTANT_CLASS             = 7;</span>
<span class="line-removed">  80     private static final int CONSTANT_STRING            = 8;</span>
<span class="line-removed">  81     private static final int CONSTANT_FIELD             = 9;</span>
<span class="line-removed">  82     private static final int CONSTANT_METHOD            = 10;</span>
<span class="line-removed">  83     private static final int CONSTANT_INTERFACEMETHOD   = 11;</span>
<span class="line-removed">  84     private static final int CONSTANT_NAMEANDTYPE       = 12;</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86     /* access and modifier flags */</span>
<span class="line-removed">  87     private static final int ACC_PUBLIC                 = 0x00000001;</span>
<span class="line-removed">  88     private static final int ACC_PRIVATE                = 0x00000002;</span>
<span class="line-removed">  89 //  private static final int ACC_PROTECTED              = 0x00000004;</span>
<span class="line-removed">  90     private static final int ACC_STATIC                 = 0x00000008;</span>
<span class="line-removed">  91     private static final int ACC_FINAL                  = 0x00000010;</span>
<span class="line-removed">  92 //  private static final int ACC_SYNCHRONIZED           = 0x00000020;</span>
<span class="line-removed">  93 //  private static final int ACC_VOLATILE               = 0x00000040;</span>
<span class="line-removed">  94 //  private static final int ACC_TRANSIENT              = 0x00000080;</span>
<span class="line-removed">  95 //  private static final int ACC_NATIVE                 = 0x00000100;</span>
<span class="line-removed">  96 //  private static final int ACC_INTERFACE              = 0x00000200;</span>
<span class="line-removed">  97 //  private static final int ACC_ABSTRACT               = 0x00000400;</span>
<span class="line-removed">  98     private static final int ACC_SUPER                  = 0x00000020;</span>
<span class="line-removed">  99 //  private static final int ACC_STRICT                 = 0x00000800;</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101     /* opcodes */</span>
<span class="line-removed"> 102 //  private static final int opc_nop                    = 0;</span>
<span class="line-removed"> 103     private static final int opc_aconst_null            = 1;</span>
<span class="line-removed"> 104 //  private static final int opc_iconst_m1              = 2;</span>
<span class="line-removed"> 105     private static final int opc_iconst_0               = 3;</span>
<span class="line-removed"> 106 //  private static final int opc_iconst_1               = 4;</span>
<span class="line-removed"> 107 //  private static final int opc_iconst_2               = 5;</span>
<span class="line-removed"> 108 //  private static final int opc_iconst_3               = 6;</span>
<span class="line-removed"> 109 //  private static final int opc_iconst_4               = 7;</span>
<span class="line-removed"> 110 //  private static final int opc_iconst_5               = 8;</span>
<span class="line-removed"> 111 //  private static final int opc_lconst_0               = 9;</span>
<span class="line-removed"> 112 //  private static final int opc_lconst_1               = 10;</span>
<span class="line-removed"> 113 //  private static final int opc_fconst_0               = 11;</span>
<span class="line-removed"> 114 //  private static final int opc_fconst_1               = 12;</span>
<span class="line-removed"> 115 //  private static final int opc_fconst_2               = 13;</span>
<span class="line-removed"> 116 //  private static final int opc_dconst_0               = 14;</span>
<span class="line-removed"> 117 //  private static final int opc_dconst_1               = 15;</span>
<span class="line-removed"> 118     private static final int opc_bipush                 = 16;</span>
<span class="line-removed"> 119     private static final int opc_sipush                 = 17;</span>
<span class="line-removed"> 120     private static final int opc_ldc                    = 18;</span>
<span class="line-removed"> 121     private static final int opc_ldc_w                  = 19;</span>
<span class="line-removed"> 122 //  private static final int opc_ldc2_w                 = 20;</span>
<span class="line-removed"> 123     private static final int opc_iload                  = 21;</span>
<span class="line-removed"> 124     private static final int opc_lload                  = 22;</span>
<span class="line-removed"> 125     private static final int opc_fload                  = 23;</span>
<span class="line-removed"> 126     private static final int opc_dload                  = 24;</span>
<span class="line-removed"> 127     private static final int opc_aload                  = 25;</span>
<span class="line-removed"> 128     private static final int opc_iload_0                = 26;</span>
<span class="line-removed"> 129 //  private static final int opc_iload_1                = 27;</span>
<span class="line-removed"> 130 //  private static final int opc_iload_2                = 28;</span>
<span class="line-removed"> 131 //  private static final int opc_iload_3                = 29;</span>
<span class="line-removed"> 132     private static final int opc_lload_0                = 30;</span>
<span class="line-removed"> 133 //  private static final int opc_lload_1                = 31;</span>
<span class="line-removed"> 134 //  private static final int opc_lload_2                = 32;</span>
<span class="line-removed"> 135 //  private static final int opc_lload_3                = 33;</span>
<span class="line-removed"> 136     private static final int opc_fload_0                = 34;</span>
<span class="line-removed"> 137 //  private static final int opc_fload_1                = 35;</span>
<span class="line-removed"> 138 //  private static final int opc_fload_2                = 36;</span>
<span class="line-removed"> 139 //  private static final int opc_fload_3                = 37;</span>
<span class="line-removed"> 140     private static final int opc_dload_0                = 38;</span>
<span class="line-removed"> 141 //  private static final int opc_dload_1                = 39;</span>
<span class="line-removed"> 142 //  private static final int opc_dload_2                = 40;</span>
<span class="line-removed"> 143 //  private static final int opc_dload_3                = 41;</span>
<span class="line-removed"> 144     private static final int opc_aload_0                = 42;</span>
<span class="line-removed"> 145 //  private static final int opc_aload_1                = 43;</span>
<span class="line-removed"> 146 //  private static final int opc_aload_2                = 44;</span>
<span class="line-removed"> 147 //  private static final int opc_aload_3                = 45;</span>
<span class="line-removed"> 148 //  private static final int opc_iaload                 = 46;</span>
<span class="line-removed"> 149 //  private static final int opc_laload                 = 47;</span>
<span class="line-removed"> 150 //  private static final int opc_faload                 = 48;</span>
<span class="line-removed"> 151 //  private static final int opc_daload                 = 49;</span>
<span class="line-removed"> 152 //  private static final int opc_aaload                 = 50;</span>
<span class="line-removed"> 153 //  private static final int opc_baload                 = 51;</span>
<span class="line-removed"> 154 //  private static final int opc_caload                 = 52;</span>
<span class="line-removed"> 155 //  private static final int opc_saload                 = 53;</span>
<span class="line-removed"> 156 //  private static final int opc_istore                 = 54;</span>
<span class="line-removed"> 157 //  private static final int opc_lstore                 = 55;</span>
<span class="line-removed"> 158 //  private static final int opc_fstore                 = 56;</span>
<span class="line-removed"> 159 //  private static final int opc_dstore                 = 57;</span>
<span class="line-removed"> 160     private static final int opc_astore                 = 58;</span>
<span class="line-removed"> 161 //  private static final int opc_istore_0               = 59;</span>
<span class="line-removed"> 162 //  private static final int opc_istore_1               = 60;</span>
<span class="line-removed"> 163 //  private static final int opc_istore_2               = 61;</span>
<span class="line-removed"> 164 //  private static final int opc_istore_3               = 62;</span>
<span class="line-removed"> 165 //  private static final int opc_lstore_0               = 63;</span>
<span class="line-removed"> 166 //  private static final int opc_lstore_1               = 64;</span>
<span class="line-removed"> 167 //  private static final int opc_lstore_2               = 65;</span>
<span class="line-removed"> 168 //  private static final int opc_lstore_3               = 66;</span>
<span class="line-removed"> 169 //  private static final int opc_fstore_0               = 67;</span>
<span class="line-removed"> 170 //  private static final int opc_fstore_1               = 68;</span>
<span class="line-removed"> 171 //  private static final int opc_fstore_2               = 69;</span>
<span class="line-removed"> 172 //  private static final int opc_fstore_3               = 70;</span>
<span class="line-removed"> 173 //  private static final int opc_dstore_0               = 71;</span>
<span class="line-removed"> 174 //  private static final int opc_dstore_1               = 72;</span>
<span class="line-removed"> 175 //  private static final int opc_dstore_2               = 73;</span>
<span class="line-removed"> 176 //  private static final int opc_dstore_3               = 74;</span>
<span class="line-removed"> 177     private static final int opc_astore_0               = 75;</span>
<span class="line-removed"> 178 //  private static final int opc_astore_1               = 76;</span>
<span class="line-removed"> 179 //  private static final int opc_astore_2               = 77;</span>
<span class="line-removed"> 180 //  private static final int opc_astore_3               = 78;</span>
<span class="line-removed"> 181 //  private static final int opc_iastore                = 79;</span>
<span class="line-removed"> 182 //  private static final int opc_lastore                = 80;</span>
<span class="line-removed"> 183 //  private static final int opc_fastore                = 81;</span>
<span class="line-removed"> 184 //  private static final int opc_dastore                = 82;</span>
<span class="line-removed"> 185     private static final int opc_aastore                = 83;</span>
<span class="line-removed"> 186 //  private static final int opc_bastore                = 84;</span>
<span class="line-removed"> 187 //  private static final int opc_castore                = 85;</span>
<span class="line-removed"> 188 //  private static final int opc_sastore                = 86;</span>
<span class="line-removed"> 189     private static final int opc_pop                    = 87;</span>
<span class="line-removed"> 190 //  private static final int opc_pop2                   = 88;</span>
<span class="line-removed"> 191     private static final int opc_dup                    = 89;</span>
<span class="line-removed"> 192 //  private static final int opc_dup_x1                 = 90;</span>
<span class="line-removed"> 193 //  private static final int opc_dup_x2                 = 91;</span>
<span class="line-removed"> 194 //  private static final int opc_dup2                   = 92;</span>
<span class="line-removed"> 195 //  private static final int opc_dup2_x1                = 93;</span>
<span class="line-removed"> 196 //  private static final int opc_dup2_x2                = 94;</span>
<span class="line-removed"> 197 //  private static final int opc_swap                   = 95;</span>
<span class="line-removed"> 198 //  private static final int opc_iadd                   = 96;</span>
<span class="line-removed"> 199 //  private static final int opc_ladd                   = 97;</span>
<span class="line-removed"> 200 //  private static final int opc_fadd                   = 98;</span>
<span class="line-removed"> 201 //  private static final int opc_dadd                   = 99;</span>
<span class="line-removed"> 202 //  private static final int opc_isub                   = 100;</span>
<span class="line-removed"> 203 //  private static final int opc_lsub                   = 101;</span>
<span class="line-removed"> 204 //  private static final int opc_fsub                   = 102;</span>
<span class="line-removed"> 205 //  private static final int opc_dsub                   = 103;</span>
<span class="line-removed"> 206 //  private static final int opc_imul                   = 104;</span>
<span class="line-removed"> 207 //  private static final int opc_lmul                   = 105;</span>
<span class="line-removed"> 208 //  private static final int opc_fmul                   = 106;</span>
<span class="line-removed"> 209 //  private static final int opc_dmul                   = 107;</span>
<span class="line-removed"> 210 //  private static final int opc_idiv                   = 108;</span>
<span class="line-removed"> 211 //  private static final int opc_ldiv                   = 109;</span>
<span class="line-removed"> 212 //  private static final int opc_fdiv                   = 110;</span>
<span class="line-removed"> 213 //  private static final int opc_ddiv                   = 111;</span>
<span class="line-removed"> 214 //  private static final int opc_irem                   = 112;</span>
<span class="line-removed"> 215 //  private static final int opc_lrem                   = 113;</span>
<span class="line-removed"> 216 //  private static final int opc_frem                   = 114;</span>
<span class="line-removed"> 217 //  private static final int opc_drem                   = 115;</span>
<span class="line-removed"> 218 //  private static final int opc_ineg                   = 116;</span>
<span class="line-removed"> 219 //  private static final int opc_lneg                   = 117;</span>
<span class="line-removed"> 220 //  private static final int opc_fneg                   = 118;</span>
<span class="line-removed"> 221 //  private static final int opc_dneg                   = 119;</span>
<span class="line-removed"> 222 //  private static final int opc_ishl                   = 120;</span>
<span class="line-removed"> 223 //  private static final int opc_lshl                   = 121;</span>
<span class="line-removed"> 224 //  private static final int opc_ishr                   = 122;</span>
<span class="line-removed"> 225 //  private static final int opc_lshr                   = 123;</span>
<span class="line-removed"> 226 //  private static final int opc_iushr                  = 124;</span>
<span class="line-removed"> 227 //  private static final int opc_lushr                  = 125;</span>
<span class="line-removed"> 228 //  private static final int opc_iand                   = 126;</span>
<span class="line-removed"> 229 //  private static final int opc_land                   = 127;</span>
<span class="line-removed"> 230 //  private static final int opc_ior                    = 128;</span>
<span class="line-removed"> 231 //  private static final int opc_lor                    = 129;</span>
<span class="line-removed"> 232 //  private static final int opc_ixor                   = 130;</span>
<span class="line-removed"> 233 //  private static final int opc_lxor                   = 131;</span>
<span class="line-removed"> 234 //  private static final int opc_iinc                   = 132;</span>
<span class="line-removed"> 235 //  private static final int opc_i2l                    = 133;</span>
<span class="line-removed"> 236 //  private static final int opc_i2f                    = 134;</span>
<span class="line-removed"> 237 //  private static final int opc_i2d                    = 135;</span>
<span class="line-removed"> 238 //  private static final int opc_l2i                    = 136;</span>
<span class="line-removed"> 239 //  private static final int opc_l2f                    = 137;</span>
<span class="line-removed"> 240 //  private static final int opc_l2d                    = 138;</span>
<span class="line-removed"> 241 //  private static final int opc_f2i                    = 139;</span>
<span class="line-removed"> 242 //  private static final int opc_f2l                    = 140;</span>
<span class="line-removed"> 243 //  private static final int opc_f2d                    = 141;</span>
<span class="line-removed"> 244 //  private static final int opc_d2i                    = 142;</span>
<span class="line-removed"> 245 //  private static final int opc_d2l                    = 143;</span>
<span class="line-removed"> 246 //  private static final int opc_d2f                    = 144;</span>
<span class="line-removed"> 247 //  private static final int opc_i2b                    = 145;</span>
<span class="line-removed"> 248 //  private static final int opc_i2c                    = 146;</span>
<span class="line-removed"> 249 //  private static final int opc_i2s                    = 147;</span>
<span class="line-removed"> 250 //  private static final int opc_lcmp                   = 148;</span>
<span class="line-removed"> 251 //  private static final int opc_fcmpl                  = 149;</span>
<span class="line-removed"> 252 //  private static final int opc_fcmpg                  = 150;</span>
<span class="line-removed"> 253 //  private static final int opc_dcmpl                  = 151;</span>
<span class="line-removed"> 254 //  private static final int opc_dcmpg                  = 152;</span>
<span class="line-removed"> 255 //  private static final int opc_ifeq                   = 153;</span>
<span class="line-removed"> 256 //  private static final int opc_ifne                   = 154;</span>
<span class="line-removed"> 257 //  private static final int opc_iflt                   = 155;</span>
<span class="line-removed"> 258 //  private static final int opc_ifge                   = 156;</span>
<span class="line-removed"> 259 //  private static final int opc_ifgt                   = 157;</span>
<span class="line-removed"> 260 //  private static final int opc_ifle                   = 158;</span>
<span class="line-removed"> 261 //  private static final int opc_if_icmpeq              = 159;</span>
<span class="line-removed"> 262 //  private static final int opc_if_icmpne              = 160;</span>
<span class="line-removed"> 263 //  private static final int opc_if_icmplt              = 161;</span>
<span class="line-removed"> 264 //  private static final int opc_if_icmpge              = 162;</span>
<span class="line-removed"> 265 //  private static final int opc_if_icmpgt              = 163;</span>
<span class="line-removed"> 266 //  private static final int opc_if_icmple              = 164;</span>
<span class="line-removed"> 267 //  private static final int opc_if_acmpeq              = 165;</span>
<span class="line-removed"> 268 //  private static final int opc_if_acmpne              = 166;</span>
<span class="line-removed"> 269 //  private static final int opc_goto                   = 167;</span>
<span class="line-removed"> 270 //  private static final int opc_jsr                    = 168;</span>
<span class="line-removed"> 271 //  private static final int opc_ret                    = 169;</span>
<span class="line-removed"> 272 //  private static final int opc_tableswitch            = 170;</span>
<span class="line-removed"> 273 //  private static final int opc_lookupswitch           = 171;</span>
<span class="line-removed"> 274     private static final int opc_ireturn                = 172;</span>
<span class="line-removed"> 275     private static final int opc_lreturn                = 173;</span>
<span class="line-removed"> 276     private static final int opc_freturn                = 174;</span>
<span class="line-removed"> 277     private static final int opc_dreturn                = 175;</span>
<span class="line-removed"> 278     private static final int opc_areturn                = 176;</span>
<span class="line-removed"> 279     private static final int opc_return                 = 177;</span>
<span class="line-removed"> 280     private static final int opc_getstatic              = 178;</span>
<span class="line-removed"> 281     private static final int opc_putstatic              = 179;</span>
<span class="line-removed"> 282     private static final int opc_getfield               = 180;</span>
<span class="line-removed"> 283 //  private static final int opc_putfield               = 181;</span>
<span class="line-removed"> 284     private static final int opc_invokevirtual          = 182;</span>
<span class="line-removed"> 285     private static final int opc_invokespecial          = 183;</span>
<span class="line-removed"> 286     private static final int opc_invokestatic           = 184;</span>
<span class="line-removed"> 287     private static final int opc_invokeinterface        = 185;</span>
<span class="line-removed"> 288     private static final int opc_new                    = 187;</span>
<span class="line-removed"> 289 //  private static final int opc_newarray               = 188;</span>
<span class="line-removed"> 290     private static final int opc_anewarray              = 189;</span>
<span class="line-removed"> 291 //  private static final int opc_arraylength            = 190;</span>
<span class="line-removed"> 292     private static final int opc_athrow                 = 191;</span>
<span class="line-removed"> 293     private static final int opc_checkcast              = 192;</span>
<span class="line-removed"> 294 //  private static final int opc_instanceof             = 193;</span>
<span class="line-removed"> 295 //  private static final int opc_monitorenter           = 194;</span>
<span class="line-removed"> 296 //  private static final int opc_monitorexit            = 195;</span>
<span class="line-removed"> 297     private static final int opc_wide                   = 196;</span>
<span class="line-removed"> 298 //  private static final int opc_multianewarray         = 197;</span>
<span class="line-removed"> 299 //  private static final int opc_ifnull                 = 198;</span>
<span class="line-removed"> 300 //  private static final int opc_ifnonnull              = 199;</span>
<span class="line-removed"> 301 //  private static final int opc_goto_w                 = 200;</span>
<span class="line-removed"> 302 //  private static final int opc_jsr_w                  = 201;</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     // end of constants copied from sun.tools.java.RuntimeConstants</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     /** name of the superclass of proxy classes */</span>
<span class="line-removed"> 307     private static final String superclassName = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309     /** name of field for storing a proxy instance&#39;s invocation handler */</span>
<span class="line-removed"> 310     private static final String handlerFieldName = &quot;h&quot;;</span>
 311 
<span class="line-modified"> 312     /** debugging flag for saving generated class files */</span>
<span class="line-modified"> 313     private static final boolean saveGeneratedFiles =</span>
<span class="line-modified"> 314         java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 315             new GetBooleanAction(</span>
<span class="line-modified"> 316                 &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;)).booleanValue();</span>

 317 
 318     /**
<span class="line-modified"> 319      * Generate a public proxy class given a name and a list of proxy interfaces.</span>
 320      */
<span class="line-modified"> 321     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed"> 322                                      Class&lt;?&gt;[] interfaces) {</span>
<span class="line-removed"> 323         return generateProxyClass(name, interfaces, (ACC_PUBLIC | ACC_FINAL | ACC_SUPER));</span>
<span class="line-removed"> 324     }</span>
 325 
 326     /**
<span class="line-modified"> 327      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified"> 328      *</span>
<span class="line-modified"> 329      * @param name        the class name of the proxy class</span>
<span class="line-removed"> 330      * @param interfaces  proxy interfaces</span>
<span class="line-removed"> 331      * @param accessFlags access flags of the proxy class</span>
<span class="line-removed"> 332     */</span>
<span class="line-removed"> 333     static byte[] generateProxyClass(final String name,</span>
<span class="line-removed"> 334                                      Class&lt;?&gt;[] interfaces,</span>
<span class="line-removed"> 335                                      int accessFlags)</span>
<span class="line-removed"> 336     {</span>
<span class="line-removed"> 337         ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);</span>
<span class="line-removed"> 338         final byte[] classFile = gen.generateClassFile();</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340         if (saveGeneratedFiles) {</span>
 341             java.security.AccessController.doPrivileged(
<span class="line-modified"> 342             new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified"> 343                 public Void run() {</span>
<span class="line-removed"> 344                     try {</span>
<span class="line-removed"> 345                         int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-removed"> 346                         Path path;</span>
<span class="line-removed"> 347                         if (i &gt; 0) {</span>
<span class="line-removed"> 348                             Path dir = Path.of(name.substring(0, i).replace(&#39;.&#39;, File.separatorChar));</span>
<span class="line-removed"> 349                             Files.createDirectories(dir);</span>
<span class="line-removed"> 350                             path = dir.resolve(name.substring(i+1, name.length()) + &quot;.class&quot;);</span>
<span class="line-removed"> 351                         } else {</span>
<span class="line-removed"> 352                             path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-removed"> 353                         }</span>
<span class="line-removed"> 354                         Files.write(path, classFile);</span>
<span class="line-removed"> 355                         return null;</span>
<span class="line-removed"> 356                     } catch (IOException e) {</span>
<span class="line-removed"> 357                         throw new InternalError(</span>
<span class="line-removed"> 358                             &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-removed"> 359                     }</span>
<span class="line-removed"> 360                 }</span>
<span class="line-removed"> 361             });</span>
<span class="line-removed"> 362         }</span>
 363 
<span class="line-modified"> 364         return classFile;</span>
<span class="line-modified"> 365     }</span>


 366 
<span class="line-removed"> 367     /* preloaded Method objects for methods in java.lang.Object */</span>
<span class="line-removed"> 368     private static Method hashCodeMethod;</span>
<span class="line-removed"> 369     private static Method equalsMethod;</span>
<span class="line-removed"> 370     private static Method toStringMethod;</span>
 371     static {
 372         try {
<span class="line-modified"> 373             hashCodeMethod = Object.class.getMethod(&quot;hashCode&quot;);</span>
<span class="line-modified"> 374             equalsMethod =</span>
<span class="line-modified"> 375                 Object.class.getMethod(&quot;equals&quot;, new Class&lt;?&gt;[] { Object.class });</span>
<span class="line-removed"> 376             toStringMethod = Object.class.getMethod(&quot;toString&quot;);</span>
 377         } catch (NoSuchMethodException e) {
 378             throw new NoSuchMethodError(e.getMessage());
 379         }
 380     }
 381 
<span class="line-modified"> 382     /** name of proxy class */</span>
<span class="line-modified"> 383     private String className;</span>
<span class="line-modified"> 384 </span>
<span class="line-modified"> 385     /** proxy interfaces */</span>
<span class="line-removed"> 386     private Class&lt;?&gt;[] interfaces;</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388     /** proxy class access flags */</span>
<span class="line-removed"> 389     private int accessFlags;</span>
 390 
<span class="line-modified"> 391     /** constant pool of class being generated */</span>
<span class="line-modified"> 392     private ConstantPool cp = new ConstantPool();</span>


 393 
<span class="line-modified"> 394     /** FieldInfo struct for each field of generated class */</span>
<span class="line-modified"> 395     private List&lt;FieldInfo&gt; fields = new ArrayList&lt;&gt;();</span>


 396 
<span class="line-modified"> 397     /** MethodInfo struct for each method of generated class */</span>
<span class="line-modified"> 398     private List&lt;MethodInfo&gt; methods = new ArrayList&lt;&gt;();</span>


 399 
 400     /**
<span class="line-modified"> 401      * maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified"> 402      * proxy methods with that signature</span>

 403      */
<span class="line-modified"> 404     private Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new HashMap&lt;&gt;();</span>
 405 
<span class="line-modified"> 406     /** count of ProxyMethod objects added to proxyMethods */</span>
<span class="line-modified"> 407     private int proxyMethodCount = 0;</span>



 408 
 409     /**
 410      * Construct a ProxyGenerator to generate a proxy class with the
 411      * specified name and for the given interfaces.
<span class="line-modified"> 412      *</span>
 413      * A ProxyGenerator object contains the state for the ongoing
 414      * generation of a particular proxy class.
 415      */
<span class="line-modified"> 416     private ProxyGenerator(String className, Class&lt;?&gt;[] interfaces, int accessFlags) {</span>



 417         this.className = className;
 418         this.interfaces = interfaces;
 419         this.accessFlags = accessFlags;
 420     }
 421 
 422     /**
<span class="line-modified"> 423      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified"> 424      * class file generation process.</span>



 425      */
<span class="line-modified"> 426     private byte[] generateClassFile() {</span>
<span class="line-modified"> 427 </span>
<span class="line-modified"> 428         /* ============================================================</span>
<span class="line-modified"> 429          * Step 1: Assemble ProxyMethod objects for all methods to</span>
<span class="line-modified"> 430          * generate proxy dispatching code for.</span>
<span class="line-modified"> 431          */</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433         /*</span>
<span class="line-removed"> 434          * Record that proxy methods are needed for the hashCode, equals,</span>
<span class="line-removed"> 435          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-removed"> 436          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-removed"> 437          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-removed"> 438          * proxy interfaces.</span>
<span class="line-removed"> 439          */</span>
<span class="line-removed"> 440         addProxyMethod(hashCodeMethod, Object.class);</span>
<span class="line-removed"> 441         addProxyMethod(equalsMethod, Object.class);</span>
<span class="line-removed"> 442         addProxyMethod(toStringMethod, Object.class);</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444         /*</span>
<span class="line-removed"> 445          * Now record all of the methods from the proxy interfaces, giving</span>
<span class="line-removed"> 446          * earlier interfaces precedence over later ones with duplicate</span>
<span class="line-removed"> 447          * methods.</span>
<span class="line-removed"> 448          */</span>
<span class="line-removed"> 449         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed"> 450             for (Method m : intf.getMethods()) {</span>
<span class="line-removed"> 451                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-removed"> 452                     addProxyMethod(m, intf);</span>
<span class="line-removed"> 453                 }</span>
<span class="line-removed"> 454             }</span>
<span class="line-removed"> 455         }</span>
<span class="line-removed"> 456 </span>
<span class="line-removed"> 457         /*</span>
<span class="line-removed"> 458          * For each set of proxy methods with the same signature,</span>
<span class="line-removed"> 459          * verify that the methods&#39; return types are compatible.</span>
<span class="line-removed"> 460          */</span>
<span class="line-removed"> 461         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed"> 462             checkReturnTypes(sigmethods);</span>
<span class="line-removed"> 463         }</span>
<span class="line-removed"> 464 </span>
<span class="line-removed"> 465         /* ============================================================</span>
<span class="line-removed"> 466          * Step 2: Assemble FieldInfo and MethodInfo structs for all of</span>
<span class="line-removed"> 467          * fields and methods in the class we are generating.</span>
<span class="line-removed"> 468          */</span>
<span class="line-removed"> 469         try {</span>
<span class="line-removed"> 470             methods.add(generateConstructor());</span>
<span class="line-removed"> 471 </span>
<span class="line-removed"> 472             for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-removed"> 473                 for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed"> 474 </span>
<span class="line-removed"> 475                     // add static field for method&#39;s Method object</span>
<span class="line-removed"> 476                     fields.add(new FieldInfo(pm.methodFieldName,</span>
<span class="line-removed"> 477                         &quot;Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-removed"> 478                          ACC_PRIVATE | ACC_STATIC));</span>
<span class="line-removed"> 479 </span>
<span class="line-removed"> 480                     // generate code for proxy method and add it</span>
<span class="line-removed"> 481                     methods.add(pm.generateMethod());</span>
<span class="line-removed"> 482                 }</span>
<span class="line-removed"> 483             }</span>
<span class="line-removed"> 484 </span>
<span class="line-removed"> 485             methods.add(generateStaticInitializer());</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487         } catch (IOException e) {</span>
<span class="line-removed"> 488             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>
<span class="line-removed"> 489         }</span>
<span class="line-removed"> 490 </span>
<span class="line-removed"> 491         if (methods.size() &gt; 65535) {</span>
<span class="line-removed"> 492             throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span>
<span class="line-removed"> 493         }</span>
<span class="line-removed"> 494         if (fields.size() &gt; 65535) {</span>
<span class="line-removed"> 495             throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span>
<span class="line-removed"> 496         }</span>
<span class="line-removed"> 497 </span>
<span class="line-removed"> 498         /* ============================================================</span>
<span class="line-removed"> 499          * Step 3: Write the final class file.</span>
<span class="line-removed"> 500          */</span>
<span class="line-removed"> 501 </span>
<span class="line-removed"> 502         /*</span>
<span class="line-removed"> 503          * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 504          * following items before starting to write the final class file.</span>
<span class="line-removed"> 505          */</span>
<span class="line-removed"> 506         cp.getClass(dotToSlash(className));</span>
<span class="line-removed"> 507         cp.getClass(superclassName);</span>
<span class="line-removed"> 508         for (Class&lt;?&gt; intf: interfaces) {</span>
<span class="line-removed"> 509             cp.getClass(dotToSlash(intf.getName()));</span>
<span class="line-removed"> 510         }</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512         /*</span>
<span class="line-removed"> 513          * Disallow new constant pool additions beyond this point, since</span>
<span class="line-removed"> 514          * we are about to write the final constant pool table.</span>
<span class="line-removed"> 515          */</span>
<span class="line-removed"> 516         cp.setReadOnly();</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518         ByteArrayOutputStream bout = new ByteArrayOutputStream();</span>
<span class="line-removed"> 519         DataOutputStream dout = new DataOutputStream(bout);</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521         try {</span>
<span class="line-removed"> 522             /*</span>
<span class="line-removed"> 523              * Write all the items of the &quot;ClassFile&quot; structure.</span>
<span class="line-removed"> 524              * See JVMS section 4.1.</span>
<span class="line-removed"> 525              */</span>
<span class="line-removed"> 526                                         // u4 magic;</span>
<span class="line-removed"> 527             dout.writeInt(0xCAFEBABE);</span>
<span class="line-removed"> 528                                         // u2 minor_version;</span>
<span class="line-removed"> 529             dout.writeShort(CLASSFILE_MINOR_VERSION);</span>
<span class="line-removed"> 530                                         // u2 major_version;</span>
<span class="line-removed"> 531             dout.writeShort(CLASSFILE_MAJOR_VERSION);</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533             cp.write(dout);             // (write constant pool)</span>
<span class="line-removed"> 534 </span>
<span class="line-removed"> 535                                         // u2 access_flags;</span>
<span class="line-removed"> 536             dout.writeShort(accessFlags);</span>
<span class="line-removed"> 537                                         // u2 this_class;</span>
<span class="line-removed"> 538             dout.writeShort(cp.getClass(dotToSlash(className)));</span>
<span class="line-removed"> 539                                         // u2 super_class;</span>
<span class="line-removed"> 540             dout.writeShort(cp.getClass(superclassName));</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542                                         // u2 interfaces_count;</span>
<span class="line-removed"> 543             dout.writeShort(interfaces.length);</span>
<span class="line-removed"> 544                                         // u2 interfaces[interfaces_count];</span>
<span class="line-removed"> 545             for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-removed"> 546                 dout.writeShort(cp.getClass(</span>
<span class="line-removed"> 547                     dotToSlash(intf.getName())));</span>
<span class="line-removed"> 548             }</span>
<span class="line-removed"> 549 </span>
<span class="line-removed"> 550                                         // u2 fields_count;</span>
<span class="line-removed"> 551             dout.writeShort(fields.size());</span>
<span class="line-removed"> 552                                         // field_info fields[fields_count];</span>
<span class="line-removed"> 553             for (FieldInfo f : fields) {</span>
<span class="line-removed"> 554                 f.write(dout);</span>
<span class="line-removed"> 555             }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557                                         // u2 methods_count;</span>
<span class="line-removed"> 558             dout.writeShort(methods.size());</span>
<span class="line-removed"> 559                                         // method_info methods[methods_count];</span>
<span class="line-removed"> 560             for (MethodInfo m : methods) {</span>
<span class="line-removed"> 561                 m.write(dout);</span>
<span class="line-removed"> 562             }</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564                                          // u2 attributes_count;</span>
<span class="line-removed"> 565             dout.writeShort(0); // (no ClassFile attributes for proxy classes)</span>
 566 
<span class="line-modified"> 567         } catch (IOException e) {</span>
<span class="line-modified"> 568             throw new InternalError(&quot;unexpected I/O Exception&quot;, e);</span>




















 569         }
 570 
<span class="line-modified"> 571         return bout.toByteArray();</span>
 572     }
 573 
 574     /**
<span class="line-modified"> 575      * Add another method to be proxied, either by creating a new</span>
<span class="line-removed"> 576      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-removed"> 577      * method.</span>
 578      *
<span class="line-modified"> 579      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-modified"> 580      * found through, which may be different from (a subinterface of)</span>
<span class="line-removed"> 581      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-removed"> 582      * object passed for a given name and descriptor identifies the</span>
<span class="line-removed"> 583      * Method object (and thus the declaring class) that will be</span>
<span class="line-removed"> 584      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-removed"> 585      * set of duplicate methods.</span>
 586      */
<span class="line-modified"> 587     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-modified"> 588         String name = m.getName();</span>
<span class="line-modified"> 589         Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span>
<span class="line-modified"> 590         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-modified"> 591         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
<span class="line-modified"> 592 </span>
<span class="line-modified"> 593         String sig = name + getParameterDescriptors(parameterTypes);</span>
<span class="line-modified"> 594         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.get(sig);</span>
<span class="line-removed"> 595         if (sigmethods != null) {</span>
<span class="line-removed"> 596             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-removed"> 597                 if (returnType == pm.returnType) {</span>
<span class="line-removed"> 598                     /*</span>
<span class="line-removed"> 599                      * Found a match: reduce exception types to the</span>
<span class="line-removed"> 600                      * greatest set of exceptions that can thrown</span>
<span class="line-removed"> 601                      * compatibly with the throws clauses of both</span>
<span class="line-removed"> 602                      * overridden methods.</span>
<span class="line-removed"> 603                      */</span>
<span class="line-removed"> 604                     List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-removed"> 605                     collectCompatibleTypes(</span>
<span class="line-removed"> 606                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-removed"> 607                     collectCompatibleTypes(</span>
<span class="line-removed"> 608                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-removed"> 609                     pm.exceptionTypes = new Class&lt;?&gt;[legalExceptions.size()];</span>
<span class="line-removed"> 610                     pm.exceptionTypes =</span>
<span class="line-removed"> 611                         legalExceptions.toArray(pm.exceptionTypes);</span>
<span class="line-removed"> 612                     return;</span>
<span class="line-removed"> 613                 }</span>
<span class="line-removed"> 614             }</span>
<span class="line-removed"> 615         } else {</span>
<span class="line-removed"> 616             sigmethods = new ArrayList&lt;&gt;(3);</span>
<span class="line-removed"> 617             proxyMethods.put(sig, sigmethods);</span>
<span class="line-removed"> 618         }</span>
<span class="line-removed"> 619         sigmethods.add(new ProxyMethod(name, parameterTypes, returnType,</span>
<span class="line-removed"> 620                                        exceptionTypes, fromClass));</span>
 621     }
 622 
 623     /**
 624      * For a given set of proxy methods with the same signature, check
 625      * that their return types are compatible according to the Proxy
 626      * specification.
 627      *
 628      * Specifically, if there is more than one such method, then all
 629      * of the return types must be reference types, and there must be
 630      * one return type that is assignable to each of the rest of them.
 631      */
 632     private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
 633         /*
 634          * If there is only one method with a given signature, there
 635          * cannot be a conflict.  This is the only case in which a
 636          * primitive (or void) return type is allowed.
 637          */
 638         if (methods.size() &lt; 2) {
 639             return;
 640         }
 641 
 642         /*
 643          * List of return types that are not yet known to be
 644          * assignable from (&quot;covered&quot; by) any of the others.
 645          */
 646         LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
 647 
<span class="line-modified"> 648     nextNewReturnType:</span>
 649         for (ProxyMethod pm : methods) {
 650             Class&lt;?&gt; newReturnType = pm.returnType;
 651             if (newReturnType.isPrimitive()) {
 652                 throw new IllegalArgumentException(
<span class="line-modified"> 653                     &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 654                     getFriendlyMethodSignature(pm.methodName,</span>
<span class="line-modified"> 655                                                pm.parameterTypes) +</span>
<span class="line-modified"> 656                     &quot; but incompatible return types: &quot; +</span>
<span class="line-removed"> 657                     newReturnType.getName() + &quot; and others&quot;);</span>
 658             }
 659             boolean added = false;
 660 
 661             /*
 662              * Compare the new return type to the existing uncovered
 663              * return types.
 664              */
 665             ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
 666             while (liter.hasNext()) {
 667                 Class&lt;?&gt; uncoveredReturnType = liter.next();
 668 
 669                 /*
 670                  * If an existing uncovered return type is assignable
 671                  * to this new one, then we can forget the new one.
 672                  */
 673                 if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
 674                     assert !added;
 675                     continue nextNewReturnType;
 676                 }
 677 
</pre>
<hr />
<pre>
 692                 }
 693             }
 694 
 695             /*
 696              * If we got through the list of existing uncovered return
 697              * types without an assignability relationship, then add
 698              * the new return type to the list of uncovered ones.
 699              */
 700             if (!added) {
 701                 uncoveredReturnTypes.add(newReturnType);
 702             }
 703         }
 704 
 705         /*
 706          * We shouldn&#39;t end up with more than one return type that is
 707          * not assignable from any of the others.
 708          */
 709         if (uncoveredReturnTypes.size() &gt; 1) {
 710             ProxyMethod pm = methods.get(0);
 711             throw new IllegalArgumentException(
<span class="line-modified"> 712                 &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 713                 getFriendlyMethodSignature(pm.methodName, pm.parameterTypes) +</span>
<span class="line-modified"> 714                 &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
 715         }
 716     }
 717 
 718     /**
<span class="line-modified"> 719      * A FieldInfo object contains information about a particular field</span>
<span class="line-modified"> 720      * in the class being generated.  The class mirrors the data items of</span>
<span class="line-modified"> 721      * the &quot;field_info&quot; structure of the class file format (see JVMS 4.5).</span>
















 722      */
<span class="line-modified"> 723     private class FieldInfo {</span>
<span class="line-modified"> 724         public int accessFlags;</span>
<span class="line-modified"> 725         public String name;</span>
<span class="line-removed"> 726         public String descriptor;</span>
<span class="line-removed"> 727 </span>
<span class="line-removed"> 728         public FieldInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed"> 729             this.name = name;</span>
<span class="line-removed"> 730             this.descriptor = descriptor;</span>
<span class="line-removed"> 731             this.accessFlags = accessFlags;</span>
 732 
<span class="line-modified"> 733             /*</span>
<span class="line-modified"> 734              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 735              * following items before starting to write the final class file.</span>
<span class="line-removed"> 736              */</span>
<span class="line-removed"> 737             cp.getUtf8(name);</span>
<span class="line-removed"> 738             cp.getUtf8(descriptor);</span>
<span class="line-removed"> 739         }</span>
 740 
<span class="line-modified"> 741         public void write(DataOutputStream out) throws IOException {</span>















 742             /*
<span class="line-modified"> 743              * Write all the items of the &quot;field_info&quot; structure.</span>
<span class="line-modified"> 744              * See JVMS section 4.5.</span>
 745              */
<span class="line-modified"> 746                                         // u2 access_flags;</span>
<span class="line-modified"> 747             out.writeShort(accessFlags);</span>
<span class="line-modified"> 748                                         // u2 name_index;</span>
<span class="line-modified"> 749             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified"> 750                                         // u2 descriptor_index;</span>
<span class="line-modified"> 751             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified"> 752                                         // u2 attributes_count;</span>
<span class="line-modified"> 753             out.writeShort(0);  // (no field_info attributes for proxy classes)</span>












 754         }

 755     }
 756 
 757     /**
<span class="line-modified"> 758      * An ExceptionTableEntry object holds values for the data items of</span>
<span class="line-modified"> 759      * an entry in the &quot;exception_table&quot; item of the &quot;Code&quot; attribute of</span>
<span class="line-modified"> 760      * &quot;method_info&quot; structures (see JVMS 4.7.3).</span>


 761      */
<span class="line-modified"> 762     private static class ExceptionTableEntry {</span>
<span class="line-modified"> 763         public short startPc;</span>
<span class="line-modified"> 764         public short endPc;</span>
<span class="line-removed"> 765         public short handlerPc;</span>
<span class="line-removed"> 766         public short catchType;</span>
<span class="line-removed"> 767 </span>
<span class="line-removed"> 768         public ExceptionTableEntry(short startPc, short endPc,</span>
<span class="line-removed"> 769                                    short handlerPc, short catchType)</span>
<span class="line-removed"> 770         {</span>
<span class="line-removed"> 771             this.startPc = startPc;</span>
<span class="line-removed"> 772             this.endPc = endPc;</span>
<span class="line-removed"> 773             this.handlerPc = handlerPc;</span>
<span class="line-removed"> 774             this.catchType = catchType;</span>
<span class="line-removed"> 775         }</span>
<span class="line-removed"> 776     };</span>
 777 
 778     /**
<span class="line-modified"> 779      * A MethodInfo object contains information about a particular method</span>
<span class="line-modified"> 780      * in the class being generated.  This class mirrors the data items of</span>
<span class="line-modified"> 781      * the &quot;method_info&quot; structure of the class file format (see JVMS 4.6).</span>




 782      */
<span class="line-modified"> 783     private class MethodInfo {</span>
<span class="line-modified"> 784         public int accessFlags;</span>
<span class="line-modified"> 785         public String name;</span>
<span class="line-modified"> 786         public String descriptor;</span>
<span class="line-modified"> 787         public short maxStack;</span>
<span class="line-removed"> 788         public short maxLocals;</span>
<span class="line-removed"> 789         public ByteArrayOutputStream code = new ByteArrayOutputStream();</span>
<span class="line-removed"> 790         public List&lt;ExceptionTableEntry&gt; exceptionTable =</span>
<span class="line-removed"> 791             new ArrayList&lt;ExceptionTableEntry&gt;();</span>
<span class="line-removed"> 792         public short[] declaredExceptions;</span>
<span class="line-removed"> 793 </span>
<span class="line-removed"> 794         public MethodInfo(String name, String descriptor, int accessFlags) {</span>
<span class="line-removed"> 795             this.name = name;</span>
<span class="line-removed"> 796             this.descriptor = descriptor;</span>
<span class="line-removed"> 797             this.accessFlags = accessFlags;</span>
<span class="line-removed"> 798 </span>
<span class="line-removed"> 799             /*</span>
<span class="line-removed"> 800              * Make sure that constant pool indexes are reserved for the</span>
<span class="line-removed"> 801              * following items before starting to write the final class file.</span>
<span class="line-removed"> 802              */</span>
<span class="line-removed"> 803             cp.getUtf8(name);</span>
<span class="line-removed"> 804             cp.getUtf8(descriptor);</span>
<span class="line-removed"> 805             cp.getUtf8(&quot;Code&quot;);</span>
<span class="line-removed"> 806             cp.getUtf8(&quot;Exceptions&quot;);</span>
 807         }

 808 
<span class="line-modified"> 809         public void write(DataOutputStream out) throws IOException {</span>
<span class="line-modified"> 810             /*</span>
<span class="line-modified"> 811              * Write all the items of the &quot;method_info&quot; structure.</span>
<span class="line-modified"> 812              * See JVMS section 4.6.</span>
<span class="line-modified"> 813              */</span>
<span class="line-modified"> 814                                         // u2 access_flags;</span>
<span class="line-modified"> 815             out.writeShort(accessFlags);</span>
<span class="line-modified"> 816                                         // u2 name_index;</span>
<span class="line-modified"> 817             out.writeShort(cp.getUtf8(name));</span>
<span class="line-modified"> 818                                         // u2 descriptor_index;</span>
<span class="line-modified"> 819             out.writeShort(cp.getUtf8(descriptor));</span>
<span class="line-modified"> 820                                         // u2 attributes_count;</span>
<span class="line-modified"> 821             out.writeShort(2);  // (two method_info attributes:)</span>
<span class="line-modified"> 822 </span>
<span class="line-modified"> 823             // Write &quot;Code&quot; attribute. See JVMS section 4.7.3.</span>
<span class="line-modified"> 824 </span>
<span class="line-modified"> 825                                         // u2 attribute_name_index;</span>
<span class="line-modified"> 826             out.writeShort(cp.getUtf8(&quot;Code&quot;));</span>
<span class="line-modified"> 827                                         // u4 attribute_length;</span>
<span class="line-modified"> 828             out.writeInt(12 + code.size() + 8 * exceptionTable.size());</span>
<span class="line-removed"> 829                                         // u2 max_stack;</span>
<span class="line-removed"> 830             out.writeShort(maxStack);</span>
<span class="line-removed"> 831                                         // u2 max_locals;</span>
<span class="line-removed"> 832             out.writeShort(maxLocals);</span>
<span class="line-removed"> 833                                         // u2 code_length;</span>
<span class="line-removed"> 834             out.writeInt(code.size());</span>
<span class="line-removed"> 835                                         // u1 code[code_length];</span>
<span class="line-removed"> 836             code.writeTo(out);</span>
<span class="line-removed"> 837                                         // u2 exception_table_length;</span>
<span class="line-removed"> 838             out.writeShort(exceptionTable.size());</span>
<span class="line-removed"> 839             for (ExceptionTableEntry e : exceptionTable) {</span>
<span class="line-removed"> 840                                         // u2 start_pc;</span>
<span class="line-removed"> 841                 out.writeShort(e.startPc);</span>
<span class="line-removed"> 842                                         // u2 end_pc;</span>
<span class="line-removed"> 843                 out.writeShort(e.endPc);</span>
<span class="line-removed"> 844                                         // u2 handler_pc;</span>
<span class="line-removed"> 845                 out.writeShort(e.handlerPc);</span>
<span class="line-removed"> 846                                         // u2 catch_type;</span>
<span class="line-removed"> 847                 out.writeShort(e.catchType);</span>
<span class="line-removed"> 848             }</span>
<span class="line-removed"> 849                                         // u2 attributes_count;</span>
<span class="line-removed"> 850             out.writeShort(0);</span>
<span class="line-removed"> 851 </span>
<span class="line-removed"> 852             // write &quot;Exceptions&quot; attribute.  See JVMS section 4.7.4.</span>
<span class="line-removed"> 853 </span>
<span class="line-removed"> 854                                         // u2 attribute_name_index;</span>
<span class="line-removed"> 855             out.writeShort(cp.getUtf8(&quot;Exceptions&quot;));</span>
<span class="line-removed"> 856                                         // u4 attributes_length;</span>
<span class="line-removed"> 857             out.writeInt(2 + 2 * declaredExceptions.length);</span>
<span class="line-removed"> 858                                         // u2 number_of_exceptions;</span>
<span class="line-removed"> 859             out.writeShort(declaredExceptions.length);</span>
<span class="line-removed"> 860                         // u2 exception_index_table[number_of_exceptions];</span>
<span class="line-removed"> 861             for (short value : declaredExceptions) {</span>
<span class="line-removed"> 862                 out.writeShort(value);</span>
 863             }
 864         }
<span class="line-removed"> 865 </span>
 866     }
 867 
 868     /**
<span class="line-modified"> 869      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified"> 870      * being generated: a method whose implementation will encode and</span>
<span class="line-modified"> 871      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>


 872      */
<span class="line-modified"> 873     private class ProxyMethod {</span>
<span class="line-modified"> 874 </span>
<span class="line-modified"> 875         public String methodName;</span>
<span class="line-removed"> 876         public Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-removed"> 877         public Class&lt;?&gt; returnType;</span>
<span class="line-removed"> 878         public Class&lt;?&gt;[] exceptionTypes;</span>
<span class="line-removed"> 879         public Class&lt;?&gt; fromClass;</span>
<span class="line-removed"> 880         public String methodFieldName;</span>
 881 
<span class="line-modified"> 882         private ProxyMethod(String methodName, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-modified"> 883                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-modified"> 884                             Class&lt;?&gt; fromClass)</span>
<span class="line-modified"> 885         {</span>
<span class="line-modified"> 886             this.methodName = methodName;</span>
<span class="line-modified"> 887             this.parameterTypes = parameterTypes;</span>
<span class="line-modified"> 888             this.returnType = returnType;</span>
<span class="line-removed"> 889             this.exceptionTypes = exceptionTypes;</span>
<span class="line-removed"> 890             this.fromClass = fromClass;</span>
<span class="line-removed"> 891             this.methodFieldName = &quot;m&quot; + proxyMethodCount++;</span>
<span class="line-removed"> 892         }</span>
 893 
<span class="line-modified"> 894         /**</span>
<span class="line-modified"> 895          * Return a MethodInfo object for this method, including generating</span>
<span class="line-modified"> 896          * the code and exception table entry.</span>



 897          */
<span class="line-modified"> 898         private MethodInfo generateMethod() throws IOException {</span>
<span class="line-modified"> 899             String desc = getMethodDescriptor(parameterTypes, returnType);</span>
<span class="line-modified"> 900             MethodInfo minfo = new MethodInfo(methodName, desc,</span>
<span class="line-removed"> 901                 ACC_PUBLIC | ACC_FINAL);</span>
 902 
<span class="line-modified"> 903             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-modified"> 904             int nextSlot = 1;</span>
<span class="line-modified"> 905             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-modified"> 906                 parameterSlot[i] = nextSlot;</span>
<span class="line-modified"> 907                 nextSlot += getWordsPerType(parameterTypes[i]);</span>



 908             }
<span class="line-modified"> 909             int localSlot0 = nextSlot;</span>
<span class="line-removed"> 910             short pc, tryBegin = 0, tryEnd;</span>
<span class="line-removed"> 911 </span>
<span class="line-removed"> 912             DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed"> 913 </span>
<span class="line-removed"> 914             code_aload(0, out);</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916             out.writeByte(opc_getfield);</span>
<span class="line-removed"> 917             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed"> 918                 superclassName,</span>
<span class="line-removed"> 919                 handlerFieldName, &quot;Ljava/lang/reflect/InvocationHandler;&quot;));</span>
 920 
<span class="line-modified"> 921             code_aload(0, out);</span>






 922 
<span class="line-modified"> 923             out.writeByte(opc_getstatic);</span>
<span class="line-removed"> 924             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed"> 925                 dotToSlash(className),</span>
<span class="line-removed"> 926                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
 927 
<span class="line-modified"> 928             if (parameterTypes.length &gt; 0) {</span>




 929 
<span class="line-modified"> 930                 code_ipush(parameterTypes.length, out);</span>



 931 
<span class="line-modified"> 932                 out.writeByte(opc_anewarray);</span>
<span class="line-removed"> 933                 out.writeShort(cp.getClass(&quot;java/lang/Object&quot;));</span>
 934 
<span class="line-modified"> 935                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>

 936 
<span class="line-modified"> 937                     out.writeByte(opc_dup);</span>















 938 
<span class="line-modified"> 939                     code_ipush(i, out);</span>























 940 
<span class="line-modified"> 941                     codeWrapArgument(parameterTypes[i], parameterSlot[i], out);</span>










 942 
<span class="line-modified"> 943                     out.writeByte(opc_aastore);</span>
<span class="line-modified"> 944                 }</span>
<span class="line-modified"> 945             } else {</span>















 946 
<span class="line-modified"> 947                 out.writeByte(opc_aconst_null);</span>
<span class="line-modified"> 948             }</span>




















































 949 
<span class="line-modified"> 950             out.writeByte(opc_invokeinterface);</span>
<span class="line-modified"> 951             out.writeShort(cp.getInterfaceMethodRef(</span>
<span class="line-modified"> 952                 &quot;java/lang/reflect/InvocationHandler&quot;,</span>
<span class="line-modified"> 953                 &quot;invoke&quot;,</span>
<span class="line-modified"> 954                 &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-modified"> 955                     &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;));</span>
<span class="line-removed"> 956             out.writeByte(4);</span>
<span class="line-removed"> 957             out.writeByte(0);</span>
 958 
<span class="line-modified"> 959             if (returnType == void.class) {</span>






 960 
<span class="line-modified"> 961                 out.writeByte(opc_pop);</span>










 962 
<span class="line-modified"> 963                 out.writeByte(opc_return);</span>










 964 
<span class="line-modified"> 965             } else {</span>








 966 
<span class="line-modified"> 967                 codeUnwrapReturnValue(returnType, out);</span>




 968             }
 969 
<span class="line-modified"> 970             tryEnd = pc = (short) minfo.code.size();</span>




 971 
 972             List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
 973             if (catchList.size() &gt; 0) {
<span class="line-removed"> 974 </span>
 975                 for (Class&lt;?&gt; ex : catchList) {
<span class="line-modified"> 976                     minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-modified"> 977                         tryBegin, tryEnd, pc,</span>
<span class="line-removed"> 978                         cp.getClass(dotToSlash(ex.getName()))));</span>
 979                 }
 980 
<span class="line-modified"> 981                 out.writeByte(opc_athrow);</span>
<span class="line-modified"> 982 </span>
<span class="line-modified"> 983                 pc = (short) minfo.code.size();</span>
<span class="line-modified"> 984 </span>
<span class="line-removed"> 985                 minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed"> 986                     tryBegin, tryEnd, pc, cp.getClass(&quot;java/lang/Throwable&quot;)));</span>
<span class="line-removed"> 987 </span>
<span class="line-removed"> 988                 code_astore(localSlot0, out);</span>
<span class="line-removed"> 989 </span>
<span class="line-removed"> 990                 out.writeByte(opc_new);</span>
<span class="line-removed"> 991                 out.writeShort(cp.getClass(</span>
<span class="line-removed"> 992                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;));</span>
<span class="line-removed"> 993 </span>
<span class="line-removed"> 994                 out.writeByte(opc_dup);</span>
 995 
<span class="line-modified"> 996                 code_aload(localSlot0, out);</span>





 997 
<span class="line-modified"> 998                 out.writeByte(opc_invokespecial);</span>












 999 
<span class="line-modified">1000                 out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">1001                     &quot;java/lang/reflect/UndeclaredThrowableException&quot;,</span>
<span class="line-modified">1002                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;));</span>

1003 
<span class="line-modified">1004                 out.writeByte(opc_athrow);</span>




1005             }
1006 
<span class="line-modified">1007             if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">1008                 throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
<span class="line-removed">1009             }</span>
1010 
<span class="line-modified">1011             minfo.maxStack = 10;</span>
<span class="line-modified">1012             minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-modified">1013             minfo.declaredExceptions = new short[exceptionTypes.length];</span>
<span class="line-removed">1014             for (int i = 0; i &lt; exceptionTypes.length; i++) {</span>
<span class="line-removed">1015                 minfo.declaredExceptions[i] = cp.getClass(</span>
<span class="line-removed">1016                     dotToSlash(exceptionTypes[i].getName()));</span>
<span class="line-removed">1017             }</span>
1018 
<span class="line-modified">1019             return minfo;</span>










1020         }
1021 
1022         /**
1023          * Generate code for wrapping an argument of the given type
1024          * whose value can be found at the specified local variable
1025          * index, in order for it to be passed (as an Object) to the
<span class="line-modified">1026          * invocation handler&#39;s &quot;invoke&quot; method.  The code is written</span>
<span class="line-removed">1027          * to the supplied stream.</span>
1028          */
<span class="line-modified">1029         private void codeWrapArgument(Class&lt;?&gt; type, int slot,</span>
<span class="line-removed">1030                                       DataOutputStream out)</span>
<span class="line-removed">1031             throws IOException</span>
<span class="line-removed">1032         {</span>
1033             if (type.isPrimitive()) {
1034                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
1035 
1036                 if (type == int.class ||
<span class="line-modified">1037                     type == boolean.class ||</span>
<span class="line-modified">1038                     type == byte.class ||</span>
<span class="line-modified">1039                     type == char.class ||</span>
<span class="line-modified">1040                     type == short.class)</span>
<span class="line-modified">1041                 {</span>
<span class="line-removed">1042                     code_iload(slot, out);</span>
1043                 } else if (type == long.class) {
<span class="line-modified">1044                     code_lload(slot, out);</span>
1045                 } else if (type == float.class) {
<span class="line-modified">1046                     code_fload(slot, out);</span>
1047                 } else if (type == double.class) {
<span class="line-modified">1048                     code_dload(slot, out);</span>
1049                 } else {
1050                     throw new AssertionError();
1051                 }
<span class="line-modified">1052 </span>
<span class="line-modified">1053                 out.writeByte(opc_invokestatic);</span>
<span class="line-removed">1054                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1055                     prim.wrapperClassName,</span>
<span class="line-removed">1056                     &quot;valueOf&quot;, prim.wrapperValueOfDesc));</span>
<span class="line-removed">1057 </span>
1058             } else {
<span class="line-modified">1059 </span>
<span class="line-removed">1060                 code_aload(slot, out);</span>
1061             }
1062         }
1063 
1064         /**
1065          * Generate code for unwrapping a return value of the given
1066          * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<span class="line-modified">1067          * Object) to its correct type.  The code is written to the</span>
<span class="line-removed">1068          * supplied stream.</span>
1069          */
<span class="line-modified">1070         private void codeUnwrapReturnValue(Class&lt;?&gt; type, DataOutputStream out)</span>
<span class="line-removed">1071             throws IOException</span>
<span class="line-removed">1072         {</span>
1073             if (type.isPrimitive()) {
1074                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
1075 
<span class="line-modified">1076                 out.writeByte(opc_checkcast);</span>
<span class="line-modified">1077                 out.writeShort(cp.getClass(prim.wrapperClassName));</span>
<span class="line-modified">1078 </span>
<span class="line-modified">1079                 out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1080                 out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1081                     prim.wrapperClassName,</span>
<span class="line-removed">1082                     prim.unwrapMethodName, prim.unwrapMethodDesc));</span>
1083 
1084                 if (type == int.class ||
<span class="line-modified">1085                     type == boolean.class ||</span>
<span class="line-modified">1086                     type == byte.class ||</span>
<span class="line-modified">1087                     type == char.class ||</span>
<span class="line-modified">1088                     type == short.class)</span>
<span class="line-modified">1089                 {</span>
<span class="line-removed">1090                     out.writeByte(opc_ireturn);</span>
1091                 } else if (type == long.class) {
<span class="line-modified">1092                     out.writeByte(opc_lreturn);</span>
1093                 } else if (type == float.class) {
<span class="line-modified">1094                     out.writeByte(opc_freturn);</span>
1095                 } else if (type == double.class) {
<span class="line-modified">1096                     out.writeByte(opc_dreturn);</span>
1097                 } else {
1098                     throw new AssertionError();
1099                 }
<span class="line-removed">1100 </span>
1101             } else {
<span class="line-modified">1102 </span>
<span class="line-modified">1103                 out.writeByte(opc_checkcast);</span>
<span class="line-removed">1104                 out.writeShort(cp.getClass(dotToSlash(type.getName())));</span>
<span class="line-removed">1105 </span>
<span class="line-removed">1106                 out.writeByte(opc_areturn);</span>
1107             }
1108         }
1109 
1110         /**
1111          * Generate code for initializing the static field that stores
<span class="line-modified">1112          * the Method object for this proxy method.  The code is written</span>
<span class="line-removed">1113          * to the supplied stream.</span>
1114          */
<span class="line-modified">1115         private void codeFieldInitialization(DataOutputStream out)</span>
<span class="line-modified">1116             throws IOException</span>
<span class="line-removed">1117         {</span>
<span class="line-removed">1118             codeClassForName(fromClass, out);</span>
1119 
<span class="line-modified">1120             code_ldc(cp.getString(methodName), out);</span>
1121 
<span class="line-modified">1122             code_ipush(parameterTypes.length, out);</span>
1123 
<span class="line-modified">1124             out.writeByte(opc_anewarray);</span>
<span class="line-removed">1125             out.writeShort(cp.getClass(&quot;java/lang/Class&quot;));</span>
1126 

1127             for (int i = 0; i &lt; parameterTypes.length; i++) {
<span class="line-modified">1128 </span>
<span class="line-modified">1129                 out.writeByte(opc_dup);</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131                 code_ipush(i, out);</span>
1132 
1133                 if (parameterTypes[i].isPrimitive()) {
1134                     PrimitiveTypeInfo prim =
<span class="line-modified">1135                         PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified">1136 </span>
<span class="line-modified">1137                     out.writeByte(opc_getstatic);</span>
<span class="line-removed">1138                     out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">1139                         prim.wrapperClassName, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;));</span>
<span class="line-removed">1140 </span>
1141                 } else {
<span class="line-modified">1142                     codeClassForName(parameterTypes[i], out);</span>
1143                 }
<span class="line-modified">1144 </span>
<span class="line-removed">1145                 out.writeByte(opc_aastore);</span>
1146             }






1147 
<span class="line-modified">1148             out.writeByte(opc_invokevirtual);</span>
<span class="line-modified">1149             out.writeShort(cp.getMethodRef(</span>
<span class="line-modified">1150                 &quot;java/lang/Class&quot;,</span>
<span class="line-removed">1151                 &quot;getMethod&quot;,</span>
<span class="line-removed">1152                 &quot;(Ljava/lang/String;[Ljava/lang/Class;)&quot; +</span>
<span class="line-removed">1153                 &quot;Ljava/lang/reflect/Method;&quot;));</span>
<span class="line-removed">1154 </span>
<span class="line-removed">1155             out.writeByte(opc_putstatic);</span>
<span class="line-removed">1156             out.writeShort(cp.getFieldRef(</span>
<span class="line-removed">1157                 dotToSlash(className),</span>
<span class="line-removed">1158                 methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;));</span>
1159         }
<span class="line-removed">1160     }</span>
<span class="line-removed">1161 </span>
<span class="line-removed">1162     /**</span>
<span class="line-removed">1163      * Generate the constructor method for the proxy class.</span>
<span class="line-removed">1164      */</span>
<span class="line-removed">1165     private MethodInfo generateConstructor() throws IOException {</span>
<span class="line-removed">1166         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">1167             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;,</span>
<span class="line-removed">1168             ACC_PUBLIC);</span>
<span class="line-removed">1169 </span>
<span class="line-removed">1170         DataOutputStream out = new DataOutputStream(minfo.code);</span>
<span class="line-removed">1171 </span>
<span class="line-removed">1172         code_aload(0, out);</span>
1173 
<span class="line-modified">1174         code_aload(1, out);</span>
<span class="line-modified">1175 </span>
<span class="line-modified">1176         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1177         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1178             superclassName,</span>
<span class="line-removed">1179             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;));</span>
<span class="line-removed">1180 </span>
<span class="line-removed">1181         out.writeByte(opc_return);</span>
<span class="line-removed">1182 </span>
<span class="line-removed">1183         minfo.maxStack = 10;</span>
<span class="line-removed">1184         minfo.maxLocals = 2;</span>
<span class="line-removed">1185         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">1186 </span>
<span class="line-removed">1187         return minfo;</span>
<span class="line-removed">1188     }</span>
<span class="line-removed">1189 </span>
<span class="line-removed">1190     /**</span>
<span class="line-removed">1191      * Generate the static initializer method for the proxy class.</span>
<span class="line-removed">1192      */</span>
<span class="line-removed">1193     private MethodInfo generateStaticInitializer() throws IOException {</span>
<span class="line-removed">1194         MethodInfo minfo = new MethodInfo(</span>
<span class="line-removed">1195             &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, ACC_STATIC);</span>
<span class="line-removed">1196 </span>
<span class="line-removed">1197         int localSlot0 = 1;</span>
<span class="line-removed">1198         short pc, tryBegin = 0, tryEnd;</span>
1199 
<span class="line-modified">1200         DataOutputStream out = new DataOutputStream(minfo.code);</span>











1201 
<span class="line-modified">1202         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-modified">1203             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-modified">1204                 pm.codeFieldInitialization(out);</span>












1205             }
1206         }
1207 
<span class="line-modified">1208         out.writeByte(opc_return);</span>
<span class="line-modified">1209 </span>
<span class="line-modified">1210         tryEnd = pc = (short) minfo.code.size();</span>
<span class="line-removed">1211 </span>
<span class="line-removed">1212         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">1213             tryBegin, tryEnd, pc,</span>
<span class="line-removed">1214             cp.getClass(&quot;java/lang/NoSuchMethodException&quot;)));</span>
<span class="line-removed">1215 </span>
<span class="line-removed">1216         code_astore(localSlot0, out);</span>
<span class="line-removed">1217 </span>
<span class="line-removed">1218         out.writeByte(opc_new);</span>
<span class="line-removed">1219         out.writeShort(cp.getClass(&quot;java/lang/NoSuchMethodError&quot;));</span>
<span class="line-removed">1220 </span>
<span class="line-removed">1221         out.writeByte(opc_dup);</span>
<span class="line-removed">1222 </span>
<span class="line-removed">1223         code_aload(localSlot0, out);</span>
<span class="line-removed">1224 </span>
<span class="line-removed">1225         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1226         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1227             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">1228 </span>
<span class="line-removed">1229         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1230         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1231             &quot;java/lang/NoSuchMethodError&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">1232 </span>
<span class="line-removed">1233         out.writeByte(opc_athrow);</span>
<span class="line-removed">1234 </span>
<span class="line-removed">1235         pc = (short) minfo.code.size();</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237         minfo.exceptionTable.add(new ExceptionTableEntry(</span>
<span class="line-removed">1238             tryBegin, tryEnd, pc,</span>
<span class="line-removed">1239             cp.getClass(&quot;java/lang/ClassNotFoundException&quot;)));</span>
<span class="line-removed">1240 </span>
<span class="line-removed">1241         code_astore(localSlot0, out);</span>
<span class="line-removed">1242 </span>
<span class="line-removed">1243         out.writeByte(opc_new);</span>
<span class="line-removed">1244         out.writeShort(cp.getClass(&quot;java/lang/NoClassDefFoundError&quot;));</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246         out.writeByte(opc_dup);</span>
<span class="line-removed">1247 </span>
<span class="line-removed">1248         code_aload(localSlot0, out);</span>
<span class="line-removed">1249 </span>
<span class="line-removed">1250         out.writeByte(opc_invokevirtual);</span>
<span class="line-removed">1251         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1252             &quot;java/lang/Throwable&quot;, &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;));</span>
<span class="line-removed">1253 </span>
<span class="line-removed">1254         out.writeByte(opc_invokespecial);</span>
<span class="line-removed">1255         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1256             &quot;java/lang/NoClassDefFoundError&quot;,</span>
<span class="line-removed">1257             &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;));</span>
<span class="line-removed">1258 </span>
<span class="line-removed">1259         out.writeByte(opc_athrow);</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261         if (minfo.code.size() &gt; 65535) {</span>
<span class="line-removed">1262             throw new IllegalArgumentException(&quot;code size limit exceeded&quot;);</span>
1263         }
<span class="line-removed">1264 </span>
<span class="line-removed">1265         minfo.maxStack = 10;</span>
<span class="line-removed">1266         minfo.maxLocals = (short) (localSlot0 + 1);</span>
<span class="line-removed">1267         minfo.declaredExceptions = new short[0];</span>
<span class="line-removed">1268 </span>
<span class="line-removed">1269         return minfo;</span>
1270     }
1271 
<span class="line-modified">1272 </span>
<span class="line-modified">1273     /*</span>
<span class="line-modified">1274      * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified">1275      */</span>
<span class="line-removed">1276 </span>
<span class="line-removed">1277     /*</span>
<span class="line-removed">1278      * The following methods generate code for the load or store operation</span>
<span class="line-removed">1279      * indicated by their name for the given local variable.  The code is</span>
<span class="line-removed">1280      * written to the supplied stream.</span>
1281      */

1282 
<span class="line-modified">1283     private void code_iload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1284         throws IOException</span>
<span class="line-removed">1285     {</span>
<span class="line-removed">1286         codeLocalLoadStore(lvar, opc_iload, opc_iload_0, out);</span>
<span class="line-removed">1287     }</span>
<span class="line-removed">1288 </span>
<span class="line-removed">1289     private void code_lload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1290         throws IOException</span>
<span class="line-removed">1291     {</span>
<span class="line-removed">1292         codeLocalLoadStore(lvar, opc_lload, opc_lload_0, out);</span>
<span class="line-removed">1293     }</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295     private void code_fload(int lvar, DataOutputStream out)</span>
<span class="line-removed">1296         throws IOException</span>
<span class="line-removed">1297     {</span>
<span class="line-removed">1298         codeLocalLoadStore(lvar, opc_fload, opc_fload_0, out);</span>
<span class="line-removed">1299     }</span>
1300 
<span class="line-modified">1301     private void code_dload(int lvar, DataOutputStream out)</span>
<span class="line-modified">1302         throws IOException</span>
<span class="line-modified">1303     {</span>
<span class="line-modified">1304         codeLocalLoadStore(lvar, opc_dload, opc_dload_0, out);</span>
<span class="line-modified">1305     }</span>





1306 
<span class="line-modified">1307     private void code_aload(int lvar, DataOutputStream out)</span>
<span class="line-modified">1308         throws IOException</span>
<span class="line-modified">1309     {</span>
<span class="line-modified">1310         codeLocalLoadStore(lvar, opc_aload, opc_aload_0, out);</span>
<span class="line-modified">1311     }</span>











1312 
<span class="line-modified">1313 //  private void code_istore(int lvar, DataOutputStream out)</span>
<span class="line-modified">1314 //      throws IOException</span>
<span class="line-removed">1315 //  {</span>
<span class="line-removed">1316 //      codeLocalLoadStore(lvar, opc_istore, opc_istore_0, out);</span>
<span class="line-removed">1317 //  }</span>
<span class="line-removed">1318 </span>
<span class="line-removed">1319 //  private void code_lstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1320 //      throws IOException</span>
<span class="line-removed">1321 //  {</span>
<span class="line-removed">1322 //      codeLocalLoadStore(lvar, opc_lstore, opc_lstore_0, out);</span>
<span class="line-removed">1323 //  }</span>
<span class="line-removed">1324 </span>
<span class="line-removed">1325 //  private void code_fstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1326 //      throws IOException</span>
<span class="line-removed">1327 //  {</span>
<span class="line-removed">1328 //      codeLocalLoadStore(lvar, opc_fstore, opc_fstore_0, out);</span>
<span class="line-removed">1329 //  }</span>
<span class="line-removed">1330 </span>
<span class="line-removed">1331 //  private void code_dstore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1332 //      throws IOException</span>
<span class="line-removed">1333 //  {</span>
<span class="line-removed">1334 //      codeLocalLoadStore(lvar, opc_dstore, opc_dstore_0, out);</span>
<span class="line-removed">1335 //  }</span>
<span class="line-removed">1336 </span>
<span class="line-removed">1337     private void code_astore(int lvar, DataOutputStream out)</span>
<span class="line-removed">1338         throws IOException</span>
<span class="line-removed">1339     {</span>
<span class="line-removed">1340         codeLocalLoadStore(lvar, opc_astore, opc_astore_0, out);</span>
<span class="line-removed">1341     }</span>
1342 
<span class="line-modified">1343     /**</span>
<span class="line-modified">1344      * Generate code for a load or store instruction for the given local</span>
<span class="line-removed">1345      * variable.  The code is written to the supplied stream.</span>
<span class="line-removed">1346      *</span>
<span class="line-removed">1347      * &quot;opcode&quot; indicates the opcode form of the desired load or store</span>
<span class="line-removed">1348      * instruction that takes an explicit local variable index, and</span>
<span class="line-removed">1349      * &quot;opcode_0&quot; indicates the corresponding form of the instruction</span>
<span class="line-removed">1350      * with the implicit index 0.</span>
<span class="line-removed">1351      */</span>
<span class="line-removed">1352     private void codeLocalLoadStore(int lvar, int opcode, int opcode_0,</span>
<span class="line-removed">1353                                     DataOutputStream out)</span>
<span class="line-removed">1354         throws IOException</span>
<span class="line-removed">1355     {</span>
<span class="line-removed">1356         assert lvar &gt;= 0 &amp;&amp; lvar &lt;= 0xFFFF;</span>
<span class="line-removed">1357         if (lvar &lt;= 3) {</span>
<span class="line-removed">1358             out.writeByte(opcode_0 + lvar);</span>
<span class="line-removed">1359         } else if (lvar &lt;= 0xFF) {</span>
<span class="line-removed">1360             out.writeByte(opcode);</span>
<span class="line-removed">1361             out.writeByte(lvar &amp; 0xFF);</span>
<span class="line-removed">1362         } else {</span>
<span class="line-removed">1363             /*</span>
<span class="line-removed">1364              * Use the &quot;wide&quot; instruction modifier for local variable</span>
<span class="line-removed">1365              * indexes that do not fit into an unsigned byte.</span>
1366              */
<span class="line-modified">1367             out.writeByte(opc_wide);</span>
<span class="line-modified">1368             out.writeByte(opcode);</span>
<span class="line-modified">1369             out.writeShort(lvar &amp; 0xFFFF);</span>
<span class="line-modified">1370         }</span>
<span class="line-modified">1371     }</span>
<span class="line-modified">1372 </span>
<span class="line-modified">1373     /**</span>
<span class="line-modified">1374      * Generate code for an &quot;ldc&quot; instruction for the given constant pool</span>
<span class="line-removed">1375      * index (the &quot;ldc_w&quot; instruction is used if the index does not fit</span>
<span class="line-removed">1376      * into an unsigned byte).  The code is written to the supplied stream.</span>
<span class="line-removed">1377      */</span>
<span class="line-removed">1378     private void code_ldc(int index, DataOutputStream out)</span>
<span class="line-removed">1379         throws IOException</span>
<span class="line-removed">1380     {</span>
<span class="line-removed">1381         assert index &gt;= 0 &amp;&amp; index &lt;= 0xFFFF;</span>
<span class="line-removed">1382         if (index &lt;= 0xFF) {</span>
<span class="line-removed">1383             out.writeByte(opc_ldc);</span>
<span class="line-removed">1384             out.writeByte(index &amp; 0xFF);</span>
<span class="line-removed">1385         } else {</span>
<span class="line-removed">1386             out.writeByte(opc_ldc_w);</span>
<span class="line-removed">1387             out.writeShort(index &amp; 0xFFFF);</span>
1388         }
<span class="line-removed">1389     }</span>
1390 
<span class="line-modified">1391     /**</span>
<span class="line-modified">1392      * Generate code to push a constant integer value on to the operand</span>
<span class="line-modified">1393      * stack, using the &quot;iconst_&lt;i&gt;&quot;, &quot;bipush&quot;, or &quot;sipush&quot; instructions</span>
<span class="line-removed">1394      * depending on the size of the value.  The code is written to the</span>
<span class="line-removed">1395      * supplied stream.</span>
<span class="line-removed">1396      */</span>
<span class="line-removed">1397     private void code_ipush(int value, DataOutputStream out)</span>
<span class="line-removed">1398         throws IOException</span>
<span class="line-removed">1399     {</span>
<span class="line-removed">1400         if (value &gt;= -1 &amp;&amp; value &lt;= 5) {</span>
<span class="line-removed">1401             out.writeByte(opc_iconst_0 + value);</span>
<span class="line-removed">1402         } else if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">1403             out.writeByte(opc_bipush);</span>
<span class="line-removed">1404             out.writeByte(value &amp; 0xFF);</span>
<span class="line-removed">1405         } else if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">1406             out.writeByte(opc_sipush);</span>
<span class="line-removed">1407             out.writeShort(value &amp; 0xFFFF);</span>
<span class="line-removed">1408         } else {</span>
<span class="line-removed">1409             throw new AssertionError();</span>
<span class="line-removed">1410         }</span>
<span class="line-removed">1411     }</span>
<span class="line-removed">1412 </span>
<span class="line-removed">1413     /**</span>
<span class="line-removed">1414      * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-removed">1415      * class to get its Class object at runtime.  The code is written to</span>
<span class="line-removed">1416      * the supplied stream.  Note that the code generated by this method</span>
<span class="line-removed">1417      * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-removed">1418      */</span>
<span class="line-removed">1419     private void codeClassForName(Class&lt;?&gt; cl, DataOutputStream out)</span>
<span class="line-removed">1420         throws IOException</span>
<span class="line-removed">1421     {</span>
<span class="line-removed">1422         code_ldc(cp.getString(cl.getName()), out);</span>
<span class="line-removed">1423 </span>
<span class="line-removed">1424         out.writeByte(opc_invokestatic);</span>
<span class="line-removed">1425         out.writeShort(cp.getMethodRef(</span>
<span class="line-removed">1426             &quot;java/lang/Class&quot;,</span>
<span class="line-removed">1427             &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;));</span>
<span class="line-removed">1428     }</span>
<span class="line-removed">1429 </span>
<span class="line-removed">1430 </span>
<span class="line-removed">1431     /*</span>
<span class="line-removed">1432      * ==================== General Utility Methods ====================</span>
<span class="line-removed">1433      */</span>
<span class="line-removed">1434 </span>
<span class="line-removed">1435     /**</span>
<span class="line-removed">1436      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-removed">1437      * separator, the external representation used by the Java language</span>
<span class="line-removed">1438      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-removed">1439      * package separator, the representation used in the class file</span>
<span class="line-removed">1440      * format (see JVMS section 4.2).</span>
<span class="line-removed">1441      */</span>
<span class="line-removed">1442     private static String dotToSlash(String name) {</span>
<span class="line-removed">1443         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">1444     }</span>
<span class="line-removed">1445 </span>
<span class="line-removed">1446     /**</span>
<span class="line-removed">1447      * Return the &quot;method descriptor&quot; string for a method with the given</span>
<span class="line-removed">1448      * parameter types and return type.  See JVMS section 4.3.3.</span>
<span class="line-removed">1449      */</span>
<span class="line-removed">1450     private static String getMethodDescriptor(Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-removed">1451                                               Class&lt;?&gt; returnType)</span>
<span class="line-removed">1452     {</span>
<span class="line-removed">1453         return getParameterDescriptors(parameterTypes) +</span>
<span class="line-removed">1454             ((returnType == void.class) ? &quot;V&quot; : getFieldType(returnType));</span>
<span class="line-removed">1455     }</span>
<span class="line-removed">1456 </span>
<span class="line-removed">1457     /**</span>
<span class="line-removed">1458      * Return the list of &quot;parameter descriptor&quot; strings enclosed in</span>
<span class="line-removed">1459      * parentheses corresponding to the given parameter types (in other</span>
<span class="line-removed">1460      * words, a method descriptor without a return descriptor).  This</span>
<span class="line-removed">1461      * string is useful for constructing string keys for methods without</span>
<span class="line-removed">1462      * regard to their return type.</span>
<span class="line-removed">1463      */</span>
<span class="line-removed">1464     private static String getParameterDescriptors(Class&lt;?&gt;[] parameterTypes) {</span>
<span class="line-removed">1465         StringBuilder desc = new StringBuilder(&quot;(&quot;);</span>
<span class="line-removed">1466         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">1467             desc.append(getFieldType(parameterTypes[i]));</span>
<span class="line-removed">1468         }</span>
<span class="line-removed">1469         desc.append(&#39;)&#39;);</span>
<span class="line-removed">1470         return desc.toString();</span>
<span class="line-removed">1471     }</span>
<span class="line-removed">1472 </span>
<span class="line-removed">1473     /**</span>
<span class="line-removed">1474      * Return the &quot;field type&quot; string for the given type, appropriate for</span>
<span class="line-removed">1475      * a field descriptor, a parameter descriptor, or a return descriptor</span>
<span class="line-removed">1476      * other than &quot;void&quot;.  See JVMS section 4.3.2.</span>
<span class="line-removed">1477      */</span>
<span class="line-removed">1478     private static String getFieldType(Class&lt;?&gt; type) {</span>
<span class="line-removed">1479         if (type.isPrimitive()) {</span>
<span class="line-removed">1480             return PrimitiveTypeInfo.get(type).baseTypeString;</span>
<span class="line-removed">1481         } else if (type.isArray()) {</span>
<span class="line-removed">1482             /*</span>
<span class="line-removed">1483              * According to JLS 20.3.2, the getName() method on Class does</span>
<span class="line-removed">1484              * return the VM type descriptor format for array classes (only);</span>
<span class="line-removed">1485              * using that should be quicker than the otherwise obvious code:</span>
<span class="line-removed">1486              *</span>
<span class="line-removed">1487              *     return &quot;[&quot; + getTypeDescriptor(type.getComponentType());</span>
<span class="line-removed">1488              */</span>
<span class="line-removed">1489             return type.getName().replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-removed">1490         } else {</span>
<span class="line-removed">1491             return &quot;L&quot; + dotToSlash(type.getName()) + &quot;;&quot;;</span>
<span class="line-removed">1492         }</span>
<span class="line-removed">1493     }</span>
<span class="line-removed">1494 </span>
<span class="line-removed">1495     /**</span>
<span class="line-removed">1496      * Returns a human-readable string representing the signature of a</span>
<span class="line-removed">1497      * method with the given name and parameter types.</span>
<span class="line-removed">1498      */</span>
<span class="line-removed">1499     private static String getFriendlyMethodSignature(String name,</span>
<span class="line-removed">1500                                                      Class&lt;?&gt;[] parameterTypes)</span>
<span class="line-removed">1501     {</span>
<span class="line-removed">1502         StringBuilder sig = new StringBuilder(name);</span>
<span class="line-removed">1503         sig.append(&#39;(&#39;);</span>
<span class="line-removed">1504         for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-removed">1505             if (i &gt; 0) {</span>
<span class="line-removed">1506                 sig.append(&#39;,&#39;);</span>
<span class="line-removed">1507             }</span>
<span class="line-removed">1508             Class&lt;?&gt; parameterType = parameterTypes[i];</span>
<span class="line-removed">1509             int dimensions = 0;</span>
<span class="line-removed">1510             while (parameterType.isArray()) {</span>
<span class="line-removed">1511                 parameterType = parameterType.getComponentType();</span>
<span class="line-removed">1512                 dimensions++;</span>
<span class="line-removed">1513             }</span>
<span class="line-removed">1514             sig.append(parameterType.getName());</span>
<span class="line-removed">1515             while (dimensions-- &gt; 0) {</span>
<span class="line-removed">1516                 sig.append(&quot;[]&quot;);</span>
<span class="line-removed">1517             }</span>
<span class="line-removed">1518         }</span>
<span class="line-removed">1519         sig.append(&#39;)&#39;);</span>
<span class="line-removed">1520         return sig.toString();</span>
<span class="line-removed">1521     }</span>
<span class="line-removed">1522 </span>
<span class="line-removed">1523     /**</span>
<span class="line-removed">1524      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-removed">1525      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-removed">1526      * section 3.6.1.</span>
<span class="line-removed">1527      *</span>
<span class="line-removed">1528      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-removed">1529      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-removed">1530      * was removed for the second edition.</span>
<span class="line-removed">1531      */</span>
<span class="line-removed">1532     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-removed">1533         if (type == long.class || type == double.class) {</span>
<span class="line-removed">1534             return 2;</span>
<span class="line-removed">1535         } else {</span>
<span class="line-removed">1536             return 1;</span>
<span class="line-removed">1537         }</span>
<span class="line-removed">1538     }</span>
<span class="line-removed">1539 </span>
<span class="line-removed">1540     /**</span>
<span class="line-removed">1541      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-removed">1542      * are not already contained in the list and are assignable to at</span>
<span class="line-removed">1543      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-removed">1544      *</span>
<span class="line-removed">1545      * This method is useful for computing the greatest common set of</span>
<span class="line-removed">1546      * declared exceptions from duplicate methods inherited from</span>
<span class="line-removed">1547      * different interfaces.</span>
<span class="line-removed">1548      */</span>
<span class="line-removed">1549     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-removed">1550                                                Class&lt;?&gt;[] with,</span>
<span class="line-removed">1551                                                List&lt;Class&lt;?&gt;&gt; list)</span>
<span class="line-removed">1552     {</span>
<span class="line-removed">1553         for (Class&lt;?&gt; fc: from) {</span>
<span class="line-removed">1554             if (!list.contains(fc)) {</span>
<span class="line-removed">1555                 for (Class&lt;?&gt; wc: with) {</span>
<span class="line-removed">1556                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-removed">1557                         list.add(fc);</span>
<span class="line-removed">1558                         break;</span>
<span class="line-removed">1559                     }</span>
<span class="line-removed">1560                 }</span>
<span class="line-removed">1561             }</span>
<span class="line-removed">1562         }</span>
<span class="line-removed">1563     }</span>
<span class="line-removed">1564 </span>
<span class="line-removed">1565     /**</span>
<span class="line-removed">1566      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-removed">1567      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-removed">1568      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-removed">1569      * implementation before catching other Throwables and wrapping them</span>
<span class="line-removed">1570      * in UndeclaredThrowableExceptions.</span>
<span class="line-removed">1571      *</span>
<span class="line-removed">1572      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-removed">1573      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-removed">1574      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-removed">1575      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-removed">1576      *</span>
<span class="line-removed">1577      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-removed">1578      * list (if none of their superclasses are contained), since those</span>
<span class="line-removed">1579      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-removed">1580      * subclasses will never appear in the returned list.</span>
<span class="line-removed">1581      *</span>
<span class="line-removed">1582      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-removed">1583      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-removed">1584      * need to be caught.</span>
<span class="line-removed">1585      */</span>
<span class="line-removed">1586     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-removed">1587         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-removed">1588                                                 // unique exceptions to catch</span>
<span class="line-removed">1589 </span>
<span class="line-removed">1590         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-removed">1591         uniqueList.add(RuntimeException.class);</span>
<span class="line-removed">1592 </span>
<span class="line-removed">1593     nextException:</span>
<span class="line-removed">1594         for (Class&lt;?&gt; ex: exceptions) {</span>
<span class="line-removed">1595             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-removed">1596                 /*</span>
<span class="line-removed">1597                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-removed">1598                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-removed">1599                  * can, at most, throw Throwable anyway.</span>
<span class="line-removed">1600                  */</span>
<span class="line-removed">1601                 uniqueList.clear();</span>
<span class="line-removed">1602                 break;</span>
<span class="line-removed">1603             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-removed">1604                 /*</span>
<span class="line-removed">1605                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-removed">1606                  */</span>
<span class="line-removed">1607                 continue;</span>
<span class="line-removed">1608             }</span>
<span class="line-removed">1609             /*</span>
<span class="line-removed">1610              * Compare this exception against the current list of</span>
<span class="line-removed">1611              * exceptions that need to be caught:</span>
<span class="line-removed">1612              */</span>
<span class="line-removed">1613             for (int j = 0; j &lt; uniqueList.size();) {</span>
<span class="line-removed">1614                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-removed">1615                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-removed">1616                     /*</span>
<span class="line-removed">1617                      * if a superclass of this exception is already on</span>
<span class="line-removed">1618                      * the list to catch, then ignore this one and continue;</span>
<span class="line-removed">1619                      */</span>
<span class="line-removed">1620                     continue nextException;</span>
<span class="line-removed">1621                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-removed">1622                     /*</span>
<span class="line-removed">1623                      * if a subclass of this exception is on the list</span>
<span class="line-removed">1624                      * to catch, then remove it;</span>
<span class="line-removed">1625                      */</span>
<span class="line-removed">1626                     uniqueList.remove(j);</span>
<span class="line-removed">1627                 } else {</span>
<span class="line-removed">1628                     j++;        // else continue comparing.</span>
<span class="line-removed">1629                 }</span>
<span class="line-removed">1630             }</span>
<span class="line-removed">1631             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-removed">1632             uniqueList.add(ex);</span>
<span class="line-removed">1633         }</span>
<span class="line-removed">1634         return uniqueList;</span>
<span class="line-removed">1635     }</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637     /**</span>
<span class="line-removed">1638      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-removed">1639      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-removed">1640      * primitive type can be obtained using the static &quot;get&quot; method.</span>
<span class="line-removed">1641      */</span>
<span class="line-removed">1642     private static class PrimitiveTypeInfo {</span>
<span class="line-removed">1643 </span>
<span class="line-removed">1644         /** &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2) */</span>
<span class="line-removed">1645         public String baseTypeString;</span>
<span class="line-removed">1646 </span>
<span class="line-removed">1647         /** name of corresponding wrapper class */</span>
<span class="line-removed">1648         public String wrapperClassName;</span>
<span class="line-removed">1649 </span>
<span class="line-removed">1650         /** method descriptor for wrapper class &quot;valueOf&quot; factory method */</span>
<span class="line-removed">1651         public String wrapperValueOfDesc;</span>
<span class="line-removed">1652 </span>
<span class="line-removed">1653         /** name of wrapper class method for retrieving primitive value */</span>
<span class="line-removed">1654         public String unwrapMethodName;</span>
<span class="line-removed">1655 </span>
<span class="line-removed">1656         /** descriptor of same method */</span>
<span class="line-removed">1657         public String unwrapMethodDesc;</span>
<span class="line-removed">1658 </span>
<span class="line-removed">1659         private static Map&lt;Class&lt;?&gt;,PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
<span class="line-removed">1660         static {</span>
<span class="line-removed">1661             add(byte.class, Byte.class);</span>
<span class="line-removed">1662             add(char.class, Character.class);</span>
<span class="line-removed">1663             add(double.class, Double.class);</span>
<span class="line-removed">1664             add(float.class, Float.class);</span>
<span class="line-removed">1665             add(int.class, Integer.class);</span>
<span class="line-removed">1666             add(long.class, Long.class);</span>
<span class="line-removed">1667             add(short.class, Short.class);</span>
<span class="line-removed">1668             add(boolean.class, Boolean.class);</span>
<span class="line-removed">1669         }</span>
<span class="line-removed">1670 </span>
<span class="line-removed">1671         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">1672             table.put(primitiveClass,</span>
<span class="line-removed">1673                       new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>
<span class="line-removed">1674         }</span>
<span class="line-removed">1675 </span>
<span class="line-removed">1676         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-removed">1677             assert primitiveClass.isPrimitive();</span>
<span class="line-removed">1678 </span>
<span class="line-removed">1679             baseTypeString =</span>
<span class="line-removed">1680                 Array.newInstance(primitiveClass, 0)</span>
<span class="line-removed">1681                 .getClass().getName().substring(1);</span>
<span class="line-removed">1682             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-removed">1683             wrapperValueOfDesc =</span>
<span class="line-removed">1684                 &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-removed">1685             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-removed">1686             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>
1687         }
1688 
1689         public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
1690             return table.get(cl);
1691         }
1692     }
<span class="line-removed">1693 </span>
<span class="line-removed">1694 </span>
<span class="line-removed">1695     /**</span>
<span class="line-removed">1696      * A ConstantPool object represents the constant pool of a class file</span>
<span class="line-removed">1697      * being generated.  This representation of a constant pool is designed</span>
<span class="line-removed">1698      * specifically for use by ProxyGenerator; in particular, it assumes</span>
<span class="line-removed">1699      * that constant pool entries will not need to be resorted (for example,</span>
<span class="line-removed">1700      * by their type, as the Java compiler does), so that the final index</span>
<span class="line-removed">1701      * value can be assigned and used when an entry is first created.</span>
<span class="line-removed">1702      *</span>
<span class="line-removed">1703      * Note that new entries cannot be created after the constant pool has</span>
<span class="line-removed">1704      * been written to a class file.  To prevent such logic errors, a</span>
<span class="line-removed">1705      * ConstantPool instance can be marked &quot;read only&quot;, so that further</span>
<span class="line-removed">1706      * attempts to add new entries will fail with a runtime exception.</span>
<span class="line-removed">1707      *</span>
<span class="line-removed">1708      * See JVMS section 4.4 for more information about the constant pool</span>
<span class="line-removed">1709      * of a class file.</span>
<span class="line-removed">1710      */</span>
<span class="line-removed">1711     private static class ConstantPool {</span>
<span class="line-removed">1712 </span>
<span class="line-removed">1713         /**</span>
<span class="line-removed">1714          * list of constant pool entries, in constant pool index order.</span>
<span class="line-removed">1715          *</span>
<span class="line-removed">1716          * This list is used when writing the constant pool to a stream</span>
<span class="line-removed">1717          * and for assigning the next index value.  Note that element 0</span>
<span class="line-removed">1718          * of this list corresponds to constant pool index 1.</span>
<span class="line-removed">1719          */</span>
<span class="line-removed">1720         private List&lt;Entry&gt; pool = new ArrayList&lt;&gt;(32);</span>
<span class="line-removed">1721 </span>
<span class="line-removed">1722         /**</span>
<span class="line-removed">1723          * maps constant pool data of all types to constant pool indexes.</span>
<span class="line-removed">1724          *</span>
<span class="line-removed">1725          * This map is used to look up the index of an existing entry for</span>
<span class="line-removed">1726          * values of all types.</span>
<span class="line-removed">1727          */</span>
<span class="line-removed">1728         private Map&lt;Object,Integer&gt; map = new HashMap&lt;&gt;(16);</span>
<span class="line-removed">1729 </span>
<span class="line-removed">1730         /** true if no new constant pool entries may be added */</span>
<span class="line-removed">1731         private boolean readOnly = false;</span>
<span class="line-removed">1732 </span>
<span class="line-removed">1733         /**</span>
<span class="line-removed">1734          * Get or assign the index for a CONSTANT_Utf8 entry.</span>
<span class="line-removed">1735          */</span>
<span class="line-removed">1736         public short getUtf8(String s) {</span>
<span class="line-removed">1737             if (s == null) {</span>
<span class="line-removed">1738                 throw new NullPointerException();</span>
<span class="line-removed">1739             }</span>
<span class="line-removed">1740             return getValue(s);</span>
<span class="line-removed">1741         }</span>
<span class="line-removed">1742 </span>
<span class="line-removed">1743         /**</span>
<span class="line-removed">1744          * Get or assign the index for a CONSTANT_Integer entry.</span>
<span class="line-removed">1745          */</span>
<span class="line-removed">1746         public short getInteger(int i) {</span>
<span class="line-removed">1747             return getValue(i);</span>
<span class="line-removed">1748         }</span>
<span class="line-removed">1749 </span>
<span class="line-removed">1750         /**</span>
<span class="line-removed">1751          * Get or assign the index for a CONSTANT_Float entry.</span>
<span class="line-removed">1752          */</span>
<span class="line-removed">1753         public short getFloat(float f) {</span>
<span class="line-removed">1754             return getValue(f);</span>
<span class="line-removed">1755         }</span>
<span class="line-removed">1756 </span>
<span class="line-removed">1757         /**</span>
<span class="line-removed">1758          * Get or assign the index for a CONSTANT_Class entry.</span>
<span class="line-removed">1759          */</span>
<span class="line-removed">1760         public short getClass(String name) {</span>
<span class="line-removed">1761             short utf8Index = getUtf8(name);</span>
<span class="line-removed">1762             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1763                 CONSTANT_CLASS, utf8Index));</span>
<span class="line-removed">1764         }</span>
<span class="line-removed">1765 </span>
<span class="line-removed">1766         /**</span>
<span class="line-removed">1767          * Get or assign the index for a CONSTANT_String entry.</span>
<span class="line-removed">1768          */</span>
<span class="line-removed">1769         public short getString(String s) {</span>
<span class="line-removed">1770             short utf8Index = getUtf8(s);</span>
<span class="line-removed">1771             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1772                 CONSTANT_STRING, utf8Index));</span>
<span class="line-removed">1773         }</span>
<span class="line-removed">1774 </span>
<span class="line-removed">1775         /**</span>
<span class="line-removed">1776          * Get or assign the index for a CONSTANT_FieldRef entry.</span>
<span class="line-removed">1777          */</span>
<span class="line-removed">1778         public short getFieldRef(String className,</span>
<span class="line-removed">1779                                  String name, String descriptor)</span>
<span class="line-removed">1780         {</span>
<span class="line-removed">1781             short classIndex = getClass(className);</span>
<span class="line-removed">1782             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1783             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1784                 CONSTANT_FIELD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1785         }</span>
<span class="line-removed">1786 </span>
<span class="line-removed">1787         /**</span>
<span class="line-removed">1788          * Get or assign the index for a CONSTANT_MethodRef entry.</span>
<span class="line-removed">1789          */</span>
<span class="line-removed">1790         public short getMethodRef(String className,</span>
<span class="line-removed">1791                                   String name, String descriptor)</span>
<span class="line-removed">1792         {</span>
<span class="line-removed">1793             short classIndex = getClass(className);</span>
<span class="line-removed">1794             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1795             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1796                 CONSTANT_METHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1797         }</span>
<span class="line-removed">1798 </span>
<span class="line-removed">1799         /**</span>
<span class="line-removed">1800          * Get or assign the index for a CONSTANT_InterfaceMethodRef entry.</span>
<span class="line-removed">1801          */</span>
<span class="line-removed">1802         public short getInterfaceMethodRef(String className, String name,</span>
<span class="line-removed">1803                                            String descriptor)</span>
<span class="line-removed">1804         {</span>
<span class="line-removed">1805             short classIndex = getClass(className);</span>
<span class="line-removed">1806             short nameAndTypeIndex = getNameAndType(name, descriptor);</span>
<span class="line-removed">1807             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1808                 CONSTANT_INTERFACEMETHOD, classIndex, nameAndTypeIndex));</span>
<span class="line-removed">1809         }</span>
<span class="line-removed">1810 </span>
<span class="line-removed">1811         /**</span>
<span class="line-removed">1812          * Get or assign the index for a CONSTANT_NameAndType entry.</span>
<span class="line-removed">1813          */</span>
<span class="line-removed">1814         public short getNameAndType(String name, String descriptor) {</span>
<span class="line-removed">1815             short nameIndex = getUtf8(name);</span>
<span class="line-removed">1816             short descriptorIndex = getUtf8(descriptor);</span>
<span class="line-removed">1817             return getIndirect(new IndirectEntry(</span>
<span class="line-removed">1818                 CONSTANT_NAMEANDTYPE, nameIndex, descriptorIndex));</span>
<span class="line-removed">1819         }</span>
<span class="line-removed">1820 </span>
<span class="line-removed">1821         /**</span>
<span class="line-removed">1822          * Set this ConstantPool instance to be &quot;read only&quot;.</span>
<span class="line-removed">1823          *</span>
<span class="line-removed">1824          * After this method has been called, further requests to get</span>
<span class="line-removed">1825          * an index for a non-existent entry will cause an InternalError</span>
<span class="line-removed">1826          * to be thrown instead of creating of the entry.</span>
<span class="line-removed">1827          */</span>
<span class="line-removed">1828         public void setReadOnly() {</span>
<span class="line-removed">1829             readOnly = true;</span>
<span class="line-removed">1830         }</span>
<span class="line-removed">1831 </span>
<span class="line-removed">1832         /**</span>
<span class="line-removed">1833          * Write this constant pool to a stream as part of</span>
<span class="line-removed">1834          * the class file format.</span>
<span class="line-removed">1835          *</span>
<span class="line-removed">1836          * This consists of writing the &quot;constant_pool_count&quot; and</span>
<span class="line-removed">1837          * &quot;constant_pool[]&quot; items of the &quot;ClassFile&quot; structure, as</span>
<span class="line-removed">1838          * described in JVMS section 4.1.</span>
<span class="line-removed">1839          */</span>
<span class="line-removed">1840         public void write(OutputStream out) throws IOException {</span>
<span class="line-removed">1841             DataOutputStream dataOut = new DataOutputStream(out);</span>
<span class="line-removed">1842 </span>
<span class="line-removed">1843             // constant_pool_count: number of entries plus one</span>
<span class="line-removed">1844             dataOut.writeShort(pool.size() + 1);</span>
<span class="line-removed">1845 </span>
<span class="line-removed">1846             for (Entry e : pool) {</span>
<span class="line-removed">1847                 e.write(dataOut);</span>
<span class="line-removed">1848             }</span>
<span class="line-removed">1849         }</span>
<span class="line-removed">1850 </span>
<span class="line-removed">1851         /**</span>
<span class="line-removed">1852          * Add a new constant pool entry and return its index.</span>
<span class="line-removed">1853          */</span>
<span class="line-removed">1854         private short addEntry(Entry entry) {</span>
<span class="line-removed">1855             pool.add(entry);</span>
<span class="line-removed">1856             /*</span>
<span class="line-removed">1857              * Note that this way of determining the index of the</span>
<span class="line-removed">1858              * added entry is wrong if this pool supports</span>
<span class="line-removed">1859              * CONSTANT_Long or CONSTANT_Double entries.</span>
<span class="line-removed">1860              */</span>
<span class="line-removed">1861             if (pool.size() &gt;= 65535) {</span>
<span class="line-removed">1862                 throw new IllegalArgumentException(</span>
<span class="line-removed">1863                     &quot;constant pool size limit exceeded&quot;);</span>
<span class="line-removed">1864             }</span>
<span class="line-removed">1865             return (short) pool.size();</span>
<span class="line-removed">1866         }</span>
<span class="line-removed">1867 </span>
<span class="line-removed">1868         /**</span>
<span class="line-removed">1869          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">1870          * a direct value.  The type of the given object determines the</span>
<span class="line-removed">1871          * type of the desired entry as follows:</span>
<span class="line-removed">1872          *</span>
<span class="line-removed">1873          *      java.lang.String        CONSTANT_Utf8</span>
<span class="line-removed">1874          *      java.lang.Integer       CONSTANT_Integer</span>
<span class="line-removed">1875          *      java.lang.Float         CONSTANT_Float</span>
<span class="line-removed">1876          *      java.lang.Long          CONSTANT_Long</span>
<span class="line-removed">1877          *      java.lang.Double        CONSTANT_DOUBLE</span>
<span class="line-removed">1878          */</span>
<span class="line-removed">1879         private short getValue(Object key) {</span>
<span class="line-removed">1880             Integer index = map.get(key);</span>
<span class="line-removed">1881             if (index != null) {</span>
<span class="line-removed">1882                 return index.shortValue();</span>
<span class="line-removed">1883             } else {</span>
<span class="line-removed">1884                 if (readOnly) {</span>
<span class="line-removed">1885                     throw new InternalError(</span>
<span class="line-removed">1886                         &quot;late constant pool addition: &quot; + key);</span>
<span class="line-removed">1887                 }</span>
<span class="line-removed">1888                 short i = addEntry(new ValueEntry(key));</span>
<span class="line-removed">1889                 map.put(key, (int)i);</span>
<span class="line-removed">1890                 return i;</span>
<span class="line-removed">1891             }</span>
<span class="line-removed">1892         }</span>
<span class="line-removed">1893 </span>
<span class="line-removed">1894         /**</span>
<span class="line-removed">1895          * Get or assign the index for an entry of a type that contains</span>
<span class="line-removed">1896          * references to other constant pool entries.</span>
<span class="line-removed">1897          */</span>
<span class="line-removed">1898         private short getIndirect(IndirectEntry e) {</span>
<span class="line-removed">1899             Integer index = map.get(e);</span>
<span class="line-removed">1900             if (index != null) {</span>
<span class="line-removed">1901                 return index.shortValue();</span>
<span class="line-removed">1902             } else {</span>
<span class="line-removed">1903                 if (readOnly) {</span>
<span class="line-removed">1904                     throw new InternalError(&quot;late constant pool addition&quot;);</span>
<span class="line-removed">1905                 }</span>
<span class="line-removed">1906                 short i = addEntry(e);</span>
<span class="line-removed">1907                 map.put(e, (int)i);</span>
<span class="line-removed">1908                 return i;</span>
<span class="line-removed">1909             }</span>
<span class="line-removed">1910         }</span>
<span class="line-removed">1911 </span>
<span class="line-removed">1912         /**</span>
<span class="line-removed">1913          * Entry is the abstact superclass of all constant pool entry types</span>
<span class="line-removed">1914          * that can be stored in the &quot;pool&quot; list; its purpose is to define a</span>
<span class="line-removed">1915          * common method for writing constant pool entries to a class file.</span>
<span class="line-removed">1916          */</span>
<span class="line-removed">1917         private abstract static class Entry {</span>
<span class="line-removed">1918             public abstract void write(DataOutputStream out)</span>
<span class="line-removed">1919                 throws IOException;</span>
<span class="line-removed">1920         }</span>
<span class="line-removed">1921 </span>
<span class="line-removed">1922         /**</span>
<span class="line-removed">1923          * ValueEntry represents a constant pool entry of a type that</span>
<span class="line-removed">1924          * contains a direct value (see the comments for the &quot;getValue&quot;</span>
<span class="line-removed">1925          * method for a list of such types).</span>
<span class="line-removed">1926          *</span>
<span class="line-removed">1927          * ValueEntry objects are not used as keys for their entries in the</span>
<span class="line-removed">1928          * Map &quot;map&quot;, so no useful hashCode or equals methods are defined.</span>
<span class="line-removed">1929          */</span>
<span class="line-removed">1930         private static class ValueEntry extends Entry {</span>
<span class="line-removed">1931             private Object value;</span>
<span class="line-removed">1932 </span>
<span class="line-removed">1933             public ValueEntry(Object value) {</span>
<span class="line-removed">1934                 this.value = value;</span>
<span class="line-removed">1935             }</span>
<span class="line-removed">1936 </span>
<span class="line-removed">1937             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">1938                 if (value instanceof String) {</span>
<span class="line-removed">1939                     out.writeByte(CONSTANT_UTF8);</span>
<span class="line-removed">1940                     out.writeUTF((String) value);</span>
<span class="line-removed">1941                 } else if (value instanceof Integer) {</span>
<span class="line-removed">1942                     out.writeByte(CONSTANT_INTEGER);</span>
<span class="line-removed">1943                     out.writeInt(((Integer) value).intValue());</span>
<span class="line-removed">1944                 } else if (value instanceof Float) {</span>
<span class="line-removed">1945                     out.writeByte(CONSTANT_FLOAT);</span>
<span class="line-removed">1946                     out.writeFloat(((Float) value).floatValue());</span>
<span class="line-removed">1947                 } else if (value instanceof Long) {</span>
<span class="line-removed">1948                     out.writeByte(CONSTANT_LONG);</span>
<span class="line-removed">1949                     out.writeLong(((Long) value).longValue());</span>
<span class="line-removed">1950                 } else if (value instanceof Double) {</span>
<span class="line-removed">1951                     out.writeDouble(CONSTANT_DOUBLE);</span>
<span class="line-removed">1952                     out.writeDouble(((Double) value).doubleValue());</span>
<span class="line-removed">1953                 } else {</span>
<span class="line-removed">1954                     throw new InternalError(&quot;bogus value entry: &quot; + value);</span>
<span class="line-removed">1955                 }</span>
<span class="line-removed">1956             }</span>
<span class="line-removed">1957         }</span>
<span class="line-removed">1958 </span>
<span class="line-removed">1959         /**</span>
<span class="line-removed">1960          * IndirectEntry represents a constant pool entry of a type that</span>
<span class="line-removed">1961          * references other constant pool entries, i.e., the following types:</span>
<span class="line-removed">1962          *</span>
<span class="line-removed">1963          *      CONSTANT_Class, CONSTANT_String, CONSTANT_Fieldref,</span>
<span class="line-removed">1964          *      CONSTANT_Methodref, CONSTANT_InterfaceMethodref, and</span>
<span class="line-removed">1965          *      CONSTANT_NameAndType.</span>
<span class="line-removed">1966          *</span>
<span class="line-removed">1967          * Each of these entry types contains either one or two indexes of</span>
<span class="line-removed">1968          * other constant pool entries.</span>
<span class="line-removed">1969          *</span>
<span class="line-removed">1970          * IndirectEntry objects are used as the keys for their entries in</span>
<span class="line-removed">1971          * the Map &quot;map&quot;, so the hashCode and equals methods are overridden</span>
<span class="line-removed">1972          * to allow matching.</span>
<span class="line-removed">1973          */</span>
<span class="line-removed">1974         private static class IndirectEntry extends Entry {</span>
<span class="line-removed">1975             private int tag;</span>
<span class="line-removed">1976             private short index0;</span>
<span class="line-removed">1977             private short index1;</span>
<span class="line-removed">1978 </span>
<span class="line-removed">1979             /**</span>
<span class="line-removed">1980              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">1981              * that contains one index of another entry.</span>
<span class="line-removed">1982              */</span>
<span class="line-removed">1983             public IndirectEntry(int tag, short index) {</span>
<span class="line-removed">1984                 this.tag = tag;</span>
<span class="line-removed">1985                 this.index0 = index;</span>
<span class="line-removed">1986                 this.index1 = 0;</span>
<span class="line-removed">1987             }</span>
<span class="line-removed">1988 </span>
<span class="line-removed">1989             /**</span>
<span class="line-removed">1990              * Construct an IndirectEntry for a constant pool entry type</span>
<span class="line-removed">1991              * that contains two indexes for other entries.</span>
<span class="line-removed">1992              */</span>
<span class="line-removed">1993             public IndirectEntry(int tag, short index0, short index1) {</span>
<span class="line-removed">1994                 this.tag = tag;</span>
<span class="line-removed">1995                 this.index0 = index0;</span>
<span class="line-removed">1996                 this.index1 = index1;</span>
<span class="line-removed">1997             }</span>
<span class="line-removed">1998 </span>
<span class="line-removed">1999             public void write(DataOutputStream out) throws IOException {</span>
<span class="line-removed">2000                 out.writeByte(tag);</span>
<span class="line-removed">2001                 out.writeShort(index0);</span>
<span class="line-removed">2002                 /*</span>
<span class="line-removed">2003                  * If this entry type contains two indexes, write</span>
<span class="line-removed">2004                  * out the second, too.</span>
<span class="line-removed">2005                  */</span>
<span class="line-removed">2006                 if (tag == CONSTANT_FIELD ||</span>
<span class="line-removed">2007                     tag == CONSTANT_METHOD ||</span>
<span class="line-removed">2008                     tag == CONSTANT_INTERFACEMETHOD ||</span>
<span class="line-removed">2009                     tag == CONSTANT_NAMEANDTYPE)</span>
<span class="line-removed">2010                 {</span>
<span class="line-removed">2011                     out.writeShort(index1);</span>
<span class="line-removed">2012                 }</span>
<span class="line-removed">2013             }</span>
<span class="line-removed">2014 </span>
<span class="line-removed">2015             public int hashCode() {</span>
<span class="line-removed">2016                 return tag + index0 + index1;</span>
<span class="line-removed">2017             }</span>
<span class="line-removed">2018 </span>
<span class="line-removed">2019             public boolean equals(Object obj) {</span>
<span class="line-removed">2020                 if (obj instanceof IndirectEntry) {</span>
<span class="line-removed">2021                     IndirectEntry other = (IndirectEntry) obj;</span>
<span class="line-removed">2022                     if (tag == other.tag &amp;&amp;</span>
<span class="line-removed">2023                         index0 == other.index0 &amp;&amp; index1 == other.index1)</span>
<span class="line-removed">2024                     {</span>
<span class="line-removed">2025                         return true;</span>
<span class="line-removed">2026                     }</span>
<span class="line-removed">2027                 }</span>
<span class="line-removed">2028                 return false;</span>
<span class="line-removed">2029             }</span>
<span class="line-removed">2030         }</span>
<span class="line-removed">2031     }</span>
2032 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
<span class="line-modified">  28 import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-modified">  29 import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-modified">  30 import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-added">  31 import jdk.internal.org.objectweb.asm.Opcodes;</span>
<span class="line-added">  32 import sun.security.action.GetBooleanAction;</span>
<span class="line-added">  33 </span>
  34 import java.io.IOException;
<span class="line-modified">  35 import java.lang.invoke.MethodType;</span>


  36 import java.nio.file.Files;
  37 import java.nio.file.Path;
  38 import java.util.ArrayList;
<span class="line-added">  39 import java.util.Arrays;</span>
  40 import java.util.HashMap;
<span class="line-added">  41 import java.util.LinkedHashMap;</span>
  42 import java.util.LinkedList;
  43 import java.util.List;
  44 import java.util.ListIterator;
  45 import java.util.Map;
<span class="line-modified">  46 </span>
<span class="line-added">  47 import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  48 
  49 /**
  50  * ProxyGenerator contains the code to generate a dynamic proxy class
  51  * for the java.lang.reflect.Proxy API.
<span class="line-modified">  52  * &lt;p&gt;</span>
<span class="line-modified">  53  * The external interface to ProxyGenerator is the static</span>
  54  * &quot;generateProxyClass&quot; method.



  55  */
<span class="line-modified">  56 final class ProxyGenerator extends ClassWriter {</span>






  57 
<span class="line-modified">  58     private static final String JL_CLASS = &quot;java/lang/Class&quot;;</span>
<span class="line-modified">  59     private static final String JL_OBJECT = &quot;java/lang/Object&quot;;</span>
<span class="line-modified">  60     private static final String JL_THROWABLE = &quot;java/lang/Throwable&quot;;</span>
<span class="line-added">  61     private static final String JL_CLASS_NOT_FOUND_EX = &quot;java/lang/ClassNotFoundException&quot;;</span>
<span class="line-added">  62     private static final String JL_NO_CLASS_DEF_FOUND_ERROR = &quot;java/lang/NoClassDefFoundError&quot;;</span>
<span class="line-added">  63     private static final String JL_NO_SUCH_METHOD_EX = &quot;java/lang/NoSuchMethodException&quot;;</span>
<span class="line-added">  64     private static final String JL_NO_SUCH_METHOD_ERROR = &quot;java/lang/NoSuchMethodError&quot;;</span>
  65 
<span class="line-modified">  66     private static final String JLR_INVOCATION_HANDLER = &quot;java/lang/reflect/InvocationHandler&quot;;</span>
<span class="line-modified">  67     private static final String JLR_PROXY = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-modified">  68     private static final String JLR_UNDECLARED_THROWABLE_EX = &quot;java/lang/reflect/UndeclaredThrowableException&quot;;</span>

  69 
<span class="line-modified">  70     private static final String LJL_CLASS = &quot;Ljava/lang/Class;&quot;;</span>
<span class="line-modified">  71     private static final String LJLR_METHOD = &quot;Ljava/lang/reflect/Method;&quot;;</span>
<span class="line-modified">  72     private static final String LJLR_INVOCATION_HANDLER = &quot;Ljava/lang/reflect/InvocationHandler;&quot;;</span>












































































































































































































































  73 
<span class="line-modified">  74     private static final String MJLR_INVOCATIONHANDLER = &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;;</span>
<span class="line-modified">  75 </span>
<span class="line-modified">  76     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;</span>
<span class="line-modified">  77     private static final String NAME_CLINIT = &quot;&lt;clinit&gt;&quot;;</span>
<span class="line-modified">  78 </span>
<span class="line-added">  79     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>
  80 
  81     /**
<span class="line-modified">  82      * name of field for storing a proxy instance&#39;s invocation handler</span>
  83      */
<span class="line-modified">  84     private static final String handlerFieldName = &quot;h&quot;;</span>



  85 
  86     /**
<span class="line-modified">  87      * debugging flag for saving generated class files</span>
<span class="line-modified">  88      */</span>
<span class="line-modified">  89     private static final boolean saveGeneratedFiles =</span>











  90             java.security.AccessController.doPrivileged(
<span class="line-modified">  91                     new GetBooleanAction(</span>
<span class="line-modified">  92                             &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;));</span>



















  93 
<span class="line-modified">  94     /* Preloaded ProxyMethod objects for methods in java.lang.Object */</span>
<span class="line-modified">  95     private final static ProxyMethod hashCodeMethod;</span>
<span class="line-added">  96     private final static ProxyMethod equalsMethod;</span>
<span class="line-added">  97     private final static ProxyMethod toStringMethod;</span>
  98 




  99     static {
 100         try {
<span class="line-modified"> 101             hashCodeMethod = new ProxyMethod(Object.class.getMethod(&quot;hashCode&quot;), &quot;m0&quot;);</span>
<span class="line-modified"> 102             equalsMethod = new ProxyMethod(Object.class.getMethod(&quot;equals&quot;, Object.class), &quot;m1&quot;);</span>
<span class="line-modified"> 103             toStringMethod = new ProxyMethod(Object.class.getMethod(&quot;toString&quot;), &quot;m2&quot;);</span>

 104         } catch (NoSuchMethodException e) {
 105             throw new NoSuchMethodError(e.getMessage());
 106         }
 107     }
 108 
<span class="line-modified"> 109     /**</span>
<span class="line-modified"> 110      * Class loader</span>
<span class="line-modified"> 111      */</span>
<span class="line-modified"> 112     private final ClassLoader loader;</span>




 113 
<span class="line-modified"> 114     /**</span>
<span class="line-modified"> 115      * Name of proxy class</span>
<span class="line-added"> 116      */</span>
<span class="line-added"> 117     private final String className;</span>
 118 
<span class="line-modified"> 119     /**</span>
<span class="line-modified"> 120      * Proxy interfaces</span>
<span class="line-added"> 121      */</span>
<span class="line-added"> 122     private final List&lt;Class&lt;?&gt;&gt; interfaces;</span>
 123 
<span class="line-modified"> 124     /**</span>
<span class="line-modified"> 125      * Proxy class access flags</span>
<span class="line-added"> 126      */</span>
<span class="line-added"> 127     private final int accessFlags;</span>
 128 
 129     /**
<span class="line-modified"> 130      * Maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified"> 131      * proxy methods with that signature.</span>
<span class="line-added"> 132      * Kept in insertion order to make it easier to compare old and new.</span>
 133      */
<span class="line-modified"> 134     private final Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new LinkedHashMap&lt;&gt;();</span>
 135 
<span class="line-modified"> 136     /**</span>
<span class="line-modified"> 137      * Ordinal of next ProxyMethod object added to proxyMethods.</span>
<span class="line-added"> 138      * Indexes are reserved for hashcode(0), equals(1), toString(2).</span>
<span class="line-added"> 139      */</span>
<span class="line-added"> 140     private int proxyMethodCount = 3;</span>
 141 
 142     /**
 143      * Construct a ProxyGenerator to generate a proxy class with the
 144      * specified name and for the given interfaces.
<span class="line-modified"> 145      * &lt;p&gt;</span>
 146      * A ProxyGenerator object contains the state for the ongoing
 147      * generation of a particular proxy class.
 148      */
<span class="line-modified"> 149     private ProxyGenerator(ClassLoader loader, String className, List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-added"> 150                            int accessFlags) {</span>
<span class="line-added"> 151         super(ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-added"> 152         this.loader = loader;</span>
 153         this.className = className;
 154         this.interfaces = interfaces;
 155         this.accessFlags = accessFlags;
 156     }
 157 
 158     /**
<span class="line-modified"> 159      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified"> 160      *</span>
<span class="line-added"> 161      * @param name        the class name of the proxy class</span>
<span class="line-added"> 162      * @param interfaces  proxy interfaces</span>
<span class="line-added"> 163      * @param accessFlags access flags of the proxy class</span>
 164      */
<span class="line-modified"> 165     static byte[] generateProxyClass(ClassLoader loader,</span>
<span class="line-modified"> 166                                      final String name,</span>
<span class="line-modified"> 167                                      List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-modified"> 168                                      int accessFlags) {</span>
<span class="line-modified"> 169         ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);</span>
<span class="line-modified"> 170         final byte[] classFile = gen.generateClassFile();</span>






































































































































 171 
<span class="line-modified"> 172         if (saveGeneratedFiles) {</span>
<span class="line-modified"> 173             java.security.AccessController.doPrivileged(</span>
<span class="line-added"> 174                     new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-added"> 175                         public Void run() {</span>
<span class="line-added"> 176                             try {</span>
<span class="line-added"> 177                                 int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-added"> 178                                 Path path;</span>
<span class="line-added"> 179                                 if (i &gt; 0) {</span>
<span class="line-added"> 180                                     Path dir = Path.of(dotToSlash(name.substring(0, i)));</span>
<span class="line-added"> 181                                     Files.createDirectories(dir);</span>
<span class="line-added"> 182                                     path = dir.resolve(name.substring(i + 1) + &quot;.class&quot;);</span>
<span class="line-added"> 183                                 } else {</span>
<span class="line-added"> 184                                     path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-added"> 185                                 }</span>
<span class="line-added"> 186                                 Files.write(path, classFile);</span>
<span class="line-added"> 187                                 return null;</span>
<span class="line-added"> 188                             } catch (IOException e) {</span>
<span class="line-added"> 189                                 throw new InternalError(</span>
<span class="line-added"> 190                                         &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-added"> 191                             }</span>
<span class="line-added"> 192                         }</span>
<span class="line-added"> 193                     });</span>
 194         }
 195 
<span class="line-modified"> 196         return classFile;</span>
 197     }
 198 
 199     /**
<span class="line-modified"> 200      * Return an array of the type names from an array of Classes.</span>


 201      *
<span class="line-modified"> 202      * @param classes an array of classes or interfaces</span>
<span class="line-modified"> 203      * @return the array of class names; or null if there are no classes</span>





 204      */
<span class="line-modified"> 205     private static String[] typeNames(List&lt;Class&lt;?&gt;&gt; classes) {</span>
<span class="line-modified"> 206         if (classes == null || classes.size() == 0)</span>
<span class="line-modified"> 207             return null;</span>
<span class="line-modified"> 208         int size = classes.size();</span>
<span class="line-modified"> 209         String[] ifaces = new String[size];</span>
<span class="line-modified"> 210         for (int i = 0; i &lt; size; i++)</span>
<span class="line-modified"> 211             ifaces[i] = dotToSlash(classes.get(i).getName());</span>
<span class="line-modified"> 212         return ifaces;</span>


























 213     }
 214 
 215     /**
 216      * For a given set of proxy methods with the same signature, check
 217      * that their return types are compatible according to the Proxy
 218      * specification.
 219      *
 220      * Specifically, if there is more than one such method, then all
 221      * of the return types must be reference types, and there must be
 222      * one return type that is assignable to each of the rest of them.
 223      */
 224     private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
 225         /*
 226          * If there is only one method with a given signature, there
 227          * cannot be a conflict.  This is the only case in which a
 228          * primitive (or void) return type is allowed.
 229          */
 230         if (methods.size() &lt; 2) {
 231             return;
 232         }
 233 
 234         /*
 235          * List of return types that are not yet known to be
 236          * assignable from (&quot;covered&quot; by) any of the others.
 237          */
 238         LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
 239 
<span class="line-modified"> 240         nextNewReturnType:</span>
 241         for (ProxyMethod pm : methods) {
 242             Class&lt;?&gt; newReturnType = pm.returnType;
 243             if (newReturnType.isPrimitive()) {
 244                 throw new IllegalArgumentException(
<span class="line-modified"> 245                         &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 246                                 pm.shortSignature +</span>
<span class="line-modified"> 247                                 &quot; but incompatible return types: &quot; +</span>
<span class="line-modified"> 248                                 newReturnType.getName() + &quot; and others&quot;);</span>

 249             }
 250             boolean added = false;
 251 
 252             /*
 253              * Compare the new return type to the existing uncovered
 254              * return types.
 255              */
 256             ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
 257             while (liter.hasNext()) {
 258                 Class&lt;?&gt; uncoveredReturnType = liter.next();
 259 
 260                 /*
 261                  * If an existing uncovered return type is assignable
 262                  * to this new one, then we can forget the new one.
 263                  */
 264                 if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
 265                     assert !added;
 266                     continue nextNewReturnType;
 267                 }
 268 
</pre>
<hr />
<pre>
 283                 }
 284             }
 285 
 286             /*
 287              * If we got through the list of existing uncovered return
 288              * types without an assignability relationship, then add
 289              * the new return type to the list of uncovered ones.
 290              */
 291             if (!added) {
 292                 uncoveredReturnTypes.add(newReturnType);
 293             }
 294         }
 295 
 296         /*
 297          * We shouldn&#39;t end up with more than one return type that is
 298          * not assignable from any of the others.
 299          */
 300         if (uncoveredReturnTypes.size() &gt; 1) {
 301             ProxyMethod pm = methods.get(0);
 302             throw new IllegalArgumentException(
<span class="line-modified"> 303                     &quot;methods with same signature &quot; +</span>
<span class="line-modified"> 304                             pm.shortSignature +</span>
<span class="line-modified"> 305                             &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
 306         }
 307     }
 308 
 309     /**
<span class="line-modified"> 310      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-modified"> 311      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-modified"> 312      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-added"> 313      * implementation before catching other Throwables and wrapping them</span>
<span class="line-added"> 314      * in UndeclaredThrowableExceptions.</span>
<span class="line-added"> 315      *</span>
<span class="line-added"> 316      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-added"> 317      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-added"> 318      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-added"> 319      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-added"> 320      *</span>
<span class="line-added"> 321      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-added"> 322      * list (if none of their superclasses are contained), since those</span>
<span class="line-added"> 323      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-added"> 324      * subclasses will never appear in the returned list.</span>
<span class="line-added"> 325      *</span>
<span class="line-added"> 326      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-added"> 327      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-added"> 328      * need to be caught.</span>
 329      */
<span class="line-modified"> 330     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-modified"> 331         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 332         // unique exceptions to catch</span>






 333 
<span class="line-modified"> 334         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-modified"> 335         uniqueList.add(RuntimeException.class);</span>





 336 
<span class="line-modified"> 337         nextException:</span>
<span class="line-added"> 338         for (Class&lt;?&gt; ex : exceptions) {</span>
<span class="line-added"> 339             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-added"> 340                 /*</span>
<span class="line-added"> 341                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-added"> 342                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-added"> 343                  * can, at most, throw Throwable anyway.</span>
<span class="line-added"> 344                  */</span>
<span class="line-added"> 345                 uniqueList.clear();</span>
<span class="line-added"> 346                 break;</span>
<span class="line-added"> 347             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-added"> 348                 /*</span>
<span class="line-added"> 349                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-added"> 350                  */</span>
<span class="line-added"> 351                 continue;</span>
<span class="line-added"> 352             }</span>
 353             /*
<span class="line-modified"> 354              * Compare this exception against the current list of</span>
<span class="line-modified"> 355              * exceptions that need to be caught:</span>
 356              */
<span class="line-modified"> 357             for (int j = 0; j &lt; uniqueList.size(); ) {</span>
<span class="line-modified"> 358                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-modified"> 359                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-modified"> 360                     /*</span>
<span class="line-modified"> 361                      * if a superclass of this exception is already on</span>
<span class="line-modified"> 362                      * the list to catch, then ignore this one and continue;</span>
<span class="line-modified"> 363                      */</span>
<span class="line-modified"> 364                     continue nextException;</span>
<span class="line-added"> 365                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-added"> 366                     /*</span>
<span class="line-added"> 367                      * if a subclass of this exception is on the list</span>
<span class="line-added"> 368                      * to catch, then remove it;</span>
<span class="line-added"> 369                      */</span>
<span class="line-added"> 370                     uniqueList.remove(j);</span>
<span class="line-added"> 371                 } else {</span>
<span class="line-added"> 372                     j++;        // else continue comparing.</span>
<span class="line-added"> 373                 }</span>
<span class="line-added"> 374             }</span>
<span class="line-added"> 375             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-added"> 376             uniqueList.add(ex);</span>
 377         }
<span class="line-added"> 378         return uniqueList;</span>
 379     }
 380 
 381     /**
<span class="line-modified"> 382      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-modified"> 383      * separator, the external representation used by the Java language</span>
<span class="line-modified"> 384      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-added"> 385      * package separator, the representation used in the class file</span>
<span class="line-added"> 386      * format (see JVMS section {@jvms 4.2}).</span>
 387      */
<span class="line-modified"> 388     private static String dotToSlash(String name) {</span>
<span class="line-modified"> 389         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-modified"> 390     }</span>












 391 
 392     /**
<span class="line-modified"> 393      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-modified"> 394      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-modified"> 395      * section 3.6.1.</span>
<span class="line-added"> 396      * &lt;p&gt;</span>
<span class="line-added"> 397      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-added"> 398      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-added"> 399      * was removed for the second edition.</span>
 400      */
<span class="line-modified"> 401     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-modified"> 402         if (type == long.class || type == double.class) {</span>
<span class="line-modified"> 403             return 2;</span>
<span class="line-modified"> 404         } else {</span>
<span class="line-modified"> 405             return 1;</span>



















 406         }
<span class="line-added"> 407     }</span>
 408 
<span class="line-modified"> 409     /**</span>
<span class="line-modified"> 410      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-modified"> 411      * are not already contained in the list and are assignable to at</span>
<span class="line-modified"> 412      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-modified"> 413      * &lt;p&gt;</span>
<span class="line-modified"> 414      * This method is useful for computing the greatest common set of</span>
<span class="line-modified"> 415      * declared exceptions from duplicate methods inherited from</span>
<span class="line-modified"> 416      * different interfaces.</span>
<span class="line-modified"> 417      */</span>
<span class="line-modified"> 418     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-modified"> 419                                                Class&lt;?&gt;[] with,</span>
<span class="line-modified"> 420                                                List&lt;Class&lt;?&gt;&gt; list) {</span>
<span class="line-modified"> 421         for (Class&lt;?&gt; fc : from) {</span>
<span class="line-modified"> 422             if (!list.contains(fc)) {</span>
<span class="line-modified"> 423                 for (Class&lt;?&gt; wc : with) {</span>
<span class="line-modified"> 424                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-modified"> 425                         list.add(fc);</span>
<span class="line-modified"> 426                         break;</span>
<span class="line-modified"> 427                     }</span>
<span class="line-modified"> 428                 }</span>


































 429             }
 430         }

 431     }
 432 
 433     /**
<span class="line-modified"> 434      * Returns the {@link ClassLoader} to be used by the default implementation of {@link</span>
<span class="line-modified"> 435      * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}&#39;s runtime type by</span>
<span class="line-modified"> 436      * default.</span>
<span class="line-added"> 437      *</span>
<span class="line-added"> 438      * @return ClassLoader</span>
 439      */
<span class="line-modified"> 440     protected ClassLoader getClassLoader() {</span>
<span class="line-modified"> 441         return loader;</span>
<span class="line-modified"> 442     }</span>





 443 
<span class="line-modified"> 444     /**</span>
<span class="line-modified"> 445      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified"> 446      * class file generation process.</span>
<span class="line-modified"> 447      */</span>
<span class="line-modified"> 448     private byte[] generateClassFile() {</span>
<span class="line-modified"> 449         visit(V14, accessFlags, dotToSlash(className), null,</span>
<span class="line-modified"> 450                 JLR_PROXY, typeNames(interfaces));</span>




 451 
<span class="line-modified"> 452         /*</span>
<span class="line-modified"> 453          * Add proxy methods for the hashCode, equals,</span>
<span class="line-modified"> 454          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-added"> 455          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-added"> 456          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-added"> 457          * proxy interfaces.</span>
 458          */
<span class="line-modified"> 459         addProxyMethod(hashCodeMethod);</span>
<span class="line-modified"> 460         addProxyMethod(equalsMethod);</span>
<span class="line-modified"> 461         addProxyMethod(toStringMethod);</span>

 462 
<span class="line-modified"> 463         /*</span>
<span class="line-modified"> 464          * Accumulate all of the methods from the proxy interfaces.</span>
<span class="line-modified"> 465          */</span>
<span class="line-modified"> 466         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-modified"> 467             for (Method m : intf.getMethods()) {</span>
<span class="line-added"> 468                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-added"> 469                     addProxyMethod(m, intf);</span>
<span class="line-added"> 470                 }</span>
 471             }
<span class="line-modified"> 472         }</span>










 473 
<span class="line-modified"> 474         /*</span>
<span class="line-added"> 475          * For each set of proxy methods with the same signature,</span>
<span class="line-added"> 476          * verify that the methods&#39; return types are compatible.</span>
<span class="line-added"> 477          */</span>
<span class="line-added"> 478         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added"> 479             checkReturnTypes(sigmethods);</span>
<span class="line-added"> 480         }</span>
 481 
<span class="line-modified"> 482         generateConstructor();</span>



 483 
<span class="line-modified"> 484         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added"> 485             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added"> 486                 // add static field for the Method object</span>
<span class="line-added"> 487                 visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,</span>
<span class="line-added"> 488                         LJLR_METHOD, null, null);</span>
 489 
<span class="line-modified"> 490                 // Generate code for proxy method</span>
<span class="line-added"> 491                 pm.generateMethod(this, className);</span>
<span class="line-added"> 492             }</span>
<span class="line-added"> 493         }</span>
 494 
<span class="line-modified"> 495         generateStaticInitializer();</span>

 496 
<span class="line-modified"> 497         return toByteArray();</span>
<span class="line-added"> 498     }</span>
 499 
<span class="line-modified"> 500     /**</span>
<span class="line-added"> 501      * Add another method to be proxied, either by creating a new</span>
<span class="line-added"> 502      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-added"> 503      * method.</span>
<span class="line-added"> 504      *</span>
<span class="line-added"> 505      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-added"> 506      * found through, which may be different from (a subinterface of)</span>
<span class="line-added"> 507      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-added"> 508      * object passed for a given name and descriptor identifies the</span>
<span class="line-added"> 509      * Method object (and thus the declaring class) that will be</span>
<span class="line-added"> 510      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-added"> 511      * set of duplicate methods.</span>
<span class="line-added"> 512      */</span>
<span class="line-added"> 513     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-added"> 514         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-added"> 515         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
 516 
<span class="line-modified"> 517         String sig = m.toShortSignature();</span>
<span class="line-added"> 518         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added"> 519                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added"> 520         for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added"> 521             if (returnType == pm.returnType) {</span>
<span class="line-added"> 522                 /*</span>
<span class="line-added"> 523                  * Found a match: reduce exception types to the</span>
<span class="line-added"> 524                  * greatest set of exceptions that can be thrown</span>
<span class="line-added"> 525                  * compatibly with the throws clauses of both</span>
<span class="line-added"> 526                  * overridden methods.</span>
<span class="line-added"> 527                  */</span>
<span class="line-added"> 528                 List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 529                 collectCompatibleTypes(</span>
<span class="line-added"> 530                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-added"> 531                 collectCompatibleTypes(</span>
<span class="line-added"> 532                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-added"> 533                 pm.exceptionTypes = legalExceptions.toArray(EMPTY_CLASS_ARRAY);</span>
<span class="line-added"> 534                 return;</span>
<span class="line-added"> 535             }</span>
<span class="line-added"> 536         }</span>
<span class="line-added"> 537         sigmethods.add(new ProxyMethod(m, sig, m.getParameterTypes(), returnType,</span>
<span class="line-added"> 538                 exceptionTypes, fromClass,</span>
<span class="line-added"> 539                 &quot;m&quot; + proxyMethodCount++));</span>
<span class="line-added"> 540     }</span>
 541 
<span class="line-modified"> 542     /**</span>
<span class="line-added"> 543      * Add an existing ProxyMethod (hashcode, equals, toString).</span>
<span class="line-added"> 544      *</span>
<span class="line-added"> 545      * @param pm an existing ProxyMethod</span>
<span class="line-added"> 546      */</span>
<span class="line-added"> 547     private void addProxyMethod(ProxyMethod pm) {</span>
<span class="line-added"> 548         String sig = pm.shortSignature;</span>
<span class="line-added"> 549         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added"> 550                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added"> 551         sigmethods.add(pm);</span>
<span class="line-added"> 552     }</span>
 553 
<span class="line-modified"> 554     /**</span>
<span class="line-modified"> 555      * Generate the constructor method for the proxy class.</span>
<span class="line-modified"> 556      */</span>
<span class="line-added"> 557     private void generateConstructor() {</span>
<span class="line-added"> 558         MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,</span>
<span class="line-added"> 559                 MJLR_INVOCATIONHANDLER, null, null);</span>
<span class="line-added"> 560         ctor.visitParameter(null, 0);</span>
<span class="line-added"> 561         ctor.visitCode();</span>
<span class="line-added"> 562         ctor.visitVarInsn(ALOAD, 0);</span>
<span class="line-added"> 563         ctor.visitVarInsn(ALOAD, 1);</span>
<span class="line-added"> 564         ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,</span>
<span class="line-added"> 565                 MJLR_INVOCATIONHANDLER, false);</span>
<span class="line-added"> 566         ctor.visitInsn(RETURN);</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added"> 569         ctor.visitMaxs(-1, -1);</span>
<span class="line-added"> 570         ctor.visitEnd();</span>
<span class="line-added"> 571     }</span>
 572 
<span class="line-modified"> 573     /**</span>
<span class="line-modified"> 574      * Generate the static initializer method for the proxy class.</span>
<span class="line-added"> 575      */</span>
<span class="line-added"> 576     private void generateStaticInitializer() {</span>
<span class="line-added"> 577 </span>
<span class="line-added"> 578         MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,</span>
<span class="line-added"> 579                 &quot;()V&quot;, null, null);</span>
<span class="line-added"> 580         mv.visitCode();</span>
<span class="line-added"> 581         Label L_startBlock = new Label();</span>
<span class="line-added"> 582         Label L_endBlock = new Label();</span>
<span class="line-added"> 583         Label L_NoMethodHandler = new Label();</span>
<span class="line-added"> 584         Label L_NoClassHandler = new Label();</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,</span>
<span class="line-added"> 587                 JL_NO_SUCH_METHOD_EX);</span>
<span class="line-added"> 588         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,</span>
<span class="line-added"> 589                 JL_CLASS_NOT_FOUND_EX);</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591         mv.visitLabel(L_startBlock);</span>
<span class="line-added"> 592         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added"> 593             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added"> 594                 pm.codeFieldInitialization(mv, className);</span>
<span class="line-added"> 595             }</span>
<span class="line-added"> 596         }</span>
<span class="line-added"> 597         mv.visitInsn(RETURN);</span>
<span class="line-added"> 598         mv.visitLabel(L_endBlock);</span>
<span class="line-added"> 599         // Generate exception handler</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601         mv.visitLabel(L_NoMethodHandler);</span>
<span class="line-added"> 602         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added"> 603         mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);</span>
<span class="line-added"> 604         mv.visitInsn(DUP);</span>
<span class="line-added"> 605         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added"> 606         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added"> 607                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added"> 608         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,</span>
<span class="line-added"> 609                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added"> 610         mv.visitInsn(ATHROW);</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612         mv.visitLabel(L_NoClassHandler);</span>
<span class="line-added"> 613         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added"> 614         mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);</span>
<span class="line-added"> 615         mv.visitInsn(DUP);</span>
<span class="line-added"> 616         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added"> 617         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added"> 618                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added"> 619         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,</span>
<span class="line-added"> 620                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added"> 621         mv.visitInsn(ATHROW);</span>
<span class="line-added"> 622 </span>
<span class="line-added"> 623         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added"> 624         mv.visitMaxs(-1, -1);</span>
<span class="line-added"> 625         mv.visitEnd();</span>
<span class="line-added"> 626     }</span>
 627 
<span class="line-modified"> 628     /**</span>
<span class="line-modified"> 629      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified"> 630      * being generated: a method whose implementation will encode and</span>
<span class="line-modified"> 631      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>
<span class="line-modified"> 632      */</span>
<span class="line-modified"> 633     private static class ProxyMethod {</span>


 634 
<span class="line-modified"> 635         private final Method method;</span>
<span class="line-added"> 636         private final String shortSignature;</span>
<span class="line-added"> 637         private final Class&lt;?&gt; fromClass;</span>
<span class="line-added"> 638         private final Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-added"> 639         private final Class&lt;?&gt; returnType;</span>
<span class="line-added"> 640         private final String methodFieldName;</span>
<span class="line-added"> 641         private Class&lt;?&gt;[] exceptionTypes;</span>
 642 
<span class="line-modified"> 643         private ProxyMethod(Method method, String sig, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-added"> 644                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-added"> 645                             Class&lt;?&gt; fromClass, String methodFieldName) {</span>
<span class="line-added"> 646             this.method = method;</span>
<span class="line-added"> 647             this.shortSignature = sig;</span>
<span class="line-added"> 648             this.parameterTypes = parameterTypes;</span>
<span class="line-added"> 649             this.returnType = returnType;</span>
<span class="line-added"> 650             this.exceptionTypes = exceptionTypes;</span>
<span class="line-added"> 651             this.fromClass = fromClass;</span>
<span class="line-added"> 652             this.methodFieldName = methodFieldName;</span>
<span class="line-added"> 653         }</span>
 654 
<span class="line-modified"> 655         /**</span>
<span class="line-added"> 656          * Create a new specific ProxyMethod with a specific field name</span>
<span class="line-added"> 657          *</span>
<span class="line-added"> 658          * @param method          The method for which to create a proxy</span>
<span class="line-added"> 659          * @param methodFieldName the fieldName to generate</span>
<span class="line-added"> 660          */</span>
<span class="line-added"> 661         private ProxyMethod(Method method, String methodFieldName) {</span>
<span class="line-added"> 662             this(method, method.toShortSignature(),</span>
<span class="line-added"> 663                     method.getParameterTypes(), method.getReturnType(),</span>
<span class="line-added"> 664                     method.getExceptionTypes(), method.getDeclaringClass(), methodFieldName);</span>
<span class="line-added"> 665         }</span>
 666 
<span class="line-modified"> 667         /**</span>
<span class="line-added"> 668          * Generate this method, including the code and exception table entry.</span>
<span class="line-added"> 669          */</span>
<span class="line-added"> 670         private void generateMethod(ClassWriter cw, String className) {</span>
<span class="line-added"> 671             MethodType mt = MethodType.methodType(returnType, parameterTypes);</span>
<span class="line-added"> 672             String desc = mt.toMethodDescriptorString();</span>
<span class="line-added"> 673             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_FINAL,</span>
<span class="line-added"> 674                     method.getName(), desc, null,</span>
<span class="line-added"> 675                     typeNames(Arrays.asList(exceptionTypes)));</span>
 676 
<span class="line-modified"> 677             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-added"> 678             int nextSlot = 1;</span>
<span class="line-added"> 679             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-added"> 680                 parameterSlot[i] = nextSlot;</span>
<span class="line-added"> 681                 nextSlot += getWordsPerType(parameterTypes[i]);</span>
 682             }
 683 
<span class="line-modified"> 684             mv.visitCode();</span>
<span class="line-added"> 685             Label L_startBlock = new Label();</span>
<span class="line-added"> 686             Label L_endBlock = new Label();</span>
<span class="line-added"> 687             Label L_RuntimeHandler = new Label();</span>
<span class="line-added"> 688             Label L_ThrowableHandler = new Label();</span>
 689 
 690             List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
 691             if (catchList.size() &gt; 0) {

 692                 for (Class&lt;?&gt; ex : catchList) {
<span class="line-modified"> 693                     mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,</span>
<span class="line-modified"> 694                             dotToSlash(ex.getName()));</span>

 695                 }
 696 
<span class="line-modified"> 697                 mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,</span>
<span class="line-modified"> 698                         JL_THROWABLE);</span>
<span class="line-modified"> 699             }</span>
<span class="line-modified"> 700             mv.visitLabel(L_startBlock);</span>










 701 
<span class="line-modified"> 702             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added"> 703             mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,</span>
<span class="line-added"> 704                     LJLR_INVOCATION_HANDLER);</span>
<span class="line-added"> 705             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added"> 706             mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,</span>
<span class="line-added"> 707                     LJLR_METHOD);</span>
 708 
<span class="line-modified"> 709             if (parameterTypes.length &gt; 0) {</span>
<span class="line-added"> 710                 // Create an array and fill with the parameters converting primitives to wrappers</span>
<span class="line-added"> 711                 emitIconstInsn(mv, parameterTypes.length);</span>
<span class="line-added"> 712                 mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);</span>
<span class="line-added"> 713                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-added"> 714                     mv.visitInsn(DUP);</span>
<span class="line-added"> 715                     emitIconstInsn(mv, i);</span>
<span class="line-added"> 716                     codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);</span>
<span class="line-added"> 717                     mv.visitInsn(Opcodes.AASTORE);</span>
<span class="line-added"> 718                 }</span>
<span class="line-added"> 719             } else {</span>
<span class="line-added"> 720                 mv.visitInsn(Opcodes.ACONST_NULL);</span>
<span class="line-added"> 721             }</span>
 722 
<span class="line-modified"> 723             mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,</span>
<span class="line-modified"> 724                     &quot;invoke&quot;,</span>
<span class="line-modified"> 725                     &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-added"> 726                             &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;, true);</span>
 727 
<span class="line-modified"> 728             if (returnType == void.class) {</span>
<span class="line-added"> 729                 mv.visitInsn(POP);</span>
<span class="line-added"> 730                 mv.visitInsn(RETURN);</span>
<span class="line-added"> 731             } else {</span>
<span class="line-added"> 732                 codeUnwrapReturnValue(mv, returnType);</span>
 733             }
 734 
<span class="line-modified"> 735             mv.visitLabel(L_endBlock);</span>


 736 
<span class="line-modified"> 737             // Generate exception handler</span>
<span class="line-modified"> 738             mv.visitLabel(L_RuntimeHandler);</span>
<span class="line-modified"> 739             mv.visitInsn(ATHROW);   // just rethrow the exception</span>




 740 
<span class="line-modified"> 741             mv.visitLabel(L_ThrowableHandler);</span>
<span class="line-added"> 742             mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added"> 743             mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);</span>
<span class="line-added"> 744             mv.visitInsn(DUP);</span>
<span class="line-added"> 745             mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added"> 746             mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,</span>
<span class="line-added"> 747                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;, false);</span>
<span class="line-added"> 748             mv.visitInsn(ATHROW);</span>
<span class="line-added"> 749             // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added"> 750             mv.visitMaxs(-1, -1);</span>
<span class="line-added"> 751             mv.visitEnd();</span>
 752         }
 753 
 754         /**
 755          * Generate code for wrapping an argument of the given type
 756          * whose value can be found at the specified local variable
 757          * index, in order for it to be passed (as an Object) to the
<span class="line-modified"> 758          * invocation handler&#39;s &quot;invoke&quot; method.</span>

 759          */
<span class="line-modified"> 760         private void codeWrapArgument(MethodVisitor mv, Class&lt;?&gt; type, int slot) {</span>



 761             if (type.isPrimitive()) {
 762                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
 763 
 764                 if (type == int.class ||
<span class="line-modified"> 765                         type == boolean.class ||</span>
<span class="line-modified"> 766                         type == byte.class ||</span>
<span class="line-modified"> 767                         type == char.class ||</span>
<span class="line-modified"> 768                         type == short.class) {</span>
<span class="line-modified"> 769                     mv.visitVarInsn(ILOAD, slot);</span>

 770                 } else if (type == long.class) {
<span class="line-modified"> 771                     mv.visitVarInsn(LLOAD, slot);</span>
 772                 } else if (type == float.class) {
<span class="line-modified"> 773                     mv.visitVarInsn(FLOAD, slot);</span>
 774                 } else if (type == double.class) {
<span class="line-modified"> 775                     mv.visitVarInsn(DLOAD, slot);</span>
 776                 } else {
 777                     throw new AssertionError();
 778                 }
<span class="line-modified"> 779                 mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, &quot;valueOf&quot;,</span>
<span class="line-modified"> 780                         prim.wrapperValueOfDesc, false);</span>




 781             } else {
<span class="line-modified"> 782                 mv.visitVarInsn(ALOAD, slot);</span>

 783             }
 784         }
 785 
 786         /**
 787          * Generate code for unwrapping a return value of the given
 788          * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<span class="line-modified"> 789          * Object) to its correct type.</span>

 790          */
<span class="line-modified"> 791         private void codeUnwrapReturnValue(MethodVisitor mv, Class&lt;?&gt; type) {</span>


 792             if (type.isPrimitive()) {
 793                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
 794 
<span class="line-modified"> 795                 mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);</span>
<span class="line-modified"> 796                 mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-modified"> 797                         prim.wrapperClassName,</span>
<span class="line-modified"> 798                         prim.unwrapMethodName, prim.unwrapMethodDesc, false);</span>



 799 
 800                 if (type == int.class ||
<span class="line-modified"> 801                         type == boolean.class ||</span>
<span class="line-modified"> 802                         type == byte.class ||</span>
<span class="line-modified"> 803                         type == char.class ||</span>
<span class="line-modified"> 804                         type == short.class) {</span>
<span class="line-modified"> 805                     mv.visitInsn(IRETURN);</span>

 806                 } else if (type == long.class) {
<span class="line-modified"> 807                     mv.visitInsn(LRETURN);</span>
 808                 } else if (type == float.class) {
<span class="line-modified"> 809                     mv.visitInsn(FRETURN);</span>
 810                 } else if (type == double.class) {
<span class="line-modified"> 811                     mv.visitInsn(DRETURN);</span>
 812                 } else {
 813                     throw new AssertionError();
 814                 }

 815             } else {
<span class="line-modified"> 816                 mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));</span>
<span class="line-modified"> 817                 mv.visitInsn(ARETURN);</span>



 818             }
 819         }
 820 
 821         /**
 822          * Generate code for initializing the static field that stores
<span class="line-modified"> 823          * the Method object for this proxy method.</span>

 824          */
<span class="line-modified"> 825         private void codeFieldInitialization(MethodVisitor mv, String className) {</span>
<span class="line-modified"> 826             codeClassForName(mv, fromClass);</span>


 827 
<span class="line-modified"> 828             mv.visitLdcInsn(method.getName());</span>
 829 
<span class="line-modified"> 830             emitIconstInsn(mv, parameterTypes.length);</span>
 831 
<span class="line-modified"> 832             mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);</span>

 833 
<span class="line-added"> 834             // Construct an array with the parameter types mapping primitives to Wrapper types</span>
 835             for (int i = 0; i &lt; parameterTypes.length; i++) {
<span class="line-modified"> 836                 mv.visitInsn(DUP);</span>
<span class="line-modified"> 837                 emitIconstInsn(mv, i);</span>


 838 
 839                 if (parameterTypes[i].isPrimitive()) {
 840                     PrimitiveTypeInfo prim =
<span class="line-modified"> 841                             PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified"> 842                     mv.visitFieldInsn(GETSTATIC,</span>
<span class="line-modified"> 843                             prim.wrapperClassName, &quot;TYPE&quot;, LJL_CLASS);</span>



 844                 } else {
<span class="line-modified"> 845                     codeClassForName(mv, parameterTypes[i]);</span>
 846                 }
<span class="line-modified"> 847                 mv.visitInsn(Opcodes.AASTORE);</span>

 848             }
<span class="line-added"> 849             // lookup the method</span>
<span class="line-added"> 850             mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-added"> 851                     JL_CLASS,</span>
<span class="line-added"> 852                     &quot;getMethod&quot;,</span>
<span class="line-added"> 853                     &quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-added"> 854                     false);</span>
 855 
<span class="line-modified"> 856             mv.visitFieldInsn(PUTSTATIC,</span>
<span class="line-modified"> 857                     dotToSlash(className),</span>
<span class="line-modified"> 858                     methodFieldName, LJLR_METHOD);</span>








 859         }













 860 
<span class="line-modified"> 861         /*</span>
<span class="line-modified"> 862          * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified"> 863          */</span>






















 864 
<span class="line-modified"> 865         /**</span>
<span class="line-added"> 866          * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-added"> 867          * class to get its Class object at runtime.  The code is written to</span>
<span class="line-added"> 868          * the supplied stream.  Note that the code generated by this method</span>
<span class="line-added"> 869          * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-added"> 870          */</span>
<span class="line-added"> 871         private void codeClassForName(MethodVisitor mv, Class&lt;?&gt; cl) {</span>
<span class="line-added"> 872             mv.visitLdcInsn(cl.getName());</span>
<span class="line-added"> 873             mv.visitMethodInsn(INVOKESTATIC,</span>
<span class="line-added"> 874                     JL_CLASS,</span>
<span class="line-added"> 875                     &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;, false);</span>
<span class="line-added"> 876         }</span>
 877 
<span class="line-modified"> 878         /**</span>
<span class="line-modified"> 879          * Visit a bytecode for a constant.</span>
<span class="line-modified"> 880          *</span>
<span class="line-added"> 881          * @param mv  The MethodVisitor</span>
<span class="line-added"> 882          * @param cst The constant value</span>
<span class="line-added"> 883          */</span>
<span class="line-added"> 884         private void emitIconstInsn(MethodVisitor mv, final int cst) {</span>
<span class="line-added"> 885             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-added"> 886                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-added"> 887             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-added"> 888                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-added"> 889             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-added"> 890                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-added"> 891             } else {</span>
<span class="line-added"> 892                 mv.visitLdcInsn(cst);</span>
 893             }
 894         }
 895 
<span class="line-modified"> 896         @Override</span>
<span class="line-modified"> 897         public String toString() {</span>
<span class="line-modified"> 898             return method.toShortString();</span>




















































 899         }






 900     }
 901 
<span class="line-modified"> 902     /**</span>
<span class="line-modified"> 903      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-modified"> 904      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-modified"> 905      * primitive type can be obtained using the static &quot;get&quot; method.</span>





 906      */
<span class="line-added"> 907     private static class PrimitiveTypeInfo {</span>
 908 
<span class="line-modified"> 909         private static Map&lt;Class&lt;?&gt;, PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
















 910 
<span class="line-modified"> 911         static {</span>
<span class="line-modified"> 912             add(byte.class, Byte.class);</span>
<span class="line-modified"> 913             add(char.class, Character.class);</span>
<span class="line-modified"> 914             add(double.class, Double.class);</span>
<span class="line-modified"> 915             add(float.class, Float.class);</span>
<span class="line-added"> 916             add(int.class, Integer.class);</span>
<span class="line-added"> 917             add(long.class, Long.class);</span>
<span class="line-added"> 918             add(short.class, Short.class);</span>
<span class="line-added"> 919             add(boolean.class, Boolean.class);</span>
<span class="line-added"> 920         }</span>
 921 
<span class="line-modified"> 922         /**</span>
<span class="line-modified"> 923          * name of corresponding wrapper class</span>
<span class="line-modified"> 924          */</span>
<span class="line-modified"> 925         private String wrapperClassName;</span>
<span class="line-modified"> 926         /**</span>
<span class="line-added"> 927          * method descriptor for wrapper class &quot;valueOf&quot; factory method</span>
<span class="line-added"> 928          */</span>
<span class="line-added"> 929         private String wrapperValueOfDesc;</span>
<span class="line-added"> 930         /**</span>
<span class="line-added"> 931          * name of wrapper class method for retrieving primitive value</span>
<span class="line-added"> 932          */</span>
<span class="line-added"> 933         private String unwrapMethodName;</span>
<span class="line-added"> 934         /**</span>
<span class="line-added"> 935          * descriptor of same method</span>
<span class="line-added"> 936          */</span>
<span class="line-added"> 937         private String unwrapMethodDesc;</span>
 938 
<span class="line-modified"> 939         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified"> 940             assert primitiveClass.isPrimitive();</span>



























 941 
<span class="line-modified"> 942             /**</span>
<span class="line-modified"> 943              * &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2)</span>





















 944              */
<span class="line-modified"> 945             String baseTypeString =</span>
<span class="line-modified"> 946                     Array.newInstance(primitiveClass, 0)</span>
<span class="line-modified"> 947                             .getClass().getName().substring(1);</span>
<span class="line-modified"> 948             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-modified"> 949             wrapperValueOfDesc =</span>
<span class="line-modified"> 950                     &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-modified"> 951             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-modified"> 952             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>













 953         }

 954 
<span class="line-modified"> 955         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified"> 956             table.put(primitiveClass,</span>
<span class="line-modified"> 957                     new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>





































































































































































































































































































 958         }
 959 
 960         public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
 961             return table.get(cl);
 962         }
 963     }



















































































































































































































































































































































 964 }
</pre>
</td>
</tr>
</table>
<center><a href="Proxy.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/CallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BoundMethodHandle.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ClassSpecializer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/CallSite.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 85,13 ***</span>
   * @since 1.7
   */
  abstract
  public class CallSite {
  
<span class="line-modified">!     // The actual payload of this call site:</span>
      /*package-private*/
<span class="line-modified">!     MethodHandle target;    // Note: This field is known to the JVM.  Do not change.</span>
  
      /**
       * Make a blank call site object with the given method type.
       * An initial target method is supplied which will throw
       * an {@link IllegalStateException} if called.
<span class="line-new-header">--- 85,14 ---</span>
   * @since 1.7
   */
  abstract
  public class CallSite {
  
<span class="line-modified">!     // The actual payload of this call site.</span>
<span class="line-added">+     // Can be modified using {@link MethodHandleNatives#setCallSiteTargetNormal} or {@link MethodHandleNatives#setCallSiteTargetVolatile}.</span>
      /*package-private*/
<span class="line-modified">!     final MethodHandle target;  // Note: This field is known to the JVM.</span>
  
      /**
       * Make a blank call site object with the given method type.
       * An initial target method is supplied which will throw
       * an {@link IllegalStateException} if called.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,15 ***</span>
       * @throws ClassCastException if the hook returns something other than a {@code MethodHandle}
       * @throws Throwable anything else thrown by the hook function
       */
      /*package-private*/
      CallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
<span class="line-modified">!         this(targetType);</span>
          ConstantCallSite selfCCS = (ConstantCallSite) this;
          MethodHandle boundTarget = (MethodHandle) createTargetHook.invokeWithArguments(selfCCS);
<span class="line-modified">!         checkTargetChange(this.target, boundTarget);</span>
<span class="line-modified">!         this.target = boundTarget;</span>
      }
  
      /**
       * {@code CallSite} dependency context.
       * JVM uses CallSite.context to store nmethod dependencies on the call site target.
<span class="line-new-header">--- 128,15 ---</span>
       * @throws ClassCastException if the hook returns something other than a {@code MethodHandle}
       * @throws Throwable anything else thrown by the hook function
       */
      /*package-private*/
      CallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
<span class="line-modified">!         this(targetType); // need to initialize target to make CallSite.type() work in createTargetHook</span>
          ConstantCallSite selfCCS = (ConstantCallSite) this;
          MethodHandle boundTarget = (MethodHandle) createTargetHook.invokeWithArguments(selfCCS);
<span class="line-modified">!         setTargetNormal(boundTarget); // ConstantCallSite doesn&#39;t publish CallSite.target</span>
<span class="line-modified">!         UNSAFE.storeStoreFence(); // barrier between target and isFrozen updates</span>
      }
  
      /**
       * {@code CallSite} dependency context.
       * JVM uses CallSite.context to store nmethod dependencies on the call site target.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,15 ***</span>
       * @see MutableCallSite#setTarget
       * @see VolatileCallSite#setTarget
       */
      public abstract void setTarget(MethodHandle newTarget);
  
<span class="line-modified">!     void checkTargetChange(MethodHandle oldTarget, MethodHandle newTarget) {</span>
<span class="line-modified">!         MethodType oldType = oldTarget.type();</span>
          MethodType newType = newTarget.type();  // null check!
<span class="line-modified">!         if (!newType.equals(oldType))</span>
              throw wrongTargetType(newTarget, oldType);
      }
  
      private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
          return new WrongMethodTypeException(String.valueOf(target)+&quot; should be of type &quot;+type);
      }
<span class="line-new-header">--- 189,16 ---</span>
       * @see MutableCallSite#setTarget
       * @see VolatileCallSite#setTarget
       */
      public abstract void setTarget(MethodHandle newTarget);
  
<span class="line-modified">!     private void checkTargetChange(MethodHandle newTarget) {</span>
<span class="line-modified">!         MethodType oldType = target.type(); // target is always present</span>
          MethodType newType = newTarget.type();  // null check!
<span class="line-modified">!         if (newType != oldType) {</span>
              throw wrongTargetType(newTarget, oldType);
<span class="line-added">+         }</span>
      }
  
      private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
          return new WrongMethodTypeException(String.valueOf(target)+&quot; should be of type &quot;+type);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,11 ***</span>
       *
       * @return a method handle which always invokes this call site&#39;s current target
       */
      public abstract MethodHandle dynamicInvoker();
  
<span class="line-modified">!     /*non-public*/ MethodHandle makeDynamicInvoker() {</span>
          MethodHandle getTarget = getTargetHandle().bindArgumentL(0, this);
          MethodHandle invoker = MethodHandles.exactInvoker(this.type());
          return MethodHandles.foldArguments(invoker, getTarget);
      }
  
<span class="line-new-header">--- 217,12 ---</span>
       *
       * @return a method handle which always invokes this call site&#39;s current target
       */
      public abstract MethodHandle dynamicInvoker();
  
<span class="line-modified">!     /*package-private*/</span>
<span class="line-added">+     MethodHandle makeDynamicInvoker() {</span>
          MethodHandle getTarget = getTargetHandle().bindArgumentL(0, this);
          MethodHandle invoker = MethodHandles.exactInvoker(this.type());
          return MethodHandles.foldArguments(invoker, getTarget);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,23 ***</span>
          assert(offset &gt; 0);
          return offset;
      }
  
      /*package-private*/
<span class="line-modified">!     void setTargetNormal(MethodHandle newTarget) {</span>
          MethodHandleNatives.setCallSiteTargetNormal(this, newTarget);
      }
      /*package-private*/
<span class="line-modified">!     MethodHandle getTargetVolatile() {</span>
          return (MethodHandle) UNSAFE.getReferenceVolatile(this, getTargetOffset());
      }
      /*package-private*/
<span class="line-modified">!     void setTargetVolatile(MethodHandle newTarget) {</span>
          MethodHandleNatives.setCallSiteTargetVolatile(this, newTarget);
      }
  
      // this implements the upcall from the JVM, MethodHandleNatives.linkCallSite:
      static CallSite makeSite(MethodHandle bootstrapMethod,
                               // Callee information:
                               String name, MethodType type,
                               // Extra arguments for BSM, if any:
                               Object info,
<span class="line-new-header">--- 283,28 ---</span>
          assert(offset &gt; 0);
          return offset;
      }
  
      /*package-private*/
<span class="line-modified">!     final void setTargetNormal(MethodHandle newTarget) {</span>
<span class="line-added">+         checkTargetChange(newTarget);</span>
          MethodHandleNatives.setCallSiteTargetNormal(this, newTarget);
      }
<span class="line-added">+ </span>
      /*package-private*/
<span class="line-modified">!     final MethodHandle getTargetVolatile() {</span>
          return (MethodHandle) UNSAFE.getReferenceVolatile(this, getTargetOffset());
      }
<span class="line-added">+ </span>
      /*package-private*/
<span class="line-modified">!     final void setTargetVolatile(MethodHandle newTarget) {</span>
<span class="line-added">+         checkTargetChange(newTarget);</span>
          MethodHandleNatives.setCallSiteTargetVolatile(this, newTarget);
      }
  
      // this implements the upcall from the JVM, MethodHandleNatives.linkCallSite:
<span class="line-added">+     /*package-private*/</span>
      static CallSite makeSite(MethodHandle bootstrapMethod,
                               // Callee information:
                               String name, MethodType type,
                               // Extra arguments for BSM, if any:
                               Object info,
</pre>
<center><a href="BoundMethodHandle.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ClassSpecializer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/NetworkInterface.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="NetPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NoRouteToHostException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/NetworkInterface.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.util.Arrays;
 29 import java.util.Enumeration;
 30 import java.util.NoSuchElementException;
<span class="line-removed"> 31 import java.security.AccessController;</span>
 32 import java.util.Spliterator;
 33 import java.util.Spliterators;
 34 import java.util.stream.Stream;
 35 import java.util.stream.StreamSupport;
 36 
 37 /**
 38  * This class represents a Network Interface made up of a name,
 39  * and a list of IP addresses assigned to this interface.
 40  * It is used to identify the local interface on which a multicast group
 41  * is joined.
 42  *
 43  * Interfaces are normally known by names such as &quot;le0&quot;.
 44  *
 45  * @since 1.4
 46  */
 47 public final class NetworkInterface {
 48     private String name;
 49     private String displayName;
 50     private int index;
 51     private InetAddress addrs[];
 52     private InterfaceAddress bindings[];
 53     private NetworkInterface childs[];
 54     private NetworkInterface parent = null;
 55     private boolean virtual = false;
 56     private static final NetworkInterface defaultInterface;
 57     private static final int defaultIndex; /* index of defaultInterface */
 58 
 59     static {
<span class="line-modified"> 60         AccessController.doPrivileged(</span>
<span class="line-removed"> 61             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed"> 62                 public Void run() {</span>
<span class="line-removed"> 63                     System.loadLibrary(&quot;net&quot;);</span>
<span class="line-removed"> 64                     return null;</span>
<span class="line-removed"> 65                 }</span>
<span class="line-removed"> 66             });</span>
 67 
 68         init();
 69         defaultInterface = DefaultInterface.getDefault();
 70         if (defaultInterface != null) {
 71             defaultIndex = defaultInterface.getIndex();
 72         } else {
 73             defaultIndex = 0;
 74         }
 75     }
 76 
 77     /**
 78      * Returns an NetworkInterface object with index set to 0 and name to null.
 79      * Setting such an interface on a MulticastSocket will cause the
 80      * kernel to choose one interface for sending multicast packets.
 81      *
 82      */
 83     NetworkInterface() {
 84     }
 85 
 86     NetworkInterface(String name, int index, InetAddress[] addrs) {
</pre>
<hr />
<pre>
304      * interfaces it is not defined which network interface is
305      * returned.
306      *
307      * @param   addr
308      *          The {@code InetAddress} to search with.
309      *
310      * @return  A {@code NetworkInterface}
311      *          or {@code null} if there is no network interface
312      *          with the specified IP address.
313      *
314      * @throws  SocketException
315      *          If an I/O error occurs.
316      *
317      * @throws  NullPointerException
318      *          If the specified address is {@code null}.
319      */
320     public static NetworkInterface getByInetAddress(InetAddress addr) throws SocketException {
321         if (addr == null) {
322             throw new NullPointerException();
323         }
<span class="line-modified">324         if (addr instanceof Inet4Address) {</span>
<span class="line-modified">325             Inet4Address inet4Address = (Inet4Address) addr;</span>
<span class="line-modified">326             if (inet4Address.holder.family != InetAddress.IPv4) {</span>
327                 throw new IllegalArgumentException(&quot;invalid family type: &quot;
<span class="line-modified">328                         + inet4Address.holder.family);</span>
329             }
<span class="line-modified">330         } else if (addr instanceof Inet6Address) {</span>
<span class="line-modified">331             Inet6Address inet6Address = (Inet6Address) addr;</span>
<span class="line-removed">332             if (inet6Address.holder.family != InetAddress.IPv6) {</span>
333                 throw new IllegalArgumentException(&quot;invalid family type: &quot;
<span class="line-modified">334                         + inet6Address.holder.family);</span>
335             }
336         } else {
337             throw new IllegalArgumentException(&quot;invalid address type: &quot; + addr);
338         }
339         return getByInetAddress0(addr);
340     }
341 
342     /**
343      * Returns an {@code Enumeration} of all the interfaces on this machine. The
344      * {@code Enumeration} contains at least one element, possibly representing
345      * a loopback interface that only supports communication between entities on
346      * this machine.
347      *
348      * @apiNote this method can be used in combination with
349      * {@link #getInetAddresses()} to obtain all IP addresses for this node
350      *
351      * @return an Enumeration of NetworkInterfaces found on this machine
<span class="line-modified">352      * @exception  SocketException  if an I/O error occurs,</span>
353      *             or if the platform does not have at least one configured
354      *             network interface.
355      * @see #networkInterfaces()
356      */
357     public static Enumeration&lt;NetworkInterface&gt; getNetworkInterfaces()
358         throws SocketException {
359         NetworkInterface[] netifs = getAll();
360         if (netifs != null &amp;&amp; netifs.length &gt; 0) {
361             return enumerationFromArray(netifs);
362         } else {
363             throw new SocketException(&quot;No network interfaces configured&quot;);
364         }
365     }
366 
367     /**
368      * Returns a {@code Stream} of all the interfaces on this machine.  The
369      * {@code Stream} contains at least one interface, possibly representing a
370      * loopback interface that only supports communication between entities on
371      * this machine.
372      *
373      * @apiNote this method can be used in combination with
374      * {@link #inetAddresses()}} to obtain a stream of all IP addresses for
375      * this node, for example:
376      * &lt;pre&gt; {@code
377      * Stream&lt;InetAddress&gt; addrs = NetworkInterface.networkInterfaces()
378      *     .flatMap(NetworkInterface::inetAddresses);
379      * }&lt;/pre&gt;
380      *
381      * @return a Stream of NetworkInterfaces found on this machine
<span class="line-modified">382      * @exception  SocketException  if an I/O error occurs,</span>
383      *             or if the platform does not have at least one configured
384      *             network interface.
385      * @since 9
386      */
387     public static Stream&lt;NetworkInterface&gt; networkInterfaces()
388         throws SocketException {
389         NetworkInterface[] netifs = getAll();
390         if (netifs != null &amp;&amp; netifs.length &gt; 0) {
391             return streamFromArray(netifs);
392         }  else {
393             throw new SocketException(&quot;No network interfaces configured&quot;);
394         }
395     }
396 

















397     private static &lt;T&gt; Enumeration&lt;T&gt; enumerationFromArray(T[] a) {
398         return new Enumeration&lt;&gt;() {
399             int i = 0;
400 
401             @Override
402             public T nextElement() {
403                 if (i &lt; a.length) {
404                     return a[i++];
405                 } else {
406                     throw new NoSuchElementException();
407                 }
408             }
409 
410             @Override
411             public boolean hasMoreElements() {
412                 return i &lt; a.length;
413             }
414         };
415     }
416 
417     private static &lt;T&gt; Stream&lt;T&gt; streamFromArray(T[] a) {
418         return StreamSupport.stream(
419                 Spliterators.spliterator(
420                         a,
421                         Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL),
422                 false);
423     }
424 
425     private static native NetworkInterface[] getAll()
426         throws SocketException;
427 
428     private static native NetworkInterface getByName0(String name)
429         throws SocketException;
430 
431     private static native NetworkInterface getByIndex0(int index)
432         throws SocketException;
433 



434     private static native NetworkInterface getByInetAddress0(InetAddress addr)
435         throws SocketException;
436 
437     /**
438      * Returns whether a network interface is up and running.
439      *
440      * @return  {@code true} if the interface is up and running.
<span class="line-modified">441      * @exception       SocketException if an I/O error occurs.</span>
442      * @since 1.6
443      */
444 
445     public boolean isUp() throws SocketException {
446         return isUp0(name, index);
447     }
448 
449     /**
450      * Returns whether a network interface is a loopback interface.
451      *
452      * @return  {@code true} if the interface is a loopback interface.
<span class="line-modified">453      * @exception       SocketException if an I/O error occurs.</span>
454      * @since 1.6
455      */
456 
457     public boolean isLoopback() throws SocketException {
458         return isLoopback0(name, index);
459     }
460 
461     /**
462      * Returns whether a network interface is a point to point interface.
463      * A typical point to point interface would be a PPP connection through
464      * a modem.
465      *
466      * @return  {@code true} if the interface is a point to point
467      *          interface.
<span class="line-modified">468      * @exception       SocketException if an I/O error occurs.</span>
469      * @since 1.6
470      */
471 
472     public boolean isPointToPoint() throws SocketException {
473         return isP2P0(name, index);
474     }
475 
476     /**
477      * Returns whether a network interface supports multicasting or not.
478      *
479      * @return  {@code true} if the interface supports Multicasting.
<span class="line-modified">480      * @exception       SocketException if an I/O error occurs.</span>
481      * @since 1.6
482      */
483 
484     public boolean supportsMulticast() throws SocketException {
485         return supportsMulticast0(name, index);
486     }
487 
488     /**
489      * Returns the hardware address (usually MAC) of the interface if it
490      * has one and if it can be accessed given the current privileges.
491      * If a security manager is set, then the caller must have
492      * the permission {@link NetPermission}(&quot;getNetworkInformation&quot;).
493      *
494      * @return  a byte array containing the address, or {@code null} if
495      *          the address doesn&#39;t exist, is not accessible or a security
496      *          manager is set and the caller does not have the permission
497      *          NetPermission(&quot;getNetworkInformation&quot;)
498      *
<span class="line-modified">499      * @exception       SocketException if an I/O error occurs.</span>
500      * @since 1.6
501      */
502     public byte[] getHardwareAddress() throws SocketException {
503         SecurityManager sec = System.getSecurityManager();
504         if (sec != null) {
505             try {
506                 sec.checkPermission(new NetPermission(&quot;getNetworkInformation&quot;));
507             } catch (SecurityException e) {
508                 if (!getInetAddresses().hasMoreElements()) {
509                     // don&#39;t have connect permission to any local address
510                     return null;
511                 }
512             }
513         }
514         for (InetAddress addr : addrs) {
515             if (addr instanceof Inet4Address) {
516                 return getMacAddr0(((Inet4Address)addr).getAddress(), name, index);
517             }
518         }
519         return getMacAddr0(null, name, index);
520     }
521 
522     /**
523      * Returns the Maximum Transmission Unit (MTU) of this interface.
524      *
525      * @return the value of the MTU for that interface.
<span class="line-modified">526      * @exception       SocketException if an I/O error occurs.</span>
527      * @since 1.6
528      */
529     public int getMTU() throws SocketException {
530         return getMTU0(name, index);
531     }
532 
533     /**
534      * Returns whether this interface is a virtual interface (also called
535      * subinterface).
536      * Virtual interfaces are, on some systems, interfaces created as a child
537      * of a physical interface and given different settings (like address or
538      * MTU). Usually the name of the interface will the name of the parent
539      * followed by a colon (:) and a number identifying the child since there
540      * can be several virtual interfaces attached to a single physical
541      * interface.
542      *
543      * @return {@code true} if this interface is a virtual interface.
544      * @since 1.6
545      */
546     public boolean isVirtual() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.util.Arrays;
 29 import java.util.Enumeration;
 30 import java.util.NoSuchElementException;

 31 import java.util.Spliterator;
 32 import java.util.Spliterators;
 33 import java.util.stream.Stream;
 34 import java.util.stream.StreamSupport;
 35 
 36 /**
 37  * This class represents a Network Interface made up of a name,
 38  * and a list of IP addresses assigned to this interface.
 39  * It is used to identify the local interface on which a multicast group
 40  * is joined.
 41  *
 42  * Interfaces are normally known by names such as &quot;le0&quot;.
 43  *
 44  * @since 1.4
 45  */
 46 public final class NetworkInterface {
 47     private String name;
 48     private String displayName;
 49     private int index;
 50     private InetAddress addrs[];
 51     private InterfaceAddress bindings[];
 52     private NetworkInterface childs[];
 53     private NetworkInterface parent = null;
 54     private boolean virtual = false;
 55     private static final NetworkInterface defaultInterface;
 56     private static final int defaultIndex; /* index of defaultInterface */
 57 
 58     static {
<span class="line-modified"> 59         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 60 
 61         init();
 62         defaultInterface = DefaultInterface.getDefault();
 63         if (defaultInterface != null) {
 64             defaultIndex = defaultInterface.getIndex();
 65         } else {
 66             defaultIndex = 0;
 67         }
 68     }
 69 
 70     /**
 71      * Returns an NetworkInterface object with index set to 0 and name to null.
 72      * Setting such an interface on a MulticastSocket will cause the
 73      * kernel to choose one interface for sending multicast packets.
 74      *
 75      */
 76     NetworkInterface() {
 77     }
 78 
 79     NetworkInterface(String name, int index, InetAddress[] addrs) {
</pre>
<hr />
<pre>
297      * interfaces it is not defined which network interface is
298      * returned.
299      *
300      * @param   addr
301      *          The {@code InetAddress} to search with.
302      *
303      * @return  A {@code NetworkInterface}
304      *          or {@code null} if there is no network interface
305      *          with the specified IP address.
306      *
307      * @throws  SocketException
308      *          If an I/O error occurs.
309      *
310      * @throws  NullPointerException
311      *          If the specified address is {@code null}.
312      */
313     public static NetworkInterface getByInetAddress(InetAddress addr) throws SocketException {
314         if (addr == null) {
315             throw new NullPointerException();
316         }
<span class="line-modified">317 </span>
<span class="line-modified">318         if (addr.holder.family == InetAddress.IPv4) {</span>
<span class="line-modified">319             if (!(addr instanceof Inet4Address)) {</span>
320                 throw new IllegalArgumentException(&quot;invalid family type: &quot;
<span class="line-modified">321                         + addr.holder.family);</span>
322             }
<span class="line-modified">323         } else if (addr.holder.family == InetAddress.IPv6) {</span>
<span class="line-modified">324             if (!(addr instanceof Inet6Address)) {</span>

325                 throw new IllegalArgumentException(&quot;invalid family type: &quot;
<span class="line-modified">326                         + addr.holder.family);</span>
327             }
328         } else {
329             throw new IllegalArgumentException(&quot;invalid address type: &quot; + addr);
330         }
331         return getByInetAddress0(addr);
332     }
333 
334     /**
335      * Returns an {@code Enumeration} of all the interfaces on this machine. The
336      * {@code Enumeration} contains at least one element, possibly representing
337      * a loopback interface that only supports communication between entities on
338      * this machine.
339      *
340      * @apiNote this method can be used in combination with
341      * {@link #getInetAddresses()} to obtain all IP addresses for this node
342      *
343      * @return an Enumeration of NetworkInterfaces found on this machine
<span class="line-modified">344      * @throws     SocketException  if an I/O error occurs,</span>
345      *             or if the platform does not have at least one configured
346      *             network interface.
347      * @see #networkInterfaces()
348      */
349     public static Enumeration&lt;NetworkInterface&gt; getNetworkInterfaces()
350         throws SocketException {
351         NetworkInterface[] netifs = getAll();
352         if (netifs != null &amp;&amp; netifs.length &gt; 0) {
353             return enumerationFromArray(netifs);
354         } else {
355             throw new SocketException(&quot;No network interfaces configured&quot;);
356         }
357     }
358 
359     /**
360      * Returns a {@code Stream} of all the interfaces on this machine.  The
361      * {@code Stream} contains at least one interface, possibly representing a
362      * loopback interface that only supports communication between entities on
363      * this machine.
364      *
365      * @apiNote this method can be used in combination with
366      * {@link #inetAddresses()}} to obtain a stream of all IP addresses for
367      * this node, for example:
368      * &lt;pre&gt; {@code
369      * Stream&lt;InetAddress&gt; addrs = NetworkInterface.networkInterfaces()
370      *     .flatMap(NetworkInterface::inetAddresses);
371      * }&lt;/pre&gt;
372      *
373      * @return a Stream of NetworkInterfaces found on this machine
<span class="line-modified">374      * @throws     SocketException  if an I/O error occurs,</span>
375      *             or if the platform does not have at least one configured
376      *             network interface.
377      * @since 9
378      */
379     public static Stream&lt;NetworkInterface&gt; networkInterfaces()
380         throws SocketException {
381         NetworkInterface[] netifs = getAll();
382         if (netifs != null &amp;&amp; netifs.length &gt; 0) {
383             return streamFromArray(netifs);
384         }  else {
385             throw new SocketException(&quot;No network interfaces configured&quot;);
386         }
387     }
388 
<span class="line-added">389     /**</span>
<span class="line-added">390      * Checks if the given address is bound to any of the interfaces on this</span>
<span class="line-added">391      * machine.</span>
<span class="line-added">392      *</span>
<span class="line-added">393      * @param   addr</span>
<span class="line-added">394      *          The {@code InetAddress} to search with.</span>
<span class="line-added">395      * @return  true iff the addr parameter is currently bound to one of</span>
<span class="line-added">396      *          the interfaces on this machine.</span>
<span class="line-added">397      *</span>
<span class="line-added">398      * @throws  SocketException</span>
<span class="line-added">399      *          If an I/O error occurs.</span>
<span class="line-added">400      */</span>
<span class="line-added">401     /* package-private */ static boolean isBoundInetAddress(InetAddress addr)</span>
<span class="line-added">402         throws SocketException {</span>
<span class="line-added">403         return boundInetAddress0(addr);</span>
<span class="line-added">404     }</span>
<span class="line-added">405 </span>
406     private static &lt;T&gt; Enumeration&lt;T&gt; enumerationFromArray(T[] a) {
407         return new Enumeration&lt;&gt;() {
408             int i = 0;
409 
410             @Override
411             public T nextElement() {
412                 if (i &lt; a.length) {
413                     return a[i++];
414                 } else {
415                     throw new NoSuchElementException();
416                 }
417             }
418 
419             @Override
420             public boolean hasMoreElements() {
421                 return i &lt; a.length;
422             }
423         };
424     }
425 
426     private static &lt;T&gt; Stream&lt;T&gt; streamFromArray(T[] a) {
427         return StreamSupport.stream(
428                 Spliterators.spliterator(
429                         a,
430                         Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL),
431                 false);
432     }
433 
434     private static native NetworkInterface[] getAll()
435         throws SocketException;
436 
437     private static native NetworkInterface getByName0(String name)
438         throws SocketException;
439 
440     private static native NetworkInterface getByIndex0(int index)
441         throws SocketException;
442 
<span class="line-added">443     private static native boolean boundInetAddress0(InetAddress addr)</span>
<span class="line-added">444             throws SocketException;</span>
<span class="line-added">445 </span>
446     private static native NetworkInterface getByInetAddress0(InetAddress addr)
447         throws SocketException;
448 
449     /**
450      * Returns whether a network interface is up and running.
451      *
452      * @return  {@code true} if the interface is up and running.
<span class="line-modified">453      * @throws          SocketException if an I/O error occurs.</span>
454      * @since 1.6
455      */
456 
457     public boolean isUp() throws SocketException {
458         return isUp0(name, index);
459     }
460 
461     /**
462      * Returns whether a network interface is a loopback interface.
463      *
464      * @return  {@code true} if the interface is a loopback interface.
<span class="line-modified">465      * @throws          SocketException if an I/O error occurs.</span>
466      * @since 1.6
467      */
468 
469     public boolean isLoopback() throws SocketException {
470         return isLoopback0(name, index);
471     }
472 
473     /**
474      * Returns whether a network interface is a point to point interface.
475      * A typical point to point interface would be a PPP connection through
476      * a modem.
477      *
478      * @return  {@code true} if the interface is a point to point
479      *          interface.
<span class="line-modified">480      * @throws          SocketException if an I/O error occurs.</span>
481      * @since 1.6
482      */
483 
484     public boolean isPointToPoint() throws SocketException {
485         return isP2P0(name, index);
486     }
487 
488     /**
489      * Returns whether a network interface supports multicasting or not.
490      *
491      * @return  {@code true} if the interface supports Multicasting.
<span class="line-modified">492      * @throws          SocketException if an I/O error occurs.</span>
493      * @since 1.6
494      */
495 
496     public boolean supportsMulticast() throws SocketException {
497         return supportsMulticast0(name, index);
498     }
499 
500     /**
501      * Returns the hardware address (usually MAC) of the interface if it
502      * has one and if it can be accessed given the current privileges.
503      * If a security manager is set, then the caller must have
504      * the permission {@link NetPermission}(&quot;getNetworkInformation&quot;).
505      *
506      * @return  a byte array containing the address, or {@code null} if
507      *          the address doesn&#39;t exist, is not accessible or a security
508      *          manager is set and the caller does not have the permission
509      *          NetPermission(&quot;getNetworkInformation&quot;)
510      *
<span class="line-modified">511      * @throws          SocketException if an I/O error occurs.</span>
512      * @since 1.6
513      */
514     public byte[] getHardwareAddress() throws SocketException {
515         SecurityManager sec = System.getSecurityManager();
516         if (sec != null) {
517             try {
518                 sec.checkPermission(new NetPermission(&quot;getNetworkInformation&quot;));
519             } catch (SecurityException e) {
520                 if (!getInetAddresses().hasMoreElements()) {
521                     // don&#39;t have connect permission to any local address
522                     return null;
523                 }
524             }
525         }
526         for (InetAddress addr : addrs) {
527             if (addr instanceof Inet4Address) {
528                 return getMacAddr0(((Inet4Address)addr).getAddress(), name, index);
529             }
530         }
531         return getMacAddr0(null, name, index);
532     }
533 
534     /**
535      * Returns the Maximum Transmission Unit (MTU) of this interface.
536      *
537      * @return the value of the MTU for that interface.
<span class="line-modified">538      * @throws          SocketException if an I/O error occurs.</span>
539      * @since 1.6
540      */
541     public int getMTU() throws SocketException {
542         return getMTU0(name, index);
543     }
544 
545     /**
546      * Returns whether this interface is a virtual interface (also called
547      * subinterface).
548      * Virtual interfaces are, on some systems, interfaces created as a child
549      * of a physical interface and given different settings (like address or
550      * MTU). Usually the name of the interface will the name of the parent
551      * followed by a colon (:) and a number identifying the child since there
552      * can be several virtual interfaces attached to a single physical
553      * interface.
554      *
555      * @return {@code true} if this interface is a virtual interface.
556      * @since 1.6
557      */
558     public boolean isVirtual() {
</pre>
</td>
</tr>
</table>
<center><a href="NetPermission.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NoRouteToHostException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
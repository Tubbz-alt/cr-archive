<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/zip/ZipInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.InputStream;
 29 import java.io.IOException;
 30 import java.io.EOFException;
 31 import java.io.PushbackInputStream;
 32 import java.nio.charset.Charset;
<a name="2" id="anc2"></a><span class="line-modified"> 33 import java.nio.charset.StandardCharsets;</span>


 34 import static java.util.zip.ZipConstants64.*;
 35 import static java.util.zip.ZipUtils.*;
 36 
 37 /**
 38  * This class implements an input stream filter for reading files in the
 39  * ZIP file format. Includes support for both compressed and uncompressed
 40  * entries.
 41  *
 42  * @author      David Connelly
 43  * @since 1.1
 44  */
<a name="3" id="anc3"></a><span class="line-modified"> 45 public</span>
<span class="line-removed"> 46 class ZipInputStream extends InflaterInputStream implements ZipConstants {</span>
 47     private ZipEntry entry;
 48     private int flag;
 49     private CRC32 crc = new CRC32();
 50     private long remaining;
 51     private byte[] tmpbuf = new byte[512];
 52 
 53     private static final int STORED = ZipEntry.STORED;
 54     private static final int DEFLATED = ZipEntry.DEFLATED;
 55 
 56     private boolean closed = false;
 57     // this flag is set to true after EOF has reached for
 58     // one entry
 59     private boolean entryEOF = false;
 60 
 61     private ZipCoder zc;
 62 
 63     /**
 64      * Check to make sure that this stream has not been closed
 65      */
 66     private void ensureOpen() throws IOException {
 67         if (closed) {
 68             throw new IOException(&quot;Stream closed&quot;);
 69         }
 70     }
 71 
 72     /**
 73      * Creates a new ZIP input stream.
 74      *
 75      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 76      * decode the entry names.
 77      *
 78      * @param in the actual input stream
 79      */
 80     public ZipInputStream(InputStream in) {
<a name="4" id="anc4"></a><span class="line-modified"> 81         this(in, StandardCharsets.UTF_8);</span>
 82     }
 83 
 84     /**
 85      * Creates a new ZIP input stream.
 86      *
 87      * @param in the actual input stream
 88      *
 89      * @param charset
 90      *        The {@linkplain java.nio.charset.Charset charset} to be
 91      *        used to decode the ZIP entry name (ignored if the
 92      *        &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 93      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 94      *        flag is set).
 95      *
 96      * @since 1.7
 97      */
 98     public ZipInputStream(InputStream in, Charset charset) {
 99         super(new PushbackInputStream(in, 512), new Inflater(true), 512);
100         usesDefaultInflater = true;
101         if (in == null) {
102             throw new NullPointerException(&quot;in is null&quot;);
103         }
104         if (charset == null)
105             throw new NullPointerException(&quot;charset is null&quot;);
106         this.zc = ZipCoder.get(charset);
107     }
108 
109     /**
110      * Reads the next ZIP file entry and positions the stream at the
111      * beginning of the entry data.
112      * @return the next ZIP file entry, or null if there are no more entries
<a name="5" id="anc5"></a><span class="line-modified">113      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">114      * @exception IOException if an I/O error has occurred</span>
115      */
116     public ZipEntry getNextEntry() throws IOException {
117         ensureOpen();
118         if (entry != null) {
119             closeEntry();
120         }
121         crc.reset();
122         inf.reset();
123         if ((entry = readLOC()) == null) {
124             return null;
125         }
126         if (entry.method == STORED) {
127             remaining = entry.size;
128         }
129         entryEOF = false;
130         return entry;
131     }
132 
133     /**
134      * Closes the current ZIP entry and positions the stream for reading the
135      * next entry.
<a name="6" id="anc6"></a><span class="line-modified">136      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">137      * @exception IOException if an I/O error has occurred</span>
138      */
139     public void closeEntry() throws IOException {
140         ensureOpen();
141         while (read(tmpbuf, 0, tmpbuf.length) != -1) ;
142         entryEOF = true;
143     }
144 
145     /**
146      * Returns 0 after EOF has reached for the current entry data,
147      * otherwise always return 1.
148      * &lt;p&gt;
149      * Programs should not count on this method to return the actual number
150      * of bytes that could be read without blocking.
151      *
152      * @return     1 before EOF and 0 after EOF has reached for current entry.
<a name="7" id="anc7"></a><span class="line-modified">153      * @exception  IOException  if an I/O error occurs.</span>
154      *
155      */
156     public int available() throws IOException {
157         ensureOpen();
158         if (entryEOF) {
159             return 0;
160         } else {
161             return 1;
162         }
163     }
164 
165     /**
166      * Reads from the current ZIP entry into an array of bytes.
<a name="8" id="anc8"></a><span class="line-modified">167      * If &lt;code&gt;len&lt;/code&gt; is not zero, the method</span>
168      * blocks until some input is available; otherwise, no
<a name="9" id="anc9"></a><span class="line-modified">169      * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
170      * @param b the buffer into which the data is read
<a name="10" id="anc10"></a><span class="line-modified">171      * @param off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</span>
172      * @param len the maximum number of bytes read
173      * @return the actual number of bytes read, or -1 if the end of the
174      *         entry is reached
<a name="11" id="anc11"></a><span class="line-modified">175      * @exception  NullPointerException if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">176      * @exception  IndexOutOfBoundsException if &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">177      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">178      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">179      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">180      * @exception IOException if an I/O error has occurred</span>
181      */
182     public int read(byte[] b, int off, int len) throws IOException {
183         ensureOpen();
184         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
185             throw new IndexOutOfBoundsException();
186         } else if (len == 0) {
187             return 0;
188         }
189 
190         if (entry == null) {
191             return -1;
192         }
193         switch (entry.method) {
194         case DEFLATED:
195             len = super.read(b, off, len);
196             if (len == -1) {
197                 readEnd(entry);
198                 entryEOF = true;
199                 entry = null;
200             } else {
201                 crc.update(b, off, len);
202             }
203             return len;
204         case STORED:
205             if (remaining &lt;= 0) {
206                 entryEOF = true;
207                 entry = null;
208                 return -1;
209             }
210             if (len &gt; remaining) {
211                 len = (int)remaining;
212             }
213             len = in.read(b, off, len);
214             if (len == -1) {
215                 throw new ZipException(&quot;unexpected EOF&quot;);
216             }
217             crc.update(b, off, len);
218             remaining -= len;
219             if (remaining == 0 &amp;&amp; entry.crc != crc.getValue()) {
220                 throw new ZipException(
221                     &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(entry.crc) +
222                     &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
223             }
224             return len;
225         default:
226             throw new ZipException(&quot;invalid compression method&quot;);
227         }
228     }
229 
230     /**
231      * Skips specified number of bytes in the current ZIP entry.
232      * @param n the number of bytes to skip
233      * @return the actual number of bytes skipped
<a name="12" id="anc12"></a><span class="line-modified">234      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">235      * @exception IOException if an I/O error has occurred</span>
<span class="line-modified">236      * @exception IllegalArgumentException if {@code n &lt; 0}</span>
237      */
238     public long skip(long n) throws IOException {
239         if (n &lt; 0) {
240             throw new IllegalArgumentException(&quot;negative skip length&quot;);
241         }
242         ensureOpen();
243         int max = (int)Math.min(n, Integer.MAX_VALUE);
244         int total = 0;
245         while (total &lt; max) {
246             int len = max - total;
247             if (len &gt; tmpbuf.length) {
248                 len = tmpbuf.length;
249             }
250             len = read(tmpbuf, 0, len);
251             if (len == -1) {
252                 entryEOF = true;
253                 break;
254             }
255             total += len;
256         }
257         return total;
258     }
259 
260     /**
261      * Closes this input stream and releases any system resources associated
262      * with the stream.
<a name="13" id="anc13"></a><span class="line-modified">263      * @exception IOException if an I/O error has occurred</span>
264      */
265     public void close() throws IOException {
266         if (!closed) {
267             super.close();
268             closed = true;
269         }
270     }
271 
272     private byte[] b = new byte[256];
273 
274     /*
275      * Reads local file (LOC) header for next entry.
276      */
277     private ZipEntry readLOC() throws IOException {
278         try {
279             readFully(tmpbuf, 0, LOCHDR);
280         } catch (EOFException e) {
281             return null;
282         }
283         if (get32(tmpbuf, 0) != LOCSIG) {
284             return null;
285         }
286         // get flag first, we need check USE_UTF8.
287         flag = get16(tmpbuf, LOCFLG);
288         // get the entry name and create the ZipEntry first
289         int len = get16(tmpbuf, LOCNAM);
290         int blen = b.length;
291         if (len &gt; blen) {
292             do {
293                 blen = blen * 2;
294             } while (len &gt; blen);
295             b = new byte[blen];
296         }
297         readFully(b, 0, len);
298         // Force to use UTF-8 if the USE_UTF8 bit is ON
299         ZipEntry e = createZipEntry(((flag &amp; USE_UTF8) != 0)
300                                     ? zc.toStringUTF8(b, len)
301                                     : zc.toString(b, len));
302         // now get the remaining fields for the entry
303         if ((flag &amp; 1) == 1) {
304             throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);
305         }
306         e.method = get16(tmpbuf, LOCHOW);
307         e.xdostime = get32(tmpbuf, LOCTIM);
308         if ((flag &amp; 8) == 8) {
309             /* &quot;Data Descriptor&quot; present */
310             if (e.method != DEFLATED) {
311                 throw new ZipException(
312                         &quot;only DEFLATED entries can have EXT descriptor&quot;);
313             }
314         } else {
315             e.crc = get32(tmpbuf, LOCCRC);
316             e.csize = get32(tmpbuf, LOCSIZ);
317             e.size = get32(tmpbuf, LOCLEN);
318         }
319         len = get16(tmpbuf, LOCEXT);
320         if (len &gt; 0) {
321             byte[] extra = new byte[len];
322             readFully(extra, 0, len);
323             e.setExtra0(extra,
<a name="14" id="anc14"></a><span class="line-modified">324                         e.csize == ZIP64_MAGICVAL || e.size == ZIP64_MAGICVAL);</span>
325         }
326         return e;
327     }
328 
329     /**
<a name="15" id="anc15"></a><span class="line-modified">330      * Creates a new &lt;code&gt;ZipEntry&lt;/code&gt; object for the specified</span>
331      * entry name.
332      *
333      * @param name the ZIP file entry name
334      * @return the ZipEntry just created
335      */
336     protected ZipEntry createZipEntry(String name) {
337         return new ZipEntry(name);
338     }
339 
340     /**
341      * Reads end of deflated entry as well as EXT descriptor if present.
342      *
343      * Local headers for DEFLATED entries may optionally be followed by a
344      * data descriptor, and that data descriptor may optionally contain a
345      * leading signature (EXTSIG).
346      *
347      * From the zip spec http://www.pkware.com/documents/casestudies/APPNOTE.TXT
348      *
349      * &quot;&quot;&quot;Although not originally assigned a signature, the value 0x08074b50
350      * has commonly been adopted as a signature value for the data descriptor
351      * record.  Implementers should be aware that ZIP files may be
352      * encountered with or without this signature marking data descriptors
353      * and should account for either case when reading ZIP files to ensure
354      * compatibility.&quot;&quot;&quot;
355      */
356     private void readEnd(ZipEntry e) throws IOException {
357         int n = inf.getRemaining();
358         if (n &gt; 0) {
359             ((PushbackInputStream)in).unread(buf, len - n, n);
360         }
361         if ((flag &amp; 8) == 8) {
362             /* &quot;Data Descriptor&quot; present */
363             if (inf.getBytesWritten() &gt; ZIP64_MAGICVAL ||
364                 inf.getBytesRead() &gt; ZIP64_MAGICVAL) {
365                 // ZIP64 format
366                 readFully(tmpbuf, 0, ZIP64_EXTHDR);
367                 long sig = get32(tmpbuf, 0);
368                 if (sig != EXTSIG) { // no EXTSIG present
369                     e.crc = sig;
370                     e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);
371                     e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);
372                     ((PushbackInputStream)in).unread(
373                         tmpbuf, ZIP64_EXTHDR - ZIP64_EXTCRC, ZIP64_EXTCRC);
374                 } else {
375                     e.crc = get32(tmpbuf, ZIP64_EXTCRC);
376                     e.csize = get64(tmpbuf, ZIP64_EXTSIZ);
377                     e.size = get64(tmpbuf, ZIP64_EXTLEN);
378                 }
379             } else {
380                 readFully(tmpbuf, 0, EXTHDR);
381                 long sig = get32(tmpbuf, 0);
382                 if (sig != EXTSIG) { // no EXTSIG present
383                     e.crc = sig;
384                     e.csize = get32(tmpbuf, EXTSIZ - EXTCRC);
385                     e.size = get32(tmpbuf, EXTLEN - EXTCRC);
386                     ((PushbackInputStream)in).unread(
387                                                tmpbuf, EXTHDR - EXTCRC, EXTCRC);
388                 } else {
389                     e.crc = get32(tmpbuf, EXTCRC);
390                     e.csize = get32(tmpbuf, EXTSIZ);
391                     e.size = get32(tmpbuf, EXTLEN);
392                 }
393             }
394         }
395         if (e.size != inf.getBytesWritten()) {
396             throw new ZipException(
397                 &quot;invalid entry size (expected &quot; + e.size +
398                 &quot; but got &quot; + inf.getBytesWritten() + &quot; bytes)&quot;);
399         }
400         if (e.csize != inf.getBytesRead()) {
401             throw new ZipException(
402                 &quot;invalid entry compressed size (expected &quot; + e.csize +
403                 &quot; but got &quot; + inf.getBytesRead() + &quot; bytes)&quot;);
404         }
405         if (e.crc != crc.getValue()) {
406             throw new ZipException(
407                 &quot;invalid entry CRC (expected 0x&quot; + Long.toHexString(e.crc) +
408                 &quot; but got 0x&quot; + Long.toHexString(crc.getValue()) + &quot;)&quot;);
409         }
410     }
411 
412     /*
413      * Reads bytes, blocking until all bytes are read.
414      */
415     private void readFully(byte[] b, int off, int len) throws IOException {
416         while (len &gt; 0) {
417             int n = in.read(b, off, len);
418             if (n == -1) {
419                 throw new EOFException();
420             }
421             off += n;
422             len -= n;
423         }
424     }
425 
426 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
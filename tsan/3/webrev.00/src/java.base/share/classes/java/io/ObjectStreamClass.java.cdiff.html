<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectStreamClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,17 ***</span>
<span class="line-new-header">--- 23,20 ---</span>
   * questions.
   */
  
  package java.io;
  
<span class="line-added">+ import java.lang.invoke.MethodHandle;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandles;</span>
  import java.lang.ref.Reference;
  import java.lang.ref.ReferenceQueue;
  import java.lang.ref.SoftReference;
  import java.lang.ref.WeakReference;
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.InvocationTargetException;
<span class="line-added">+ import java.lang.reflect.RecordComponent;</span>
  import java.lang.reflect.UndeclaredThrowableException;
  import java.lang.reflect.Member;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
  import java.lang.reflect.Proxy;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,10 ***</span>
<span class="line-new-header">--- 45,12 ---</span>
  import java.security.MessageDigest;
  import java.security.NoSuchAlgorithmException;
  import java.security.PermissionCollection;
  import java.security.Permissions;
  import java.security.PrivilegedAction;
<span class="line-added">+ import java.security.PrivilegedActionException;</span>
<span class="line-added">+ import java.security.PrivilegedExceptionAction;</span>
  import java.security.ProtectionDomain;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.Comparator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,11 ***</span>
<span class="line-new-header">--- 87,13 ---</span>
  
      /** serialPersistentFields value indicating no serializable fields */
      public static final ObjectStreamField[] NO_FIELDS =
          new ObjectStreamField[0];
  
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -6120832682080437368L;
<span class="line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields =
          NO_FIELDS;
  
      /** reflection factory for obtaining serialization constructors */
      private static final ReflectionFactory reflFactory =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,10 ***</span>
<span class="line-new-header">--- 126,12 ---</span>
  
      /** true if represents dynamic proxy class */
      private boolean isProxy;
      /** true if represents enum type */
      private boolean isEnum;
<span class="line-added">+     /** true if represents record type */</span>
<span class="line-added">+     private boolean isRecord;</span>
      /** true if represented class implements Serializable */
      private boolean serializable;
      /** true if represented class implements Externalizable */
      private boolean externalizable;
      /** true if desc has data written by class-defined writeObject method */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,10 ***</span>
<span class="line-new-header">--- 189,12 ---</span>
      /** data layout of serialized objects described by this class desc */
      private volatile ClassDataSlot[] dataLayout;
  
      /** serialization-appropriate constructor, or null if none */
      private Constructor&lt;?&gt; cons;
<span class="line-added">+     /** record canonical constructor, or null */</span>
<span class="line-added">+     private MethodHandle canonicalCtr;</span>
      /** protection domains that need to be checked when calling the constructor */
      private ProtectionDomain[] domains;
  
      /** class-defined writeObject method, or null if none */
      private Method writeObjectMethod;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,10 ***</span>
<span class="line-new-header">--- 268,13 ---</span>
       * @return  the SUID of the class described by this descriptor
       */
      public long getSerialVersionUID() {
          // REMIND: synchronize instead of relying on volatile?
          if (suid == null) {
<span class="line-added">+             if (isRecord)</span>
<span class="line-added">+                 return 0L;</span>
<span class="line-added">+ </span>
              suid = AccessController.doPrivileged(
                  new PrivilegedAction&lt;Long&gt;() {
                      public Long run() {
                          return computeDefaultSUID(cl);
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,11 ***</span>
  
      /**
       * Return the class in the local VM that this version is mapped to.  Null
       * is returned if there is no corresponding local class.
       *
<span class="line-modified">!      * @return  the &lt;code&gt;Class&lt;/code&gt; instance that this descriptor represents</span>
       */
      @CallerSensitive
      public Class&lt;?&gt; forClass() {
          if (cl == null) {
              return null;
<span class="line-new-header">--- 286,11 ---</span>
  
      /**
       * Return the class in the local VM that this version is mapped to.  Null
       * is returned if there is no corresponding local class.
       *
<span class="line-modified">!      * @return  the {@code Class} instance that this descriptor represents</span>
       */
      @CallerSensitive
      public Class&lt;?&gt; forClass() {
          if (cl == null) {
              return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,18 ***</span>
<span class="line-new-header">--- 477,24 ---</span>
          Thread getOwner() {
              return owner;
          }
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-added">+         return cls.isRecord();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Creates local class descriptor representing given class.
       */
      private ObjectStreamClass(final Class&lt;?&gt; cl) {
          this.cl = cl;
          name = cl.getName();
          isProxy = Proxy.isProxyClass(cl);
          isEnum = Enum.class.isAssignableFrom(cl);
<span class="line-added">+         isRecord = isRecord(cl);</span>
          serializable = Serializable.class.isAssignableFrom(cl);
          externalizable = Externalizable.class.isAssignableFrom(cl);
  
          Class&lt;?&gt; superCl = cl.getSuperclass();
          superDesc = (superCl != null) ? lookup(superCl, false) : null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,11 ***</span>
                          serializeEx = deserializeEx =
                              new ExceptionInfo(e.classname, e.getMessage());
                          fields = NO_FIELDS;
                      }
  
<span class="line-modified">!                     if (externalizable) {</span>
                          cons = getExternalizableConstructor(cl);
                      } else {
                          cons = getSerializableConstructor(cl);
                          writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
                              new Class&lt;?&gt;[] { ObjectOutputStream.class },
<span class="line-new-header">--- 521,13 ---</span>
                          serializeEx = deserializeEx =
                              new ExceptionInfo(e.classname, e.getMessage());
                          fields = NO_FIELDS;
                      }
  
<span class="line-modified">!                     if (isRecord) {</span>
<span class="line-added">+                         canonicalCtr = canonicalRecordCtr(cl);</span>
<span class="line-added">+                     } else if (externalizable) {</span>
                          cons = getExternalizableConstructor(cl);
                      } else {
                          cons = getSerializableConstructor(cl);
                          writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
                              new Class&lt;?&gt;[] { ObjectOutputStream.class },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,18 ***</span>
          }
  
          if (deserializeEx == null) {
              if (isEnum) {
                  deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<span class="line-modified">!             } else if (cons == null) {</span>
                  deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
              }
          }
<span class="line-modified">!         for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-modified">!             if (fields[i].getField() == null) {</span>
<span class="line-modified">!                 defaultSerializeEx = new ExceptionInfo(</span>
<span class="line-modified">!                     name, &quot;unmatched serializable field(s) declared&quot;);</span>
              }
          }
          initialized = true;
      }
  
<span class="line-new-header">--- 560,22 ---</span>
          }
  
          if (deserializeEx == null) {
              if (isEnum) {
                  deserializeEx = new ExceptionInfo(name, &quot;enum type&quot;);
<span class="line-modified">!             } else if (cons == null &amp;&amp; !isRecord) {</span>
                  deserializeEx = new ExceptionInfo(name, &quot;no valid constructor&quot;);
              }
          }
<span class="line-modified">!         if (isRecord &amp;&amp; canonicalCtr == null) {</span>
<span class="line-modified">!             deserializeEx = new ExceptionInfo(name, &quot;record canonical constructor not found&quot;);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">+                 if (fields[i].getField() == null) {</span>
<span class="line-added">+                     defaultSerializeEx = new ExceptionInfo(</span>
<span class="line-added">+                         name, &quot;unmatched serializable field(s) declared&quot;);</span>
<span class="line-added">+                 }</span>
              }
          }
          initialized = true;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,11 ***</span>
                          &quot;cannot bind enum descriptor to a non-enum class&quot; :
                          &quot;cannot bind non-enum descriptor to an enum class&quot;);
              }
  
              if (model.serializable == osc.serializable &amp;&amp;
<span class="line-modified">!                     !cl.isArray() &amp;&amp;</span>
                      suid != osc.getSerialVersionUID()) {
                  throw new InvalidClassException(osc.name,
                          &quot;local class incompatible: &quot; +
                                  &quot;stream classdesc serialVersionUID = &quot; + suid +
                                  &quot;, local class serialVersionUID = &quot; +
<span class="line-new-header">--- 704,11 ---</span>
                          &quot;cannot bind enum descriptor to a non-enum class&quot; :
                          &quot;cannot bind non-enum descriptor to an enum class&quot;);
              }
  
              if (model.serializable == osc.serializable &amp;&amp;
<span class="line-modified">!                     !cl.isArray() &amp;&amp; !isRecord(cl) &amp;&amp;</span>
                      suid != osc.getSerialVersionUID()) {
                  throw new InvalidClassException(osc.name,
                          &quot;local class incompatible: &quot; +
                                  &quot;stream classdesc serialVersionUID = &quot; + suid +
                                  &quot;, local class serialVersionUID = &quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 710,10 ***</span>
<span class="line-new-header">--- 736,14 ---</span>
                  }
              }
          }
  
          this.cl = cl;
<span class="line-added">+         if (cl != null) {</span>
<span class="line-added">+             this.isRecord = isRecord(cl);</span>
<span class="line-added">+             this.canonicalCtr = osc.canonicalCtr;</span>
<span class="line-added">+         }</span>
          this.resolveEx = resolveEx;
          this.superDesc = superDesc;
          name = model.name;
          this.suid = suid;
          isProxy = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,16 ***</span>
<span class="line-new-header">--- 765,18 ---</span>
              readResolveMethod = localDesc.readResolveMethod;
              if (deserializeEx == null) {
                  deserializeEx = localDesc.deserializeEx;
              }
              domains = localDesc.domains;
<span class="line-added">+             assert isRecord(cl) ? localDesc.cons == null : true;</span>
              cons = localDesc.cons;
          }
  
          fieldRefl = getReflector(fields, localDesc);
          // reassign to matched fields so as to reflect local unshared settings
          fields = fieldRefl.getFields();
<span class="line-added">+ </span>
          initialized = true;
      }
  
      /**
       * Reads non-proxy class descriptor information from given input stream.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 962,10 ***</span>
<span class="line-new-header">--- 994,19 ---</span>
      boolean isEnum() {
          requireInitialized();
          return isEnum;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns true if class descriptor represents a record type, false</span>
<span class="line-added">+      * otherwise.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     boolean isRecord() {</span>
<span class="line-added">+         requireInitialized();</span>
<span class="line-added">+         return isRecord;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns true if represented class implements Externalizable, false
       * otherwise.
       */
      boolean isExternalizable() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1514,10 ***</span>
<span class="line-new-header">--- 1555,41 ---</span>
       */
      private static Constructor&lt;?&gt; getSerializableConstructor(Class&lt;?&gt; cl) {
          return reflFactory.newConstructorForSerialization(cl);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the canonical constructor for the given record class, or null if</span>
<span class="line-added">+      * the not found ( which should never happen for correctly generated record</span>
<span class="line-added">+      * classes ).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private static MethodHandle canonicalRecordCtr(Class&lt;?&gt; cls) {</span>
<span class="line-added">+         assert isRecord(cls) : &quot;Expected record, got: &quot; + cls;</span>
<span class="line-added">+         PrivilegedAction&lt;MethodHandle&gt; pa = () -&gt; {</span>
<span class="line-added">+             Class&lt;?&gt;[] paramTypes = Arrays.stream(cls.getRecordComponents())</span>
<span class="line-added">+                                           .map(RecordComponent::getType)</span>
<span class="line-added">+                                           .toArray(Class&lt;?&gt;[]::new);</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 Constructor&lt;?&gt; ctr = cls.getConstructor(paramTypes);</span>
<span class="line-added">+                 ctr.setAccessible(true);</span>
<span class="line-added">+                 return MethodHandles.lookup().unreflectConstructor(ctr);</span>
<span class="line-added">+             } catch (IllegalAccessException | NoSuchMethodException e) {</span>
<span class="line-added">+                 return null;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+         return AccessController.doPrivileged(pa);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the canonical constructor, if the local class equivalent of this</span>
<span class="line-added">+      * stream class descriptor is a record class, otherwise null.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     MethodHandle getRecordConstructor() {</span>
<span class="line-added">+         return canonicalCtr;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns non-static, non-abstract method with given signature provided it
       * is defined by or accessible (via inheritance) by the given class, or
       * null if no match found.  Access checks are disabled on the returned
       * method (if any).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1637,16 ***</span>
       * declared) serializable fields are invalid.
       */
      private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
          throws InvalidClassException
      {
          ObjectStreamField[] fields;
<span class="line-modified">!         if (Serializable.class.isAssignableFrom(cl) &amp;&amp;</span>
<span class="line-modified">!             !Externalizable.class.isAssignableFrom(cl) &amp;&amp;</span>
              !Proxy.isProxyClass(cl) &amp;&amp;
<span class="line-modified">!             !cl.isInterface())</span>
<span class="line-removed">-         {</span>
              if ((fields = getDeclaredSerialFields(cl)) == null) {
                  fields = getDefaultSerialFields(cl);
              }
              Arrays.sort(fields);
          } else {
<span class="line-new-header">--- 1709,20 ---</span>
       * declared) serializable fields are invalid.
       */
      private static ObjectStreamField[] getSerialFields(Class&lt;?&gt; cl)
          throws InvalidClassException
      {
<span class="line-added">+         if (!Serializable.class.isAssignableFrom(cl))</span>
<span class="line-added">+             return NO_FIELDS;</span>
<span class="line-added">+ </span>
          ObjectStreamField[] fields;
<span class="line-modified">!         if (isRecord(cl)) {</span>
<span class="line-modified">!             fields = getDefaultSerialFields(cl);</span>
<span class="line-added">+             Arrays.sort(fields);</span>
<span class="line-added">+         } else if (!Externalizable.class.isAssignableFrom(cl) &amp;&amp;</span>
              !Proxy.isProxyClass(cl) &amp;&amp;
<span class="line-modified">!                    !cl.isInterface()) {</span>
              if ((fields = getDeclaredSerialFields(cl)) == null) {
                  fields = getDefaultSerialFields(cl);
              }
              Arrays.sort(fields);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2434,6 ***</span>
<span class="line-new-header">--- 2510,117 ---</span>
              } else {
                  return false;
              }
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     /** Record specific support for retrieving and binding stream field values. */</span>
<span class="line-added">+     static final class RecordSupport {</span>
<span class="line-added">+ </span>
<span class="line-added">+         /** Binds the given stream field values to the given method handle. */</span>
<span class="line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+         static MethodHandle bindCtrValues(MethodHandle ctrMH,</span>
<span class="line-added">+                                           ObjectStreamClass desc,</span>
<span class="line-added">+                                           ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">+             RecordComponent[] recordComponents;</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 Class&lt;?&gt; cls = desc.forClass();</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;</span>
<span class="line-added">+                 recordComponents = AccessController.doPrivileged(pa);</span>
<span class="line-added">+             } catch (PrivilegedActionException e) {</span>
<span class="line-added">+                 throw new InternalError(e.getCause());</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             Object[] args = new Object[recordComponents.length];</span>
<span class="line-added">+             for (int i = 0; i &lt; recordComponents.length; i++) {</span>
<span class="line-added">+                 String name = recordComponents[i].getName();</span>
<span class="line-added">+                 Class&lt;?&gt; type= recordComponents[i].getType();</span>
<span class="line-added">+                 Object o = streamFieldValue(name, type, desc, fieldValues);</span>
<span class="line-added">+                 args[i] = o;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return MethodHandles.insertArguments(ctrMH, 0, args);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /** Returns the number of primitive fields for the given descriptor. */</span>
<span class="line-added">+         private static int numberPrimValues(ObjectStreamClass desc) {</span>
<span class="line-added">+             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">+             int primValueCount = 0;</span>
<span class="line-added">+             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">+                 if (fields[i].isPrimitive())</span>
<span class="line-added">+                     primValueCount++;</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     break;  // can be no more</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return primValueCount;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /** Returns the default value for the given type. */</span>
<span class="line-added">+         private static Object defaultValueFor(Class&lt;?&gt; pType) {</span>
<span class="line-added">+             if (pType == Integer.TYPE)</span>
<span class="line-added">+                 return 0;</span>
<span class="line-added">+             else if (pType == Byte.TYPE)</span>
<span class="line-added">+                 return (byte)0;</span>
<span class="line-added">+             else if (pType == Long.TYPE)</span>
<span class="line-added">+                 return 0L;</span>
<span class="line-added">+             else if (pType == Float.TYPE)</span>
<span class="line-added">+                 return 0.0f;</span>
<span class="line-added">+             else if (pType == Double.TYPE)</span>
<span class="line-added">+                 return 0.0d;</span>
<span class="line-added">+             else if (pType == Short.TYPE)</span>
<span class="line-added">+                 return (short)0;</span>
<span class="line-added">+             else if (pType == Character.TYPE)</span>
<span class="line-added">+                 return &#39;\u0000&#39;;</span>
<span class="line-added">+             else if (pType == Boolean.TYPE)</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Returns the stream field value for the given name. The default value</span>
<span class="line-added">+          * for the given type is returned if the field value is absent.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static Object streamFieldValue(String pName,</span>
<span class="line-added">+                                                Class&lt;?&gt; pType,</span>
<span class="line-added">+                                                ObjectStreamClass desc,</span>
<span class="line-added">+                                                ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-added">+             ObjectStreamField[] fields = desc.getFields();</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">+                 ObjectStreamField f = fields[i];</span>
<span class="line-added">+                 String fName = f.getName();</span>
<span class="line-added">+                 if (!fName.equals(pName))</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 Class&lt;?&gt; fType = f.getField().getType();</span>
<span class="line-added">+                 if (!pType.isAssignableFrom(fType))</span>
<span class="line-added">+                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (f.isPrimitive()) {</span>
<span class="line-added">+                     if (pType == Integer.TYPE)</span>
<span class="line-added">+                         return Bits.getInt(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Byte.TYPE)</span>
<span class="line-added">+                         return fieldValues.primValues[f.getOffset()];</span>
<span class="line-added">+                     else if (fType == Long.TYPE)</span>
<span class="line-added">+                         return Bits.getLong(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Float.TYPE)</span>
<span class="line-added">+                         return Bits.getFloat(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Double.TYPE)</span>
<span class="line-added">+                         return Bits.getDouble(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Short.TYPE)</span>
<span class="line-added">+                         return Bits.getShort(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Character.TYPE)</span>
<span class="line-added">+                         return Bits.getChar(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else if (fType == Boolean.TYPE)</span>
<span class="line-added">+                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());</span>
<span class="line-added">+                     else</span>
<span class="line-added">+                         throw new InternalError(&quot;Unexpected type: &quot; + fType);</span>
<span class="line-added">+                 } else { // reference</span>
<span class="line-added">+                     return fieldValues.objValues[i - numberPrimValues(desc)];</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return defaultValueFor(pType);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="ObjectOutputStream.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectStreamException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/SerializedLambda.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
 27 import java.io.Serializable;
 28 import java.io.InvalidObjectException;
 29 import java.io.ObjectStreamException;
 30 import java.lang.reflect.Method;
 31 import java.security.AccessController;
 32 import java.security.PrivilegedActionException;
 33 import java.security.PrivilegedExceptionAction;
 34 import java.util.Objects;
 35 
 36 /**
 37  * Serialized form of a lambda expression.  The properties of this class
 38  * represent the information that is present at the lambda factory site, including
 39  * static metafactory arguments such as the identity of the primary functional
 40  * interface method and the identity of the implementation method, as well as
 41  * dynamic metafactory arguments such as values captured from the lexical scope
 42  * at the time of lambda capture.
 43  *
 44  * &lt;p&gt;Implementors of serializable lambdas, such as compilers or language
 45  * runtime libraries, are expected to ensure that instances deserialize properly.
 46  * One means to do so is to ensure that the {@code writeReplace} method returns
 47  * an instance of {@code SerializedLambda}, rather than allowing default
 48  * serialization to proceed.
 49  *
 50  * &lt;p&gt;{@code SerializedLambda} has a {@code readResolve} method that looks for
 51  * a (possibly private) static method called
 52  * {@code $deserializeLambda$(SerializedLambda)} in the capturing class, invokes
 53  * that with itself as the first argument, and returns the result.  Lambda classes
 54  * implementing {@code $deserializeLambda$} are responsible for validating
 55  * that the properties of the {@code SerializedLambda} are consistent with a
 56  * lambda actually captured by that class.
 57  *
 58  * &lt;p&gt;The identity of a function object produced by deserializing the serialized
 59  * form is unpredictable, and therefore identity-sensitive operations (such as
 60  * reference equality, object locking, and {@code System.identityHashCode()} may
 61  * produce different results in different implementations, or even upon
 62  * different deserializations in the same implementation.
 63  *
 64  * @see LambdaMetafactory
 65  * @since 1.8
 66  */
 67 public final class SerializedLambda implements Serializable {
<a name="2" id="anc2"></a>
 68     private static final long serialVersionUID = 8025925345765570181L;
 69     private final Class&lt;?&gt; capturingClass;
 70     private final String functionalInterfaceClass;
 71     private final String functionalInterfaceMethodName;
 72     private final String functionalInterfaceMethodSignature;
 73     private final String implClass;
 74     private final String implMethodName;
 75     private final String implMethodSignature;
 76     private final int implMethodKind;
 77     private final String instantiatedMethodType;
<a name="3" id="anc3"></a>
 78     private final Object[] capturedArgs;
 79 
 80     /**
 81      * Create a {@code SerializedLambda} from the low-level information present
 82      * at the lambda factory site.
 83      *
 84      * @param capturingClass The class in which the lambda expression appears
 85      * @param functionalInterfaceClass Name, in slash-delimited form, of static
 86      *                                 type of the returned lambda object
 87      * @param functionalInterfaceMethodName Name of the functional interface
 88      *                                      method for the present at the
 89      *                                      lambda factory site
 90      * @param functionalInterfaceMethodSignature Signature of the functional
 91      *                                           interface method present at
 92      *                                           the lambda factory site
 93      * @param implMethodKind Method handle kind for the implementation method
 94      * @param implClass Name, in slash-delimited form, for the class holding
 95      *                  the implementation method
 96      * @param implMethodName Name of the implementation method
 97      * @param implMethodSignature Signature of the implementation method
 98      * @param instantiatedMethodType The signature of the primary functional
 99      *                               interface method after type variables
100      *                               are substituted with their instantiation
101      *                               from the capture site
102      * @param capturedArgs The dynamic arguments to the lambda factory site,
103      *                     which represent variables captured by
104      *                     the lambda
105      */
106     public SerializedLambda(Class&lt;?&gt; capturingClass,
107                             String functionalInterfaceClass,
108                             String functionalInterfaceMethodName,
109                             String functionalInterfaceMethodSignature,
110                             int implMethodKind,
111                             String implClass,
112                             String implMethodName,
113                             String implMethodSignature,
114                             String instantiatedMethodType,
115                             Object[] capturedArgs) {
116         this.capturingClass = capturingClass;
117         this.functionalInterfaceClass = functionalInterfaceClass;
118         this.functionalInterfaceMethodName = functionalInterfaceMethodName;
119         this.functionalInterfaceMethodSignature = functionalInterfaceMethodSignature;
120         this.implMethodKind = implMethodKind;
121         this.implClass = implClass;
122         this.implMethodName = implMethodName;
123         this.implMethodSignature = implMethodSignature;
124         this.instantiatedMethodType = instantiatedMethodType;
125         this.capturedArgs = Objects.requireNonNull(capturedArgs).clone();
126     }
127 
128     /**
129      * Get the name of the class that captured this lambda.
130      * @return the name of the class that captured this lambda
131      */
132     public String getCapturingClass() {
133         return capturingClass.getName().replace(&#39;.&#39;, &#39;/&#39;);
134     }
135 
136     /**
137      * Get the name of the invoked type to which this
138      * lambda has been converted
139      * @return the name of the functional interface class to which
140      * this lambda has been converted
141      */
142     public String getFunctionalInterfaceClass() {
143         return functionalInterfaceClass;
144     }
145 
146     /**
147      * Get the name of the primary method for the functional interface
148      * to which this lambda has been converted.
149      * @return the name of the primary methods of the functional interface
150      */
151     public String getFunctionalInterfaceMethodName() {
152         return functionalInterfaceMethodName;
153     }
154 
155     /**
156      * Get the signature of the primary method for the functional
157      * interface to which this lambda has been converted.
158      * @return the signature of the primary method of the functional
159      * interface
160      */
161     public String getFunctionalInterfaceMethodSignature() {
162         return functionalInterfaceMethodSignature;
163     }
164 
165     /**
166      * Get the name of the class containing the implementation
167      * method.
168      * @return the name of the class containing the implementation
169      * method
170      */
171     public String getImplClass() {
172         return implClass;
173     }
174 
175     /**
176      * Get the name of the implementation method.
177      * @return the name of the implementation method
178      */
179     public String getImplMethodName() {
180         return implMethodName;
181     }
182 
183     /**
184      * Get the signature of the implementation method.
185      * @return the signature of the implementation method
186      */
187     public String getImplMethodSignature() {
188         return implMethodSignature;
189     }
190 
191     /**
192      * Get the method handle kind (see {@link MethodHandleInfo}) of
193      * the implementation method.
194      * @return the method handle kind of the implementation method
195      */
196     public int getImplMethodKind() {
197         return implMethodKind;
198     }
199 
200     /**
201      * Get the signature of the primary functional interface method
202      * after type variables are substituted with their instantiation
203      * from the capture site.
204      * @return the signature of the primary functional interface method
205      * after type variable processing
206      */
207     public final String getInstantiatedMethodType() {
208         return instantiatedMethodType;
209     }
210 
211     /**
212      * Get the count of dynamic arguments to the lambda capture site.
213      * @return the count of dynamic arguments to the lambda capture site
214      */
215     public int getCapturedArgCount() {
216         return capturedArgs.length;
217     }
218 
219     /**
220      * Get a dynamic argument to the lambda capture site.
221      * @param i the argument to capture
222      * @return a dynamic argument to the lambda capture site
223      */
224     public Object getCapturedArg(int i) {
225         return capturedArgs[i];
226     }
227 
<a name="4" id="anc4"></a>
228     private Object readResolve() throws ObjectStreamException {
229         try {
230             Method deserialize = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
231                 @Override
232                 public Method run() throws Exception {
233                     Method m = capturingClass.getDeclaredMethod(&quot;$deserializeLambda$&quot;, SerializedLambda.class);
234                     m.setAccessible(true);
235                     return m;
236                 }
237             });
238 
239             return deserialize.invoke(null, this);
240         } catch (ReflectiveOperationException roe) {
241             ObjectStreamException ose = new InvalidObjectException(&quot;ReflectiveOperationException during deserialization&quot;);
242             ose.initCause(roe);
243             throw ose;
244         } catch (PrivilegedActionException e) {
245             Exception cause = e.getException();
246             if (cause instanceof RuntimeException)
247                 throw (RuntimeException) cause;
248             else
249                 throw new RuntimeException(&quot;Exception in SerializedLambda.readResolve&quot;, e);
250         }
251     }
252 
253     @Override
254     public String toString() {
255         String implKind=MethodHandleInfo.referenceKindToString(implMethodKind);
256         return String.format(&quot;SerializedLambda[%s=%s, %s=%s.%s:%s, &quot; +
257                              &quot;%s=%s %s.%s:%s, %s=%s, %s=%d]&quot;,
258                              &quot;capturingClass&quot;, capturingClass,
259                              &quot;functionalInterfaceMethod&quot;, functionalInterfaceClass,
260                                functionalInterfaceMethodName,
261                                functionalInterfaceMethodSignature,
262                              &quot;implementation&quot;,
263                                implKind,
264                                implClass, implMethodName, implMethodSignature,
265                              &quot;instantiatedMethodType&quot;, instantiatedMethodType,
266                              &quot;numCaptured&quot;, capturedArgs.length);
267     }
268 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
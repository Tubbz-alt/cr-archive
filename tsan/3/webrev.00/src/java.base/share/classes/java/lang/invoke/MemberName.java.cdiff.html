<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MemberName.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaMetafactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandle.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MemberName.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,16 ***</span>
   * allows invocation.  A MemberName is much lighter than a Method,
   * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
   * and those seven fields omit much of the information in Method.
   * @author jrose
   */
<span class="line-modified">! /*non-public*/ final class ResolvedMethodName {</span>
      //@Injected JVM_Method* vmtarget;
      //@Injected Class&lt;?&gt;    vmholder;
  };
  
<span class="line-modified">! /*non-public*/ final class MemberName implements Member, Cloneable {</span>
      private Class&lt;?&gt; clazz;       // class in which the member is defined
      private String   name;        // may be null if not yet materialized
      private Object   type;        // may be null if not yet materialized
      private int      flags;       // modifier bits; see reflect.Modifier
      private ResolvedMethodName method;    // cached resolved method information
<span class="line-new-header">--- 68,18 ---</span>
   * allows invocation.  A MemberName is much lighter than a Method,
   * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
   * and those seven fields omit much of the information in Method.
   * @author jrose
   */
<span class="line-modified">! /*non-public*/</span>
<span class="line-added">+ final class ResolvedMethodName {</span>
      //@Injected JVM_Method* vmtarget;
      //@Injected Class&lt;?&gt;    vmholder;
  };
  
<span class="line-modified">! /*non-public*/</span>
<span class="line-added">+ final class MemberName implements Member, Cloneable {</span>
      private Class&lt;?&gt; clazz;       // class in which the member is defined
      private String   name;        // may be null if not yet materialized
      private Object   type;        // may be null if not yet materialized
      private int      flags;       // modifier bits; see reflect.Modifier
      private ResolvedMethodName method;    // cached resolved method information
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,11 ***</span>
              return true;
          if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)
              return true;
          return false;
      }
<span class="line-modified">!     /*non-public*/ boolean referenceKindIsConsistentWith(int originalRefKind) {</span>
          int refKind = getReferenceKind();
          if (refKind == originalRefKind)  return true;
          switch (originalRefKind) {
          case REF_invokeInterface:
              // Looking up an interface method, can get (e.g.) Object.hashCode
<span class="line-new-header">--- 310,13 ---</span>
              return true;
          if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)
              return true;
          return false;
      }
<span class="line-modified">! </span>
<span class="line-added">+     /*non-public*/</span>
<span class="line-added">+     boolean referenceKindIsConsistentWith(int originalRefKind) {</span>
          int refKind = getReferenceKind();
          if (refKind == originalRefKind)  return true;
          switch (originalRefKind) {
          case REF_invokeInterface:
              // Looking up an interface method, can get (e.g.) Object.hashCode
</pre>
<hr />
<pre>
<span class="line-old-header">*** 519,11 ***</span>
  
      /** Utility method to query whether this member is accessible from a given lookup class. */
      public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
          int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
          return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
<span class="line-modified">!                                                lookupClass, mode);</span>
      }
  
      /**
       * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
       */
<span class="line-new-header">--- 523,11 ---</span>
  
      /** Utility method to query whether this member is accessible from a given lookup class. */
      public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
          int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
          return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
<span class="line-modified">!                                                lookupClass, null, mode);</span>
      }
  
      /**
       * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,17 ***</span>
          if (from != null)  {
              if (from == MethodHandles.publicLookup()) {
                  message += &quot;, from public Lookup&quot;;
              } else {
                  Module m;
                  if (from instanceof MethodHandles.Lookup) {
                      MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
                      m = lookup.lookupClass().getModule();
                  } else {
<span class="line-modified">!                     m = from.getClass().getModule();</span>
                  }
                  message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
              }
          }
          return new IllegalAccessException(message);
      }
      private String message() {
<span class="line-new-header">--- 932,25 ---</span>
          if (from != null)  {
              if (from == MethodHandles.publicLookup()) {
                  message += &quot;, from public Lookup&quot;;
              } else {
                  Module m;
<span class="line-added">+                 Class&lt;?&gt; plc;</span>
                  if (from instanceof MethodHandles.Lookup) {
                      MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
<span class="line-added">+                     from = lookup.lookupClass();</span>
                      m = lookup.lookupClass().getModule();
<span class="line-added">+                     plc = lookup.previousLookupClass();</span>
                  } else {
<span class="line-modified">!                     m = ((Class&lt;?&gt;)from).getModule();</span>
<span class="line-added">+                     plc = null;</span>
                  }
                  message += &quot;, from &quot; + from + &quot; (&quot; + m + &quot;)&quot;;
<span class="line-added">+                 if (plc != null) {</span>
<span class="line-added">+                     message += &quot;, previous lookup &quot; +</span>
<span class="line-added">+                         plc.getName() + &quot; (&quot; + plc.getModule() + &quot;)&quot;;</span>
<span class="line-added">+                 }</span>
              }
          }
          return new IllegalAccessException(message);
      }
      private String message() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 967,17 ***</span>
              ex.initCause((Throwable) resolution);
          return ex;
      }
  
      /** Actually making a query requires an access check. */
<span class="line-modified">!     /*non-public*/ static Factory getFactory() {</span>
          return Factory.INSTANCE;
      }
      /** A factory type for resolving member names with the help of the VM.
       *  TBD: Define access-safe public constructors for this factory.
       */
<span class="line-modified">!     /*non-public*/ static class Factory {</span>
          private Factory() { } // singleton pattern
          static Factory INSTANCE = new Factory();
  
          private static int ALLOWED_FLAGS = ALL_KINDS;
  
<span class="line-new-header">--- 979,19 ---</span>
              ex.initCause((Throwable) resolution);
          return ex;
      }
  
      /** Actually making a query requires an access check. */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Factory getFactory() {</span>
          return Factory.INSTANCE;
      }
      /** A factory type for resolving member names with the help of the VM.
       *  TBD: Define access-safe public constructors for this factory.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static class Factory {</span>
          private Factory() { } // singleton pattern
          static Factory INSTANCE = new Factory();
  
          private static int ALLOWED_FLAGS = ALL_KINDS;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,13 ***</span>
           *  Super types are searched (for inherited members) if {@code searchSupers} is true.
           *  Access checking is performed on behalf of the given {@code lookupClass}.
           *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
           *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
           */
<span class="line-modified">!         public</span>
<span class="line-modified">!         &lt;NoSuchMemberException extends ReflectiveOperationException&gt;</span>
<span class="line-removed">-         MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,</span>
                                   Class&lt;NoSuchMemberException&gt; nsmClass)
                  throws IllegalAccessException, NoSuchMemberException {
              MemberName result = resolve(refKind, m, lookupClass, false);
              if (result.isResolved())
                  return result;
<span class="line-new-header">--- 1102,12 ---</span>
           *  Super types are searched (for inherited members) if {@code searchSupers} is true.
           *  Access checking is performed on behalf of the given {@code lookupClass}.
           *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
           *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
           */
<span class="line-modified">!         public &lt;NoSuchMemberException extends ReflectiveOperationException&gt;</span>
<span class="line-modified">!                 MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,</span>
                                   Class&lt;NoSuchMemberException&gt; nsmClass)
                  throws IllegalAccessException, NoSuchMemberException {
              MemberName result = resolve(refKind, m, lookupClass, false);
              if (result.isResolved())
                  return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1106,12 ***</span>
           *  Super types are searched (for inherited members) if {@code searchSupers} is true.
           *  Access checking is performed on behalf of the given {@code lookupClass}.
           *  If lookup fails or access is not permitted, return null.
           *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
           */
<span class="line-modified">!         public</span>
<span class="line-removed">-         MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {</span>
              MemberName result = resolve(refKind, m, lookupClass, true);
              if (result != null &amp;&amp; result.isResolved())
                  return result;
              return null;
          }
<span class="line-new-header">--- 1119,11 ---</span>
           *  Super types are searched (for inherited members) if {@code searchSupers} is true.
           *  Access checking is performed on behalf of the given {@code lookupClass}.
           *  If lookup fails or access is not permitted, return null.
           *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
           */
<span class="line-modified">!         public MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {</span>
              MemberName result = resolve(refKind, m, lookupClass, true);
              if (result != null &amp;&amp; result.isResolved())
                  return result;
              return null;
          }
</pre>
<center><a href="LambdaMetafactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandle.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
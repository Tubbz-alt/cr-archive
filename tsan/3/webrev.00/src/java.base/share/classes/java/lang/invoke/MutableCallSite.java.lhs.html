<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MutableCallSite.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import java.util.Objects;
 29 import java.util.concurrent.atomic.AtomicInteger;
 30 
 31 /**
 32  * A {@code MutableCallSite} is a {@link CallSite} whose target variable
 33  * behaves like an ordinary field.
 34  * An {@code invokedynamic} instruction linked to a {@code MutableCallSite} delegates
 35  * all calls to the site&#39;s current target.
 36  * The {@linkplain CallSite#dynamicInvoker dynamic invoker} of a mutable call site
 37  * also delegates each call to the site&#39;s current target.
 38  * &lt;p&gt;
 39  * Here is an example of a mutable call site which introduces a
 40  * state variable into a method handle chain.
 41  * &lt;!-- JavaDocExamplesTest.testMutableCallSite --&gt;
 42  * &lt;blockquote&gt;&lt;pre&gt;{@code
 43 MutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));
 44 MethodHandle MH_name = name.dynamicInvoker();
 45 MethodType MT_str1 = MethodType.methodType(String.class);
 46 MethodHandle MH_upcase = MethodHandles.lookup()
 47     .findVirtual(String.class, &quot;toUpperCase&quot;, MT_str1);
 48 MethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);
 49 name.setTarget(MethodHandles.constant(String.class, &quot;Rocky&quot;));
 50 assertEquals(&quot;ROCKY&quot;, (String) worker1.invokeExact());
 51 name.setTarget(MethodHandles.constant(String.class, &quot;Fred&quot;));
 52 assertEquals(&quot;FRED&quot;, (String) worker1.invokeExact());
 53 // (mutation can be continued indefinitely)
 54  * }&lt;/pre&gt;&lt;/blockquote&gt;
 55  * &lt;p&gt;
 56  * The same call site may be used in several places at once.
 57  * &lt;blockquote&gt;&lt;pre&gt;{@code
 58 MethodType MT_str2 = MethodType.methodType(String.class, String.class);
 59 MethodHandle MH_cat = lookup().findVirtual(String.class,
 60   &quot;concat&quot;, methodType(String.class, String.class));
 61 MethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, &quot;, dear?&quot;);
 62 MethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);
 63 assertEquals(&quot;Fred, dear?&quot;, (String) worker2.invokeExact());
 64 name.setTarget(MethodHandles.constant(String.class, &quot;Wilma&quot;));
 65 assertEquals(&quot;WILMA&quot;, (String) worker1.invokeExact());
 66 assertEquals(&quot;Wilma, dear?&quot;, (String) worker2.invokeExact());
 67  * }&lt;/pre&gt;&lt;/blockquote&gt;
 68  * &lt;p&gt;
 69  * &lt;em&gt;Non-synchronization of target values:&lt;/em&gt;
 70  * A write to a mutable call site&#39;s target does not force other threads
 71  * to become aware of the updated value.  Threads which do not perform
 72  * suitable synchronization actions relative to the updated call site
 73  * may cache the old target value and delay their use of the new target
 74  * value indefinitely.
 75  * (This is a normal consequence of the Java Memory Model as applied
 76  * to object fields.)
 77  * &lt;p&gt;
 78  * The {@link #syncAll syncAll} operation provides a way to force threads
 79  * to accept a new target value, even if there is no other synchronization.
 80  * &lt;p&gt;
 81  * For target values which will be frequently updated, consider using
 82  * a {@linkplain VolatileCallSite volatile call site} instead.
 83  * @author John Rose, JSR 292 EG
 84  * @since 1.7
 85  */
 86 public class MutableCallSite extends CallSite {
 87     /**
 88      * Creates a blank call site object with the given method type.
 89      * The initial target is set to a method handle of the given type
 90      * which will throw an {@link IllegalStateException} if called.
 91      * &lt;p&gt;
 92      * The type of the call site is permanently set to the given type.
 93      * &lt;p&gt;
 94      * Before this {@code CallSite} object is returned from a bootstrap method,
 95      * or invoked in some other manner,
 96      * it is usually provided with a more useful target method,
 97      * via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.
 98      * @param type the method type that this call site will have
 99      * @throws NullPointerException if the proposed type is null
100      */
101     public MutableCallSite(MethodType type) {
102         super(type);
103     }
104 
105     /**
106      * Creates a call site object with an initial target method handle.
107      * The type of the call site is permanently set to the initial target&#39;s type.
108      * @param target the method handle that will be the initial target of the call site
109      * @throws NullPointerException if the proposed target is null
110      */
111     public MutableCallSite(MethodHandle target) {
112         super(target);
113     }
114 
115     /**
116      * Returns the target method of the call site, which behaves
117      * like a normal field of the {@code MutableCallSite}.
118      * &lt;p&gt;
119      * The interactions of {@code getTarget} with memory are the same
120      * as of a read from an ordinary variable, such as an array element or a
121      * non-volatile, non-final field.
122      * &lt;p&gt;
123      * In particular, the current thread may choose to reuse the result
124      * of a previous read of the target from memory, and may fail to see
125      * a recent update to the target by another thread.
126      *
127      * @return the linkage state of this call site, a method handle which can change over time
128      * @see #setTarget
129      */
130     @Override public final MethodHandle getTarget() {
131         return target;
132     }
133 
134     /**
135      * Updates the target method of this call site, as a normal variable.
136      * The type of the new target must agree with the type of the old target.
137      * &lt;p&gt;
138      * The interactions with memory are the same
139      * as of a write to an ordinary variable, such as an array element or a
140      * non-volatile, non-final field.
141      * &lt;p&gt;
142      * In particular, unrelated threads may fail to see the updated target
143      * until they perform a read from memory.
144      * Stronger guarantees can be created by putting appropriate operations
145      * into the bootstrap method and/or the target methods used
146      * at any given call site.
147      *
148      * @param newTarget the new target
149      * @throws NullPointerException if the proposed new target is null
150      * @throws WrongMethodTypeException if the proposed new target
151      *         has a method type that differs from the previous target
152      * @see #getTarget
153      */
154     @Override public void setTarget(MethodHandle newTarget) {
<a name="2" id="anc2"></a><span class="line-removed">155         checkTargetChange(this.target, newTarget);</span>
156         setTargetNormal(newTarget);
157     }
158 
159     /**
160      * {@inheritDoc}
161      */
162     @Override
163     public final MethodHandle dynamicInvoker() {
164         return makeDynamicInvoker();
165     }
166 
167     /**
168      * Performs a synchronization operation on each call site in the given array,
169      * forcing all other threads to throw away any cached values previously
170      * loaded from the target of any of the call sites.
171      * &lt;p&gt;
172      * This operation does not reverse any calls that have already started
173      * on an old target value.
174      * (Java supports {@linkplain java.lang.Object#wait() forward time travel} only.)
175      * &lt;p&gt;
176      * The overall effect is to force all future readers of each call site&#39;s target
177      * to accept the most recently stored value.
178      * (&quot;Most recently&quot; is reckoned relative to the {@code syncAll} itself.)
179      * Conversely, the {@code syncAll} call may block until all readers have
180      * (somehow) decached all previous versions of each call site&#39;s target.
181      * &lt;p&gt;
182      * To avoid race conditions, calls to {@code setTarget} and {@code syncAll}
183      * should generally be performed under some sort of mutual exclusion.
184      * Note that reader threads may observe an updated target as early
185      * as the {@code setTarget} call that install the value
186      * (and before the {@code syncAll} that confirms the value).
187      * On the other hand, reader threads may observe previous versions of
188      * the target until the {@code syncAll} call returns
189      * (and after the {@code setTarget} that attempts to convey the updated version).
190      * &lt;p&gt;
191      * This operation is likely to be expensive and should be used sparingly.
192      * If possible, it should be buffered for batch processing on sets of call sites.
193      * &lt;p&gt;
194      * If {@code sites} contains a null element,
195      * a {@code NullPointerException} will be raised.
196      * In this case, some non-null elements in the array may be
197      * processed before the method returns abnormally.
198      * Which elements these are (if any) is implementation-dependent.
199      *
<a name="3" id="anc3"></a><span class="line-modified">200      * &lt;h1&gt;Java Memory Model details&lt;/h1&gt;</span>
201      * In terms of the Java Memory Model, this operation performs a synchronization
202      * action which is comparable in effect to the writing of a volatile variable
203      * by the current thread, and an eventual volatile read by every other thread
204      * that may access one of the affected call sites.
205      * &lt;p&gt;
206      * The following effects are apparent, for each individual call site {@code S}:
207      * &lt;ul&gt;
208      * &lt;li&gt;A new volatile variable {@code V} is created, and written by the current thread.
209      *     As defined by the JMM, this write is a global synchronization event.
210      * &lt;li&gt;As is normal with thread-local ordering of write events,
211      *     every action already performed by the current thread is
212      *     taken to happen before the volatile write to {@code V}.
213      *     (In some implementations, this means that the current thread
214      *     performs a global release operation.)
215      * &lt;li&gt;Specifically, the write to the current target of {@code S} is
216      *     taken to happen before the volatile write to {@code V}.
217      * &lt;li&gt;The volatile write to {@code V} is placed
218      *     (in an implementation specific manner)
219      *     in the global synchronization order.
220      * &lt;li&gt;Consider an arbitrary thread {@code T} (other than the current thread).
221      *     If {@code T} executes a synchronization action {@code A}
222      *     after the volatile write to {@code V} (in the global synchronization order),
223      *     it is therefore required to see either the current target
224      *     of {@code S}, or a later write to that target,
225      *     if it executes a read on the target of {@code S}.
226      *     (This constraint is called &quot;synchronization-order consistency&quot;.)
227      * &lt;li&gt;The JMM specifically allows optimizing compilers to elide
228      *     reads or writes of variables that are known to be useless.
229      *     Such elided reads and writes have no effect on the happens-before
230      *     relation.  Regardless of this fact, the volatile {@code V}
231      *     will not be elided, even though its written value is
232      *     indeterminate and its read value is not used.
233      * &lt;/ul&gt;
234      * Because of the last point, the implementation behaves as if a
235      * volatile read of {@code V} were performed by {@code T}
236      * immediately after its action {@code A}.  In the local ordering
237      * of actions in {@code T}, this read happens before any future
238      * read of the target of {@code S}.  It is as if the
239      * implementation arbitrarily picked a read of {@code S}&#39;s target
240      * by {@code T}, and forced a read of {@code V} to precede it,
241      * thereby ensuring communication of the new target value.
242      * &lt;p&gt;
243      * As long as the constraints of the Java Memory Model are obeyed,
244      * implementations may delay the completion of a {@code syncAll}
245      * operation while other threads ({@code T} above) continue to
246      * use previous values of {@code S}&#39;s target.
247      * However, implementations are (as always) encouraged to avoid
248      * livelock, and to eventually require all threads to take account
249      * of the updated target.
250      *
251      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
252      * &lt;em&gt;Discussion:&lt;/em&gt;
253      * For performance reasons, {@code syncAll} is not a virtual method
254      * on a single call site, but rather applies to a set of call sites.
255      * Some implementations may incur a large fixed overhead cost
256      * for processing one or more synchronization operations,
257      * but a small incremental cost for each additional call site.
258      * In any case, this operation is likely to be costly, since
259      * other threads may have to be somehow interrupted
260      * in order to make them notice the updated target value.
261      * However, it may be observed that a single call to synchronize
262      * several sites has the same formal effect as many calls,
263      * each on just one of the sites.
264      *
265      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
266      * &lt;em&gt;Implementation Note:&lt;/em&gt;
267      * Simple implementations of {@code MutableCallSite} may use
268      * a volatile variable for the target of a mutable call site.
269      * In such an implementation, the {@code syncAll} method can be a no-op,
270      * and yet it will conform to the JMM behavior documented above.
271      *
272      * @param sites an array of call sites to be synchronized
273      * @throws NullPointerException if the {@code sites} array reference is null
274      *                              or the array contains a null
275      */
276     public static void syncAll(MutableCallSite[] sites) {
277         if (sites.length == 0)  return;
278         STORE_BARRIER.lazySet(0);
279         for (MutableCallSite site : sites) {
280             Objects.requireNonNull(site); // trigger NPE on first null
281         }
282         // FIXME: NYI
283     }
284     private static final AtomicInteger STORE_BARRIER = new AtomicInteger();
285 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
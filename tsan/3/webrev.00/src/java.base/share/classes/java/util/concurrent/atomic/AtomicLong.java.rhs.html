<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent.atomic;
 37 
 38 import java.lang.invoke.VarHandle;
 39 import java.util.function.LongBinaryOperator;
 40 import java.util.function.LongUnaryOperator;
<a name="1" id="anc1"></a><span class="line-added"> 41 import jdk.internal.misc.Unsafe;</span>
 42 
 43 /**
 44  * A {@code long} value that may be updated atomically.  See the
 45  * {@link VarHandle} specification for descriptions of the properties
 46  * of atomic accesses. An {@code AtomicLong} is used in applications
 47  * such as atomically incremented sequence numbers, and cannot be used
 48  * as a replacement for a {@link java.lang.Long}. However, this class
 49  * does extend {@code Number} to allow uniform access by tools and
 50  * utilities that deal with numerically-based classes.
 51  *
 52  * @since 1.5
 53  * @author Doug Lea
 54  */
 55 public class AtomicLong extends Number implements java.io.Serializable {
 56     private static final long serialVersionUID = 1927816293512124184L;
 57 
 58     /**
 59      * Records whether the underlying JVM supports lockless
 60      * compareAndSet for longs. While the intrinsic compareAndSetLong
 61      * method works in either case, some constructions should be
 62      * handled at Java level to avoid locking user-visible locks.
 63      */
 64     static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();
 65 
 66     /**
 67      * Returns whether underlying JVM supports lockless CompareAndSet
 68      * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.
 69      */
 70     private static native boolean VMSupportsCS8();
 71 
 72     /*
 73      * This class intended to be implemented using VarHandles, but there
 74      * are unresolved cyclic startup dependencies.
 75      */
<a name="2" id="anc2"></a><span class="line-modified"> 76     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified"> 77     private static final long VALUE</span>
<span class="line-added"> 78         = U.objectFieldOffset(AtomicLong.class, &quot;value&quot;);</span>
 79 
 80     private volatile long value;
 81 
 82     /**
 83      * Creates a new AtomicLong with the given initial value.
 84      *
 85      * @param initialValue the initial value
 86      */
 87     public AtomicLong(long initialValue) {
 88         value = initialValue;
 89     }
 90 
 91     /**
 92      * Creates a new AtomicLong with initial value {@code 0}.
 93      */
 94     public AtomicLong() {
 95     }
 96 
 97     /**
 98      * Returns the current value,
 99      * with memory effects as specified by {@link VarHandle#getVolatile}.
100      *
101      * @return the current value
102      */
103     public final long get() {
104         return value;
105     }
106 
107     /**
108      * Sets the value to {@code newValue},
109      * with memory effects as specified by {@link VarHandle#setVolatile}.
110      *
111      * @param newValue the new value
112      */
113     public final void set(long newValue) {
114         // See JDK-8180620: Clarify VarHandle mixed-access subtleties
115         U.putLongVolatile(this, VALUE, newValue);
116     }
117 
118     /**
119      * Sets the value to {@code newValue},
120      * with memory effects as specified by {@link VarHandle#setRelease}.
121      *
122      * @param newValue the new value
123      * @since 1.6
124      */
125     public final void lazySet(long newValue) {
126         U.putLongRelease(this, VALUE, newValue);
127     }
128 
129     /**
130      * Atomically sets the value to {@code newValue} and returns the old value,
131      * with memory effects as specified by {@link VarHandle#getAndSet}.
132      *
133      * @param newValue the new value
134      * @return the previous value
135      */
136     public final long getAndSet(long newValue) {
137         return U.getAndSetLong(this, VALUE, newValue);
138     }
139 
140     /**
141      * Atomically sets the value to {@code newValue}
142      * if the current value {@code == expectedValue},
143      * with memory effects as specified by {@link VarHandle#compareAndSet}.
144      *
145      * @param expectedValue the expected value
146      * @param newValue the new value
147      * @return {@code true} if successful. False return indicates that
148      * the actual value was not equal to the expected value.
149      */
150     public final boolean compareAndSet(long expectedValue, long newValue) {
151         return U.compareAndSetLong(this, VALUE, expectedValue, newValue);
152     }
153 
154     /**
155      * Possibly atomically sets the value to {@code newValue}
156      * if the current value {@code == expectedValue},
157      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
158      *
159      * @deprecated This method has plain memory effects but the method
160      * name implies volatile memory effects (see methods such as
161      * {@link #compareAndExchange} and {@link #compareAndSet}).  To avoid
162      * confusion over plain or volatile memory effects it is recommended that
163      * the method {@link #weakCompareAndSetPlain} be used instead.
164      *
165      * @param expectedValue the expected value
166      * @param newValue the new value
167      * @return {@code true} if successful
168      * @see #weakCompareAndSetPlain
169      */
170     @Deprecated(since=&quot;9&quot;)
171     public final boolean weakCompareAndSet(long expectedValue, long newValue) {
172         return U.weakCompareAndSetLongPlain(this, VALUE, expectedValue, newValue);
173     }
174 
175     /**
176      * Possibly atomically sets the value to {@code newValue}
177      * if the current value {@code == expectedValue},
178      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
179      *
180      * @param expectedValue the expected value
181      * @param newValue the new value
182      * @return {@code true} if successful
183      * @since 9
184      */
185     public final boolean weakCompareAndSetPlain(long expectedValue, long newValue) {
186         return U.weakCompareAndSetLongPlain(this, VALUE, expectedValue, newValue);
187     }
188 
189     /**
190      * Atomically increments the current value,
191      * with memory effects as specified by {@link VarHandle#getAndAdd}.
192      *
193      * &lt;p&gt;Equivalent to {@code getAndAdd(1)}.
194      *
195      * @return the previous value
196      */
197     public final long getAndIncrement() {
198         return U.getAndAddLong(this, VALUE, 1L);
199     }
200 
201     /**
202      * Atomically decrements the current value,
203      * with memory effects as specified by {@link VarHandle#getAndAdd}.
204      *
205      * &lt;p&gt;Equivalent to {@code getAndAdd(-1)}.
206      *
207      * @return the previous value
208      */
209     public final long getAndDecrement() {
210         return U.getAndAddLong(this, VALUE, -1L);
211     }
212 
213     /**
214      * Atomically adds the given value to the current value,
215      * with memory effects as specified by {@link VarHandle#getAndAdd}.
216      *
217      * @param delta the value to add
218      * @return the previous value
219      */
220     public final long getAndAdd(long delta) {
221         return U.getAndAddLong(this, VALUE, delta);
222     }
223 
224     /**
225      * Atomically increments the current value,
226      * with memory effects as specified by {@link VarHandle#getAndAdd}.
227      *
228      * &lt;p&gt;Equivalent to {@code addAndGet(1)}.
229      *
230      * @return the updated value
231      */
232     public final long incrementAndGet() {
233         return U.getAndAddLong(this, VALUE, 1L) + 1L;
234     }
235 
236     /**
237      * Atomically decrements the current value,
238      * with memory effects as specified by {@link VarHandle#getAndAdd}.
239      *
240      * &lt;p&gt;Equivalent to {@code addAndGet(-1)}.
241      *
242      * @return the updated value
243      */
244     public final long decrementAndGet() {
245         return U.getAndAddLong(this, VALUE, -1L) - 1L;
246     }
247 
248     /**
249      * Atomically adds the given value to the current value,
250      * with memory effects as specified by {@link VarHandle#getAndAdd}.
251      *
252      * @param delta the value to add
253      * @return the updated value
254      */
255     public final long addAndGet(long delta) {
256         return U.getAndAddLong(this, VALUE, delta) + delta;
257     }
258 
259     /**
260      * Atomically updates (with memory effects as specified by {@link
261      * VarHandle#compareAndSet}) the current value with the results of
262      * applying the given function, returning the previous value. The
263      * function should be side-effect-free, since it may be re-applied
264      * when attempted updates fail due to contention among threads.
265      *
266      * @param updateFunction a side-effect-free function
267      * @return the previous value
268      * @since 1.8
269      */
270     public final long getAndUpdate(LongUnaryOperator updateFunction) {
271         long prev = get(), next = 0L;
272         for (boolean haveNext = false;;) {
273             if (!haveNext)
274                 next = updateFunction.applyAsLong(prev);
275             if (weakCompareAndSetVolatile(prev, next))
276                 return prev;
277             haveNext = (prev == (prev = get()));
278         }
279     }
280 
281     /**
282      * Atomically updates (with memory effects as specified by {@link
283      * VarHandle#compareAndSet}) the current value with the results of
284      * applying the given function, returning the updated value. The
285      * function should be side-effect-free, since it may be re-applied
286      * when attempted updates fail due to contention among threads.
287      *
288      * @param updateFunction a side-effect-free function
289      * @return the updated value
290      * @since 1.8
291      */
292     public final long updateAndGet(LongUnaryOperator updateFunction) {
293         long prev = get(), next = 0L;
294         for (boolean haveNext = false;;) {
295             if (!haveNext)
296                 next = updateFunction.applyAsLong(prev);
297             if (weakCompareAndSetVolatile(prev, next))
298                 return next;
299             haveNext = (prev == (prev = get()));
300         }
301     }
302 
303     /**
304      * Atomically updates (with memory effects as specified by {@link
305      * VarHandle#compareAndSet}) the current value with the results of
306      * applying the given function to the current and given values,
307      * returning the previous value. The function should be
308      * side-effect-free, since it may be re-applied when attempted
309      * updates fail due to contention among threads.  The function is
310      * applied with the current value as its first argument, and the
311      * given update as the second argument.
312      *
313      * @param x the update value
314      * @param accumulatorFunction a side-effect-free function of two arguments
315      * @return the previous value
316      * @since 1.8
317      */
318     public final long getAndAccumulate(long x,
319                                        LongBinaryOperator accumulatorFunction) {
320         long prev = get(), next = 0L;
321         for (boolean haveNext = false;;) {
322             if (!haveNext)
323                 next = accumulatorFunction.applyAsLong(prev, x);
324             if (weakCompareAndSetVolatile(prev, next))
325                 return prev;
326             haveNext = (prev == (prev = get()));
327         }
328     }
329 
330     /**
331      * Atomically updates (with memory effects as specified by {@link
332      * VarHandle#compareAndSet}) the current value with the results of
333      * applying the given function to the current and given values,
334      * returning the updated value. The function should be
335      * side-effect-free, since it may be re-applied when attempted
336      * updates fail due to contention among threads.  The function is
337      * applied with the current value as its first argument, and the
338      * given update as the second argument.
339      *
340      * @param x the update value
341      * @param accumulatorFunction a side-effect-free function of two arguments
342      * @return the updated value
343      * @since 1.8
344      */
345     public final long accumulateAndGet(long x,
346                                        LongBinaryOperator accumulatorFunction) {
347         long prev = get(), next = 0L;
348         for (boolean haveNext = false;;) {
349             if (!haveNext)
350                 next = accumulatorFunction.applyAsLong(prev, x);
351             if (weakCompareAndSetVolatile(prev, next))
352                 return next;
353             haveNext = (prev == (prev = get()));
354         }
355     }
356 
357     /**
358      * Returns the String representation of the current value.
359      * @return the String representation of the current value
360      */
361     public String toString() {
362         return Long.toString(get());
363     }
364 
365     /**
366      * Returns the current value of this {@code AtomicLong} as an {@code int}
367      * after a narrowing primitive conversion,
368      * with memory effects as specified by {@link VarHandle#getVolatile}.
<a name="3" id="anc3"></a><span class="line-modified">369      * @jls 5.1.3 Narrowing Primitive Conversion</span>
370      */
371     public int intValue() {
372         return (int)get();
373     }
374 
375     /**
376      * Returns the current value of this {@code AtomicLong} as a {@code long},
377      * with memory effects as specified by {@link VarHandle#getVolatile}.
378      * Equivalent to {@link #get()}.
379      */
380     public long longValue() {
381         return get();
382     }
383 
384     /**
385      * Returns the current value of this {@code AtomicLong} as a {@code float}
386      * after a widening primitive conversion,
387      * with memory effects as specified by {@link VarHandle#getVolatile}.
<a name="4" id="anc4"></a><span class="line-modified">388      * @jls 5.1.2 Widening Primitive Conversion</span>
389      */
390     public float floatValue() {
391         return (float)get();
392     }
393 
394     /**
395      * Returns the current value of this {@code AtomicLong} as a {@code double}
396      * after a widening primitive conversion,
397      * with memory effects as specified by {@link VarHandle#getVolatile}.
<a name="5" id="anc5"></a><span class="line-modified">398      * @jls 5.1.2 Widening Primitive Conversion</span>
399      */
400     public double doubleValue() {
401         return (double)get();
402     }
403 
404     // jdk9
405 
406     /**
407      * Returns the current value, with memory semantics of reading as if the
408      * variable was declared non-{@code volatile}.
409      *
410      * @return the value
411      * @since 9
412      */
413     public final long getPlain() {
414         return U.getLong(this, VALUE);
415     }
416 
417     /**
418      * Sets the value to {@code newValue}, with memory semantics
419      * of setting as if the variable was declared non-{@code volatile}
420      * and non-{@code final}.
421      *
422      * @param newValue the new value
423      * @since 9
424      */
425     public final void setPlain(long newValue) {
426         U.putLong(this, VALUE, newValue);
427     }
428 
429     /**
430      * Returns the current value,
431      * with memory effects as specified by {@link VarHandle#getOpaque}.
432      *
433      * @return the value
434      * @since 9
435      */
436     public final long getOpaque() {
437         return U.getLongOpaque(this, VALUE);
438     }
439 
440     /**
441      * Sets the value to {@code newValue},
442      * with memory effects as specified by {@link VarHandle#setOpaque}.
443      *
444      * @param newValue the new value
445      * @since 9
446      */
447     public final void setOpaque(long newValue) {
448         U.putLongOpaque(this, VALUE, newValue);
449     }
450 
451     /**
452      * Returns the current value,
453      * with memory effects as specified by {@link VarHandle#getAcquire}.
454      *
455      * @return the value
456      * @since 9
457      */
458     public final long getAcquire() {
459         return U.getLongAcquire(this, VALUE);
460     }
461 
462     /**
463      * Sets the value to {@code newValue},
464      * with memory effects as specified by {@link VarHandle#setRelease}.
465      *
466      * @param newValue the new value
467      * @since 9
468      */
469     public final void setRelease(long newValue) {
470         U.putLongRelease(this, VALUE, newValue);
471     }
472 
473     /**
474      * Atomically sets the value to {@code newValue} if the current value,
475      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
476      * with memory effects as specified by
477      * {@link VarHandle#compareAndExchange}.
478      *
479      * @param expectedValue the expected value
480      * @param newValue the new value
481      * @return the witness value, which will be the same as the
482      * expected value if successful
483      * @since 9
484      */
485     public final long compareAndExchange(long expectedValue, long newValue) {
486         return U.compareAndExchangeLong(this, VALUE, expectedValue, newValue);
487     }
488 
489     /**
490      * Atomically sets the value to {@code newValue} if the current value,
491      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
492      * with memory effects as specified by
493      * {@link VarHandle#compareAndExchangeAcquire}.
494      *
495      * @param expectedValue the expected value
496      * @param newValue the new value
497      * @return the witness value, which will be the same as the
498      * expected value if successful
499      * @since 9
500      */
501     public final long compareAndExchangeAcquire(long expectedValue, long newValue) {
502         return U.compareAndExchangeLongAcquire(this, VALUE, expectedValue, newValue);
503     }
504 
505     /**
506      * Atomically sets the value to {@code newValue} if the current value,
507      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
508      * with memory effects as specified by
509      * {@link VarHandle#compareAndExchangeRelease}.
510      *
511      * @param expectedValue the expected value
512      * @param newValue the new value
513      * @return the witness value, which will be the same as the
514      * expected value if successful
515      * @since 9
516      */
517     public final long compareAndExchangeRelease(long expectedValue, long newValue) {
518         return U.compareAndExchangeLongRelease(this, VALUE, expectedValue, newValue);
519     }
520 
521     /**
522      * Possibly atomically sets the value to {@code newValue}
523      * if the current value {@code == expectedValue},
524      * with memory effects as specified by
525      * {@link VarHandle#weakCompareAndSet}.
526      *
527      * @param expectedValue the expected value
528      * @param newValue the new value
529      * @return {@code true} if successful
530      * @since 9
531      */
532     public final boolean weakCompareAndSetVolatile(long expectedValue, long newValue) {
533         return U.weakCompareAndSetLong(this, VALUE, expectedValue, newValue);
534     }
535 
536     /**
537      * Possibly atomically sets the value to {@code newValue}
538      * if the current value {@code == expectedValue},
539      * with memory effects as specified by
540      * {@link VarHandle#weakCompareAndSetAcquire}.
541      *
542      * @param expectedValue the expected value
543      * @param newValue the new value
544      * @return {@code true} if successful
545      * @since 9
546      */
547     public final boolean weakCompareAndSetAcquire(long expectedValue, long newValue) {
548         return U.weakCompareAndSetLongAcquire(this, VALUE, expectedValue, newValue);
549     }
550 
551     /**
552      * Possibly atomically sets the value to {@code newValue}
553      * if the current value {@code == expectedValue},
554      * with memory effects as specified by
555      * {@link VarHandle#weakCompareAndSetRelease}.
556      *
557      * @param expectedValue the expected value
558      * @param newValue the new value
559      * @return {@code true} if successful
560      * @since 9
561      */
562     public final boolean weakCompareAndSetRelease(long expectedValue, long newValue) {
563         return U.weakCompareAndSetLongRelease(this, VALUE, expectedValue, newValue);
564     }
565 
566 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
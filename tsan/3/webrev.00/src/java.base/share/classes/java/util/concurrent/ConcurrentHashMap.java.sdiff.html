<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompletableFuture.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 368      * iterators in the same way.
 369      *
 370      * The table is resized when occupancy exceeds a percentage
 371      * threshold (nominally, 0.75, but see below).  Any thread
 372      * noticing an overfull bin may assist in resizing after the
 373      * initiating thread allocates and sets up the replacement array.
 374      * However, rather than stalling, these other threads may proceed
 375      * with insertions etc.  The use of TreeBins shields us from the
 376      * worst case effects of overfilling while resizes are in
 377      * progress.  Resizing proceeds by transferring bins, one by one,
 378      * from the table to the next table. However, threads claim small
 379      * blocks of indices to transfer (via field transferIndex) before
 380      * doing so, reducing contention.  A generation stamp in field
 381      * sizeCtl ensures that resizings do not overlap. Because we are
 382      * using power-of-two expansion, the elements from each bin must
 383      * either stay at same index, or move with a power of two
 384      * offset. We eliminate unnecessary node creation by catching
 385      * cases where old nodes can be reused because their next fields
 386      * won&#39;t change.  On average, only about one-sixth of them need
 387      * cloning when a table doubles. The nodes they replace will be
<span class="line-modified"> 388      * garbage collectable as soon as they are no longer referenced by</span>
 389      * any reader thread that may be in the midst of concurrently
 390      * traversing table.  Upon transfer, the old table bin contains
 391      * only a special forwarding node (with hash field &quot;MOVED&quot;) that
 392      * contains the next table as its key. On encountering a
 393      * forwarding node, access and update operations restart, using
 394      * the new table.
 395      *
 396      * Each bin transfer requires its bin lock, which can stall
 397      * waiting for locks while resizing. However, because other
 398      * threads can join in and help resize rather than contend for
 399      * locks, average aggregate waits become shorter as resizing
 400      * progresses.  The transfer operation must also ensure that all
 401      * accessible bins in both the old and new table are usable by any
 402      * traversal.  This is arranged in part by proceeding from the
 403      * last bin (table.length - 1) up towards the first.  Upon seeing
 404      * a forwarding node, traversals (see class Traverser) arrange to
 405      * move to the new table without revisiting nodes.  To ensure that
 406      * no intervening nodes are skipped even when moved out of order,
 407      * a stack (see class TableStack) is created on first encounter of
 408      * a forwarding node during a traversal, to maintain its place if
</pre>
<hr />
<pre>
1650     boolean removeValueIf(Predicate&lt;? super V&gt; function) {
1651         if (function == null) throw new NullPointerException();
1652         Node&lt;K,V&gt;[] t;
1653         boolean removed = false;
1654         if ((t = table) != null) {
1655             Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length);
1656             for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) {
1657                 K k = p.key;
1658                 V v = p.val;
1659                 if (function.test(v) &amp;&amp; replaceNode(k, null, v) != null)
1660                     removed = true;
1661             }
1662         }
1663         return removed;
1664     }
1665 
1666     /**
1667      * If the specified key is not already associated with a value,
1668      * attempts to compute its value using the given mapping function
1669      * and enters it into this map unless {@code null}.  The entire
<span class="line-modified">1670      * method invocation is performed atomically, so the function is</span>
<span class="line-modified">1671      * applied at most once per key.  Some attempted update operations</span>
<span class="line-modified">1672      * on this map by other threads may be blocked while computation</span>
<span class="line-modified">1673      * is in progress, so the computation should be short and simple,</span>
<span class="line-modified">1674      * and must not attempt to update any other mappings of this map.</span>



1675      *
1676      * @param key key with which the specified value is to be associated
1677      * @param mappingFunction the function to compute a value
1678      * @return the current (existing or computed) value associated with
1679      *         the specified key, or null if the computed value is null
1680      * @throws NullPointerException if the specified key or mappingFunction
1681      *         is null
1682      * @throws IllegalStateException if the computation detectably
1683      *         attempts a recursive update to this map that would
1684      *         otherwise never complete
1685      * @throws RuntimeException or Error if the mappingFunction does so,
1686      *         in which case the mapping is left unestablished
1687      */
1688     public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {
1689         if (key == null || mappingFunction == null)
1690             throw new NullPointerException();
1691         int h = spread(key.hashCode());
1692         V val = null;
1693         int binCount = 0;
1694         for (Node&lt;K,V&gt;[] tab = table;;) {
</pre>
<hr />
<pre>
1761                     }
1762                 }
1763                 if (binCount != 0) {
1764                     if (binCount &gt;= TREEIFY_THRESHOLD)
1765                         treeifyBin(tab, i);
1766                     if (!added)
1767                         return val;
1768                     break;
1769                 }
1770             }
1771         }
1772         if (val != null)
1773             addCount(1L, binCount);
1774         return val;
1775     }
1776 
1777     /**
1778      * If the value for the specified key is present, attempts to
1779      * compute a new mapping given the key and its current mapped
1780      * value.  The entire method invocation is performed atomically.
<span class="line-modified">1781      * Some attempted update operations on this map by other threads</span>
<span class="line-modified">1782      * may be blocked while computation is in progress, so the</span>
<span class="line-modified">1783      * computation should be short and simple, and must not attempt to</span>
<span class="line-modified">1784      * update any other mappings of this map.</span>



1785      *
1786      * @param key key with which a value may be associated
1787      * @param remappingFunction the function to compute a value
1788      * @return the new value associated with the specified key, or null if none
1789      * @throws NullPointerException if the specified key or remappingFunction
1790      *         is null
1791      * @throws IllegalStateException if the computation detectably
1792      *         attempts a recursive update to this map that would
1793      *         otherwise never complete
1794      * @throws RuntimeException or Error if the remappingFunction does so,
1795      *         in which case the mapping is unchanged
1796      */
1797     public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1798         if (key == null || remappingFunction == null)
1799             throw new NullPointerException();
1800         int h = spread(key.hashCode());
1801         V val = null;
1802         int delta = 0;
1803         int binCount = 0;
1804         for (Node&lt;K,V&gt;[] tab = table;;) {
</pre>
<hr />
<pre>
1853                                 }
1854                             }
1855                         }
1856                         else if (f instanceof ReservationNode)
1857                             throw new IllegalStateException(&quot;Recursive update&quot;);
1858                     }
1859                 }
1860                 if (binCount != 0)
1861                     break;
1862             }
1863         }
1864         if (delta != 0)
1865             addCount((long)delta, binCount);
1866         return val;
1867     }
1868 
1869     /**
1870      * Attempts to compute a mapping for the specified key and its
1871      * current mapped value (or {@code null} if there is no current
1872      * mapping). The entire method invocation is performed atomically.
<span class="line-modified">1873      * Some attempted update operations on this map by other threads</span>
<span class="line-modified">1874      * may be blocked while computation is in progress, so the</span>
<span class="line-modified">1875      * computation should be short and simple, and must not attempt to</span>
<span class="line-modified">1876      * update any other mappings of this Map.</span>


1877      *
1878      * @param key key with which the specified value is to be associated
1879      * @param remappingFunction the function to compute a value
1880      * @return the new value associated with the specified key, or null if none
1881      * @throws NullPointerException if the specified key or remappingFunction
1882      *         is null
1883      * @throws IllegalStateException if the computation detectably
1884      *         attempts a recursive update to this map that would
1885      *         otherwise never complete
1886      * @throws RuntimeException or Error if the remappingFunction does so,
1887      *         in which case the mapping is unchanged
1888      */
1889     public V compute(K key,
1890                      BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1891         if (key == null || remappingFunction == null)
1892             throw new NullPointerException();
1893         int h = spread(key.hashCode());
1894         V val = null;
1895         int delta = 0;
1896         int binCount = 0;
</pre>
<hr />
<pre>
3269                 tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
3270             if (tb != null &amp;&amp; tb.next != t)
3271                 return false;
3272             if (tn != null &amp;&amp; tn.prev != t)
3273                 return false;
3274             if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
3275                 return false;
3276             if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
3277                 return false;
3278             if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
3279                 return false;
3280             if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
3281                 return false;
3282             if (tl != null &amp;&amp; !checkInvariants(tl))
3283                 return false;
3284             if (tr != null &amp;&amp; !checkInvariants(tr))
3285                 return false;
3286             return true;
3287         }
3288 
<span class="line-removed">3289         private static final Unsafe U = Unsafe.getUnsafe();</span>
3290         private static final long LOCKSTATE
<span class="line-modified">3291                 = U.objectFieldOffset(TreeBin.class, &quot;lockState&quot;);</span>
3292     }
3293 
3294     /* ----------------Table Traversal -------------- */
3295 
3296     /**
3297      * Records the table, its length, and current traversal index for a
3298      * traverser that must process a region of a forwarded table before
3299      * proceeding with current table.
3300      */
3301     static final class TableStack&lt;K,V&gt; {
3302         int length;
3303         int index;
3304         Node&lt;K,V&gt;[] tab;
3305         TableStack&lt;K,V&gt; next;
3306     }
3307 
3308     /**
3309      * Encapsulates traversal for methods such as containsValue; also
3310      * serves as a base class for other iterators and spliterators.
3311      *
</pre>
<hr />
<pre>
4568             }
4569             return modified;
4570         }
4571 
4572     }
4573 
4574     /**
4575      * A view of a ConcurrentHashMap as a {@link Set} of keys, in
4576      * which additions may optionally be enabled by mapping to a
4577      * common value.  This class cannot be directly instantiated.
4578      * See {@link #keySet() keySet()},
4579      * {@link #keySet(Object) keySet(V)},
4580      * {@link #newKeySet() newKeySet()},
4581      * {@link #newKeySet(int) newKeySet(int)}.
4582      *
4583      * @since 1.8
4584      */
4585     public static class KeySetView&lt;K,V&gt; extends CollectionView&lt;K,V,K&gt;
4586         implements Set&lt;K&gt;, java.io.Serializable {
4587         private static final long serialVersionUID = 7249069246763182397L;

4588         private final V value;
4589         KeySetView(ConcurrentHashMap&lt;K,V&gt; map, V value) {  // non-public
4590             super(map);
4591             this.value = value;
4592         }
4593 
4594         /**
4595          * Returns the default mapped value for additions,
4596          * or {@code null} if additions are not supported.
4597          *
4598          * @return the default mapped value for additions, or {@code null}
4599          * if not supported
4600          */
4601         public V getMappedValue() { return value; }
4602 
4603         /**
4604          * {@inheritDoc}
4605          * @throws NullPointerException if the specified key is null
4606          */
4607         public boolean contains(Object o) { return map.containsKey(o); }
</pre>
<hr />
<pre>
6328                 for (Node&lt;K,V&gt; p; (p = advance()) != null; )
6329                     r = reducer.applyAsInt(r, transformer.applyAsInt(p.key, p.val));
6330                 result = r;
6331                 CountedCompleter&lt;?&gt; c;
6332                 for (c = firstComplete(); c != null; c = c.nextComplete()) {
6333                     @SuppressWarnings(&quot;unchecked&quot;)
6334                     MapReduceMappingsToIntTask&lt;K,V&gt;
6335                         t = (MapReduceMappingsToIntTask&lt;K,V&gt;)c,
6336                         s = t.rights;
6337                     while (s != null) {
6338                         t.result = reducer.applyAsInt(t.result, s.result);
6339                         s = t.rights = s.nextRight;
6340                     }
6341                 }
6342             }
6343         }
6344     }
6345 
6346     // Unsafe mechanics
6347     private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">6348     private static final long SIZECTL;</span>
<span class="line-modified">6349     private static final long TRANSFERINDEX;</span>
<span class="line-modified">6350     private static final long BASECOUNT;</span>
<span class="line-modified">6351     private static final long CELLSBUSY;</span>
<span class="line-modified">6352     private static final long CELLVALUE;</span>
<span class="line-modified">6353     private static final int ABASE;</span>





6354     private static final int ASHIFT;
6355 
6356     static {
<span class="line-removed">6357         SIZECTL = U.objectFieldOffset</span>
<span class="line-removed">6358             (ConcurrentHashMap.class, &quot;sizeCtl&quot;);</span>
<span class="line-removed">6359         TRANSFERINDEX = U.objectFieldOffset</span>
<span class="line-removed">6360             (ConcurrentHashMap.class, &quot;transferIndex&quot;);</span>
<span class="line-removed">6361         BASECOUNT = U.objectFieldOffset</span>
<span class="line-removed">6362             (ConcurrentHashMap.class, &quot;baseCount&quot;);</span>
<span class="line-removed">6363         CELLSBUSY = U.objectFieldOffset</span>
<span class="line-removed">6364             (ConcurrentHashMap.class, &quot;cellsBusy&quot;);</span>
<span class="line-removed">6365 </span>
<span class="line-removed">6366         CELLVALUE = U.objectFieldOffset</span>
<span class="line-removed">6367             (CounterCell.class, &quot;value&quot;);</span>
<span class="line-removed">6368 </span>
<span class="line-removed">6369         ABASE = U.arrayBaseOffset(Node[].class);</span>
6370         int scale = U.arrayIndexScale(Node[].class);
6371         if ((scale &amp; (scale - 1)) != 0)
6372             throw new ExceptionInInitializerError(&quot;array index scale not a power of two&quot;);
6373         ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
6374 
6375         // Reduce the risk of rare disastrous classloading in first call to
6376         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773
6377         Class&lt;?&gt; ensureLoaded = LockSupport.class;
6378 
6379         // Eager class load observed to help JIT during startup
6380         ensureLoaded = ReservationNode.class;
6381     }
6382 }
</pre>
</td>
<td>
<hr />
<pre>
 368      * iterators in the same way.
 369      *
 370      * The table is resized when occupancy exceeds a percentage
 371      * threshold (nominally, 0.75, but see below).  Any thread
 372      * noticing an overfull bin may assist in resizing after the
 373      * initiating thread allocates and sets up the replacement array.
 374      * However, rather than stalling, these other threads may proceed
 375      * with insertions etc.  The use of TreeBins shields us from the
 376      * worst case effects of overfilling while resizes are in
 377      * progress.  Resizing proceeds by transferring bins, one by one,
 378      * from the table to the next table. However, threads claim small
 379      * blocks of indices to transfer (via field transferIndex) before
 380      * doing so, reducing contention.  A generation stamp in field
 381      * sizeCtl ensures that resizings do not overlap. Because we are
 382      * using power-of-two expansion, the elements from each bin must
 383      * either stay at same index, or move with a power of two
 384      * offset. We eliminate unnecessary node creation by catching
 385      * cases where old nodes can be reused because their next fields
 386      * won&#39;t change.  On average, only about one-sixth of them need
 387      * cloning when a table doubles. The nodes they replace will be
<span class="line-modified"> 388      * garbage collectible as soon as they are no longer referenced by</span>
 389      * any reader thread that may be in the midst of concurrently
 390      * traversing table.  Upon transfer, the old table bin contains
 391      * only a special forwarding node (with hash field &quot;MOVED&quot;) that
 392      * contains the next table as its key. On encountering a
 393      * forwarding node, access and update operations restart, using
 394      * the new table.
 395      *
 396      * Each bin transfer requires its bin lock, which can stall
 397      * waiting for locks while resizing. However, because other
 398      * threads can join in and help resize rather than contend for
 399      * locks, average aggregate waits become shorter as resizing
 400      * progresses.  The transfer operation must also ensure that all
 401      * accessible bins in both the old and new table are usable by any
 402      * traversal.  This is arranged in part by proceeding from the
 403      * last bin (table.length - 1) up towards the first.  Upon seeing
 404      * a forwarding node, traversals (see class Traverser) arrange to
 405      * move to the new table without revisiting nodes.  To ensure that
 406      * no intervening nodes are skipped even when moved out of order,
 407      * a stack (see class TableStack) is created on first encounter of
 408      * a forwarding node during a traversal, to maintain its place if
</pre>
<hr />
<pre>
1650     boolean removeValueIf(Predicate&lt;? super V&gt; function) {
1651         if (function == null) throw new NullPointerException();
1652         Node&lt;K,V&gt;[] t;
1653         boolean removed = false;
1654         if ((t = table) != null) {
1655             Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length);
1656             for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) {
1657                 K k = p.key;
1658                 V v = p.val;
1659                 if (function.test(v) &amp;&amp; replaceNode(k, null, v) != null)
1660                     removed = true;
1661             }
1662         }
1663         return removed;
1664     }
1665 
1666     /**
1667      * If the specified key is not already associated with a value,
1668      * attempts to compute its value using the given mapping function
1669      * and enters it into this map unless {@code null}.  The entire
<span class="line-modified">1670      * method invocation is performed atomically.  The supplied</span>
<span class="line-modified">1671      * function is invoked exactly once per invocation of this method</span>
<span class="line-modified">1672      * if the key is absent, else not at all.  Some attempted update</span>
<span class="line-modified">1673      * operations on this map by other threads may be blocked while</span>
<span class="line-modified">1674      * computation is in progress, so the computation should be short</span>
<span class="line-added">1675      * and simple.</span>
<span class="line-added">1676      *</span>
<span class="line-added">1677      * &lt;p&gt;The mapping function must not modify this map during computation.</span>
1678      *
1679      * @param key key with which the specified value is to be associated
1680      * @param mappingFunction the function to compute a value
1681      * @return the current (existing or computed) value associated with
1682      *         the specified key, or null if the computed value is null
1683      * @throws NullPointerException if the specified key or mappingFunction
1684      *         is null
1685      * @throws IllegalStateException if the computation detectably
1686      *         attempts a recursive update to this map that would
1687      *         otherwise never complete
1688      * @throws RuntimeException or Error if the mappingFunction does so,
1689      *         in which case the mapping is left unestablished
1690      */
1691     public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {
1692         if (key == null || mappingFunction == null)
1693             throw new NullPointerException();
1694         int h = spread(key.hashCode());
1695         V val = null;
1696         int binCount = 0;
1697         for (Node&lt;K,V&gt;[] tab = table;;) {
</pre>
<hr />
<pre>
1764                     }
1765                 }
1766                 if (binCount != 0) {
1767                     if (binCount &gt;= TREEIFY_THRESHOLD)
1768                         treeifyBin(tab, i);
1769                     if (!added)
1770                         return val;
1771                     break;
1772                 }
1773             }
1774         }
1775         if (val != null)
1776             addCount(1L, binCount);
1777         return val;
1778     }
1779 
1780     /**
1781      * If the value for the specified key is present, attempts to
1782      * compute a new mapping given the key and its current mapped
1783      * value.  The entire method invocation is performed atomically.
<span class="line-modified">1784      * The supplied function is invoked exactly once per invocation of</span>
<span class="line-modified">1785      * this method if the key is present, else not at all.  Some</span>
<span class="line-modified">1786      * attempted update operations on this map by other threads may be</span>
<span class="line-modified">1787      * blocked while computation is in progress, so the computation</span>
<span class="line-added">1788      * should be short and simple.</span>
<span class="line-added">1789      *</span>
<span class="line-added">1790      * &lt;p&gt;The remapping function must not modify this map during computation.</span>
1791      *
1792      * @param key key with which a value may be associated
1793      * @param remappingFunction the function to compute a value
1794      * @return the new value associated with the specified key, or null if none
1795      * @throws NullPointerException if the specified key or remappingFunction
1796      *         is null
1797      * @throws IllegalStateException if the computation detectably
1798      *         attempts a recursive update to this map that would
1799      *         otherwise never complete
1800      * @throws RuntimeException or Error if the remappingFunction does so,
1801      *         in which case the mapping is unchanged
1802      */
1803     public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1804         if (key == null || remappingFunction == null)
1805             throw new NullPointerException();
1806         int h = spread(key.hashCode());
1807         V val = null;
1808         int delta = 0;
1809         int binCount = 0;
1810         for (Node&lt;K,V&gt;[] tab = table;;) {
</pre>
<hr />
<pre>
1859                                 }
1860                             }
1861                         }
1862                         else if (f instanceof ReservationNode)
1863                             throw new IllegalStateException(&quot;Recursive update&quot;);
1864                     }
1865                 }
1866                 if (binCount != 0)
1867                     break;
1868             }
1869         }
1870         if (delta != 0)
1871             addCount((long)delta, binCount);
1872         return val;
1873     }
1874 
1875     /**
1876      * Attempts to compute a mapping for the specified key and its
1877      * current mapped value (or {@code null} if there is no current
1878      * mapping). The entire method invocation is performed atomically.
<span class="line-modified">1879      * The supplied function is invoked exactly once per invocation of</span>
<span class="line-modified">1880      * this method.  Some attempted update operations on this map by</span>
<span class="line-modified">1881      * other threads may be blocked while computation is in progress,</span>
<span class="line-modified">1882      * so the computation should be short and simple.</span>
<span class="line-added">1883      *</span>
<span class="line-added">1884      * &lt;p&gt;The remapping function must not modify this map during computation.</span>
1885      *
1886      * @param key key with which the specified value is to be associated
1887      * @param remappingFunction the function to compute a value
1888      * @return the new value associated with the specified key, or null if none
1889      * @throws NullPointerException if the specified key or remappingFunction
1890      *         is null
1891      * @throws IllegalStateException if the computation detectably
1892      *         attempts a recursive update to this map that would
1893      *         otherwise never complete
1894      * @throws RuntimeException or Error if the remappingFunction does so,
1895      *         in which case the mapping is unchanged
1896      */
1897     public V compute(K key,
1898                      BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1899         if (key == null || remappingFunction == null)
1900             throw new NullPointerException();
1901         int h = spread(key.hashCode());
1902         V val = null;
1903         int delta = 0;
1904         int binCount = 0;
</pre>
<hr />
<pre>
3277                 tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
3278             if (tb != null &amp;&amp; tb.next != t)
3279                 return false;
3280             if (tn != null &amp;&amp; tn.prev != t)
3281                 return false;
3282             if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
3283                 return false;
3284             if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
3285                 return false;
3286             if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
3287                 return false;
3288             if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
3289                 return false;
3290             if (tl != null &amp;&amp; !checkInvariants(tl))
3291                 return false;
3292             if (tr != null &amp;&amp; !checkInvariants(tr))
3293                 return false;
3294             return true;
3295         }
3296 

3297         private static final long LOCKSTATE
<span class="line-modified">3298             = U.objectFieldOffset(TreeBin.class, &quot;lockState&quot;);</span>
3299     }
3300 
3301     /* ----------------Table Traversal -------------- */
3302 
3303     /**
3304      * Records the table, its length, and current traversal index for a
3305      * traverser that must process a region of a forwarded table before
3306      * proceeding with current table.
3307      */
3308     static final class TableStack&lt;K,V&gt; {
3309         int length;
3310         int index;
3311         Node&lt;K,V&gt;[] tab;
3312         TableStack&lt;K,V&gt; next;
3313     }
3314 
3315     /**
3316      * Encapsulates traversal for methods such as containsValue; also
3317      * serves as a base class for other iterators and spliterators.
3318      *
</pre>
<hr />
<pre>
4575             }
4576             return modified;
4577         }
4578 
4579     }
4580 
4581     /**
4582      * A view of a ConcurrentHashMap as a {@link Set} of keys, in
4583      * which additions may optionally be enabled by mapping to a
4584      * common value.  This class cannot be directly instantiated.
4585      * See {@link #keySet() keySet()},
4586      * {@link #keySet(Object) keySet(V)},
4587      * {@link #newKeySet() newKeySet()},
4588      * {@link #newKeySet(int) newKeySet(int)}.
4589      *
4590      * @since 1.8
4591      */
4592     public static class KeySetView&lt;K,V&gt; extends CollectionView&lt;K,V,K&gt;
4593         implements Set&lt;K&gt;, java.io.Serializable {
4594         private static final long serialVersionUID = 7249069246763182397L;
<span class="line-added">4595         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
4596         private final V value;
4597         KeySetView(ConcurrentHashMap&lt;K,V&gt; map, V value) {  // non-public
4598             super(map);
4599             this.value = value;
4600         }
4601 
4602         /**
4603          * Returns the default mapped value for additions,
4604          * or {@code null} if additions are not supported.
4605          *
4606          * @return the default mapped value for additions, or {@code null}
4607          * if not supported
4608          */
4609         public V getMappedValue() { return value; }
4610 
4611         /**
4612          * {@inheritDoc}
4613          * @throws NullPointerException if the specified key is null
4614          */
4615         public boolean contains(Object o) { return map.containsKey(o); }
</pre>
<hr />
<pre>
6336                 for (Node&lt;K,V&gt; p; (p = advance()) != null; )
6337                     r = reducer.applyAsInt(r, transformer.applyAsInt(p.key, p.val));
6338                 result = r;
6339                 CountedCompleter&lt;?&gt; c;
6340                 for (c = firstComplete(); c != null; c = c.nextComplete()) {
6341                     @SuppressWarnings(&quot;unchecked&quot;)
6342                     MapReduceMappingsToIntTask&lt;K,V&gt;
6343                         t = (MapReduceMappingsToIntTask&lt;K,V&gt;)c,
6344                         s = t.rights;
6345                     while (s != null) {
6346                         t.result = reducer.applyAsInt(t.result, s.result);
6347                         s = t.rights = s.nextRight;
6348                     }
6349                 }
6350             }
6351         }
6352     }
6353 
6354     // Unsafe mechanics
6355     private static final Unsafe U = Unsafe.getUnsafe();
<span class="line-modified">6356     private static final long SIZECTL</span>
<span class="line-modified">6357         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;sizeCtl&quot;);</span>
<span class="line-modified">6358     private static final long TRANSFERINDEX</span>
<span class="line-modified">6359         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;transferIndex&quot;);</span>
<span class="line-modified">6360     private static final long BASECOUNT</span>
<span class="line-modified">6361         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;baseCount&quot;);</span>
<span class="line-added">6362     private static final long CELLSBUSY</span>
<span class="line-added">6363         = U.objectFieldOffset(ConcurrentHashMap.class, &quot;cellsBusy&quot;);</span>
<span class="line-added">6364     private static final long CELLVALUE</span>
<span class="line-added">6365         = U.objectFieldOffset(CounterCell.class, &quot;value&quot;);</span>
<span class="line-added">6366     private static final int ABASE = U.arrayBaseOffset(Node[].class);</span>
6367     private static final int ASHIFT;
6368 
6369     static {













6370         int scale = U.arrayIndexScale(Node[].class);
6371         if ((scale &amp; (scale - 1)) != 0)
6372             throw new ExceptionInInitializerError(&quot;array index scale not a power of two&quot;);
6373         ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
6374 
6375         // Reduce the risk of rare disastrous classloading in first call to
6376         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773
6377         Class&lt;?&gt; ensureLoaded = LockSupport.class;
6378 
6379         // Eager class load observed to help JIT during startup
6380         ensureLoaded = ReservationNode.class;
6381     }
6382 }
</pre>
</td>
</tr>
</table>
<center><a href="CompletableFuture.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ConcurrentSkipListMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/DateFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CompactNumberFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormatSymbols.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/DateFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  41 import java.io.InvalidObjectException;
  42 import java.text.spi.DateFormatProvider;
  43 import java.util.Calendar;
  44 import java.util.Date;
  45 import java.util.GregorianCalendar;
  46 import java.util.HashMap;
  47 import java.util.Locale;
  48 import java.util.Map;
  49 import java.util.MissingResourceException;
  50 import java.util.ResourceBundle;
  51 import java.util.TimeZone;
  52 import java.util.spi.LocaleServiceProvider;
  53 import sun.util.locale.provider.LocaleProviderAdapter;
  54 import sun.util.locale.provider.LocaleServiceProviderPool;
  55 
  56 /**
  57  * {@code DateFormat} is an abstract class for date/time formatting subclasses which
  58  * formats and parses dates or time in a language-independent manner.
  59  * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
  60  * formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
<span class="line-modified">  61  * normalization.  The date is represented as a &lt;code&gt;Date&lt;/code&gt; object or</span>
  62  * as the milliseconds since January 1, 1970, 00:00:00 GMT.
  63  *
  64  * &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
  65  * formatters based on the default or a given locale and a number of formatting
  66  * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
  67  * detail and examples of using these styles are provided in the method
  68  * descriptions.
  69  *
  70  * &lt;p&gt;{@code DateFormat} helps you to format and parse dates for any locale.
  71  * Your code can be completely independent of the locale conventions for
  72  * months, days of the week, or even the calendar format: lunar vs. solar.
  73  *
  74  * &lt;p&gt;To format a date for the current Locale, use one of the
  75  * static factory methods:
  76  * &lt;blockquote&gt;
  77  * &lt;pre&gt;{@code
  78  * myString = DateFormat.getDateInstance().format(myDate);
  79  * }&lt;/pre&gt;
  80  * &lt;/blockquote&gt;
  81  * &lt;p&gt;If you are formatting multiple dates, it is
</pre>
<hr />
<pre>
 123  * &lt;li&gt;{@link #FULL} is pretty completely specified, such as
 124  * {@code Tuesday, April 12, 1952 AD or 3:30:42pm PST}.
 125  * &lt;/ul&gt;
 126  *
 127  * &lt;p&gt;You can also set the time zone on the format if you wish.
 128  * If you want even more control over the format or parsing,
 129  * (or want to give your users more control),
 130  * you can try casting the {@code DateFormat} you get from the factory methods
 131  * to a {@link SimpleDateFormat}. This will work for the majority
 132  * of countries; just remember to put it in a {@code try} block in case you
 133  * encounter an unusual one.
 134  *
 135  * &lt;p&gt;You can also use forms of the parse and format methods with
 136  * {@link ParsePosition} and {@link FieldPosition} to
 137  * allow you to
 138  * &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
 139  * &lt;li&gt;align any particular field, or find out where it is for selection
 140  * on the screen.
 141  * &lt;/ul&gt;
 142  *
<span class="line-modified"> 143  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 144  *
 145  * &lt;p&gt;
 146  * Date formats are not synchronized.
 147  * It is recommended to create separate format instances for each thread.
 148  * If multiple threads access a format concurrently, it must be synchronized
 149  * externally.
 150  *
 151  * @implSpec
 152  * &lt;ul&gt;&lt;li&gt;The {@link #format(Date, StringBuffer, FieldPosition)} and
 153  * {@link #parse(String, ParsePosition)} methods may throw
 154  * {@code NullPointerException}, if any of their parameter is {@code null}.
 155  * The subclass may provide its own implementation and specification about
 156  * {@code NullPointerException}.&lt;/li&gt;
 157  * &lt;li&gt;The {@link #setCalendar(Calendar)}, {@link
 158  * #setNumberFormat(NumberFormat)} and {@link #setTimeZone(TimeZone)} methods
 159  * do not throw {@code NullPointerException} when their parameter is
 160  * {@code null}, but any subsequent operations on the same instance may throw
 161  * {@code NullPointerException}.&lt;/li&gt;
 162  * &lt;li&gt;The {@link #getCalendar()}, {@link #getNumberFormat()} and
 163  * {@link getTimeZone()} methods may return {@code null}, if the respective
</pre>
<hr />
<pre>
 168  * &lt;/ul&gt;
 169  *
 170  * @see          Format
 171  * @see          NumberFormat
 172  * @see          SimpleDateFormat
 173  * @see          java.util.Calendar
 174  * @see          java.util.GregorianCalendar
 175  * @see          java.util.TimeZone
 176  * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
 177  * @since 1.1
 178  */
 179 public abstract class DateFormat extends Format {
 180 
 181     /**
 182      * The {@link Calendar} instance used for calculating the date-time fields
 183      * and the instant of time. This field is used for both formatting and
 184      * parsing.
 185      *
 186      * &lt;p&gt;Subclasses should initialize this field to a {@link Calendar}
 187      * appropriate for the {@link Locale} associated with this
<span class="line-modified"> 188      * &lt;code&gt;DateFormat&lt;/code&gt;.</span>
 189      * @serial
 190      */
 191     protected Calendar calendar;
 192 
 193     /**
<span class="line-modified"> 194      * The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers</span>
 195      * in dates and times.  Subclasses should initialize this to a number format
<span class="line-modified"> 196      * appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.</span>
 197      * @serial
 198      */
 199     protected NumberFormat numberFormat;
 200 
 201     /**
 202      * Useful constant for ERA field alignment.
 203      * Used in FieldPosition of date/time formatting.
 204      */
 205     public static final int ERA_FIELD = 0;
 206     /**
 207      * Useful constant for YEAR field alignment.
 208      * Used in FieldPosition of date/time formatting.
 209      */
 210     public static final int YEAR_FIELD = 1;
 211     /**
 212      * Useful constant for MONTH field alignment.
 213      * Used in FieldPosition of date/time formatting.
 214      */
 215     public static final int MONTH_FIELD = 2;
 216     /**
</pre>
<hr />
<pre>
 281      * Useful constant for one-based HOUR field alignment.
 282      * Used in FieldPosition of date/time formatting.
 283      * HOUR1_FIELD is used for the one-based 12-hour clock.
 284      * For example, 11:30 PM + 1 hour results in 12:30 AM.
 285      */
 286     public static final int HOUR1_FIELD = 15;
 287     /**
 288      * Useful constant for zero-based HOUR field alignment.
 289      * Used in FieldPosition of date/time formatting.
 290      * HOUR0_FIELD is used for the zero-based 12-hour clock.
 291      * For example, 11:30 PM + 1 hour results in 00:30 AM.
 292      */
 293     public static final int HOUR0_FIELD = 16;
 294     /**
 295      * Useful constant for TIMEZONE field alignment.
 296      * Used in FieldPosition of date/time formatting.
 297      */
 298     public static final int TIMEZONE_FIELD = 17;
 299 
 300     // Proclaim serial compatibility with 1.1 FCS

 301     private static final long serialVersionUID = 7218322306649953788L;
 302 
 303     /**
 304      * Formats the given {@code Object} into a date-time string. The formatted
 305      * string is appended to the given {@code StringBuffer}.
 306      *
 307      * @param obj Must be a {@code Date} or a {@code Number} representing a
 308      * millisecond offset from the &lt;a href=&quot;../util/Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;.
 309      * @param toAppendTo The string buffer for the returning date-time string.
 310      * @param fieldPosition keeps track on the position of the field within
 311      * the returned string. For example, given a date-time text
 312      * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
 313      * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
 314      * {@code fieldPosition} will be set to 0 and 4, respectively.
 315      * Notice that if the same date-time field appears more than once in a
 316      * pattern, the {@code fieldPosition} will be set for the first occurrence
 317      * of that date-time field. For instance, formatting a {@code Date} to the
 318      * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
 319      * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
 320      * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
 321      * {@code fieldPosition} will be set to 5 and 8, respectively, for the
 322      * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
 323      * @return the string buffer passed in as {@code toAppendTo},
 324      *         with formatted text appended.
<span class="line-modified"> 325      * @exception IllegalArgumentException if the {@code Format} cannot format</span>
 326      *            the given {@code obj}.
 327      * @see java.text.Format
 328      */
 329     public final StringBuffer format(Object obj, StringBuffer toAppendTo,
 330                                      FieldPosition fieldPosition)
 331     {
 332         if (obj instanceof Date)
 333             return format( (Date)obj, toAppendTo, fieldPosition );
 334         else if (obj instanceof Number)
 335             return format( new Date(((Number)obj).longValue()),
 336                           toAppendTo, fieldPosition );
 337         else
 338             throw new IllegalArgumentException(&quot;Cannot format given Object as a Date&quot;);
 339     }
 340 
 341     /**
 342      * Formats a {@link Date} into a date-time string. The formatted
 343      * string is appended to the given {@code StringBuffer}.
 344      *
 345      * @param date a Date to be formatted into a date-time string.
</pre>
<hr />
<pre>
 365 
 366     /**
 367       * Formats a {@link Date} into a date-time string.
 368       *
 369       * @param date the time value to be formatted into a date-time string.
 370       * @return the formatted date-time string.
 371      */
 372     public final String format(Date date)
 373     {
 374         return format(date, new StringBuffer(),
 375                       DontCareFieldPosition.INSTANCE).toString();
 376     }
 377 
 378     /**
 379      * Parses text from the beginning of the given string to produce a date.
 380      * The method may not use the entire text of the given string.
 381      * &lt;p&gt;
 382      * See the {@link #parse(String, ParsePosition)} method for more information
 383      * on date parsing.
 384      *
<span class="line-modified"> 385      * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.</span>
<span class="line-modified"> 386      * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string.</span>
<span class="line-modified"> 387      * @exception ParseException if the beginning of the specified string</span>
 388      *            cannot be parsed.
 389      */
 390     public Date parse(String source) throws ParseException
 391     {
 392         ParsePosition pos = new ParsePosition(0);
 393         Date result = parse(source, pos);
 394         if (pos.index == 0)
 395             throw new ParseException(&quot;Unparseable date: \&quot;&quot; + source + &quot;\&quot;&quot; ,
 396                 pos.errorIndex);
 397         return result;
 398     }
 399 
 400     /**
 401      * Parse a date/time string according to the given parse position.  For
 402      * example, a time text {@code &quot;07/10/96 4:5 PM, PDT&quot;} will be parsed into a {@code Date}
 403      * that is equivalent to {@code Date(837039900000L)}.
 404      *
 405      * &lt;p&gt; By default, parsing is lenient: If the input is not in the form used
 406      * by this object&#39;s format method but can still be parsed as a date, then
 407      * the parse succeeds.  Clients may insist on strict adherence to the
</pre>
<hr />
<pre>
 409      *
 410      * &lt;p&gt;This parsing operation uses the {@link #calendar} to produce
 411      * a {@code Date}. As a result, the {@code calendar}&#39;s date-time
 412      * fields and the {@code TimeZone} value may have been
 413      * overwritten, depending on subclass implementations. Any {@code
 414      * TimeZone} value that has previously been set by a call to
 415      * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
 416      * to be restored for further operations.
 417      *
 418      * @param source  The date/time string to be parsed
 419      *
 420      * @param pos   On input, the position at which to start parsing; on
 421      *              output, the position at which parsing terminated, or the
 422      *              start position if the parse failed.
 423      *
 424      * @return      A {@code Date}, or {@code null} if the input could not be parsed
 425      */
 426     public abstract Date parse(String source, ParsePosition pos);
 427 
 428     /**
<span class="line-modified"> 429      * Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.</span>
 430      * &lt;p&gt;
 431      * The method attempts to parse text starting at the index given by
<span class="line-modified"> 432      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified"> 433      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
 434      * to the index after the last character used (parsing does not necessarily
 435      * use all characters up to the end of the string), and the parsed
<span class="line-modified"> 436      * date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
 437      * indicate the starting point for the next call to this method.
<span class="line-modified"> 438      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified"> 439      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
 440      * the character where the error occurred, and null is returned.
 441      * &lt;p&gt;
 442      * See the {@link #parse(String, ParsePosition)} method for more information
 443      * on date parsing.
 444      *
<span class="line-modified"> 445      * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified"> 446      * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
 447      *            index information as described above.
<span class="line-modified"> 448      * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of</span>
 449      *         error, returns null.
 450      * @throws NullPointerException if {@code source} or {@code pos} is null.
 451      */
 452     public Object parseObject(String source, ParsePosition pos) {
 453         return parse(source, pos);
 454     }
 455 
 456     /**
 457      * Constant for full style pattern.
 458      */
 459     public static final int FULL = 0;
 460     /**
 461      * Constant for long style pattern.
 462      */
 463     public static final int LONG = 1;
 464     /**
 465      * Constant for medium style pattern.
 466      */
 467     public static final int MEDIUM = 2;
 468     /**
</pre>
<hr />
<pre>
 610      * @return a date/time formatter.
 611      */
 612     public static final DateFormat
 613         getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)
 614     {
 615         return get(timeStyle, dateStyle, 3, aLocale);
 616     }
 617 
 618     /**
 619      * Get a default date/time formatter that uses the SHORT style for both the
 620      * date and the time.
 621      *
 622      * @return a date/time formatter
 623      */
 624     public static final DateFormat getInstance() {
 625         return getDateTimeInstance(SHORT, SHORT);
 626     }
 627 
 628     /**
 629      * Returns an array of all locales for which the
<span class="line-modified"> 630      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
 631      * localized instances.
 632      * The returned array represents the union of locales supported by the Java
 633      * runtime and by installed
 634      * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
<span class="line-modified"> 635      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to</span>
 636      * {@link java.util.Locale#US Locale.US}.
 637      *
 638      * @return An array of locales for which localized
<span class="line-modified"> 639      *         &lt;code&gt;DateFormat&lt;/code&gt; instances are available.</span>
 640      */
 641     public static Locale[] getAvailableLocales()
 642     {
 643         LocaleServiceProviderPool pool =
 644             LocaleServiceProviderPool.getPool(DateFormatProvider.class);
 645         return pool.getAvailableLocales();
 646     }
 647 
 648     /**
 649      * Set the calendar to be used by this date format.  Initially, the default
 650      * calendar for the specified or default locale is used.
 651      *
 652      * &lt;p&gt;Any {@link java.util.TimeZone TimeZone} and {@linkplain
 653      * #isLenient() leniency} values that have previously been set are
 654      * overwritten by {@code newCalendar}&#39;s values.
 655      *
 656      * @param newCalendar the new {@code Calendar} to be used by the date format
 657      */
 658     public void setCalendar(Calendar newCalendar)
 659     {
</pre>
<hr />
<pre>
 836         DateFormat dateFormat;
 837         if (timeStyle == -1) {
 838             dateFormat = provider.getDateInstance(dateStyle, loc);
 839         } else {
 840             if (dateStyle == -1) {
 841                 dateFormat = provider.getTimeInstance(timeStyle, loc);
 842             } else {
 843                 dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);
 844             }
 845         }
 846         return dateFormat;
 847     }
 848 
 849     /**
 850      * Create a new date format.
 851      */
 852     protected DateFormat() {}
 853 
 854     /**
 855      * Defines constants that are used as attribute keys in the
<span class="line-modified"> 856      * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned</span>
<span class="line-modified"> 857      * from &lt;code&gt;DateFormat.formatToCharacterIterator&lt;/code&gt; and as</span>
<span class="line-modified"> 858      * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.</span>
 859      * &lt;p&gt;
 860      * The class also provides two methods to map
 861      * between its constants and the corresponding Calendar constants.
 862      *
 863      * @since 1.4
 864      * @see java.util.Calendar
 865      */
 866     public static class Field extends Format.Field {
 867 
 868         // Proclaim serial compatibility with 1.4 FCS

 869         private static final long serialVersionUID = 7441350119349544720L;
 870 
 871         // table of all instances in this class, used by readResolve
 872         private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(18);
 873         // Maps from Calendar constant (such as Calendar.ERA) to Field
 874         // constant (such as Field.ERA).
 875         private static final Field[] calendarToFieldMapping =
 876                                              new Field[Calendar.FIELD_COUNT];
 877 
 878         /** Calendar field. */
 879         private int calendarField;
 880 
 881         /**
<span class="line-modified"> 882          * Returns the &lt;code&gt;Field&lt;/code&gt; constant that corresponds to</span>
<span class="line-modified"> 883          * the &lt;code&gt;Calendar&lt;/code&gt; constant &lt;code&gt;calendarField&lt;/code&gt;.</span>
<span class="line-modified"> 884          * If there is no direct mapping between the &lt;code&gt;Calendar&lt;/code&gt;</span>
<span class="line-modified"> 885          * constant and a &lt;code&gt;Field&lt;/code&gt;, null is returned.</span>
 886          *
<span class="line-modified"> 887          * @throws IllegalArgumentException if &lt;code&gt;calendarField&lt;/code&gt; is</span>
<span class="line-modified"> 888          *         not the value of a &lt;code&gt;Calendar&lt;/code&gt; field constant.</span>
 889          * @param calendarField Calendar field constant
 890          * @return Field instance representing calendarField.
 891          * @see java.util.Calendar
 892          */
 893         public static Field ofCalendarField(int calendarField) {
 894             if (calendarField &lt; 0 || calendarField &gt;=
 895                         calendarToFieldMapping.length) {
 896                 throw new IllegalArgumentException(&quot;Unknown Calendar constant &quot;
 897                                                    + calendarField);
 898             }
 899             return calendarToFieldMapping[calendarField];
 900         }
 901 
 902         /**
<span class="line-modified"> 903          * Creates a &lt;code&gt;Field&lt;/code&gt;.</span>
 904          *
<span class="line-modified"> 905          * @param name the name of the &lt;code&gt;Field&lt;/code&gt;</span>
<span class="line-modified"> 906          * @param calendarField the &lt;code&gt;Calendar&lt;/code&gt; constant this</span>
<span class="line-modified"> 907          *        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one</span>
<span class="line-modified"> 908          *        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may</span>
<span class="line-modified"> 909          *        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values</span>
<span class="line-modified"> 910          *        that don&#39;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values</span>
 911          */
 912         protected Field(String name, int calendarField) {
 913             super(name);
 914             this.calendarField = calendarField;
 915             if (this.getClass() == DateFormat.Field.class) {
 916                 instanceMap.put(name, this);
 917                 if (calendarField &gt;= 0) {
 918                     // assert(calendarField &lt; Calendar.FIELD_COUNT);
 919                     calendarToFieldMapping[calendarField] = this;
 920                 }
 921             }
 922         }
 923 
 924         /**
<span class="line-modified"> 925          * Returns the &lt;code&gt;Calendar&lt;/code&gt; field associated with this</span>
 926          * attribute. For example, if this represents the hours field of
<span class="line-modified"> 927          * a &lt;code&gt;Calendar&lt;/code&gt;, this would return</span>
<span class="line-modified"> 928          * &lt;code&gt;Calendar.HOUR&lt;/code&gt;. If there is no corresponding</span>
<span class="line-modified"> 929          * &lt;code&gt;Calendar&lt;/code&gt; constant, this will return -1.</span>
 930          *
 931          * @return Calendar constant for this field
 932          * @see java.util.Calendar
 933          */
 934         public int getCalendarField() {
 935             return calendarField;
 936         }
 937 
 938         /**
 939          * Resolves instances being deserialized to the predefined constants.
 940          *
 941          * @throws InvalidObjectException if the constant could not be
 942          *         resolved.
 943          * @return resolved DateFormat.Field constant
 944          */
 945         @Override

 946         protected Object readResolve() throws InvalidObjectException {
 947             if (this.getClass() != DateFormat.Field.class) {
 948                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
 949             }
 950 
 951             Object instance = instanceMap.get(getName());
 952             if (instance != null) {
 953                 return instance;
 954             } else {
 955                 throw new InvalidObjectException(&quot;unknown attribute name&quot;);
 956             }
 957         }
 958 
 959         //
 960         // The constants
 961         //
 962 
 963         /**
 964          * Constant identifying the era field.
 965          */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  41 import java.io.InvalidObjectException;
  42 import java.text.spi.DateFormatProvider;
  43 import java.util.Calendar;
  44 import java.util.Date;
  45 import java.util.GregorianCalendar;
  46 import java.util.HashMap;
  47 import java.util.Locale;
  48 import java.util.Map;
  49 import java.util.MissingResourceException;
  50 import java.util.ResourceBundle;
  51 import java.util.TimeZone;
  52 import java.util.spi.LocaleServiceProvider;
  53 import sun.util.locale.provider.LocaleProviderAdapter;
  54 import sun.util.locale.provider.LocaleServiceProviderPool;
  55 
  56 /**
  57  * {@code DateFormat} is an abstract class for date/time formatting subclasses which
  58  * formats and parses dates or time in a language-independent manner.
  59  * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
  60  * formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
<span class="line-modified">  61  * normalization.  The date is represented as a {@code Date} object or</span>
  62  * as the milliseconds since January 1, 1970, 00:00:00 GMT.
  63  *
  64  * &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
  65  * formatters based on the default or a given locale and a number of formatting
  66  * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
  67  * detail and examples of using these styles are provided in the method
  68  * descriptions.
  69  *
  70  * &lt;p&gt;{@code DateFormat} helps you to format and parse dates for any locale.
  71  * Your code can be completely independent of the locale conventions for
  72  * months, days of the week, or even the calendar format: lunar vs. solar.
  73  *
  74  * &lt;p&gt;To format a date for the current Locale, use one of the
  75  * static factory methods:
  76  * &lt;blockquote&gt;
  77  * &lt;pre&gt;{@code
  78  * myString = DateFormat.getDateInstance().format(myDate);
  79  * }&lt;/pre&gt;
  80  * &lt;/blockquote&gt;
  81  * &lt;p&gt;If you are formatting multiple dates, it is
</pre>
<hr />
<pre>
 123  * &lt;li&gt;{@link #FULL} is pretty completely specified, such as
 124  * {@code Tuesday, April 12, 1952 AD or 3:30:42pm PST}.
 125  * &lt;/ul&gt;
 126  *
 127  * &lt;p&gt;You can also set the time zone on the format if you wish.
 128  * If you want even more control over the format or parsing,
 129  * (or want to give your users more control),
 130  * you can try casting the {@code DateFormat} you get from the factory methods
 131  * to a {@link SimpleDateFormat}. This will work for the majority
 132  * of countries; just remember to put it in a {@code try} block in case you
 133  * encounter an unusual one.
 134  *
 135  * &lt;p&gt;You can also use forms of the parse and format methods with
 136  * {@link ParsePosition} and {@link FieldPosition} to
 137  * allow you to
 138  * &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
 139  * &lt;li&gt;align any particular field, or find out where it is for selection
 140  * on the screen.
 141  * &lt;/ul&gt;
 142  *
<span class="line-modified"> 143  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
 144  *
 145  * &lt;p&gt;
 146  * Date formats are not synchronized.
 147  * It is recommended to create separate format instances for each thread.
 148  * If multiple threads access a format concurrently, it must be synchronized
 149  * externally.
 150  *
 151  * @implSpec
 152  * &lt;ul&gt;&lt;li&gt;The {@link #format(Date, StringBuffer, FieldPosition)} and
 153  * {@link #parse(String, ParsePosition)} methods may throw
 154  * {@code NullPointerException}, if any of their parameter is {@code null}.
 155  * The subclass may provide its own implementation and specification about
 156  * {@code NullPointerException}.&lt;/li&gt;
 157  * &lt;li&gt;The {@link #setCalendar(Calendar)}, {@link
 158  * #setNumberFormat(NumberFormat)} and {@link #setTimeZone(TimeZone)} methods
 159  * do not throw {@code NullPointerException} when their parameter is
 160  * {@code null}, but any subsequent operations on the same instance may throw
 161  * {@code NullPointerException}.&lt;/li&gt;
 162  * &lt;li&gt;The {@link #getCalendar()}, {@link #getNumberFormat()} and
 163  * {@link getTimeZone()} methods may return {@code null}, if the respective
</pre>
<hr />
<pre>
 168  * &lt;/ul&gt;
 169  *
 170  * @see          Format
 171  * @see          NumberFormat
 172  * @see          SimpleDateFormat
 173  * @see          java.util.Calendar
 174  * @see          java.util.GregorianCalendar
 175  * @see          java.util.TimeZone
 176  * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
 177  * @since 1.1
 178  */
 179 public abstract class DateFormat extends Format {
 180 
 181     /**
 182      * The {@link Calendar} instance used for calculating the date-time fields
 183      * and the instant of time. This field is used for both formatting and
 184      * parsing.
 185      *
 186      * &lt;p&gt;Subclasses should initialize this field to a {@link Calendar}
 187      * appropriate for the {@link Locale} associated with this
<span class="line-modified"> 188      * {@code DateFormat}.</span>
 189      * @serial
 190      */
 191     protected Calendar calendar;
 192 
 193     /**
<span class="line-modified"> 194      * The number formatter that {@code DateFormat} uses to format numbers</span>
 195      * in dates and times.  Subclasses should initialize this to a number format
<span class="line-modified"> 196      * appropriate for the locale associated with this {@code DateFormat}.</span>
 197      * @serial
 198      */
 199     protected NumberFormat numberFormat;
 200 
 201     /**
 202      * Useful constant for ERA field alignment.
 203      * Used in FieldPosition of date/time formatting.
 204      */
 205     public static final int ERA_FIELD = 0;
 206     /**
 207      * Useful constant for YEAR field alignment.
 208      * Used in FieldPosition of date/time formatting.
 209      */
 210     public static final int YEAR_FIELD = 1;
 211     /**
 212      * Useful constant for MONTH field alignment.
 213      * Used in FieldPosition of date/time formatting.
 214      */
 215     public static final int MONTH_FIELD = 2;
 216     /**
</pre>
<hr />
<pre>
 281      * Useful constant for one-based HOUR field alignment.
 282      * Used in FieldPosition of date/time formatting.
 283      * HOUR1_FIELD is used for the one-based 12-hour clock.
 284      * For example, 11:30 PM + 1 hour results in 12:30 AM.
 285      */
 286     public static final int HOUR1_FIELD = 15;
 287     /**
 288      * Useful constant for zero-based HOUR field alignment.
 289      * Used in FieldPosition of date/time formatting.
 290      * HOUR0_FIELD is used for the zero-based 12-hour clock.
 291      * For example, 11:30 PM + 1 hour results in 00:30 AM.
 292      */
 293     public static final int HOUR0_FIELD = 16;
 294     /**
 295      * Useful constant for TIMEZONE field alignment.
 296      * Used in FieldPosition of date/time formatting.
 297      */
 298     public static final int TIMEZONE_FIELD = 17;
 299 
 300     // Proclaim serial compatibility with 1.1 FCS
<span class="line-added"> 301     @java.io.Serial</span>
 302     private static final long serialVersionUID = 7218322306649953788L;
 303 
 304     /**
 305      * Formats the given {@code Object} into a date-time string. The formatted
 306      * string is appended to the given {@code StringBuffer}.
 307      *
 308      * @param obj Must be a {@code Date} or a {@code Number} representing a
 309      * millisecond offset from the &lt;a href=&quot;../util/Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;.
 310      * @param toAppendTo The string buffer for the returning date-time string.
 311      * @param fieldPosition keeps track on the position of the field within
 312      * the returned string. For example, given a date-time text
 313      * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
 314      * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
 315      * {@code fieldPosition} will be set to 0 and 4, respectively.
 316      * Notice that if the same date-time field appears more than once in a
 317      * pattern, the {@code fieldPosition} will be set for the first occurrence
 318      * of that date-time field. For instance, formatting a {@code Date} to the
 319      * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
 320      * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
 321      * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
 322      * {@code fieldPosition} will be set to 5 and 8, respectively, for the
 323      * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
 324      * @return the string buffer passed in as {@code toAppendTo},
 325      *         with formatted text appended.
<span class="line-modified"> 326      * @throws    IllegalArgumentException if the {@code Format} cannot format</span>
 327      *            the given {@code obj}.
 328      * @see java.text.Format
 329      */
 330     public final StringBuffer format(Object obj, StringBuffer toAppendTo,
 331                                      FieldPosition fieldPosition)
 332     {
 333         if (obj instanceof Date)
 334             return format( (Date)obj, toAppendTo, fieldPosition );
 335         else if (obj instanceof Number)
 336             return format( new Date(((Number)obj).longValue()),
 337                           toAppendTo, fieldPosition );
 338         else
 339             throw new IllegalArgumentException(&quot;Cannot format given Object as a Date&quot;);
 340     }
 341 
 342     /**
 343      * Formats a {@link Date} into a date-time string. The formatted
 344      * string is appended to the given {@code StringBuffer}.
 345      *
 346      * @param date a Date to be formatted into a date-time string.
</pre>
<hr />
<pre>
 366 
 367     /**
 368       * Formats a {@link Date} into a date-time string.
 369       *
 370       * @param date the time value to be formatted into a date-time string.
 371       * @return the formatted date-time string.
 372      */
 373     public final String format(Date date)
 374     {
 375         return format(date, new StringBuffer(),
 376                       DontCareFieldPosition.INSTANCE).toString();
 377     }
 378 
 379     /**
 380      * Parses text from the beginning of the given string to produce a date.
 381      * The method may not use the entire text of the given string.
 382      * &lt;p&gt;
 383      * See the {@link #parse(String, ParsePosition)} method for more information
 384      * on date parsing.
 385      *
<span class="line-modified"> 386      * @param source A {@code String} whose beginning should be parsed.</span>
<span class="line-modified"> 387      * @return A {@code Date} parsed from the string.</span>
<span class="line-modified"> 388      * @throws    ParseException if the beginning of the specified string</span>
 389      *            cannot be parsed.
 390      */
 391     public Date parse(String source) throws ParseException
 392     {
 393         ParsePosition pos = new ParsePosition(0);
 394         Date result = parse(source, pos);
 395         if (pos.index == 0)
 396             throw new ParseException(&quot;Unparseable date: \&quot;&quot; + source + &quot;\&quot;&quot; ,
 397                 pos.errorIndex);
 398         return result;
 399     }
 400 
 401     /**
 402      * Parse a date/time string according to the given parse position.  For
 403      * example, a time text {@code &quot;07/10/96 4:5 PM, PDT&quot;} will be parsed into a {@code Date}
 404      * that is equivalent to {@code Date(837039900000L)}.
 405      *
 406      * &lt;p&gt; By default, parsing is lenient: If the input is not in the form used
 407      * by this object&#39;s format method but can still be parsed as a date, then
 408      * the parse succeeds.  Clients may insist on strict adherence to the
</pre>
<hr />
<pre>
 410      *
 411      * &lt;p&gt;This parsing operation uses the {@link #calendar} to produce
 412      * a {@code Date}. As a result, the {@code calendar}&#39;s date-time
 413      * fields and the {@code TimeZone} value may have been
 414      * overwritten, depending on subclass implementations. Any {@code
 415      * TimeZone} value that has previously been set by a call to
 416      * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
 417      * to be restored for further operations.
 418      *
 419      * @param source  The date/time string to be parsed
 420      *
 421      * @param pos   On input, the position at which to start parsing; on
 422      *              output, the position at which parsing terminated, or the
 423      *              start position if the parse failed.
 424      *
 425      * @return      A {@code Date}, or {@code null} if the input could not be parsed
 426      */
 427     public abstract Date parse(String source, ParsePosition pos);
 428 
 429     /**
<span class="line-modified"> 430      * Parses text from a string to produce a {@code Date}.</span>
 431      * &lt;p&gt;
 432      * The method attempts to parse text starting at the index given by
<span class="line-modified"> 433      * {@code pos}.</span>
<span class="line-modified"> 434      * If parsing succeeds, then the index of {@code pos} is updated</span>
 435      * to the index after the last character used (parsing does not necessarily
 436      * use all characters up to the end of the string), and the parsed
<span class="line-modified"> 437      * date is returned. The updated {@code pos} can be used to</span>
 438      * indicate the starting point for the next call to this method.
<span class="line-modified"> 439      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified"> 440      * changed, the error index of {@code pos} is set to the index of</span>
 441      * the character where the error occurred, and null is returned.
 442      * &lt;p&gt;
 443      * See the {@link #parse(String, ParsePosition)} method for more information
 444      * on date parsing.
 445      *
<span class="line-modified"> 446      * @param source A {@code String}, part of which should be parsed.</span>
<span class="line-modified"> 447      * @param pos A {@code ParsePosition} object with index and error</span>
 448      *            index information as described above.
<span class="line-modified"> 449      * @return A {@code Date} parsed from the string. In case of</span>
 450      *         error, returns null.
 451      * @throws NullPointerException if {@code source} or {@code pos} is null.
 452      */
 453     public Object parseObject(String source, ParsePosition pos) {
 454         return parse(source, pos);
 455     }
 456 
 457     /**
 458      * Constant for full style pattern.
 459      */
 460     public static final int FULL = 0;
 461     /**
 462      * Constant for long style pattern.
 463      */
 464     public static final int LONG = 1;
 465     /**
 466      * Constant for medium style pattern.
 467      */
 468     public static final int MEDIUM = 2;
 469     /**
</pre>
<hr />
<pre>
 611      * @return a date/time formatter.
 612      */
 613     public static final DateFormat
 614         getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)
 615     {
 616         return get(timeStyle, dateStyle, 3, aLocale);
 617     }
 618 
 619     /**
 620      * Get a default date/time formatter that uses the SHORT style for both the
 621      * date and the time.
 622      *
 623      * @return a date/time formatter
 624      */
 625     public static final DateFormat getInstance() {
 626         return getDateTimeInstance(SHORT, SHORT);
 627     }
 628 
 629     /**
 630      * Returns an array of all locales for which the
<span class="line-modified"> 631      * {@code get*Instance} methods of this class can return</span>
 632      * localized instances.
 633      * The returned array represents the union of locales supported by the Java
 634      * runtime and by installed
 635      * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
<span class="line-modified"> 636      * It must contain at least a {@code Locale} instance equal to</span>
 637      * {@link java.util.Locale#US Locale.US}.
 638      *
 639      * @return An array of locales for which localized
<span class="line-modified"> 640      *         {@code DateFormat} instances are available.</span>
 641      */
 642     public static Locale[] getAvailableLocales()
 643     {
 644         LocaleServiceProviderPool pool =
 645             LocaleServiceProviderPool.getPool(DateFormatProvider.class);
 646         return pool.getAvailableLocales();
 647     }
 648 
 649     /**
 650      * Set the calendar to be used by this date format.  Initially, the default
 651      * calendar for the specified or default locale is used.
 652      *
 653      * &lt;p&gt;Any {@link java.util.TimeZone TimeZone} and {@linkplain
 654      * #isLenient() leniency} values that have previously been set are
 655      * overwritten by {@code newCalendar}&#39;s values.
 656      *
 657      * @param newCalendar the new {@code Calendar} to be used by the date format
 658      */
 659     public void setCalendar(Calendar newCalendar)
 660     {
</pre>
<hr />
<pre>
 837         DateFormat dateFormat;
 838         if (timeStyle == -1) {
 839             dateFormat = provider.getDateInstance(dateStyle, loc);
 840         } else {
 841             if (dateStyle == -1) {
 842                 dateFormat = provider.getTimeInstance(timeStyle, loc);
 843             } else {
 844                 dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);
 845             }
 846         }
 847         return dateFormat;
 848     }
 849 
 850     /**
 851      * Create a new date format.
 852      */
 853     protected DateFormat() {}
 854 
 855     /**
 856      * Defines constants that are used as attribute keys in the
<span class="line-modified"> 857      * {@code AttributedCharacterIterator} returned</span>
<span class="line-modified"> 858      * from {@code DateFormat.formatToCharacterIterator} and as</span>
<span class="line-modified"> 859      * field identifiers in {@code FieldPosition}.</span>
 860      * &lt;p&gt;
 861      * The class also provides two methods to map
 862      * between its constants and the corresponding Calendar constants.
 863      *
 864      * @since 1.4
 865      * @see java.util.Calendar
 866      */
 867     public static class Field extends Format.Field {
 868 
 869         // Proclaim serial compatibility with 1.4 FCS
<span class="line-added"> 870         @java.io.Serial</span>
 871         private static final long serialVersionUID = 7441350119349544720L;
 872 
 873         // table of all instances in this class, used by readResolve
 874         private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(18);
 875         // Maps from Calendar constant (such as Calendar.ERA) to Field
 876         // constant (such as Field.ERA).
 877         private static final Field[] calendarToFieldMapping =
 878                                              new Field[Calendar.FIELD_COUNT];
 879 
 880         /** Calendar field. */
 881         private int calendarField;
 882 
 883         /**
<span class="line-modified"> 884          * Returns the {@code Field} constant that corresponds to</span>
<span class="line-modified"> 885          * the {@code Calendar} constant {@code calendarField}.</span>
<span class="line-modified"> 886          * If there is no direct mapping between the {@code Calendar}</span>
<span class="line-modified"> 887          * constant and a {@code Field}, null is returned.</span>
 888          *
<span class="line-modified"> 889          * @throws IllegalArgumentException if {@code calendarField} is</span>
<span class="line-modified"> 890          *         not the value of a {@code Calendar} field constant.</span>
 891          * @param calendarField Calendar field constant
 892          * @return Field instance representing calendarField.
 893          * @see java.util.Calendar
 894          */
 895         public static Field ofCalendarField(int calendarField) {
 896             if (calendarField &lt; 0 || calendarField &gt;=
 897                         calendarToFieldMapping.length) {
 898                 throw new IllegalArgumentException(&quot;Unknown Calendar constant &quot;
 899                                                    + calendarField);
 900             }
 901             return calendarToFieldMapping[calendarField];
 902         }
 903 
 904         /**
<span class="line-modified"> 905          * Creates a {@code Field}.</span>
 906          *
<span class="line-modified"> 907          * @param name the name of the {@code Field}</span>
<span class="line-modified"> 908          * @param calendarField the {@code Calendar} constant this</span>
<span class="line-modified"> 909          *        {@code Field} corresponds to; any value, even one</span>
<span class="line-modified"> 910          *        outside the range of legal {@code Calendar} values may</span>
<span class="line-modified"> 911          *        be used, but {@code -1} should be used for values</span>
<span class="line-modified"> 912          *        that don&#39;t correspond to legal {@code Calendar} values</span>
 913          */
 914         protected Field(String name, int calendarField) {
 915             super(name);
 916             this.calendarField = calendarField;
 917             if (this.getClass() == DateFormat.Field.class) {
 918                 instanceMap.put(name, this);
 919                 if (calendarField &gt;= 0) {
 920                     // assert(calendarField &lt; Calendar.FIELD_COUNT);
 921                     calendarToFieldMapping[calendarField] = this;
 922                 }
 923             }
 924         }
 925 
 926         /**
<span class="line-modified"> 927          * Returns the {@code Calendar} field associated with this</span>
 928          * attribute. For example, if this represents the hours field of
<span class="line-modified"> 929          * a {@code Calendar}, this would return</span>
<span class="line-modified"> 930          * {@code Calendar.HOUR}. If there is no corresponding</span>
<span class="line-modified"> 931          * {@code Calendar} constant, this will return -1.</span>
 932          *
 933          * @return Calendar constant for this field
 934          * @see java.util.Calendar
 935          */
 936         public int getCalendarField() {
 937             return calendarField;
 938         }
 939 
 940         /**
 941          * Resolves instances being deserialized to the predefined constants.
 942          *
 943          * @throws InvalidObjectException if the constant could not be
 944          *         resolved.
 945          * @return resolved DateFormat.Field constant
 946          */
 947         @Override
<span class="line-added"> 948         @java.io.Serial</span>
 949         protected Object readResolve() throws InvalidObjectException {
 950             if (this.getClass() != DateFormat.Field.class) {
 951                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
 952             }
 953 
 954             Object instance = instanceMap.get(getName());
 955             if (instance != null) {
 956                 return instance;
 957             } else {
 958                 throw new InvalidObjectException(&quot;unknown attribute name&quot;);
 959             }
 960         }
 961 
 962         //
 963         // The constants
 964         //
 965 
 966         /**
 967          * Constant identifying the era field.
 968          */
</pre>
</td>
</tr>
</table>
<center><a href="CompactNumberFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DateFormatSymbols.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
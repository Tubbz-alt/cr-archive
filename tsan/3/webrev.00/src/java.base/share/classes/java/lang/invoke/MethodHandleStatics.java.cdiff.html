<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/MethodHandleStatics.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleProxies.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleStatics.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
   * This class consists exclusively of static names internal to the
   * method handle implementation.
   * Usage:  {@code import static java.lang.invoke.MethodHandleStatics.*}
   * @author John Rose, JSR 292 EG
   */
<span class="line-modified">! /*non-public*/ class MethodHandleStatics {</span>
  
      private MethodHandleStatics() { }  // do not instantiate
  
      static final Unsafe UNSAFE = Unsafe.getUnsafe();
  
<span class="line-new-header">--- 34,12 ---</span>
   * This class consists exclusively of static names internal to the
   * method handle implementation.
   * Usage:  {@code import static java.lang.invoke.MethodHandleStatics.*}
   * @author John Rose, JSR 292 EG
   */
<span class="line-modified">! /*non-public*/</span>
<span class="line-added">+ class MethodHandleStatics {</span>
  
      private MethodHandleStatics() { }  // do not instantiate
  
      static final Unsafe UNSAFE = Unsafe.getUnsafe();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,45 ***</span>
      }
  
      /** Tell if any of the debugging switches are turned on.
       *  If this is the case, it is reasonable to perform extra checks or save extra information.
       */
<span class="line-modified">!     /*non-public*/ static boolean debugEnabled() {</span>
          return (DEBUG_METHOD_HANDLE_NAMES |
                  DUMP_CLASS_FILES |
                  TRACE_INTERPRETER |
                  TRACE_METHOD_LINKAGE |
                  LOG_LF_COMPILATION_FAILURE);
      }
  
      // handy shared exception makers (they simplify the common case code)
<span class="line-modified">!     /*non-public*/ static InternalError newInternalError(String message) {</span>
          return new InternalError(message);
      }
<span class="line-modified">!     /*non-public*/ static InternalError newInternalError(String message, Exception cause) {</span>
          return new InternalError(message, cause);
      }
<span class="line-modified">!     /*non-public*/ static InternalError newInternalError(Exception cause) {</span>
          return new InternalError(cause);
      }
<span class="line-modified">!     /*non-public*/ static RuntimeException newIllegalStateException(String message) {</span>
          return new IllegalStateException(message);
      }
<span class="line-modified">!     /*non-public*/ static RuntimeException newIllegalStateException(String message, Object obj) {</span>
          return new IllegalStateException(message(message, obj));
      }
<span class="line-modified">!     /*non-public*/ static RuntimeException newIllegalArgumentException(String message) {</span>
          return new IllegalArgumentException(message);
      }
<span class="line-modified">!     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj) {</span>
          return new IllegalArgumentException(message(message, obj));
      }
<span class="line-modified">!     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj, Object obj2) {</span>
          return new IllegalArgumentException(message(message, obj, obj2));
      }
      /** Propagate unchecked exceptions and errors, but wrap anything checked and throw that instead. */
<span class="line-modified">!     /*non-public*/ static Error uncaughtException(Throwable ex) {</span>
          if (ex instanceof Error)  throw (Error) ex;
          if (ex instanceof RuntimeException)  throw (RuntimeException) ex;
          throw new InternalError(&quot;uncaught exception&quot;, ex);
      }
      private static String message(String message, Object obj) {
<span class="line-new-header">--- 94,55 ---</span>
      }
  
      /** Tell if any of the debugging switches are turned on.
       *  If this is the case, it is reasonable to perform extra checks or save extra information.
       */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static boolean debugEnabled() {</span>
          return (DEBUG_METHOD_HANDLE_NAMES |
                  DUMP_CLASS_FILES |
                  TRACE_INTERPRETER |
                  TRACE_METHOD_LINKAGE |
                  LOG_LF_COMPILATION_FAILURE);
      }
  
      // handy shared exception makers (they simplify the common case code)
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static InternalError newInternalError(String message) {</span>
          return new InternalError(message);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static InternalError newInternalError(String message, Exception cause) {</span>
          return new InternalError(message, cause);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static InternalError newInternalError(Exception cause) {</span>
          return new InternalError(cause);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static RuntimeException newIllegalStateException(String message) {</span>
          return new IllegalStateException(message);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static RuntimeException newIllegalStateException(String message, Object obj) {</span>
          return new IllegalStateException(message(message, obj));
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static RuntimeException newIllegalArgumentException(String message) {</span>
          return new IllegalArgumentException(message);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static RuntimeException newIllegalArgumentException(String message, Object obj) {</span>
          return new IllegalArgumentException(message(message, obj));
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static RuntimeException newIllegalArgumentException(String message, Object obj, Object obj2) {</span>
          return new IllegalArgumentException(message(message, obj, obj2));
      }
      /** Propagate unchecked exceptions and errors, but wrap anything checked and throw that instead. */
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static Error uncaughtException(Throwable ex) {</span>
          if (ex instanceof Error)  throw (Error) ex;
          if (ex instanceof RuntimeException)  throw (RuntimeException) ex;
          throw new InternalError(&quot;uncaught exception&quot;, ex);
      }
      private static String message(String message, Object obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,15 ***</span>
      }
      private static String message(String message, Object obj, Object obj2) {
          if (obj != null || obj2 != null)  message = message + &quot;: &quot; + obj + &quot;, &quot; + obj2;
          return message;
      }
<span class="line-modified">!     /*non-public*/ static void rangeCheck2(int start, int end, int size) {</span>
          if (0 &gt; start || start &gt; end || end &gt; size)
              throw new IndexOutOfBoundsException(start+&quot;..&quot;+end);
      }
<span class="line-modified">!     /*non-public*/ static int rangeCheck1(int index, int size) {</span>
          if (0 &gt; index || index &gt;= size)
              throw new IndexOutOfBoundsException(index);
          return index;
      }
  }
<span class="line-new-header">--- 151,17 ---</span>
      }
      private static String message(String message, Object obj, Object obj2) {
          if (obj != null || obj2 != null)  message = message + &quot;: &quot; + obj + &quot;, &quot; + obj2;
          return message;
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static void rangeCheck2(int start, int end, int size) {</span>
          if (0 &gt; start || start &gt; end || end &gt; size)
              throw new IndexOutOfBoundsException(start+&quot;..&quot;+end);
      }
<span class="line-modified">!     /*non-public*/</span>
<span class="line-added">+     static int rangeCheck1(int index, int size) {</span>
          if (0 &gt; index || index &gt;= size)
              throw new IndexOutOfBoundsException(index);
          return index;
      }
  }
</pre>
<center><a href="MethodHandleProxies.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
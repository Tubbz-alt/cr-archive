<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/Long.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="LiveStackFrame.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Long.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -396,33 +396,41 @@</span>
              return new String(buf, UTF16);
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Format a long (treated as unsigned) into a character buffer. If</span>
<span class="udiff-line-modified-added">+      * Format a long (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
       * {@code len} exceeds the formatted ASCII representation of {@code val},
       * {@code buf} will be padded with leading zeroes.
       *
       * @param val the unsigned long to format
       * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="udiff-line-modified-removed">-      * @param buf the character buffer to write to</span>
<span class="udiff-line-modified-added">+      * @param buf the byte buffer to write to</span>
       * @param offset the offset in the destination buffer to start at
       * @param len the number of characters to write
       */
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     /** byte[]/LATIN1 version    */</span>
<span class="udiff-line-removed">-     static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>
<span class="udiff-line-modified-added">+     private static void formatUnsignedLong0(long val, int shift, byte[] buf, int offset, int len) {</span>
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              buf[--charPos] = (byte)Integer.digits[((int) val) &amp; mask];
              val &gt;&gt;&gt;= shift;
          } while (charPos &gt; offset);
      }
  
<span class="udiff-line-modified-removed">-     /** byte[]/UTF16 version    */</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-added">+      * Format a long (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="udiff-line-added">+      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="udiff-line-added">+      * {@code buf} will be padded with leading zeroes.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param val the unsigned long to format</span>
<span class="udiff-line-added">+      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="udiff-line-added">+      * @param buf the byte buffer to write to</span>
<span class="udiff-line-added">+      * @param offset the offset in the destination buffer to start at</span>
<span class="udiff-line-added">+      * @param len the number of characters to write</span>
<span class="udiff-line-added">+      */</span>
      private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {
          int charPos = offset + len;
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -737,11 +745,11 @@</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="udiff-line-modified-removed">-         s = Objects.requireNonNull(s);</span>
<span class="udiff-line-modified-added">+         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          if (radix &lt; Character.MIN_RADIX) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -983,11 +991,11 @@</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="udiff-line-modified-removed">-         s = Objects.requireNonNull(s);</span>
<span class="udiff-line-modified-added">+         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          int start = beginIndex, len = endIndex - beginIndex;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1337,29 +1345,29 @@</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code byte} after
       * a narrowing primitive conversion.
<span class="udiff-line-modified-removed">-      * @jls 5.1.3 Narrowing Primitive Conversions</span>
<span class="udiff-line-modified-added">+      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public byte byteValue() {
          return (byte)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code short} after
       * a narrowing primitive conversion.
<span class="udiff-line-modified-removed">-      * @jls 5.1.3 Narrowing Primitive Conversions</span>
<span class="udiff-line-modified-added">+      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public short shortValue() {
          return (short)value;
      }
  
      /**
       * Returns the value of this {@code Long} as an {@code int} after
       * a narrowing primitive conversion.
<span class="udiff-line-modified-removed">-      * @jls 5.1.3 Narrowing Primitive Conversions</span>
<span class="udiff-line-modified-added">+      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public int intValue() {
          return (int)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1373,20 +1381,20 @@</span>
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code float} after
       * a widening primitive conversion.
<span class="udiff-line-modified-removed">-      * @jls 5.1.2 Widening Primitive Conversions</span>
<span class="udiff-line-modified-added">+      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public float floatValue() {
          return (float)value;
      }
  
      /**
       * Returns the value of this {@code Long} as a {@code double}
       * after a widening primitive conversion.
<span class="udiff-line-modified-removed">-      * @jls 5.1.2 Widening Primitive Conversions</span>
<span class="udiff-line-modified-added">+      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public double doubleValue() {
          return (double)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1990,7 +1998,8 @@</span>
      public Long resolveConstantDesc(MethodHandles.Lookup lookup) {
          return this;
      }
  
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      @Native private static final long serialVersionUID = 4290774380558885855L;
  }
</pre>
<center><a href="LiveStackFrame.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Math.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
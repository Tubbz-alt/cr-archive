<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/SequenceInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Reader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Serializable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/SequenceInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.io.InputStream;
 29 import java.util.Enumeration;
 30 import java.util.Vector;
 31 
 32 /**
<span class="line-modified"> 33  * A &lt;code&gt;SequenceInputStream&lt;/code&gt; represents</span>
 34  * the logical concatenation of other input
 35  * streams. It starts out with an ordered
 36  * collection of input streams and reads from
 37  * the first one until end of file is reached,
 38  * whereupon it reads from the second one,
 39  * and so on, until end of file is reached
 40  * on the last of the contained input streams.
 41  *
 42  * @author  Author van Hoff
 43  * @since   1.0
 44  */
<span class="line-modified"> 45 public</span>
<span class="line-removed"> 46 class SequenceInputStream extends InputStream {</span>
 47     Enumeration&lt;? extends InputStream&gt; e;
 48     InputStream in;
 49 
 50     /**
<span class="line-modified"> 51      * Initializes a newly created &lt;code&gt;SequenceInputStream&lt;/code&gt;</span>
 52      * by remembering the argument, which must
<span class="line-modified"> 53      * be an &lt;code&gt;Enumeration&lt;/code&gt;  that produces</span>
<span class="line-modified"> 54      * objects whose run-time type is &lt;code&gt;InputStream&lt;/code&gt;.</span>
 55      * The input streams that are  produced by
 56      * the enumeration will be read, in order,
 57      * to provide the bytes to be read  from this
<span class="line-modified"> 58      * &lt;code&gt;SequenceInputStream&lt;/code&gt;. After</span>
 59      * each input stream from the enumeration
 60      * is exhausted, it is closed by calling its
<span class="line-modified"> 61      * &lt;code&gt;close&lt;/code&gt; method.</span>
 62      *
 63      * @param   e   an enumeration of input streams.
 64      * @see     java.util.Enumeration
 65      */
 66     public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) {
 67         this.e = e;
 68         peekNextStream();
 69     }
 70 
 71     /**
 72      * Initializes a newly
<span class="line-modified"> 73      * created &lt;code&gt;SequenceInputStream&lt;/code&gt;</span>
 74      * by remembering the two arguments, which
<span class="line-modified"> 75      * will be read in order, first &lt;code&gt;s1&lt;/code&gt;</span>
<span class="line-modified"> 76      * and then &lt;code&gt;s2&lt;/code&gt;, to provide the</span>
<span class="line-modified"> 77      * bytes to be read from this &lt;code&gt;SequenceInputStream&lt;/code&gt;.</span>
 78      *
 79      * @param   s1   the first input stream to read.
 80      * @param   s2   the second input stream to read.
 81      */
 82     public SequenceInputStream(InputStream s1, InputStream s2) {
 83         Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(2);
 84         v.addElement(s1);
 85         v.addElement(s2);
 86         e = v.elements();
 87         peekNextStream();
 88     }
 89 
 90     /**
<span class="line-modified"> 91      *  Continues reading in the next stream if an EOF is reached.</span>
 92      */
 93     final void nextStream() throws IOException {
 94         if (in != null) {
 95             in.close();
 96         }
 97         peekNextStream();
 98     }
 99 
100     private void peekNextStream() {
101         if (e.hasMoreElements()) {
102             in = (InputStream) e.nextElement();
103             if (in == null)
104                 throw new NullPointerException();
105         } else {
106             in = null;
107         }
108     }
109 
110     /**
111      * Returns an estimate of the number of bytes that can be read (or
112      * skipped over) from the current underlying input stream without
113      * blocking by the next invocation of a method for the current
114      * underlying input stream. The next invocation might be
115      * the same thread or another thread.  A single read or skip of this
116      * many bytes will not block, but may read or skip fewer bytes.
117      * &lt;p&gt;
118      * This method simply calls {@code available} of the current underlying
119      * input stream and returns the result.
120      *
<span class="line-modified">121      * @return an estimate of the number of bytes that can be read (or</span>
<span class="line-modified">122      *         skipped over) from the current underlying input stream</span>
<span class="line-modified">123      *         without blocking or {@code 0} if this input stream</span>
<span class="line-modified">124      *         has been closed by invoking its {@link #close()} method</span>
<span class="line-modified">125      * @exception  IOException  if an I/O error occurs.</span>
126      *
<span class="line-modified">127      * @since   1.1</span>
128      */
129     public int available() throws IOException {
130         if (in == null) {
131             return 0; // no way to signal EOF from available()
132         }
133         return in.available();
134     }
135 
136     /**
137      * Reads the next byte of data from this input stream. The byte is
<span class="line-modified">138      * returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to</span>
<span class="line-modified">139      * &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the</span>
<span class="line-modified">140      * stream has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned.</span>
141      * This method blocks until input data is available, the end of the
142      * stream is detected, or an exception is thrown.
143      * &lt;p&gt;
144      * This method
145      * tries to read one character from the current substream. If it
<span class="line-modified">146      * reaches the end of the stream, it calls the &lt;code&gt;close&lt;/code&gt;</span>
147      * method of the current substream and begins reading from the next
148      * substream.
149      *
<span class="line-modified">150      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
151      *             stream is reached.
<span class="line-modified">152      * @exception  IOException  if an I/O error occurs.</span>
153      */
154     public int read() throws IOException {
155         while (in != null) {
156             int c = in.read();
157             if (c != -1) {
158                 return c;
159             }
160             nextStream();
161         }
162         return -1;
163     }
164 
165     /**
<span class="line-modified">166      * Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream</span>
<span class="line-modified">167      * into an array of bytes.  If &lt;code&gt;len&lt;/code&gt; is not zero, the method</span>
168      * blocks until at least 1 byte of input is available; otherwise, no
<span class="line-modified">169      * bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</span>
170      * &lt;p&gt;
<span class="line-modified">171      * The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;SequenceInputStream&lt;/code&gt;</span>
172      * tries to read the data from the current substream. If it fails to
173      * read any characters because the substream has reached the end of
<span class="line-modified">174      * the stream, it calls the &lt;code&gt;close&lt;/code&gt; method of the current</span>
175      * substream and begins reading from the next substream.
176      *
177      * @param      b     the buffer into which the data is read.
<span class="line-modified">178      * @param      off   the start offset in array &lt;code&gt;b&lt;/code&gt;</span>
179      *                   at which the data is written.
180      * @param      len   the maximum number of bytes read.
181      * @return     int   the number of bytes read.
<span class="line-modified">182      * @exception  NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span>
<span class="line-modified">183      * @exception  IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,</span>
<span class="line-modified">184      * &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than</span>
<span class="line-modified">185      * &lt;code&gt;b.length - off&lt;/code&gt;</span>
<span class="line-modified">186      * @exception  IOException  if an I/O error occurs.</span>
187      */
188     public int read(byte b[], int off, int len) throws IOException {
189         if (in == null) {
190             return -1;
191         } else if (b == null) {
192             throw new NullPointerException();
193         } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
194             throw new IndexOutOfBoundsException();
195         } else if (len == 0) {
196             return 0;
197         }
198         do {
199             int n = in.read(b, off, len);
200             if (n &gt; 0) {
201                 return n;
202             }
203             nextStream();
204         } while (in != null);
205         return -1;
206     }
207 
208     /**
209      * Closes this input stream and releases any system resources
210      * associated with the stream.
<span class="line-modified">211      * A closed &lt;code&gt;SequenceInputStream&lt;/code&gt;</span>
212      * cannot  perform input operations and cannot
213      * be reopened.
214      * &lt;p&gt;
215      * If this stream was created
216      * from an enumeration, all remaining elements
217      * are requested from the enumeration and closed
<span class="line-modified">218      * before the &lt;code&gt;close&lt;/code&gt; method returns.</span>
219      *
<span class="line-modified">220      * @exception  IOException  if an I/O error occurs.</span>
221      */
222     public void close() throws IOException {
<span class="line-modified">223         do {</span>
<span class="line-modified">224             nextStream();</span>
<span class="line-modified">225         } while (in != null);</span>













226     }
227 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.io.InputStream;
 29 import java.util.Enumeration;
 30 import java.util.Vector;
 31 
 32 /**
<span class="line-modified"> 33  * A {@code SequenceInputStream} represents</span>
 34  * the logical concatenation of other input
 35  * streams. It starts out with an ordered
 36  * collection of input streams and reads from
 37  * the first one until end of file is reached,
 38  * whereupon it reads from the second one,
 39  * and so on, until end of file is reached
 40  * on the last of the contained input streams.
 41  *
 42  * @author  Author van Hoff
 43  * @since   1.0
 44  */
<span class="line-modified"> 45 public class SequenceInputStream extends InputStream {</span>

 46     Enumeration&lt;? extends InputStream&gt; e;
 47     InputStream in;
 48 
 49     /**
<span class="line-modified"> 50      * Initializes a newly created {@code SequenceInputStream}</span>
 51      * by remembering the argument, which must
<span class="line-modified"> 52      * be an {@code Enumeration}  that produces</span>
<span class="line-modified"> 53      * objects whose run-time type is {@code InputStream}.</span>
 54      * The input streams that are  produced by
 55      * the enumeration will be read, in order,
 56      * to provide the bytes to be read  from this
<span class="line-modified"> 57      * {@code SequenceInputStream}. After</span>
 58      * each input stream from the enumeration
 59      * is exhausted, it is closed by calling its
<span class="line-modified"> 60      * {@code close} method.</span>
 61      *
 62      * @param   e   an enumeration of input streams.
 63      * @see     java.util.Enumeration
 64      */
 65     public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) {
 66         this.e = e;
 67         peekNextStream();
 68     }
 69 
 70     /**
 71      * Initializes a newly
<span class="line-modified"> 72      * created {@code SequenceInputStream}</span>
 73      * by remembering the two arguments, which
<span class="line-modified"> 74      * will be read in order, first {@code s1}</span>
<span class="line-modified"> 75      * and then {@code s2}, to provide the</span>
<span class="line-modified"> 76      * bytes to be read from this {@code SequenceInputStream}.</span>
 77      *
 78      * @param   s1   the first input stream to read.
 79      * @param   s2   the second input stream to read.
 80      */
 81     public SequenceInputStream(InputStream s1, InputStream s2) {
 82         Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(2);
 83         v.addElement(s1);
 84         v.addElement(s2);
 85         e = v.elements();
 86         peekNextStream();
 87     }
 88 
 89     /**
<span class="line-modified"> 90      * Continues reading in the next stream if an EOF is reached.</span>
 91      */
 92     final void nextStream() throws IOException {
 93         if (in != null) {
 94             in.close();
 95         }
 96         peekNextStream();
 97     }
 98 
 99     private void peekNextStream() {
100         if (e.hasMoreElements()) {
101             in = (InputStream) e.nextElement();
102             if (in == null)
103                 throw new NullPointerException();
104         } else {
105             in = null;
106         }
107     }
108 
109     /**
110      * Returns an estimate of the number of bytes that can be read (or
111      * skipped over) from the current underlying input stream without
112      * blocking by the next invocation of a method for the current
113      * underlying input stream. The next invocation might be
114      * the same thread or another thread.  A single read or skip of this
115      * many bytes will not block, but may read or skip fewer bytes.
116      * &lt;p&gt;
117      * This method simply calls {@code available} of the current underlying
118      * input stream and returns the result.
119      *
<span class="line-modified">120      * @return   an estimate of the number of bytes that can be read (or</span>
<span class="line-modified">121      *           skipped over) from the current underlying input stream</span>
<span class="line-modified">122      *           without blocking or {@code 0} if this input stream</span>
<span class="line-modified">123      *           has been closed by invoking its {@link #close()} method</span>
<span class="line-modified">124      * @throw    IOException  if an I/O error occurs.</span>
125      *
<span class="line-modified">126      * @since    1.1</span>
127      */
128     public int available() throws IOException {
129         if (in == null) {
130             return 0; // no way to signal EOF from available()
131         }
132         return in.available();
133     }
134 
135     /**
136      * Reads the next byte of data from this input stream. The byte is
<span class="line-modified">137      * returned as an {@code int} in the range {@code 0} to</span>
<span class="line-modified">138      * {@code 255}. If no byte is available because the end of the</span>
<span class="line-modified">139      * stream has been reached, the value {@code -1} is returned.</span>
140      * This method blocks until input data is available, the end of the
141      * stream is detected, or an exception is thrown.
142      * &lt;p&gt;
143      * This method
144      * tries to read one character from the current substream. If it
<span class="line-modified">145      * reaches the end of the stream, it calls the {@code close}</span>
146      * method of the current substream and begins reading from the next
147      * substream.
148      *
<span class="line-modified">149      * @return     the next byte of data, or {@code -1} if the end of the</span>
150      *             stream is reached.
<span class="line-modified">151      * @throws     IOException  if an I/O error occurs.</span>
152      */
153     public int read() throws IOException {
154         while (in != null) {
155             int c = in.read();
156             if (c != -1) {
157                 return c;
158             }
159             nextStream();
160         }
161         return -1;
162     }
163 
164     /**
<span class="line-modified">165      * Reads up to {@code len} bytes of data from this input stream</span>
<span class="line-modified">166      * into an array of bytes.  If {@code len} is not zero, the method</span>
167      * blocks until at least 1 byte of input is available; otherwise, no
<span class="line-modified">168      * bytes are read and {@code 0} is returned.</span>
169      * &lt;p&gt;
<span class="line-modified">170      * The {@code read} method of {@code SequenceInputStream}</span>
171      * tries to read the data from the current substream. If it fails to
172      * read any characters because the substream has reached the end of
<span class="line-modified">173      * the stream, it calls the {@code close} method of the current</span>
174      * substream and begins reading from the next substream.
175      *
176      * @param      b     the buffer into which the data is read.
<span class="line-modified">177      * @param      off   the start offset in array {@code b}</span>
178      *                   at which the data is written.
179      * @param      len   the maximum number of bytes read.
180      * @return     int   the number of bytes read.
<span class="line-modified">181      * @throws     NullPointerException If {@code b} is {@code null}.</span>
<span class="line-modified">182      * @throws     IndexOutOfBoundsException If {@code off} is negative,</span>
<span class="line-modified">183      *             {@code len} is negative, or {@code len} is</span>
<span class="line-modified">184      *             greater than {@code b.length - off}</span>
<span class="line-modified">185      * @throws     IOException  if an I/O error occurs.</span>
186      */
187     public int read(byte b[], int off, int len) throws IOException {
188         if (in == null) {
189             return -1;
190         } else if (b == null) {
191             throw new NullPointerException();
192         } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
193             throw new IndexOutOfBoundsException();
194         } else if (len == 0) {
195             return 0;
196         }
197         do {
198             int n = in.read(b, off, len);
199             if (n &gt; 0) {
200                 return n;
201             }
202             nextStream();
203         } while (in != null);
204         return -1;
205     }
206 
207     /**
208      * Closes this input stream and releases any system resources
209      * associated with the stream.
<span class="line-modified">210      * A closed {@code SequenceInputStream}</span>
211      * cannot  perform input operations and cannot
212      * be reopened.
213      * &lt;p&gt;
214      * If this stream was created
215      * from an enumeration, all remaining elements
216      * are requested from the enumeration and closed
<span class="line-modified">217      * before the {@code close} method returns.</span>
218      *
<span class="line-modified">219      * @throws     IOException  if an I/O error occurs.</span>
220      */
221     public void close() throws IOException {
<span class="line-modified">222         IOException ioe = null;</span>
<span class="line-modified">223         while (in != null) {</span>
<span class="line-modified">224             try {</span>
<span class="line-added">225                 in.close();</span>
<span class="line-added">226             } catch (IOException e) {</span>
<span class="line-added">227                 if (ioe == null) {</span>
<span class="line-added">228                     ioe = e;</span>
<span class="line-added">229                 } else {</span>
<span class="line-added">230                     ioe.addSuppressed(e);</span>
<span class="line-added">231                 }</span>
<span class="line-added">232             }</span>
<span class="line-added">233             peekNextStream();</span>
<span class="line-added">234         }</span>
<span class="line-added">235         if (ioe != null) {</span>
<span class="line-added">236             throw ioe;</span>
<span class="line-added">237         }</span>
238     }
239 }
</pre>
</td>
</tr>
</table>
<center><a href="Reader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Serializable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
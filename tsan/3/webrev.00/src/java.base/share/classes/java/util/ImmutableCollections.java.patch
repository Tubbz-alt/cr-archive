diff a/src/java.base/share/classes/java/util/ImmutableCollections.java b/src/java.base/share/classes/java/util/ImmutableCollections.java
--- a/src/java.base/share/classes/java/util/ImmutableCollections.java
+++ b/src/java.base/share/classes/java/util/ImmutableCollections.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -53,14 +53,60 @@
      * A "salt" value used for randomizing iteration order. This is initialized once
      * and stays constant for the lifetime of the JVM. It need not be truly random, but
      * it needs to vary sufficiently from one run to the next so that iteration order
      * will vary between JVM runs.
      */
-    static final int SALT;
+    private static final long SALT32L;
+
+    /**
+     * For set and map iteration, we will iterate in "reverse" stochastically,
+     * decided at bootstrap time.
+     */
+    private static final boolean REVERSE;
+    static {
+        // to generate a reasonably random and well-mixed SALT, use an arbitrary
+        // value (a slice of pi), multiply with the System.nanoTime, then pick
+        // the mid 32-bits from the product. By picking a SALT value in the
+        // [0 ... 0xFFFF_FFFFL == 2^32-1] range, we ensure that for any positive
+        // int N, (SALT32L * N) >> 32 is a number in the [0 ... N-1] range. This
+        // property will be used to avoid more expensive modulo-based
+        // calculations.
+        long color = 0x243F_6A88_85A3_08D3L; // slice of pi
+        long seed = System.nanoTime();
+        SALT32L = (int)((color * seed) >> 16) & 0xFFFF_FFFFL;
+        // use the lowest bit to determine if we should reverse iteration
+        REVERSE = (SALT32L & 1) == 0;
+    }
+
+    /**
+     * Constants following this might be initialized from the CDS archive via
+     * this array.
+     */
+    private static Object[] archivedObjects;
+
+    private static final Object EMPTY;
+
+    static final ListN<?> EMPTY_LIST;
+
+    static final SetN<?> EMPTY_SET;
+
+    static final MapN<?,?> EMPTY_MAP;
+
     static {
-        long nt = System.nanoTime();
-        SALT = (int)((nt >>> 32) ^ nt);
+        VM.initializeFromArchive(ImmutableCollections.class);
+        if (archivedObjects == null) {
+            EMPTY = new Object();
+            EMPTY_LIST = new ListN<>();
+            EMPTY_SET = new SetN<>();
+            EMPTY_MAP = new MapN<>();
+            archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };
+        } else {
+            EMPTY = archivedObjects[0];
+            EMPTY_LIST = (ListN)archivedObjects[1];
+            EMPTY_SET = (SetN)archivedObjects[2];
+            EMPTY_MAP = (MapN)archivedObjects[3];
+        }
     }
 
     /** No instances. */
     private ImmutableCollections() { }
 
@@ -93,15 +139,10 @@
         } else {
             return (List<E>)List.of(coll.toArray());
         }
     }
 
-    @SuppressWarnings("unchecked")
-    static <E> List<E> emptyList() {
-        return (List<E>) ListN.EMPTY_LIST;
-    }
-
     static abstract class AbstractImmutableList<E> extends AbstractImmutableCollection<E>
             implements List<E>, RandomAccess {
 
         // all mutating methods throw UnsupportedOperationException
         @Override public void    add(int index, E element) { throw uoe(); }
@@ -389,62 +430,72 @@
 
         @Stable
         private final E e0;
 
         @Stable
-        private final E e1;
+        private final Object e1;
 
         List12(E e0) {
             this.e0 = Objects.requireNonNull(e0);
-            this.e1 = null;
+            // Use EMPTY as a sentinel for an unused element: not using null
+            // enable constant folding optimizations over single-element lists
+            this.e1 = EMPTY;
         }
 
         List12(E e0, E e1) {
             this.e0 = Objects.requireNonNull(e0);
             this.e1 = Objects.requireNonNull(e1);
         }
 
         @Override
         public int size() {
-            return e1 != null ? 2 : 1;
+            return e1 != EMPTY ? 2 : 1;
         }
 
         @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        @SuppressWarnings("unchecked")
         public E get(int index) {
             if (index == 0) {
                 return e0;
-            } else if (index == 1 && e1 != null) {
-                return e1;
+            } else if (index == 1 && e1 != EMPTY) {
+                return (E)e1;
             }
             throw outOfBounds(index);
         }
 
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
-            if (e1 == null) {
+            if (e1 == EMPTY) {
                 return new CollSer(CollSer.IMM_LIST, e0);
             } else {
                 return new CollSer(CollSer.IMM_LIST, e0, e1);
             }
         }
 
         @Override
         public Object[] toArray() {
-            if (e1 == null) {
+            if (e1 == EMPTY) {
                 return new Object[] { e0 };
             } else {
                 return new Object[] { e0, e1 };
             }
         }
 
         @Override
         @SuppressWarnings("unchecked")
         public <T> T[] toArray(T[] a) {
-            int size = e1 == null ? 1 : 2;
+            int size = size();
             T[] array = a.length >= size ? a :
                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
             array[0] = (T)e0;
             if (size == 2) {
                 array[1] = (T)e1;
@@ -457,20 +508,10 @@
     }
 
     static final class ListN<E> extends AbstractImmutableList<E>
             implements Serializable {
 
-        // EMPTY_LIST may be initialized from the CDS archive.
-        static @Stable List<?> EMPTY_LIST;
-
-        static {
-            VM.initializeFromArchive(ListN.class);
-            if (EMPTY_LIST == null) {
-                EMPTY_LIST = new ListN<>();
-            }
-        }
-
         @Stable
         private final E[] elements;
 
         @SafeVarargs
         ListN(E... input) {
@@ -483,11 +524,11 @@
             elements = tmp;
         }
 
         @Override
         public boolean isEmpty() {
-            return size() == 0;
+            return elements.length == 0;
         }
 
         @Override
         public int size() {
             return elements.length;
@@ -496,14 +537,16 @@
         @Override
         public E get(int index) {
             return elements[index];
         }
 
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
             return new CollSer(CollSer.IMM_LIST, elements);
         }
 
         @Override
@@ -554,26 +597,24 @@
 
         @Override
         public abstract int hashCode();
     }
 
-    @SuppressWarnings("unchecked")
-    static <E> Set<E> emptySet() {
-        return (Set<E>) SetN.EMPTY_SET;
-    }
-
     static final class Set12<E> extends AbstractImmutableSet<E>
             implements Serializable {
 
         @Stable
-        final E e0;
+        private final E e0;
+
         @Stable
-        final E e1;
+        private final Object e1;
 
         Set12(E e0) {
             this.e0 = Objects.requireNonNull(e0);
-            this.e1 = null;
+            // Use EMPTY as a sentinel for an unused element: not using null
+            // enable constant folding optimizations over single-element sets
+            this.e1 = EMPTY;
         }
 
         Set12(E e0, E e1) {
             if (e0.equals(Objects.requireNonNull(e1))) { // implicit nullcheck of e0
                 throw new IllegalArgumentException("duplicate element: " + e0);
@@ -583,80 +624,88 @@
             this.e1 = e1;
         }
 
         @Override
         public int size() {
-            return (e1 == null) ? 1 : 2;
+            return (e1 == EMPTY) ? 1 : 2;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
         }
 
         @Override
         public boolean contains(Object o) {
-            return o.equals(e0) || o.equals(e1); // implicit nullcheck of o
+            return o.equals(e0) || e1.equals(o); // implicit nullcheck of o
         }
 
         @Override
         public int hashCode() {
-            return e0.hashCode() + (e1 == null ? 0 : e1.hashCode());
+            return e0.hashCode() + (e1 == EMPTY ? 0 : e1.hashCode());
         }
 
         @Override
         public Iterator<E> iterator() {
             return new Iterator<>() {
-                private int idx = size();
+                private int idx = (e1 == EMPTY) ? 1 : 2;
 
                 @Override
                 public boolean hasNext() {
                     return idx > 0;
                 }
 
                 @Override
+                @SuppressWarnings("unchecked")
                 public E next() {
                     if (idx == 1) {
                         idx = 0;
-                        return SALT >= 0 || e1 == null ? e0 : e1;
+                        return (REVERSE || e1 == EMPTY) ? e0 : (E)e1;
                     } else if (idx == 2) {
                         idx = 1;
-                        return SALT >= 0 ? e1 : e0;
+                        return REVERSE ? (E)e1 : e0;
                     } else {
                         throw new NoSuchElementException();
                     }
                 }
             };
         }
 
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
-            if (e1 == null) {
+            if (e1 == EMPTY) {
                 return new CollSer(CollSer.IMM_SET, e0);
             } else {
                 return new CollSer(CollSer.IMM_SET, e0, e1);
             }
         }
 
         @Override
         public Object[] toArray() {
-            if (e1 == null) {
+            if (e1 == EMPTY) {
                 return new Object[] { e0 };
-            } else if (SALT >= 0) {
+            } else if (REVERSE) {
                 return new Object[] { e1, e0 };
             } else {
                 return new Object[] { e0, e1 };
             }
         }
 
         @Override
         @SuppressWarnings("unchecked")
         public <T> T[] toArray(T[] a) {
-            int size = e1 == null ? 1 : 2;
+            int size = size();
             T[] array = a.length >= size ? a :
                     (T[])Array.newInstance(a.getClass().getComponentType(), size);
             if (size == 1) {
                 array[0] = (T)e0;
-            } else if (SALT >= 0) {
+            } else if (REVERSE) {
                 array[0] = (T)e1;
                 array[1] = (T)e0;
             } else {
                 array[0] = (T)e0;
                 array[1] = (T)e1;
@@ -676,22 +725,13 @@
      * @param <E> the element type
      */
     static final class SetN<E> extends AbstractImmutableSet<E>
             implements Serializable {
 
-        // EMPTY_SET may be initialized from the CDS archive.
-        static @Stable Set<?> EMPTY_SET;
-
-        static {
-            VM.initializeFromArchive(SetN.class);
-            if (EMPTY_SET == null) {
-                EMPTY_SET = new SetN<>();
-            }
-        }
-
         @Stable
         final E[] elements;
+
         @Stable
         final int size;
 
         @SafeVarargs
         @SuppressWarnings("unchecked")
@@ -713,10 +753,15 @@
         @Override
         public int size() {
             return size;
         }
 
+        @Override
+        public boolean isEmpty() {
+            return size == 0;
+        }
+
         @Override
         public boolean contains(Object o) {
             Objects.requireNonNull(o);
             return size > 0 && probe(o) >= 0;
         }
@@ -726,41 +771,40 @@
             private int remaining;
 
             private int idx;
 
             SetNIterator() {
-                remaining = size();
-                if (remaining > 0) {
-                    idx = Math.floorMod(SALT, elements.length);
-                }
+                remaining = size;
+                // pick a starting index in the [0 .. element.length-1] range
+                // randomly based on SALT32L
+                idx = (int) ((SALT32L * elements.length) >>> 32);
             }
 
             @Override
             public boolean hasNext() {
                 return remaining > 0;
             }
 
-            private int nextIndex() {
-                int idx = this.idx;
-                if (SALT >= 0) {
-                    if (++idx >= elements.length) {
-                        idx = 0;
-                    }
-                } else {
-                    if (--idx < 0) {
-                        idx = elements.length - 1;
-                    }
-                }
-                return this.idx = idx;
-            }
-
             @Override
             public E next() {
                 if (remaining > 0) {
                     E element;
-                    // skip null elements
-                    while ((element = elements[nextIndex()]) == null) {}
+                    int idx = this.idx;
+                    int len = elements.length;
+                    // step to the next element; skip null elements
+                    do {
+                        if (REVERSE) {
+                            if (++idx >= len) {
+                                idx = 0;
+                            }
+                        } else {
+                            if (--idx < 0) {
+                                idx = len - 1;
+                            }
+                        }
+                    } while ((element = elements[idx]) == null);
+                    this.idx = idx;
                     remaining--;
                     return element;
                 } else {
                     throw new NoSuchElementException();
                 }
@@ -799,14 +843,16 @@
                     idx = 0;
                 }
             }
         }
 
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
             Object[] array = new Object[size];
             int dest = 0;
             for (Object o : elements) {
                 if (o != null) {
@@ -842,15 +888,10 @@
         }
     }
 
     // ---------- Map Implementations ----------
 
-    @SuppressWarnings("unchecked")
-    static <K,V> Map<K,V> emptyMap() {
-        return (Map<K,V>) MapN.EMPTY_MAP;
-    }
-
     abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {
         @Override public void clear() { throw uoe(); }
         @Override public V compute(K key, BiFunction<? super K,? super V,? extends V> rf) { throw uoe(); }
         @Override public V computeIfAbsent(K key, Function<? super K,? extends V> mf) { throw uoe(); }
         @Override public V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> rf) { throw uoe(); }
@@ -861,10 +902,24 @@
         @Override public V remove(Object key) { throw uoe(); }
         @Override public boolean remove(Object key, Object value) { throw uoe(); }
         @Override public V replace(K key, V value) { throw uoe(); }
         @Override public boolean replace(K key, V oldValue, V newValue) { throw uoe(); }
         @Override public void replaceAll(BiFunction<? super K,? super V,? extends V> f) { throw uoe(); }
+
+        /**
+         * @implNote {@code null} values are disallowed in these immutable maps,
+         * so we can improve upon the default implementation since a
+         * {@code null} return from {@code get(key)} always means the default
+         * value should be returned.
+         */
+        @Override
+        public V getOrDefault(Object key, V defaultValue) {
+            V v;
+            return ((v = get(key)) != null)
+                    ? v
+                    : defaultValue;
+        }
     }
 
     static final class Map1<K,V> extends AbstractImmutableMap<K,V> {
         @Stable
         private final K k0;
@@ -879,24 +934,41 @@
         @Override
         public Set<Map.Entry<K,V>> entrySet() {
             return Set.of(new KeyValueHolder<>(k0, v0));
         }
 
+        @Override
+        public V get(Object o) {
+            return o.equals(k0) ? v0 : null; // implicit nullcheck of o
+        }
+
         @Override
         public boolean containsKey(Object o) {
             return o.equals(k0); // implicit nullcheck of o
         }
 
         @Override
         public boolean containsValue(Object o) {
             return o.equals(v0); // implicit nullcheck of o
         }
 
+        @Override
+        public int size() {
+            return 1;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
             return new CollSer(CollSer.IMM_MAP, k0, v0);
         }
 
         @Override
@@ -914,20 +986,10 @@
      * @param <K> the key type
      * @param <V> the value type
      */
     static final class MapN<K,V> extends AbstractImmutableMap<K,V> {
 
-        // EMPTY_MAP may be initialized from the CDS archive.
-        static @Stable Map<?,?> EMPTY_MAP;
-
-        static {
-            VM.initializeFromArchive(MapN.class);
-            if (EMPTY_MAP == null) {
-                EMPTY_MAP = new MapN<>();
-            }
-        }
-
         @Stable
         final Object[] table; // pairs of key, value
 
         @Stable
         final int size; // number of pairs
@@ -1006,31 +1068,36 @@
         @Override
         public int size() {
             return size;
         }
 
+        @Override
+        public boolean isEmpty() {
+            return size == 0;
+        }
+
         class MapNIterator implements Iterator<Map.Entry<K,V>> {
 
             private int remaining;
 
             private int idx;
 
             MapNIterator() {
-                remaining = size();
-                if (remaining > 0) {
-                    idx = Math.floorMod(SALT, table.length >> 1) << 1;
-                }
+                remaining = size;
+                // pick an even starting index in the [0 .. table.length-1]
+                // range randomly based on SALT32L
+                idx = (int) ((SALT32L * (table.length >> 1)) >>> 32) << 1;
             }
 
             @Override
             public boolean hasNext() {
                 return remaining > 0;
             }
 
             private int nextIndex() {
                 int idx = this.idx;
-                if (SALT >= 0) {
+                if (REVERSE) {
                     if ((idx += 2) >= table.length) {
                         idx = 0;
                     }
                 } else {
                     if ((idx -= 2) < 0) {
@@ -1088,14 +1155,16 @@
                     idx = 0;
                 }
             }
         }
 
+        @java.io.Serial
         private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
             throw new InvalidObjectException("not serial proxy");
         }
 
+        @java.io.Serial
         private Object writeReplace() {
             Object[] array = new Object[2 * size];
             int len = table.length;
             int dest = 0;
             for (int i = 0; i < len; i += 2) {
@@ -1116,10 +1185,11 @@
  *
  * @serial
  * @since 9
  */
 final class CollSer implements Serializable {
+    @java.io.Serial
     private static final long serialVersionUID = 6309168927139932177L;
 
     static final int IMM_LIST = 1;
     static final int IMM_SET = 2;
     static final int IMM_MAP = 3;
@@ -1176,10 +1246,11 @@
      * @throws IOException if an I/O error occurs
      * @throws ClassNotFoundException if a serialized class cannot be loaded
      * @throws InvalidObjectException if the count is negative
      * @since 9
      */
+    @java.io.Serial
     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
         ois.defaultReadObject();
         int len = ois.readInt();
 
         if (len < 0) {
@@ -1205,10 +1276,11 @@
      *
      * @param oos the ObjectOutputStream to which data is written
      * @throws IOException if an I/O error occurs
      * @since 9
      */
+    @java.io.Serial
     private void writeObject(ObjectOutputStream oos) throws IOException {
         oos.defaultWriteObject();
         oos.writeInt(array.length);
         for (int i = 0; i < array.length; i++) {
             oos.writeObject(array[i]);
@@ -1231,10 +1303,11 @@
      * @throws InvalidObjectException if the tag value is illegal or if an exception
      *         is thrown during creation of the collection
      * @throws ObjectStreamException if another serialization error has occurred
      * @since 9
      */
+   @java.io.Serial
     private Object readResolve() throws ObjectStreamException {
         try {
             if (array == null) {
                 throw new InvalidObjectException("null array");
             }
@@ -1246,11 +1319,11 @@
                     return List.of(array);
                 case IMM_SET:
                     return Set.of(array);
                 case IMM_MAP:
                     if (array.length == 0) {
-                        return ImmutableCollections.emptyMap();
+                        return ImmutableCollections.EMPTY_MAP;
                     } else if (array.length == 2) {
                         return new ImmutableCollections.Map1<>(array[0], array[1]);
                     } else {
                         return new ImmutableCollections.MapN<>(array);
                     }

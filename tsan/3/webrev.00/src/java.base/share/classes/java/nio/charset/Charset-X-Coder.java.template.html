<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/nio/charset/Charset-X-Coder.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #warn This file is preprocessed before being compiled
  27 
  28 package java.nio.charset;
  29 
  30 import java.nio.Buffer;
  31 import java.nio.ByteBuffer;
  32 import java.nio.CharBuffer;
  33 import java.nio.BufferOverflowException;
  34 import java.nio.BufferUnderflowException;
  35 import java.lang.ref.WeakReference;
  36 import java.nio.charset.CoderMalfunctionError;                  // javadoc
  37 import java.util.Arrays;
  38 
  39 
  40 /**
  41  * An engine that can transform a sequence of $itypesPhrase$ into a sequence of
  42  * $otypesPhrase$.
  43  *
  44  * &lt;a id=&quot;steps&quot;&gt;&lt;/a&gt;
  45  *
  46  * &lt;p&gt; The input $itype$ sequence is provided in a $itype$ buffer or a series
  47  * of such buffers.  The output $otype$ sequence is written to a $otype$ buffer
  48  * or a series of such buffers.  $A$ $coder$ should always be used by making
  49  * the following sequence of method invocations, hereinafter referred to as $a$
  50  * &lt;i&gt;$coding$ operation&lt;/i&gt;:
  51  *
  52  * &lt;ol&gt;
  53  *
  54  *   &lt;li&gt;&lt;p&gt; Reset the $coder$ via the {@link #reset reset} method, unless it
  55  *   has not been used before; &lt;/p&gt;&lt;/li&gt;
  56  *
  57  *   &lt;li&gt;&lt;p&gt; Invoke the {@link #$code$ $code$} method zero or more times, as
  58  *   long as additional input may be available, passing {@code false} for the
  59  *   {@code endOfInput} argument and filling the input buffer and flushing the
  60  *   output buffer between invocations; &lt;/p&gt;&lt;/li&gt;
  61  *
  62  *   &lt;li&gt;&lt;p&gt; Invoke the {@link #$code$ $code$} method one final time, passing
  63  *   {@code true} for the {@code endOfInput} argument; and then &lt;/p&gt;&lt;/li&gt;
  64  *
  65  *   &lt;li&gt;&lt;p&gt; Invoke the {@link #flush flush} method so that the $coder$ can
  66  *   flush any internal state to the output buffer. &lt;/p&gt;&lt;/li&gt;
  67  *
  68  * &lt;/ol&gt;
  69  *
  70  * Each invocation of the {@link #$code$ $code$} method will $code$ as many
  71  * $itype$s as possible from the input buffer, writing the resulting $otype$s
  72  * to the output buffer.  The {@link #$code$ $code$} method returns when more
  73  * input is required, when there is not enough room in the output buffer, or
  74  * when $a$ $coding$ error has occurred.  In each case a {@link CoderResult}
  75  * object is returned to describe the reason for termination.  An invoker can
  76  * examine this object and fill the input buffer, flush the output buffer, or
  77  * attempt to recover from $a$ $coding$ error, as appropriate, and try again.
  78  *
  79  * &lt;a id=&quot;ce&quot;&gt;&lt;/a&gt;
  80  *
  81  * &lt;p&gt; There are two general types of $coding$ errors.  If the input $itype$
  82  * sequence is $notLegal$ then the input is considered &lt;i&gt;malformed&lt;/i&gt;.  If
  83  * the input $itype$ sequence is legal but cannot be mapped to a valid
  84  * $outSequence$ then an &lt;i&gt;unmappable character&lt;/i&gt; has been encountered.
  85  *
  86  * &lt;a id=&quot;cae&quot;&gt;&lt;/a&gt;
  87  *
  88  * &lt;p&gt; How $a$ $coding$ error is handled depends upon the action requested for
  89  * that type of error, which is described by an instance of the {@link
  90  * CodingErrorAction} class.  The possible error actions are to {@linkplain
  91  * CodingErrorAction#IGNORE ignore} the erroneous input, {@linkplain
  92  * CodingErrorAction#REPORT report} the error to the invoker via
  93  * the returned {@link CoderResult} object, or {@linkplain CodingErrorAction#REPLACE
  94  * replace} the erroneous input with the current value of the
  95  * replacement $replTypeName$.  The replacement
  96  *
  97 #if[encoder]
  98  * is initially set to the $coder$&#39;s default replacement, which often
  99  * (but not always) has the initial value&amp;nbsp;$defaultReplName$;
 100 #end[encoder]
 101 #if[decoder]
 102  * has the initial value $defaultReplName$;
 103 #end[decoder]
 104  *
 105  * its value may be changed via the {@link #replaceWith($replFQType$)
 106  * replaceWith} method.
 107  *
 108  * &lt;p&gt; The default action for malformed-input and unmappable-character errors
 109  * is to {@linkplain CodingErrorAction#REPORT report} them.  The
 110  * malformed-input error action may be changed via the {@link
 111  * #onMalformedInput(CodingErrorAction) onMalformedInput} method; the
 112  * unmappable-character action may be changed via the {@link
 113  * #onUnmappableCharacter(CodingErrorAction) onUnmappableCharacter} method.
 114  *
 115  * &lt;p&gt; This class is designed to handle many of the details of the $coding$
 116  * process, including the implementation of error actions.  $A$ $coder$ for a
 117  * specific charset, which is a concrete subclass of this class, need only
 118  * implement the abstract {@link #$code$Loop $code$Loop} method, which
 119  * encapsulates the basic $coding$ loop.  A subclass that maintains internal
 120  * state should, additionally, override the {@link #implFlush implFlush} and
 121  * {@link #implReset implReset} methods.
 122  *
 123  * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
 124  * threads.  &lt;/p&gt;
 125  *
 126  *
 127  * @author Mark Reinhold
 128  * @author JSR-51 Expert Group
 129  * @since 1.4
 130  *
 131  * @see ByteBuffer
 132  * @see CharBuffer
 133  * @see Charset
 134  * @see Charset$OtherCoder$
 135  */
 136 
 137 public abstract class Charset$Coder$ {
 138 
 139     private final Charset charset;
 140     private final float average$ItypesPerOtype$;
 141     private final float max$ItypesPerOtype$;
 142 
 143     private $replType$ replacement;
 144     private CodingErrorAction malformedInputAction
 145         = CodingErrorAction.REPORT;
 146     private CodingErrorAction unmappableCharacterAction
 147         = CodingErrorAction.REPORT;
 148 
 149     // Internal states
 150     //
 151     private static final int ST_RESET   = 0;
 152     private static final int ST_CODING  = 1;
 153     private static final int ST_END     = 2;
 154     private static final int ST_FLUSHED = 3;
 155 
 156     private int state = ST_RESET;
 157 
 158     private static String stateNames[]
 159         = { &quot;RESET&quot;, &quot;CODING&quot;, &quot;CODING_END&quot;, &quot;FLUSHED&quot; };
 160 
 161 
 162     /**
 163      * Initializes a new $coder$.  The new $coder$ will have the given
 164      * $otypes-per-itype$ and replacement values.
 165      *
 166      * @param  cs
 167      *         The charset that created this $coder$
 168      *
 169      * @param  average$ItypesPerOtype$
 170      *         A positive float value indicating the expected number of
 171      *         $otype$s that will be produced for each input $itype$
 172      *
 173      * @param  max$ItypesPerOtype$
 174      *         A positive float value indicating the maximum number of
 175      *         $otype$s that will be produced for each input $itype$
 176      *
 177      * @param  replacement
 178      *         The initial replacement; must not be {@code null}, must have
 179      *         non-zero length, must not be longer than max$ItypesPerOtype$,
 180      *         and must be {@linkplain #isLegalReplacement legal}
 181      *
 182      * @throws  IllegalArgumentException
 183      *          If the preconditions on the parameters do not hold
 184      */
 185     {#if[encoder]?protected:private}
 186     Charset$Coder$(Charset cs,
 187                    float average$ItypesPerOtype$,
 188                    float max$ItypesPerOtype$,
 189                    $replType$ replacement)
 190     {
 191         this.charset = cs;
 192         // Use !(a &gt; 0.0f) rather than (a &lt;= 0.0f) to exclude NaN values
 193         if (!(average$ItypesPerOtype$ &gt; 0.0f))
 194             throw new IllegalArgumentException(&quot;Non-positive &quot;
 195                                                + &quot;average$ItypesPerOtype$&quot;);
 196         // Use !(a &gt; 0.0f) rather than (a &lt;= 0.0f) to exclude NaN values
 197         if (!(max$ItypesPerOtype$ &gt; 0.0f))
 198             throw new IllegalArgumentException(&quot;Non-positive &quot;
 199                                                + &quot;max$ItypesPerOtype$&quot;);
 200         if (average$ItypesPerOtype$ &gt; max$ItypesPerOtype$)
 201             throw new IllegalArgumentException(&quot;average$ItypesPerOtype$&quot;
 202                                                + &quot; exceeds &quot;
 203                                                + &quot;max$ItypesPerOtype$&quot;);
 204         this.replacement = replacement;
 205         this.average$ItypesPerOtype$ = average$ItypesPerOtype$;
 206         this.max$ItypesPerOtype$ = max$ItypesPerOtype$;
 207         replaceWith(replacement);
 208     }
 209 
 210     /**
 211      * Initializes a new $coder$.  The new $coder$ will have the given
 212      * $otypes-per-itype$ values and its replacement will be the
 213      * $replTypeName$ $defaultReplName$.
 214      *
 215      * @param  cs
 216      *         The charset that created this $coder$
 217      *
 218      * @param  average$ItypesPerOtype$
 219      *         A positive float value indicating the expected number of
 220      *         $otype$s that will be produced for each input $itype$
 221      *
 222      * @param  max$ItypesPerOtype$
 223      *         A positive float value indicating the maximum number of
 224      *         $otype$s that will be produced for each input $itype$
 225      *
 226      * @throws  IllegalArgumentException
 227      *          If the preconditions on the parameters do not hold
 228      */
 229     protected Charset$Coder$(Charset cs,
 230                              float average$ItypesPerOtype$,
 231                              float max$ItypesPerOtype$)
 232     {
 233         this(cs,
 234              average$ItypesPerOtype$, max$ItypesPerOtype$,
 235              $defaultRepl$);
 236     }
 237 
 238     /**
 239      * Returns the charset that created this $coder$.
 240      *
 241      * @return  This $coder$&#39;s charset
 242      */
 243     public final Charset charset() {
 244         return charset;
 245     }
 246 
 247     /**
 248      * Returns this $coder$&#39;s replacement value.
 249      *
 250      * @return  This $coder$&#39;s current replacement,
 251      *          which is never {@code null} and is never empty
 252      */
 253     public final $replType$ replacement() {
 254 #if[decoder]
 255         return replacement;
 256 #end[decoder]
 257 #if[encoder]
 258         return Arrays.copyOf(replacement, replacement.$replLength$);
 259 #end[encoder]
 260     }
 261 
 262     /**
 263      * Changes this $coder$&#39;s replacement value.
 264      *
 265      * &lt;p&gt; This method invokes the {@link #implReplaceWith implReplaceWith}
 266      * method, passing the new replacement, after checking that the new
 267      * replacement is acceptable.  &lt;/p&gt;
 268      *
 269      * @param  newReplacement  The new replacement; must not be
 270      *         {@code null}, must have non-zero length,
 271 #if[decoder]
 272      *         and must not be longer than the value returned by the
 273      *         {@link #max$ItypesPerOtype$() max$ItypesPerOtype$} method
 274 #end[decoder]
 275 #if[encoder]
 276      *         must not be longer than the value returned by the
 277      *         {@link #max$ItypesPerOtype$() max$ItypesPerOtype$} method, and
 278      *         must be {@link #isLegalReplacement legal}
 279 #end[encoder]
 280      *
 281      * @return  This $coder$
 282      *
 283      * @throws  IllegalArgumentException
 284      *          If the preconditions on the parameter do not hold
 285      */
 286     public final Charset$Coder$ replaceWith($replType$ newReplacement) {
 287         if (newReplacement == null)
 288             throw new IllegalArgumentException(&quot;Null replacement&quot;);
 289         int len = newReplacement.$replLength$;
 290         if (len == 0)
 291             throw new IllegalArgumentException(&quot;Empty replacement&quot;);
 292         if (len &gt; max$ItypesPerOtype$)
 293             throw new IllegalArgumentException(&quot;Replacement too long&quot;);
 294 #if[decoder]
 295         this.replacement = newReplacement;
 296 #end[decoder]
 297 #if[encoder]
 298         if (!isLegalReplacement(newReplacement))
 299             throw new IllegalArgumentException(&quot;Illegal replacement&quot;);
 300         this.replacement = Arrays.copyOf(newReplacement, newReplacement.$replLength$);
 301 #end[encoder]
 302         implReplaceWith(this.replacement);
 303         return this;
 304     }
 305 
 306     /**
 307      * Reports a change to this $coder$&#39;s replacement value.
 308      *
 309      * &lt;p&gt; The default implementation of this method does nothing.  This method
 310      * should be overridden by $coder$s that require notification of changes to
 311      * the replacement.  &lt;/p&gt;
 312      *
 313      * @param  newReplacement    The replacement value
 314      */
 315     protected void implReplaceWith($replType$ newReplacement) {
 316     }
 317 
 318 #if[encoder]
 319 
 320     private WeakReference&lt;CharsetDecoder&gt; cachedDecoder = null;
 321 
 322     /**
 323      * Tells whether or not the given byte array is a legal replacement value
 324      * for this encoder.
 325      *
 326      * &lt;p&gt; A replacement is legal if, and only if, it is a legal sequence of
 327      * bytes in this encoder&#39;s charset; that is, it must be possible to decode
 328      * the replacement into one or more sixteen-bit Unicode characters.
 329      *
 330      * &lt;p&gt; The default implementation of this method is not very efficient; it
 331      * should generally be overridden to improve performance.  &lt;/p&gt;
 332      *
 333      * @param  repl  The byte array to be tested
 334      *
 335      * @return  {@code true} if, and only if, the given byte array
 336      *          is a legal replacement value for this encoder
 337      */
 338     public boolean isLegalReplacement(byte[] repl) {
 339         WeakReference&lt;CharsetDecoder&gt; wr = cachedDecoder;
 340         CharsetDecoder dec = null;
 341         if ((wr == null) || ((dec = wr.get()) == null)) {
 342             dec = charset().newDecoder();
 343             dec.onMalformedInput(CodingErrorAction.REPORT);
 344             dec.onUnmappableCharacter(CodingErrorAction.REPORT);
 345             cachedDecoder = new WeakReference&lt;CharsetDecoder&gt;(dec);
 346         } else {
 347             dec.reset();
 348         }
 349         ByteBuffer bb = ByteBuffer.wrap(repl);
 350         CharBuffer cb = CharBuffer.allocate((int)(bb.remaining()
 351                                                   * dec.maxCharsPerByte()));
 352         CoderResult cr = dec.decode(bb, cb, true);
 353         return !cr.isError();
 354     }
 355 
 356 #end[encoder]
 357 
 358     /**
 359      * Returns this $coder$&#39;s current action for malformed-input errors.
 360      *
 361      * @return The current malformed-input action, which is never {@code null}
 362      */
 363     public CodingErrorAction malformedInputAction() {
 364         return malformedInputAction;
 365     }
 366 
 367     /**
 368      * Changes this $coder$&#39;s action for malformed-input errors.
 369      *
 370      * &lt;p&gt; This method invokes the {@link #implOnMalformedInput
 371      * implOnMalformedInput} method, passing the new action.  &lt;/p&gt;
 372      *
 373      * @param  newAction  The new action; must not be {@code null}
 374      *
 375      * @return  This $coder$
 376      *
 377      * @throws IllegalArgumentException
 378      *         If the precondition on the parameter does not hold
 379      */
 380     public final Charset$Coder$ onMalformedInput(CodingErrorAction newAction) {
 381         if (newAction == null)
 382             throw new IllegalArgumentException(&quot;Null action&quot;);
 383         malformedInputAction = newAction;
 384         implOnMalformedInput(newAction);
 385         return this;
 386     }
 387 
 388     /**
 389      * Reports a change to this $coder$&#39;s malformed-input action.
 390      *
 391      * &lt;p&gt; The default implementation of this method does nothing.  This method
 392      * should be overridden by $coder$s that require notification of changes to
 393      * the malformed-input action.  &lt;/p&gt;
 394      *
 395      * @param  newAction  The new action
 396      */
 397     protected void implOnMalformedInput(CodingErrorAction newAction) { }
 398 
 399     /**
 400      * Returns this $coder$&#39;s current action for unmappable-character errors.
 401      *
 402      * @return The current unmappable-character action, which is never
 403      *         {@code null}
 404      */
 405     public CodingErrorAction unmappableCharacterAction() {
 406         return unmappableCharacterAction;
 407     }
 408 
 409     /**
 410      * Changes this $coder$&#39;s action for unmappable-character errors.
 411      *
 412      * &lt;p&gt; This method invokes the {@link #implOnUnmappableCharacter
 413      * implOnUnmappableCharacter} method, passing the new action.  &lt;/p&gt;
 414      *
 415      * @param  newAction  The new action; must not be {@code null}
 416      *
 417      * @return  This $coder$
 418      *
 419      * @throws IllegalArgumentException
 420      *         If the precondition on the parameter does not hold
 421      */
 422     public final Charset$Coder$ onUnmappableCharacter(CodingErrorAction
 423                                                       newAction)
 424     {
 425         if (newAction == null)
 426             throw new IllegalArgumentException(&quot;Null action&quot;);
 427         unmappableCharacterAction = newAction;
 428         implOnUnmappableCharacter(newAction);
 429         return this;
 430     }
 431 
 432     /**
 433      * Reports a change to this $coder$&#39;s unmappable-character action.
 434      *
 435      * &lt;p&gt; The default implementation of this method does nothing.  This method
 436      * should be overridden by $coder$s that require notification of changes to
 437      * the unmappable-character action.  &lt;/p&gt;
 438      *
 439      * @param  newAction  The new action
 440      */
 441     protected void implOnUnmappableCharacter(CodingErrorAction newAction) { }
 442 
 443     /**
 444      * Returns the average number of $otype$s that will be produced for each
 445      * $itype$ of input.  This heuristic value may be used to estimate the size
 446      * of the output buffer required for a given input sequence.
 447      *
 448      * @return  The average number of $otype$s produced
 449      *          per $itype$ of input
 450      */
 451     public final float average$ItypesPerOtype$() {
 452         return average$ItypesPerOtype$;
 453     }
 454 
 455     /**
 456      * Returns the maximum number of $otype$s that will be produced for each
 457      * $itype$ of input.  This value may be used to compute the worst-case size
 458      * of the output buffer required for a given input sequence. This value
 459      * accounts for any necessary content-independent prefix or suffix
 460 #if[encoder]
 461      * $otype$s, such as byte-order marks.
 462 #end[encoder]
 463 #if[decoder]
 464      * $otype$s.
 465 #end[decoder]
 466      *
 467      * @return  The maximum number of $otype$s that will be produced per
 468      *          $itype$ of input
 469      */
 470     public final float max$ItypesPerOtype$() {
 471         return max$ItypesPerOtype$;
 472     }
 473 
 474     /**
 475      * $Code$s as many $itype$s as possible from the given input buffer,
 476      * writing the results to the given output buffer.
 477      *
 478      * &lt;p&gt; The buffers are read from, and written to, starting at their current
 479      * positions.  At most {@link Buffer#remaining in.remaining()} $itype$s
 480      * will be read and at most {@link Buffer#remaining out.remaining()}
 481      * $otype$s will be written.  The buffers&#39; positions will be advanced to
 482      * reflect the $itype$s read and the $otype$s written, but their marks and
 483      * limits will not be modified.
 484      *
 485      * &lt;p&gt; In addition to reading $itype$s from the input buffer and writing
 486      * $otype$s to the output buffer, this method returns a {@link CoderResult}
 487      * object to describe its reason for termination:
 488      *
 489      * &lt;ul&gt;
 490      *
 491      *   &lt;li&gt;&lt;p&gt; {@link CoderResult#UNDERFLOW} indicates that as much of the
 492      *   input buffer as possible has been $code$d.  If there is no further
 493      *   input then the invoker can proceed to the next step of the
 494      *   &lt;a href=&quot;#steps&quot;&gt;$coding$ operation&lt;/a&gt;.  Otherwise this method
 495      *   should be invoked again with further input.  &lt;/p&gt;&lt;/li&gt;
 496      *
 497      *   &lt;li&gt;&lt;p&gt; {@link CoderResult#OVERFLOW} indicates that there is
 498      *   insufficient space in the output buffer to $code$ any more $itype$s.
 499      *   This method should be invoked again with an output buffer that has
 500      *   more {@linkplain Buffer#remaining remaining} $otype$s. This is
 501      *   typically done by draining any $code$d $otype$s from the output
 502      *   buffer.  &lt;/p&gt;&lt;/li&gt;
 503      *
 504      *   &lt;li&gt;&lt;p&gt; A {@linkplain CoderResult#malformedForLength
 505      *   malformed-input} result indicates that a malformed-input
 506      *   error has been detected.  The malformed $itype$s begin at the input
 507      *   buffer&#39;s (possibly incremented) position; the number of malformed
 508      *   $itype$s may be determined by invoking the result object&#39;s {@link
 509      *   CoderResult#length() length} method.  This case applies only if the
 510      *   {@linkplain #onMalformedInput malformed action} of this $coder$
 511      *   is {@link CodingErrorAction#REPORT}; otherwise the malformed input
 512      *   will be ignored or replaced, as requested.  &lt;/p&gt;&lt;/li&gt;
 513      *
 514      *   &lt;li&gt;&lt;p&gt; An {@linkplain CoderResult#unmappableForLength
 515      *   unmappable-character} result indicates that an
 516      *   unmappable-character error has been detected.  The $itype$s that
 517      *   $code$ the unmappable character begin at the input buffer&#39;s (possibly
 518      *   incremented) position; the number of such $itype$s may be determined
 519      *   by invoking the result object&#39;s {@link CoderResult#length() length}
 520      *   method.  This case applies only if the {@linkplain #onUnmappableCharacter
 521      *   unmappable action} of this $coder$ is {@link
 522      *   CodingErrorAction#REPORT}; otherwise the unmappable character will be
 523      *   ignored or replaced, as requested.  &lt;/p&gt;&lt;/li&gt;
 524      *
 525      * &lt;/ul&gt;
 526      *
 527      * In any case, if this method is to be reinvoked in the same $coding$
 528      * operation then care should be taken to preserve any $itype$s remaining
 529      * in the input buffer so that they are available to the next invocation.
 530      *
 531      * &lt;p&gt; The {@code endOfInput} parameter advises this method as to whether
 532      * the invoker can provide further input beyond that contained in the given
 533      * input buffer.  If there is a possibility of providing additional input
 534      * then the invoker should pass {@code false} for this parameter; if there
 535      * is no possibility of providing further input then the invoker should
 536      * pass {@code true}.  It is not erroneous, and in fact it is quite
 537      * common, to pass {@code false} in one invocation and later discover that
 538      * no further input was actually available.  It is critical, however, that
 539      * the final invocation of this method in a sequence of invocations always
 540      * pass {@code true} so that any remaining un$code$d input will be treated
 541      * as being malformed.
 542      *
 543      * &lt;p&gt; This method works by invoking the {@link #$code$Loop $code$Loop}
 544      * method, interpreting its results, handling error conditions, and
 545      * reinvoking it as necessary.  &lt;/p&gt;
 546      *
 547      *
 548      * @param  in
 549      *         The input $itype$ buffer
 550      *
 551      * @param  out
 552      *         The output $otype$ buffer
 553      *
 554      * @param  endOfInput
 555      *         {@code true} if, and only if, the invoker can provide no
 556      *         additional input $itype$s beyond those in the given buffer
 557      *
 558      * @return  A coder-result object describing the reason for termination
 559      *
 560      * @throws  IllegalStateException
 561      *          If $a$ $coding$ operation is already in progress and the previous
 562      *          step was an invocation neither of the {@link #reset reset}
 563      *          method, nor of this method with a value of {@code false} for
 564      *          the {@code endOfInput} parameter, nor of this method with a
 565      *          value of {@code true} for the {@code endOfInput} parameter
 566      *          but a return value indicating an incomplete $coding$ operation
 567      *
 568      * @throws  CoderMalfunctionError
 569      *          If an invocation of the $code$Loop method threw
 570      *          an unexpected exception
 571      */
 572     public final CoderResult $code$($Itype$Buffer in, $Otype$Buffer out,
 573                                     boolean endOfInput)
 574     {
 575         int newState = endOfInput ? ST_END : ST_CODING;
 576         if ((state != ST_RESET) &amp;&amp; (state != ST_CODING)
 577             &amp;&amp; !(endOfInput &amp;&amp; (state == ST_END)))
 578             throwIllegalStateException(state, newState);
 579         state = newState;
 580 
 581         for (;;) {
 582 
 583             CoderResult cr;
 584             try {
 585                 cr = $code$Loop(in, out);
 586             } catch (BufferUnderflowException x) {
 587                 throw new CoderMalfunctionError(x);
 588             } catch (BufferOverflowException x) {
 589                 throw new CoderMalfunctionError(x);
 590             }
 591 
 592             if (cr.isOverflow())
 593                 return cr;
 594 
 595             if (cr.isUnderflow()) {
 596                 if (endOfInput &amp;&amp; in.hasRemaining()) {
 597                     cr = CoderResult.malformedForLength(in.remaining());
 598                     // Fall through to malformed-input case
 599                 } else {
 600                     return cr;
 601                 }
 602             }
 603 
 604             CodingErrorAction action = null;
 605             if (cr.isMalformed())
 606                 action = malformedInputAction;
 607             else if (cr.isUnmappable())
 608                 action = unmappableCharacterAction;
 609             else
 610                 assert false : cr.toString();
 611 
 612             if (action == CodingErrorAction.REPORT)
 613                 return cr;
 614 
 615             if (action == CodingErrorAction.REPLACE) {
 616                 if (out.remaining() &lt; replacement.$replLength$)
 617                     return CoderResult.OVERFLOW;
 618                 out.put(replacement);
 619             }
 620 
 621             if ((action == CodingErrorAction.IGNORE)
 622                 || (action == CodingErrorAction.REPLACE)) {
 623                 // Skip erroneous input either way
 624                 in.position(in.position() + cr.length());
 625                 continue;
 626             }
 627 
 628             assert false;
 629         }
 630 
 631     }
 632 
 633     /**
 634      * Flushes this $coder$.
 635      *
 636      * &lt;p&gt; Some $coder$s maintain internal state and may need to write some
 637      * final $otype$s to the output buffer once the overall input sequence has
 638      * been read.
 639      *
 640      * &lt;p&gt; Any additional output is written to the output buffer beginning at
 641      * its current position.  At most {@link Buffer#remaining out.remaining()}
 642      * $otype$s will be written.  The buffer&#39;s position will be advanced
 643      * appropriately, but its mark and limit will not be modified.
 644      *
 645      * &lt;p&gt; If this method completes successfully then it returns {@link
 646      * CoderResult#UNDERFLOW}.  If there is insufficient room in the output
 647      * buffer then it returns {@link CoderResult#OVERFLOW}.  If this happens
 648      * then this method must be invoked again, with an output buffer that has
 649      * more room, in order to complete the current &lt;a href=&quot;#steps&quot;&gt;$coding$
 650      * operation&lt;/a&gt;.
 651      *
 652      * &lt;p&gt; If this $coder$ has already been flushed then invoking this method
 653      * has no effect.
 654      *
 655      * &lt;p&gt; This method invokes the {@link #implFlush implFlush} method to
 656      * perform the actual flushing operation.  &lt;/p&gt;
 657      *
 658      * @param  out
 659      *         The output $otype$ buffer
 660      *
 661      * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or
 662      *          {@link CoderResult#OVERFLOW}
 663      *
 664      * @throws  IllegalStateException
 665      *          If the previous step of the current $coding$ operation was an
 666      *          invocation neither of the {@link #flush flush} method nor of
 667      *          the three-argument {@link
 668      *          #$code$($Itype$Buffer,$Otype$Buffer,boolean) $code$} method
 669      *          with a value of {@code true} for the {@code endOfInput}
 670      *          parameter
 671      */
 672     public final CoderResult flush($Otype$Buffer out) {
 673         if (state == ST_END) {
 674             CoderResult cr = implFlush(out);
 675             if (cr.isUnderflow())
 676                 state = ST_FLUSHED;
 677             return cr;
 678         }
 679 
 680         if (state != ST_FLUSHED)
 681             throwIllegalStateException(state, ST_FLUSHED);
 682 
 683         return CoderResult.UNDERFLOW; // Already flushed
 684     }
 685 
 686     /**
 687      * Flushes this $coder$.
 688      *
 689      * &lt;p&gt; The default implementation of this method does nothing, and always
 690      * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden
 691      * by $coder$s that may need to write final $otype$s to the output buffer
 692      * once the entire input sequence has been read. &lt;/p&gt;
 693      *
 694      * @param  out
 695      *         The output $otype$ buffer
 696      *
 697      * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or
 698      *          {@link CoderResult#OVERFLOW}
 699      */
 700     protected CoderResult implFlush($Otype$Buffer out) {
 701         return CoderResult.UNDERFLOW;
 702     }
 703 
 704     /**
 705      * Resets this $coder$, clearing any internal state.
 706      *
 707      * &lt;p&gt; This method resets charset-independent state and also invokes the
 708      * {@link #implReset() implReset} method in order to perform any
 709      * charset-specific reset actions.  &lt;/p&gt;
 710      *
 711      * @return  This $coder$
 712      *
 713      */
 714     public final Charset$Coder$ reset() {
 715         implReset();
 716         state = ST_RESET;
 717         return this;
 718     }
 719 
 720     /**
 721      * Resets this $coder$, clearing any charset-specific internal state.
 722      *
 723      * &lt;p&gt; The default implementation of this method does nothing.  This method
 724      * should be overridden by $coder$s that maintain internal state.  &lt;/p&gt;
 725      */
 726     protected void implReset() { }
 727 
 728     /**
 729      * $Code$s one or more $itype$s into one or more $otype$s.
 730      *
 731      * &lt;p&gt; This method encapsulates the basic $coding$ loop, $coding$ as many
 732      * $itype$s as possible until it either runs out of input, runs out of room
 733      * in the output buffer, or encounters $a$ $coding$ error.  This method is
 734      * invoked by the {@link #$code$ $code$} method, which handles result
 735      * interpretation and error recovery.
 736      *
 737      * &lt;p&gt; The buffers are read from, and written to, starting at their current
 738      * positions.  At most {@link Buffer#remaining in.remaining()} $itype$s
 739      * will be read, and at most {@link Buffer#remaining out.remaining()}
 740      * $otype$s will be written.  The buffers&#39; positions will be advanced to
 741      * reflect the $itype$s read and the $otype$s written, but their marks and
 742      * limits will not be modified.
 743      *
 744      * &lt;p&gt; This method returns a {@link CoderResult} object to describe its
 745      * reason for termination, in the same manner as the {@link #$code$ $code$}
 746      * method.  Most implementations of this method will handle $coding$ errors
 747      * by returning an appropriate result object for interpretation by the
 748      * {@link #$code$ $code$} method.  An optimized implementation may instead
 749      * examine the relevant error action and implement that action itself.
 750      *
 751      * &lt;p&gt; An implementation of this method may perform arbitrary lookahead by
 752      * returning {@link CoderResult#UNDERFLOW} until it receives sufficient
 753      * input.  &lt;/p&gt;
 754      *
 755      * @param  in
 756      *         The input $itype$ buffer
 757      *
 758      * @param  out
 759      *         The output $otype$ buffer
 760      *
 761      * @return  A coder-result object describing the reason for termination
 762      */
 763     protected abstract CoderResult $code$Loop($Itype$Buffer in,
 764                                               $Otype$Buffer out);
 765 
 766     /**
 767      * Convenience method that $code$s the remaining content of a single input
 768      * $itype$ buffer into a newly-allocated $otype$ buffer.
 769      *
 770      * &lt;p&gt; This method implements an entire &lt;a href=&quot;#steps&quot;&gt;$coding$
 771      * operation&lt;/a&gt;; that is, it resets this $coder$, then it $code$s the
 772      * $itype$s in the given $itype$ buffer, and finally it flushes this
 773      * $coder$.  This method should therefore not be invoked if $a$ $coding$
 774      * operation is already in progress.  &lt;/p&gt;
 775      *
 776      * @param  in
 777      *         The input $itype$ buffer
 778      *
 779      * @return A newly-allocated $otype$ buffer containing the result of the
 780      *         $coding$ operation.  The buffer&#39;s position will be zero and its
 781      *         limit will follow the last $otype$ written.
 782      *
 783      * @throws  IllegalStateException
 784      *          If $a$ $coding$ operation is already in progress
 785      *
 786      * @throws  MalformedInputException
 787      *          If the $itype$ sequence starting at the input buffer&#39;s current
 788      *          position is $notLegal$ and the current malformed-input action
 789      *          is {@link CodingErrorAction#REPORT}
 790      *
 791      * @throws  UnmappableCharacterException
 792      *          If the $itype$ sequence starting at the input buffer&#39;s current
 793      *          position cannot be mapped to an equivalent $otype$ sequence and
 794      *          the current unmappable-character action is {@link
 795      *          CodingErrorAction#REPORT}
 796      */
 797     public final $Otype$Buffer $code$($Itype$Buffer in)
 798         throws CharacterCodingException
 799     {
 800         int n = (int)(in.remaining() * average$ItypesPerOtype$());
 801         $Otype$Buffer out = $Otype$Buffer.allocate(n);
 802 
 803         if ((n == 0) &amp;&amp; (in.remaining() == 0))
 804             return out;
 805         reset();
 806         for (;;) {
 807             CoderResult cr = in.hasRemaining() ?
 808                 $code$(in, out, true) : CoderResult.UNDERFLOW;
 809             if (cr.isUnderflow())
 810                 cr = flush(out);
 811 
 812             if (cr.isUnderflow())
 813                 break;
 814             if (cr.isOverflow()) {
 815                 n = 2*n + 1;    // Ensure progress; n might be 0!
 816                 $Otype$Buffer o = $Otype$Buffer.allocate(n);
 817                 out.flip();
 818                 o.put(out);
 819                 out = o;
 820                 continue;
 821             }
 822             cr.throwException();
 823         }
 824         out.flip();
 825         return out;
 826     }
 827 
 828 #if[decoder]
 829 
 830     /**
 831      * Tells whether or not this decoder implements an auto-detecting charset.
 832      *
 833      * &lt;p&gt; The default implementation of this method always returns
 834      * {@code false}; it should be overridden by auto-detecting decoders to
 835      * return {@code true}.  &lt;/p&gt;
 836      *
 837      * @return  {@code true} if, and only if, this decoder implements an
 838      *          auto-detecting charset
 839      */
 840     public boolean isAutoDetecting() {
 841         return false;
 842     }
 843 
 844     /**
 845      * Tells whether or not this decoder has yet detected a
 846      * charset&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
 847      *
 848      * &lt;p&gt; If this decoder implements an auto-detecting charset then at a
 849      * single point during a decoding operation this method may start returning
 850      * {@code true} to indicate that a specific charset has been detected in
 851      * the input byte sequence.  Once this occurs, the {@link #detectedCharset
 852      * detectedCharset} method may be invoked to retrieve the detected charset.
 853      *
 854      * &lt;p&gt; That this method returns {@code false} does not imply that no bytes
 855      * have yet been decoded.  Some auto-detecting decoders are capable of
 856      * decoding some, or even all, of an input byte sequence without fixing on
 857      * a particular charset.
 858      *
 859      * &lt;p&gt; The default implementation of this method always throws an {@link
 860      * UnsupportedOperationException}; it should be overridden by
 861      * auto-detecting decoders to return {@code true} once the input charset
 862      * has been determined.  &lt;/p&gt;
 863      *
 864      * @return  {@code true} if, and only if, this decoder has detected a
 865      *          specific charset
 866      *
 867      * @throws  UnsupportedOperationException
 868      *          If this decoder does not implement an auto-detecting charset
 869      */
 870     public boolean isCharsetDetected() {
 871         throw new UnsupportedOperationException();
 872     }
 873 
 874     /**
 875      * Retrieves the charset that was detected by this
 876      * decoder&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
 877      *
 878      * &lt;p&gt; If this decoder implements an auto-detecting charset then this
 879      * method returns the actual charset once it has been detected.  After that
 880      * point, this method returns the same value for the duration of the
 881      * current decoding operation.  If not enough input bytes have yet been
 882      * read to determine the actual charset then this method throws an {@link
 883      * IllegalStateException}.
 884      *
 885      * &lt;p&gt; The default implementation of this method always throws an {@link
 886      * UnsupportedOperationException}; it should be overridden by
 887      * auto-detecting decoders to return the appropriate value.  &lt;/p&gt;
 888      *
 889      * @return  The charset detected by this auto-detecting decoder,
 890      *          or {@code null} if the charset has not yet been determined
 891      *
 892      * @throws  IllegalStateException
 893      *          If insufficient bytes have been read to determine a charset
 894      *
 895      * @throws  UnsupportedOperationException
 896      *          If this decoder does not implement an auto-detecting charset
 897      */
 898     public Charset detectedCharset() {
 899         throw new UnsupportedOperationException();
 900     }
 901 
 902 #end[decoder]
 903 
 904 #if[encoder]
 905 
 906     private boolean canEncode(CharBuffer cb) {
 907         if (state == ST_FLUSHED)
 908             reset();
 909         else if (state != ST_RESET)
 910             throwIllegalStateException(state, ST_CODING);
 911         CodingErrorAction ma = malformedInputAction();
 912         CodingErrorAction ua = unmappableCharacterAction();
 913         try {
 914             onMalformedInput(CodingErrorAction.REPORT);
 915             onUnmappableCharacter(CodingErrorAction.REPORT);
 916             encode(cb);
 917         } catch (CharacterCodingException x) {
 918             return false;
 919         } finally {
 920             onMalformedInput(ma);
 921             onUnmappableCharacter(ua);
 922             reset();
 923         }
 924         return true;
 925     }
 926 
 927     /**
 928      * Tells whether or not this encoder can encode the given character.
 929      *
 930      * &lt;p&gt; This method returns {@code false} if the given character is a
 931      * surrogate character; such characters can be interpreted only when they
 932      * are members of a pair consisting of a high surrogate followed by a low
 933      * surrogate.  The {@link #canEncode(java.lang.CharSequence)
 934      * canEncode(CharSequence)} method may be used to test whether or not a
 935      * character sequence can be encoded.
 936      *
 937      * &lt;p&gt; This method may modify this encoder&#39;s state; it should therefore not
 938      * be invoked if an &lt;a href=&quot;#steps&quot;&gt;encoding operation&lt;/a&gt; is already in
 939      * progress.
 940      *
 941      * &lt;p&gt; The default implementation of this method is not very efficient; it
 942      * should generally be overridden to improve performance.  &lt;/p&gt;
 943      *
 944      * @param   c
 945      *          The given character
 946      *
 947      * @return  {@code true} if, and only if, this encoder can encode
 948      *          the given character
 949      *
 950      * @throws  IllegalStateException
 951      *          If $a$ $coding$ operation is already in progress
 952      */
 953     public boolean canEncode(char c) {
 954         CharBuffer cb = CharBuffer.allocate(1);
 955         cb.put(c);
 956         cb.flip();
 957         return canEncode(cb);
 958     }
 959 
 960     /**
 961      * Tells whether or not this encoder can encode the given character
 962      * sequence.
 963      *
 964      * &lt;p&gt; If this method returns {@code false} for a particular character
 965      * sequence then more information about why the sequence cannot be encoded
 966      * may be obtained by performing a full &lt;a href=&quot;#steps&quot;&gt;encoding
 967      * operation&lt;/a&gt;.
 968      *
 969      * &lt;p&gt; This method may modify this encoder&#39;s state; it should therefore not
 970      * be invoked if an encoding operation is already in progress.
 971      *
 972      * &lt;p&gt; The default implementation of this method is not very efficient; it
 973      * should generally be overridden to improve performance.  &lt;/p&gt;
 974      *
 975      * @param   cs
 976      *          The given character sequence
 977      *
 978      * @return  {@code true} if, and only if, this encoder can encode
 979      *          the given character without throwing any exceptions and without
 980      *          performing any replacements
 981      *
 982      * @throws  IllegalStateException
 983      *          If $a$ $coding$ operation is already in progress
 984      */
 985     public boolean canEncode(CharSequence cs) {
 986         CharBuffer cb;
 987         if (cs instanceof CharBuffer)
 988             cb = ((CharBuffer)cs).duplicate();
 989         else
 990             cb = CharBuffer.wrap(cs.toString());
 991         return canEncode(cb);
 992     }
 993 
 994 #end[encoder]
 995 
 996 
 997     private void throwIllegalStateException(int from, int to) {
 998         throw new IllegalStateException(&quot;Current state = &quot; + stateNames[from]
 999                                         + &quot;, new state = &quot; + stateNames[to]);
1000     }
1001 
1002 }
    </pre>
  </body>
</html>
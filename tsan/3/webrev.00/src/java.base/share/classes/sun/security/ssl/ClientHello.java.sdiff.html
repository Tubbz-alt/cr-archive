<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ClientHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CipherSuite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHClientKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ClientHello.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.SecureRandom;
  31 import java.security.cert.X509Certificate;
  32 import java.text.MessageFormat;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.LinkedList;
  36 import java.util.List;
  37 import java.util.Locale;
<span class="line-removed">  38 import java.util.Objects;</span>
  39 import javax.net.ssl.SSLException;
  40 import javax.net.ssl.SSLHandshakeException;
  41 import javax.net.ssl.SSLPeerUnverifiedException;
  42 import javax.net.ssl.SSLProtocolException;
  43 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  45 import sun.security.ssl.SupportedVersionsExtension.CHSupportedVersionsSpec;
  46 
  47 /**
  48  * Pack of the ClientHello handshake message.
  49  */
  50 final class ClientHello {
  51     static final SSLProducer kickstartProducer =
  52         new ClientHelloKickstartProducer();
  53     static final SSLConsumer handshakeConsumer =
  54         new ClientHelloConsumer();
  55     static final HandshakeProducer handshakeProducer =
  56         new ClientHelloProducer();
  57 
  58     private static final HandshakeConsumer t12HandshakeConsumer =
</pre>
<hr />
<pre>
 952             // natural at first, but warnings are not appropriate because
 953             // the sending party does not know how the receiving party
 954             // will behave.  This state must be treated as a fatal server
 955             // condition.
 956             //
 957             // This will not have any impact on server initiated renegotiation.
 958             if (shc.conContext.isNegotiated) {
 959                 if (!shc.conContext.secureRenegotiation &amp;&amp;
 960                         !HandshakeContext.allowUnsafeRenegotiation) {
 961                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 962                             &quot;Unsafe renegotiation is not allowed&quot;);
 963                 }
 964 
 965                 if (ServerHandshakeContext.rejectClientInitiatedRenego &amp;&amp;
 966                         !shc.kickstartMessageDelivered) {
 967                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 968                             &quot;Client initiated renegotiation is not allowed&quot;);
 969                 }
 970             }
 971 
<span class="line-modified"> 972             // Is it an abbreviated handshake?</span>
<span class="line-modified"> 973             if (clientHello.sessionId.length() != 0) {</span>
<span class="line-modified"> 974                 SSLSessionImpl previous = ((SSLSessionContextImpl)shc.sslContext</span>
<span class="line-modified"> 975                             .engineGetServerSessionContext())</span>
<span class="line-modified"> 976                             .get(clientHello.sessionId.getId());</span>













 977 
 978                 boolean resumingSession =
 979                         (previous != null) &amp;&amp; previous.isRejoinable();
 980                 if (!resumingSession) {
 981                     if (SSLLogger.isOn &amp;&amp;
 982                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
 983                         SSLLogger.finest(
 984                                 &quot;Can&#39;t resume, &quot; +
 985                                 &quot;the existing session is not rejoinable&quot;);
 986                     }
 987                 }
 988                 // Validate the negotiated protocol version.
 989                 if (resumingSession) {
 990                     ProtocolVersion sessionProtocol =
 991                             previous.getProtocolVersion();
 992                     if (sessionProtocol != shc.negotiatedProtocol) {
 993                         resumingSession = false;
 994                         if (SSLLogger.isOn &amp;&amp;
 995                                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
 996                             SSLLogger.finest(
</pre>
<hr />
<pre>
1034                 // one in the session
1035                 String identityAlg = shc.sslConfig.identificationProtocol;
1036                 if (resumingSession &amp;&amp; identityAlg != null) {
1037                     String sessionIdentityAlg =
1038                         previous.getIdentificationProtocol();
1039                     if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {
1040                         if (SSLLogger.isOn &amp;&amp;
1041                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1042                             SSLLogger.finest(&quot;Can&#39;t resume, endpoint id&quot; +
1043                             &quot; algorithm does not match, requested: &quot; +
1044                             identityAlg + &quot;, cached: &quot; + sessionIdentityAlg);
1045                         }
1046                         resumingSession = false;
1047                     }
1048                 }
1049 
1050                 // So far so good.  Note that the handshake extensions may reset
1051                 // the resuming options later.
1052                 shc.isResumption = resumingSession;
1053                 shc.resumingSession = resumingSession ? previous : null;





1054             }
1055 
1056             // cache the client random number for further using
1057             shc.clientHelloRandom = clientHello.clientRandom;
1058 
1059             // Check and launch ClientHello extensions.
<span class="line-modified">1060             SSLExtension[] extTypes = shc.sslConfig.getEnabledExtensions(</span>
<span class="line-modified">1061                     SSLHandshake.CLIENT_HELLO);</span>

1062             clientHello.extensions.consumeOnLoad(shc, extTypes);
1063 
1064             //
1065             // update
1066             //
1067             if (!shc.conContext.isNegotiated) {
1068                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
1069                 shc.conContext.outputRecord.setVersion(shc.negotiatedProtocol);
1070             }
1071 
1072             // update the responders
1073             //
1074             // Only need to ServerHello, which may add more responders later.
1075             // Note that ServerHello and HelloRetryRequest share the same
1076             // handshake type/id.  The ServerHello producer may be replaced
1077             // by HelloRetryRequest producer if needed.
1078             shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO.id,
1079                     SSLHandshake.SERVER_HELLO);
1080 
1081             //
</pre>
<hr />
<pre>
1105         }
1106     }
1107 
1108     /**
1109      * The &quot;ClientHello&quot; handshake message consumer for TLS 1.3.
1110      */
1111     private static final
1112             class T13ClientHelloConsumer implements HandshakeConsumer {
1113         // Prevent instantiation of this class.
1114         private T13ClientHelloConsumer() {
1115             // blank
1116         }
1117 
1118         @Override
1119         public void consume(ConnectionContext context,
1120                 HandshakeMessage message) throws IOException {
1121             // The consuming happens in server side only.
1122             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1123             ClientHelloMessage clientHello = (ClientHelloMessage)message;
1124 









1125             // The client may send a dummy change_cipher_spec record
1126             // immediately after the first ClientHello.
1127             shc.conContext.consumers.putIfAbsent(
1128                     ContentType.CHANGE_CIPHER_SPEC.id,
1129                     ChangeCipherSpec.t13Consumer);
1130 
1131             // Is it a resumption?
1132             //
1133             // Check and launch the &quot;psk_key_exchange_modes&quot; and
1134             // &quot;pre_shared_key&quot; extensions first, which will reset the
1135             // resuming session, no matter the extensions present or not.
1136             shc.isResumption = true;
1137             SSLExtension[] extTypes = new SSLExtension[] {
1138                     SSLExtension.PSK_KEY_EXCHANGE_MODES,
1139                     SSLExtension.CH_PRE_SHARED_KEY
1140                 };
1141             clientHello.extensions.consumeOnLoad(shc, extTypes);
1142 
1143             // Check and launch ClientHello extensions other than
1144             // &quot;psk_key_exchange_modes&quot;, &quot;pre_shared_key&quot;, &quot;protocol_version&quot;
</pre>
<hr />
<pre>
1259             // natural at first, but warnings are not appropriate because
1260             // the sending party does not know how the receiving party
1261             // will behave.  This state must be treated as a fatal server
1262             // condition.
1263             //
1264             // This will not have any impact on server initiated renegotiation.
1265             if (shc.conContext.isNegotiated) {
1266                 if (!shc.conContext.secureRenegotiation &amp;&amp;
1267                         !HandshakeContext.allowUnsafeRenegotiation) {
1268                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1269                             &quot;Unsafe renegotiation is not allowed&quot;);
1270                 }
1271 
1272                 if (ServerHandshakeContext.rejectClientInitiatedRenego &amp;&amp;
1273                         !shc.kickstartMessageDelivered) {
1274                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1275                             &quot;Client initiated renegotiation is not allowed&quot;);
1276                 }
1277             }
1278 
<span class="line-modified">1279             // Is it an abbreviated handshake?</span>

1280             if (clientHello.sessionId.length() != 0) {
<span class="line-modified">1281                 SSLSessionImpl previous = ((SSLSessionContextImpl)shc.sslContext</span>
<span class="line-modified">1282                             .engineGetServerSessionContext())</span>
<span class="line-modified">1283                             .get(clientHello.sessionId.getId());</span>













1284 
1285                 boolean resumingSession =
1286                         (previous != null) &amp;&amp; previous.isRejoinable();
1287                 if (!resumingSession) {
1288                     if (SSLLogger.isOn &amp;&amp;
1289                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1290                         SSLLogger.finest(
1291                             &quot;Can&#39;t resume, &quot; +
1292                             &quot;the existing session is not rejoinable&quot;);
1293                     }
1294                 }
1295                 // Validate the negotiated protocol version.
1296                 if (resumingSession) {
1297                     ProtocolVersion sessionProtocol =
1298                             previous.getProtocolVersion();
1299                     if (sessionProtocol != shc.negotiatedProtocol) {
1300                         resumingSession = false;
1301                         if (SSLLogger.isOn &amp;&amp;
1302                                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1303                             SSLLogger.finest(
</pre>
</td>
<td>
<hr />
<pre>
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.SecureRandom;
  31 import java.security.cert.X509Certificate;
  32 import java.text.MessageFormat;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.LinkedList;
  36 import java.util.List;
  37 import java.util.Locale;

  38 import javax.net.ssl.SSLException;
  39 import javax.net.ssl.SSLHandshakeException;
  40 import javax.net.ssl.SSLPeerUnverifiedException;
  41 import javax.net.ssl.SSLProtocolException;
  42 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  43 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  44 import sun.security.ssl.SupportedVersionsExtension.CHSupportedVersionsSpec;
  45 
  46 /**
  47  * Pack of the ClientHello handshake message.
  48  */
  49 final class ClientHello {
  50     static final SSLProducer kickstartProducer =
  51         new ClientHelloKickstartProducer();
  52     static final SSLConsumer handshakeConsumer =
  53         new ClientHelloConsumer();
  54     static final HandshakeProducer handshakeProducer =
  55         new ClientHelloProducer();
  56 
  57     private static final HandshakeConsumer t12HandshakeConsumer =
</pre>
<hr />
<pre>
 951             // natural at first, but warnings are not appropriate because
 952             // the sending party does not know how the receiving party
 953             // will behave.  This state must be treated as a fatal server
 954             // condition.
 955             //
 956             // This will not have any impact on server initiated renegotiation.
 957             if (shc.conContext.isNegotiated) {
 958                 if (!shc.conContext.secureRenegotiation &amp;&amp;
 959                         !HandshakeContext.allowUnsafeRenegotiation) {
 960                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 961                             &quot;Unsafe renegotiation is not allowed&quot;);
 962                 }
 963 
 964                 if (ServerHandshakeContext.rejectClientInitiatedRenego &amp;&amp;
 965                         !shc.kickstartMessageDelivered) {
 966                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 967                             &quot;Client initiated renegotiation is not allowed&quot;);
 968                 }
 969             }
 970 
<span class="line-modified"> 971             // Consume a Session Ticket Extension if it exists</span>
<span class="line-modified"> 972             SSLExtension[] ext = new SSLExtension[]{</span>
<span class="line-modified"> 973                     SSLExtension.CH_SESSION_TICKET</span>
<span class="line-modified"> 974             };</span>
<span class="line-modified"> 975             clientHello.extensions.consumeOnLoad(shc, ext);</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977             // Does the client want to resume a session?</span>
<span class="line-added"> 978             if (clientHello.sessionId.length() != 0 || shc.statelessResumption) {</span>
<span class="line-added"> 979                 SSLSessionContextImpl cache = (SSLSessionContextImpl)shc.sslContext</span>
<span class="line-added"> 980                         .engineGetServerSessionContext();</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982                 SSLSessionImpl previous;</span>
<span class="line-added"> 983                 // Use the stateless session ticket if provided</span>
<span class="line-added"> 984                 if (shc.statelessResumption) {</span>
<span class="line-added"> 985                     previous = shc.resumingSession;</span>
<span class="line-added"> 986                 } else {</span>
<span class="line-added"> 987                     previous = cache.get(clientHello.sessionId.getId());</span>
<span class="line-added"> 988                 }</span>
 989 
 990                 boolean resumingSession =
 991                         (previous != null) &amp;&amp; previous.isRejoinable();
 992                 if (!resumingSession) {
 993                     if (SSLLogger.isOn &amp;&amp;
 994                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
 995                         SSLLogger.finest(
 996                                 &quot;Can&#39;t resume, &quot; +
 997                                 &quot;the existing session is not rejoinable&quot;);
 998                     }
 999                 }
1000                 // Validate the negotiated protocol version.
1001                 if (resumingSession) {
1002                     ProtocolVersion sessionProtocol =
1003                             previous.getProtocolVersion();
1004                     if (sessionProtocol != shc.negotiatedProtocol) {
1005                         resumingSession = false;
1006                         if (SSLLogger.isOn &amp;&amp;
1007                                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1008                             SSLLogger.finest(
</pre>
<hr />
<pre>
1046                 // one in the session
1047                 String identityAlg = shc.sslConfig.identificationProtocol;
1048                 if (resumingSession &amp;&amp; identityAlg != null) {
1049                     String sessionIdentityAlg =
1050                         previous.getIdentificationProtocol();
1051                     if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {
1052                         if (SSLLogger.isOn &amp;&amp;
1053                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1054                             SSLLogger.finest(&quot;Can&#39;t resume, endpoint id&quot; +
1055                             &quot; algorithm does not match, requested: &quot; +
1056                             identityAlg + &quot;, cached: &quot; + sessionIdentityAlg);
1057                         }
1058                         resumingSession = false;
1059                     }
1060                 }
1061 
1062                 // So far so good.  Note that the handshake extensions may reset
1063                 // the resuming options later.
1064                 shc.isResumption = resumingSession;
1065                 shc.resumingSession = resumingSession ? previous : null;
<span class="line-added">1066 </span>
<span class="line-added">1067                 if (!resumingSession &amp;&amp; SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">1068                         SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">1069                     SSLLogger.fine(&quot;Session not resumed.&quot;);</span>
<span class="line-added">1070                 }</span>
1071             }
1072 
1073             // cache the client random number for further using
1074             shc.clientHelloRandom = clientHello.clientRandom;
1075 
1076             // Check and launch ClientHello extensions.
<span class="line-modified">1077             SSLExtension[] extTypes = shc.sslConfig.getExclusiveExtensions(</span>
<span class="line-modified">1078                     SSLHandshake.CLIENT_HELLO,</span>
<span class="line-added">1079                     Arrays.asList(SSLExtension.CH_SESSION_TICKET));</span>
1080             clientHello.extensions.consumeOnLoad(shc, extTypes);
1081 
1082             //
1083             // update
1084             //
1085             if (!shc.conContext.isNegotiated) {
1086                 shc.conContext.protocolVersion = shc.negotiatedProtocol;
1087                 shc.conContext.outputRecord.setVersion(shc.negotiatedProtocol);
1088             }
1089 
1090             // update the responders
1091             //
1092             // Only need to ServerHello, which may add more responders later.
1093             // Note that ServerHello and HelloRetryRequest share the same
1094             // handshake type/id.  The ServerHello producer may be replaced
1095             // by HelloRetryRequest producer if needed.
1096             shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO.id,
1097                     SSLHandshake.SERVER_HELLO);
1098 
1099             //
</pre>
<hr />
<pre>
1123         }
1124     }
1125 
1126     /**
1127      * The &quot;ClientHello&quot; handshake message consumer for TLS 1.3.
1128      */
1129     private static final
1130             class T13ClientHelloConsumer implements HandshakeConsumer {
1131         // Prevent instantiation of this class.
1132         private T13ClientHelloConsumer() {
1133             // blank
1134         }
1135 
1136         @Override
1137         public void consume(ConnectionContext context,
1138                 HandshakeMessage message) throws IOException {
1139             // The consuming happens in server side only.
1140             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1141             ClientHelloMessage clientHello = (ClientHelloMessage)message;
1142 
<span class="line-added">1143             // [RFC 8446] TLS 1.3 forbids renegotiation. If a server has</span>
<span class="line-added">1144             // negotiated TLS 1.3 and receives a ClientHello at any other</span>
<span class="line-added">1145             // time, it MUST terminate the connection with an</span>
<span class="line-added">1146             // &quot;unexpected_message&quot; alert.</span>
<span class="line-added">1147             if (shc.conContext.isNegotiated) {</span>
<span class="line-added">1148                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added">1149                         &quot;Received unexpected renegotiation handshake message&quot;);</span>
<span class="line-added">1150             }</span>
<span class="line-added">1151 </span>
1152             // The client may send a dummy change_cipher_spec record
1153             // immediately after the first ClientHello.
1154             shc.conContext.consumers.putIfAbsent(
1155                     ContentType.CHANGE_CIPHER_SPEC.id,
1156                     ChangeCipherSpec.t13Consumer);
1157 
1158             // Is it a resumption?
1159             //
1160             // Check and launch the &quot;psk_key_exchange_modes&quot; and
1161             // &quot;pre_shared_key&quot; extensions first, which will reset the
1162             // resuming session, no matter the extensions present or not.
1163             shc.isResumption = true;
1164             SSLExtension[] extTypes = new SSLExtension[] {
1165                     SSLExtension.PSK_KEY_EXCHANGE_MODES,
1166                     SSLExtension.CH_PRE_SHARED_KEY
1167                 };
1168             clientHello.extensions.consumeOnLoad(shc, extTypes);
1169 
1170             // Check and launch ClientHello extensions other than
1171             // &quot;psk_key_exchange_modes&quot;, &quot;pre_shared_key&quot;, &quot;protocol_version&quot;
</pre>
<hr />
<pre>
1286             // natural at first, but warnings are not appropriate because
1287             // the sending party does not know how the receiving party
1288             // will behave.  This state must be treated as a fatal server
1289             // condition.
1290             //
1291             // This will not have any impact on server initiated renegotiation.
1292             if (shc.conContext.isNegotiated) {
1293                 if (!shc.conContext.secureRenegotiation &amp;&amp;
1294                         !HandshakeContext.allowUnsafeRenegotiation) {
1295                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1296                             &quot;Unsafe renegotiation is not allowed&quot;);
1297                 }
1298 
1299                 if (ServerHandshakeContext.rejectClientInitiatedRenego &amp;&amp;
1300                         !shc.kickstartMessageDelivered) {
1301                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1302                             &quot;Client initiated renegotiation is not allowed&quot;);
1303                 }
1304             }
1305 
<span class="line-modified">1306 </span>
<span class="line-added">1307             // Does the client want to resume a session?</span>
1308             if (clientHello.sessionId.length() != 0) {
<span class="line-modified">1309                 SSLSessionContextImpl cache = (SSLSessionContextImpl)shc.sslContext</span>
<span class="line-modified">1310                         .engineGetServerSessionContext();</span>
<span class="line-modified">1311 </span>
<span class="line-added">1312                 // Consume a Session Ticket Extension if it exists</span>
<span class="line-added">1313                 SSLExtension[] ext = new SSLExtension[]{</span>
<span class="line-added">1314                         SSLExtension.CH_SESSION_TICKET</span>
<span class="line-added">1315                 };</span>
<span class="line-added">1316                 clientHello.extensions.consumeOnLoad(shc, ext);</span>
<span class="line-added">1317 </span>
<span class="line-added">1318                 SSLSessionImpl previous;</span>
<span class="line-added">1319                 // Use stateless session ticket if provided.</span>
<span class="line-added">1320                 if (shc.statelessResumption) {</span>
<span class="line-added">1321                     previous = shc.resumingSession;</span>
<span class="line-added">1322                 } else {</span>
<span class="line-added">1323                     previous = cache.get(clientHello.sessionId.getId());</span>
<span class="line-added">1324                 }</span>
1325 
1326                 boolean resumingSession =
1327                         (previous != null) &amp;&amp; previous.isRejoinable();
1328                 if (!resumingSession) {
1329                     if (SSLLogger.isOn &amp;&amp;
1330                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1331                         SSLLogger.finest(
1332                             &quot;Can&#39;t resume, &quot; +
1333                             &quot;the existing session is not rejoinable&quot;);
1334                     }
1335                 }
1336                 // Validate the negotiated protocol version.
1337                 if (resumingSession) {
1338                     ProtocolVersion sessionProtocol =
1339                             previous.getProtocolVersion();
1340                     if (sessionProtocol != shc.negotiatedProtocol) {
1341                         resumingSession = false;
1342                         if (SSLLogger.isOn &amp;&amp;
1343                                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1344                             SSLLogger.finest(
</pre>
</td>
</tr>
</table>
<center><a href="CipherSuite.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHClientKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
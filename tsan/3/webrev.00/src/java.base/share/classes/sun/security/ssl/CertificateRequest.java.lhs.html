<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.PrivateKey;
 31 import java.security.cert.X509Certificate;
 32 import java.text.MessageFormat;
 33 import java.util.ArrayList;
 34 import java.util.Collection;
 35 import java.util.Collections;
 36 import java.util.HashSet;
 37 import java.util.LinkedList;
 38 import java.util.List;
 39 import java.util.Locale;
 40 import javax.net.ssl.SSLEngine;
 41 import javax.net.ssl.SSLSocket;
 42 import javax.net.ssl.X509ExtendedKeyManager;
 43 import javax.security.auth.x500.X500Principal;
 44 import sun.security.ssl.CipherSuite.KeyExchange;
 45 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 46 import sun.security.ssl.X509Authentication.X509Possession;
 47 
 48 /**
 49  * Pack of the CertificateRequest handshake message.
 50  */
 51 final class CertificateRequest {
 52     static final SSLConsumer t10HandshakeConsumer =
 53         new T10CertificateRequestConsumer();
 54     static final HandshakeProducer t10HandshakeProducer =
 55         new T10CertificateRequestProducer();
 56 
 57     static final SSLConsumer t12HandshakeConsumer =
 58         new T12CertificateRequestConsumer();
 59     static final HandshakeProducer t12HandshakeProducer =
 60         new T12CertificateRequestProducer();
 61 
 62     static final SSLConsumer t13HandshakeConsumer =
 63         new T13CertificateRequestConsumer();
 64     static final HandshakeProducer t13HandshakeProducer =
 65         new T13CertificateRequestProducer();
 66 
 67     // TLS 1.2 and prior versions
 68     private static enum ClientCertificateType {
 69         // RFC 2246
 70         RSA_SIGN            ((byte)0x01, &quot;rsa_sign&quot;, &quot;RSA&quot;, true),
 71         DSS_SIGN            ((byte)0x02, &quot;dss_sign&quot;, &quot;DSA&quot;, true),
 72         RSA_FIXED_DH        ((byte)0x03, &quot;rsa_fixed_dh&quot;),
 73         DSS_FIXED_DH        ((byte)0x04, &quot;dss_fixed_dh&quot;),
 74 
 75         // RFC 4346
 76         RSA_EPHEMERAL_DH    ((byte)0x05, &quot;rsa_ephemeral_dh&quot;),
 77         DSS_EPHEMERAL_DH    ((byte)0x06, &quot;dss_ephemeral_dh&quot;),
 78         FORTEZZA_DMS        ((byte)0x14, &quot;fortezza_dms&quot;),
 79 
 80         // RFC 4492
 81         ECDSA_SIGN          ((byte)0x40, &quot;ecdsa_sign&quot;,
 82                                              &quot;EC&quot;, JsseJce.isEcAvailable()),
 83         RSA_FIXED_ECDH      ((byte)0x41, &quot;rsa_fixed_ecdh&quot;),
 84         ECDSA_FIXED_ECDH    ((byte)0x42, &quot;ecdsa_fixed_ecdh&quot;);
 85 
 86         private static final byte[] CERT_TYPES =
 87                 JsseJce.isEcAvailable() ? new byte[] {
 88                         ECDSA_SIGN.id,
 89                         RSA_SIGN.id,
 90                         DSS_SIGN.id
 91                     } :  new byte[] {
 92                         RSA_SIGN.id,
 93                         DSS_SIGN.id
 94                     };
 95 
 96         final byte id;
 97         final String name;
 98         final String keyAlgorithm;
 99         final boolean isAvailable;
100 
101         private ClientCertificateType(byte id, String name) {
102             this(id, name, null, false);
103         }
104 
105         private ClientCertificateType(byte id, String name,
106                 String keyAlgorithm, boolean isAvailable) {
107             this.id = id;
108             this.name = name;
109             this.keyAlgorithm = keyAlgorithm;
110             this.isAvailable = isAvailable;
111         }
112 
113         private static String nameOf(byte id) {
114             for (ClientCertificateType cct : ClientCertificateType.values()) {
115                 if (cct.id == id) {
116                     return cct.name;
117                 }
118             }
119             return &quot;UNDEFINED-CLIENT-CERTIFICATE-TYPE(&quot; + (int)id + &quot;)&quot;;
120         }
121 
122         private static ClientCertificateType valueOf(byte id) {
123             for (ClientCertificateType cct : ClientCertificateType.values()) {
124                 if (cct.id == id) {
125                     return cct;
126                 }
127             }
128 
129             return null;
130         }
131 
132         private static String[] getKeyTypes(byte[] ids) {
133             ArrayList&lt;String&gt; keyTypes = new ArrayList&lt;&gt;(3);
134             for (byte id : ids) {
135                 ClientCertificateType cct = ClientCertificateType.valueOf(id);
136                 if (cct.isAvailable) {
137                     keyTypes.add(cct.keyAlgorithm);
138                 }
139             }
140 
141             return keyTypes.toArray(new String[0]);
142         }
143     }
144 
145     /**
146      * The &quot;CertificateRequest&quot; handshake message for SSL 3.0 and TLS 1.0/1.1.
147      */
148     static final class T10CertificateRequestMessage extends HandshakeMessage {
149         final byte[] types;                 // certificate types
150         final List&lt;byte[]&gt; authorities;     // certificate authorities
151 
152         T10CertificateRequestMessage(HandshakeContext handshakeContext,
153                 X509Certificate[] trustedCerts, KeyExchange keyExchange) {
154             super(handshakeContext);
155 
156             this.authorities = new ArrayList&lt;&gt;(trustedCerts.length);
157             for (X509Certificate cert : trustedCerts) {
158                 X500Principal x500Principal = cert.getSubjectX500Principal();
159                 authorities.add(x500Principal.getEncoded());
160             }
161 
162             this.types = ClientCertificateType.CERT_TYPES;
163         }
164 
165         T10CertificateRequestMessage(HandshakeContext handshakeContext,
166                 ByteBuffer m) throws IOException {
167             super(handshakeContext);
168 
169             // struct {
170             //     ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
171             //     DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
172             // } CertificateRequest;
173             if (m.remaining() &lt; 4) {
174                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
175                     &quot;Incorrect CertificateRequest message: no sufficient data&quot;);
176             }
177             this.types = Record.getBytes8(m);
178 
179             int listLen = Record.getInt16(m);
180             if (listLen &gt; m.remaining()) {
181                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
182                     &quot;Incorrect CertificateRequest message:no sufficient data&quot;);
183             }
184 
185             if (listLen &gt; 0) {
186                 this.authorities = new LinkedList&lt;&gt;();
187                 while (listLen &gt; 0) {
188                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
189                     byte[] encoded = Record.getBytes16(m);
190                     listLen -= (2 + encoded.length);
191                     authorities.add(encoded);
192                 }
193             } else {
194                 this.authorities = Collections.emptyList();
195             }
196         }
197 
198         String[] getKeyTypes() {
199             return  ClientCertificateType.getKeyTypes(types);
200         }
201 
202         X500Principal[] getAuthorities() {
203             List&lt;X500Principal&gt; principals =
204                     new ArrayList&lt;&gt;(authorities.size());
205             for (byte[] encoded : authorities) {
206                 X500Principal principal = new X500Principal(encoded);
207                 principals.add(principal);
208             }
209 
210             return principals.toArray(new X500Principal[0]);
211         }
212 
213         @Override
214         public SSLHandshake handshakeType() {
215             return SSLHandshake.CERTIFICATE_REQUEST;
216         }
217 
218         @Override
219         public int messageLength() {
220             int len = 1 + types.length + 2;
221             for (byte[] encoded : authorities) {
222                 len += encoded.length + 2;
223             }
224             return len;
225         }
226 
227         @Override
228         public void send(HandshakeOutStream hos) throws IOException {
229             hos.putBytes8(types);
230 
231             int listLen = 0;
232             for (byte[] encoded : authorities) {
233                 listLen += encoded.length + 2;
234             }
235 
236             hos.putInt16(listLen);
237             for (byte[] encoded : authorities) {
238                 hos.putBytes16(encoded);
239             }
240         }
241 
242         @Override
243         public String toString() {
244             MessageFormat messageFormat = new MessageFormat(
245                     &quot;\&quot;CertificateRequest\&quot;: &#39;{&#39;\n&quot; +
246                     &quot;  \&quot;certificate types\&quot;: {0}\n&quot; +
247                     &quot;  \&quot;certificate authorities\&quot;: {1}\n&quot; +
248                     &quot;&#39;}&#39;&quot;,
249                     Locale.ENGLISH);
250 
251             List&lt;String&gt; typeNames = new ArrayList&lt;&gt;(types.length);
252             for (byte type : types) {
253                 typeNames.add(ClientCertificateType.nameOf(type));
254             }
255 
256             List&lt;String&gt; authorityNames = new ArrayList&lt;&gt;(authorities.size());
257             for (byte[] encoded : authorities) {
258                 X500Principal principal = new X500Principal(encoded);
259                 authorityNames.add(principal.toString());
260             }
261             Object[] messageFields = {
262                 typeNames,
263                 authorityNames
264             };
265 
266             return messageFormat.format(messageFields);
267         }
268     }
269 
270     /**
271      * The &quot;CertificateRequest&quot; handshake message producer for SSL 3.0 and
272      * TLS 1.0/1.1.
273      */
274     private static final
275             class T10CertificateRequestProducer implements HandshakeProducer {
276         // Prevent instantiation of this class.
277         private T10CertificateRequestProducer() {
278             // blank
279         }
280 
281         @Override
282         public byte[] produce(ConnectionContext context,
283                 HandshakeMessage message) throws IOException {
284             // The producing happens in server side only.
285             ServerHandshakeContext shc = (ServerHandshakeContext)context;
286 
287             X509Certificate[] caCerts =
288                     shc.sslContext.getX509TrustManager().getAcceptedIssuers();
289             T10CertificateRequestMessage crm = new T10CertificateRequestMessage(
290                     shc, caCerts, shc.negotiatedCipherSuite.keyExchange);
291             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
292                 SSLLogger.fine(
293                     &quot;Produced CertificateRequest handshake message&quot;, crm);
294             }
295 
296             // Output the handshake message.
297             crm.write(shc.handshakeOutput);
298             shc.handshakeOutput.flush();
299 
300             //
301             // update
302             //
303             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE.id,
304                     SSLHandshake.CERTIFICATE);
305             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
306                     SSLHandshake.CERTIFICATE_VERIFY);
307 
308             // The handshake message has been delivered.
309             return null;
310         }
311     }
312 
313     /**
314      * The &quot;CertificateRequest&quot; handshake message consumer for SSL 3.0 and
315      * TLS 1.0/1.1.
316      */
317     private static final
318             class T10CertificateRequestConsumer implements SSLConsumer {
319         // Prevent instantiation of this class.
320         private T10CertificateRequestConsumer() {
321             // blank
322         }
323 
324         @Override
325         public void consume(ConnectionContext context,
326                 ByteBuffer message) throws IOException {
327             // The consuming happens in client side only.
328             ClientHandshakeContext chc = (ClientHandshakeContext)context;
329 
330             // clean up this consumer
331             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
332 
<a name="2" id="anc2"></a>








333             T10CertificateRequestMessage crm =
334                     new T10CertificateRequestMessage(chc, message);
335             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
336                 SSLLogger.fine(
337                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
338             }
339 
340             //
341             // validate
342             //
343             // blank
344 
345             //
346             // update
347             //
348 
349             // An empty client Certificate handshake message may be allow.
350             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
351                     SSLHandshake.CERTIFICATE);
352 
353             X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();
354             String clientAlias = null;
355             if (chc.conContext.transport instanceof SSLSocketImpl) {
356                 clientAlias = km.chooseClientAlias(crm.getKeyTypes(),
357                     crm.getAuthorities(), (SSLSocket)chc.conContext.transport);
358             } else if (chc.conContext.transport instanceof SSLEngineImpl) {
359                 clientAlias = km.chooseEngineClientAlias(crm.getKeyTypes(),
360                     crm.getAuthorities(), (SSLEngine)chc.conContext.transport);
361             }
362 
363 
364             if (clientAlias == null) {
365                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
366                     SSLLogger.warning(&quot;No available client authentication&quot;);
367                 }
368                 return;
369             }
370 
371             PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);
372             if (clientPrivateKey == null) {
373                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
374                     SSLLogger.warning(&quot;No available client private key&quot;);
375                 }
376                 return;
377             }
378 
379             X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);
380             if ((clientCerts == null) || (clientCerts.length == 0)) {
381                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
382                     SSLLogger.warning(&quot;No available client certificate&quot;);
383                 }
384                 return;
385             }
386 
387             chc.handshakePossessions.add(
388                     new X509Possession(clientPrivateKey, clientCerts));
389             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
390                     SSLHandshake.CERTIFICATE_VERIFY);
391         }
392     }
393 
394     /**
395      * The CertificateRequest handshake message for TLS 1.2.
396      */
397     static final class T12CertificateRequestMessage extends HandshakeMessage {
398         final byte[] types;                 // certificate types
399         final int[] algorithmIds;           // supported signature algorithms
400         final List&lt;byte[]&gt; authorities;     // certificate authorities
401 
402         T12CertificateRequestMessage(HandshakeContext handshakeContext,
403                 X509Certificate[] trustedCerts, KeyExchange keyExchange,
404                 List&lt;SignatureScheme&gt; signatureSchemes) throws IOException {
405             super(handshakeContext);
406 
407             this.types = ClientCertificateType.CERT_TYPES;
408 
409             if (signatureSchemes == null || signatureSchemes.isEmpty()) {
410                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
411                         &quot;No signature algorithms specified for &quot; +
412                         &quot;CertificateRequest hanshake message&quot;);
413             }
414             this.algorithmIds = new int[signatureSchemes.size()];
415             int i = 0;
416             for (SignatureScheme scheme : signatureSchemes) {
417                 algorithmIds[i++] = scheme.id;
418             }
419 
420             this.authorities = new ArrayList&lt;&gt;(trustedCerts.length);
421             for (X509Certificate cert : trustedCerts) {
422                 X500Principal x500Principal = cert.getSubjectX500Principal();
423                 authorities.add(x500Principal.getEncoded());
424             }
425         }
426 
427         T12CertificateRequestMessage(HandshakeContext handshakeContext,
428                 ByteBuffer m) throws IOException {
429             super(handshakeContext);
430 
431             // struct {
432             //     ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
433             //     SignatureAndHashAlgorithm
434             //       supported_signature_algorithms&lt;2..2^16-2&gt;;
435             //     DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
436             // } CertificateRequest;
437 
438             // certificate_authorities
439             if (m.remaining() &lt; 8) {
440                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
441                         &quot;Invalid CertificateRequest handshake message: &quot; +
442                         &quot;no sufficient data&quot;);
443             }
444             this.types = Record.getBytes8(m);
445 
446             // supported_signature_algorithms
447             if (m.remaining() &lt; 6) {
448                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
449                         &quot;Invalid CertificateRequest handshake message: &quot; +
450                         &quot;no sufficient data&quot;);
451             }
452 
453             byte[] algs = Record.getBytes16(m);
454             if (algs == null || algs.length == 0 || (algs.length &amp; 0x01) != 0) {
455                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
456                         &quot;Invalid CertificateRequest handshake message: &quot; +
457                         &quot;incomplete signature algorithms&quot;);
458             }
459 
460             this.algorithmIds = new int[(algs.length &gt;&gt; 1)];
461             for (int i = 0, j = 0; i &lt; algs.length;) {
462                 byte hash = algs[i++];
463                 byte sign = algs[i++];
464                 algorithmIds[j++] = ((hash &amp; 0xFF) &lt;&lt; 8) | (sign &amp; 0xFF);
465             }
466 
467             // certificate_authorities
468             if (m.remaining() &lt; 2) {
469                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
470                         &quot;Invalid CertificateRequest handshake message: &quot; +
471                         &quot;no sufficient data&quot;);
472             }
473 
474             int listLen = Record.getInt16(m);
475             if (listLen &gt; m.remaining()) {
476                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
477                     &quot;Invalid CertificateRequest message: no sufficient data&quot;);
478             }
479 
480             if (listLen &gt; 0) {
481                 this.authorities = new LinkedList&lt;&gt;();
482                 while (listLen &gt; 0) {
483                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
484                     byte[] encoded = Record.getBytes16(m);
485                     listLen -= (2 + encoded.length);
486                     authorities.add(encoded);
487                 }
488             } else {
489                 this.authorities = Collections.emptyList();
490             }
491         }
492 
493         String[] getKeyTypes() {
494             return ClientCertificateType.getKeyTypes(types);
495         }
496 
497         X500Principal[] getAuthorities() {
498             List&lt;X500Principal&gt; principals =
499                     new ArrayList&lt;&gt;(authorities.size());
500             for (byte[] encoded : authorities) {
501                 X500Principal principal = new X500Principal(encoded);
502                 principals.add(principal);
503             }
504 
505             return principals.toArray(new X500Principal[0]);
506         }
507 
508         @Override
509         public SSLHandshake handshakeType() {
510             return SSLHandshake.CERTIFICATE_REQUEST;
511         }
512 
513         @Override
514         public int messageLength() {
515             int len = 1 + types.length + 2 + (algorithmIds.length &lt;&lt; 1) + 2;
516             for (byte[] encoded : authorities) {
517                 len += encoded.length + 2;
518             }
519             return len;
520         }
521 
522         @Override
523         public void send(HandshakeOutStream hos) throws IOException {
524             hos.putBytes8(types);
525 
526             int listLen = 0;
527             for (byte[] encoded : authorities) {
528                 listLen += encoded.length + 2;
529             }
530 
531             hos.putInt16(algorithmIds.length &lt;&lt; 1);
532             for (int algorithmId : algorithmIds) {
533                 hos.putInt16(algorithmId);
534             }
535 
536             hos.putInt16(listLen);
537             for (byte[] encoded : authorities) {
538                 hos.putBytes16(encoded);
539             }
540         }
541 
542         @Override
543         public String toString() {
544             MessageFormat messageFormat = new MessageFormat(
545                     &quot;\&quot;CertificateRequest\&quot;: &#39;{&#39;\n&quot; +
546                     &quot;  \&quot;certificate types\&quot;: {0}\n&quot; +
547                     &quot;  \&quot;supported signature algorithms\&quot;: {1}\n&quot; +
548                     &quot;  \&quot;certificate authorities\&quot;: {2}\n&quot; +
549                     &quot;&#39;}&#39;&quot;,
550                     Locale.ENGLISH);
551 
552             List&lt;String&gt; typeNames = new ArrayList&lt;&gt;(types.length);
553             for (byte type : types) {
554                 typeNames.add(ClientCertificateType.nameOf(type));
555             }
556 
557             List&lt;String&gt; algorithmNames = new ArrayList&lt;&gt;(algorithmIds.length);
558             for (int algorithmId : algorithmIds) {
559                 algorithmNames.add(SignatureScheme.nameOf(algorithmId));
560             }
561 
562             List&lt;String&gt; authorityNames = new ArrayList&lt;&gt;(authorities.size());
563             for (byte[] encoded : authorities) {
564                 X500Principal principal = new X500Principal(encoded);
565                 authorityNames.add(principal.toString());
566             }
567             Object[] messageFields = {
568                 typeNames,
569                 algorithmNames,
570                 authorityNames
571             };
572 
573             return messageFormat.format(messageFields);
574         }
575     }
576 
577     /**
578      * The &quot;CertificateRequest&quot; handshake message producer for TLS 1.2.
579      */
580     private static final
581             class T12CertificateRequestProducer implements HandshakeProducer {
582         // Prevent instantiation of this class.
583         private T12CertificateRequestProducer() {
584             // blank
585         }
586 
587         @Override
588         public byte[] produce(ConnectionContext context,
589                 HandshakeMessage message) throws IOException {
590             // The producing happens in server side only.
591             ServerHandshakeContext shc = (ServerHandshakeContext)context;
592             if (shc.localSupportedSignAlgs == null) {
593                 shc.localSupportedSignAlgs =
594                     SignatureScheme.getSupportedAlgorithms(
595                             shc.algorithmConstraints, shc.activeProtocols);
596             }
597 
598             if (shc.localSupportedSignAlgs == null ||
599                     shc.localSupportedSignAlgs.isEmpty()) {
600                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
601                     &quot;No supported signature algorithm&quot;);
602             }
603 
604             X509Certificate[] caCerts =
605                     shc.sslContext.getX509TrustManager().getAcceptedIssuers();
606             T12CertificateRequestMessage crm = new T12CertificateRequestMessage(
607                     shc, caCerts, shc.negotiatedCipherSuite.keyExchange,
608                     shc.localSupportedSignAlgs);
609             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
610                 SSLLogger.fine(
611                     &quot;Produced CertificateRequest handshake message&quot;, crm);
612             }
613 
614             // Output the handshake message.
615             crm.write(shc.handshakeOutput);
616             shc.handshakeOutput.flush();
617 
618             //
619             // update
620             //
621             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE.id,
622                     SSLHandshake.CERTIFICATE);
623             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
624                     SSLHandshake.CERTIFICATE_VERIFY);
625 
626             // The handshake message has been delivered.
627             return null;
628         }
629     }
630 
631     /**
632      * The &quot;CertificateRequest&quot; handshake message consumer for TLS 1.2.
633      */
634     private static final
635             class T12CertificateRequestConsumer implements SSLConsumer {
636         // Prevent instantiation of this class.
637         private T12CertificateRequestConsumer() {
638             // blank
639         }
640 
641         @Override
642         public void consume(ConnectionContext context,
643                 ByteBuffer message) throws IOException {
644             // The consuming happens in client side only.
645             ClientHandshakeContext chc = (ClientHandshakeContext)context;
646 
647             // clean up this consumer
648             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
649 
<a name="3" id="anc3"></a>








650             T12CertificateRequestMessage crm =
651                     new T12CertificateRequestMessage(chc, message);
652             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
653                 SSLLogger.fine(
654                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
655             }
656 
657             //
658             // validate
659             //
660             // blank
661 
662             //
663             // update
664             //
665 
666             // An empty client Certificate handshake message may be allow.
667             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
668                     SSLHandshake.CERTIFICATE);
669 
670             List&lt;SignatureScheme&gt; sss = new LinkedList&lt;&gt;();
671             for (int id : crm.algorithmIds) {
672                 SignatureScheme ss = SignatureScheme.valueOf(id);
673                 if (ss != null) {
674                     sss.add(ss);
675                 }
676             }
677             chc.peerRequestedSignatureSchemes = sss;
678             chc.peerRequestedCertSignSchemes = sss;     // use the same schemes
679             chc.handshakeSession.setPeerSupportedSignatureAlgorithms(sss);
680             chc.peerSupportedAuthorities = crm.getAuthorities();
681 
682             // For TLS 1.2, we no longer use the certificate_types field
683             // from the CertificateRequest message to directly determine
684             // the SSLPossession.  Instead, the choosePossession method
685             // will use the accepted signature schemes in the message to
686             // determine the set of acceptable certificate types to select from.
687             SSLPossession pos = choosePossession(chc);
688             if (pos == null) {
689                 return;
690             }
691 
692             chc.handshakePossessions.add(pos);
693             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
694                     SSLHandshake.CERTIFICATE_VERIFY);
695         }
696 
697         private static SSLPossession choosePossession(HandshakeContext hc)
698                 throws IOException {
699             if (hc.peerRequestedCertSignSchemes == null ||
700                     hc.peerRequestedCertSignSchemes.isEmpty()) {
701                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
702                     SSLLogger.warning(&quot;No signature and hash algorithms &quot; +
703                             &quot;in CertificateRequest&quot;);
704                 }
705                 return null;
706             }
707 
708             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
709             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
710                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
711                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
712                         SSLLogger.warning(
713                             &quot;Unsupported authentication scheme: &quot; + ss.name);
714                     }
715                     continue;
716                 }
717 
718                 // Don&#39;t select a signature scheme unless we will be able to
719                 // produce a CertificateVerify message later
720                 if (SignatureScheme.getPreferableAlgorithm(
<a name="4" id="anc4"></a>
721                         hc.peerRequestedSignatureSchemes,
722                         ss, hc.negotiatedProtocol) == null) {
723 
724                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
725                         SSLLogger.warning(
726                             &quot;Unable to produce CertificateVerify for &quot; +
727                             &quot;signature scheme: &quot; + ss.name);
728                     }
729                     checkedKeyTypes.add(ss.keyAlgorithm);
730                     continue;
731                 }
732 
733                 SSLAuthentication ka = X509Authentication.valueOf(ss);
734                 if (ka == null) {
735                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
736                         SSLLogger.warning(
737                             &quot;Unsupported authentication scheme: &quot; + ss.name);
738                     }
739                     checkedKeyTypes.add(ss.keyAlgorithm);
740                     continue;
741                 }
742 
743                 SSLPossession pos = ka.createPossession(hc);
744                 if (pos == null) {
745                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
746                         SSLLogger.warning(
747                             &quot;Unavailable authentication scheme: &quot; + ss.name);
748                     }
749                     continue;
750                 }
751 
752                 return pos;
753             }
754 
755             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
756                 SSLLogger.warning(&quot;No available authentication scheme&quot;);
757             }
758             return null;
759         }
760     }
761 
762     /**
763      * The CertificateRequest handshake message for TLS 1.3.
764      */
765     static final class T13CertificateRequestMessage extends HandshakeMessage {
766         private final byte[] requestContext;
767         private final SSLExtensions extensions;
768 
769         T13CertificateRequestMessage(
770                 HandshakeContext handshakeContext) throws IOException {
771             super(handshakeContext);
772 
773             this.requestContext = new byte[0];
774             this.extensions = new SSLExtensions(this);
775         }
776 
777         T13CertificateRequestMessage(HandshakeContext handshakeContext,
778                 ByteBuffer m) throws IOException {
779             super(handshakeContext);
780 
781             // struct {
782             //      opaque certificate_request_context&lt;0..2^8-1&gt;;
783             //      Extension extensions&lt;2..2^16-1&gt;;
784             //  } CertificateRequest;
785             if (m.remaining() &lt; 5) {
786                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
787                         &quot;Invalid CertificateRequest handshake message: &quot; +
788                         &quot;no sufficient data&quot;);
789             }
790             this.requestContext = Record.getBytes8(m);
791 
792             if (m.remaining() &lt; 4) {
793                 throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,
794                         &quot;Invalid CertificateRequest handshake message: &quot; +
795                         &quot;no sufficient extensions data&quot;);
796             }
797             SSLExtension[] enabledExtensions =
798                 handshakeContext.sslConfig.getEnabledExtensions(
799                         SSLHandshake.CERTIFICATE_REQUEST);
800             this.extensions = new SSLExtensions(this, m, enabledExtensions);
801         }
802 
803         @Override
804         SSLHandshake handshakeType() {
805             return SSLHandshake.CERTIFICATE_REQUEST;
806         }
807 
808         @Override
809         int messageLength() {
810             // In TLS 1.3, use of certain extensions is mandatory.
811             return 1 + requestContext.length + extensions.length();
812         }
813 
814         @Override
815         void send(HandshakeOutStream hos) throws IOException {
816             hos.putBytes8(requestContext);
817 
818             // In TLS 1.3, use of certain extensions is mandatory.
819             extensions.send(hos);
820         }
821 
822         @Override
823         public String toString() {
824             MessageFormat messageFormat = new MessageFormat(
825                 &quot;\&quot;CertificateRequest\&quot;: &#39;{&#39;\n&quot; +
826                 &quot;  \&quot;certificate_request_context\&quot;: \&quot;{0}\&quot;,\n&quot; +
827                 &quot;  \&quot;extensions\&quot;: [\n&quot; +
828                 &quot;{1}\n&quot; +
829                 &quot;  ]\n&quot; +
830                 &quot;&#39;}&#39;&quot;,
831                 Locale.ENGLISH);
832             Object[] messageFields = {
833                 Utilities.toHexString(requestContext),
834                 Utilities.indent(Utilities.indent(extensions.toString()))
835             };
836 
837             return messageFormat.format(messageFields);
838         }
839     }
840 
841     /**
842      * The &quot;CertificateRequest&quot; handshake message producer for TLS 1.3.
843      */
844     private static final
845             class T13CertificateRequestProducer implements HandshakeProducer {
846         // Prevent instantiation of this class.
847         private T13CertificateRequestProducer() {
848             // blank
849         }
850 
851         @Override
852         public byte[] produce(ConnectionContext context,
853                 HandshakeMessage message) throws IOException {
854             // The producing happens in server side only.
855             ServerHandshakeContext shc = (ServerHandshakeContext)context;
856 
857             T13CertificateRequestMessage crm =
858                     new T13CertificateRequestMessage(shc);
859             // Produce extensions for CertificateRequest handshake message.
860             SSLExtension[] extTypes = shc.sslConfig.getEnabledExtensions(
861                     SSLHandshake.CERTIFICATE_REQUEST, shc.negotiatedProtocol);
862             crm.extensions.produce(shc, extTypes);
863             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
864                 SSLLogger.fine(&quot;Produced CertificateRequest message&quot;, crm);
865             }
866 
867             // Output the handshake message.
868             crm.write(shc.handshakeOutput);
869             shc.handshakeOutput.flush();
870 
871             //
872             // update
873             //
874             shc.certRequestContext = crm.requestContext.clone();
875             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE.id,
876                     SSLHandshake.CERTIFICATE);
877             shc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
878                     SSLHandshake.CERTIFICATE_VERIFY);
879 
880             // The handshake message has been delivered.
881             return null;
882         }
883     }
884 
885     /**
886      * The &quot;CertificateRequest&quot; handshake message consumer for TLS 1.3.
887      */
888     private static final
889             class T13CertificateRequestConsumer implements SSLConsumer {
890         // Prevent instantiation of this class.
891         private T13CertificateRequestConsumer() {
892             // blank
893         }
894 
895         @Override
896         public void consume(ConnectionContext context,
897                 ByteBuffer message) throws IOException {
898             // The consuming happens in client side only.
899             ClientHandshakeContext chc = (ClientHandshakeContext)context;
900 
901             // clean up this consumer
902             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
903 
904             T13CertificateRequestMessage crm =
905                     new T13CertificateRequestMessage(chc, message);
906             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
907                 SSLLogger.fine(
908                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
909             }
910 
911             //
912             // validate
913             //
914             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
915                     SSLHandshake.CERTIFICATE_REQUEST);
916             crm.extensions.consumeOnLoad(chc, extTypes);
917 
918             //
919             // update
920             //
921             crm.extensions.consumeOnTrade(chc, extTypes);
922 
923             //
924             // produce
925             //
926             chc.certRequestContext = crm.requestContext.clone();
927             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
928                     SSLHandshake.CERTIFICATE);
929             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE_VERIFY.id,
930                     SSLHandshake.CERTIFICATE_VERIFY);
931         }
932     }
933 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
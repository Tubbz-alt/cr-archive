<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLContextImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineInputRecord.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLEngineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  import java.security.AccessController;
  import java.security.PrivilegedActionException;
  import java.security.PrivilegedExceptionAction;
  import java.util.List;
  import java.util.Map;
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import java.util.function.BiFunction;
  import javax.net.ssl.SSLEngine;
  import javax.net.ssl.SSLEngineResult;
  import javax.net.ssl.SSLEngineResult.HandshakeStatus;
  import javax.net.ssl.SSLEngineResult.Status;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,10 ***</span>
<span class="line-new-header">--- 53,11 ---</span>
   * @author Brad Wetmore
   */
  final class SSLEngineImpl extends SSLEngine implements SSLTransport {
      private final SSLContextImpl        sslContext;
      final TransportContext              conContext;
<span class="line-added">+     private final ReentrantLock         engineLock = new ReentrantLock();</span>
  
      /**
       * Constructor for an SSLEngine from SSLContext, without
       * host/port hints.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,61 ***</span>
                              conContext.sslConfig.serverNames, host);
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized void beginHandshake() throws SSLException {</span>
<span class="line-modified">!         if (conContext.isUnsureMode) {</span>
<span class="line-removed">-             throw new IllegalStateException(</span>
<span class="line-removed">-                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          try {
<span class="line-modified">!             conContext.kickstart();</span>
<span class="line-modified">!         } catch (IOException ioe) {</span>
<span class="line-modified">!             throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-modified">!                 &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-modified">!         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                 &quot;Fail to begin handshake&quot;, ex);</span>
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLEngineResult wrap(ByteBuffer[] appData,</span>
              int offset, int length, ByteBuffer netData) throws SSLException {
          return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
      }
  
      // @Override
<span class="line-modified">!     public synchronized SSLEngineResult wrap(</span>
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
          ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
  
<span class="line-modified">!         if (conContext.isUnsureMode) {</span>
<span class="line-modified">!             throw new IllegalStateException(</span>
<span class="line-modified">!                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified">!         checkTaskThrown();</span>
  
<span class="line-modified">!         // check parameters</span>
<span class="line-modified">!         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return writeRecord(</span>
<span class="line-modified">!                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified">!         } catch (SSLProtocolException spe) {</span>
<span class="line-modified">!             // may be an unexpected handshake message</span>
<span class="line-modified">!             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified">!         } catch (IOException ioe) {</span>
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                 &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified">!         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                 &quot;Fail to wrap application data&quot;, ex);</span>
          }
      }
  
      private SSLEngineResult writeRecord(
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
<span class="line-new-header">--- 93,72 ---</span>
                              conContext.sslConfig.serverNames, host);
          }
      }
  
      @Override
<span class="line-modified">!     public void beginHandshake() throws SSLException {</span>
<span class="line-modified">!         engineLock.lock();</span>
          try {
<span class="line-modified">!             if (conContext.isUnsureMode) {</span>
<span class="line-modified">!                 throw new IllegalStateException(</span>
<span class="line-modified">!                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 conContext.kickstart();</span>
<span class="line-added">+             } catch (IOException ioe) {</span>
<span class="line-added">+                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,</span>
<span class="line-added">+                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);</span>
<span class="line-added">+             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-added">+                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-added">+                     &quot;Fail to begin handshake&quot;, ex);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
      }
  
      @Override
<span class="line-modified">!     public SSLEngineResult wrap(ByteBuffer[] appData,</span>
              int offset, int length, ByteBuffer netData) throws SSLException {
          return wrap(appData, offset, length, new ByteBuffer[]{ netData }, 0, 1);
      }
  
      // @Override
<span class="line-modified">!     public SSLEngineResult wrap(</span>
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
          ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
  
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (conContext.isUnsureMode) {</span>
<span class="line-modified">!                 throw new IllegalStateException(</span>
<span class="line-added">+                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified">!             checkTaskThrown();</span>
  
<span class="line-modified">!             // check parameters</span>
<span class="line-modified">!             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added">+                     dsts, dstsOffset, dstsLength);</span>
  
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 return writeRecord(</span>
<span class="line-modified">!                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified">!             } catch (SSLProtocolException spe) {</span>
<span class="line-modified">!                 // may be an unexpected handshake message</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, spe);</span>
<span class="line-modified">!             } catch (IOException ioe) {</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                     &quot;problem wrapping app data&quot;, ioe);</span>
<span class="line-modified">!             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                     &quot;Fail to wrap application data&quot;, ex);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
      }
  
      private SSLEngineResult writeRecord(
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,10 ***</span>
<span class="line-new-header">--- 342,16 ---</span>
          if (conContext.outputRecord.seqNumIsHuge() ||
                  conContext.outputRecord.writeCipher.atKeyLimit()) {
              hsStatus = tryKeyUpdate(hsStatus);
          }
  
<span class="line-added">+         // Check if NewSessionTicket PostHandshake message needs to be sent</span>
<span class="line-added">+         if (conContext.conSession.updateNST &amp;&amp;</span>
<span class="line-added">+                 !conContext.sslConfig.isClientMode) {</span>
<span class="line-added">+             hsStatus = tryNewSessionTicket(hsStatus);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // update context status
          ciphertext.handshakeStatus = hsStatus;
  
          return ciphertext;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,10 ***</span>
<span class="line-new-header">--- 401,33 ---</span>
          }
  
          return currentHandshakeStatus;
      }
  
<span class="line-added">+     // Try to generate a PostHandshake NewSessionTicket message.  This is</span>
<span class="line-added">+     // TLS 1.3 only.</span>
<span class="line-added">+     private HandshakeStatus tryNewSessionTicket(</span>
<span class="line-added">+             HandshakeStatus currentHandshakeStatus) throws IOException {</span>
<span class="line-added">+         // Don&#39;t bother to kickstart if handshaking is in progress, or if the</span>
<span class="line-added">+         // connection is not duplex-open.</span>
<span class="line-added">+         if ((conContext.handshakeContext == null) &amp;&amp;</span>
<span class="line-added">+                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">+                 !conContext.isOutboundClosed() &amp;&amp;</span>
<span class="line-added">+                 !conContext.isInboundClosed() &amp;&amp;</span>
<span class="line-added">+                 !conContext.isBroken) {</span>
<span class="line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                 SSLLogger.finest(&quot;trigger NST&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             conContext.conSession.updateNST = false;</span>
<span class="line-added">+             NewSessionTicket.kickstartProducer.produce(</span>
<span class="line-added">+                     new PostHandshakeContext(conContext));</span>
<span class="line-added">+             return conContext.getHandshakeStatus();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return currentHandshakeStatus;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static void checkParams(
              ByteBuffer[] srcs, int srcsOffset, int srcsLength,
              ByteBuffer[] dsts, int dstsOffset, int dstsLength) {
  
          if ((srcs == null) || (dsts == null)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,51 ***</span>
              }
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLEngineResult unwrap(ByteBuffer src,</span>
              ByteBuffer[] dsts, int offset, int length) throws SSLException {
          return unwrap(
                  new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
      }
  
      // @Override
<span class="line-modified">!     public synchronized SSLEngineResult unwrap(</span>
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
          ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
  
<span class="line-modified">!         if (conContext.isUnsureMode) {</span>
<span class="line-modified">!             throw new IllegalStateException(</span>
<span class="line-modified">!                     &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified">!         checkTaskThrown();</span>
  
<span class="line-modified">!         // check parameters</span>
<span class="line-modified">!         checkParams(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return readRecord(</span>
<span class="line-modified">!                 srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified">!         } catch (SSLProtocolException spe) {</span>
<span class="line-modified">!             // may be an unexpected handshake message</span>
<span class="line-modified">!             throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">!                     spe.getMessage(), spe);</span>
<span class="line-modified">!         } catch (IOException ioe) {</span>
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified">!              * consume anything.  We did consume something, and it</span>
<span class="line-modified">!              * got us into this situation, so report that much back.</span>
<span class="line-modified">!              * Our days of consuming are now over anyway.</span>
<span class="line-modified">!              */</span>
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                     &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified">!         } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                 &quot;Fail to unwrap network record&quot;, ex);</span>
          }
      }
  
      private SSLEngineResult readRecord(
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
<span class="line-new-header">--- 468,57 ---</span>
              }
          }
      }
  
      @Override
<span class="line-modified">!     public SSLEngineResult unwrap(ByteBuffer src,</span>
              ByteBuffer[] dsts, int offset, int length) throws SSLException {
          return unwrap(
                  new ByteBuffer[]{src}, 0, 1, dsts, offset, length);
      }
  
      // @Override
<span class="line-modified">!     public SSLEngineResult unwrap(</span>
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
          ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws SSLException {
  
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (conContext.isUnsureMode) {</span>
<span class="line-modified">!                 throw new IllegalStateException(</span>
<span class="line-added">+                         &quot;Client/Server mode has not yet been set.&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // See if the handshaker needs to report back some SSLException.</span>
<span class="line-modified">!             checkTaskThrown();</span>
  
<span class="line-modified">!             // check parameters</span>
<span class="line-modified">!             checkParams(srcs, srcsOffset, srcsLength,</span>
<span class="line-added">+                     dsts, dstsOffset, dstsLength);</span>
  
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 return readRecord(</span>
<span class="line-modified">!                     srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);</span>
<span class="line-modified">!             } catch (SSLProtocolException spe) {</span>
<span class="line-modified">!                 // may be an unexpected handshake message</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">!                         spe.getMessage(), spe);</span>
<span class="line-modified">!             } catch (IOException ioe) {</span>
<span class="line-modified">!                 /*</span>
<span class="line-modified">!                  * Don&#39;t reset position so it looks like we didn&#39;t</span>
<span class="line-modified">!                  * consume anything.  We did consume something, and it</span>
<span class="line-modified">!                  * got us into this situation, so report that much back.</span>
<span class="line-modified">!                  * Our days of consuming are now over anyway.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                         &quot;problem unwrapping net record&quot;, ioe);</span>
<span class="line-modified">!             } catch (Exception ex) {     // including RuntimeException</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                     &quot;Fail to unwrap network record&quot;, ex);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
      }
  
      private SSLEngineResult readRecord(
          ByteBuffer[] srcs, int srcsOffset, int srcsLength,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,203 ***</span>
  
          return pt;
      }
  
      @Override
<span class="line-modified">!     public synchronized Runnable getDelegatedTask() {</span>
<span class="line-modified">!         if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified">!                 !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified">!                 !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-modified">!             conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-modified">!             return new DelegatedTask(this);</span>
          }
  
          return null;
      }
  
      @Override
<span class="line-modified">!     public synchronized void closeInbound() throws SSLException {</span>
<span class="line-modified">!         if (isInboundDone()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!             SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Is it ready to close inbound?</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // No need to throw exception if the initial handshake is not started.</span>
<span class="line-modified">!         if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified">!             (conContext.isNegotiated || conContext.handshakeContext != null)) {</span>
  
<span class="line-modified">!             throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                     &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         conContext.closeInbound();</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean isInboundDone() {</span>
<span class="line-modified">!         return conContext.isInboundClosed();</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void closeOutbound() {</span>
<span class="line-modified">!         if (conContext.isOutboundClosed()) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!             SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         conContext.closeOutbound();</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean isOutboundDone() {</span>
<span class="line-modified">!         return conContext.isOutboundDone();</span>
      }
  
      @Override
      public String[] getSupportedCipherSuites() {
          return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
      }
  
      @Override
<span class="line-modified">!     public synchronized String[] getEnabledCipherSuites() {</span>
<span class="line-modified">!         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified">!         conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-modified">!                 CipherSuite.validValuesOf(suites);</span>
      }
  
      @Override
      public String[] getSupportedProtocols() {
          return ProtocolVersion.toStringArray(
                  sslContext.getSupportedProtocolVersions());
      }
  
      @Override
<span class="line-modified">!     public synchronized String[] getEnabledProtocols() {</span>
<span class="line-modified">!         return ProtocolVersion.toStringArray(</span>
<span class="line-modified">!                 conContext.sslConfig.enabledProtocols);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified">!         if (protocols == null) {</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified">!                 ProtocolVersion.namesOf(protocols);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLSession getSession() {</span>
<span class="line-modified">!         return conContext.conSession;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLSession getHandshakeSession() {</span>
<span class="line-modified">!         return conContext.handshakeContext == null ?</span>
<span class="line-modified">!                 null : conContext.handshakeContext.handshakeSession;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified">!         return conContext.getHandshakeStatus();</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setUseClientMode(boolean mode) {</span>
<span class="line-modified">!         conContext.setUseClientMode(mode);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getUseClientMode() {</span>
<span class="line-modified">!         return conContext.sslConfig.isClientMode;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setNeedClientAuth(boolean need) {</span>
<span class="line-modified">!         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified">!                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_NONE);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getNeedClientAuth() {</span>
<span class="line-modified">!         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_REQUIRED);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setWantClientAuth(boolean want) {</span>
<span class="line-modified">!         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified">!                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_NONE);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getWantClientAuth() {</span>
<span class="line-modified">!         return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_REQUESTED);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified">!         conContext.sslConfig.enableSessionCreation = flag;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getEnableSessionCreation() {</span>
<span class="line-modified">!         return conContext.sslConfig.enableSessionCreation;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLParameters getSSLParameters() {</span>
<span class="line-modified">!         return conContext.sslConfig.getSSLParameters();</span>
<span class="line-modified">!     }</span>
  
      @Override
<span class="line-modified">!     public synchronized void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">!         conContext.sslConfig.setSSLParameters(params);</span>
  
<span class="line-modified">!         if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">!             conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">!                     conContext.sslConfig.maximumPacketSize);</span>
          }
<span class="line-modified">!     }</span>
  
      @Override
<span class="line-modified">!     public synchronized String getApplicationProtocol() {</span>
<span class="line-modified">!         return conContext.applicationProtocol;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">!         return conContext.handshakeContext == null ?</span>
<span class="line-modified">!                 null : conContext.handshakeContext.applicationProtocol;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setHandshakeApplicationProtocolSelector(</span>
              BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">!         conContext.sslConfig.engineAPSelector = selector;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
              getHandshakeApplicationProtocolSelector() {
<span class="line-modified">!         return conContext.sslConfig.engineAPSelector;</span>
      }
  
      @Override
      public boolean useDelegatedTask() {
          return true;
<span class="line-new-header">--- 749,334 ---</span>
  
          return pt;
      }
  
      @Override
<span class="line-modified">!     public Runnable getDelegatedTask() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (conContext.handshakeContext != null &amp;&amp; // PRE or POST handshake</span>
<span class="line-modified">!                     !conContext.handshakeContext.taskDelegated &amp;&amp;</span>
<span class="line-modified">!                     !conContext.handshakeContext.delegatedActions.isEmpty()) {</span>
<span class="line-added">+                 conContext.handshakeContext.taskDelegated = true;</span>
<span class="line-added">+                 return new DelegatedTask(this);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
  
          return null;
      }
  
      @Override
<span class="line-modified">!     public void closeInbound() throws SSLException {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isInboundDone()) {</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!                 SSLLogger.finest(&quot;Closing inbound of SSLEngine&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             // Is it ready to close inbound?</span>
<span class="line-modified">!             //</span>
<span class="line-modified">!             // No exception if the initial handshake is not started.</span>
<span class="line-modified">!             if (!conContext.isInputCloseNotified &amp;&amp;</span>
<span class="line-modified">!                 (conContext.isNegotiated ||</span>
<span class="line-added">+                     conContext.handshakeContext != null)) {</span>
  
<span class="line-modified">!                 throw conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-modified">!                         &quot;closing inbound before receiving peer&#39;s close_notify&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             conContext.closeInbound();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean isInboundDone() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.isInboundClosed();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void closeOutbound() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (conContext.isOutboundClosed()) {</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">!                 SSLLogger.finest(&quot;Closing outbound of SSLEngine&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             conContext.closeOutbound();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean isOutboundDone() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.isOutboundDone();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public String[] getSupportedCipherSuites() {
          return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
      }
  
      @Override
<span class="line-modified">!     public String[] getEnabledCipherSuites() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-added">+                     CipherSuite.validValuesOf(suites);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public String[] getSupportedProtocols() {
          return ProtocolVersion.toStringArray(
                  sslContext.getSupportedProtocolVersions());
      }
  
      @Override
<span class="line-modified">!     public String[] getEnabledProtocols() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return ProtocolVersion.toStringArray(</span>
<span class="line-added">+                     conContext.sslConfig.enabledProtocols);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnabledProtocols(String[] protocols) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (protocols == null) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified">!                     ProtocolVersion.namesOf(protocols);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public SSLSession getSession() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.conSession;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public SSLSession getHandshakeSession() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return conContext.handshakeContext == null ?</span>
<span class="line-added">+                     null : conContext.handshakeContext.handshakeSession;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public SSLEngineResult.HandshakeStatus getHandshakeStatus() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.getHandshakeStatus();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setUseClientMode(boolean mode) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.setUseClientMode(mode);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getUseClientMode() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.isClientMode;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setNeedClientAuth(boolean need) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             conContext.sslConfig.clientAuthType =</span>
<span class="line-added">+                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getNeedClientAuth() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_REQUIRED);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setWantClientAuth(boolean want) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             conContext.sslConfig.clientAuthType =</span>
<span class="line-added">+                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getWantClientAuth() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return (conContext.sslConfig.clientAuthType ==</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_REQUESTED);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.enableSessionCreation = flag;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getEnableSessionCreation() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.enableSessionCreation;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public SSLParameters getSSLParameters() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return conContext.sslConfig.getSSLParameters();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+    }</span>
  
      @Override
<span class="line-modified">!     public void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.setSSLParameters(params);</span>
  
<span class="line-modified">!             if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">!                 conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">!                         conContext.sslConfig.maximumPacketSize);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
<span class="line-modified">!    }</span>
  
      @Override
<span class="line-modified">!     public String getApplicationProtocol() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.applicationProtocol;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return conContext.handshakeContext == null ?</span>
<span class="line-added">+                     null : conContext.handshakeContext.applicationProtocol;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setHandshakeApplicationProtocolSelector(</span>
              BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.engineAPSelector = selector;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public BiFunction&lt;SSLEngine, List&lt;String&gt;, String&gt;</span>
              getHandshakeApplicationProtocolSelector() {
<span class="line-modified">!         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.engineAPSelector;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public boolean useDelegatedTask() {
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,42 ***</span>
       * Depending on whether the error was just a warning and the
       * handshaker wasn&#39;t closed, or fatal and the handshaker is now
       * null, report back the Exception that happened in the delegated
       * task(s).
       */
<span class="line-modified">!     private synchronized void checkTaskThrown() throws SSLException {</span>
  
          Exception exc = null;
  
<span class="line-modified">!         // First check the handshake context.</span>
<span class="line-modified">!         HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-modified">!         if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-modified">!             exc = hc.delegatedThrown;</span>
<span class="line-modified">!             hc.delegatedThrown = null;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * hc.delegatedThrown and conContext.delegatedThrown are most likely</span>
<span class="line-modified">!          * the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified">!          * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified">!          * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified">!          * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified">!          * need to clear that on a successive call.  Otherwise, clear it now.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         if (conContext.delegatedThrown != null) {</span>
<span class="line-modified">!             if (exc != null) {</span>
<span class="line-modified">!                 // hc object comparison</span>
<span class="line-modified">!                 if (conContext.delegatedThrown == exc) {</span>
<span class="line-removed">-                     // clear if/only if both are the same</span>
                      conContext.delegatedThrown = null;
<span class="line-modified">!                 } // otherwise report the hc delegatedThrown</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-removed">-                 // TransportContext.</span>
<span class="line-removed">-                 exc = conContext.delegatedThrown;</span>
<span class="line-removed">-                 conContext.delegatedThrown = null;</span>
              }
          }
  
          // Anything to report?
          if (exc == null) {
              return;
<span class="line-new-header">--- 1086,46 ---</span>
       * Depending on whether the error was just a warning and the
       * handshaker wasn&#39;t closed, or fatal and the handshaker is now
       * null, report back the Exception that happened in the delegated
       * task(s).
       */
<span class="line-modified">!     private void checkTaskThrown() throws SSLException {</span>
  
          Exception exc = null;
<span class="line-added">+         engineLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             // First check the handshake context.</span>
<span class="line-added">+             HandshakeContext hc = conContext.handshakeContext;</span>
<span class="line-added">+             if ((hc != null) &amp;&amp; (hc.delegatedThrown != null)) {</span>
<span class="line-added">+                 exc = hc.delegatedThrown;</span>
<span class="line-added">+                 hc.delegatedThrown = null;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             /*</span>
<span class="line-modified">!              * hc.delegatedThrown and conContext.delegatedThrown are most</span>
<span class="line-modified">!              * likely the same, but it&#39;s possible we could have had a non-fatal</span>
<span class="line-modified">!              * exception and thus the new HandshakeContext is still valid</span>
<span class="line-modified">!              * (alert warning).  If so, then we may have a secondary exception</span>
<span class="line-modified">!              * waiting to be reported from the TransportContext, so we will</span>
<span class="line-modified">!              * need to clear that on a successive call. Otherwise, clear it now.</span>
<span class="line-modified">!              */</span>
<span class="line-modified">!             if (conContext.delegatedThrown != null) {</span>
<span class="line-modified">!                 if (exc != null) {</span>
<span class="line-modified">!                     // hc object comparison</span>
<span class="line-modified">!                     if (conContext.delegatedThrown == exc) {</span>
<span class="line-modified">!                         // clear if/only if both are the same</span>
<span class="line-modified">!                         conContext.delegatedThrown = null;</span>
<span class="line-modified">!                     } // otherwise report the hc delegatedThrown</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     // Nothing waiting in HandshakeContext, but one is in the</span>
<span class="line-modified">!                     // TransportContext.</span>
<span class="line-modified">!                     exc = conContext.delegatedThrown;</span>
                      conContext.delegatedThrown = null;
<span class="line-modified">!                 }</span>
              }
<span class="line-added">+         } finally {</span>
<span class="line-added">+             engineLock.unlock();</span>
          }
  
          // Anything to report?
          if (exc == null) {
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,11 ***</span>
              this.engine = engineInstance;
          }
  
          @Override
          public void run() {
<span class="line-modified">!             synchronized (engine) {</span>
                  HandshakeContext hc = engine.conContext.handshakeContext;
                  if (hc == null || hc.delegatedActions.isEmpty()) {
                      return;
                  }
  
<span class="line-new-header">--- 1179,12 ---</span>
              this.engine = engineInstance;
          }
  
          @Override
          public void run() {
<span class="line-modified">!             engine.engineLock.lock();</span>
<span class="line-added">+             try {</span>
                  HandshakeContext hc = engine.conContext.handshakeContext;
                  if (hc == null || hc.delegatedActions.isEmpty()) {
                      return;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,10 ***</span>
<span class="line-new-header">--- 1237,12 ---</span>
                  // handshaking has completed.
                  hc = engine.conContext.handshakeContext;
                  if (hc != null) {
                      hc.taskDelegated = false;
                  }
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 engine.engineLock.unlock();</span>
              }
          }
  
          private static class DelegatedAction
                  implements PrivilegedExceptionAction&lt;Void&gt; {
</pre>
<center><a href="SSLContextImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineInputRecord.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
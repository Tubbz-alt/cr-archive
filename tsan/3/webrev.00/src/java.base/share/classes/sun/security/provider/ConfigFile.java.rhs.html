<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/provider/ConfigFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.*;
 29 import java.net.MalformedURLException;
 30 import java.net.URI;
 31 import java.net.URL;
 32 import java.security.AccessController;
 33 import java.security.PrivilegedAction;
 34 import java.security.PrivilegedActionException;
 35 import java.security.PrivilegedExceptionAction;
 36 import java.security.Security;
 37 import java.security.URIParameter;
 38 import java.text.MessageFormat;
 39 import java.util.*;
 40 import javax.security.auth.AuthPermission;
 41 import javax.security.auth.login.AppConfigurationEntry;
 42 import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;
 43 import javax.security.auth.login.Configuration;
 44 import javax.security.auth.login.ConfigurationSpi;
 45 import sun.security.util.Debug;
 46 import sun.security.util.PropertyExpander;
 47 import sun.security.util.ResourcesMgr;
 48 
<a name="2" id="anc2"></a><span class="line-added"> 49 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 50 </span>
 51 /**
 52  * This class represents a default implementation for
 53  * {@code javax.security.auth.login.Configuration}.
 54  *
 55  * &lt;p&gt; This object stores the runtime login configuration representation,
 56  * and is the amalgamation of multiple static login configurations that
 57  * resides in files. The algorithm for locating the login configuration
 58  * file(s) and reading their information into this {@code Configuration}
 59  * object is:
 60  *
 61  * &lt;ol&gt;
 62  * &lt;li&gt;
 63  *   Loop through the security properties,
 64  *   &lt;i&gt;login.config.url.1&lt;/i&gt;, &lt;i&gt;login.config.url.2&lt;/i&gt;, ...,
 65  *   &lt;i&gt;login.config.url.X&lt;/i&gt;.
 66  *   Each property value specifies a {@code URL} pointing to a
 67  *   login configuration file to be loaded.  Read in and load
 68  *   each configuration.
 69  *
 70  * &lt;li&gt;
 71  *   The {@code java.lang.System} property
 72  *   &lt;i&gt;java.security.auth.login.config&lt;/i&gt;
 73  *   may also be set to a {@code URL} pointing to another
 74  *   login configuration file
 75  *   (which is the case when a user uses the -D switch at runtime).
 76  *   If this property is defined, and its use is allowed by the
 77  *   security property file (the Security property,
 78  *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 79  *   also load that login configuration.
 80  *
 81  * &lt;li&gt;
 82  *   If the &lt;i&gt;java.security.auth.login.config&lt;/i&gt; property is defined using
 83  *   &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
 84  *   login configurations and only load this configuration.
 85  *
 86  * &lt;li&gt;
 87  *   If no system or security properties were set, try to read from the file,
 88  *   ${user.home}/.java.login.config, where ${user.home} is the value
 89  *   represented by the &quot;user.home&quot; System property.
 90  * &lt;/ol&gt;
 91  *
 92  * &lt;p&gt; The configuration syntax supported by this implementation
 93  * is exactly that syntax specified in the
 94  * {@code javax.security.auth.login.Configuration} class.
 95  *
 96  * @see javax.security.auth.login.LoginContext
 97  * @see java.security.Security security properties
 98  */
 99 public final class ConfigFile extends Configuration {
100 
101     private final Spi spi;
102 
103     public ConfigFile() {
104         spi = new Spi();
105     }
106 
107     @Override
108     public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
109         return spi.engineGetAppConfigurationEntry(appName);
110     }
111 
112     @Override
113     public synchronized void refresh() {
114         spi.engineRefresh();
115     }
116 
117     public static final class Spi extends ConfigurationSpi {
118 
119         private URL url;
120         private boolean expandProp = true;
121         private Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; configuration;
122         private int linenum;
123         private StreamTokenizer st;
124         private int lookahead;
125 
126         private static Debug debugConfig = Debug.getInstance(&quot;configfile&quot;);
127         private static Debug debugParser = Debug.getInstance(&quot;configparser&quot;);
128 
129         /**
130          * Creates a new {@code ConfigurationSpi} object.
131          *
132          * @throws SecurityException if the {@code ConfigurationSpi} can not be
133          *                           initialized
134          */
135         public Spi() {
136             try {
137                 init();
138             } catch (IOException ioe) {
139                 throw new SecurityException(ioe);
140             }
141         }
142 
143         /**
144          * Creates a new {@code ConfigurationSpi} object from the specified
145          * {@code URI}.
146          *
147          * @param uri the {@code URI}
148          * @throws SecurityException if the {@code ConfigurationSpi} can not be
149          *                           initialized
150          * @throws NullPointerException if {@code uri} is null
151          */
152         public Spi(URI uri) {
153             // only load config from the specified URI
154             try {
155                 url = uri.toURL();
156                 init();
157             } catch (IOException ioe) {
158                 throw new SecurityException(ioe);
159             }
160         }
161 
162         public Spi(final Configuration.Parameters params) throws IOException {
163 
164             // call in a doPrivileged
165             //
166             // we have already passed the Configuration.getInstance
167             // security check.  also this class is not freely accessible
168             // (it is in the &quot;sun&quot; package).
169 
170             try {
171                 AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {
172                     public Void run() throws IOException {
173                         if (params == null) {
174                             init();
175                         } else {
176                             if (!(params instanceof URIParameter)) {
177                                 throw new IllegalArgumentException
178                                         (&quot;Unrecognized parameter: &quot; + params);
179                             }
180                             URIParameter uriParam = (URIParameter)params;
181                             url = uriParam.getURI().toURL();
182                             init();
183                         }
184                         return null;
185                     }
186                 });
187             } catch (PrivilegedActionException pae) {
188                 throw (IOException)pae.getException();
189             }
190 
191             // if init() throws some other RuntimeException,
192             // let it percolate up naturally.
193         }
194 
195         /**
196          * Read and initialize the entire login Configuration from the
197          * configured URL.
198          *
199          * @throws IOException if the Configuration can not be initialized
200          * @throws SecurityException if the caller does not have permission
201          *                           to initialize the Configuration
202          */
203         private void init() throws IOException {
204 
205             boolean initialized = false;
206 
207             // For policy.expandProperties, check if either a security or system
208             // property is set to false (old code erroneously checked the system
209             // prop so we must check both to preserve compatibility).
210             String expand = Security.getProperty(&quot;policy.expandProperties&quot;);
211             if (expand == null) {
212                 expand = System.getProperty(&quot;policy.expandProperties&quot;);
213             }
214             if (&quot;false&quot;.equals(expand)) {
215                 expandProp = false;
216             }
217 
218             // new configuration
219             Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig = new HashMap&lt;&gt;();
220 
221             if (url != null) {
222                 /**
223                  * If the caller specified a URI via Configuration.getInstance,
224                  * we only read from that URI
225                  */
226                 if (debugConfig != null) {
227                     debugConfig.println(&quot;reading &quot; + url);
228                 }
229                 init(url, newConfig);
230                 configuration = newConfig;
231                 return;
232             }
233 
234             /**
235              * Caller did not specify URI via Configuration.getInstance.
236              * Read from URLs listed in the java.security properties file.
237              */
238             String allowSys = Security.getProperty(&quot;policy.allowSystemProperty&quot;);
239 
240             if (&quot;true&quot;.equalsIgnoreCase(allowSys)) {
241                 String extra_config = System.getProperty
242                                       (&quot;java.security.auth.login.config&quot;);
243                 if (extra_config != null) {
244                     boolean overrideAll = false;
245                     if (extra_config.startsWith(&quot;=&quot;)) {
246                         overrideAll = true;
247                         extra_config = extra_config.substring(1);
248                     }
249                     try {
250                         extra_config = PropertyExpander.expand(extra_config);
251                     } catch (PropertyExpander.ExpandException peee) {
252                         throw ioException(&quot;Unable.to.properly.expand.config&quot;,
253                                           extra_config);
254                     }
255 
256                     URL configURL = null;
257                     try {
258                         configURL = new URL(extra_config);
259                     } catch (MalformedURLException mue) {
260                         File configFile = new File(extra_config);
261                         if (configFile.exists()) {
262                             configURL = configFile.toURI().toURL();
263                         } else {
264                             throw ioException(
265                                 &quot;extra.config.No.such.file.or.directory.&quot;,
266                                 extra_config);
267                         }
268                     }
269 
270                     if (debugConfig != null) {
271                         debugConfig.println(&quot;reading &quot;+configURL);
272                     }
273                     init(configURL, newConfig);
274                     initialized = true;
275                     if (overrideAll) {
276                         if (debugConfig != null) {
277                             debugConfig.println(&quot;overriding other policies!&quot;);
278                         }
279                         configuration = newConfig;
280                         return;
281                     }
282                 }
283             }
284 
285             int n = 1;
286             String config_url;
287             while ((config_url = Security.getProperty
288                                      (&quot;login.config.url.&quot;+n)) != null) {
289                 try {
290                     config_url = PropertyExpander.expand
291                         (config_url).replace(File.separatorChar, &#39;/&#39;);
292                     if (debugConfig != null) {
293                         debugConfig.println(&quot;\tReading config: &quot; + config_url);
294                     }
295                     init(new URL(config_url), newConfig);
296                     initialized = true;
297                 } catch (PropertyExpander.ExpandException peee) {
298                     throw ioException(&quot;Unable.to.properly.expand.config&quot;,
299                                       config_url);
300                 }
301                 n++;
302             }
303 
304             if (initialized == false &amp;&amp; n == 1 &amp;&amp; config_url == null) {
305 
306                 // get the config from the user&#39;s home directory
307                 if (debugConfig != null) {
308                     debugConfig.println(&quot;\tReading Policy &quot; +
309                                 &quot;from ~/.java.login.config&quot;);
310                 }
311                 config_url = System.getProperty(&quot;user.home&quot;);
312                 String userConfigFile = config_url + File.separatorChar +
313                                         &quot;.java.login.config&quot;;
314 
315                 // No longer throws an exception when there&#39;s no config file
316                 // at all. Returns an empty Configuration instead.
317                 if (new File(userConfigFile).exists()) {
318                     init(new File(userConfigFile).toURI().toURL(), newConfig);
319                 }
320             }
321 
322             configuration = newConfig;
323         }
324 
325         private void init(URL config,
326                           Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
327                           throws IOException {
328 
329             try (InputStreamReader isr
<a name="3" id="anc3"></a><span class="line-modified">330                     = new InputStreamReader(getInputStream(config), UTF_8)) {</span>
331                 readConfig(isr, newConfig);
332             } catch (FileNotFoundException fnfe) {
333                 if (debugConfig != null) {
334                     debugConfig.println(fnfe.toString());
335                 }
336                 throw new IOException(ResourcesMgr.getAuthResourceString
337                     (&quot;Configuration.Error.No.such.file.or.directory&quot;));
338             }
339         }
340 
341         /**
342          * Retrieve an entry from the Configuration using an application name
343          * as an index.
344          *
345          * @param applicationName the name used to index the Configuration.
346          * @return an array of AppConfigurationEntries which correspond to
347          *         the stacked configuration of LoginModules for this
348          *         application, or null if this application has no configured
349          *         LoginModules.
350          */
351         @Override
352         public AppConfigurationEntry[] engineGetAppConfigurationEntry
353             (String applicationName) {
354 
355             List&lt;AppConfigurationEntry&gt; list = null;
356             synchronized (configuration) {
357                 list = configuration.get(applicationName);
358             }
359 
360             if (list == null || list.size() == 0) {
361                 return null;
362             }
363 
364             AppConfigurationEntry[] entries =
365                                     new AppConfigurationEntry[list.size()];
366             Iterator&lt;AppConfigurationEntry&gt; iterator = list.iterator();
367             for (int i = 0; iterator.hasNext(); i++) {
368                 AppConfigurationEntry e = iterator.next();
369                 entries[i] = new AppConfigurationEntry(e.getLoginModuleName(),
370                                                        e.getControlFlag(),
371                                                        e.getOptions());
372             }
373             return entries;
374         }
375 
376         /**
377          * Refresh and reload the Configuration by re-reading all of the
378          * login configurations.
379          *
380          * @throws SecurityException if the caller does not have permission
381          *                           to refresh the Configuration.
382          */
383         @Override
384         public synchronized void engineRefresh() {
385 
386             SecurityManager sm = System.getSecurityManager();
387             if (sm != null) {
388                 sm.checkPermission(
389                     new AuthPermission(&quot;refreshLoginConfiguration&quot;));
390             }
391 
392             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
393                 public Void run() {
394                     try {
395                         init();
396                     } catch (IOException ioe) {
397                         throw new SecurityException(ioe.getLocalizedMessage(),
398                                                     ioe);
399                     }
400                     return null;
401                 }
402             });
403         }
404 
405         private void readConfig(Reader reader,
406             Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
407             throws IOException {
408 
409             linenum = 1;
410 
411             if (!(reader instanceof BufferedReader)) {
412                 reader = new BufferedReader(reader);
413             }
414 
415             st = new StreamTokenizer(reader);
416             st.quoteChar(&#39;&quot;&#39;);
417             st.wordChars(&#39;$&#39;, &#39;$&#39;);
418             st.wordChars(&#39;_&#39;, &#39;_&#39;);
419             st.wordChars(&#39;-&#39;, &#39;-&#39;);
420             st.wordChars(&#39;*&#39;, &#39;*&#39;);
421             st.lowerCaseMode(false);
422             st.slashSlashComments(true);
423             st.slashStarComments(true);
424             st.eolIsSignificant(true);
425 
426             lookahead = nextToken();
427             while (lookahead != StreamTokenizer.TT_EOF) {
428                 parseLoginEntry(newConfig);
429             }
430         }
431 
432         private void parseLoginEntry(
433             Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
434             throws IOException {
435 
436             List&lt;AppConfigurationEntry&gt; configEntries = new LinkedList&lt;&gt;();
437 
438             // application name
439             String appName = st.sval;
440             lookahead = nextToken();
441 
442             if (debugParser != null) {
443                 debugParser.println(&quot;\tReading next config entry: &quot; + appName);
444             }
445 
446             match(&quot;{&quot;);
447 
448             // get the modules
449             while (peek(&quot;}&quot;) == false) {
450                 // get the module class name
451                 String moduleClass = match(&quot;module class name&quot;);
452 
453                 // controlFlag (required, optional, etc)
454                 LoginModuleControlFlag controlFlag;
455                 String sflag = match(&quot;controlFlag&quot;).toUpperCase(Locale.ENGLISH);
456                 switch (sflag) {
457                     case &quot;REQUIRED&quot;:
458                         controlFlag = LoginModuleControlFlag.REQUIRED;
459                         break;
460                     case &quot;REQUISITE&quot;:
461                         controlFlag = LoginModuleControlFlag.REQUISITE;
462                         break;
463                     case &quot;SUFFICIENT&quot;:
464                         controlFlag = LoginModuleControlFlag.SUFFICIENT;
465                         break;
466                     case &quot;OPTIONAL&quot;:
467                         controlFlag = LoginModuleControlFlag.OPTIONAL;
468                         break;
469                     default:
470                         throw ioException(
471                             &quot;Configuration.Error.Invalid.control.flag.flag&quot;,
472                             sflag);
473                 }
474 
475                 // get the args
476                 Map&lt;String, String&gt; options = new HashMap&lt;&gt;();
477                 while (peek(&quot;;&quot;) == false) {
478                     String key = match(&quot;option key&quot;);
479                     match(&quot;=&quot;);
480                     try {
481                         options.put(key, expand(match(&quot;option value&quot;)));
482                     } catch (PropertyExpander.ExpandException peee) {
483                         throw new IOException(peee.getLocalizedMessage());
484                     }
485                 }
486 
487                 lookahead = nextToken();
488 
489                 // create the new element
490                 if (debugParser != null) {
491                     debugParser.println(&quot;\t\t&quot; + moduleClass + &quot;, &quot; + sflag);
492                     for (String key : options.keySet()) {
493                         debugParser.println(&quot;\t\t\t&quot; + key +
494                                             &quot;=&quot; + options.get(key));
495                     }
496                 }
497                 configEntries.add(new AppConfigurationEntry(moduleClass,
498                                                             controlFlag,
499                                                             options));
500             }
501 
502             match(&quot;}&quot;);
503             match(&quot;;&quot;);
504 
505             // add this configuration entry
506             if (newConfig.containsKey(appName)) {
507                 throw ioException(
508                     &quot;Configuration.Error.Can.not.specify.multiple.entries.for.appName&quot;,
509                     appName);
510             }
511             newConfig.put(appName, configEntries);
512         }
513 
514         private String match(String expect) throws IOException {
515 
516             String value = null;
517 
518             switch(lookahead) {
519             case StreamTokenizer.TT_EOF:
520                 throw ioException(
521                     &quot;Configuration.Error.expected.expect.read.end.of.file.&quot;,
522                     expect);
523 
524             case &#39;&quot;&#39;:
525             case StreamTokenizer.TT_WORD:
526                 if (expect.equalsIgnoreCase(&quot;module class name&quot;) ||
527                     expect.equalsIgnoreCase(&quot;controlFlag&quot;) ||
528                     expect.equalsIgnoreCase(&quot;option key&quot;) ||
529                     expect.equalsIgnoreCase(&quot;option value&quot;)) {
530                     value = st.sval;
531                     lookahead = nextToken();
532                 } else {
533                     throw ioException(
534                         &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
535                         linenum, expect, st.sval);
536                 }
537                 break;
538 
539             case &#39;{&#39;:
540                 if (expect.equalsIgnoreCase(&quot;{&quot;)) {
541                     lookahead = nextToken();
542                 } else {
543                     throw ioException(
544                         &quot;Configuration.Error.Line.line.expected.expect.&quot;,
545                         linenum, expect, st.sval);
546                 }
547                 break;
548 
549             case &#39;;&#39;:
550                 if (expect.equalsIgnoreCase(&quot;;&quot;)) {
551                     lookahead = nextToken();
552                 } else {
553                     throw ioException(
554                         &quot;Configuration.Error.Line.line.expected.expect.&quot;,
555                         linenum, expect, st.sval);
556                 }
557                 break;
558 
559             case &#39;}&#39;:
560                 if (expect.equalsIgnoreCase(&quot;}&quot;)) {
561                     lookahead = nextToken();
562                 } else {
563                     throw ioException(
564                         &quot;Configuration.Error.Line.line.expected.expect.&quot;,
565                         linenum, expect, st.sval);
566                 }
567                 break;
568 
569             case &#39;=&#39;:
570                 if (expect.equalsIgnoreCase(&quot;=&quot;)) {
571                     lookahead = nextToken();
572                 } else {
573                     throw ioException(
574                         &quot;Configuration.Error.Line.line.expected.expect.&quot;,
575                         linenum, expect, st.sval);
576                 }
577                 break;
578 
579             default:
580                 throw ioException(
581                     &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
582                     linenum, expect, st.sval);
583             }
584             return value;
585         }
586 
587         private boolean peek(String expect) {
588             switch (lookahead) {
589                 case &#39;,&#39;:
590                     return expect.equalsIgnoreCase(&quot;,&quot;);
591                 case &#39;;&#39;:
592                     return expect.equalsIgnoreCase(&quot;;&quot;);
593                 case &#39;{&#39;:
594                     return expect.equalsIgnoreCase(&quot;{&quot;);
595                 case &#39;}&#39;:
596                     return expect.equalsIgnoreCase(&quot;}&quot;);
597                 default:
598                     return false;
599             }
600         }
601 
602         private int nextToken() throws IOException {
603             int tok;
604             while ((tok = st.nextToken()) == StreamTokenizer.TT_EOL) {
605                 linenum++;
606             }
607             return tok;
608         }
609 
610         private InputStream getInputStream(URL url) throws IOException {
611             if (&quot;file&quot;.equalsIgnoreCase(url.getProtocol())) {
612                 // Compatibility notes:
613                 //
614                 // Code changed from
615                 //   String path = url.getFile().replace(&#39;/&#39;, File.separatorChar);
616                 //   return new FileInputStream(path);
617                 //
618                 // The original implementation would search for &quot;/tmp/a%20b&quot;
619                 // when url is &quot;file:///tmp/a%20b&quot;. This is incorrect. The
620                 // current codes fix this bug and searches for &quot;/tmp/a b&quot;.
621                 // For compatibility reasons, when the file &quot;/tmp/a b&quot; does
622                 // not exist, the file named &quot;/tmp/a%20b&quot; will be tried.
623                 //
624                 // This also means that if both file exists, the behavior of
625                 // this method is changed, and the current codes choose the
626                 // correct one.
627                 try {
628                     return url.openStream();
629                 } catch (Exception e) {
630                     String file = url.getPath();
631                     if (!url.getHost().isEmpty()) {  // For Windows UNC
632                         file = &quot;//&quot; + url.getHost() + file;
633                     }
634                     if (debugConfig != null) {
635                         debugConfig.println(&quot;cannot read &quot; + url +
636                                             &quot;, try &quot; + file);
637                     }
638                     return new FileInputStream(file);
639                 }
640             } else {
641                 return url.openStream();
642             }
643         }
644 
645         private String expand(String value)
646             throws PropertyExpander.ExpandException, IOException {
647 
648             if (value.isEmpty()) {
649                 return value;
650             }
651 
652             if (!expandProp) {
653                 return value;
654             }
655             String s = PropertyExpander.expand(value);
656             if (s == null || s.isEmpty()) {
657                 throw ioException(
658                     &quot;Configuration.Error.Line.line.system.property.value.expanded.to.empty.value&quot;,
659                     linenum, value);
660             }
661             return s;
662         }
663 
664         private IOException ioException(String resourceKey, Object... args) {
665             MessageFormat form = new MessageFormat(
666                 ResourcesMgr.getAuthResourceString(resourceKey));
667             return new IOException(form.format(args));
668         }
669     }
670 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/util/locale/provider/LocaleResources.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JRELocaleProviderAdapter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NumberFormatProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/util/locale/provider/LocaleResources.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  * The original version of this source code and documentation
 31  * is copyrighted and owned by Taligent, Inc., a wholly-owned
 32  * subsidiary of IBM. These materials are provided under terms
 33  * of a License Agreement between Taligent and Sun. This technology
 34  * is protected by multiple US and International patents.
 35  *
 36  * This notice and attribution to Taligent may not be removed.
 37  * Taligent is a registered trademark of Taligent, Inc.
 38  *
 39  */
 40 
 41 package sun.util.locale.provider;
 42 
 43 import java.lang.ref.ReferenceQueue;
 44 import java.lang.ref.SoftReference;
 45 import java.text.MessageFormat;
 46 import java.text.NumberFormat;

 47 import java.util.Calendar;
 48 import java.util.HashSet;
 49 import java.util.LinkedHashSet;
 50 import java.util.Locale;
 51 import java.util.Map;
 52 import java.util.Objects;
 53 import java.util.ResourceBundle;
 54 import java.util.Set;
 55 import java.util.TimeZone;
 56 import java.util.concurrent.ConcurrentHashMap;
 57 import java.util.concurrent.ConcurrentMap;
 58 import sun.security.action.GetPropertyAction;
 59 import sun.util.resources.LocaleData;
 60 import sun.util.resources.OpenListResourceBundle;
 61 import sun.util.resources.ParallelListResourceBundle;
 62 import sun.util.resources.TimeZoneNamesBundle;
 63 
 64 /**
 65  * Central accessor to locale-dependent resources for JRE/CLDR provider adapters.
 66  *
</pre>
<hr />
<pre>
160             if (rb.containsKey(key)) {
161                 coldata = rb.getString(key);
162             }
163             cache.put(COLLATION_DATA_CACHEKEY,
164                       new ResourceReference(COLLATION_DATA_CACHEKEY, (Object) coldata, referenceQueue));
165         }
166 
167         return coldata;
168     }
169 
170     public Object[] getDecimalFormatSymbolsData() {
171         Object[] dfsdata;
172 
173         removeEmptyReferences();
174         ResourceReference data = cache.get(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY);
175         if (data == null || ((dfsdata = (Object[]) data.get()) == null)) {
176             // Note that only dfsdata[0] is prepared here in this method. Other
177             // elements are provided by the caller, yet they are cached here.
178             ResourceBundle rb = localeData.getNumberFormatData(locale);
179             dfsdata = new Object[3];

180 
<span class="line-modified">181             // NumberElements look up. First, try the Unicode extension</span>
<span class="line-modified">182             String numElemKey;</span>
<span class="line-modified">183             String numberType = locale.getUnicodeLocaleType(&quot;nu&quot;);</span>
<span class="line-removed">184             if (numberType != null) {</span>
<span class="line-removed">185                 numElemKey = numberType + &quot;.NumberElements&quot;;</span>
<span class="line-removed">186                 if (rb.containsKey(numElemKey)) {</span>
<span class="line-removed">187                     dfsdata[0] = rb.getStringArray(numElemKey);</span>
<span class="line-removed">188                 }</span>
<span class="line-removed">189             }</span>
190 
<span class="line-modified">191             // Next, try DefaultNumberingSystem value</span>
<span class="line-modified">192             if (dfsdata[0] == null &amp;&amp; rb.containsKey(&quot;DefaultNumberingSystem&quot;)) {</span>
<span class="line-modified">193                 numElemKey = rb.getString(&quot;DefaultNumberingSystem&quot;) + &quot;.NumberElements&quot;;</span>
<span class="line-modified">194                 if (rb.containsKey(numElemKey)) {</span>
<span class="line-modified">195                     dfsdata[0] = rb.getStringArray(numElemKey);</span>
<span class="line-modified">196                 }</span>








197             }

198 
<span class="line-modified">199             // Last resort. No need to check the availability.</span>
<span class="line-modified">200             // Just let it throw MissingResourceException when needed.</span>
<span class="line-modified">201             if (dfsdata[0] == null) {</span>
<span class="line-modified">202                 dfsdata[0] = rb.getStringArray(&quot;NumberElements&quot;);</span>

203             }

204 
<span class="line-modified">205             cache.put(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY,</span>
<span class="line-modified">206                       new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, (Object) dfsdata, referenceQueue));</span>


207         }
208 
<span class="line-modified">209         return dfsdata;</span>
210     }
211 
212     public String getCurrencyName(String key) {
213         Object currencyName = null;
214         String cacheKey = CURRENCY_NAMES + key;
215 
216         removeEmptyReferences();
217         ResourceReference data = cache.get(cacheKey);
218 
219         if (data != null &amp;&amp; ((currencyName = data.get()) != null)) {
220             if (currencyName.equals(NULLOBJECT)) {
221                 currencyName = null;
222             }
223 
224             return (String) currencyName;
225         }
226 
227         OpenListResourceBundle olrb = localeData.getCurrencyNames(locale);
228 
229         if (olrb.containsKey(key)) {
</pre>
<hr />
<pre>
308         Set&lt;String&gt; zoneIDs = null;
309 
310         removeEmptyReferences();
311         ResourceReference data = cache.get(ZONE_IDS_CACHEKEY);
312         if (data == null || ((zoneIDs = (Set&lt;String&gt;) data.get()) == null)) {
313             TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
314             zoneIDs = rb.keySet();
315             cache.put(ZONE_IDS_CACHEKEY,
316                       new ResourceReference(ZONE_IDS_CACHEKEY, (Object) zoneIDs, referenceQueue));
317         }
318 
319         return zoneIDs;
320     }
321 
322     // zoneStrings are cached separately in TimeZoneNameUtility.
323     String[][] getZoneStrings() {
324         TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
325         Set&lt;String&gt; keyset = getZoneIDs();
326         // Use a LinkedHashSet to preseve the order
327         Set&lt;String[]&gt; value = new LinkedHashSet&lt;&gt;();
<span class="line-modified">328         Set&lt;String&gt; tzIds = new HashSet&lt;&gt;(Set.of(TimeZone.getAvailableIDs()));</span>
329         for (String key : keyset) {
330             if (!key.startsWith(TZNB_EXCITY_PREFIX)) {
331                 value.add(rb.getStringArray(key));
332                 tzIds.remove(key);
333             }
334         }
335 
336         if (type == LocaleProviderAdapter.Type.CLDR) {
337             // Note: TimeZoneNamesBundle creates a String[] on each getStringArray call.
338 
339             // Add timezones which are not present in this keyset,
340             // so that their fallback names will be generated at runtime.
341             tzIds.stream().filter(i -&gt; (!i.startsWith(&quot;Etc/GMT&quot;)
342                     &amp;&amp; !i.startsWith(&quot;GMT&quot;)
343                     &amp;&amp; !i.startsWith(&quot;SystemV&quot;)))
344                     .forEach(tzid -&gt; {
345                         String[] val = new String[7];
346                         if (keyset.contains(tzid)) {
347                             val = rb.getStringArray(tzid);
348                         } else {
</pre>
<hr />
<pre>
467                 }
468             } else {
469                 pattern = timePattern;
470             }
471         } else if (dateStyle &gt;= 0) {
472             pattern = datePattern;
473         } else {
474             throw new IllegalArgumentException(&quot;No date or time style specified&quot;);
475         }
476         return pattern;
477     }
478 
479     public String[] getNumberPatterns() {
480         String[] numberPatterns = null;
481 
482         removeEmptyReferences();
483         ResourceReference data = cache.get(NUMBER_PATTERNS_CACHEKEY);
484 
485         if (data == null || ((numberPatterns = (String[]) data.get()) == null)) {
486             ResourceBundle resource = localeData.getNumberFormatData(locale);
<span class="line-modified">487             numberPatterns = resource.getStringArray(&quot;NumberPatterns&quot;);</span>
488             cache.put(NUMBER_PATTERNS_CACHEKEY,
489                       new ResourceReference(NUMBER_PATTERNS_CACHEKEY, (Object) numberPatterns, referenceQueue));
490         }
491 
492         return numberPatterns;
493     }
494 
495     /**
496      * Returns the compact number format patterns.
497      * @param formatStyle the style for formatting a number
498      * @return an array of compact number patterns
499      */
500     @SuppressWarnings(&quot;unchecked&quot;)
501     public String[] getCNPatterns(NumberFormat.Style formatStyle) {
502 
503         Objects.requireNonNull(formatStyle);
504         String[] compactNumberPatterns = null;
505         removeEmptyReferences();
506         String width = (formatStyle == NumberFormat.Style.LONG) ? &quot;long&quot; : &quot;short&quot;;
507         String cacheKey = width + &quot;.&quot; + COMPACT_NUMBER_PATTERNS_CACHEKEY;
</pre>
</td>
<td>
<hr />
<pre>
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  * The original version of this source code and documentation
 31  * is copyrighted and owned by Taligent, Inc., a wholly-owned
 32  * subsidiary of IBM. These materials are provided under terms
 33  * of a License Agreement between Taligent and Sun. This technology
 34  * is protected by multiple US and International patents.
 35  *
 36  * This notice and attribution to Taligent may not be removed.
 37  * Taligent is a registered trademark of Taligent, Inc.
 38  *
 39  */
 40 
 41 package sun.util.locale.provider;
 42 
 43 import java.lang.ref.ReferenceQueue;
 44 import java.lang.ref.SoftReference;
 45 import java.text.MessageFormat;
 46 import java.text.NumberFormat;
<span class="line-added"> 47 import java.util.Arrays;</span>
 48 import java.util.Calendar;
 49 import java.util.HashSet;
 50 import java.util.LinkedHashSet;
 51 import java.util.Locale;
 52 import java.util.Map;
 53 import java.util.Objects;
 54 import java.util.ResourceBundle;
 55 import java.util.Set;
 56 import java.util.TimeZone;
 57 import java.util.concurrent.ConcurrentHashMap;
 58 import java.util.concurrent.ConcurrentMap;
 59 import sun.security.action.GetPropertyAction;
 60 import sun.util.resources.LocaleData;
 61 import sun.util.resources.OpenListResourceBundle;
 62 import sun.util.resources.ParallelListResourceBundle;
 63 import sun.util.resources.TimeZoneNamesBundle;
 64 
 65 /**
 66  * Central accessor to locale-dependent resources for JRE/CLDR provider adapters.
 67  *
</pre>
<hr />
<pre>
161             if (rb.containsKey(key)) {
162                 coldata = rb.getString(key);
163             }
164             cache.put(COLLATION_DATA_CACHEKEY,
165                       new ResourceReference(COLLATION_DATA_CACHEKEY, (Object) coldata, referenceQueue));
166         }
167 
168         return coldata;
169     }
170 
171     public Object[] getDecimalFormatSymbolsData() {
172         Object[] dfsdata;
173 
174         removeEmptyReferences();
175         ResourceReference data = cache.get(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY);
176         if (data == null || ((dfsdata = (Object[]) data.get()) == null)) {
177             // Note that only dfsdata[0] is prepared here in this method. Other
178             // elements are provided by the caller, yet they are cached here.
179             ResourceBundle rb = localeData.getNumberFormatData(locale);
180             dfsdata = new Object[3];
<span class="line-added">181             dfsdata[0] = getNumberStrings(rb, &quot;NumberElements&quot;);</span>
182 
<span class="line-modified">183             cache.put(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY,</span>
<span class="line-modified">184                       new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, (Object) dfsdata, referenceQueue));</span>
<span class="line-modified">185         }</span>






186 
<span class="line-modified">187         return dfsdata;</span>
<span class="line-modified">188     }</span>
<span class="line-modified">189 </span>
<span class="line-modified">190     private String[] getNumberStrings(ResourceBundle rb, String type) {</span>
<span class="line-modified">191         String[] ret = null;</span>
<span class="line-modified">192         String key;</span>
<span class="line-added">193         String numSys;</span>
<span class="line-added">194 </span>
<span class="line-added">195         // Number strings look up. First, try the Unicode extension</span>
<span class="line-added">196         numSys = locale.getUnicodeLocaleType(&quot;nu&quot;);</span>
<span class="line-added">197         if (numSys != null) {</span>
<span class="line-added">198             key = numSys + &quot;.&quot; + type;</span>
<span class="line-added">199             if (rb.containsKey(key)) {</span>
<span class="line-added">200                 ret = rb.getStringArray(key);</span>
201             }
<span class="line-added">202         }</span>
203 
<span class="line-modified">204         // Next, try DefaultNumberingSystem value</span>
<span class="line-modified">205         if (ret == null &amp;&amp; rb.containsKey(&quot;DefaultNumberingSystem&quot;)) {</span>
<span class="line-modified">206             key = rb.getString(&quot;DefaultNumberingSystem&quot;) + &quot;.&quot; + type;</span>
<span class="line-modified">207             if (rb.containsKey(key)) {</span>
<span class="line-added">208                 ret = rb.getStringArray(key);</span>
209             }
<span class="line-added">210         }</span>
211 
<span class="line-modified">212         // Last resort. No need to check the availability.</span>
<span class="line-modified">213         // Just let it throw MissingResourceException when needed.</span>
<span class="line-added">214         if (ret == null) {</span>
<span class="line-added">215             ret = rb.getStringArray(type);</span>
216         }
217 
<span class="line-modified">218         return ret;</span>
219     }
220 
221     public String getCurrencyName(String key) {
222         Object currencyName = null;
223         String cacheKey = CURRENCY_NAMES + key;
224 
225         removeEmptyReferences();
226         ResourceReference data = cache.get(cacheKey);
227 
228         if (data != null &amp;&amp; ((currencyName = data.get()) != null)) {
229             if (currencyName.equals(NULLOBJECT)) {
230                 currencyName = null;
231             }
232 
233             return (String) currencyName;
234         }
235 
236         OpenListResourceBundle olrb = localeData.getCurrencyNames(locale);
237 
238         if (olrb.containsKey(key)) {
</pre>
<hr />
<pre>
317         Set&lt;String&gt; zoneIDs = null;
318 
319         removeEmptyReferences();
320         ResourceReference data = cache.get(ZONE_IDS_CACHEKEY);
321         if (data == null || ((zoneIDs = (Set&lt;String&gt;) data.get()) == null)) {
322             TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
323             zoneIDs = rb.keySet();
324             cache.put(ZONE_IDS_CACHEKEY,
325                       new ResourceReference(ZONE_IDS_CACHEKEY, (Object) zoneIDs, referenceQueue));
326         }
327 
328         return zoneIDs;
329     }
330 
331     // zoneStrings are cached separately in TimeZoneNameUtility.
332     String[][] getZoneStrings() {
333         TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
334         Set&lt;String&gt; keyset = getZoneIDs();
335         // Use a LinkedHashSet to preseve the order
336         Set&lt;String[]&gt; value = new LinkedHashSet&lt;&gt;();
<span class="line-modified">337         Set&lt;String&gt; tzIds = new HashSet&lt;&gt;(Arrays.asList(TimeZone.getAvailableIDs()));</span>
338         for (String key : keyset) {
339             if (!key.startsWith(TZNB_EXCITY_PREFIX)) {
340                 value.add(rb.getStringArray(key));
341                 tzIds.remove(key);
342             }
343         }
344 
345         if (type == LocaleProviderAdapter.Type.CLDR) {
346             // Note: TimeZoneNamesBundle creates a String[] on each getStringArray call.
347 
348             // Add timezones which are not present in this keyset,
349             // so that their fallback names will be generated at runtime.
350             tzIds.stream().filter(i -&gt; (!i.startsWith(&quot;Etc/GMT&quot;)
351                     &amp;&amp; !i.startsWith(&quot;GMT&quot;)
352                     &amp;&amp; !i.startsWith(&quot;SystemV&quot;)))
353                     .forEach(tzid -&gt; {
354                         String[] val = new String[7];
355                         if (keyset.contains(tzid)) {
356                             val = rb.getStringArray(tzid);
357                         } else {
</pre>
<hr />
<pre>
476                 }
477             } else {
478                 pattern = timePattern;
479             }
480         } else if (dateStyle &gt;= 0) {
481             pattern = datePattern;
482         } else {
483             throw new IllegalArgumentException(&quot;No date or time style specified&quot;);
484         }
485         return pattern;
486     }
487 
488     public String[] getNumberPatterns() {
489         String[] numberPatterns = null;
490 
491         removeEmptyReferences();
492         ResourceReference data = cache.get(NUMBER_PATTERNS_CACHEKEY);
493 
494         if (data == null || ((numberPatterns = (String[]) data.get()) == null)) {
495             ResourceBundle resource = localeData.getNumberFormatData(locale);
<span class="line-modified">496             numberPatterns = getNumberStrings(resource, &quot;NumberPatterns&quot;);</span>
497             cache.put(NUMBER_PATTERNS_CACHEKEY,
498                       new ResourceReference(NUMBER_PATTERNS_CACHEKEY, (Object) numberPatterns, referenceQueue));
499         }
500 
501         return numberPatterns;
502     }
503 
504     /**
505      * Returns the compact number format patterns.
506      * @param formatStyle the style for formatting a number
507      * @return an array of compact number patterns
508      */
509     @SuppressWarnings(&quot;unchecked&quot;)
510     public String[] getCNPatterns(NumberFormat.Style formatStyle) {
511 
512         Objects.requireNonNull(formatStyle);
513         String[] compactNumberPatterns = null;
514         removeEmptyReferences();
515         String width = (formatStyle == NumberFormat.Style.LONG) ? &quot;long&quot; : &quot;short&quot;;
516         String cacheKey = width + &quot;.&quot; + COMPACT_NUMBER_PATTERNS_CACHEKEY;
</pre>
</td>
</tr>
</table>
<center><a href="JRELocaleProviderAdapter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NumberFormatProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
<a name="1" id="anc1"></a>



  27 import java.math.BigInteger;
  28 import java.net.InetAddress;
<a name="2" id="anc2"></a>
  29 import java.security.Principal;
  30 import java.security.PrivateKey;
  31 import java.security.cert.CertificateEncodingException;
  32 import java.security.cert.X509Certificate;
  33 import java.util.ArrayList;
<a name="3" id="anc3"></a>
  34 import java.util.Queue;
  35 import java.util.Collection;
  36 import java.util.Collections;
  37 import java.util.Enumeration;
  38 import java.util.List;
<a name="4" id="anc4"></a><span class="line-removed">  39 import java.util.Optional;</span>
  40 import java.util.concurrent.ConcurrentHashMap;
  41 import java.util.concurrent.ConcurrentLinkedQueue;
<a name="5" id="anc5"></a>
  42 import javax.crypto.SecretKey;
<a name="6" id="anc6"></a>
  43 import javax.net.ssl.ExtendedSSLSession;
<a name="7" id="anc7"></a>
  44 import javax.net.ssl.SNIServerName;
<a name="8" id="anc8"></a>
  45 import javax.net.ssl.SSLPeerUnverifiedException;
  46 import javax.net.ssl.SSLPermission;
  47 import javax.net.ssl.SSLSessionBindingEvent;
  48 import javax.net.ssl.SSLSessionBindingListener;
  49 import javax.net.ssl.SSLSessionContext;
  50 
  51 /**
  52  * Implements the SSL session interface, and exposes the session context
  53  * which is maintained by SSL servers.
  54  *
  55  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  56  * their authentication context(s).  They can do this by enumerating the
  57  * IDs of the sessions which are cached, examining those sessions, and then
  58  * perhaps invalidating a given session so that it can&#39;t be used again.
  59  * If servers do not explicitly manage the cache, sessions will linger
  60  * until memory is low enough that the runtime environment purges cache
  61  * entries automatically to reclaim space.
  62  *
  63  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  64  * there&#39;s no other public way to get at the server session context which
  65  * is associated with any given authentication context. &lt;/em&gt;
  66  *
  67  * @author David Brownell
  68  */
  69 final class SSLSessionImpl extends ExtendedSSLSession {
  70 
  71     /*
  72      * we only really need a single null session
  73      */
  74     static final SSLSessionImpl         nullSession = new SSLSessionImpl();
  75 
  76     /*
  77      * The state of a single session, as described in section 7.1
  78      * of the SSLv3 spec.
  79      */
  80     private final ProtocolVersion       protocolVersion;
  81     private final SessionId             sessionId;
  82     private X509Certificate[]   peerCerts;
  83     private CipherSuite         cipherSuite;
  84     private SecretKey           masterSecret;
  85     final boolean               useExtendedMasterSecret;
  86 
  87     /*
  88      * Information not part of the SSLv3 protocol spec, but used
  89      * to support session management policies.
  90      */
  91     private final long          creationTime;
  92     private long                lastUsedTime = 0;
  93     private final String        host;
  94     private final int           port;
  95     private SSLSessionContextImpl       context;
  96     private boolean             invalidated;
  97     private X509Certificate[]   localCerts;
  98     private PrivateKey          localPrivateKey;
  99     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
<a name="9" id="anc9"></a><span class="line-modified"> 100     private String[]            peerSupportedSignAlgs;      // for certificate</span>
 101     private boolean             useDefaultPeerSignAlgs = false;
 102     private List&lt;byte[]&gt;        statusResponses;
 103     private SecretKey           resumptionMasterSecret;
 104     private SecretKey           preSharedKey;
 105     private byte[]              pskIdentity;
 106     private final long          ticketCreationTime = System.currentTimeMillis();
 107     private int                 ticketAgeAdd;
 108 
 109     private int                 negotiatedMaxFragLen = -1;
 110     private int                 maximumPacketSize;
 111 
 112     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 113                                         new ConcurrentLinkedQueue&lt;&gt;();
 114 
 115     /*
 116      * Is the session currently re-established with a session-resumption
 117      * abbreviated initial handshake?
 118      *
 119      * Note that currently we only set this variable in client side.
 120      */
 121     private boolean isSessionResumption = false;
 122 
 123     /*
 124      * Use of session caches is globally enabled/disabled.
 125      */
 126     private static boolean      defaultRejoinable = true;
 127 
 128     // server name indication
 129     final SNIServerName         serverNameIndication;
 130     private final List&lt;SNIServerName&gt;    requestedServerNames;
 131 
 132     // Counter used to create unique nonces in NewSessionTicket
 133     private BigInteger ticketNonceCounter = BigInteger.ONE;
 134 
 135     // The endpoint identification algorithm used to check certificates
 136     // in this session.
<a name="10" id="anc10"></a><span class="line-modified"> 137     private final String              identificationProtocol;</span>


 138 
 139     /*
 140      * Create a new non-rejoinable session, using the default (null)
 141      * cipher spec.  This constructor returns a session which could
 142      * be used either by a client or by a server, as a connection is
 143      * first opened and before handshaking begins.
 144      */
 145     private SSLSessionImpl() {
 146         this.protocolVersion = ProtocolVersion.NONE;
 147         this.cipherSuite = CipherSuite.C_NULL;
 148         this.sessionId = new SessionId(false, null);
 149         this.host = null;
 150         this.port = -1;
 151         this.localSupportedSignAlgs = Collections.emptySet();
 152         this.serverNameIndication = null;
 153         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 154         this.useExtendedMasterSecret = false;
 155         this.creationTime = System.currentTimeMillis();
 156         this.identificationProtocol = null;
 157         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 158     }
 159 
 160     /*
 161      * Create a new session, using a given cipher spec.  This will
 162      * be rejoinable if session caching is enabled; the constructor
 163      * is intended mostly for use by serves.
 164      */
 165     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 166         this(hc, cipherSuite,
 167             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 168     }
 169 
 170     /*
 171      * Record a new session, using a given cipher spec and session ID.
 172      */
 173     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 174         this(hc, cipherSuite, id, System.currentTimeMillis());
 175     }
 176 
 177     /*
 178      * Record a new session, using a given cipher spec, session ID,
 179      * and creation time.
 180      * Note: For the unmodifiable collections and lists we are creating new
 181      * collections as inputs to avoid potential deep nesting of
 182      * unmodifiable collections that can cause StackOverflowErrors
 183      * (see JDK-6323374).
 184      */
 185     SSLSessionImpl(HandshakeContext hc,
 186             CipherSuite cipherSuite, SessionId id, long creationTime) {
 187         this.protocolVersion = hc.negotiatedProtocol;
 188         this.cipherSuite = cipherSuite;
 189         this.sessionId = id;
 190         this.host = hc.conContext.transport.getPeerHost();
 191         this.port = hc.conContext.transport.getPeerPort();
 192         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 193                 Collections.emptySet() :
 194                 Collections.unmodifiableCollection(
 195                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 196         this.serverNameIndication = hc.negotiatedServerName;
 197         this.requestedServerNames = Collections.unmodifiableList(
 198                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 199         if (hc.sslConfig.isClientMode) {
 200             this.useExtendedMasterSecret =
 201                 (hc.handshakeExtensions.get(
 202                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 203                 (hc.handshakeExtensions.get(
 204                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 205         } else {
 206             this.useExtendedMasterSecret =
 207                 (hc.handshakeExtensions.get(
 208                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 209                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 210         }
 211         this.creationTime = creationTime;
 212         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 213         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 214 
 215         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 216              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 217         }
 218     }
 219 
 220     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 221         this.protocolVersion = baseSession.getProtocolVersion();
 222         this.cipherSuite = baseSession.cipherSuite;
 223         this.sessionId = newId;
 224         this.host = baseSession.getPeerHost();
 225         this.port = baseSession.getPeerPort();
 226         this.localSupportedSignAlgs =
 227                 baseSession.localSupportedSignAlgs == null ?
 228                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 229         this.peerSupportedSignAlgs =
<a name="11" id="anc11"></a><span class="line-modified"> 230                 baseSession.getPeerSupportedSignatureAlgorithms();</span>

 231         this.serverNameIndication = baseSession.serverNameIndication;
 232         this.requestedServerNames = baseSession.getRequestedServerNames();
 233         this.masterSecret = baseSession.getMasterSecret();
 234         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 235         this.creationTime = baseSession.getCreationTime();
 236         this.lastUsedTime = System.currentTimeMillis();
 237         this.identificationProtocol = baseSession.getIdentificationProtocol();
 238         this.localCerts = baseSession.localCerts;
 239         this.peerCerts = baseSession.peerCerts;
 240         this.statusResponses = baseSession.statusResponses;
 241         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 242         this.context = baseSession.context;
 243         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 244         this.maximumPacketSize = baseSession.maximumPacketSize;
 245         this.boundValues = baseSession.boundValues;
 246 
 247         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 248              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 249         }
 250     }
 251 
<a name="12" id="anc12"></a>



























































































































































































































































































































































































































































 252     void setMasterSecret(SecretKey secret) {
 253         masterSecret = secret;
 254     }
 255 
 256     void setResumptionMasterSecret(SecretKey secret) {
 257         resumptionMasterSecret = secret;
 258     }
 259 
 260     void setPreSharedKey(SecretKey key) {
 261         preSharedKey = key;
 262     }
 263 
 264     void addChild(SSLSessionImpl session) {
 265         childSessions.add(session);
 266     }
 267 
 268     void setTicketAgeAdd(int ticketAgeAdd) {
 269         this.ticketAgeAdd = ticketAgeAdd;
 270     }
 271 
 272     void setPskIdentity(byte[] pskIdentity) {
 273         this.pskIdentity = pskIdentity;
 274     }
 275 
 276     BigInteger incrTicketNonceCounter() {
 277         BigInteger result = ticketNonceCounter;
<a name="13" id="anc13"></a><span class="line-modified"> 278         ticketNonceCounter = ticketNonceCounter.add(BigInteger.valueOf(1));</span>
 279         return result;
 280     }
 281 
<a name="14" id="anc14"></a>



 282     /**
 283      * Returns the master secret ... treat with extreme caution!
 284      */
 285     SecretKey getMasterSecret() {
 286         return masterSecret;
 287     }
 288 
<a name="15" id="anc15"></a><span class="line-modified"> 289     Optional&lt;SecretKey&gt; getResumptionMasterSecret() {</span>
<span class="line-modified"> 290         return Optional.ofNullable(resumptionMasterSecret);</span>
 291     }
 292 
<a name="16" id="anc16"></a><span class="line-modified"> 293     synchronized Optional&lt;SecretKey&gt; getPreSharedKey() {</span>
<span class="line-modified"> 294         return Optional.ofNullable(preSharedKey);</span>





 295     }
 296 
<a name="17" id="anc17"></a><span class="line-modified"> 297     synchronized Optional&lt;SecretKey&gt; consumePreSharedKey() {</span>
<span class="line-modified"> 298         Optional&lt;SecretKey&gt; result = Optional.ofNullable(preSharedKey);</span>
<span class="line-modified"> 299         preSharedKey = null;</span>
<span class="line-modified"> 300         return result;</span>




 301     }
 302 
 303     int getTicketAgeAdd() {
 304         return ticketAgeAdd;
 305     }
 306 
 307     String getIdentificationProtocol() {
 308         return this.identificationProtocol;
 309     }
 310 
 311     /* PSK identities created from new_session_ticket messages should only
 312      * be used once. This method will return the identity and then clear it
 313      * so it cannot be used again.
 314      */
<a name="18" id="anc18"></a><span class="line-modified"> 315     synchronized Optional&lt;byte[]&gt; consumePskIdentity() {</span>
<span class="line-modified"> 316         Optional&lt;byte[]&gt; result = Optional.ofNullable(pskIdentity);</span>
<span class="line-modified"> 317         pskIdentity = null;</span>
<span class="line-modified"> 318         return result;</span>








 319     }
 320 
 321     void setPeerCertificates(X509Certificate[] peer) {
 322         if (peerCerts == null) {
 323             peerCerts = peer;
 324         }
 325     }
 326 
 327     void setLocalCertificates(X509Certificate[] local) {
 328         localCerts = local;
 329     }
 330 
 331     void setLocalPrivateKey(PrivateKey privateKey) {
 332         localPrivateKey = privateKey;
 333     }
 334 
 335     void setPeerSupportedSignatureAlgorithms(
 336             Collection&lt;SignatureScheme&gt; signatureSchemes) {
<a name="19" id="anc19"></a><span class="line-modified"> 337         peerSupportedSignAlgs =</span>
<span class="line-removed"> 338             SignatureScheme.getAlgorithmNames(signatureSchemes);</span>
 339     }
 340 
 341     // TLS 1.2 only
 342     //
 343     // Per RFC 5246, If the client supports only the default hash
 344     // and signature algorithms, it MAY omit the
 345     // signature_algorithms extension.  If the client does not
 346     // support the default algorithms, or supports other hash
 347     // and signature algorithms (and it is willing to use them
 348     // for verifying messages sent by the server, i.e., server
 349     // certificates and server key exchange), it MUST send the
 350     // signature_algorithms extension, listing the algorithms it
 351     // is willing to accept.
<a name="20" id="anc20"></a>




 352     void setUseDefaultPeerSignAlgs() {
 353         useDefaultPeerSignAlgs = true;
<a name="21" id="anc21"></a><span class="line-modified"> 354         peerSupportedSignAlgs = new String[] {</span>
<span class="line-removed"> 355             &quot;SHA1withRSA&quot;, &quot;SHA1withDSA&quot;, &quot;SHA1withECDSA&quot;};</span>
 356     }
 357 
 358     // Returns the connection session.
 359     SSLSessionImpl finish() {
 360         if (useDefaultPeerSignAlgs) {
<a name="22" id="anc22"></a><span class="line-modified"> 361             this.peerSupportedSignAlgs = new String[0];</span>
 362         }
 363 
 364         return this;
 365     }
 366 
 367     /**
 368      * Provide status response data obtained during the SSL handshake.
 369      *
 370      * @param responses a {@link List} of responses in binary form.
 371      */
 372     void setStatusResponses(List&lt;byte[]&gt; responses) {
 373         if (responses != null &amp;&amp; !responses.isEmpty()) {
 374             statusResponses = responses;
 375         } else {
 376             statusResponses = Collections.emptyList();
 377         }
 378     }
 379 
 380     /**
 381      * Returns true iff this session may be resumed ... sessions are
 382      * usually resumable.  Security policies may suggest otherwise,
 383      * for example sessions that haven&#39;t been used for a while (say,
 384      * a working day) won&#39;t be resumable, and sessions might have a
 385      * maximum lifetime in any case.
 386      */
 387     boolean isRejoinable() {
<a name="23" id="anc23"></a>



 388         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
<a name="24" id="anc24"></a><span class="line-modified"> 389             !invalidated &amp;&amp; isLocalAuthenticationValid();</span>
 390     }
 391 
 392     @Override
<a name="25" id="anc25"></a><span class="line-modified"> 393     public synchronized boolean isValid() {</span>
<span class="line-modified"> 394         return isRejoinable();</span>





 395     }
 396 
 397     /**
 398      * Check if the authentication used when establishing this session
 399      * is still valid. Returns true if no authentication was used
 400      */
 401     private boolean isLocalAuthenticationValid() {
 402         if (localPrivateKey != null) {
 403             try {
 404                 // if the private key is no longer valid, getAlgorithm()
 405                 // should throw an exception
 406                 // (e.g. Smartcard has been removed from the reader)
 407                 localPrivateKey.getAlgorithm();
 408             } catch (Exception e) {
 409                 invalidate();
 410                 return false;
 411             }
 412         }
 413 
 414         return true;
 415     }
 416 
 417     /**
 418      * Returns the ID for this session.  The ID is fixed for the
 419      * duration of the session; neither it, nor its value, changes.
 420      */
 421     @Override
 422     public byte[] getId() {
 423         return sessionId.getId();
 424     }
 425 
 426     /**
 427      * For server sessions, this returns the set of sessions which
 428      * are currently valid in this process.  For client sessions,
 429      * this returns null.
 430      */
 431     @Override
 432     public SSLSessionContext getSessionContext() {
 433         /*
 434          * An interim security policy until we can do something
 435          * more specific in 1.2. Only allow trusted code (code which
 436          * can set system properties) to get an
 437          * SSLSessionContext. This is to limit the ability of code to
 438          * look up specific sessions or enumerate over them. Otherwise,
 439          * code can only get session objects from successful SSL
 440          * connections which implies that they must have had permission
 441          * to make the network connection in the first place.
 442          */
 443         SecurityManager sm;
 444         if ((sm = System.getSecurityManager()) != null) {
 445             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 446         }
 447 
 448         return context;
 449     }
 450 
 451 
 452     SessionId getSessionId() {
 453         return sessionId;
 454     }
 455 
 456 
 457     /**
 458      * Returns the cipher spec in use on this session
 459      */
 460     CipherSuite getSuite() {
 461         return cipherSuite;
 462     }
 463 
 464     /**
 465      * Resets the cipher spec in use on this session
 466      */
 467     void setSuite(CipherSuite suite) {
 468        cipherSuite = suite;
 469 
 470         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 471              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 472        }
 473     }
 474 
 475     /**
 476      * Return true if the session is currently re-established with a
 477      * session-resumption abbreviated initial handshake.
 478      */
 479     boolean isSessionResumption() {
 480         return isSessionResumption;
 481     }
 482 
 483     /**
 484      * Resets whether the session is re-established with a session-resumption
 485      * abbreviated initial handshake.
 486      */
 487     void setAsSessionResumption(boolean flag) {
 488         isSessionResumption = flag;
 489     }
 490 
 491     /**
 492      * Returns the name of the cipher suite in use on this session
 493      */
 494     @Override
 495     public String getCipherSuite() {
 496         return getSuite().name;
 497     }
 498 
 499     ProtocolVersion getProtocolVersion() {
 500         return protocolVersion;
 501     }
 502 
 503     /**
 504      * Returns the standard name of the protocol in use on this session
 505      */
 506     @Override
 507     public String getProtocol() {
 508         return getProtocolVersion().name;
 509     }
 510 
 511     /**
 512      * Returns the hashcode for this session
 513      */
 514     @Override
 515     public int hashCode() {
 516         return sessionId.hashCode();
 517     }
 518 
 519     /**
 520      * Returns true if sessions have same ids, false otherwise.
 521      */
 522     @Override
 523     public boolean equals(Object obj) {
 524 
 525         if (obj == this) {
 526             return true;
 527         }
 528 
 529         if (obj instanceof SSLSessionImpl) {
 530             SSLSessionImpl sess = (SSLSessionImpl) obj;
 531             return (sessionId != null) &amp;&amp; (sessionId.equals(
 532                         sess.getSessionId()));
 533         }
 534 
 535         return false;
 536     }
 537 
 538 
 539     /**
 540      * Return the cert chain presented by the peer in the
 541      * java.security.cert format.
 542      * Note: This method can be used only when using certificate-based
 543      * cipher suites; using it with non-certificate-based cipher suites
 544      * will throw an SSLPeerUnverifiedException.
 545      *
 546      * @return array of peer X.509 certs, with the peer&#39;s own cert
 547      *  first in the chain, and with the &quot;root&quot; CA last.
 548      */
 549     @Override
 550     public java.security.cert.Certificate[] getPeerCertificates()
 551             throws SSLPeerUnverifiedException {
 552         //
 553         // clone to preserve integrity of session ... caller can&#39;t
 554         // change record of peer identity even by accident, much
 555         // less do it intentionally.
 556         //
 557         if (peerCerts == null) {
 558             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
 559         }
 560         // Certs are immutable objects, therefore we don&#39;t clone them.
 561         // But do need to clone the array, so that nothing is inserted
 562         // into peerCerts.
 563         return (java.security.cert.Certificate[])peerCerts.clone();
 564     }
 565 
 566     /**
 567      * Return the cert chain presented to the peer in the
 568      * java.security.cert format.
 569      * Note: This method is useful only when using certificate-based
 570      * cipher suites.
 571      *
 572      * @return array of peer X.509 certs, with the peer&#39;s own cert
 573      *  first in the chain, and with the &quot;root&quot; CA last.
 574      */
 575     @Override
 576     public java.security.cert.Certificate[] getLocalCertificates() {
 577         //
 578         // clone to preserve integrity of session ... caller can&#39;t
 579         // change record of peer identity even by accident, much
 580         // less do it intentionally.
 581         return (localCerts == null ? null :
 582             (java.security.cert.Certificate[])localCerts.clone());
 583     }
 584 
 585     /**
 586      * Return the cert chain presented by the peer in the
 587      * javax.security.cert format.
 588      * Note: This method can be used only when using certificate-based
 589      * cipher suites; using it with non-certificate-based cipher suites
 590      * will throw an SSLPeerUnverifiedException.
 591      *
 592      * @return array of peer X.509 certs, with the peer&#39;s own cert
 593      *  first in the chain, and with the &quot;root&quot; CA last.
 594      *
 595      * @deprecated This method returns the deprecated
 596      *  {@code javax.security.cert.X509Certificate} type.
 597      *  Use {@code getPeerCertificates()} instead.
 598      */
 599     @Override
 600     @SuppressWarnings(&quot;removal&quot;)
 601     @Deprecated(since=&quot;9&quot;, forRemoval=true)
 602     public javax.security.cert.X509Certificate[] getPeerCertificateChain()
 603             throws SSLPeerUnverifiedException {
 604         //
 605         // clone to preserve integrity of session ... caller can&#39;t
 606         // change record of peer identity even by accident, much
 607         // less do it intentionally.
 608         //
 609         if (peerCerts == null) {
 610             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
 611         }
 612         javax.security.cert.X509Certificate[] certs;
 613         certs = new javax.security.cert.X509Certificate[peerCerts.length];
 614         for (int i = 0; i &lt; peerCerts.length; i++) {
 615             byte[] der = null;
 616             try {
 617                 der = peerCerts[i].getEncoded();
 618                 certs[i] = javax.security.cert.X509Certificate.getInstance(der);
 619             } catch (CertificateEncodingException e) {
 620                 throw new SSLPeerUnverifiedException(e.getMessage());
 621             } catch (javax.security.cert.CertificateException e) {
 622                 throw new SSLPeerUnverifiedException(e.getMessage());
 623             }
 624         }
 625 
 626         return certs;
 627     }
 628 
 629     /**
 630      * Return the cert chain presented by the peer.
 631      * Note: This method can be used only when using certificate-based
 632      * cipher suites; using it with non-certificate-based cipher suites
 633      * will throw an SSLPeerUnverifiedException.
 634      *
 635      * @return array of peer X.509 certs, with the peer&#39;s own cert
 636      *  first in the chain, and with the &quot;root&quot; CA last.
 637      */
 638     public X509Certificate[] getCertificateChain()
 639             throws SSLPeerUnverifiedException {
 640         /*
 641          * clone to preserve integrity of session ... caller can&#39;t
 642          * change record of peer identity even by accident, much
 643          * less do it intentionally.
 644          */
 645         if (peerCerts != null) {
 646             return peerCerts.clone();
 647         } else {
 648             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
 649         }
 650     }
 651 
 652     /**
 653      * Return a List of status responses presented by the peer.
 654      * Note: This method can be used only when using certificate-based
 655      * server authentication; otherwise an empty {@code List} will be returned.
 656      *
 657      * @return an unmodifiable {@code List} of byte arrays, each consisting
 658      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
 659      * been presented by the server or non-certificate based server
 660      * authentication is used then an empty {@code List} is returned.
 661      */
 662     @Override
 663     public List&lt;byte[]&gt; getStatusResponses() {
 664         if (statusResponses == null || statusResponses.isEmpty()) {
 665             return Collections.emptyList();
 666         } else {
 667             // Clone both the list and the contents
 668             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
 669             for (byte[] respBytes : statusResponses) {
 670                 responses.add(respBytes.clone());
 671             }
 672             return Collections.unmodifiableList(responses);
 673         }
 674     }
 675 
 676     /**
 677      * Returns the identity of the peer which was established as part of
 678      * defining the session.
 679      *
 680      * @return the peer&#39;s principal. Returns an X500Principal of the
 681      * end-entity certificate for X509-based cipher suites.
 682      *
 683      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
 684      *          been verified
 685      */
 686     @Override
 687     public Principal getPeerPrincipal()
 688                 throws SSLPeerUnverifiedException
 689     {
 690         if (peerCerts == null) {
 691             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
 692         }
 693         return peerCerts[0].getSubjectX500Principal();
 694     }
 695 
 696     /**
 697      * Returns the principal that was sent to the peer during handshaking.
 698      *
 699      * @return the principal sent to the peer. Returns an X500Principal
 700      * of the end-entity certificate for X509-based cipher suites.
 701      * If no principal was sent, then null is returned.
 702      */
 703     @Override
 704     public Principal getLocalPrincipal() {
 705         return ((localCerts == null || localCerts.length == 0) ? null :
 706                 localCerts[0].getSubjectX500Principal());
 707     }
 708 
 709     /*
 710      * Return the time the ticket for this session was created.
 711      */
 712     public long getTicketCreationTime() {
 713         return ticketCreationTime;
 714     }
 715 
 716     /**
 717      * Returns the time this session was created.
 718      */
 719     @Override
 720     public long getCreationTime() {
 721         return creationTime;
 722     }
 723 
 724     /**
 725      * Returns the last time this session was used to initialize
 726      * a connection.
 727      */
 728     @Override
 729     public long getLastAccessedTime() {
 730         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
 731     }
 732 
 733     void setLastAccessedTime(long time) {
 734         lastUsedTime = time;
 735     }
 736 
 737 
 738     /**
 739      * Returns the network address of the session&#39;s peer.  This
 740      * implementation does not insist that connections between
 741      * different ports on the same host must necessarily belong
 742      * to different sessions, though that is of course allowed.
 743      */
 744     public InetAddress getPeerAddress() {
 745         try {
 746             return InetAddress.getByName(host);
 747         } catch (java.net.UnknownHostException e) {
 748             return null;
 749         }
 750     }
 751 
 752     @Override
 753     public String getPeerHost() {
 754         return host;
 755     }
 756 
 757     /**
 758      * Need to provide the port info for caching sessions based on
 759      * host and port. Accessed by SSLSessionContextImpl
 760      */
 761     @Override
 762     public int getPeerPort() {
 763         return port;
 764     }
 765 
 766     void setContext(SSLSessionContextImpl ctx) {
 767         if (context == null) {
 768             context = ctx;
 769         }
 770     }
 771 
 772     /**
 773      * Invalidate a session.  Active connections may still exist, but
 774      * no connections will be able to rejoin this session.
 775      */
 776     @Override
<a name="26" id="anc26"></a><span class="line-modified"> 777     public synchronized void invalidate() {</span>
<span class="line-modified"> 778         //</span>
<span class="line-modified"> 779         // Can&#39;t invalidate the NULL session -- this would be</span>
<span class="line-modified"> 780         // attempted when we get a handshaking error on a brand</span>
<span class="line-modified"> 781         // new connection, with no &quot;real&quot; session yet.</span>
<span class="line-modified"> 782         //</span>
<span class="line-modified"> 783         if (this == nullSession) {</span>
<span class="line-modified"> 784             return;</span>
<span class="line-modified"> 785         }</span>


 786 
<a name="27" id="anc27"></a><span class="line-modified"> 787         if (context != null) {</span>
<span class="line-modified"> 788             context.remove(sessionId);</span>
<span class="line-modified"> 789             context = null;</span>
<span class="line-modified"> 790         }</span>
<span class="line-modified"> 791         if (invalidated) {</span>
<span class="line-modified"> 792             return;</span>
<span class="line-modified"> 793         }</span>
<span class="line-modified"> 794         invalidated = true;</span>
<span class="line-modified"> 795         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {</span>
<span class="line-modified"> 796              SSLLogger.finest(&quot;Invalidated session:  &quot; + this);</span>
<span class="line-modified"> 797         }</span>
<span class="line-modified"> 798         for (SSLSessionImpl child : childSessions) {</span>
<span class="line-modified"> 799             child.invalidate();</span>




 800         }
 801     }
 802 
 803     /*
 804      * Table of application-specific session data indexed by an application
 805      * key and the calling security context. This is important since
 806      * sessions can be shared across different protection domains.
 807      */
 808     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
<a name="28" id="anc28"></a>
 809 
 810     /**
 811      * Assigns a session value.  Session change events are given if
 812      * appropriate, to any original value as well as the new value.
 813      */
 814     @Override
 815     public void putValue(String key, Object value) {
 816         if ((key == null) || (value == null)) {
 817             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
 818         }
 819 
 820         SecureKey secureKey = new SecureKey(key);
 821         Object oldValue = boundValues.put(secureKey, value);
 822 
 823         if (oldValue instanceof SSLSessionBindingListener) {
 824             SSLSessionBindingEvent e;
 825 
 826             e = new SSLSessionBindingEvent(this, key);
 827             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
 828         }
 829         if (value instanceof SSLSessionBindingListener) {
 830             SSLSessionBindingEvent e;
 831 
 832             e = new SSLSessionBindingEvent(this, key);
 833             ((SSLSessionBindingListener)value).valueBound(e);
 834         }
<a name="29" id="anc29"></a>


 835     }
 836 
 837     /**
 838      * Returns the specified session value.
 839      */
 840     @Override
 841     public Object getValue(String key) {
 842         if (key == null) {
 843             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
 844         }
 845 
 846         SecureKey secureKey = new SecureKey(key);
 847         return boundValues.get(secureKey);
 848     }
 849 
 850 
 851     /**
 852      * Removes the specified session value, delivering a session changed
 853      * event as appropriate.
 854      */
 855     @Override
 856     public void removeValue(String key) {
 857         if (key == null) {
 858             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
 859         }
 860 
 861         SecureKey secureKey = new SecureKey(key);
 862         Object value = boundValues.remove(secureKey);
 863 
 864         if (value instanceof SSLSessionBindingListener) {
 865             SSLSessionBindingEvent e;
 866 
 867             e = new SSLSessionBindingEvent(this, key);
 868             ((SSLSessionBindingListener)value).valueUnbound(e);
 869         }
<a name="30" id="anc30"></a>


 870     }
 871 
 872 
 873     /**
 874      * Lists the names of the session values.
 875      */
 876     @Override
 877     public String[] getValueNames() {
 878         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
 879         Object securityCtx = SecureKey.getCurrentSecurityContext();
 880         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
 881                 e.hasMoreElements(); ) {
 882             SecureKey key = e.nextElement();
 883             if (securityCtx.equals(key.getSecurityContext())) {
 884                 v.add(key.getAppKey());
 885             }
 886         }
 887 
 888         return v.toArray(new String[0]);
 889     }
 890 
 891     /**
 892      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
 893      * until changed.
 894      *
 895      * In the TLS specification (section 6.2.1, RFC2246), it is not
 896      * recommended that the plaintext has more than 2^14 bytes.
 897      * However, some TLS implementations violate the specification.
 898      * This is a workaround for interoperability with these stacks.
 899      *
 900      * Application could accept large fragments up to 2^15 bytes by
 901      * setting the system property jsse.SSLEngine.acceptLargeFragments
 902      * to &quot;true&quot;.
 903      */
 904     private boolean acceptLargeFragments =
 905             Utilities.getBooleanProperty(
 906                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
 907 
 908     /**
 909      * Expand the buffer size of both SSL/TLS network packet and
 910      * application data.
 911      */
<a name="31" id="anc31"></a><span class="line-modified"> 912     protected synchronized void expandBufferSizes() {</span>
<span class="line-modified"> 913         acceptLargeFragments = true;</span>





 914     }
 915 
 916     /**
 917      * Gets the current size of the largest SSL/TLS packet that is expected
 918      * when using this session.
 919      */
 920     @Override
<a name="32" id="anc32"></a><span class="line-modified"> 921     public synchronized int getPacketBufferSize() {</span>
<span class="line-modified"> 922         // Use the bigger packet size calculated from maximumPacketSize</span>
<span class="line-modified"> 923         // and negotiatedMaxFragLen.</span>
<span class="line-modified"> 924         int packetSize = 0;</span>
<span class="line-modified"> 925         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified"> 926             packetSize = cipherSuite.calculatePacketSize(</span>
<span class="line-modified"> 927                     negotiatedMaxFragLen, protocolVersion,</span>
<span class="line-modified"> 928                     protocolVersion.isDTLS);</span>
<span class="line-modified"> 929         }</span>


 930 
<a name="33" id="anc33"></a><span class="line-modified"> 931         if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified"> 932             return (maximumPacketSize &gt; packetSize) ?</span>
<span class="line-modified"> 933                     maximumPacketSize : packetSize;</span>
<span class="line-modified"> 934         }</span>
 935 
<a name="34" id="anc34"></a><span class="line-modified"> 936         if (packetSize != 0) {</span>
<span class="line-modified"> 937            return packetSize;</span>
<span class="line-modified"> 938         }</span>
 939 
<a name="35" id="anc35"></a><span class="line-modified"> 940         if (protocolVersion.isDTLS) {</span>
<span class="line-modified"> 941             return DTLSRecord.maxRecordSize;</span>
<span class="line-modified"> 942         } else {</span>
<span class="line-modified"> 943             return acceptLargeFragments ?</span>
<span class="line-modified"> 944                     SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>



 945         }
 946     }
 947 
 948     /**
 949      * Gets the current size of the largest application data that is
 950      * expected when using this session.
 951      */
 952     @Override
<a name="36" id="anc36"></a><span class="line-modified"> 953     public synchronized int getApplicationBufferSize() {</span>
<span class="line-modified"> 954         // Use the bigger fragment size calculated from maximumPacketSize</span>
<span class="line-modified"> 955         // and negotiatedMaxFragLen.</span>
<span class="line-modified"> 956         int fragmentSize = 0;</span>
<span class="line-modified"> 957         if (maximumPacketSize &gt; 0) {</span>
<span class="line-modified"> 958             fragmentSize = cipherSuite.calculateFragSize(</span>
<span class="line-modified"> 959                     maximumPacketSize, protocolVersion,</span>
<span class="line-modified"> 960                     protocolVersion.isDTLS);</span>
<span class="line-modified"> 961         }</span>


 962 
<a name="37" id="anc37"></a><span class="line-modified"> 963         if (negotiatedMaxFragLen &gt; 0) {</span>
<span class="line-modified"> 964             return (negotiatedMaxFragLen &gt; fragmentSize) ?</span>
<span class="line-modified"> 965                     negotiatedMaxFragLen : fragmentSize;</span>
<span class="line-modified"> 966         }</span>
 967 
<a name="38" id="anc38"></a><span class="line-modified"> 968         if (fragmentSize != 0) {</span>
<span class="line-modified"> 969             return fragmentSize;</span>
<span class="line-modified"> 970         }</span>
 971 
<a name="39" id="anc39"></a><span class="line-modified"> 972         if (protocolVersion.isDTLS) {</span>
<span class="line-modified"> 973             return Record.maxDataSize;</span>
<span class="line-modified"> 974         } else {</span>
<span class="line-modified"> 975             int maxPacketSize = acceptLargeFragments ?</span>
<span class="line-modified"> 976                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;</span>
<span class="line-modified"> 977             return (maxPacketSize - SSLRecord.headerSize);</span>



 978         }
 979     }
 980 
 981     /**
 982      * Sets the negotiated maximum fragment length, as specified by the
 983      * max_fragment_length ClientHello extension in RFC 6066.
 984      *
 985      * @param  negotiatedMaxFragLen
 986      *         the negotiated maximum fragment length, or {@code -1} if
 987      *         no such length has been negotiated.
 988      */
<a name="40" id="anc40"></a><span class="line-modified"> 989     synchronized void setNegotiatedMaxFragSize(</span>
 990             int negotiatedMaxFragLen) {
<a name="41" id="anc41"></a><span class="line-modified"> 991 </span>
<span class="line-modified"> 992         this.negotiatedMaxFragLen = negotiatedMaxFragLen;</span>




 993     }
 994 
 995     /**
 996      * Get the negotiated maximum fragment length, as specified by the
 997      * max_fragment_length ClientHello extension in RFC 6066.
 998      *
 999      * @return the negotiated maximum fragment length, or {@code -1} if
1000      *         no such length has been negotiated.
1001      */
<a name="42" id="anc42"></a><span class="line-modified">1002     synchronized int getNegotiatedMaxFragSize() {</span>
<span class="line-modified">1003         return negotiatedMaxFragLen;</span>





1004     }
1005 
<a name="43" id="anc43"></a><span class="line-modified">1006     synchronized void setMaximumPacketSize(int maximumPacketSize) {</span>
<span class="line-modified">1007         this.maximumPacketSize = maximumPacketSize;</span>





1008     }
1009 
<a name="44" id="anc44"></a><span class="line-modified">1010     synchronized int getMaximumPacketSize() {</span>
<span class="line-modified">1011         return maximumPacketSize;</span>





1012     }
1013 
1014     /**
1015      * Gets an array of supported signature algorithm names that the local
1016      * side is willing to verify.
1017      */
1018     @Override
1019     public String[] getLocalSupportedSignatureAlgorithms() {
1020         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1021     }
1022 
1023     /**
1024      * Gets an array of supported signature schemes that the local side is
1025      * willing to verify.
1026      */
1027     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1028         return localSupportedSignAlgs;
1029     }
1030 
1031     /**
1032      * Gets an array of supported signature algorithms that the peer is
1033      * able to verify.
1034      */
1035     @Override
1036     public String[] getPeerSupportedSignatureAlgorithms() {
<a name="45" id="anc45"></a><span class="line-modified">1037         if (peerSupportedSignAlgs != null) {</span>
<span class="line-removed">1038             return peerSupportedSignAlgs.clone();</span>
<span class="line-removed">1039         }</span>
<span class="line-removed">1040 </span>
<span class="line-removed">1041         return new String[0];</span>
1042     }
1043 
1044     /**
1045      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1046      * of the requested Server Name Indication (SNI) extension.
1047      */
1048     @Override
1049     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1050         return requestedServerNames;
1051     }
1052 
1053     /** Returns a string representation of this SSL session */
1054     @Override
1055     public String toString() {
1056         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1057     }
1058 }
1059 
1060 /**
1061  * This &quot;struct&quot; class serves as a Hash Key that combines an
1062  * application-specific key and a security context.
1063  */
1064 class SecureKey {
1065     private static final Object     nullObject = new Object();
1066     private final Object            appKey;
1067     private final Object            securityCtx;
1068 
1069     static Object getCurrentSecurityContext() {
1070         SecurityManager sm = System.getSecurityManager();
1071         Object context = null;
1072 
1073         if (sm != null)
1074             context = sm.getSecurityContext();
1075         if (context == null)
1076             context = nullObject;
1077         return context;
1078     }
1079 
1080     SecureKey(Object key) {
1081         this.appKey = key;
1082         this.securityCtx = getCurrentSecurityContext();
1083     }
1084 
1085     Object getAppKey() {
1086         return appKey;
1087     }
1088 
1089     Object getSecurityContext() {
1090         return securityCtx;
1091     }
1092 
1093     @Override
1094     public int hashCode() {
1095         return appKey.hashCode() ^ securityCtx.hashCode();
1096     }
1097 
1098     @Override
1099     public boolean equals(Object o) {
1100         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1101                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1102     }
1103 }
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
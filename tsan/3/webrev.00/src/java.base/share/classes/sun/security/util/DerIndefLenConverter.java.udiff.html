<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CurveDB.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerInputStream.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerIndefLenConverter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,11 +24,13 @@</span>
   */
  
  package sun.security.util;
  
  import java.io.IOException;
<span class="udiff-line-added">+ import java.io.InputStream;</span>
  import java.util.ArrayList;
<span class="udiff-line-added">+ import java.util.Arrays;</span>
  
  /**
   * A package private utility class to convert indefinite length DER
   * encoded byte arrays to definite length DER encoded byte arrays.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88,12 +90,10 @@</span>
      /**
       * Parse the tag and if it is an end-of-contents tag then
       * add the current position to the &lt;code&gt;eocList&lt;/code&gt; vector.
       */
      private void parseTag() throws IOException {
<span class="udiff-line-removed">-         if (dataPos == dataSize)</span>
<span class="udiff-line-removed">-             return;</span>
          if (isEOC(data[dataPos]) &amp;&amp; (data[dataPos + 1] == 0)) {
              int numOfEncapsulatedLenBytes = 0;
              Object elem = null;
              int index;
              for (index = ndefsList.size()-1; index &gt;= 0; index--) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141,10 +141,14 @@</span>
      }
  
      /**
       * Parse the length and if it is an indefinite length then add
       * the current position to the &lt;code&gt;ndefsList&lt;/code&gt; vector.
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return the length of definite length data next, or -1 if there is</span>
<span class="udiff-line-added">+      *         not enough bytes to determine it</span>
<span class="udiff-line-added">+      * @throws IOException if invalid data is read</span>
       */
      private int parseLength() throws IOException {
          int curLen = 0;
          if (dataPos == dataSize)
              return curLen;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158,11 +162,11 @@</span>
              lenByte &amp;= LEN_MASK;
              if (lenByte &gt; 4) {
                  throw new IOException(&quot;Too much data&quot;);
              }
              if ((dataSize - dataPos) &lt; (lenByte + 1)) {
<span class="udiff-line-modified-removed">-                 throw new IOException(&quot;Too little data&quot;);</span>
<span class="udiff-line-modified-added">+                 return -1;</span>
              }
              for (int i = 0; i &lt; lenByte; i++) {
                  curLen = (curLen &lt;&lt; 8) + (data[dataPos++] &amp; 0xff);
              }
              if (curLen &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,34 +316,41 @@</span>
       * a definte length DER encoding.
       *
       * @param indefData the byte array holding the indefinite
       *        length encoding.
       * @return the byte array containing the definite length
<span class="udiff-line-modified-removed">-      *         DER encoding.</span>
<span class="udiff-line-modified-added">+      *         DER encoding, or null if there is not enough data.</span>
       * @exception IOException on parsing or re-writing errors.
       */
<span class="udiff-line-modified-removed">-     byte[] convert(byte[] indefData) throws IOException {</span>
<span class="udiff-line-modified-added">+     byte[] convertBytes(byte[] indefData) throws IOException {</span>
          data = indefData;
          dataPos=0; index=0;
          dataSize = data.length;
          int len=0;
          int unused = 0;
  
          // parse and set up the vectors of all the indefinite-lengths
          while (dataPos &lt; dataSize) {
<span class="udiff-line-added">+             if (dataPos + 2 &gt; dataSize) {</span>
<span class="udiff-line-added">+                 // There should be at least one tag and one length</span>
<span class="udiff-line-added">+                 return null;</span>
<span class="udiff-line-added">+             }</span>
              parseTag();
              len = parseLength();
<span class="udiff-line-added">+             if (len &lt; 0) {</span>
<span class="udiff-line-added">+                 return null;</span>
<span class="udiff-line-added">+             }</span>
              parseValue(len);
              if (unresolved == 0) {
                  unused = dataSize - dataPos;
                  dataSize = dataPos;
                  break;
              }
          }
  
          if (unresolved != 0) {
<span class="udiff-line-modified-removed">-             throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="udiff-line-modified-added">+             return null;</span>
          }
  
          newData = new byte[dataSize + numOfTotalLenBytes + unused];
          dataPos=0; newDataPos=0; index=0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,6 +363,50 @@</span>
          System.arraycopy(indefData, dataSize,
                           newData, dataSize + numOfTotalLenBytes, unused);
  
          return newData;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Read the input stream into a DER byte array. If an indef len BER is</span>
<span class="udiff-line-added">+      * not resolved this method will try to read more data until EOF is reached.</span>
<span class="udiff-line-added">+      * This may block.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param in the input stream with tag and lenByte already read</span>
<span class="udiff-line-added">+      * @param lenByte the length of the length field to remember</span>
<span class="udiff-line-added">+      * @param tag the tag to remember</span>
<span class="udiff-line-added">+      * @return a DER byte array</span>
<span class="udiff-line-added">+      * @throws IOException if not all indef len BER</span>
<span class="udiff-line-added">+      *         can be resolved or another I/O error happens</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static byte[] convertStream(InputStream in, byte lenByte, byte tag)</span>
<span class="udiff-line-added">+             throws IOException {</span>
<span class="udiff-line-added">+         int offset = 2;     // for tag and length bytes</span>
<span class="udiff-line-added">+         int readLen = in.available();</span>
<span class="udiff-line-added">+         byte[] indefData = new byte[readLen + offset];</span>
<span class="udiff-line-added">+         indefData[0] = tag;</span>
<span class="udiff-line-added">+         indefData[1] = lenByte;</span>
<span class="udiff-line-added">+         while (true) {</span>
<span class="udiff-line-added">+             int bytesRead = in.readNBytes(indefData, offset, readLen);</span>
<span class="udiff-line-added">+             if (bytesRead != readLen) {</span>
<span class="udiff-line-added">+                 readLen = bytesRead;</span>
<span class="udiff-line-added">+                 indefData = Arrays.copyOf(indefData, offset + bytesRead);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="udiff-line-added">+             byte[] result = derIn.convertBytes(indefData);</span>
<span class="udiff-line-added">+             if (result == null) {</span>
<span class="udiff-line-added">+                 int next = in.read(); // This could block, but we need more</span>
<span class="udiff-line-added">+                 if (next == -1) {</span>
<span class="udiff-line-added">+                     throw new IOException(&quot;not all indef len BER resolved&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 int more = in.available();</span>
<span class="udiff-line-added">+                 // expand array to include next and more</span>
<span class="udiff-line-added">+                 indefData = Arrays.copyOf(indefData, offset + readLen + 1 + more);</span>
<span class="udiff-line-added">+                 indefData[offset + readLen] = (byte)next;</span>
<span class="udiff-line-added">+                 offset = offset + readLen + 1;</span>
<span class="udiff-line-added">+                 readLen = more;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 return result;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="CurveDB.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerInputStream.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
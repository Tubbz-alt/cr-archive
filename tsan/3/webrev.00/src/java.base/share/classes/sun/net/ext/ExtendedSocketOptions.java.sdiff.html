<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/ext/ExtendedSocketOptions.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TelnetProtocolException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../ftp/FtpLoginException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/ext/ExtendedSocketOptions.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.ext;
 27 
 28 import java.io.FileDescriptor;
 29 import java.net.SocketException;
 30 import java.net.SocketOption;
 31 import java.util.Collections;

 32 import java.util.Set;
<span class="line-removed"> 33 import java.util.stream.Collectors;</span>
 34 
 35 /**
 36  * Defines the infrastructure to support extended socket options, beyond those
 37  * defined in {@link java.net.StandardSocketOptions}.
 38  *
 39  * Extended socket options are accessed through the jdk.net API, which is in
 40  * the jdk.net module.
 41  */
 42 public abstract class ExtendedSocketOptions {
 43 
 44     public static final short SOCK_STREAM = 1;
 45     public static final short SOCK_DGRAM = 2;
 46 
 47     private final Set&lt;SocketOption&lt;?&gt;&gt; options;



 48 
 49     /** Tells whether or not the option is supported. */
 50     public final boolean isOptionSupported(SocketOption&lt;?&gt; option) {
 51         return options().contains(option);
 52     }
 53 
 54     /** Return the, possibly empty, set of extended socket options available. */
 55     public final Set&lt;SocketOption&lt;?&gt;&gt; options() { return options; }
 56 
 57     /**
 58      * Returns the (possibly empty) set of extended socket options for
 59      * stream-oriented listening sockets.
 60      */
 61     public static Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions() {
 62         return getInstance().options0(SOCK_STREAM, true);
 63     }
 64 
 65     /**
 66      * Returns the (possibly empty) set of extended socket options for
 67      * stream-oriented connecting sockets.
 68      */
 69     public static Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions() {
 70         return getInstance().options0(SOCK_STREAM, false);
 71     }
 72 
 73     /**
 74      * Returns the (possibly empty) set of extended socket options for
 75      * datagram-oriented sockets.
 76      */
 77     public static Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions() {
 78         return getInstance().options0(SOCK_DGRAM, false);
 79     }
 80 
<span class="line-modified"> 81     private boolean isDatagramOption(SocketOption&lt;?&gt; option) {</span>
 82         return !option.name().startsWith(&quot;TCP_&quot;);
 83     }
 84 
<span class="line-modified"> 85     private boolean isStreamOption(SocketOption&lt;?&gt; option, boolean server) {</span>
 86         if (server &amp;&amp; &quot;SO_FLOW_SLA&quot;.equals(option.name())) {
 87             return false;
 88         } else {
 89             return !option.name().startsWith(&quot;UDP_&quot;);
 90         }
 91     }
 92 
 93     private Set&lt;SocketOption&lt;?&gt;&gt; options0(short type, boolean server) {
<span class="line-removed"> 94         Set&lt;SocketOption&lt;?&gt;&gt; extOptions;</span>
 95         switch (type) {
 96             case SOCK_DGRAM:
<span class="line-modified"> 97                 extOptions = options.stream()</span>
<span class="line-removed"> 98                         .filter(option -&gt; isDatagramOption(option))</span>
<span class="line-removed"> 99                         .collect(Collectors.toUnmodifiableSet());</span>
<span class="line-removed">100                 break;</span>
101             case SOCK_STREAM:
<span class="line-modified">102                 extOptions = options.stream()</span>
<span class="line-modified">103                         .filter(option -&gt; isStreamOption(option, server))</span>
<span class="line-modified">104                         .collect(Collectors.toUnmodifiableSet());</span>
<span class="line-modified">105                 break;</span>

106             default:
107                 //this will never happen
108                 throw new IllegalArgumentException(&quot;Invalid socket option type&quot;);
109         }
<span class="line-removed">110         return extOptions;</span>
111     }
112 
113     /** Sets the value of a socket option, for the given socket. */
114     public abstract void setOption(FileDescriptor fd, SocketOption&lt;?&gt; option, Object value)
115             throws SocketException;
116 
117     /** Returns the value of a socket option, for the given socket. */
118     public abstract Object getOption(FileDescriptor fd, SocketOption&lt;?&gt; option)
119             throws SocketException;
120 
121     protected ExtendedSocketOptions(Set&lt;SocketOption&lt;?&gt;&gt; options) {
122         this.options = options;

















123     }
124 
125     private static volatile ExtendedSocketOptions instance;
126 
127     public static final ExtendedSocketOptions getInstance() { return instance; }
128 
129     /** Registers support for extended socket options. Invoked by the jdk.net module. */
130     public static final void register(ExtendedSocketOptions extOptions) {
131         if (instance != null)
132             throw new InternalError(&quot;Attempting to reregister extended options&quot;);
133 
134         instance = extOptions;
135     }
136 
137     static {
138         try {
139             // If the class is present, it will be initialized which
140             // triggers registration of the extended socket options.
141             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.ExtendedSocketOptions&quot;);
142         } catch (ClassNotFoundException e) {
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.ext;
 27 
 28 import java.io.FileDescriptor;
 29 import java.net.SocketException;
 30 import java.net.SocketOption;
 31 import java.util.Collections;
<span class="line-added"> 32 import java.util.HashSet;</span>
 33 import java.util.Set;

 34 
 35 /**
 36  * Defines the infrastructure to support extended socket options, beyond those
 37  * defined in {@link java.net.StandardSocketOptions}.
 38  *
 39  * Extended socket options are accessed through the jdk.net API, which is in
 40  * the jdk.net module.
 41  */
 42 public abstract class ExtendedSocketOptions {
 43 
 44     public static final short SOCK_STREAM = 1;
 45     public static final short SOCK_DGRAM = 2;
 46 
 47     private final Set&lt;SocketOption&lt;?&gt;&gt; options;
<span class="line-added"> 48     private final Set&lt;SocketOption&lt;?&gt;&gt; datagramOptions;</span>
<span class="line-added"> 49     private final Set&lt;SocketOption&lt;?&gt;&gt; clientStreamOptions;</span>
<span class="line-added"> 50     private final Set&lt;SocketOption&lt;?&gt;&gt; serverStreamOptions;</span>
 51 
 52     /** Tells whether or not the option is supported. */
 53     public final boolean isOptionSupported(SocketOption&lt;?&gt; option) {
 54         return options().contains(option);
 55     }
 56 
 57     /** Return the, possibly empty, set of extended socket options available. */
 58     public final Set&lt;SocketOption&lt;?&gt;&gt; options() { return options; }
 59 
 60     /**
 61      * Returns the (possibly empty) set of extended socket options for
 62      * stream-oriented listening sockets.
 63      */
 64     public static Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions() {
 65         return getInstance().options0(SOCK_STREAM, true);
 66     }
 67 
 68     /**
 69      * Returns the (possibly empty) set of extended socket options for
 70      * stream-oriented connecting sockets.
 71      */
 72     public static Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions() {
 73         return getInstance().options0(SOCK_STREAM, false);
 74     }
 75 
 76     /**
 77      * Returns the (possibly empty) set of extended socket options for
 78      * datagram-oriented sockets.
 79      */
 80     public static Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions() {
 81         return getInstance().options0(SOCK_DGRAM, false);
 82     }
 83 
<span class="line-modified"> 84     private static boolean isDatagramOption(SocketOption&lt;?&gt; option) {</span>
 85         return !option.name().startsWith(&quot;TCP_&quot;);
 86     }
 87 
<span class="line-modified"> 88     private static boolean isStreamOption(SocketOption&lt;?&gt; option, boolean server) {</span>
 89         if (server &amp;&amp; &quot;SO_FLOW_SLA&quot;.equals(option.name())) {
 90             return false;
 91         } else {
 92             return !option.name().startsWith(&quot;UDP_&quot;);
 93         }
 94     }
 95 
 96     private Set&lt;SocketOption&lt;?&gt;&gt; options0(short type, boolean server) {

 97         switch (type) {
 98             case SOCK_DGRAM:
<span class="line-modified"> 99                 return datagramOptions;</span>



100             case SOCK_STREAM:
<span class="line-modified">101                 if (server) {</span>
<span class="line-modified">102                     return serverStreamOptions;</span>
<span class="line-modified">103                 } else {</span>
<span class="line-modified">104                     return clientStreamOptions;</span>
<span class="line-added">105                 }</span>
106             default:
107                 //this will never happen
108                 throw new IllegalArgumentException(&quot;Invalid socket option type&quot;);
109         }

110     }
111 
112     /** Sets the value of a socket option, for the given socket. */
113     public abstract void setOption(FileDescriptor fd, SocketOption&lt;?&gt; option, Object value)
114             throws SocketException;
115 
116     /** Returns the value of a socket option, for the given socket. */
117     public abstract Object getOption(FileDescriptor fd, SocketOption&lt;?&gt; option)
118             throws SocketException;
119 
120     protected ExtendedSocketOptions(Set&lt;SocketOption&lt;?&gt;&gt; options) {
121         this.options = options;
<span class="line-added">122         var datagramOptions = new HashSet&lt;SocketOption&lt;?&gt;&gt;();</span>
<span class="line-added">123         var serverStreamOptions = new HashSet&lt;SocketOption&lt;?&gt;&gt;();</span>
<span class="line-added">124         var clientStreamOptions = new HashSet&lt;SocketOption&lt;?&gt;&gt;();</span>
<span class="line-added">125         for (var option : options) {</span>
<span class="line-added">126             if (isDatagramOption(option)) {</span>
<span class="line-added">127                 datagramOptions.add(option);</span>
<span class="line-added">128             }</span>
<span class="line-added">129             if (isStreamOption(option, true)) {</span>
<span class="line-added">130                 serverStreamOptions.add(option);</span>
<span class="line-added">131             }</span>
<span class="line-added">132             if (isStreamOption(option, false)) {</span>
<span class="line-added">133                 clientStreamOptions.add(option);</span>
<span class="line-added">134             }</span>
<span class="line-added">135         }</span>
<span class="line-added">136         this.datagramOptions = Set.copyOf(datagramOptions);</span>
<span class="line-added">137         this.serverStreamOptions = Set.copyOf(serverStreamOptions);</span>
<span class="line-added">138         this.clientStreamOptions = Set.copyOf(clientStreamOptions);</span>
139     }
140 
141     private static volatile ExtendedSocketOptions instance;
142 
143     public static final ExtendedSocketOptions getInstance() { return instance; }
144 
145     /** Registers support for extended socket options. Invoked by the jdk.net module. */
146     public static final void register(ExtendedSocketOptions extOptions) {
147         if (instance != null)
148             throw new InternalError(&quot;Attempting to reregister extended options&quot;);
149 
150         instance = extOptions;
151     }
152 
153     static {
154         try {
155             // If the class is present, it will be initialized which
156             // triggers registration of the extended socket options.
157             Class&lt;?&gt; c = Class.forName(&quot;jdk.net.ExtendedSocketOptions&quot;);
158         } catch (ClassNotFoundException e) {
</pre>
</td>
</tr>
</table>
<center><a href="../TelnetProtocolException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../ftp/FtpLoginException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
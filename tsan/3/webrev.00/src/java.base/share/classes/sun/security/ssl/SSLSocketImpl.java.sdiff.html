<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSessionImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;


  41 import java.util.function.BiFunction;
  42 import javax.net.ssl.HandshakeCompletedListener;
  43 import javax.net.ssl.SSLException;
  44 import javax.net.ssl.SSLHandshakeException;
  45 import javax.net.ssl.SSLParameters;
  46 import javax.net.ssl.SSLProtocolException;
  47 import javax.net.ssl.SSLServerSocket;
  48 import javax.net.ssl.SSLSession;
  49 import javax.net.ssl.SSLSocket;
  50 import jdk.internal.access.JavaNetInetAddressAccess;
  51 import jdk.internal.access.SharedSecrets;
  52 
  53 /**
  54  * Implementation of an SSL socket.
  55  * &lt;P&gt;
  56  * This is a normal connection type socket, implementing SSL over some lower
  57  * level socket, such as TCP.  Because it is layered over some lower level
  58  * socket, it MUST override all default socket methods.
  59  * &lt;P&gt;
  60  * This API offers a non-traditional option for establishing SSL
</pre>
<hr />
<pre>
  67  *
  68  * @see javax.net.ssl.SSLSocket
  69  * @see SSLServerSocket
  70  *
  71  * @author David Brownell
  72  */
  73 public final class SSLSocketImpl
  74         extends BaseSSLSocketImpl implements SSLTransport {
  75 
  76     final SSLContextImpl            sslContext;
  77     final TransportContext          conContext;
  78 
  79     private final AppInputStream    appInput = new AppInputStream();
  80     private final AppOutputStream   appOutput = new AppOutputStream();
  81 
  82     private String                  peerHost;
  83     private boolean                 autoClose;
  84     private boolean                 isConnected = false;
  85     private volatile boolean        tlsIsClosed = false;
  86 



  87     /*
  88      * Is the local name service trustworthy?
  89      *
  90      * If the local name service is not trustworthy, reverse host name
  91      * resolution should not be performed for endpoint identification.
  92      */
  93     private static final boolean trustNameService =
  94             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
  95 
  96     /**
  97      * Package-private constructor used to instantiate an unconnected
  98      * socket.
  99      *
 100      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 101      */
 102     SSLSocketImpl(SSLContextImpl sslContext) {
 103         super();
 104         this.sslContext = sslContext;
 105         HandshakeHash handshakeHash = new HandshakeHash();
 106         this.conContext = new TransportContext(sslContext, this,
</pre>
<hr />
<pre>
 275 
 276         if (isLayered()) {
 277             throw new SocketException(&quot;Already connected&quot;);
 278         }
 279 
 280         if (!(endpoint instanceof InetSocketAddress)) {
 281             throw new SocketException(
 282                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 283         }
 284 
 285         super.connect(endpoint, timeout);
 286         doneConnect();
 287     }
 288 
 289     @Override
 290     public String[] getSupportedCipherSuites() {
 291         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 292     }
 293 
 294     @Override
<span class="line-modified"> 295     public synchronized String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 296         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>






 297     }
 298 
 299     @Override
<span class="line-modified"> 300     public synchronized void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 301         conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-modified"> 302                 CipherSuite.validValuesOf(suites);</span>





 303     }
 304 
 305     @Override
 306     public String[] getSupportedProtocols() {
 307         return ProtocolVersion.toStringArray(
 308                 sslContext.getSupportedProtocolVersions());
 309     }
 310 
 311     @Override
<span class="line-modified"> 312     public synchronized String[] getEnabledProtocols() {</span>
<span class="line-modified"> 313         return ProtocolVersion.toStringArray(</span>
<span class="line-modified"> 314                 conContext.sslConfig.enabledProtocols);</span>





 315     }
 316 
 317     @Override
<span class="line-modified"> 318     public synchronized void setEnabledProtocols(String[] protocols) {</span>
 319         if (protocols == null) {
 320             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 321         }
 322 
<span class="line-modified"> 323         conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified"> 324                 ProtocolVersion.namesOf(protocols);</span>





 325     }
 326 
 327     @Override
 328     public SSLSession getSession() {
 329         try {
 330             // start handshaking, if failed, the connection will be closed.
 331             ensureNegotiated();
 332         } catch (IOException ioe) {
 333             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 334                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 335             }
 336 
 337             return SSLSessionImpl.nullSession;
 338         }
 339 
 340         return conContext.conSession;
 341     }
 342 
 343     @Override
<span class="line-modified"> 344     public synchronized SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 345         if (conContext.handshakeContext != null) {</span>
<span class="line-modified"> 346             synchronized (this) {</span>
<span class="line-modified"> 347                 if (conContext.handshakeContext != null) {</span>
<span class="line-modified"> 348                     return conContext.handshakeContext.handshakeSession;</span>
<span class="line-modified"> 349                 }</span>
<span class="line-modified"> 350             }</span>
 351         }
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353         return null;</span>
 354     }
 355 
 356     @Override
<span class="line-modified"> 357     public synchronized void addHandshakeCompletedListener(</span>
 358             HandshakeCompletedListener listener) {
 359         if (listener == null) {
 360             throw new IllegalArgumentException(&quot;listener is null&quot;);
 361         }
 362 
<span class="line-modified"> 363         conContext.sslConfig.addHandshakeCompletedListener(listener);</span>





 364     }
 365 
 366     @Override
<span class="line-modified"> 367     public synchronized void removeHandshakeCompletedListener(</span>
 368             HandshakeCompletedListener listener) {
 369         if (listener == null) {
 370             throw new IllegalArgumentException(&quot;listener is null&quot;);
 371         }
 372 
<span class="line-modified"> 373         conContext.sslConfig.removeHandshakeCompletedListener(listener);</span>





 374     }
 375 
 376     @Override
 377     public void startHandshake() throws IOException {
 378         if (!isConnected) {
 379             throw new SocketException(&quot;Socket is not connected&quot;);
 380         }
 381 
 382         if (conContext.isBroken || conContext.isInboundClosed() ||
 383                 conContext.isOutboundClosed()) {
 384             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 385         }
 386 
<span class="line-modified"> 387         synchronized (conContext) {     // handshake lock</span>

 388             // double check the context status
 389             if (conContext.isBroken || conContext.isInboundClosed() ||
 390                     conContext.isOutboundClosed()) {
 391                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 392             }
 393 
 394             try {
 395                 conContext.kickstart();
 396 
 397                 // All initial handshaking goes through this operation until we
 398                 // have a valid SSL connection.
 399                 //
 400                 // Handle handshake messages only, need no application data.
 401                 if (!conContext.isNegotiated) {
 402                     readHandshakeRecord();
 403                 }
 404             } catch (IOException ioe) {
 405                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 406                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 407             } catch (Exception oe) {    // including RuntimeException
 408                 handleException(oe);
 409             }


 410         }
 411     }
 412 
 413     @Override
<span class="line-modified"> 414     public synchronized void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 415         conContext.setUseClientMode(mode);</span>





 416     }
 417 
 418     @Override
<span class="line-modified"> 419     public synchronized boolean getUseClientMode() {</span>
<span class="line-modified"> 420         return conContext.sslConfig.isClientMode;</span>





 421     }
 422 
 423     @Override
<span class="line-modified"> 424     public synchronized void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 425         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 426                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-modified"> 427                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 428     }
 429 
 430     @Override
<span class="line-modified"> 431     public synchronized boolean getNeedClientAuth() {</span>
<span class="line-modified"> 432         return (conContext.sslConfig.clientAuthType ==</span>


 433                         ClientAuthType.CLIENT_AUTH_REQUIRED);



 434     }
 435 
 436     @Override
<span class="line-modified"> 437     public synchronized void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 438         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified"> 439                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-modified"> 440                         ClientAuthType.CLIENT_AUTH_NONE);</span>





 441     }
 442 
 443     @Override
<span class="line-modified"> 444     public synchronized boolean getWantClientAuth() {</span>
<span class="line-modified"> 445         return (conContext.sslConfig.clientAuthType ==</span>


 446                         ClientAuthType.CLIENT_AUTH_REQUESTED);



 447     }
 448 
 449     @Override
<span class="line-modified"> 450     public synchronized void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 451         conContext.sslConfig.enableSessionCreation = flag;</span>





 452     }
 453 
 454     @Override
<span class="line-modified"> 455     public synchronized boolean getEnableSessionCreation() {</span>
<span class="line-modified"> 456         return conContext.sslConfig.enableSessionCreation;</span>





 457     }
 458 
 459     @Override
 460     public boolean isClosed() {
 461         return tlsIsClosed;
 462     }
 463 
 464     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 465     // locks may be deadlocked.
 466     @Override
 467     public void close() throws IOException {
 468         if (tlsIsClosed) {
 469             return;
 470         }
 471 
 472         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 473             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 474         }
 475 
 476         try {
</pre>
<hr />
<pre>
 525         if (conContext.isNegotiated) {
 526             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 527                 hasCloseReceipt = true;
 528             } else {
 529                 // Use a user_canceled alert for TLS 1.3 duplex close.
 530                 useUserCanceled = true;
 531             }
 532         } else if (conContext.handshakeContext != null) {   // initial handshake
 533             // Use user_canceled alert regardless the protocol versions.
 534             useUserCanceled = true;
 535 
 536             // The protocol version may have been negotiated.
 537             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 538             if (pv == null || (!pv.useTLS13PlusSpec())) {
 539                 hasCloseReceipt = true;
 540             }
 541         }
 542 
 543         // Need a lock here so that the user_canceled alert and the
 544         // close_notify alert can be delivered together.
<span class="line-modified"> 545         try {</span>
<span class="line-modified"> 546             synchronized (conContext.outputRecord) {</span>
<span class="line-modified"> 547                 // send a user_canceled alert if needed.</span>
<span class="line-modified"> 548                 if (useUserCanceled) {</span>
<span class="line-modified"> 549                     conContext.warning(Alert.USER_CANCELED);</span>
















































 550                 }

















 551 
<span class="line-modified"> 552                 // send a close_notify alert</span>
<span class="line-modified"> 553                 conContext.warning(Alert.CLOSE_NOTIFY);</span>









 554             }



 555         } finally {
 556             if (!conContext.isOutboundClosed()) {
 557                 conContext.outputRecord.close();
 558             }
 559 
<span class="line-modified"> 560             if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {</span>

 561                 super.shutdownOutput();
 562             }
 563         }
<span class="line-removed"> 564 </span>
<span class="line-removed"> 565         if (!isInputShutdown()) {</span>
<span class="line-removed"> 566             bruteForceCloseInput(hasCloseReceipt);</span>
<span class="line-removed"> 567         }</span>
 568     }
 569 
 570     /**
 571      * Duplex close, start from closing inbound.
 572      *
 573      * This method should only be called when the outbound has been closed,
 574      * but the inbound is still open.
 575      */
 576     private void duplexCloseInput() throws IOException {
 577         boolean hasCloseReceipt = false;
 578         if (conContext.isNegotiated &amp;&amp;
 579                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 580             hasCloseReceipt = true;
 581         }   // No close receipt if handshake has no completed.
 582 
 583         bruteForceCloseInput(hasCloseReceipt);
 584     }
 585 
 586     /**
 587      * Brute force close the input bound.
</pre>
<hr />
<pre>
 671             return;
 672         }
 673 
 674         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 675             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 676         }
 677         conContext.closeOutbound();
 678 
 679         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 680             super.shutdownOutput();
 681         }
 682     }
 683 
 684     @Override
 685     public boolean isOutputShutdown() {
 686         return conContext.isOutboundClosed() &amp;&amp;
 687                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 688     }
 689 
 690     @Override
<span class="line-modified"> 691     public synchronized InputStream getInputStream() throws IOException {</span>
<span class="line-modified"> 692         if (isClosed()) {</span>
<span class="line-modified"> 693             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-modified"> 694         }</span>


 695 
<span class="line-modified"> 696         if (!isConnected) {</span>
<span class="line-modified"> 697             throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified"> 698         }</span>
 699 
<span class="line-modified"> 700         if (conContext.isInboundClosed() || isInputShutdown()) {</span>
<span class="line-modified"> 701             throw new SocketException(&quot;Socket input is already shutdown&quot;);</span>
<span class="line-modified"> 702         }</span>
 703 
<span class="line-modified"> 704         return appInput;</span>



 705     }
 706 
 707     private void ensureNegotiated() throws IOException {
 708         if (conContext.isNegotiated || conContext.isBroken ||
 709                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 710             return;
 711         }
 712 
<span class="line-modified"> 713         synchronized (conContext) {     // handshake lock</span>

 714             // double check the context status
 715             if (conContext.isNegotiated || conContext.isBroken ||
 716                     conContext.isInboundClosed() ||
 717                     conContext.isOutboundClosed()) {
 718                 return;
 719             }
 720 
 721             startHandshake();


 722         }
 723     }
 724 
 725     /**
 726      * InputStream for application data as returned by
 727      * SSLSocket.getInputStream().
 728      */
 729     private class AppInputStream extends InputStream {
 730         // One element array used to implement the single byte read() method
 731         private final byte[] oneByte = new byte[1];
 732 
 733         // the temporary buffer used to read network
 734         private ByteBuffer buffer;
 735 
 736         // Is application data available in the stream?
 737         private volatile boolean appDataIsAvailable;
 738 







 739         AppInputStream() {
 740             this.appDataIsAvailable = false;
 741             this.buffer = ByteBuffer.allocate(4096);
 742         }
 743 
 744         /**
 745          * Return the minimum number of bytes that can be read
 746          * without blocking.
 747          */
 748         @Override
 749         public int available() throws IOException {
 750             // Currently not synchronized.
 751             if ((!appDataIsAvailable) || checkEOF()) {
 752                 return 0;
 753             }
 754 
 755             return buffer.remaining();
 756         }
 757 
 758         /**
</pre>
<hr />
<pre>
 764             if (n &lt;= 0) {   // EOF
 765                 return -1;
 766             }
 767 
 768             return oneByte[0] &amp; 0xFF;
 769         }
 770 
 771         /**
 772          * Reads up to {@code len} bytes of data from the input stream
 773          * into an array of bytes.
 774          *
 775          * An attempt is made to read as many as {@code len} bytes, but a
 776          * smaller number may be read. The number of bytes actually read
 777          * is returned as an integer.
 778          *
 779          * If the layer above needs more data, it asks for more, so we
 780          * are responsible only for blocking to fill at most one buffer,
 781          * and returning &quot;-1&quot; on non-fault EOF status.
 782          */
 783         @Override
<span class="line-modified"> 784         public int read(byte[] b, int off, int len)</span>
<span class="line-removed"> 785                 throws IOException {</span>
 786             if (b == null) {
 787                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 788             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 789                 throw new IndexOutOfBoundsException(
 790                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 791                         &quot;, bytes to read:&quot; + len);
 792             } else if (len == 0) {
 793                 return 0;
 794             }
 795 
 796             if (checkEOF()) {
 797                 return -1;
 798             }
 799 
 800             // start handshaking if the connection has not been negotiated.
 801             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 802                     !conContext.isInboundClosed() &amp;&amp;
 803                     !conContext.isOutboundClosed()) {
 804                 ensureNegotiated();
 805             }
 806 
 807             // Check if the Socket is invalid (error or closed).
 808             if (!conContext.isNegotiated ||
 809                     conContext.isBroken || conContext.isInboundClosed()) {
 810                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 811             }
 812 













 813             // Read the available bytes at first.
 814             //
 815             // Note that the receiving and processing of post-handshake message
 816             // are also synchronized with the read lock.
<span class="line-modified"> 817             synchronized (this) {</span>
















 818                 int remains = available();
 819                 if (remains &gt; 0) {
 820                     int howmany = Math.min(remains, len);
 821                     buffer.get(b, off, howmany);
 822 
 823                     return howmany;
 824                 }
 825 
 826                 appDataIsAvailable = false;
 827                 try {
 828                     ByteBuffer bb = readApplicationRecord(buffer);
 829                     if (bb == null) {   // EOF
 830                         return -1;
 831                     } else {
 832                         // The buffer may be reallocated for bigger capacity.
 833                         buffer = bb;
 834                     }
 835 
 836                     bb.flip();
 837                     int volume = Math.min(len, bb.remaining());
 838                     buffer.get(b, off, volume);
 839                     appDataIsAvailable = true;
 840 
 841                     return volume;
 842                 } catch (Exception e) {   // including RuntimeException
 843                     // shutdown and rethrow (wrapped) exception as appropriate
 844                     handleException(e);
 845 
 846                     // dummy for compiler
 847                     return -1;
 848                 }












 849             }
 850         }
 851 
 852         /**
 853          * Skip n bytes.
 854          *
 855          * This implementation is somewhat less efficient than possible, but
 856          * not badly so (redundant copy).  We reuse the read() code to keep
 857          * things simpler.
 858          */
 859         @Override
<span class="line-modified"> 860         public synchronized long skip(long n) throws IOException {</span>
 861             // dummy array used to implement skip()
 862             byte[] skipArray = new byte[256];
<span class="line-removed"> 863 </span>
 864             long skipped = 0;
<span class="line-modified"> 865             while (n &gt; 0) {</span>
<span class="line-modified"> 866                 int len = (int)Math.min(n, skipArray.length);</span>
<span class="line-modified"> 867                 int r = read(skipArray, 0, len);</span>
<span class="line-modified"> 868                 if (r &lt;= 0) {</span>
<span class="line-modified"> 869                     break;</span>






 870                 }
<span class="line-modified"> 871                 n -= r;</span>
<span class="line-modified"> 872                 skipped += r;</span>
 873             }
 874 
 875             return skipped;
 876         }
 877 
 878         @Override
 879         public void close() throws IOException {
 880             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 881                 SSLLogger.finest(&quot;Closing input stream&quot;);
 882             }
 883 
 884             try {
<span class="line-modified"> 885                 shutdownInput(false);</span>
 886             } catch (IOException ioe) {
 887                 // ignore the exception
 888                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 889                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
 890                 }
 891             }
 892         }
 893 
 894         /**
 895          * Return whether we have reached end-of-file.
 896          *
 897          * If the socket is not connected, has been shutdown because of an error
 898          * or has been closed, throw an Exception.
 899          */
 900         private boolean checkEOF() throws IOException {
 901             if (conContext.isInboundClosed()) {
 902                 return true;
 903             } else if (conContext.isInputCloseNotified || conContext.isBroken) {
 904                 if (conContext.closeReason == null) {
 905                     return true;
 906                 } else {
 907                     throw new SSLException(
 908                         &quot;Connection has closed: &quot; + conContext.closeReason,
 909                         conContext.closeReason);
 910                 }
 911             }
 912 
 913             return false;
 914         }
 915 
 916         /**
 917          * Try the best to use up the input records so as to close the
 918          * socket gracefully, without impact the performance too much.
 919          */
<span class="line-modified"> 920         private synchronized void deplete() {</span>
<span class="line-modified"> 921             if (!conContext.isInboundClosed()) {</span>
<span class="line-modified"> 922                 if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {</span>
<span class="line-modified"> 923                     return;</span>
<span class="line-removed"> 924                 }</span>
 925 
<span class="line-modified"> 926                 SSLSocketInputRecord socketInputRecord =</span>
<span class="line-modified"> 927                         (SSLSocketInputRecord)conContext.inputRecord;</span>
 928                 try {
<span class="line-modified"> 929                     socketInputRecord.deplete(</span>
<span class="line-modified"> 930                         conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));</span>
<span class="line-modified"> 931                 } catch (IOException ioe) {</span>
<span class="line-removed"> 932                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-removed"> 933                         SSLLogger.warning(</span>
<span class="line-removed"> 934                             &quot;input stream close depletion failed&quot;, ioe);</span>
<span class="line-removed"> 935                     }</span>
 936                 }
 937             }
 938         }































 939     }
 940 
 941     @Override
<span class="line-modified"> 942     public synchronized OutputStream getOutputStream() throws IOException {</span>
<span class="line-modified"> 943         if (isClosed()) {</span>
<span class="line-modified"> 944             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-modified"> 945         }</span>


 946 
<span class="line-modified"> 947         if (!isConnected) {</span>
<span class="line-modified"> 948             throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified"> 949         }</span>
 950 
<span class="line-modified"> 951         if (conContext.isOutboundDone() || isOutputShutdown()) {</span>
<span class="line-modified"> 952             throw new SocketException(&quot;Socket output is already shutdown&quot;);</span>
<span class="line-modified"> 953         }</span>
 954 
<span class="line-modified"> 955         return appOutput;</span>



 956     }
 957 
 958 
 959     /**
 960      * OutputStream for application data as returned by
 961      * SSLSocket.getOutputStream().
 962      */
 963     private class AppOutputStream extends OutputStream {
 964         // One element array used to implement the write(byte) method
 965         private final byte[] oneByte = new byte[1];
 966 
 967         @Override
 968         public void write(int i) throws IOException {
 969             oneByte[0] = (byte)i;
 970             write(oneByte, 0, 1);
 971         }
 972 
 973         @Override
 974         public void write(byte[] b,
 975                 int off, int len) throws IOException {
</pre>
<hr />
<pre>
 995             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 996                     !conContext.isInboundClosed() &amp;&amp;
 997                     !conContext.isOutboundClosed()) {
 998                 ensureNegotiated();
 999             }
1000 
1001             // Check if the Socket is invalid (error or closed).
1002             if (!conContext.isNegotiated ||
1003                     conContext.isBroken || conContext.isOutboundClosed()) {
1004                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1005             }
1006 
1007             //
1008 
1009             // Delegate the writing to the underlying socket.
1010             try {
1011                 conContext.outputRecord.deliver(b, off, len);
1012             } catch (SSLHandshakeException she) {
1013                 // may be record sequence number overflow
1014                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
<span class="line-modified">1015             } catch (IOException e) {</span>
<span class="line-modified">1016                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);</span>
<span class="line-modified">1017             }</span>


1018 
1019             // Is the sequence number is nearly overflow, or has the key usage
1020             // limit been reached?
1021             if (conContext.outputRecord.seqNumIsHuge() ||
1022                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1023                 tryKeyUpdate();
1024             }





1025         }
1026 
1027         @Override
1028         public void close() throws IOException {
1029             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1030                 SSLLogger.finest(&quot;Closing output stream&quot;);
1031             }
1032 
1033             try {
<span class="line-modified">1034                 shutdownOutput();</span>
1035             } catch (IOException ioe) {
1036                 // ignore the exception
1037                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1038                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1039                 }
1040             }
1041         }
1042     }
1043 
1044     @Override
<span class="line-modified">1045     public synchronized SSLParameters getSSLParameters() {</span>
<span class="line-modified">1046         return conContext.sslConfig.getSSLParameters();</span>





1047     }
1048 
1049     @Override
<span class="line-modified">1050     public synchronized void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">1051         conContext.sslConfig.setSSLParameters(params);</span>


1052 
<span class="line-modified">1053         if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">1054             conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">1055                     conContext.sslConfig.maximumPacketSize);</span>



1056         }
1057     }
1058 
1059     @Override
<span class="line-modified">1060     public synchronized String getApplicationProtocol() {</span>
<span class="line-modified">1061         return conContext.applicationProtocol;</span>





1062     }
1063 
1064     @Override
<span class="line-modified">1065     public synchronized String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">1066         if (conContext.handshakeContext != null) {</span>
<span class="line-modified">1067             return conContext.handshakeContext.applicationProtocol;</span>





1068         }
1069 
1070         return null;
1071     }
1072 
1073     @Override
<span class="line-modified">1074     public synchronized void setHandshakeApplicationProtocolSelector(</span>
1075             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">1076         conContext.sslConfig.socketAPSelector = selector;</span>





1077     }
1078 
1079     @Override
<span class="line-modified">1080     public synchronized BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;</span>
1081             getHandshakeApplicationProtocolSelector() {
<span class="line-modified">1082         return conContext.sslConfig.socketAPSelector;</span>





1083     }
1084 
1085     /**
1086      * Read the initial handshake records.
1087      */
1088     private int readHandshakeRecord() throws IOException {
1089         while (!conContext.isInboundClosed()) {
1090             try {
1091                 Plaintext plainText = decode(null);
1092                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1093                         conContext.isNegotiated) {
1094                     return 0;
1095                 }
1096             } catch (SSLException ssle) {
1097                 throw ssle;
1098             } catch (IOException ioe) {
1099                 if (!(ioe instanceof SSLException)) {
1100                     throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1101                 } else {
1102                     throw ioe;
</pre>
<hr />
<pre>
1132             int inLen = conContext.inputRecord.bytesInCompletePacket();
1133             if (inLen &lt; 0) {    // EOF
1134                 handleEOF(null);
1135 
1136                 // if no exception thrown
1137                 return null;
1138             }
1139 
1140             // Is this packet bigger than SSL/TLS normally allows?
1141             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1142                 throw new SSLProtocolException(
1143                         &quot;Illegal packet size: &quot; + inLen);
1144             }
1145 
1146             if (inLen &gt; buffer.remaining()) {
1147                 buffer = ByteBuffer.allocate(inLen);
1148             }
1149 
1150             try {
1151                 Plaintext plainText;
<span class="line-modified">1152                 synchronized (this) {</span>

1153                     plainText = decode(buffer);


1154                 }
1155                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1156                         buffer.position() &gt; 0) {
1157                     return buffer;
1158                 }
1159             } catch (SSLException ssle) {
1160                 throw ssle;
1161             } catch (IOException ioe) {
1162                 if (!(ioe instanceof SSLException)) {
1163                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1164                 } else {
1165                     throw ioe;
1166                 }
1167             }
1168         }
1169 
1170         //
1171         // couldn&#39;t read, due to some kind of error
1172         //
1173         return null;
</pre>
<hr />
<pre>
1207      *
1208      * As we request renegotiation or close the connection for wrapped sequence
1209      * number when there is enough sequence number space left to handle a few
1210      * more records, so the sequence number of the last record cannot be
1211      * wrapped.
1212      */
1213     private void tryKeyUpdate() throws IOException {
1214         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1215         // connection is not duplex-open.
1216         if ((conContext.handshakeContext == null) &amp;&amp;
1217                 !conContext.isOutboundClosed() &amp;&amp;
1218                 !conContext.isInboundClosed() &amp;&amp;
1219                 !conContext.isBroken) {
1220             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1221                 SSLLogger.finest(&quot;trigger key update&quot;);
1222             }
1223             startHandshake();
1224         }
1225     }
1226 



















1227     /**
1228      * Initialize the handshaker and socket streams.
1229      *
1230      * Called by connect, the layered constructor, and SSLServerSocket.
1231      */
<span class="line-modified">1232     synchronized void doneConnect() throws IOException {</span>
<span class="line-modified">1233         // In server mode, it is not necessary to set host and serverNames.</span>
<span class="line-modified">1234         // Otherwise, would require a reverse DNS lookup to get the hostname.</span>
<span class="line-modified">1235         if (peerHost == null || peerHost.isEmpty()) {</span>
<span class="line-modified">1236             boolean useNameService =</span>
<span class="line-modified">1237                     trustNameService &amp;&amp; conContext.sslConfig.isClientMode;</span>
<span class="line-modified">1238             useImplicitHost(useNameService);</span>
<span class="line-modified">1239         } else {</span>
<span class="line-modified">1240             conContext.sslConfig.serverNames =</span>
<span class="line-modified">1241                     Utilities.addToSNIServerNameList(</span>
<span class="line-modified">1242                             conContext.sslConfig.serverNames, peerHost);</span>
<span class="line-modified">1243         }</span>



1244 
<span class="line-modified">1245         InputStream sockInput = super.getInputStream();</span>
<span class="line-modified">1246         conContext.inputRecord.setReceiverStream(sockInput);</span>
1247 
<span class="line-modified">1248         OutputStream sockOutput = super.getOutputStream();</span>
<span class="line-modified">1249         conContext.inputRecord.setDeliverStream(sockOutput);</span>
<span class="line-modified">1250         conContext.outputRecord.setDeliverStream(sockOutput);</span>
1251 
<span class="line-modified">1252         this.isConnected = true;</span>



1253     }
1254 
1255     private void useImplicitHost(boolean useNameService) {
1256         // Note: If the local name service is not trustworthy, reverse
1257         // host name resolution should not be performed for endpoint
1258         // identification.  Use the application original specified
1259         // hostname or IP address instead.
1260 
1261         // Get the original hostname via jdk.internal.access.SharedSecrets
1262         InetAddress inetAddress = getInetAddress();
1263         if (inetAddress == null) {      // not connected
1264             return;
1265         }
1266 
1267         JavaNetInetAddressAccess jna =
1268                 SharedSecrets.getJavaNetInetAddressAccess();
1269         String originalHostname = jna.getOriginalHostName(inetAddress);
1270         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1271 
1272             this.peerHost = originalHostname;
</pre>
<hr />
<pre>
1278             }
1279 
1280             return;
1281         }
1282 
1283         // No explicitly specified hostname, no server name indication.
1284         if (!useNameService) {
1285             // The local name service is not trustworthy, use IP address.
1286             this.peerHost = inetAddress.getHostAddress();
1287         } else {
1288             // Use the underlying reverse host name resolution service.
1289             this.peerHost = getInetAddress().getHostName();
1290         }
1291     }
1292 
1293     // ONLY used by HttpsClient to setup the URI specified hostname
1294     //
1295     // Please NOTE that this method MUST be called before calling to
1296     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1297     // may override SNIHostName in the customized server name indication.
<span class="line-modified">1298     public synchronized void setHost(String host) {</span>
<span class="line-modified">1299         this.peerHost = host;</span>
<span class="line-modified">1300         this.conContext.sslConfig.serverNames =</span>
<span class="line-modified">1301                 Utilities.addToSNIServerNameList(</span>
<span class="line-modified">1302                         conContext.sslConfig.serverNames, host);</span>





1303     }
1304 
1305     /**
1306      * Handle an exception.
1307      *
1308      * This method is called by top level exception handlers (in read(),
1309      * write()) to make sure we always shutdown the connection correctly
1310      * and do not pass runtime exception to the application.
1311      *
1312      * This method never returns normally, it always throws an IOException.
1313      */
1314     private void handleException(Exception cause) throws IOException {
1315         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1316             SSLLogger.warning(&quot;handling exception&quot;, cause);
1317         }
1318 
1319         // Don&#39;t close the Socket in case of timeouts or interrupts.
1320         if (cause instanceof InterruptedIOException) {
1321             throw (IOException)cause;
1322         }
</pre>
</td>
<td>
<hr />
<pre>
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.EOFException;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InterruptedIOException;
  32 import java.io.OutputStream;
  33 import java.net.InetAddress;
  34 import java.net.InetSocketAddress;
  35 import java.net.Socket;
  36 import java.net.SocketAddress;
  37 import java.net.SocketException;
  38 import java.net.UnknownHostException;
  39 import java.nio.ByteBuffer;
  40 import java.util.List;
<span class="line-added">  41 import java.util.concurrent.TimeUnit;</span>
<span class="line-added">  42 import java.util.concurrent.locks.ReentrantLock;</span>
  43 import java.util.function.BiFunction;
  44 import javax.net.ssl.HandshakeCompletedListener;
  45 import javax.net.ssl.SSLException;
  46 import javax.net.ssl.SSLHandshakeException;
  47 import javax.net.ssl.SSLParameters;
  48 import javax.net.ssl.SSLProtocolException;
  49 import javax.net.ssl.SSLServerSocket;
  50 import javax.net.ssl.SSLSession;
  51 import javax.net.ssl.SSLSocket;
  52 import jdk.internal.access.JavaNetInetAddressAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 
  55 /**
  56  * Implementation of an SSL socket.
  57  * &lt;P&gt;
  58  * This is a normal connection type socket, implementing SSL over some lower
  59  * level socket, such as TCP.  Because it is layered over some lower level
  60  * socket, it MUST override all default socket methods.
  61  * &lt;P&gt;
  62  * This API offers a non-traditional option for establishing SSL
</pre>
<hr />
<pre>
  69  *
  70  * @see javax.net.ssl.SSLSocket
  71  * @see SSLServerSocket
  72  *
  73  * @author David Brownell
  74  */
  75 public final class SSLSocketImpl
  76         extends BaseSSLSocketImpl implements SSLTransport {
  77 
  78     final SSLContextImpl            sslContext;
  79     final TransportContext          conContext;
  80 
  81     private final AppInputStream    appInput = new AppInputStream();
  82     private final AppOutputStream   appOutput = new AppOutputStream();
  83 
  84     private String                  peerHost;
  85     private boolean                 autoClose;
  86     private boolean                 isConnected = false;
  87     private volatile boolean        tlsIsClosed = false;
  88 
<span class="line-added">  89     private final ReentrantLock     socketLock = new ReentrantLock();</span>
<span class="line-added">  90     private final ReentrantLock     handshakeLock = new ReentrantLock();</span>
<span class="line-added">  91 </span>
  92     /*
  93      * Is the local name service trustworthy?
  94      *
  95      * If the local name service is not trustworthy, reverse host name
  96      * resolution should not be performed for endpoint identification.
  97      */
  98     private static final boolean trustNameService =
  99             Utilities.getBooleanProperty(&quot;jdk.tls.trustNameService&quot;, false);
 100 
 101     /**
 102      * Package-private constructor used to instantiate an unconnected
 103      * socket.
 104      *
 105      * This instance is meant to set handshake state to use &quot;client mode&quot;.
 106      */
 107     SSLSocketImpl(SSLContextImpl sslContext) {
 108         super();
 109         this.sslContext = sslContext;
 110         HandshakeHash handshakeHash = new HandshakeHash();
 111         this.conContext = new TransportContext(sslContext, this,
</pre>
<hr />
<pre>
 280 
 281         if (isLayered()) {
 282             throw new SocketException(&quot;Already connected&quot;);
 283         }
 284 
 285         if (!(endpoint instanceof InetSocketAddress)) {
 286             throw new SocketException(
 287                     &quot;Cannot handle non-Inet socket addresses.&quot;);
 288         }
 289 
 290         super.connect(endpoint, timeout);
 291         doneConnect();
 292     }
 293 
 294     @Override
 295     public String[] getSupportedCipherSuites() {
 296         return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
 297     }
 298 
 299     @Override
<span class="line-modified"> 300     public String[] getEnabledCipherSuites() {</span>
<span class="line-modified"> 301         socketLock.lock();</span>
<span class="line-added"> 302         try {</span>
<span class="line-added"> 303             return CipherSuite.namesOf(</span>
<span class="line-added"> 304                     conContext.sslConfig.enabledCipherSuites);</span>
<span class="line-added"> 305         } finally {</span>
<span class="line-added"> 306             socketLock.unlock();</span>
<span class="line-added"> 307         }</span>
 308     }
 309 
 310     @Override
<span class="line-modified"> 311     public void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified"> 312         socketLock.lock();</span>
<span class="line-modified"> 313         try {</span>
<span class="line-added"> 314             conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-added"> 315                     CipherSuite.validValuesOf(suites);</span>
<span class="line-added"> 316         } finally {</span>
<span class="line-added"> 317             socketLock.unlock();</span>
<span class="line-added"> 318         }</span>
 319     }
 320 
 321     @Override
 322     public String[] getSupportedProtocols() {
 323         return ProtocolVersion.toStringArray(
 324                 sslContext.getSupportedProtocolVersions());
 325     }
 326 
 327     @Override
<span class="line-modified"> 328     public String[] getEnabledProtocols() {</span>
<span class="line-modified"> 329         socketLock.lock();</span>
<span class="line-modified"> 330         try {</span>
<span class="line-added"> 331             return ProtocolVersion.toStringArray(</span>
<span class="line-added"> 332                     conContext.sslConfig.enabledProtocols);</span>
<span class="line-added"> 333         } finally {</span>
<span class="line-added"> 334             socketLock.unlock();</span>
<span class="line-added"> 335         }</span>
 336     }
 337 
 338     @Override
<span class="line-modified"> 339     public void setEnabledProtocols(String[] protocols) {</span>
 340         if (protocols == null) {
 341             throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
 342         }
 343 
<span class="line-modified"> 344         socketLock.lock();</span>
<span class="line-modified"> 345         try {</span>
<span class="line-added"> 346             conContext.sslConfig.enabledProtocols =</span>
<span class="line-added"> 347                     ProtocolVersion.namesOf(protocols);</span>
<span class="line-added"> 348         } finally {</span>
<span class="line-added"> 349             socketLock.unlock();</span>
<span class="line-added"> 350         }</span>
 351     }
 352 
 353     @Override
 354     public SSLSession getSession() {
 355         try {
 356             // start handshaking, if failed, the connection will be closed.
 357             ensureNegotiated();
 358         } catch (IOException ioe) {
 359             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 360                 SSLLogger.severe(&quot;handshake failed&quot;, ioe);
 361             }
 362 
 363             return SSLSessionImpl.nullSession;
 364         }
 365 
 366         return conContext.conSession;
 367     }
 368 
 369     @Override
<span class="line-modified"> 370     public SSLSession getHandshakeSession() {</span>
<span class="line-modified"> 371         socketLock.lock();</span>
<span class="line-modified"> 372         try {</span>
<span class="line-modified"> 373             return conContext.handshakeContext == null ?</span>
<span class="line-modified"> 374                     null : conContext.handshakeContext.handshakeSession;</span>
<span class="line-modified"> 375         } finally {</span>
<span class="line-modified"> 376             socketLock.unlock();</span>
 377         }


 378     }
 379 
 380     @Override
<span class="line-modified"> 381     public void addHandshakeCompletedListener(</span>
 382             HandshakeCompletedListener listener) {
 383         if (listener == null) {
 384             throw new IllegalArgumentException(&quot;listener is null&quot;);
 385         }
 386 
<span class="line-modified"> 387         socketLock.lock();</span>
<span class="line-added"> 388         try {</span>
<span class="line-added"> 389             conContext.sslConfig.addHandshakeCompletedListener(listener);</span>
<span class="line-added"> 390         } finally {</span>
<span class="line-added"> 391             socketLock.unlock();</span>
<span class="line-added"> 392         }</span>
 393     }
 394 
 395     @Override
<span class="line-modified"> 396     public void removeHandshakeCompletedListener(</span>
 397             HandshakeCompletedListener listener) {
 398         if (listener == null) {
 399             throw new IllegalArgumentException(&quot;listener is null&quot;);
 400         }
 401 
<span class="line-modified"> 402         socketLock.lock();</span>
<span class="line-added"> 403         try {</span>
<span class="line-added"> 404             conContext.sslConfig.removeHandshakeCompletedListener(listener);</span>
<span class="line-added"> 405         } finally {</span>
<span class="line-added"> 406             socketLock.unlock();</span>
<span class="line-added"> 407         }</span>
 408     }
 409 
 410     @Override
 411     public void startHandshake() throws IOException {
 412         if (!isConnected) {
 413             throw new SocketException(&quot;Socket is not connected&quot;);
 414         }
 415 
 416         if (conContext.isBroken || conContext.isInboundClosed() ||
 417                 conContext.isOutboundClosed()) {
 418             throw new SocketException(&quot;Socket has been closed or broken&quot;);
 419         }
 420 
<span class="line-modified"> 421         handshakeLock.lock();</span>
<span class="line-added"> 422         try {</span>
 423             // double check the context status
 424             if (conContext.isBroken || conContext.isInboundClosed() ||
 425                     conContext.isOutboundClosed()) {
 426                 throw new SocketException(&quot;Socket has been closed or broken&quot;);
 427             }
 428 
 429             try {
 430                 conContext.kickstart();
 431 
 432                 // All initial handshaking goes through this operation until we
 433                 // have a valid SSL connection.
 434                 //
 435                 // Handle handshake messages only, need no application data.
 436                 if (!conContext.isNegotiated) {
 437                     readHandshakeRecord();
 438                 }
 439             } catch (IOException ioe) {
 440                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
 441                     &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
 442             } catch (Exception oe) {    // including RuntimeException
 443                 handleException(oe);
 444             }
<span class="line-added"> 445         } finally {</span>
<span class="line-added"> 446             handshakeLock.unlock();</span>
 447         }
 448     }
 449 
 450     @Override
<span class="line-modified"> 451     public void setUseClientMode(boolean mode) {</span>
<span class="line-modified"> 452         socketLock.lock();</span>
<span class="line-added"> 453         try {</span>
<span class="line-added"> 454             conContext.setUseClientMode(mode);</span>
<span class="line-added"> 455         } finally {</span>
<span class="line-added"> 456             socketLock.unlock();</span>
<span class="line-added"> 457         }</span>
 458     }
 459 
 460     @Override
<span class="line-modified"> 461     public boolean getUseClientMode() {</span>
<span class="line-modified"> 462         socketLock.lock();</span>
<span class="line-added"> 463         try {</span>
<span class="line-added"> 464             return conContext.sslConfig.isClientMode;</span>
<span class="line-added"> 465         } finally {</span>
<span class="line-added"> 466             socketLock.unlock();</span>
<span class="line-added"> 467         }</span>
 468     }
 469 
 470     @Override
<span class="line-modified"> 471     public void setNeedClientAuth(boolean need) {</span>
<span class="line-modified"> 472         socketLock.lock();</span>
<span class="line-modified"> 473         try {</span>
<span class="line-modified"> 474             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 475                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-added"> 476                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 477         } finally {</span>
<span class="line-added"> 478             socketLock.unlock();</span>
<span class="line-added"> 479         }</span>
 480     }
 481 
 482     @Override
<span class="line-modified"> 483     public boolean getNeedClientAuth() {</span>
<span class="line-modified"> 484         socketLock.lock();</span>
<span class="line-added"> 485         try {</span>
<span class="line-added"> 486             return (conContext.sslConfig.clientAuthType ==</span>
 487                         ClientAuthType.CLIENT_AUTH_REQUIRED);
<span class="line-added"> 488         } finally {</span>
<span class="line-added"> 489             socketLock.unlock();</span>
<span class="line-added"> 490         }</span>
 491     }
 492 
 493     @Override
<span class="line-modified"> 494     public void setWantClientAuth(boolean want) {</span>
<span class="line-modified"> 495         socketLock.lock();</span>
<span class="line-modified"> 496         try {</span>
<span class="line-modified"> 497             conContext.sslConfig.clientAuthType =</span>
<span class="line-added"> 498                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-added"> 499                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added"> 500         } finally {</span>
<span class="line-added"> 501             socketLock.unlock();</span>
<span class="line-added"> 502         }</span>
 503     }
 504 
 505     @Override
<span class="line-modified"> 506     public boolean getWantClientAuth() {</span>
<span class="line-modified"> 507         socketLock.lock();</span>
<span class="line-added"> 508         try {</span>
<span class="line-added"> 509             return (conContext.sslConfig.clientAuthType ==</span>
 510                         ClientAuthType.CLIENT_AUTH_REQUESTED);
<span class="line-added"> 511         } finally {</span>
<span class="line-added"> 512             socketLock.unlock();</span>
<span class="line-added"> 513         }</span>
 514     }
 515 
 516     @Override
<span class="line-modified"> 517     public void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified"> 518         socketLock.lock();</span>
<span class="line-added"> 519         try {</span>
<span class="line-added"> 520             conContext.sslConfig.enableSessionCreation = flag;</span>
<span class="line-added"> 521         } finally {</span>
<span class="line-added"> 522             socketLock.unlock();</span>
<span class="line-added"> 523         }</span>
 524     }
 525 
 526     @Override
<span class="line-modified"> 527     public boolean getEnableSessionCreation() {</span>
<span class="line-modified"> 528         socketLock.lock();</span>
<span class="line-added"> 529         try {</span>
<span class="line-added"> 530             return conContext.sslConfig.enableSessionCreation;</span>
<span class="line-added"> 531         } finally {</span>
<span class="line-added"> 532             socketLock.unlock();</span>
<span class="line-added"> 533         }</span>
 534     }
 535 
 536     @Override
 537     public boolean isClosed() {
 538         return tlsIsClosed;
 539     }
 540 
 541     // Please don&#39;t synchronized this method.  Otherwise, the read and close
 542     // locks may be deadlocked.
 543     @Override
 544     public void close() throws IOException {
 545         if (tlsIsClosed) {
 546             return;
 547         }
 548 
 549         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 550             SSLLogger.fine(&quot;duplex close of SSLSocket&quot;);
 551         }
 552 
 553         try {
</pre>
<hr />
<pre>
 602         if (conContext.isNegotiated) {
 603             if (!conContext.protocolVersion.useTLS13PlusSpec()) {
 604                 hasCloseReceipt = true;
 605             } else {
 606                 // Use a user_canceled alert for TLS 1.3 duplex close.
 607                 useUserCanceled = true;
 608             }
 609         } else if (conContext.handshakeContext != null) {   // initial handshake
 610             // Use user_canceled alert regardless the protocol versions.
 611             useUserCanceled = true;
 612 
 613             // The protocol version may have been negotiated.
 614             ProtocolVersion pv = conContext.handshakeContext.negotiatedProtocol;
 615             if (pv == null || (!pv.useTLS13PlusSpec())) {
 616                 hasCloseReceipt = true;
 617             }
 618         }
 619 
 620         // Need a lock here so that the user_canceled alert and the
 621         // close_notify alert can be delivered together.
<span class="line-modified"> 622         int linger = getSoLinger();</span>
<span class="line-modified"> 623         if (linger &gt;= 0) {</span>
<span class="line-modified"> 624             // don&#39;t wait more than SO_LINGER for obtaining the</span>
<span class="line-modified"> 625             // the lock.</span>
<span class="line-modified"> 626             //</span>
<span class="line-added"> 627             // keep and clear the current thread interruption status.</span>
<span class="line-added"> 628             boolean interrupted = Thread.interrupted();</span>
<span class="line-added"> 629             try {</span>
<span class="line-added"> 630                 if (conContext.outputRecord.recordLock.tryLock() ||</span>
<span class="line-added"> 631                         conContext.outputRecord.recordLock.tryLock(</span>
<span class="line-added"> 632                                 linger, TimeUnit.SECONDS)) {</span>
<span class="line-added"> 633                     try {</span>
<span class="line-added"> 634                         handleClosedNotifyAlert(useUserCanceled);</span>
<span class="line-added"> 635                     } finally {</span>
<span class="line-added"> 636                         conContext.outputRecord.recordLock.unlock();</span>
<span class="line-added"> 637                     }</span>
<span class="line-added"> 638                 } else {</span>
<span class="line-added"> 639                     // For layered, non-autoclose sockets, we are not</span>
<span class="line-added"> 640                     // able to bring them into a usable state, so we</span>
<span class="line-added"> 641                     // treat it as fatal error.</span>
<span class="line-added"> 642                     if (!super.isOutputShutdown()) {</span>
<span class="line-added"> 643                         if (isLayered() &amp;&amp; !autoClose) {</span>
<span class="line-added"> 644                             throw new SSLException(</span>
<span class="line-added"> 645                                     &quot;SO_LINGER timeout, &quot; +</span>
<span class="line-added"> 646                                     &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added"> 647                         } else {</span>
<span class="line-added"> 648                             super.shutdownOutput();</span>
<span class="line-added"> 649                             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 650                                 SSLLogger.warning(</span>
<span class="line-added"> 651                                     &quot;SSLSocket output duplex close failed: &quot; +</span>
<span class="line-added"> 652                                     &quot;SO_LINGER timeout, &quot; +</span>
<span class="line-added"> 653                                     &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added"> 654                             }</span>
<span class="line-added"> 655                         }</span>
<span class="line-added"> 656                     }</span>
<span class="line-added"> 657 </span>
<span class="line-added"> 658                     // RFC2246 requires that the session becomes</span>
<span class="line-added"> 659                     // unresumable if any connection is terminated</span>
<span class="line-added"> 660                     // without proper close_notify messages with</span>
<span class="line-added"> 661                     // level equal to warning.</span>
<span class="line-added"> 662                     //</span>
<span class="line-added"> 663                     // RFC4346 no longer requires that a session not be</span>
<span class="line-added"> 664                     // resumed if failure to properly close a connection.</span>
<span class="line-added"> 665                     //</span>
<span class="line-added"> 666                     // We choose to make the session unresumable if</span>
<span class="line-added"> 667                     // failed to send the close_notify message.</span>
<span class="line-added"> 668                     //</span>
<span class="line-added"> 669                     conContext.conSession.invalidate();</span>
<span class="line-added"> 670                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 671                         SSLLogger.warning(</span>
<span class="line-added"> 672                                 &quot;Invalidate the session: SO_LINGER timeout, &quot; +</span>
<span class="line-added"> 673                                 &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added"> 674                     }</span>
 675                 }
<span class="line-added"> 676             } catch (InterruptedException ex) {</span>
<span class="line-added"> 677                 // keep interrupted status</span>
<span class="line-added"> 678                 interrupted = true;</span>
<span class="line-added"> 679             }</span>
<span class="line-added"> 680 </span>
<span class="line-added"> 681             // restore the interrupted status</span>
<span class="line-added"> 682             if (interrupted) {</span>
<span class="line-added"> 683                 Thread.currentThread().interrupt();</span>
<span class="line-added"> 684             }</span>
<span class="line-added"> 685         } else {</span>
<span class="line-added"> 686             conContext.outputRecord.recordLock.lock();</span>
<span class="line-added"> 687             try {</span>
<span class="line-added"> 688                 handleClosedNotifyAlert(useUserCanceled);</span>
<span class="line-added"> 689             } finally {</span>
<span class="line-added"> 690                 conContext.outputRecord.recordLock.unlock();</span>
<span class="line-added"> 691             }</span>
<span class="line-added"> 692         }</span>
 693 
<span class="line-modified"> 694         if (!isInputShutdown()) {</span>
<span class="line-modified"> 695             bruteForceCloseInput(hasCloseReceipt);</span>
<span class="line-added"> 696         }</span>
<span class="line-added"> 697     }</span>
<span class="line-added"> 698 </span>
<span class="line-added"> 699     private void handleClosedNotifyAlert(</span>
<span class="line-added"> 700             boolean useUserCanceled) throws IOException {</span>
<span class="line-added"> 701         try {</span>
<span class="line-added"> 702             // send a user_canceled alert if needed.</span>
<span class="line-added"> 703             if (useUserCanceled) {</span>
<span class="line-added"> 704                 conContext.warning(Alert.USER_CANCELED);</span>
 705             }
<span class="line-added"> 706 </span>
<span class="line-added"> 707             // send a close_notify alert</span>
<span class="line-added"> 708             conContext.warning(Alert.CLOSE_NOTIFY);</span>
 709         } finally {
 710             if (!conContext.isOutboundClosed()) {
 711                 conContext.outputRecord.close();
 712             }
 713 
<span class="line-modified"> 714             if (!super.isOutputShutdown() &amp;&amp;</span>
<span class="line-added"> 715                     (autoClose || !isLayered())) {</span>
 716                 super.shutdownOutput();
 717             }
 718         }




 719     }
 720 
 721     /**
 722      * Duplex close, start from closing inbound.
 723      *
 724      * This method should only be called when the outbound has been closed,
 725      * but the inbound is still open.
 726      */
 727     private void duplexCloseInput() throws IOException {
 728         boolean hasCloseReceipt = false;
 729         if (conContext.isNegotiated &amp;&amp;
 730                 !conContext.protocolVersion.useTLS13PlusSpec()) {
 731             hasCloseReceipt = true;
 732         }   // No close receipt if handshake has no completed.
 733 
 734         bruteForceCloseInput(hasCloseReceipt);
 735     }
 736 
 737     /**
 738      * Brute force close the input bound.
</pre>
<hr />
<pre>
 822             return;
 823         }
 824 
 825         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 826             SSLLogger.fine(&quot;close outbound of SSLSocket&quot;);
 827         }
 828         conContext.closeOutbound();
 829 
 830         if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {
 831             super.shutdownOutput();
 832         }
 833     }
 834 
 835     @Override
 836     public boolean isOutputShutdown() {
 837         return conContext.isOutboundClosed() &amp;&amp;
 838                 ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
 839     }
 840 
 841     @Override
<span class="line-modified"> 842     public InputStream getInputStream() throws IOException {</span>
<span class="line-modified"> 843         socketLock.lock();</span>
<span class="line-modified"> 844         try {</span>
<span class="line-modified"> 845             if (isClosed()) {</span>
<span class="line-added"> 846                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added"> 847             }</span>
 848 
<span class="line-modified"> 849             if (!isConnected) {</span>
<span class="line-modified"> 850                 throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified"> 851             }</span>
 852 
<span class="line-modified"> 853             if (conContext.isInboundClosed() || isInputShutdown()) {</span>
<span class="line-modified"> 854                 throw new SocketException(&quot;Socket input is already shutdown&quot;);</span>
<span class="line-modified"> 855             }</span>
 856 
<span class="line-modified"> 857             return appInput;</span>
<span class="line-added"> 858         } finally {</span>
<span class="line-added"> 859             socketLock.unlock();</span>
<span class="line-added"> 860         }</span>
 861     }
 862 
 863     private void ensureNegotiated() throws IOException {
 864         if (conContext.isNegotiated || conContext.isBroken ||
 865                 conContext.isInboundClosed() || conContext.isOutboundClosed()) {
 866             return;
 867         }
 868 
<span class="line-modified"> 869         handshakeLock.lock();</span>
<span class="line-added"> 870         try {</span>
 871             // double check the context status
 872             if (conContext.isNegotiated || conContext.isBroken ||
 873                     conContext.isInboundClosed() ||
 874                     conContext.isOutboundClosed()) {
 875                 return;
 876             }
 877 
 878             startHandshake();
<span class="line-added"> 879         } finally {</span>
<span class="line-added"> 880             handshakeLock.unlock();</span>
 881         }
 882     }
 883 
 884     /**
 885      * InputStream for application data as returned by
 886      * SSLSocket.getInputStream().
 887      */
 888     private class AppInputStream extends InputStream {
 889         // One element array used to implement the single byte read() method
 890         private final byte[] oneByte = new byte[1];
 891 
 892         // the temporary buffer used to read network
 893         private ByteBuffer buffer;
 894 
 895         // Is application data available in the stream?
 896         private volatile boolean appDataIsAvailable;
 897 
<span class="line-added"> 898         // reading lock</span>
<span class="line-added"> 899         private final ReentrantLock readLock = new ReentrantLock();</span>
<span class="line-added"> 900 </span>
<span class="line-added"> 901         // closing status</span>
<span class="line-added"> 902         private volatile boolean isClosing;</span>
<span class="line-added"> 903         private volatile boolean hasDepleted;</span>
<span class="line-added"> 904 </span>
 905         AppInputStream() {
 906             this.appDataIsAvailable = false;
 907             this.buffer = ByteBuffer.allocate(4096);
 908         }
 909 
 910         /**
 911          * Return the minimum number of bytes that can be read
 912          * without blocking.
 913          */
 914         @Override
 915         public int available() throws IOException {
 916             // Currently not synchronized.
 917             if ((!appDataIsAvailable) || checkEOF()) {
 918                 return 0;
 919             }
 920 
 921             return buffer.remaining();
 922         }
 923 
 924         /**
</pre>
<hr />
<pre>
 930             if (n &lt;= 0) {   // EOF
 931                 return -1;
 932             }
 933 
 934             return oneByte[0] &amp; 0xFF;
 935         }
 936 
 937         /**
 938          * Reads up to {@code len} bytes of data from the input stream
 939          * into an array of bytes.
 940          *
 941          * An attempt is made to read as many as {@code len} bytes, but a
 942          * smaller number may be read. The number of bytes actually read
 943          * is returned as an integer.
 944          *
 945          * If the layer above needs more data, it asks for more, so we
 946          * are responsible only for blocking to fill at most one buffer,
 947          * and returning &quot;-1&quot; on non-fault EOF status.
 948          */
 949         @Override
<span class="line-modified"> 950         public int read(byte[] b, int off, int len) throws IOException {</span>

 951             if (b == null) {
 952                 throw new NullPointerException(&quot;the target buffer is null&quot;);
 953             } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
 954                 throw new IndexOutOfBoundsException(
 955                         &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
 956                         &quot;, bytes to read:&quot; + len);
 957             } else if (len == 0) {
 958                 return 0;
 959             }
 960 
 961             if (checkEOF()) {
 962                 return -1;
 963             }
 964 
 965             // start handshaking if the connection has not been negotiated.
 966             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
 967                     !conContext.isInboundClosed() &amp;&amp;
 968                     !conContext.isOutboundClosed()) {
 969                 ensureNegotiated();
 970             }
 971 
 972             // Check if the Socket is invalid (error or closed).
 973             if (!conContext.isNegotiated ||
 974                     conContext.isBroken || conContext.isInboundClosed()) {
 975                 throw new SocketException(&quot;Connection or inbound has closed&quot;);
 976             }
 977 
<span class="line-added"> 978             // Check if the input stream has been depleted.</span>
<span class="line-added"> 979             //</span>
<span class="line-added"> 980             // Note that the &quot;hasDepleted&quot; rather than the isClosing</span>
<span class="line-added"> 981             // filed is checked here, in case the closing process is</span>
<span class="line-added"> 982             // still in progress.</span>
<span class="line-added"> 983             if (hasDepleted) {</span>
<span class="line-added"> 984                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added"> 985                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);</span>
<span class="line-added"> 986                 }</span>
<span class="line-added"> 987 </span>
<span class="line-added"> 988                 return -1;</span>
<span class="line-added"> 989             }</span>
<span class="line-added"> 990 </span>
 991             // Read the available bytes at first.
 992             //
 993             // Note that the receiving and processing of post-handshake message
 994             // are also synchronized with the read lock.
<span class="line-modified"> 995             readLock.lock();</span>
<span class="line-added"> 996             try {</span>
<span class="line-added"> 997                 // Double check if the Socket is invalid (error or closed).</span>
<span class="line-added"> 998                 if (conContext.isBroken || conContext.isInboundClosed()) {</span>
<span class="line-added"> 999                     throw new SocketException(</span>
<span class="line-added">1000                             &quot;Connection or inbound has closed&quot;);</span>
<span class="line-added">1001                 }</span>
<span class="line-added">1002 </span>
<span class="line-added">1003                 // Double check if the input stream has been depleted.</span>
<span class="line-added">1004                 if (hasDepleted) {</span>
<span class="line-added">1005                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">1006                         SSLLogger.fine(&quot;The input stream is closing&quot;);</span>
<span class="line-added">1007                     }</span>
<span class="line-added">1008 </span>
<span class="line-added">1009                     return -1;</span>
<span class="line-added">1010                 }</span>
<span class="line-added">1011 </span>
1012                 int remains = available();
1013                 if (remains &gt; 0) {
1014                     int howmany = Math.min(remains, len);
1015                     buffer.get(b, off, howmany);
1016 
1017                     return howmany;
1018                 }
1019 
1020                 appDataIsAvailable = false;
1021                 try {
1022                     ByteBuffer bb = readApplicationRecord(buffer);
1023                     if (bb == null) {   // EOF
1024                         return -1;
1025                     } else {
1026                         // The buffer may be reallocated for bigger capacity.
1027                         buffer = bb;
1028                     }
1029 
1030                     bb.flip();
1031                     int volume = Math.min(len, bb.remaining());
1032                     buffer.get(b, off, volume);
1033                     appDataIsAvailable = true;
1034 
1035                     return volume;
1036                 } catch (Exception e) {   // including RuntimeException
1037                     // shutdown and rethrow (wrapped) exception as appropriate
1038                     handleException(e);
1039 
1040                     // dummy for compiler
1041                     return -1;
1042                 }
<span class="line-added">1043             } finally {</span>
<span class="line-added">1044                 // Check if the input stream is closing.</span>
<span class="line-added">1045                 //</span>
<span class="line-added">1046                 // If the deplete() did not hold the lock, clean up the</span>
<span class="line-added">1047                 // input stream here.</span>
<span class="line-added">1048                 try {</span>
<span class="line-added">1049                     if (isClosing) {</span>
<span class="line-added">1050                         readLockedDeplete();</span>
<span class="line-added">1051                     }</span>
<span class="line-added">1052                 } finally {</span>
<span class="line-added">1053                     readLock.unlock();</span>
<span class="line-added">1054                 }</span>
1055             }
1056         }
1057 
1058         /**
1059          * Skip n bytes.
1060          *
1061          * This implementation is somewhat less efficient than possible, but
1062          * not badly so (redundant copy).  We reuse the read() code to keep
1063          * things simpler.
1064          */
1065         @Override
<span class="line-modified">1066         public long skip(long n) throws IOException {</span>
1067             // dummy array used to implement skip()
1068             byte[] skipArray = new byte[256];

1069             long skipped = 0;
<span class="line-modified">1070 </span>
<span class="line-modified">1071             readLock.lock();</span>
<span class="line-modified">1072             try {</span>
<span class="line-modified">1073                 while (n &gt; 0) {</span>
<span class="line-modified">1074                     int len = (int)Math.min(n, skipArray.length);</span>
<span class="line-added">1075                     int r = read(skipArray, 0, len);</span>
<span class="line-added">1076                     if (r &lt;= 0) {</span>
<span class="line-added">1077                         break;</span>
<span class="line-added">1078                     }</span>
<span class="line-added">1079                     n -= r;</span>
<span class="line-added">1080                     skipped += r;</span>
1081                 }
<span class="line-modified">1082             } finally {</span>
<span class="line-modified">1083                 readLock.unlock();</span>
1084             }
1085 
1086             return skipped;
1087         }
1088 
1089         @Override
1090         public void close() throws IOException {
1091             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1092                 SSLLogger.finest(&quot;Closing input stream&quot;);
1093             }
1094 
1095             try {
<span class="line-modified">1096                 SSLSocketImpl.this.close();</span>
1097             } catch (IOException ioe) {
1098                 // ignore the exception
1099                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1100                     SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
1101                 }
1102             }
1103         }
1104 
1105         /**
1106          * Return whether we have reached end-of-file.
1107          *
1108          * If the socket is not connected, has been shutdown because of an error
1109          * or has been closed, throw an Exception.
1110          */
1111         private boolean checkEOF() throws IOException {
1112             if (conContext.isInboundClosed()) {
1113                 return true;
1114             } else if (conContext.isInputCloseNotified || conContext.isBroken) {
1115                 if (conContext.closeReason == null) {
1116                     return true;
1117                 } else {
1118                     throw new SSLException(
1119                         &quot;Connection has closed: &quot; + conContext.closeReason,
1120                         conContext.closeReason);
1121                 }
1122             }
1123 
1124             return false;
1125         }
1126 
1127         /**
1128          * Try the best to use up the input records so as to close the
1129          * socket gracefully, without impact the performance too much.
1130          */
<span class="line-modified">1131         private void deplete() {</span>
<span class="line-modified">1132             if (conContext.isInboundClosed() || isClosing) {</span>
<span class="line-modified">1133                 return;</span>
<span class="line-modified">1134             }</span>

1135 
<span class="line-modified">1136             isClosing = true;</span>
<span class="line-modified">1137             if (readLock.tryLock()) {</span>
1138                 try {
<span class="line-modified">1139                     readLockedDeplete();</span>
<span class="line-modified">1140                 } finally {</span>
<span class="line-modified">1141                     readLock.unlock();</span>




1142                 }
1143             }
1144         }
<span class="line-added">1145 </span>
<span class="line-added">1146         /**</span>
<span class="line-added">1147          * Try to use up the input records.</span>
<span class="line-added">1148          *</span>
<span class="line-added">1149          * Please don&#39;t call this method unless the readLock is held by</span>
<span class="line-added">1150          * the current thread.</span>
<span class="line-added">1151          */</span>
<span class="line-added">1152         private void readLockedDeplete() {</span>
<span class="line-added">1153             // double check</span>
<span class="line-added">1154             if (hasDepleted || conContext.isInboundClosed()) {</span>
<span class="line-added">1155                 return;</span>
<span class="line-added">1156             }</span>
<span class="line-added">1157 </span>
<span class="line-added">1158             if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {</span>
<span class="line-added">1159                 return;</span>
<span class="line-added">1160             }</span>
<span class="line-added">1161 </span>
<span class="line-added">1162             SSLSocketInputRecord socketInputRecord =</span>
<span class="line-added">1163                     (SSLSocketInputRecord)conContext.inputRecord;</span>
<span class="line-added">1164             try {</span>
<span class="line-added">1165                 socketInputRecord.deplete(</span>
<span class="line-added">1166                     conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));</span>
<span class="line-added">1167             } catch (Exception ex) {</span>
<span class="line-added">1168                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">1169                     SSLLogger.warning(</span>
<span class="line-added">1170                         &quot;input stream close depletion failed&quot;, ex);</span>
<span class="line-added">1171                 }</span>
<span class="line-added">1172             } finally {</span>
<span class="line-added">1173                 hasDepleted = true;</span>
<span class="line-added">1174             }</span>
<span class="line-added">1175         }</span>
1176     }
1177 
1178     @Override
<span class="line-modified">1179     public OutputStream getOutputStream() throws IOException {</span>
<span class="line-modified">1180         socketLock.lock();</span>
<span class="line-modified">1181         try {</span>
<span class="line-modified">1182             if (isClosed()) {</span>
<span class="line-added">1183                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">1184             }</span>
1185 
<span class="line-modified">1186             if (!isConnected) {</span>
<span class="line-modified">1187                 throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified">1188             }</span>
1189 
<span class="line-modified">1190             if (conContext.isOutboundDone() || isOutputShutdown()) {</span>
<span class="line-modified">1191                 throw new SocketException(&quot;Socket output is already shutdown&quot;);</span>
<span class="line-modified">1192             }</span>
1193 
<span class="line-modified">1194             return appOutput;</span>
<span class="line-added">1195         } finally {</span>
<span class="line-added">1196             socketLock.unlock();</span>
<span class="line-added">1197         }</span>
1198     }
1199 
1200 
1201     /**
1202      * OutputStream for application data as returned by
1203      * SSLSocket.getOutputStream().
1204      */
1205     private class AppOutputStream extends OutputStream {
1206         // One element array used to implement the write(byte) method
1207         private final byte[] oneByte = new byte[1];
1208 
1209         @Override
1210         public void write(int i) throws IOException {
1211             oneByte[0] = (byte)i;
1212             write(oneByte, 0, 1);
1213         }
1214 
1215         @Override
1216         public void write(byte[] b,
1217                 int off, int len) throws IOException {
</pre>
<hr />
<pre>
1237             if (!conContext.isNegotiated &amp;&amp; !conContext.isBroken &amp;&amp;
1238                     !conContext.isInboundClosed() &amp;&amp;
1239                     !conContext.isOutboundClosed()) {
1240                 ensureNegotiated();
1241             }
1242 
1243             // Check if the Socket is invalid (error or closed).
1244             if (!conContext.isNegotiated ||
1245                     conContext.isBroken || conContext.isOutboundClosed()) {
1246                 throw new SocketException(&quot;Connection or outbound has closed&quot;);
1247             }
1248 
1249             //
1250 
1251             // Delegate the writing to the underlying socket.
1252             try {
1253                 conContext.outputRecord.deliver(b, off, len);
1254             } catch (SSLHandshakeException she) {
1255                 // may be record sequence number overflow
1256                 throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
<span class="line-modified">1257             } catch (SSLException ssle) {</span>
<span class="line-modified">1258                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);</span>
<span class="line-modified">1259             }   // re-throw other IOException, which should be caused by</span>
<span class="line-added">1260                 // the underlying plain socket and could be handled by</span>
<span class="line-added">1261                 // applications (for example, re-try the connection).</span>
1262 
1263             // Is the sequence number is nearly overflow, or has the key usage
1264             // limit been reached?
1265             if (conContext.outputRecord.seqNumIsHuge() ||
1266                     conContext.outputRecord.writeCipher.atKeyLimit()) {
1267                 tryKeyUpdate();
1268             }
<span class="line-added">1269             // Check if NewSessionTicket PostHandshake message needs to be sent</span>
<span class="line-added">1270             if (conContext.conSession.updateNST) {</span>
<span class="line-added">1271                 conContext.conSession.updateNST = false;</span>
<span class="line-added">1272                 tryNewSessionTicket();</span>
<span class="line-added">1273             }</span>
1274         }
1275 
1276         @Override
1277         public void close() throws IOException {
1278             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1279                 SSLLogger.finest(&quot;Closing output stream&quot;);
1280             }
1281 
1282             try {
<span class="line-modified">1283                 SSLSocketImpl.this.close();</span>
1284             } catch (IOException ioe) {
1285                 // ignore the exception
1286                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1287                     SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
1288                 }
1289             }
1290         }
1291     }
1292 
1293     @Override
<span class="line-modified">1294     public SSLParameters getSSLParameters() {</span>
<span class="line-modified">1295         socketLock.lock();</span>
<span class="line-added">1296         try {</span>
<span class="line-added">1297             return conContext.sslConfig.getSSLParameters();</span>
<span class="line-added">1298         } finally {</span>
<span class="line-added">1299             socketLock.unlock();</span>
<span class="line-added">1300         }</span>
1301     }
1302 
1303     @Override
<span class="line-modified">1304     public void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">1305         socketLock.lock();</span>
<span class="line-added">1306         try {</span>
<span class="line-added">1307             conContext.sslConfig.setSSLParameters(params);</span>
1308 
<span class="line-modified">1309             if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">1310                 conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">1311                         conContext.sslConfig.maximumPacketSize);</span>
<span class="line-added">1312             }</span>
<span class="line-added">1313         } finally {</span>
<span class="line-added">1314             socketLock.unlock();</span>
1315         }
1316     }
1317 
1318     @Override
<span class="line-modified">1319     public String getApplicationProtocol() {</span>
<span class="line-modified">1320         socketLock.lock();</span>
<span class="line-added">1321         try {</span>
<span class="line-added">1322             return conContext.applicationProtocol;</span>
<span class="line-added">1323         } finally {</span>
<span class="line-added">1324             socketLock.unlock();</span>
<span class="line-added">1325         }</span>
1326     }
1327 
1328     @Override
<span class="line-modified">1329     public String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">1330         socketLock.lock();</span>
<span class="line-modified">1331         try {</span>
<span class="line-added">1332             if (conContext.handshakeContext != null) {</span>
<span class="line-added">1333                 return conContext.handshakeContext.applicationProtocol;</span>
<span class="line-added">1334             }</span>
<span class="line-added">1335         } finally {</span>
<span class="line-added">1336             socketLock.unlock();</span>
1337         }
1338 
1339         return null;
1340     }
1341 
1342     @Override
<span class="line-modified">1343     public void setHandshakeApplicationProtocolSelector(</span>
1344             BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">1345         socketLock.lock();</span>
<span class="line-added">1346         try {</span>
<span class="line-added">1347             conContext.sslConfig.socketAPSelector = selector;</span>
<span class="line-added">1348         } finally {</span>
<span class="line-added">1349             socketLock.unlock();</span>
<span class="line-added">1350         }</span>
1351     }
1352 
1353     @Override
<span class="line-modified">1354     public BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;</span>
1355             getHandshakeApplicationProtocolSelector() {
<span class="line-modified">1356         socketLock.lock();</span>
<span class="line-added">1357         try {</span>
<span class="line-added">1358             return conContext.sslConfig.socketAPSelector;</span>
<span class="line-added">1359         } finally {</span>
<span class="line-added">1360             socketLock.unlock();</span>
<span class="line-added">1361         }</span>
1362     }
1363 
1364     /**
1365      * Read the initial handshake records.
1366      */
1367     private int readHandshakeRecord() throws IOException {
1368         while (!conContext.isInboundClosed()) {
1369             try {
1370                 Plaintext plainText = decode(null);
1371                 if ((plainText.contentType == ContentType.HANDSHAKE.id) &amp;&amp;
1372                         conContext.isNegotiated) {
1373                     return 0;
1374                 }
1375             } catch (SSLException ssle) {
1376                 throw ssle;
1377             } catch (IOException ioe) {
1378                 if (!(ioe instanceof SSLException)) {
1379                     throw new SSLException(&quot;readHandshakeRecord&quot;, ioe);
1380                 } else {
1381                     throw ioe;
</pre>
<hr />
<pre>
1411             int inLen = conContext.inputRecord.bytesInCompletePacket();
1412             if (inLen &lt; 0) {    // EOF
1413                 handleEOF(null);
1414 
1415                 // if no exception thrown
1416                 return null;
1417             }
1418 
1419             // Is this packet bigger than SSL/TLS normally allows?
1420             if (inLen &gt; SSLRecord.maxLargeRecordSize) {
1421                 throw new SSLProtocolException(
1422                         &quot;Illegal packet size: &quot; + inLen);
1423             }
1424 
1425             if (inLen &gt; buffer.remaining()) {
1426                 buffer = ByteBuffer.allocate(inLen);
1427             }
1428 
1429             try {
1430                 Plaintext plainText;
<span class="line-modified">1431                 socketLock.lock();</span>
<span class="line-added">1432                 try {</span>
1433                     plainText = decode(buffer);
<span class="line-added">1434                 } finally {</span>
<span class="line-added">1435                     socketLock.unlock();</span>
1436                 }
1437                 if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
1438                         buffer.position() &gt; 0) {
1439                     return buffer;
1440                 }
1441             } catch (SSLException ssle) {
1442                 throw ssle;
1443             } catch (IOException ioe) {
1444                 if (!(ioe instanceof SSLException)) {
1445                     throw new SSLException(&quot;readApplicationRecord&quot;, ioe);
1446                 } else {
1447                     throw ioe;
1448                 }
1449             }
1450         }
1451 
1452         //
1453         // couldn&#39;t read, due to some kind of error
1454         //
1455         return null;
</pre>
<hr />
<pre>
1489      *
1490      * As we request renegotiation or close the connection for wrapped sequence
1491      * number when there is enough sequence number space left to handle a few
1492      * more records, so the sequence number of the last record cannot be
1493      * wrapped.
1494      */
1495     private void tryKeyUpdate() throws IOException {
1496         // Don&#39;t bother to kickstart if handshaking is in progress, or if the
1497         // connection is not duplex-open.
1498         if ((conContext.handshakeContext == null) &amp;&amp;
1499                 !conContext.isOutboundClosed() &amp;&amp;
1500                 !conContext.isInboundClosed() &amp;&amp;
1501                 !conContext.isBroken) {
1502             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1503                 SSLLogger.finest(&quot;trigger key update&quot;);
1504             }
1505             startHandshake();
1506         }
1507     }
1508 
<span class="line-added">1509     // Try to generate a PostHandshake NewSessionTicket message.  This is</span>
<span class="line-added">1510     // TLS 1.3 only.</span>
<span class="line-added">1511     private void tryNewSessionTicket() throws IOException {</span>
<span class="line-added">1512         // Don&#39;t bother to kickstart if handshaking is in progress, or if the</span>
<span class="line-added">1513         // connection is not duplex-open.</span>
<span class="line-added">1514         if (!conContext.sslConfig.isClientMode &amp;&amp;</span>
<span class="line-added">1515                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">1516                 conContext.handshakeContext == null &amp;&amp;</span>
<span class="line-added">1517                 !conContext.isOutboundClosed() &amp;&amp;</span>
<span class="line-added">1518                 !conContext.isInboundClosed() &amp;&amp;</span>
<span class="line-added">1519                 !conContext.isBroken) {</span>
<span class="line-added">1520             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">1521                 SSLLogger.finest(&quot;trigger new session ticket&quot;);</span>
<span class="line-added">1522             }</span>
<span class="line-added">1523             NewSessionTicket.kickstartProducer.produce(</span>
<span class="line-added">1524                     new PostHandshakeContext(conContext));</span>
<span class="line-added">1525         }</span>
<span class="line-added">1526     }</span>
<span class="line-added">1527 </span>
1528     /**
1529      * Initialize the handshaker and socket streams.
1530      *
1531      * Called by connect, the layered constructor, and SSLServerSocket.
1532      */
<span class="line-modified">1533     void doneConnect() throws IOException {</span>
<span class="line-modified">1534         socketLock.lock();</span>
<span class="line-modified">1535         try {</span>
<span class="line-modified">1536             // In server mode, it is not necessary to set host and serverNames.</span>
<span class="line-modified">1537             // Otherwise, would require a reverse DNS lookup to get</span>
<span class="line-modified">1538             // the hostname.</span>
<span class="line-modified">1539             if (peerHost == null || peerHost.isEmpty()) {</span>
<span class="line-modified">1540                 boolean useNameService =</span>
<span class="line-modified">1541                         trustNameService &amp;&amp; conContext.sslConfig.isClientMode;</span>
<span class="line-modified">1542                 useImplicitHost(useNameService);</span>
<span class="line-modified">1543             } else {</span>
<span class="line-modified">1544                 conContext.sslConfig.serverNames =</span>
<span class="line-added">1545                         Utilities.addToSNIServerNameList(</span>
<span class="line-added">1546                                 conContext.sslConfig.serverNames, peerHost);</span>
<span class="line-added">1547             }</span>
1548 
<span class="line-modified">1549             InputStream sockInput = super.getInputStream();</span>
<span class="line-modified">1550             conContext.inputRecord.setReceiverStream(sockInput);</span>
1551 
<span class="line-modified">1552             OutputStream sockOutput = super.getOutputStream();</span>
<span class="line-modified">1553             conContext.inputRecord.setDeliverStream(sockOutput);</span>
<span class="line-modified">1554             conContext.outputRecord.setDeliverStream(sockOutput);</span>
1555 
<span class="line-modified">1556             this.isConnected = true;</span>
<span class="line-added">1557         } finally {</span>
<span class="line-added">1558             socketLock.unlock();</span>
<span class="line-added">1559         }</span>
1560     }
1561 
1562     private void useImplicitHost(boolean useNameService) {
1563         // Note: If the local name service is not trustworthy, reverse
1564         // host name resolution should not be performed for endpoint
1565         // identification.  Use the application original specified
1566         // hostname or IP address instead.
1567 
1568         // Get the original hostname via jdk.internal.access.SharedSecrets
1569         InetAddress inetAddress = getInetAddress();
1570         if (inetAddress == null) {      // not connected
1571             return;
1572         }
1573 
1574         JavaNetInetAddressAccess jna =
1575                 SharedSecrets.getJavaNetInetAddressAccess();
1576         String originalHostname = jna.getOriginalHostName(inetAddress);
1577         if (originalHostname != null &amp;&amp; !originalHostname.isEmpty()) {
1578 
1579             this.peerHost = originalHostname;
</pre>
<hr />
<pre>
1585             }
1586 
1587             return;
1588         }
1589 
1590         // No explicitly specified hostname, no server name indication.
1591         if (!useNameService) {
1592             // The local name service is not trustworthy, use IP address.
1593             this.peerHost = inetAddress.getHostAddress();
1594         } else {
1595             // Use the underlying reverse host name resolution service.
1596             this.peerHost = getInetAddress().getHostName();
1597         }
1598     }
1599 
1600     // ONLY used by HttpsClient to setup the URI specified hostname
1601     //
1602     // Please NOTE that this method MUST be called before calling to
1603     // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
1604     // may override SNIHostName in the customized server name indication.
<span class="line-modified">1605     public void setHost(String host) {</span>
<span class="line-modified">1606         socketLock.lock();</span>
<span class="line-modified">1607         try {</span>
<span class="line-modified">1608             this.peerHost = host;</span>
<span class="line-modified">1609             this.conContext.sslConfig.serverNames =</span>
<span class="line-added">1610                     Utilities.addToSNIServerNameList(</span>
<span class="line-added">1611                             conContext.sslConfig.serverNames, host);</span>
<span class="line-added">1612         } finally {</span>
<span class="line-added">1613             socketLock.unlock();</span>
<span class="line-added">1614         }</span>
1615     }
1616 
1617     /**
1618      * Handle an exception.
1619      *
1620      * This method is called by top level exception handlers (in read(),
1621      * write()) to make sure we always shutdown the connection correctly
1622      * and do not pass runtime exception to the application.
1623      *
1624      * This method never returns normally, it always throws an IOException.
1625      */
1626     private void handleException(Exception cause) throws IOException {
1627         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
1628             SSLLogger.warning(&quot;handling exception&quot;, cause);
1629         }
1630 
1631         // Don&#39;t close the Socket in case of timeouts or interrupts.
1632         if (cause instanceof InterruptedIOException) {
1633             throw (IOException)cause;
1634         }
</pre>
</td>
</tr>
</table>
<center><a href="SSLSessionImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketInputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
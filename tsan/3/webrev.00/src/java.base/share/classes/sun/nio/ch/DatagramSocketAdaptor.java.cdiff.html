<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramChannelImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,201 ***</span>
   */
  
  package sun.nio.ch;
  
  import java.io.IOException;
  import java.net.DatagramPacket;
  import java.net.DatagramSocket;
<span class="line-removed">- import java.net.DatagramSocketImpl;</span>
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.NetworkInterface;
  import java.net.SocketAddress;
  import java.net.SocketException;
  import java.net.SocketOption;
<span class="line-removed">- import java.net.SocketTimeoutException;</span>
  import java.net.StandardSocketOptions;
  import java.nio.ByteBuffer;
  import java.nio.channels.ClosedChannelException;
  import java.nio.channels.DatagramChannel;
<span class="line-modified">! import java.nio.channels.IllegalBlockingModeException;</span>
  import java.util.Objects;
  
  
<span class="line-modified">! // Make a datagram-socket channel look like a datagram socket.</span>
<span class="line-modified">! //</span>
<span class="line-modified">! // The methods in this class are defined in exactly the same order as in</span>
<span class="line-modified">! // java.net.DatagramSocket so as to simplify tracking future changes to that</span>
<span class="line-modified">! // class.</span>
<span class="line-modified">! //</span>
<span class="line-modified">! </span>
  public class DatagramSocketAdaptor
<span class="line-modified">!     extends DatagramSocket</span>
  {
      // The channel being adapted
      private final DatagramChannelImpl dc;
  
      // Timeout &quot;option&quot; value for receives
      private volatile int timeout;
  
<span class="line-removed">-     // ## super will create a useless impl</span>
      private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
<span class="line-modified">!         // Invoke the DatagramSocketAdaptor(SocketAddress) constructor,</span>
<span class="line-removed">-         // passing a dummy DatagramSocketImpl object to avoid any native</span>
<span class="line-removed">-         // resource allocation in super class and invoking our bind method</span>
<span class="line-removed">-         // before the dc field is initialized.</span>
<span class="line-removed">-         super(dummyDatagramSocket);</span>
          this.dc = dc;
      }
  
<span class="line-modified">!     public static DatagramSocket create(DatagramChannelImpl dc) {</span>
          try {
              return new DatagramSocketAdaptor(dc);
<span class="line-modified">!         } catch (IOException x) {</span>
<span class="line-modified">!             throw new Error(x);</span>
          }
      }
  
<span class="line-modified">!     private void connectInternal(SocketAddress remote)</span>
<span class="line-removed">-         throws SocketException</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         InetSocketAddress isa = Net.asInetSocketAddress(remote);</span>
<span class="line-removed">-         int port = isa.getPort();</span>
<span class="line-removed">-         if (port &lt; 0 || port &gt; 0xFFFF)</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
<span class="line-removed">-         if (remote == null)</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
          try {
<span class="line-modified">!             dc.connect(remote);</span>
          } catch (ClosedChannelException e) {
              // ignore
          } catch (Exception x) {
              Net.translateToSocketException(x);
          }
      }
  
      public void bind(SocketAddress local) throws SocketException {
          try {
<span class="line-removed">-             if (local == null)</span>
<span class="line-removed">-                 local = new InetSocketAddress(0);</span>
              dc.bind(local);
          } catch (Exception x) {
              Net.translateToSocketException(x);
          }
      }
  
      public void connect(InetAddress address, int port) {
          try {
              connectInternal(new InetSocketAddress(address, port));
          } catch (SocketException x) {
<span class="line-modified">!             // Yes, j.n.DatagramSocket really does this</span>
          }
      }
  
      public void connect(SocketAddress remote) throws SocketException {
<span class="line-modified">!         Objects.requireNonNull(remote, &quot;Address can&#39;t be null&quot;);</span>
<span class="line-modified">!         connectInternal(remote);</span>
      }
  
      public void disconnect() {
          try {
              dc.disconnect();
          } catch (IOException x) {
<span class="line-modified">!             throw new Error(x);</span>
          }
      }
  
      public boolean isBound() {
          return dc.localAddress() != null;
      }
  
      public boolean isConnected() {
          return dc.remoteAddress() != null;
      }
  
      public InetAddress getInetAddress() {
          InetSocketAddress remote = dc.remoteAddress();
          return (remote != null) ? remote.getAddress() : null;
      }
  
      public int getPort() {
          InetSocketAddress remote = dc.remoteAddress();
          return (remote != null) ? remote.getPort() : -1;
      }
  
<span class="line-modified">!     public void send(DatagramPacket p) throws IOException {</span>
<span class="line-modified">!         synchronized (dc.blockingLock()) {</span>
<span class="line-modified">!             if (!dc.isBlocking())</span>
<span class="line-removed">-                 throw new IllegalBlockingModeException();</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 synchronized (p) {</span>
<span class="line-removed">-                     ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="line-removed">-                                                     p.getOffset(),</span>
<span class="line-removed">-                                                     p.getLength());</span>
<span class="line-removed">-                     if (dc.isConnected()) {</span>
<span class="line-removed">-                         if (p.getAddress() == null) {</span>
<span class="line-removed">-                             // Legacy DatagramSocket will send in this case</span>
<span class="line-removed">-                             // and set address and port of the packet</span>
<span class="line-removed">-                             InetSocketAddress isa = dc.remoteAddress();</span>
<span class="line-removed">-                             p.setPort(isa.getPort());</span>
<span class="line-removed">-                             p.setAddress(isa.getAddress());</span>
<span class="line-removed">-                             dc.write(bb);</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             // Target address may not match connected address</span>
<span class="line-removed">-                             dc.send(bb, p.getSocketAddress());</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         // Not connected so address must be valid or throw</span>
<span class="line-removed">-                         dc.send(bb, p.getSocketAddress());</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } catch (IOException x) {</span>
<span class="line-removed">-                 Net.translateException(x);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     private SocketAddress receive(ByteBuffer bb) throws IOException {</span>
<span class="line-modified">!         assert Thread.holdsLock(dc.blockingLock()) &amp;&amp; dc.isBlocking();</span>
  
<span class="line-modified">!         long to = this.timeout;</span>
<span class="line-modified">!         if (to == 0) {</span>
<span class="line-modified">!             return dc.receive(bb);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             for (;;) {</span>
<span class="line-modified">!                 if (!dc.isOpen())</span>
<span class="line-modified">!                     throw new ClosedChannelException();</span>
<span class="line-modified">!                 long st = System.currentTimeMillis();</span>
<span class="line-modified">!                 if (dc.pollRead(to)) {</span>
<span class="line-modified">!                     return dc.receive(bb);</span>
                  }
<span class="line-modified">!                 to -= System.currentTimeMillis() - st;</span>
<span class="line-modified">!                 if (to &lt;= 0)</span>
<span class="line-modified">!                     throw new SocketTimeoutException();</span>
              }
          }
      }
  
      public void receive(DatagramPacket p) throws IOException {
<span class="line-modified">!         synchronized (dc.blockingLock()) {</span>
<span class="line-modified">!             if (!dc.isBlocking())</span>
<span class="line-modified">!                 throw new IllegalBlockingModeException();</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 synchronized (p) {</span>
<span class="line-modified">!                     ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="line-modified">!                                                     p.getOffset(),</span>
<span class="line-modified">!                                                     p.getLength());</span>
<span class="line-modified">!                     SocketAddress sender = receive(bb);</span>
<span class="line-modified">!                     p.setSocketAddress(sender);</span>
<span class="line-modified">!                     p.setLength(bb.position() - p.getOffset());</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } catch (IOException x) {</span>
<span class="line-modified">!                 Net.translateException(x);</span>
              }
          }
      }
  
      public InetAddress getLocalAddress() {
          if (isClosed())
              return null;
          InetSocketAddress local = dc.localAddress();
          if (local == null)
<span class="line-new-header">--- 24,232 ---</span>
   */
  
  package sun.nio.ch;
  
  import java.io.IOException;
<span class="line-added">+ import java.io.UncheckedIOException;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandle;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandles;</span>
<span class="line-added">+ import java.lang.invoke.MethodHandles.Lookup;</span>
<span class="line-added">+ import java.lang.invoke.MethodType;</span>
<span class="line-added">+ import java.lang.invoke.VarHandle;</span>
  import java.net.DatagramPacket;
  import java.net.DatagramSocket;
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.NetworkInterface;
<span class="line-added">+ import java.net.MulticastSocket;</span>
  import java.net.SocketAddress;
  import java.net.SocketException;
  import java.net.SocketOption;
  import java.net.StandardSocketOptions;
  import java.nio.ByteBuffer;
<span class="line-added">+ import java.nio.channels.AlreadyConnectedException;</span>
  import java.nio.channels.ClosedChannelException;
  import java.nio.channels.DatagramChannel;
<span class="line-modified">! import java.nio.channels.MembershipKey;</span>
<span class="line-added">+ import java.security.AccessController;</span>
<span class="line-added">+ import java.security.PrivilegedAction;</span>
<span class="line-added">+ import java.security.PrivilegedExceptionAction;</span>
  import java.util.Objects;
<span class="line-added">+ import java.util.Set;</span>
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  
<span class="line-added">+ import static java.util.concurrent.TimeUnit.MILLISECONDS;</span>
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * A multicast datagram socket based on a datagram channel.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This class overrides every public method defined by java.net.DatagramSocket</span>
<span class="line-modified">!  * and java.net.MulticastSocket. The methods in this class are defined in exactly</span>
<span class="line-modified">!  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so</span>
<span class="line-modified">!  * as to simplify tracking changes.</span>
<span class="line-added">+  */</span>
  public class DatagramSocketAdaptor
<span class="line-modified">!     extends MulticastSocket</span>
  {
      // The channel being adapted
      private final DatagramChannelImpl dc;
  
      // Timeout &quot;option&quot; value for receives
      private volatile int timeout;
  
      private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
<span class="line-modified">!         super(/*SocketAddress*/null);</span>
          this.dc = dc;
      }
  
<span class="line-modified">!     static DatagramSocket create(DatagramChannelImpl dc) {</span>
          try {
              return new DatagramSocketAdaptor(dc);
<span class="line-modified">!         } catch (IOException e) {</span>
<span class="line-modified">!             throw new Error(e);</span>
          }
      }
  
<span class="line-modified">!     private void connectInternal(SocketAddress remote) throws SocketException {</span>
          try {
<span class="line-modified">!             dc.connect(remote, false); // skips check for already connected</span>
          } catch (ClosedChannelException e) {
              // ignore
          } catch (Exception x) {
              Net.translateToSocketException(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public void bind(SocketAddress local) throws SocketException {
<span class="line-added">+         if (local != null) {</span>
<span class="line-added">+             local = Net.asInetSocketAddress(local);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             local = new InetSocketAddress(0);</span>
<span class="line-added">+         }</span>
          try {
              dc.bind(local);
          } catch (Exception x) {
              Net.translateToSocketException(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public void connect(InetAddress address, int port) {
<span class="line-added">+         if (address == null)</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
          try {
              connectInternal(new InetSocketAddress(address, port));
          } catch (SocketException x) {
<span class="line-modified">!             throw new UncheckedIOException(x);</span>
          }
      }
  
<span class="line-added">+     @Override</span>
      public void connect(SocketAddress remote) throws SocketException {
<span class="line-modified">!         if (remote == null)</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
<span class="line-added">+         connectInternal(Net.asInetSocketAddress(remote));</span>
      }
  
<span class="line-added">+     @Override</span>
      public void disconnect() {
          try {
              dc.disconnect();
          } catch (IOException x) {
<span class="line-modified">!             throw new UncheckedIOException(x);</span>
          }
      }
  
<span class="line-added">+     @Override</span>
      public boolean isBound() {
          return dc.localAddress() != null;
      }
  
<span class="line-added">+     @Override</span>
      public boolean isConnected() {
          return dc.remoteAddress() != null;
      }
  
<span class="line-added">+     @Override</span>
      public InetAddress getInetAddress() {
          InetSocketAddress remote = dc.remoteAddress();
          return (remote != null) ? remote.getAddress() : null;
      }
  
<span class="line-added">+     @Override</span>
      public int getPort() {
          InetSocketAddress remote = dc.remoteAddress();
          return (remote != null) ? remote.getPort() : -1;
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public SocketAddress getRemoteSocketAddress() {</span>
<span class="line-modified">!         return dc.remoteAddress();</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public SocketAddress getLocalSocketAddress() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return dc.getLocalAddress();</span>
<span class="line-added">+         } catch (ClosedChannelException e) {</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         } catch (Exception x) {</span>
<span class="line-added">+             throw new Error(x);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public void send(DatagramPacket p) throws IOException {</span>
<span class="line-modified">!         ByteBuffer bb = null;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             InetSocketAddress target;</span>
<span class="line-modified">!             synchronized (p) {</span>
<span class="line-modified">!                 // copy bytes to temporary direct buffer</span>
<span class="line-modified">!                 int len = p.getLength();</span>
<span class="line-modified">!                 bb = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">!                 bb.put(p.getData(), p.getOffset(), len);</span>
<span class="line-added">+                 bb.flip();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // target address</span>
<span class="line-added">+                 if (p.getAddress() == null) {</span>
<span class="line-added">+                     InetSocketAddress remote = dc.remoteAddress();</span>
<span class="line-added">+                     if (remote == null) {</span>
<span class="line-added">+                         // not specified by DatagramSocket</span>
<span class="line-added">+                         throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     // set address/port to maintain compatibility with DatagramSocket</span>
<span class="line-added">+                     p.setAddress(remote.getAddress());</span>
<span class="line-added">+                     p.setPort(remote.getPort());</span>
<span class="line-added">+                     target = remote;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // throws IllegalArgumentException if port not set</span>
<span class="line-added">+                     target = (InetSocketAddress) p.getSocketAddress();</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!             // send datagram</span>
<span class="line-modified">!             try {</span>
<span class="line-added">+                 dc.blockingSend(bb, target);</span>
<span class="line-added">+             } catch (AlreadyConnectedException e) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);</span>
<span class="line-added">+             } catch (ClosedChannelException e) {</span>
<span class="line-added">+                 var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">+                 exc.initCause(e);</span>
<span class="line-added">+                 throw exc;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             if (bb != null) {</span>
<span class="line-added">+                 Util.offerFirstTemporaryDirectBuffer(bb);</span>
              }
          }
      }
  
<span class="line-added">+     @Override</span>
      public void receive(DatagramPacket p) throws IOException {
<span class="line-modified">!         // get temporary direct buffer with a capacity of p.bufLength</span>
<span class="line-modified">!         int bufLength = DatagramPackets.getBufLength(p);</span>
<span class="line-modified">!         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-modified">!             SocketAddress sender = dc.blockingReceive(bb, nanos);</span>
<span class="line-modified">!             bb.flip();</span>
<span class="line-modified">!             synchronized (p) {</span>
<span class="line-modified">!                 // copy bytes to the DatagramPacket and set length</span>
<span class="line-modified">!                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));</span>
<span class="line-modified">!                 bb.get(p.getData(), p.getOffset(), len);</span>
<span class="line-modified">!                 DatagramPackets.setLength(p, len);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // sender address</span>
<span class="line-added">+                 p.setSocketAddress(sender);</span>
              }
<span class="line-added">+         } catch (ClosedChannelException e) {</span>
<span class="line-added">+             var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">+             exc.initCause(e);</span>
<span class="line-added">+             throw exc;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             Util.offerFirstTemporaryDirectBuffer(bb);</span>
          }
      }
  
<span class="line-added">+     @Override</span>
      public InetAddress getLocalAddress() {
          if (isClosed())
              return null;
          InetSocketAddress local = dc.localAddress();
          if (local == null)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,28 ***</span>
              }
          }
          return result;
      }
  
      public int getLocalPort() {
          if (isClosed())
              return -1;
<span class="line-modified">!         try {</span>
<span class="line-modified">!             InetSocketAddress local = dc.localAddress();</span>
<span class="line-modified">!             if (local != null) {</span>
<span class="line-removed">-                 return local.getPort();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } catch (Exception x) {</span>
          }
          return 0;
      }
  
      public void setSoTimeout(int timeout) throws SocketException {
          this.timeout = timeout;
      }
  
      public int getSoTimeout() throws SocketException {
          return timeout;
      }
  
      private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
          throws SocketException
<span class="line-new-header">--- 264,34 ---</span>
              }
          }
          return result;
      }
  
<span class="line-added">+     @Override</span>
      public int getLocalPort() {
          if (isClosed())
              return -1;
<span class="line-modified">!         InetSocketAddress local = dc.localAddress();</span>
<span class="line-modified">!         if (local != null) {</span>
<span class="line-modified">!             return local.getPort();</span>
          }
          return 0;
      }
  
<span class="line-added">+     @Override</span>
      public void setSoTimeout(int timeout) throws SocketException {
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">+         if (timeout &lt; 0)</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
          this.timeout = timeout;
      }
  
<span class="line-added">+     @Override</span>
      public int getSoTimeout() throws SocketException {
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          return timeout;
      }
  
      private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
          throws SocketException
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,113 ***</span>
              Net.translateToSocketException(x);
              return -1;          // keep compiler happy
          }
      }
  
      public void setSendBufferSize(int size) throws SocketException {
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid send size&quot;);
          setIntOption(StandardSocketOptions.SO_SNDBUF, size);
      }
  
      public int getSendBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_SNDBUF);
      }
  
      public void setReceiveBufferSize(int size) throws SocketException {
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
          setIntOption(StandardSocketOptions.SO_RCVBUF, size);
      }
  
      public int getReceiveBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_RCVBUF);
      }
  
      public void setReuseAddress(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
      }
  
      public boolean getReuseAddress() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
<span class="line-removed">- </span>
      }
  
      public void setBroadcast(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
      }
  
      public boolean getBroadcast() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
      }
  
      public void setTrafficClass(int tc) throws SocketException {
          setIntOption(StandardSocketOptions.IP_TOS, tc);
      }
  
      public int getTrafficClass() throws SocketException {
          return getIntOption(StandardSocketOptions.IP_TOS);
      }
  
      public void close() {
          try {
              dc.close();
          } catch (IOException x) {
              throw new Error(x);
          }
      }
  
      public boolean isClosed() {
          return !dc.isOpen();
      }
  
      public DatagramChannel getChannel() {
          return dc;
      }
  
<span class="line-modified">!    /*</span>
<span class="line-modified">!     * A dummy implementation of DatagramSocketImpl that can be passed to the</span>
<span class="line-modified">!     * DatagramSocket constructor so that no native resources are allocated in</span>
<span class="line-modified">!     * super class.</span>
<span class="line-modified">!     */</span>
<span class="line-removed">-    private static final DatagramSocketImpl dummyDatagramSocket</span>
<span class="line-removed">-        = new DatagramSocketImpl()</span>
<span class="line-removed">-    {</span>
<span class="line-removed">-        protected void create() throws SocketException {}</span>
  
<span class="line-modified">!        protected void bind(int lport, InetAddress laddr) throws SocketException {}</span>
  
<span class="line-modified">!        protected void send(DatagramPacket p) throws IOException {}</span>
  
<span class="line-modified">!        protected int peek(InetAddress i) throws IOException { return 0; }</span>
  
<span class="line-modified">!        protected int peekData(DatagramPacket p) throws IOException { return 0; }</span>
  
<span class="line-modified">!        protected void receive(DatagramPacket p) throws IOException {}</span>
  
<span class="line-modified">!        @Deprecated</span>
<span class="line-modified">!        protected void setTTL(byte ttl) throws IOException {}</span>
  
<span class="line-modified">!        @Deprecated</span>
<span class="line-modified">!        protected byte getTTL() throws IOException { return 0; }</span>
  
<span class="line-modified">!        protected void setTimeToLive(int ttl) throws IOException {}</span>
  
<span class="line-modified">!        protected int getTimeToLive() throws IOException { return 0;}</span>
  
<span class="line-modified">!        protected void join(InetAddress inetaddr) throws IOException {}</span>
  
<span class="line-modified">!        protected void leave(InetAddress inetaddr) throws IOException {}</span>
  
<span class="line-modified">!        protected void joinGroup(SocketAddress mcastaddr,</span>
<span class="line-modified">!                                  NetworkInterface netIf) throws IOException {}</span>
  
<span class="line-modified">!        protected void leaveGroup(SocketAddress mcastaddr,</span>
<span class="line-modified">!                                  NetworkInterface netIf) throws IOException {}</span>
  
<span class="line-modified">!        protected void close() {}</span>
  
<span class="line-modified">!        public Object getOption(int optID) throws SocketException { return null;}</span>
  
<span class="line-modified">!        public void setOption(int optID, Object value) throws SocketException {}</span>
<span class="line-modified">!    };</span>
<span class="line-modified">! }</span>
<span class="line-new-header">--- 329,435 ---</span>
              Net.translateToSocketException(x);
              return -1;          // keep compiler happy
          }
      }
  
<span class="line-added">+     @Override</span>
      public void setSendBufferSize(int size) throws SocketException {
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid send size&quot;);
          setIntOption(StandardSocketOptions.SO_SNDBUF, size);
      }
  
<span class="line-added">+     @Override</span>
      public int getSendBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_SNDBUF);
      }
  
<span class="line-added">+     @Override</span>
      public void setReceiveBufferSize(int size) throws SocketException {
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
          setIntOption(StandardSocketOptions.SO_RCVBUF, size);
      }
  
<span class="line-added">+     @Override</span>
      public int getReceiveBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_RCVBUF);
      }
  
<span class="line-added">+     @Override</span>
      public void setReuseAddress(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getReuseAddress() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
      }
  
<span class="line-added">+     @Override</span>
      public void setBroadcast(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getBroadcast() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
      }
  
<span class="line-added">+     @Override</span>
      public void setTrafficClass(int tc) throws SocketException {
          setIntOption(StandardSocketOptions.IP_TOS, tc);
      }
  
<span class="line-added">+     @Override</span>
      public int getTrafficClass() throws SocketException {
          return getIntOption(StandardSocketOptions.IP_TOS);
      }
  
<span class="line-added">+     @Override</span>
      public void close() {
          try {
              dc.close();
          } catch (IOException x) {
              throw new Error(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public boolean isClosed() {
          return !dc.isOpen();
      }
  
<span class="line-added">+     @Override</span>
      public DatagramChannel getChannel() {
          return dc;
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-modified">!         dc.setOption(name, value);</span>
<span class="line-modified">!         return this;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">+         return dc.getOption(name);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">+         return dc.supportedOptions();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     // -- java.net.MulticastSocket --</span>
  
<span class="line-modified">!     // used to coordinate changing TTL with the deprecated send method</span>
<span class="line-added">+     private final ReentrantLock sendLock = new ReentrantLock();</span>
  
<span class="line-modified">!     // cached outgoing interface (for use by setInterface/getInterface)</span>
<span class="line-added">+     private final Object outgoingInterfaceLock = new Object();</span>
<span class="line-added">+     private NetworkInterface outgoingNetworkInterface;</span>
<span class="line-added">+     private InetAddress outgoingInetAddress;</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     @Deprecated</span>
<span class="line-added">+     public void setTTL(byte ttl) throws IOException {</span>
<span class="line-added">+         setTimeToLive(Byte.toUnsignedInt(ttl));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public void setTimeToLive(int ttl) throws IOException {</span>
<span class="line-added">+         sendLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             sendLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public byte getTTL() throws IOException {</span>
<span class="line-added">+         return (byte) getTimeToLive();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     public int getTimeToLive() throws IOException {</span>
<span class="line-added">+         sendLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             sendLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public void joinGroup(InetAddress group) throws IOException {</span>
<span class="line-added">+         Objects.requireNonNull(group);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             joinGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">+         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">+             // 1-arg joinGroup does not specify IllegalArgumentException</span>
<span class="line-added">+             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public void leaveGroup(InetAddress group) throws IOException {</span>
<span class="line-added">+         Objects.requireNonNull(group);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             leaveGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">+         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">+             // 1-arg leaveGroup does not specify IllegalArgumentException</span>
<span class="line-added">+             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Checks a SocketAddress to ensure that it is a multicast address.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the multicast group</span>
<span class="line-added">+      * @throws IllegalArgumentException if group is null, an unsupported address</span>
<span class="line-added">+      *         type, or an unresolved address</span>
<span class="line-added">+      * @throws SocketException if group is not a multicast address</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {</span>
<span class="line-added">+         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-added">+         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();</span>
<span class="line-added">+         if (group == null)</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Unresolved address&quot;);</span>
<span class="line-added">+         if (!group.isMulticastAddress())</span>
<span class="line-added">+             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-added">+         return group;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">+         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">+         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">+         synchronized (this) {</span>
<span class="line-added">+             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">+             if (key != null) {</span>
<span class="line-added">+                 // already a member but need to check permission anyway</span>
<span class="line-added">+                 SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+                 if (sm != null)</span>
<span class="line-added">+                     sm.checkMulticast(group);</span>
<span class="line-added">+                 throw new SocketException(&quot;Already a member of group&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             dc.join(group, ni);  // checks permission</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">+         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">+         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">+         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">+         if (sm != null)</span>
<span class="line-added">+             sm.checkMulticast(group);</span>
<span class="line-added">+         synchronized (this) {</span>
<span class="line-added">+             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">+             if (key == null)</span>
<span class="line-added">+                 throw new SocketException(&quot;Not a member of group&quot;);</span>
<span class="line-added">+             key.drop();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public void setInterface(InetAddress inf) throws SocketException {</span>
<span class="line-added">+         if (inf == null)</span>
<span class="line-added">+             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);</span>
<span class="line-added">+         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);</span>
<span class="line-added">+         if (ni == null) {</span>
<span class="line-added">+             String address = inf.getHostAddress();</span>
<span class="line-added">+             throw new SocketException(&quot;No network interface with address &quot; + address);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">+             // set interface and update cached values</span>
<span class="line-added">+             setNetworkInterface(ni);</span>
<span class="line-added">+             outgoingNetworkInterface = ni;</span>
<span class="line-added">+             outgoingInetAddress = inf;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public InetAddress getInterface() throws SocketException {</span>
<span class="line-added">+         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">+             NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">+             if (ni != null) {</span>
<span class="line-added">+                 if (ni.equals(outgoingNetworkInterface)) {</span>
<span class="line-added">+                     return outgoingInetAddress;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // network interface has changed so update cached values</span>
<span class="line-added">+                     PrivilegedAction&lt;InetAddress&gt; pa;</span>
<span class="line-added">+                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);</span>
<span class="line-added">+                     InetAddress ia = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                     if (ia == null)</span>
<span class="line-added">+                         throw new SocketException(&quot;Network interface has no IP address&quot;);</span>
<span class="line-added">+                     outgoingNetworkInterface = ni;</span>
<span class="line-added">+                     outgoingInetAddress = ia;</span>
<span class="line-added">+                     return ia;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // no interface set</span>
<span class="line-added">+         return anyInetAddress();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);</span>
<span class="line-added">+         } catch (IOException e) {</span>
<span class="line-added">+             Net.translateToSocketException(e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public NetworkInterface getNetworkInterface() throws SocketException {</span>
<span class="line-added">+         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">+         if (ni == null) {</span>
<span class="line-added">+             // return NetworkInterface with index == 0 as placeholder</span>
<span class="line-added">+             ni = anyNetworkInterface();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return ni;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public void setLoopbackMode(boolean disable) throws SocketException {</span>
<span class="line-added">+         boolean enable = !disable;</span>
<span class="line-added">+         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     public boolean getLoopbackMode() throws SocketException {</span>
<span class="line-added">+         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">+         return !enabled;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     @Deprecated</span>
<span class="line-added">+     public void send(DatagramPacket p, byte ttl) throws IOException {</span>
<span class="line-added">+         sendLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             int oldValue = getTimeToLive();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 setTTL(ttl);</span>
<span class="line-added">+                 send(p);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 setTimeToLive(oldValue);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             sendLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the outgoing NetworkInterface or null if not set.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private NetworkInterface outgoingNetworkInterface() throws SocketException {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return getOption(StandardSocketOptions.IP_MULTICAST_IF);</span>
<span class="line-added">+         } catch (IOException e) {</span>
<span class="line-added">+             Net.translateToSocketException(e);</span>
<span class="line-added">+             return null; // keep compiler happy</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the default NetworkInterface to use when joining or leaving a</span>
<span class="line-added">+      * multicast group and a network interface is not specified.</span>
<span class="line-added">+      * This method will return the outgoing NetworkInterface if set, otherwise</span>
<span class="line-added">+      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface</span>
<span class="line-added">+      * with index == 0 as a placeholder for &quot;any network interface&quot;.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private NetworkInterface defaultNetworkInterface() throws SocketException {</span>
<span class="line-added">+         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">+         if (ni == null)</span>
<span class="line-added">+             ni = NetworkInterfaces.getDefault();   // macOS</span>
<span class="line-added">+         if (ni == null)</span>
<span class="line-added">+             ni = anyNetworkInterface();</span>
<span class="line-added">+         return ni;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private NetworkInterface anyNetworkInterface() {</span>
<span class="line-added">+         InetAddress[] addrs = new InetAddress[1];</span>
<span class="line-added">+         addrs[0] = anyInetAddress();</span>
<span class="line-added">+         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the InetAddress representing anyLocalAddress.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private InetAddress anyInetAddress() {</span>
<span class="line-added">+         return new InetSocketAddress(0).getAddress();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Defines static methods to get/set DatagramPacket fields and workaround</span>
<span class="line-added">+      * DatagramPacket deficiencies.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class DatagramPackets {</span>
<span class="line-added">+         private static final VarHandle LENGTH;</span>
<span class="line-added">+         private static final VarHandle BUF_LENGTH;</span>
<span class="line-added">+         static {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">+                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());</span>
<span class="line-added">+                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);</span>
<span class="line-added">+                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);</span>
<span class="line-added">+             } catch (Exception e) {</span>
<span class="line-added">+                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be</span>
<span class="line-added">+          * used at this time because it sets both the length and bufLength fields.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         static void setLength(DatagramPacket p, int value) {</span>
<span class="line-added">+             synchronized (p) {</span>
<span class="line-added">+                 LENGTH.set(p, value);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Returns the value of the DatagramPacket.bufLength field.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         static int getBufLength(DatagramPacket p) {</span>
<span class="line-added">+             synchronized (p) {</span>
<span class="line-added">+                 return (int) BUF_LENGTH.get(p);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Defines static methods to invoke non-public NetworkInterface methods.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class NetworkInterfaces {</span>
<span class="line-added">+         static final MethodHandle GET_DEFAULT;</span>
<span class="line-added">+         static final MethodHandle CONSTRUCTOR;</span>
<span class="line-added">+         static {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">+                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());</span>
<span class="line-added">+                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                 MethodType methodType = MethodType.methodType(NetworkInterface.class);</span>
<span class="line-added">+                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);</span>
<span class="line-added">+                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);</span>
<span class="line-added">+                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);</span>
<span class="line-added">+             } catch (Exception e) {</span>
<span class="line-added">+                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Returns the default network interface or null.</span>
<span class="line-modified">!          */</span>
<span class="line-added">+         static NetworkInterface getDefault() {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 return (NetworkInterface) GET_DEFAULT.invokeExact();</span>
<span class="line-added">+             } catch (Throwable e) {</span>
<span class="line-added">+                 throw new InternalError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Creates a NetworkInterface with the given name index and addresses.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);</span>
<span class="line-added">+             } catch (Throwable e) {</span>
<span class="line-added">+                 throw new InternalError(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="DatagramChannelImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
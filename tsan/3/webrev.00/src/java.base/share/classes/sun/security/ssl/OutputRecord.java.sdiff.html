<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/OutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewSessionTicket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/OutputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.Closeable;
 30 import java.io.IOException;
 31 import java.io.OutputStream;
 32 import java.nio.ByteBuffer;

 33 import sun.security.ssl.SSLCipher.SSLWriteCipher;
 34 
 35 /**
 36  * {@code OutputRecord} takes care of the management of SSL/(D)TLS
 37  * output records, including buffering, encryption, handshake
 38  * messages marshal, etc.
 39  *
 40  * @author David Brownell
 41  */
 42 abstract class OutputRecord
 43         extends ByteArrayOutputStream implements Record, Closeable {
 44     SSLWriteCipher              writeCipher;
 45     // Needed for KeyUpdate, used after Handshake.Finished
 46     TransportContext            tc;
 47 
 48     final HandshakeHash         handshakeHash;
 49     boolean                     firstMessage;
 50 
 51     // current protocol version, sent as record version
 52     ProtocolVersion             protocolVersion;
 53 
 54     // version for the ClientHello message. Only relevant if this is a
 55     // client handshake record. If set to ProtocolVersion.SSL20Hello,
 56     // the V3 client hello is converted to V2 format.
 57     ProtocolVersion             helloVersion;
 58 
 59     // Is it the first application record to write?
 60     boolean                     isFirstAppOutputRecord = true;
 61 
 62     // packet size
 63     int                         packetSize;
 64 
 65     // fragment size
<span class="line-modified"> 66     int                         fragmentSize;</span>
 67 
 68     // closed or not?
 69     volatile boolean            isClosed;
 70 


 71     /*
 72      * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
 73      * This is taken from the SSL V3 specification, Appendix E.
 74      */
 75     private static final int[] V3toV2CipherMap1 =
 76         {-1, -1, -1, 0x02, 0x01, -1, 0x04, 0x05, -1, 0x06, 0x07};
 77     private static final int[] V3toV2CipherMap3 =
 78         {-1, -1, -1, 0x80, 0x80, -1, 0x80, 0x80, -1, 0x40, 0xC0};
 79     private static final byte[] HANDSHAKE_MESSAGE_KEY_UPDATE =
 80         {SSLHandshake.KEY_UPDATE.id, 0x00, 0x00, 0x01, 0x00};
 81 
 82     OutputRecord(HandshakeHash handshakeHash, SSLWriteCipher writeCipher) {
 83         this.writeCipher = writeCipher;
 84         this.firstMessage = true;
 85         this.fragmentSize = Record.maxDataSize;
 86 
 87         this.handshakeHash = handshakeHash;
 88 
 89         // Please set packetSize and protocolVersion in the implementation.
 90     }
 91 
<span class="line-modified"> 92     synchronized void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="line-modified"> 93         this.protocolVersion = protocolVersion;</span>





 94     }
 95 
 96     /*
 97      * Updates helloVersion of this record.
 98      */
<span class="line-modified"> 99     synchronized void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="line-modified">100         this.helloVersion = helloVersion;</span>





101     }
102 
103     /*
104      * Return true iff the record is empty -- to avoid doing the work
105      * of sending empty records over the network.
106      */
107     boolean isEmpty() {
108         return false;
109     }
110 
<span class="line-modified">111     synchronized boolean seqNumIsHuge() {</span>
<span class="line-modified">112         return (writeCipher.authenticator != null) &amp;&amp;</span>


113                         writeCipher.authenticator.seqNumIsHuge();



114     }
115 
116     // SSLEngine and SSLSocket
117     abstract void encodeAlert(byte level, byte description) throws IOException;
118 
119     // SSLEngine and SSLSocket
120     abstract void encodeHandshake(byte[] buffer,
121             int offset, int length) throws IOException;
122 
123     // SSLEngine and SSLSocket
124     abstract void encodeChangeCipherSpec() throws IOException;
125 
126     // apply to SSLEngine only
127     Ciphertext encode(
128         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
129         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
130 
131         throw new UnsupportedOperationException();
132     }
133 
134     // apply to SSLEngine only
135     void encodeV2NoCipher() throws IOException {
136         throw new UnsupportedOperationException();
137     }
138 
139     // apply to SSLSocket only
140     void deliver(
141             byte[] source, int offset, int length) throws IOException {
142         throw new UnsupportedOperationException();
143     }
144 
145     // apply to SSLSocket only
146     void setDeliverStream(OutputStream outputStream) {
147         throw new UnsupportedOperationException();
148     }
149 
150     // Change write ciphers, may use change_cipher_spec record.
<span class="line-modified">151     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
152             boolean useChangeCipherSpec) throws IOException {
<span class="line-modified">153         if (isClosed()) {</span>
<span class="line-modified">154             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">155                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">156                     &quot;change_cipher_spec message&quot;);</span>




157             }
<span class="line-removed">158             return;</span>
<span class="line-removed">159         }</span>
160 
<span class="line-modified">161         if (useChangeCipherSpec) {</span>
<span class="line-modified">162             encodeChangeCipherSpec();</span>
<span class="line-modified">163         }</span>
<span class="line-removed">164 </span>
<span class="line-removed">165         /*</span>
<span class="line-removed">166          * Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-removed">167          * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="line-removed">168          * and thus make finalization faster.</span>
<span class="line-removed">169          *</span>
<span class="line-removed">170          * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="line-removed">171          * not necessary to do the same with MAC&#39;s.</span>
<span class="line-removed">172          */</span>
<span class="line-removed">173         writeCipher.dispose();</span>
174 
<span class="line-modified">175         this.writeCipher = writeCipher;</span>
<span class="line-modified">176         this.isFirstAppOutputRecord = true;</span>













177     }
178 
179     // Change write ciphers using key_update handshake message.
<span class="line-modified">180     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
181             byte keyUpdateRequest) throws IOException {
<span class="line-modified">182         if (isClosed()) {</span>
<span class="line-modified">183             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">184                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">185                     &quot;key_update handshake message&quot;);</span>




186             }
<span class="line-removed">187             return;</span>
<span class="line-removed">188         }</span>
189 
<span class="line-modified">190         // encode the handshake message, KeyUpdate</span>
<span class="line-modified">191         byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="line-modified">192         hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="line-modified">193         encodeHandshake(hm, 0, hm.length);</span>
<span class="line-modified">194         flush();</span>
195 
<span class="line-modified">196         // Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-modified">197         writeCipher.dispose();</span>
198 
<span class="line-modified">199         this.writeCipher = writeCipher;</span>
<span class="line-modified">200         this.isFirstAppOutputRecord = true;</span>



201     }
202 
<span class="line-modified">203     synchronized void changePacketSize(int packetSize) {</span>
<span class="line-modified">204         this.packetSize = packetSize;</span>





205     }
206 
<span class="line-modified">207     synchronized void changeFragmentSize(int fragmentSize) {</span>
<span class="line-modified">208         this.fragmentSize = fragmentSize;</span>





209     }
210 
<span class="line-modified">211     synchronized int getMaxPacketSize() {</span>
<span class="line-modified">212         return packetSize;</span>





213     }
214 
215     // apply to DTLS SSLEngine
216     void initHandshaker() {
217         // blank
218     }
219 
220     // apply to DTLS SSLEngine
221     void finishHandshake() {
222         // blank
223     }
224 
225     // apply to DTLS SSLEngine
226     void launchRetransmission() {
227         // blank
228     }
229 
230     @Override
<span class="line-modified">231     public synchronized void close() throws IOException {</span>
<span class="line-modified">232         if (isClosed) {</span>
<span class="line-modified">233             return;</span>
<span class="line-modified">234         }</span>


235 
<span class="line-modified">236         isClosed = true;</span>
<span class="line-modified">237         writeCipher.dispose();</span>



238     }
239 
240     boolean isClosed() {
241         return isClosed;
242     }
243 
244     //
245     // shared helpers
246     //
247 


















248     // Encrypt a fragment and wrap up a record.
249     //
250     // To be consistent with the spec of SSLEngine.wrap() methods, the
251     // destination ByteBuffer&#39;s position is updated to reflect the amount
252     // of data produced.  The limit remains the same.
253     static long encrypt(
254             SSLWriteCipher encCipher, byte contentType, ByteBuffer destination,
255             int headerOffset, int dstLim, int headerSize,
256             ProtocolVersion protocolVersion) {
257         boolean isDTLS = protocolVersion.isDTLS;
258         if (isDTLS) {
259             if (protocolVersion.useTLS13PlusSpec()) {
260                 return d13Encrypt(encCipher,
261                         contentType, destination, headerOffset,
262                         dstLim, headerSize, protocolVersion);
263             } else {
264                 return d10Encrypt(encCipher,
265                         contentType, destination, headerOffset,
266                         dstLim, headerSize, protocolVersion);
267             }
</pre>
<hr />
<pre>
309         destination.put(headerOffset + 9, sequenceNumber[6]);
310         destination.put(headerOffset + 10, sequenceNumber[7]);
311 
312         // fragment length
313         destination.put(headerOffset + 11, (byte)(fragLen &gt;&gt; 8));
314         destination.put(headerOffset + 12, (byte)fragLen);
315 
316         // Update destination position to reflect the amount of data produced.
317         destination.position(destination.limit());
318 
319         return Authenticator.toLong(sequenceNumber);
320     }
321 
322     private static long t13Encrypt(
323             SSLWriteCipher encCipher, byte contentType, ByteBuffer destination,
324             int headerOffset, int dstLim, int headerSize,
325             ProtocolVersion protocolVersion) {
326         if (!encCipher.isNullCipher()) {
327             // inner plaintext, using zero length padding.
328             int endOfPt = destination.limit();
<span class="line-modified">329             destination.limit(endOfPt + 1);</span>
<span class="line-modified">330             destination.put(endOfPt, contentType);</span>




331         }
332 
333         // use the right TLSCiphertext.opaque_type and legacy_record_version
334         ProtocolVersion pv = protocolVersion;
335         if (!encCipher.isNullCipher()) {
336             pv = ProtocolVersion.TLS12;
337             contentType = ContentType.APPLICATION_DATA.id;
338         } else if (protocolVersion.useTLS13PlusSpec()) {
339             pv = ProtocolVersion.TLS12;
340         }
341 
342         byte[] sequenceNumber = encCipher.authenticator.sequenceNumber();
343         encCipher.encrypt(contentType, destination);
344 
345         // Finish out the record header.
346         int fragLen = destination.limit() - headerOffset - headerSize;
347         destination.put(headerOffset, contentType);
348         destination.put(headerOffset + 1, pv.major);
349         destination.put(headerOffset + 2, pv.minor);
350 
</pre>
<hr />
<pre>
378 
379         // Update destination position to reflect the amount of data produced.
380         destination.position(destination.limit());
381 
382         return Authenticator.toLong(sequenceNumber);
383     }
384 
385     // Encrypt a fragment and wrap up a record.
386     //
387     // Uses the internal expandable buf variable and the current
388     // protocolVersion variable.
389     long encrypt(
390             SSLWriteCipher encCipher, byte contentType, int headerSize) {
391         if (protocolVersion.useTLS13PlusSpec()) {
392             return t13Encrypt(encCipher, contentType, headerSize);
393         } else {
394             return t10Encrypt(encCipher, contentType, headerSize);
395         }
396     }
397 
<span class="line-removed">398     private static final class T13PaddingHolder {</span>
<span class="line-removed">399         private static final byte[] zeros = new byte[16];</span>
<span class="line-removed">400     }</span>
<span class="line-removed">401 </span>
402     private long t13Encrypt(
403             SSLWriteCipher encCipher, byte contentType, int headerSize) {
404         if (!encCipher.isNullCipher()) {
405             // inner plaintext
406             write(contentType);
407             write(T13PaddingHolder.zeros, 0, T13PaddingHolder.zeros.length);
408         }
409 
410         byte[] sequenceNumber = encCipher.authenticator.sequenceNumber();
411         int position = headerSize;
412         int contentLen = count - position;
413 
414         // ensure the capacity
415         int requiredPacketSize =
416                 encCipher.calculatePacketSize(contentLen, headerSize);
417         if (requiredPacketSize &gt; buf.length) {
418             byte[] newBuf = new byte[requiredPacketSize];
419             System.arraycopy(buf, 0, newBuf, 0, count);
420             buf = newBuf;
421         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.Closeable;
 30 import java.io.IOException;
 31 import java.io.OutputStream;
 32 import java.nio.ByteBuffer;
<span class="line-added"> 33 import java.util.concurrent.locks.ReentrantLock;</span>
 34 import sun.security.ssl.SSLCipher.SSLWriteCipher;
 35 
 36 /**
 37  * {@code OutputRecord} takes care of the management of SSL/(D)TLS
 38  * output records, including buffering, encryption, handshake
 39  * messages marshal, etc.
 40  *
 41  * @author David Brownell
 42  */
 43 abstract class OutputRecord
 44         extends ByteArrayOutputStream implements Record, Closeable {
 45     SSLWriteCipher              writeCipher;
 46     // Needed for KeyUpdate, used after Handshake.Finished
 47     TransportContext            tc;
 48 
 49     final HandshakeHash         handshakeHash;
 50     boolean                     firstMessage;
 51 
 52     // current protocol version, sent as record version
 53     ProtocolVersion             protocolVersion;
 54 
 55     // version for the ClientHello message. Only relevant if this is a
 56     // client handshake record. If set to ProtocolVersion.SSL20Hello,
 57     // the V3 client hello is converted to V2 format.
 58     ProtocolVersion             helloVersion;
 59 
 60     // Is it the first application record to write?
 61     boolean                     isFirstAppOutputRecord = true;
 62 
 63     // packet size
 64     int                         packetSize;
 65 
 66     // fragment size
<span class="line-modified"> 67     private int                 fragmentSize;</span>
 68 
 69     // closed or not?
 70     volatile boolean            isClosed;
 71 
<span class="line-added"> 72     final ReentrantLock recordLock = new ReentrantLock();</span>
<span class="line-added"> 73 </span>
 74     /*
 75      * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
 76      * This is taken from the SSL V3 specification, Appendix E.
 77      */
 78     private static final int[] V3toV2CipherMap1 =
 79         {-1, -1, -1, 0x02, 0x01, -1, 0x04, 0x05, -1, 0x06, 0x07};
 80     private static final int[] V3toV2CipherMap3 =
 81         {-1, -1, -1, 0x80, 0x80, -1, 0x80, 0x80, -1, 0x40, 0xC0};
 82     private static final byte[] HANDSHAKE_MESSAGE_KEY_UPDATE =
 83         {SSLHandshake.KEY_UPDATE.id, 0x00, 0x00, 0x01, 0x00};
 84 
 85     OutputRecord(HandshakeHash handshakeHash, SSLWriteCipher writeCipher) {
 86         this.writeCipher = writeCipher;
 87         this.firstMessage = true;
 88         this.fragmentSize = Record.maxDataSize;
 89 
 90         this.handshakeHash = handshakeHash;
 91 
 92         // Please set packetSize and protocolVersion in the implementation.
 93     }
 94 
<span class="line-modified"> 95     void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="line-modified"> 96         recordLock.lock();</span>
<span class="line-added"> 97         try {</span>
<span class="line-added"> 98             this.protocolVersion = protocolVersion;</span>
<span class="line-added"> 99         } finally {</span>
<span class="line-added">100             recordLock.unlock();</span>
<span class="line-added">101         }</span>
102     }
103 
104     /*
105      * Updates helloVersion of this record.
106      */
<span class="line-modified">107     void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="line-modified">108         recordLock.lock();</span>
<span class="line-added">109         try {</span>
<span class="line-added">110             this.helloVersion = helloVersion;</span>
<span class="line-added">111         } finally {</span>
<span class="line-added">112             recordLock.unlock();</span>
<span class="line-added">113         }</span>
114     }
115 
116     /*
117      * Return true iff the record is empty -- to avoid doing the work
118      * of sending empty records over the network.
119      */
120     boolean isEmpty() {
121         return false;
122     }
123 
<span class="line-modified">124     boolean seqNumIsHuge() {</span>
<span class="line-modified">125         recordLock.lock();</span>
<span class="line-added">126         try {</span>
<span class="line-added">127             return (writeCipher.authenticator != null) &amp;&amp;</span>
128                         writeCipher.authenticator.seqNumIsHuge();
<span class="line-added">129         } finally {</span>
<span class="line-added">130             recordLock.unlock();</span>
<span class="line-added">131         }</span>
132     }
133 
134     // SSLEngine and SSLSocket
135     abstract void encodeAlert(byte level, byte description) throws IOException;
136 
137     // SSLEngine and SSLSocket
138     abstract void encodeHandshake(byte[] buffer,
139             int offset, int length) throws IOException;
140 
141     // SSLEngine and SSLSocket
142     abstract void encodeChangeCipherSpec() throws IOException;
143 
144     // apply to SSLEngine only
145     Ciphertext encode(
146         ByteBuffer[] srcs, int srcsOffset, int srcsLength,
147         ByteBuffer[] dsts, int dstsOffset, int dstsLength) throws IOException {
148 
149         throw new UnsupportedOperationException();
150     }
151 
152     // apply to SSLEngine only
153     void encodeV2NoCipher() throws IOException {
154         throw new UnsupportedOperationException();
155     }
156 
157     // apply to SSLSocket only
158     void deliver(
159             byte[] source, int offset, int length) throws IOException {
160         throw new UnsupportedOperationException();
161     }
162 
163     // apply to SSLSocket only
164     void setDeliverStream(OutputStream outputStream) {
165         throw new UnsupportedOperationException();
166     }
167 
168     // Change write ciphers, may use change_cipher_spec record.
<span class="line-modified">169     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
170             boolean useChangeCipherSpec) throws IOException {
<span class="line-modified">171         recordLock.lock();</span>
<span class="line-modified">172         try {</span>
<span class="line-modified">173             if (isClosed()) {</span>
<span class="line-modified">174                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">175                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">176                         &quot;change_cipher_spec message&quot;);</span>
<span class="line-added">177                 }</span>
<span class="line-added">178                 return;</span>
179             }


180 
<span class="line-modified">181             if (useChangeCipherSpec) {</span>
<span class="line-modified">182                 encodeChangeCipherSpec();</span>
<span class="line-modified">183             }</span>










184 
<span class="line-modified">185             /*</span>
<span class="line-modified">186              * Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-added">187              * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="line-added">188              * and thus make finalization faster.</span>
<span class="line-added">189              *</span>
<span class="line-added">190              * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="line-added">191              * not necessary to do the same with MAC&#39;s.</span>
<span class="line-added">192              */</span>
<span class="line-added">193             writeCipher.dispose();</span>
<span class="line-added">194 </span>
<span class="line-added">195             this.writeCipher = writeCipher;</span>
<span class="line-added">196             this.isFirstAppOutputRecord = true;</span>
<span class="line-added">197         } finally {</span>
<span class="line-added">198             recordLock.unlock();</span>
<span class="line-added">199         }</span>
200     }
201 
202     // Change write ciphers using key_update handshake message.
<span class="line-modified">203     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
204             byte keyUpdateRequest) throws IOException {
<span class="line-modified">205         recordLock.lock();</span>
<span class="line-modified">206         try {</span>
<span class="line-modified">207             if (isClosed()) {</span>
<span class="line-modified">208                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">209                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">210                         &quot;key_update handshake message&quot;);</span>
<span class="line-added">211                 }</span>
<span class="line-added">212                 return;</span>
213             }


214 
<span class="line-modified">215             // encode the handshake message, KeyUpdate</span>
<span class="line-modified">216             byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="line-modified">217             hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="line-modified">218             encodeHandshake(hm, 0, hm.length);</span>
<span class="line-modified">219             flush();</span>
220 
<span class="line-modified">221             // Dispose of any intermediate state in the underlying cipher.</span>
<span class="line-modified">222             writeCipher.dispose();</span>
223 
<span class="line-modified">224             this.writeCipher = writeCipher;</span>
<span class="line-modified">225             this.isFirstAppOutputRecord = true;</span>
<span class="line-added">226         } finally {</span>
<span class="line-added">227             recordLock.unlock();</span>
<span class="line-added">228         }</span>
229     }
230 
<span class="line-modified">231     void changePacketSize(int packetSize) {</span>
<span class="line-modified">232         recordLock.lock();</span>
<span class="line-added">233         try {</span>
<span class="line-added">234             this.packetSize = packetSize;</span>
<span class="line-added">235         } finally {</span>
<span class="line-added">236             recordLock.unlock();</span>
<span class="line-added">237         }</span>
238     }
239 
<span class="line-modified">240     void changeFragmentSize(int fragmentSize) {</span>
<span class="line-modified">241         recordLock.lock();</span>
<span class="line-added">242         try {</span>
<span class="line-added">243             this.fragmentSize = fragmentSize;</span>
<span class="line-added">244         } finally {</span>
<span class="line-added">245             recordLock.unlock();</span>
<span class="line-added">246         }</span>
247     }
248 
<span class="line-modified">249     int getMaxPacketSize() {</span>
<span class="line-modified">250         recordLock.lock();</span>
<span class="line-added">251         try {</span>
<span class="line-added">252             return packetSize;</span>
<span class="line-added">253         } finally {</span>
<span class="line-added">254             recordLock.unlock();</span>
<span class="line-added">255         }</span>
256     }
257 
258     // apply to DTLS SSLEngine
259     void initHandshaker() {
260         // blank
261     }
262 
263     // apply to DTLS SSLEngine
264     void finishHandshake() {
265         // blank
266     }
267 
268     // apply to DTLS SSLEngine
269     void launchRetransmission() {
270         // blank
271     }
272 
273     @Override
<span class="line-modified">274     public void close() throws IOException {</span>
<span class="line-modified">275         recordLock.lock();</span>
<span class="line-modified">276         try {</span>
<span class="line-modified">277             if (isClosed) {</span>
<span class="line-added">278                 return;</span>
<span class="line-added">279             }</span>
280 
<span class="line-modified">281             isClosed = true;</span>
<span class="line-modified">282             writeCipher.dispose();</span>
<span class="line-added">283         } finally {</span>
<span class="line-added">284             recordLock.unlock();</span>
<span class="line-added">285         }</span>
286     }
287 
288     boolean isClosed() {
289         return isClosed;
290     }
291 
292     //
293     // shared helpers
294     //
295 
<span class="line-added">296     private static final class T13PaddingHolder {</span>
<span class="line-added">297         private static final byte[] zeros = new byte[16];</span>
<span class="line-added">298     }</span>
<span class="line-added">299 </span>
<span class="line-added">300     int calculateFragmentSize(int fragmentLimit) {</span>
<span class="line-added">301         if (fragmentSize &gt; 0) {</span>
<span class="line-added">302             fragmentLimit = Math.min(fragmentLimit, fragmentSize);</span>
<span class="line-added">303         }</span>
<span class="line-added">304 </span>
<span class="line-added">305         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="line-added">306             // No negative integer checking as the fragment capacity should</span>
<span class="line-added">307             // have been ensured.</span>
<span class="line-added">308             return fragmentLimit -  T13PaddingHolder.zeros.length - 1;</span>
<span class="line-added">309         }</span>
<span class="line-added">310 </span>
<span class="line-added">311         return fragmentLimit;</span>
<span class="line-added">312     }</span>
<span class="line-added">313 </span>
314     // Encrypt a fragment and wrap up a record.
315     //
316     // To be consistent with the spec of SSLEngine.wrap() methods, the
317     // destination ByteBuffer&#39;s position is updated to reflect the amount
318     // of data produced.  The limit remains the same.
319     static long encrypt(
320             SSLWriteCipher encCipher, byte contentType, ByteBuffer destination,
321             int headerOffset, int dstLim, int headerSize,
322             ProtocolVersion protocolVersion) {
323         boolean isDTLS = protocolVersion.isDTLS;
324         if (isDTLS) {
325             if (protocolVersion.useTLS13PlusSpec()) {
326                 return d13Encrypt(encCipher,
327                         contentType, destination, headerOffset,
328                         dstLim, headerSize, protocolVersion);
329             } else {
330                 return d10Encrypt(encCipher,
331                         contentType, destination, headerOffset,
332                         dstLim, headerSize, protocolVersion);
333             }
</pre>
<hr />
<pre>
375         destination.put(headerOffset + 9, sequenceNumber[6]);
376         destination.put(headerOffset + 10, sequenceNumber[7]);
377 
378         // fragment length
379         destination.put(headerOffset + 11, (byte)(fragLen &gt;&gt; 8));
380         destination.put(headerOffset + 12, (byte)fragLen);
381 
382         // Update destination position to reflect the amount of data produced.
383         destination.position(destination.limit());
384 
385         return Authenticator.toLong(sequenceNumber);
386     }
387 
388     private static long t13Encrypt(
389             SSLWriteCipher encCipher, byte contentType, ByteBuffer destination,
390             int headerOffset, int dstLim, int headerSize,
391             ProtocolVersion protocolVersion) {
392         if (!encCipher.isNullCipher()) {
393             // inner plaintext, using zero length padding.
394             int endOfPt = destination.limit();
<span class="line-modified">395             int startOfPt = destination.position();</span>
<span class="line-modified">396             destination.position(endOfPt);</span>
<span class="line-added">397             destination.limit(endOfPt + 1 + T13PaddingHolder.zeros.length);</span>
<span class="line-added">398             destination.put(contentType);</span>
<span class="line-added">399             destination.put(T13PaddingHolder.zeros);</span>
<span class="line-added">400             destination.position(startOfPt);</span>
401         }
402 
403         // use the right TLSCiphertext.opaque_type and legacy_record_version
404         ProtocolVersion pv = protocolVersion;
405         if (!encCipher.isNullCipher()) {
406             pv = ProtocolVersion.TLS12;
407             contentType = ContentType.APPLICATION_DATA.id;
408         } else if (protocolVersion.useTLS13PlusSpec()) {
409             pv = ProtocolVersion.TLS12;
410         }
411 
412         byte[] sequenceNumber = encCipher.authenticator.sequenceNumber();
413         encCipher.encrypt(contentType, destination);
414 
415         // Finish out the record header.
416         int fragLen = destination.limit() - headerOffset - headerSize;
417         destination.put(headerOffset, contentType);
418         destination.put(headerOffset + 1, pv.major);
419         destination.put(headerOffset + 2, pv.minor);
420 
</pre>
<hr />
<pre>
448 
449         // Update destination position to reflect the amount of data produced.
450         destination.position(destination.limit());
451 
452         return Authenticator.toLong(sequenceNumber);
453     }
454 
455     // Encrypt a fragment and wrap up a record.
456     //
457     // Uses the internal expandable buf variable and the current
458     // protocolVersion variable.
459     long encrypt(
460             SSLWriteCipher encCipher, byte contentType, int headerSize) {
461         if (protocolVersion.useTLS13PlusSpec()) {
462             return t13Encrypt(encCipher, contentType, headerSize);
463         } else {
464             return t10Encrypt(encCipher, contentType, headerSize);
465         }
466     }
467 




468     private long t13Encrypt(
469             SSLWriteCipher encCipher, byte contentType, int headerSize) {
470         if (!encCipher.isNullCipher()) {
471             // inner plaintext
472             write(contentType);
473             write(T13PaddingHolder.zeros, 0, T13PaddingHolder.zeros.length);
474         }
475 
476         byte[] sequenceNumber = encCipher.authenticator.sequenceNumber();
477         int position = headerSize;
478         int contentLen = count - position;
479 
480         // ensure the capacity
481         int requiredPacketSize =
482                 encCipher.calculatePacketSize(contentLen, headerSize);
483         if (requiredPacketSize &gt; buf.length) {
484             byte[] newBuf = new byte[requiredPacketSize];
485             System.arraycopy(buf, 0, newBuf, 0, count);
486             buf = newBuf;
487         }
</pre>
</td>
</tr>
</table>
<center><a href="NewSessionTicket.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/util/locale/BaseLocale.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../cldr/CLDRTimeZoneNameProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LocaleSyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/util/locale/BaseLocale.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *******************************************************************************
 28  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
 29  * others. All Rights Reserved.                                                *
 30  *******************************************************************************
 31  */
 32 
 33 package sun.util.locale;
 34 



 35 import java.lang.ref.SoftReference;
 36 import java.util.StringJoiner;
 37 
 38 public final class BaseLocale {
 39 
<span class="line-modified"> 40     public static final String SEP = &quot;_&quot;;</span>















































 41 
<span class="line-modified"> 42     private static final Cache CACHE = new Cache();</span>
 43 
 44     private final String language;
 45     private final String script;
 46     private final String region;
 47     private final String variant;
 48 
 49     private volatile int hash;
 50 
 51     // This method must be called with normalize = false only when creating the
 52     // Locale.* constants and non-normalized BaseLocale$Keys used for lookup.
 53     private BaseLocale(String language, String script, String region, String variant,
 54                        boolean normalize) {
 55         if (normalize) {
 56             this.language = LocaleUtils.toLowerString(language).intern();
 57             this.script = LocaleUtils.toTitleString(script).intern();
 58             this.region = LocaleUtils.toUpperString(region).intern();
 59             this.variant = variant.intern();
 60         } else {
 61             this.language = language;
 62             this.script = script;
 63             this.region = region;
 64             this.variant = variant;
 65         }
 66     }
 67 
 68     // Called for creating the Locale.* constants. No argument
 69     // validation is performed.
<span class="line-modified"> 70     public static BaseLocale createInstance(String language, String region) {</span>
<span class="line-modified"> 71         BaseLocale base = new BaseLocale(language, &quot;&quot;, region, &quot;&quot;, false);</span>
<span class="line-removed"> 72         CACHE.put(new Key(base), base);</span>
<span class="line-removed"> 73         return base;</span>
 74     }
 75 
 76     public static BaseLocale getInstance(String language, String script,
 77                                          String region, String variant) {




























 78         // JDK uses deprecated ISO639.1 language codes for he, yi and id
<span class="line-modified"> 79         if (language != null) {</span>
<span class="line-modified"> 80             if (LocaleUtils.caseIgnoreMatch(language, &quot;he&quot;)) {</span>
 81                 language = &quot;iw&quot;;
<span class="line-modified"> 82             } else if (LocaleUtils.caseIgnoreMatch(language, &quot;yi&quot;)) {</span>
 83                 language = &quot;ji&quot;;
<span class="line-modified"> 84             } else if (LocaleUtils.caseIgnoreMatch(language, &quot;id&quot;)) {</span>
 85                 language = &quot;in&quot;;
 86             }
 87         }
 88 
 89         Key key = new Key(language, script, region, variant, false);
<span class="line-modified"> 90         BaseLocale baseLocale = CACHE.get(key);</span>
<span class="line-removed"> 91         return baseLocale;</span>
 92     }
 93 
 94     public String getLanguage() {
 95         return language;
 96     }
 97 
 98     public String getScript() {
 99         return script;
100     }
101 
102     public String getRegion() {
103         return region;
104     }
105 
106     public String getVariant() {
107         return variant;
108     }
109 
110     @Override
111     public boolean equals(Object obj) {
</pre>
<hr />
<pre>
154             }
155         }
156         return h;
157     }
158 
159     private static final class Key {
160         /**
161          * Keep a SoftReference to the Key data if normalized (actually used
162          * as a cache key) and not initialized via the constant creation path.
163          *
164          * This allows us to avoid creating SoftReferences on lookup Keys
165          * (which are short-lived) and for Locales created via
166          * Locale#createConstant.
167          */
168         private final SoftReference&lt;BaseLocale&gt; holderRef;
169         private final BaseLocale holder;
170 
171         private final boolean normalized;
172         private final int hash;
173 
<span class="line-removed">174         /**</span>
<span class="line-removed">175          * Creates a Key. language and region must be normalized</span>
<span class="line-removed">176          * (intern&#39;ed in the proper case).</span>
<span class="line-removed">177          */</span>
<span class="line-removed">178         private Key(BaseLocale locale) {</span>
<span class="line-removed">179             this.holder = locale;</span>
<span class="line-removed">180             this.holderRef = null;</span>
<span class="line-removed">181             this.normalized = true;</span>
<span class="line-removed">182             String language = locale.getLanguage();</span>
<span class="line-removed">183             String region = locale.getRegion();</span>
<span class="line-removed">184             assert LocaleUtils.toLowerString(language).intern() == language</span>
<span class="line-removed">185                     &amp;&amp; LocaleUtils.toUpperString(region).intern() == region</span>
<span class="line-removed">186                     &amp;&amp; locale.getVariant() == &quot;&quot;</span>
<span class="line-removed">187                     &amp;&amp; locale.getScript() == &quot;&quot;;</span>
<span class="line-removed">188 </span>
<span class="line-removed">189             int h = language.hashCode();</span>
<span class="line-removed">190             if (region != &quot;&quot;) {</span>
<span class="line-removed">191                 int len = region.length();</span>
<span class="line-removed">192                 for (int i = 0; i &lt; len; i++) {</span>
<span class="line-removed">193                     h = 31 * h + LocaleUtils.toLower(region.charAt(i));</span>
<span class="line-removed">194                 }</span>
<span class="line-removed">195             }</span>
<span class="line-removed">196             hash = h;</span>
<span class="line-removed">197         }</span>
<span class="line-removed">198 </span>
199         private Key(String language, String script, String region,
200                     String variant, boolean normalize) {
<span class="line-removed">201             if (language == null) {</span>
<span class="line-removed">202                 language = &quot;&quot;;</span>
<span class="line-removed">203             }</span>
<span class="line-removed">204             if (script == null) {</span>
<span class="line-removed">205                 script = &quot;&quot;;</span>
<span class="line-removed">206             }</span>
<span class="line-removed">207             if (region == null) {</span>
<span class="line-removed">208                 region = &quot;&quot;;</span>
<span class="line-removed">209             }</span>
<span class="line-removed">210             if (variant == null) {</span>
<span class="line-removed">211                 variant = &quot;&quot;;</span>
<span class="line-removed">212             }</span>
<span class="line-removed">213 </span>
214             BaseLocale locale = new BaseLocale(language, script, region, variant, normalize);
215             this.normalized = normalize;
216             if (normalized) {
217                 this.holderRef = new SoftReference&lt;&gt;(locale);
218                 this.holder = null;
219             } else {
220                 this.holderRef = null;
221                 this.holder = locale;
222             }
223             this.hash = hashCode(locale);
224         }
225 
226         public int hashCode() {
227             return hash;
228         }
229 
230         private int hashCode(BaseLocale locale) {
231             int h = 0;
232             String lang = locale.getLanguage();
233             int len = lang.length();
</pre>
<hr />
<pre>
274                 }
275             }
276             return false;
277         }
278 
279         public static Key normalize(Key key) {
280             if (key.normalized) {
281                 return key;
282             }
283 
284             // Only normalized keys may be softly referencing the data holder
285             assert (key.holder != null &amp;&amp; key.holderRef == null);
286             BaseLocale locale = key.holder;
287             return new Key(locale.getLanguage(), locale.getScript(),
288                     locale.getRegion(), locale.getVariant(), true);
289         }
290     }
291 
292     private static class Cache extends LocaleObjectCache&lt;Key, BaseLocale&gt; {
293 


294         public Cache() {
295         }
296 
297         @Override
298         protected Key normalizeKey(Key key) {
299             return Key.normalize(key);
300         }
301 
302         @Override
303         protected BaseLocale createObject(Key key) {
304             return Key.normalize(key).getBaseLocale();
305         }
306     }
307 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  *******************************************************************************
 28  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
 29  * others. All Rights Reserved.                                                *
 30  *******************************************************************************
 31  */
 32 
 33 package sun.util.locale;
 34 
<span class="line-added"> 35 import jdk.internal.misc.VM;</span>
<span class="line-added"> 36 import jdk.internal.vm.annotation.Stable;</span>
<span class="line-added"> 37 </span>
 38 import java.lang.ref.SoftReference;
 39 import java.util.StringJoiner;
 40 
 41 public final class BaseLocale {
 42 
<span class="line-modified"> 43     public static @Stable BaseLocale[] constantBaseLocales;</span>
<span class="line-added"> 44     public static final byte ENGLISH = 0,</span>
<span class="line-added"> 45             FRENCH = 1,</span>
<span class="line-added"> 46             GERMAN = 2,</span>
<span class="line-added"> 47             ITALIAN = 3,</span>
<span class="line-added"> 48             JAPANESE = 4,</span>
<span class="line-added"> 49             KOREAN = 5,</span>
<span class="line-added"> 50             CHINESE = 6,</span>
<span class="line-added"> 51             SIMPLIFIED_CHINESE = 7,</span>
<span class="line-added"> 52             TRADITIONAL_CHINESE = 8,</span>
<span class="line-added"> 53             FRANCE = 9,</span>
<span class="line-added"> 54             GERMANY = 10,</span>
<span class="line-added"> 55             ITALY = 11,</span>
<span class="line-added"> 56             JAPAN = 12,</span>
<span class="line-added"> 57             KOREA = 13,</span>
<span class="line-added"> 58             UK = 14,</span>
<span class="line-added"> 59             US = 15,</span>
<span class="line-added"> 60             CANADA = 16,</span>
<span class="line-added"> 61             CANADA_FRENCH = 17,</span>
<span class="line-added"> 62             ROOT = 18,</span>
<span class="line-added"> 63             NUM_CONSTANTS = 19;</span>
<span class="line-added"> 64     static {</span>
<span class="line-added"> 65         VM.initializeFromArchive(BaseLocale.class);</span>
<span class="line-added"> 66         BaseLocale[] baseLocales = constantBaseLocales;</span>
<span class="line-added"> 67         if (baseLocales == null) {</span>
<span class="line-added"> 68             baseLocales = new BaseLocale[NUM_CONSTANTS];</span>
<span class="line-added"> 69             baseLocales[ENGLISH] = createInstance(&quot;en&quot;, &quot;&quot;);</span>
<span class="line-added"> 70             baseLocales[FRENCH] = createInstance(&quot;fr&quot;, &quot;&quot;);</span>
<span class="line-added"> 71             baseLocales[GERMAN] = createInstance(&quot;de&quot;, &quot;&quot;);</span>
<span class="line-added"> 72             baseLocales[ITALIAN] = createInstance(&quot;it&quot;, &quot;&quot;);</span>
<span class="line-added"> 73             baseLocales[JAPANESE] = createInstance(&quot;ja&quot;, &quot;&quot;);</span>
<span class="line-added"> 74             baseLocales[KOREAN] = createInstance(&quot;ko&quot;, &quot;&quot;);</span>
<span class="line-added"> 75             baseLocales[CHINESE] = createInstance(&quot;zh&quot;, &quot;&quot;);</span>
<span class="line-added"> 76             baseLocales[SIMPLIFIED_CHINESE] = createInstance(&quot;zh&quot;, &quot;CN&quot;);</span>
<span class="line-added"> 77             baseLocales[TRADITIONAL_CHINESE] = createInstance(&quot;zh&quot;, &quot;TW&quot;);</span>
<span class="line-added"> 78             baseLocales[FRANCE] = createInstance(&quot;fr&quot;, &quot;FR&quot;);</span>
<span class="line-added"> 79             baseLocales[GERMANY] = createInstance(&quot;de&quot;, &quot;DE&quot;);</span>
<span class="line-added"> 80             baseLocales[ITALY] = createInstance(&quot;it&quot;, &quot;IT&quot;);</span>
<span class="line-added"> 81             baseLocales[JAPAN] = createInstance(&quot;ja&quot;, &quot;JP&quot;);</span>
<span class="line-added"> 82             baseLocales[KOREA] = createInstance(&quot;ko&quot;, &quot;KR&quot;);</span>
<span class="line-added"> 83             baseLocales[UK] = createInstance(&quot;en&quot;, &quot;GB&quot;);</span>
<span class="line-added"> 84             baseLocales[US] = createInstance(&quot;en&quot;, &quot;US&quot;);</span>
<span class="line-added"> 85             baseLocales[CANADA] = createInstance(&quot;en&quot;, &quot;CA&quot;);</span>
<span class="line-added"> 86             baseLocales[CANADA_FRENCH] = createInstance(&quot;fr&quot;, &quot;CA&quot;);</span>
<span class="line-added"> 87             baseLocales[ROOT] = createInstance(&quot;&quot;, &quot;&quot;);</span>
<span class="line-added"> 88             constantBaseLocales = baseLocales;</span>
<span class="line-added"> 89         }</span>
<span class="line-added"> 90     }</span>
 91 
<span class="line-modified"> 92     public static final String SEP = &quot;_&quot;;</span>
 93 
 94     private final String language;
 95     private final String script;
 96     private final String region;
 97     private final String variant;
 98 
 99     private volatile int hash;
100 
101     // This method must be called with normalize = false only when creating the
102     // Locale.* constants and non-normalized BaseLocale$Keys used for lookup.
103     private BaseLocale(String language, String script, String region, String variant,
104                        boolean normalize) {
105         if (normalize) {
106             this.language = LocaleUtils.toLowerString(language).intern();
107             this.script = LocaleUtils.toTitleString(script).intern();
108             this.region = LocaleUtils.toUpperString(region).intern();
109             this.variant = variant.intern();
110         } else {
111             this.language = language;
112             this.script = script;
113             this.region = region;
114             this.variant = variant;
115         }
116     }
117 
118     // Called for creating the Locale.* constants. No argument
119     // validation is performed.
<span class="line-modified">120     private static BaseLocale createInstance(String language, String region) {</span>
<span class="line-modified">121         return new BaseLocale(language, &quot;&quot;, region, &quot;&quot;, false);</span>


122     }
123 
124     public static BaseLocale getInstance(String language, String script,
125                                          String region, String variant) {
<span class="line-added">126 </span>
<span class="line-added">127         if (script == null) {</span>
<span class="line-added">128             script = &quot;&quot;;</span>
<span class="line-added">129         }</span>
<span class="line-added">130         if (region == null) {</span>
<span class="line-added">131             region = &quot;&quot;;</span>
<span class="line-added">132         }</span>
<span class="line-added">133         if (language == null) {</span>
<span class="line-added">134             language = null;</span>
<span class="line-added">135         }</span>
<span class="line-added">136         if (variant == null) {</span>
<span class="line-added">137             variant = &quot;&quot;;</span>
<span class="line-added">138         }</span>
<span class="line-added">139 </span>
<span class="line-added">140         // Non-allocating for most uses</span>
<span class="line-added">141         language = LocaleUtils.toLowerString(language);</span>
<span class="line-added">142         region = LocaleUtils.toUpperString(region);</span>
<span class="line-added">143 </span>
<span class="line-added">144         // Check for constant base locales first</span>
<span class="line-added">145         if (script.isEmpty() &amp;&amp; variant.isEmpty()) {</span>
<span class="line-added">146             for (BaseLocale baseLocale : constantBaseLocales) {</span>
<span class="line-added">147                 if (baseLocale.getLanguage().equals(language)</span>
<span class="line-added">148                         &amp;&amp; baseLocale.getRegion().equals(region)) {</span>
<span class="line-added">149                     return baseLocale;</span>
<span class="line-added">150                 }</span>
<span class="line-added">151             }</span>
<span class="line-added">152         }</span>
<span class="line-added">153 </span>
154         // JDK uses deprecated ISO639.1 language codes for he, yi and id
<span class="line-modified">155         if (!language.isEmpty()) {</span>
<span class="line-modified">156             if (language.equals(&quot;he&quot;)) {</span>
157                 language = &quot;iw&quot;;
<span class="line-modified">158             } else if (language.equals(&quot;yi&quot;)) {</span>
159                 language = &quot;ji&quot;;
<span class="line-modified">160             } else if (language.equals(&quot;id&quot;)) {</span>
161                 language = &quot;in&quot;;
162             }
163         }
164 
165         Key key = new Key(language, script, region, variant, false);
<span class="line-modified">166         return Cache.CACHE.get(key);</span>

167     }
168 
169     public String getLanguage() {
170         return language;
171     }
172 
173     public String getScript() {
174         return script;
175     }
176 
177     public String getRegion() {
178         return region;
179     }
180 
181     public String getVariant() {
182         return variant;
183     }
184 
185     @Override
186     public boolean equals(Object obj) {
</pre>
<hr />
<pre>
229             }
230         }
231         return h;
232     }
233 
234     private static final class Key {
235         /**
236          * Keep a SoftReference to the Key data if normalized (actually used
237          * as a cache key) and not initialized via the constant creation path.
238          *
239          * This allows us to avoid creating SoftReferences on lookup Keys
240          * (which are short-lived) and for Locales created via
241          * Locale#createConstant.
242          */
243         private final SoftReference&lt;BaseLocale&gt; holderRef;
244         private final BaseLocale holder;
245 
246         private final boolean normalized;
247         private final int hash;
248 

























249         private Key(String language, String script, String region,
250                     String variant, boolean normalize) {













251             BaseLocale locale = new BaseLocale(language, script, region, variant, normalize);
252             this.normalized = normalize;
253             if (normalized) {
254                 this.holderRef = new SoftReference&lt;&gt;(locale);
255                 this.holder = null;
256             } else {
257                 this.holderRef = null;
258                 this.holder = locale;
259             }
260             this.hash = hashCode(locale);
261         }
262 
263         public int hashCode() {
264             return hash;
265         }
266 
267         private int hashCode(BaseLocale locale) {
268             int h = 0;
269             String lang = locale.getLanguage();
270             int len = lang.length();
</pre>
<hr />
<pre>
311                 }
312             }
313             return false;
314         }
315 
316         public static Key normalize(Key key) {
317             if (key.normalized) {
318                 return key;
319             }
320 
321             // Only normalized keys may be softly referencing the data holder
322             assert (key.holder != null &amp;&amp; key.holderRef == null);
323             BaseLocale locale = key.holder;
324             return new Key(locale.getLanguage(), locale.getScript(),
325                     locale.getRegion(), locale.getVariant(), true);
326         }
327     }
328 
329     private static class Cache extends LocaleObjectCache&lt;Key, BaseLocale&gt; {
330 
<span class="line-added">331         private static final Cache CACHE = new Cache();</span>
<span class="line-added">332 </span>
333         public Cache() {
334         }
335 
336         @Override
337         protected Key normalizeKey(Key key) {
338             return Key.normalize(key);
339         }
340 
341         @Override
342         protected BaseLocale createObject(Key key) {
343             return Key.normalize(key).getBaseLocale();
344         }
345     }
346 }
</pre>
</td>
</tr>
</table>
<center><a href="../cldr/CLDRTimeZoneNameProviderImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="LocaleSyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
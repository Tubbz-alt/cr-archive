<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/x509/AVA.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../validator/ValidatorException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AccessDescription.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/x509/AVA.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.OutputStream;
  31 import java.io.Reader;
  32 import java.security.AccessController;
  33 import java.text.Normalizer;
  34 import java.util.*;
  35 


  36 import sun.security.action.GetBooleanAction;
  37 import sun.security.util.*;
  38 import sun.security.pkcs.PKCS9Attribute;
  39 
  40 
  41 /**
  42  * X.500 Attribute-Value-Assertion (AVA):  an attribute, as identified by
  43  * some attribute ID, has some particular value.  Values are as a rule ASN.1
  44  * printable strings.  A conventional set of type IDs is recognized when
  45  * parsing (and generating) RFC 1779, 2253 or 4514 syntax strings.
  46  *
  47  * &lt;P&gt;AVAs are components of X.500 relative names.  Think of them as being
  48  * individual fields of a database record.  The attribute ID is how you
  49  * identify the field, and the value is part of a particular record.
  50  * &lt;p&gt;
  51  * Note that instances of this class are immutable.
  52  *
  53  * @see X500Name
  54  * @see RDN
  55  *
</pre>
<hr />
<pre>
 508 
 509     private static Byte getEmbeddedHexPair(int c1, Reader in)
 510         throws IOException {
 511 
 512         if (hexDigits.indexOf(Character.toUpperCase((char)c1)) &gt;= 0) {
 513             int c2 = readChar(in, &quot;unexpected EOF - &quot; +
 514                         &quot;escaped hex value must include two valid digits&quot;);
 515 
 516             if (hexDigits.indexOf(Character.toUpperCase((char)c2)) &gt;= 0) {
 517                 int hi = Character.digit((char)c1, 16);
 518                 int lo = Character.digit((char)c2, 16);
 519                 return (byte)((hi&lt;&lt;4) + lo);
 520             } else {
 521                 throw new IOException
 522                         (&quot;escaped hex value must include two valid digits&quot;);
 523             }
 524         }
 525         return null;
 526     }
 527 
<span class="line-modified"> 528     private static String getEmbeddedHexString(List&lt;Byte&gt; hexList)</span>
<span class="line-removed"> 529                                                 throws IOException {</span>
 530         int n = hexList.size();
 531         byte[] hexBytes = new byte[n];
 532         for (int i = 0; i &lt; n; i++) {
<span class="line-modified"> 533                 hexBytes[i] = hexList.get(i).byteValue();</span>
 534         }
<span class="line-modified"> 535         return new String(hexBytes, &quot;UTF8&quot;);</span>
 536     }
 537 
 538     private static boolean isTerminator(int ch, int format) {
 539         switch (ch) {
 540         case -1:
 541         case &#39;+&#39;:
 542         case &#39;,&#39;:
 543             return true;
 544         case &#39;;&#39;:
 545             return format != RFC2253;
 546         default:
 547             return false;
 548         }
 549     }
 550 
 551     private static int readChar(Reader in, String errMsg) throws IOException {
 552         int c = in.read();
 553         if (c == -1) {
 554             throw new IOException(errMsg);
 555         }
</pre>
<hr />
<pre>
 581                         trailing = false;
 582                         break;
 583                     }
 584                 } else {
 585                     trailing = false;
 586                     break;
 587                 }
 588             }
 589 
 590             in.reset();
 591             return trailing;
 592         }
 593     }
 594 
 595     AVA(DerValue derval) throws IOException {
 596         // Individual attribute value assertions are SEQUENCE of two values.
 597         // That&#39;d be a &quot;struct&quot; outside of ASN.1.
 598         if (derval.tag != DerValue.tag_Sequence) {
 599             throw new IOException(&quot;AVA not a sequence&quot;);
 600         }
<span class="line-modified"> 601         oid = X500Name.intern(derval.data.getOID());</span>
 602         value = derval.data.getDerValue();
 603 
 604         if (derval.data.available() != 0) {
 605             throw new IOException(&quot;AVA, extra bytes = &quot;
 606                 + derval.data.available());
 607         }
 608     }
 609 
 610     AVA(DerInputStream in) throws IOException {
 611         this(in.getDerValue());
 612     }
 613 
 614     public boolean equals(Object obj) {
 615         if (this == obj) {
 616             return true;
 617         }
 618         if (obj instanceof AVA == false) {
 619             return false;
 620         }
 621         AVA other = (AVA)obj;
</pre>
<hr />
<pre>
 735             } catch (IOException ie) {
 736                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 737             }
 738             typeAndValue.append(&#39;#&#39;);
 739             for (int j = 0; j &lt; data.length; j++) {
 740                 byte b = data[j];
 741                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 742                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 743             }
 744         } else {
 745             /*
 746              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 747              * has a string representation, the value is converted first to a
 748              * UTF-8 string according to its syntax specification.
 749              *
 750              * NOTE: this implementation only emits DirectoryStrings of the
 751              * types returned by isDerString().
 752              */
 753             String valStr = null;
 754             try {
<span class="line-modified"> 755                 valStr = new String(value.getDataBytes(), &quot;UTF8&quot;);</span>
 756             } catch (IOException ie) {
 757                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 758             }
 759 
 760             /*
 761              * 2.4 (cont): If the UTF-8 string does not have any of the
 762              * following characters which need escaping, then that string can be
 763              * used as the string representation of the value.
 764              *
 765              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 766              *       string
 767              *   o   a space character occurring at the end of the string
 768              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 769              *
 770              * Implementations MAY escape other characters.
 771              *
 772              * NOTE: this implementation also recognizes &quot;=&quot; and &quot;#&quot; as
 773              * characters which need escaping, and null which is escaped as
 774              * &#39;\00&#39; (see RFC 4514).
 775              *
</pre>
<hr />
<pre>
 787                 char c = valStr.charAt(i);
 788                 if (DerValue.isPrintableStringChar(c) ||
 789                     escapees.indexOf(c) &gt;= 0) {
 790 
 791                     // escape escapees
 792                     if (escapees.indexOf(c) &gt;= 0) {
 793                         sbuffer.append(&#39;\\&#39;);
 794                     }
 795 
 796                     // append printable/escaped char
 797                     sbuffer.append(c);
 798 
 799                 } else if (c == &#39;\u0000&#39;) {
 800                     // escape null character
 801                     sbuffer.append(&quot;\\00&quot;);
 802 
 803                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 804 
 805                     // embed non-printable/non-escaped char
 806                     // as escaped hex pairs for debugging
<span class="line-modified"> 807                     byte[] valueBytes = null;</span>
<span class="line-removed"> 808                     try {</span>
<span class="line-removed"> 809                         valueBytes = Character.toString(c).getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed"> 810                     } catch (IOException ie) {</span>
<span class="line-removed"> 811                         throw new IllegalArgumentException</span>
<span class="line-removed"> 812                                         (&quot;DER Value conversion&quot;);</span>
<span class="line-removed"> 813                     }</span>
 814                     for (int j = 0; j &lt; valueBytes.length; j++) {
 815                         sbuffer.append(&#39;\\&#39;);
 816                         char hexChar = Character.forDigit
 817                                 (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
 818                         sbuffer.append(Character.toUpperCase(hexChar));
 819                         hexChar = Character.forDigit
 820                                 (0xF &amp; (valueBytes[j]), 16);
 821                         sbuffer.append(Character.toUpperCase(hexChar));
 822                     }
 823                 } else {
 824 
 825                     // append non-printable/non-escaped char
 826                     sbuffer.append(c);
 827                 }
 828             }
 829 
 830             char[] chars = sbuffer.toString().toCharArray();
 831             sbuffer = new StringBuilder();
 832 
 833             // Find leading and trailing whitespace.
</pre>
<hr />
<pre>
 888             } catch (IOException ie) {
 889                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 890             }
 891             typeAndValue.append(&#39;#&#39;);
 892             for (int j = 0; j &lt; data.length; j++) {
 893                 byte b = data[j];
 894                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 895                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 896             }
 897         } else {
 898             /*
 899              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 900              * has a string representation, the value is converted first to a
 901              * UTF-8 string according to its syntax specification.
 902              *
 903              * NOTE: this implementation only emits DirectoryStrings of the
 904              * types returned by isDerString().
 905              */
 906             String valStr = null;
 907             try {
<span class="line-modified"> 908                 valStr = new String(value.getDataBytes(), &quot;UTF8&quot;);</span>
 909             } catch (IOException ie) {
 910                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 911             }
 912 
 913             /*
 914              * 2.4 (cont): If the UTF-8 string does not have any of the
 915              * following characters which need escaping, then that string can be
 916              * used as the string representation of the value.
 917              *
 918              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 919              *       string
 920              *   o   a space character occurring at the end of the string
 921              *
 922              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 923              *
 924              * If a character to be escaped is one of the list shown above, then
 925              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 926              *
 927              * Otherwise the character to be escaped is replaced by a backslash
 928              * and two hex digits, which form a single byte in the code of the
</pre>
<hr />
<pre>
 949                         previousWhite = false;
 950                         sbuffer.append(c);
 951                     } else {
 952                         if (previousWhite == false) {
 953                             // add single whitespace
 954                             previousWhite = true;
 955                             sbuffer.append(c);
 956                         } else {
 957                             // ignore subsequent consecutive whitespace
 958                             continue;
 959                         }
 960                     }
 961 
 962                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 963 
 964                     // embed non-printable/non-escaped char
 965                     // as escaped hex pairs for debugging
 966 
 967                     previousWhite = false;
 968 
<span class="line-modified"> 969                     byte[] valueBytes = null;</span>
<span class="line-removed"> 970                     try {</span>
<span class="line-removed"> 971                         valueBytes = Character.toString(c).getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed"> 972                     } catch (IOException ie) {</span>
<span class="line-removed"> 973                         throw new IllegalArgumentException</span>
<span class="line-removed"> 974                                         (&quot;DER Value conversion&quot;);</span>
<span class="line-removed"> 975                     }</span>
 976                     for (int j = 0; j &lt; valueBytes.length; j++) {
 977                         sbuffer.append(&#39;\\&#39;);
 978                         sbuffer.append(Character.forDigit
 979                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16));
 980                         sbuffer.append(Character.forDigit
 981                                         (0xF &amp; (valueBytes[j]), 16));
 982                     }
 983                 } else {
 984 
 985                     // append non-printable/non-escaped char
 986 
 987                     previousWhite = false;
 988                     sbuffer.append(c);
 989                 }
 990             }
 991 
 992             // remove leading and trailing whitespace from value
 993             typeAndValue.append(sbuffer.toString().trim());
 994         }
 995 
</pre>
<hr />
<pre>
1099                             }
1100                             previousWhite = false;
1101                         } else {
1102                             if (!quoteNeeded &amp;&amp; previousWhite) {
1103                                 quoteNeeded = true;
1104                             }
1105                             previousWhite = true;
1106                         }
1107 
1108                         sbuffer.append(c);
1109 
1110                     } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
1111 
1112                         // embed non-printable/non-escaped char
1113                         // as escaped hex pairs for debugging
1114 
1115                         previousWhite = false;
1116 
1117                         // embed escaped hex pairs
1118                         byte[] valueBytes =
<span class="line-modified">1119                                 Character.toString(c).getBytes(&quot;UTF8&quot;);</span>
1120                         for (int j = 0; j &lt; valueBytes.length; j++) {
1121                             sbuffer.append(&#39;\\&#39;);
1122                             char hexChar = Character.forDigit
1123                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
1124                             sbuffer.append(Character.toUpperCase(hexChar));
1125                             hexChar = Character.forDigit
1126                                         (0xF &amp; (valueBytes[j]), 16);
1127                             sbuffer.append(Character.toUpperCase(hexChar));
1128                         }
1129                     } else {
1130 
1131                         // append non-printable/non-escaped char
1132 
1133                         previousWhite = false;
1134                         sbuffer.append(c);
1135                     }
1136                 }
1137 
1138                 // quote if trailing whitespace
1139                 if (sbuffer.length() &gt; 0) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.OutputStream;
  31 import java.io.Reader;
  32 import java.security.AccessController;
  33 import java.text.Normalizer;
  34 import java.util.*;
  35 
<span class="line-added">  36 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added">  37 </span>
  38 import sun.security.action.GetBooleanAction;
  39 import sun.security.util.*;
  40 import sun.security.pkcs.PKCS9Attribute;
  41 
  42 
  43 /**
  44  * X.500 Attribute-Value-Assertion (AVA):  an attribute, as identified by
  45  * some attribute ID, has some particular value.  Values are as a rule ASN.1
  46  * printable strings.  A conventional set of type IDs is recognized when
  47  * parsing (and generating) RFC 1779, 2253 or 4514 syntax strings.
  48  *
  49  * &lt;P&gt;AVAs are components of X.500 relative names.  Think of them as being
  50  * individual fields of a database record.  The attribute ID is how you
  51  * identify the field, and the value is part of a particular record.
  52  * &lt;p&gt;
  53  * Note that instances of this class are immutable.
  54  *
  55  * @see X500Name
  56  * @see RDN
  57  *
</pre>
<hr />
<pre>
 510 
 511     private static Byte getEmbeddedHexPair(int c1, Reader in)
 512         throws IOException {
 513 
 514         if (hexDigits.indexOf(Character.toUpperCase((char)c1)) &gt;= 0) {
 515             int c2 = readChar(in, &quot;unexpected EOF - &quot; +
 516                         &quot;escaped hex value must include two valid digits&quot;);
 517 
 518             if (hexDigits.indexOf(Character.toUpperCase((char)c2)) &gt;= 0) {
 519                 int hi = Character.digit((char)c1, 16);
 520                 int lo = Character.digit((char)c2, 16);
 521                 return (byte)((hi&lt;&lt;4) + lo);
 522             } else {
 523                 throw new IOException
 524                         (&quot;escaped hex value must include two valid digits&quot;);
 525             }
 526         }
 527         return null;
 528     }
 529 
<span class="line-modified"> 530     private static String getEmbeddedHexString(List&lt;Byte&gt; hexList) {</span>

 531         int n = hexList.size();
 532         byte[] hexBytes = new byte[n];
 533         for (int i = 0; i &lt; n; i++) {
<span class="line-modified"> 534             hexBytes[i] = hexList.get(i).byteValue();</span>
 535         }
<span class="line-modified"> 536         return new String(hexBytes, UTF_8);</span>
 537     }
 538 
 539     private static boolean isTerminator(int ch, int format) {
 540         switch (ch) {
 541         case -1:
 542         case &#39;+&#39;:
 543         case &#39;,&#39;:
 544             return true;
 545         case &#39;;&#39;:
 546             return format != RFC2253;
 547         default:
 548             return false;
 549         }
 550     }
 551 
 552     private static int readChar(Reader in, String errMsg) throws IOException {
 553         int c = in.read();
 554         if (c == -1) {
 555             throw new IOException(errMsg);
 556         }
</pre>
<hr />
<pre>
 582                         trailing = false;
 583                         break;
 584                     }
 585                 } else {
 586                     trailing = false;
 587                     break;
 588                 }
 589             }
 590 
 591             in.reset();
 592             return trailing;
 593         }
 594     }
 595 
 596     AVA(DerValue derval) throws IOException {
 597         // Individual attribute value assertions are SEQUENCE of two values.
 598         // That&#39;d be a &quot;struct&quot; outside of ASN.1.
 599         if (derval.tag != DerValue.tag_Sequence) {
 600             throw new IOException(&quot;AVA not a sequence&quot;);
 601         }
<span class="line-modified"> 602         oid = derval.data.getOID();</span>
 603         value = derval.data.getDerValue();
 604 
 605         if (derval.data.available() != 0) {
 606             throw new IOException(&quot;AVA, extra bytes = &quot;
 607                 + derval.data.available());
 608         }
 609     }
 610 
 611     AVA(DerInputStream in) throws IOException {
 612         this(in.getDerValue());
 613     }
 614 
 615     public boolean equals(Object obj) {
 616         if (this == obj) {
 617             return true;
 618         }
 619         if (obj instanceof AVA == false) {
 620             return false;
 621         }
 622         AVA other = (AVA)obj;
</pre>
<hr />
<pre>
 736             } catch (IOException ie) {
 737                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 738             }
 739             typeAndValue.append(&#39;#&#39;);
 740             for (int j = 0; j &lt; data.length; j++) {
 741                 byte b = data[j];
 742                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 743                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 744             }
 745         } else {
 746             /*
 747              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 748              * has a string representation, the value is converted first to a
 749              * UTF-8 string according to its syntax specification.
 750              *
 751              * NOTE: this implementation only emits DirectoryStrings of the
 752              * types returned by isDerString().
 753              */
 754             String valStr = null;
 755             try {
<span class="line-modified"> 756                 valStr = new String(value.getDataBytes(), UTF_8);</span>
 757             } catch (IOException ie) {
 758                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 759             }
 760 
 761             /*
 762              * 2.4 (cont): If the UTF-8 string does not have any of the
 763              * following characters which need escaping, then that string can be
 764              * used as the string representation of the value.
 765              *
 766              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 767              *       string
 768              *   o   a space character occurring at the end of the string
 769              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 770              *
 771              * Implementations MAY escape other characters.
 772              *
 773              * NOTE: this implementation also recognizes &quot;=&quot; and &quot;#&quot; as
 774              * characters which need escaping, and null which is escaped as
 775              * &#39;\00&#39; (see RFC 4514).
 776              *
</pre>
<hr />
<pre>
 788                 char c = valStr.charAt(i);
 789                 if (DerValue.isPrintableStringChar(c) ||
 790                     escapees.indexOf(c) &gt;= 0) {
 791 
 792                     // escape escapees
 793                     if (escapees.indexOf(c) &gt;= 0) {
 794                         sbuffer.append(&#39;\\&#39;);
 795                     }
 796 
 797                     // append printable/escaped char
 798                     sbuffer.append(c);
 799 
 800                 } else if (c == &#39;\u0000&#39;) {
 801                     // escape null character
 802                     sbuffer.append(&quot;\\00&quot;);
 803 
 804                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 805 
 806                     // embed non-printable/non-escaped char
 807                     // as escaped hex pairs for debugging
<span class="line-modified"> 808                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);</span>






 809                     for (int j = 0; j &lt; valueBytes.length; j++) {
 810                         sbuffer.append(&#39;\\&#39;);
 811                         char hexChar = Character.forDigit
 812                                 (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
 813                         sbuffer.append(Character.toUpperCase(hexChar));
 814                         hexChar = Character.forDigit
 815                                 (0xF &amp; (valueBytes[j]), 16);
 816                         sbuffer.append(Character.toUpperCase(hexChar));
 817                     }
 818                 } else {
 819 
 820                     // append non-printable/non-escaped char
 821                     sbuffer.append(c);
 822                 }
 823             }
 824 
 825             char[] chars = sbuffer.toString().toCharArray();
 826             sbuffer = new StringBuilder();
 827 
 828             // Find leading and trailing whitespace.
</pre>
<hr />
<pre>
 883             } catch (IOException ie) {
 884                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 885             }
 886             typeAndValue.append(&#39;#&#39;);
 887             for (int j = 0; j &lt; data.length; j++) {
 888                 byte b = data[j];
 889                 typeAndValue.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));
 890                 typeAndValue.append(Character.forDigit(0xF &amp; b, 16));
 891             }
 892         } else {
 893             /*
 894              * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
 895              * has a string representation, the value is converted first to a
 896              * UTF-8 string according to its syntax specification.
 897              *
 898              * NOTE: this implementation only emits DirectoryStrings of the
 899              * types returned by isDerString().
 900              */
 901             String valStr = null;
 902             try {
<span class="line-modified"> 903                 valStr = new String(value.getDataBytes(), UTF_8);</span>
 904             } catch (IOException ie) {
 905                 throw new IllegalArgumentException(&quot;DER Value conversion&quot;);
 906             }
 907 
 908             /*
 909              * 2.4 (cont): If the UTF-8 string does not have any of the
 910              * following characters which need escaping, then that string can be
 911              * used as the string representation of the value.
 912              *
 913              *   o   a space or &quot;#&quot; character occurring at the beginning of the
 914              *       string
 915              *   o   a space character occurring at the end of the string
 916              *
 917              *   o   one of the characters &quot;,&quot;, &quot;+&quot;, &quot;&quot;&quot;, &quot;\&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; or &quot;;&quot;
 918              *
 919              * If a character to be escaped is one of the list shown above, then
 920              * it is prefixed by a backslash (&#39;\&#39; ASCII 92).
 921              *
 922              * Otherwise the character to be escaped is replaced by a backslash
 923              * and two hex digits, which form a single byte in the code of the
</pre>
<hr />
<pre>
 944                         previousWhite = false;
 945                         sbuffer.append(c);
 946                     } else {
 947                         if (previousWhite == false) {
 948                             // add single whitespace
 949                             previousWhite = true;
 950                             sbuffer.append(c);
 951                         } else {
 952                             // ignore subsequent consecutive whitespace
 953                             continue;
 954                         }
 955                     }
 956 
 957                 } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
 958 
 959                     // embed non-printable/non-escaped char
 960                     // as escaped hex pairs for debugging
 961 
 962                     previousWhite = false;
 963 
<span class="line-modified"> 964                     byte[] valueBytes = Character.toString(c).getBytes(UTF_8);</span>






 965                     for (int j = 0; j &lt; valueBytes.length; j++) {
 966                         sbuffer.append(&#39;\\&#39;);
 967                         sbuffer.append(Character.forDigit
 968                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16));
 969                         sbuffer.append(Character.forDigit
 970                                         (0xF &amp; (valueBytes[j]), 16));
 971                     }
 972                 } else {
 973 
 974                     // append non-printable/non-escaped char
 975 
 976                     previousWhite = false;
 977                     sbuffer.append(c);
 978                 }
 979             }
 980 
 981             // remove leading and trailing whitespace from value
 982             typeAndValue.append(sbuffer.toString().trim());
 983         }
 984 
</pre>
<hr />
<pre>
1088                             }
1089                             previousWhite = false;
1090                         } else {
1091                             if (!quoteNeeded &amp;&amp; previousWhite) {
1092                                 quoteNeeded = true;
1093                             }
1094                             previousWhite = true;
1095                         }
1096 
1097                         sbuffer.append(c);
1098 
1099                     } else if (debug != null &amp;&amp; Debug.isOn(&quot;ava&quot;)) {
1100 
1101                         // embed non-printable/non-escaped char
1102                         // as escaped hex pairs for debugging
1103 
1104                         previousWhite = false;
1105 
1106                         // embed escaped hex pairs
1107                         byte[] valueBytes =
<span class="line-modified">1108                                 Character.toString(c).getBytes(UTF_8);</span>
1109                         for (int j = 0; j &lt; valueBytes.length; j++) {
1110                             sbuffer.append(&#39;\\&#39;);
1111                             char hexChar = Character.forDigit
1112                                         (0xF &amp; (valueBytes[j] &gt;&gt;&gt; 4), 16);
1113                             sbuffer.append(Character.toUpperCase(hexChar));
1114                             hexChar = Character.forDigit
1115                                         (0xF &amp; (valueBytes[j]), 16);
1116                             sbuffer.append(Character.toUpperCase(hexChar));
1117                         }
1118                     } else {
1119 
1120                         // append non-printable/non-escaped char
1121 
1122                         previousWhite = false;
1123                         sbuffer.append(c);
1124                     }
1125                 }
1126 
1127                 // quote if trailing whitespace
1128                 if (sbuffer.length() &gt; 0) {
</pre>
</td>
</tr>
</table>
<center><a href="../validator/ValidatorException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="AccessDescription.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
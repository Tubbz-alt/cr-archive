<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/ParseUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessageHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="http/ChunkedInputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/ParseUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www;
 27 
 28 import java.io.File;
<span class="line-removed"> 29 import java.net.URL;</span>
 30 import java.net.MalformedURLException;
 31 import java.net.URI;
 32 import java.net.URISyntaxException;

 33 import java.nio.ByteBuffer;
 34 import java.nio.CharBuffer;
 35 import java.nio.charset.CharacterCodingException;
<span class="line-removed"> 36 </span>
<span class="line-removed"> 37 import sun.nio.cs.ThreadLocalCoders;</span>
 38 import java.nio.charset.CharsetDecoder;
 39 import java.nio.charset.CoderResult;
 40 import java.nio.charset.CodingErrorAction;
 41 



 42 /**
 43  * A class that contains useful routines common to sun.net.www
 44  * @author  Mike McCloskey
 45  */
 46 
 47 public final class ParseUtil {
 48 
 49     private ParseUtil() {}
 50 
 51     /**
 52      * Constructs an encoded version of the specified path string suitable
 53      * for use in the construction of a URL.
 54      *
 55      * A path separator is replaced by a forward slash. The string is UTF8
 56      * encoded. The % escape sequence is used for characters that are above
 57      * 0x7F or those defined in RFC2396 as reserved or excluded in the path
 58      * component of a URL.
 59      */
 60     public static String encodePath(String path) {
 61         return encodePath(path, true);
</pre>
<hr />
<pre>
129                     retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);
130                 }
131             }
132             //worst case scenario for character [0x7ff-] every single
133             //character will be encoded into 9 characters.
134             if (retLen + 9 &gt; retCC.length) {
135                 int newLen = retCC.length * 2 + 16;
136                 if (newLen &lt; 0) {
137                     newLen = Integer.MAX_VALUE;
138                 }
139                 char[] buf = new char[newLen];
140                 System.arraycopy(retCC, 0, buf, 0, retLen);
141                 retCC = buf;
142             }
143         }
144         return new String(retCC, 0, retLen);
145     }
146 
147     /**
148      * Appends the URL escape sequence for the specified char to the
<span class="line-modified">149      * specified StringBuffer.</span>
150      */
151     private static int escape(char[] cc, char c, int index) {
152         cc[index++] = &#39;%&#39;;
153         cc[index++] = Character.forDigit((c &gt;&gt; 4) &amp; 0xF, 16);
154         cc[index++] = Character.forDigit(c &amp; 0xF, 16);
155         return index;
156     }
157 
158     /**
159      * Un-escape and return the character at position i in string s.
160      */
161     private static byte unescape(String s, int i) {
162         return (byte) Integer.parseInt(s, i + 1, i + 3, 16);
163     }
164 
165 
166     /**
167      * Returns a new String constructed from the specified String by replacing
168      * the URL escape sequences and UTF8 encoding with the characters they
169      * represent.
170      */
171     public static String decode(String s) {
172         int n = s.length();
173         if ((n == 0) || (s.indexOf(&#39;%&#39;) &lt; 0))
174             return s;
175 
176         StringBuilder sb = new StringBuilder(n);
177         ByteBuffer bb = ByteBuffer.allocate(n);
178         CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">179         CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)</span>
180             .onMalformedInput(CodingErrorAction.REPORT)
181             .onUnmappableCharacter(CodingErrorAction.REPORT);
182 
183         char c = s.charAt(0);
184         for (int i = 0; i &lt; n;) {
185             assert c == s.charAt(i);
186             if (c != &#39;%&#39;) {
187                 sb.append(c);
188                 if (++i &gt;= n)
189                     break;
190                 c = s.charAt(i);
191                 continue;
192             }
193             bb.clear();
194             int ui = i;
195             for (;;) {
196                 assert (n - i &gt;= 2);
197                 try {
198                     bb.put(unescape(s, i));
199                 } catch (NumberFormatException e) {
</pre>
<hr />
<pre>
319                                  String query,
320                                  String fragment) throws URISyntaxException
321     {
322         String s = toString(scheme, null,
323                             authority, null, null, -1,
324                             path, query, fragment);
325         checkPath(s, scheme, path);
326         return new URI(s);
327     }
328 
329     private static String toString(String scheme,
330                             String opaquePart,
331                             String authority,
332                             String userInfo,
333                             String host,
334                             int port,
335                             String path,
336                             String query,
337                             String fragment)
338     {
<span class="line-modified">339         StringBuffer sb = new StringBuffer();</span>
340         if (scheme != null) {
341             sb.append(scheme);
342             sb.append(&#39;:&#39;);
343         }
344         appendSchemeSpecificPart(sb, opaquePart,
345                                  authority, userInfo, host, port,
346                                  path, query);
347         appendFragment(sb, fragment);
348         return sb.toString();
349     }
350 
<span class="line-modified">351     private static void appendSchemeSpecificPart(StringBuffer sb,</span>
352                                           String opaquePart,
353                                           String authority,
354                                           String userInfo,
355                                           String host,
356                                           int port,
357                                           String path,
358                                           String query)
359     {
360         if (opaquePart != null) {
361             /* check if SSP begins with an IPv6 address
362              * because we must not quote a literal IPv6 address
363              */
364             if (opaquePart.startsWith(&quot;//[&quot;)) {
365                 int end =  opaquePart.indexOf(&#39;]&#39;);
366                 if (end != -1 &amp;&amp; opaquePart.indexOf(&#39;:&#39;)!=-1) {
367                     String doquote, dontquote;
368                     if (end == opaquePart.length()) {
369                         dontquote = opaquePart;
370                         doquote = &quot;&quot;;
371                     } else {
372                         dontquote = opaquePart.substring(0,end+1);
373                         doquote = opaquePart.substring(end+1);
374                     }
375                     sb.append (dontquote);
376                     sb.append(quote(doquote, L_URIC, H_URIC));
377                 }
378             } else {
379                 sb.append(quote(opaquePart, L_URIC, H_URIC));
380             }
381         } else {
382             appendAuthority(sb, authority, userInfo, host, port);
383             if (path != null)
384                 sb.append(quote(path, L_PATH, H_PATH));
385             if (query != null) {
386                 sb.append(&#39;?&#39;);
387                 sb.append(quote(query, L_URIC, H_URIC));
388             }
389         }
390     }
391 
<span class="line-modified">392     private static void appendAuthority(StringBuffer sb,</span>
393                                  String authority,
394                                  String userInfo,
395                                  String host,
396                                  int port)
397     {
398         if (host != null) {
399             sb.append(&quot;//&quot;);
400             if (userInfo != null) {
401                 sb.append(quote(userInfo, L_USERINFO, H_USERINFO));
402                 sb.append(&#39;@&#39;);
403             }
404             boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)
405                                     &amp;&amp; !host.startsWith(&quot;[&quot;)
406                                     &amp;&amp; !host.endsWith(&quot;]&quot;));
407             if (needBrackets) sb.append(&#39;[&#39;);
408             sb.append(host);
409             if (needBrackets) sb.append(&#39;]&#39;);
410             if (port != -1) {
411                 sb.append(&#39;:&#39;);
412                 sb.append(port);
</pre>
<hr />
<pre>
420                     if (end == authority.length()) {
421                         dontquote = authority;
422                         doquote = &quot;&quot;;
423                     } else {
424                         dontquote = authority.substring(0,end+1);
425                         doquote = authority.substring(end+1);
426                     }
427                     sb.append (dontquote);
428                     sb.append(quote(doquote,
429                             L_REG_NAME | L_SERVER,
430                             H_REG_NAME | H_SERVER));
431                 }
432             } else {
433                 sb.append(quote(authority,
434                             L_REG_NAME | L_SERVER,
435                             H_REG_NAME | H_SERVER));
436             }
437         }
438     }
439 
<span class="line-modified">440     private static void appendFragment(StringBuffer sb, String fragment) {</span>
441         if (fragment != null) {
442             sb.append(&#39;#&#39;);
443             sb.append(quote(fragment, L_URIC, H_URIC));
444         }
445     }
446 
447     // Quote any characters in s that are not permitted
448     // by the given mask pair
449     //
450     private static String quote(String s, long lowMask, long highMask) {
451         int n = s.length();
<span class="line-modified">452         StringBuffer sb = null;</span>
453         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
454         for (int i = 0; i &lt; s.length(); i++) {
455             char c = s.charAt(i);
456             if (c &lt; &#39;\u0080&#39;) {
457                 if (!match(c, lowMask, highMask) &amp;&amp; !isEscaped(s, i)) {
458                     if (sb == null) {
<span class="line-modified">459                         sb = new StringBuffer();</span>
460                         sb.append(s, 0, i);
461                     }
462                     appendEscape(sb, (byte)c);
463                 } else {
464                     if (sb != null)
465                         sb.append(c);
466                 }
467             } else if (allowNonASCII
468                        &amp;&amp; (Character.isSpaceChar(c)
469                            || Character.isISOControl(c))) {
470                 if (sb == null) {
<span class="line-modified">471                     sb = new StringBuffer();</span>
472                     sb.append(s, 0, i);
473                 }
474                 appendEncoded(sb, c);
475             } else {
476                 if (sb != null)
477                     sb.append(c);
478             }
479         }
480         return (sb == null) ? s : sb.toString();
481     }
482 
483     //
484     // To check if the given string has an escaped triplet
485     // at the given position
486     //
487     private static boolean isEscaped(String s, int pos) {
488         if (s == null || (s.length() &lt;= (pos + 2)))
489             return false;
490 
491         return s.charAt(pos) == &#39;%&#39;
492                &amp;&amp; match(s.charAt(pos + 1), L_HEX, H_HEX)
493                &amp;&amp; match(s.charAt(pos + 2), L_HEX, H_HEX);
494     }
495 
<span class="line-modified">496     private static void appendEncoded(StringBuffer sb, char c) {</span>
497         ByteBuffer bb = null;
498         try {
<span class="line-modified">499             bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
500                 .encode(CharBuffer.wrap(&quot;&quot; + c));
501         } catch (CharacterCodingException x) {
502             assert false;
503         }
504         while (bb.hasRemaining()) {
505             int b = bb.get() &amp; 0xff;
506             if (b &gt;= 0x80)
507                 appendEscape(sb, (byte)b);
508             else
509                 sb.append((char)b);
510         }
511     }
512 
513     private static final char[] hexDigits = {
514         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
515         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
516     };
517 
<span class="line-modified">518     private static void appendEscape(StringBuffer sb, byte b) {</span>
519         sb.append(&#39;%&#39;);
520         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
521         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
522     }
523 
524     // Tell whether the given character is permitted by the given mask pair
525     private static boolean match(char c, long lowMask, long highMask) {
526         if (c &lt; 64)
527             return ((1L &lt;&lt; c) &amp; lowMask) != 0;
528         if (c &lt; 128)
529             return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;
530         return false;
531     }
532 
533     // If a scheme is given then the path, if given, must be absolute
534     //
535     private static void checkPath(String s, String scheme, String path)
536         throws URISyntaxException
537     {
538         if (scheme != null) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www;
 27 
 28 import java.io.File;

 29 import java.net.MalformedURLException;
 30 import java.net.URI;
 31 import java.net.URISyntaxException;
<span class="line-added"> 32 import java.net.URL;</span>
 33 import java.nio.ByteBuffer;
 34 import java.nio.CharBuffer;
 35 import java.nio.charset.CharacterCodingException;


 36 import java.nio.charset.CharsetDecoder;
 37 import java.nio.charset.CoderResult;
 38 import java.nio.charset.CodingErrorAction;
 39 
<span class="line-added"> 40 import sun.nio.cs.ThreadLocalCoders;</span>
<span class="line-added"> 41 import sun.nio.cs.UTF_8;</span>
<span class="line-added"> 42 </span>
 43 /**
 44  * A class that contains useful routines common to sun.net.www
 45  * @author  Mike McCloskey
 46  */
 47 
 48 public final class ParseUtil {
 49 
 50     private ParseUtil() {}
 51 
 52     /**
 53      * Constructs an encoded version of the specified path string suitable
 54      * for use in the construction of a URL.
 55      *
 56      * A path separator is replaced by a forward slash. The string is UTF8
 57      * encoded. The % escape sequence is used for characters that are above
 58      * 0x7F or those defined in RFC2396 as reserved or excluded in the path
 59      * component of a URL.
 60      */
 61     public static String encodePath(String path) {
 62         return encodePath(path, true);
</pre>
<hr />
<pre>
130                     retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);
131                 }
132             }
133             //worst case scenario for character [0x7ff-] every single
134             //character will be encoded into 9 characters.
135             if (retLen + 9 &gt; retCC.length) {
136                 int newLen = retCC.length * 2 + 16;
137                 if (newLen &lt; 0) {
138                     newLen = Integer.MAX_VALUE;
139                 }
140                 char[] buf = new char[newLen];
141                 System.arraycopy(retCC, 0, buf, 0, retLen);
142                 retCC = buf;
143             }
144         }
145         return new String(retCC, 0, retLen);
146     }
147 
148     /**
149      * Appends the URL escape sequence for the specified char to the
<span class="line-modified">150      * specified character array.</span>
151      */
152     private static int escape(char[] cc, char c, int index) {
153         cc[index++] = &#39;%&#39;;
154         cc[index++] = Character.forDigit((c &gt;&gt; 4) &amp; 0xF, 16);
155         cc[index++] = Character.forDigit(c &amp; 0xF, 16);
156         return index;
157     }
158 
159     /**
160      * Un-escape and return the character at position i in string s.
161      */
162     private static byte unescape(String s, int i) {
163         return (byte) Integer.parseInt(s, i + 1, i + 3, 16);
164     }
165 
166 
167     /**
168      * Returns a new String constructed from the specified String by replacing
169      * the URL escape sequences and UTF8 encoding with the characters they
170      * represent.
171      */
172     public static String decode(String s) {
173         int n = s.length();
174         if ((n == 0) || (s.indexOf(&#39;%&#39;) &lt; 0))
175             return s;
176 
177         StringBuilder sb = new StringBuilder(n);
178         ByteBuffer bb = ByteBuffer.allocate(n);
179         CharBuffer cb = CharBuffer.allocate(n);
<span class="line-modified">180         CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)</span>
181             .onMalformedInput(CodingErrorAction.REPORT)
182             .onUnmappableCharacter(CodingErrorAction.REPORT);
183 
184         char c = s.charAt(0);
185         for (int i = 0; i &lt; n;) {
186             assert c == s.charAt(i);
187             if (c != &#39;%&#39;) {
188                 sb.append(c);
189                 if (++i &gt;= n)
190                     break;
191                 c = s.charAt(i);
192                 continue;
193             }
194             bb.clear();
195             int ui = i;
196             for (;;) {
197                 assert (n - i &gt;= 2);
198                 try {
199                     bb.put(unescape(s, i));
200                 } catch (NumberFormatException e) {
</pre>
<hr />
<pre>
320                                  String query,
321                                  String fragment) throws URISyntaxException
322     {
323         String s = toString(scheme, null,
324                             authority, null, null, -1,
325                             path, query, fragment);
326         checkPath(s, scheme, path);
327         return new URI(s);
328     }
329 
330     private static String toString(String scheme,
331                             String opaquePart,
332                             String authority,
333                             String userInfo,
334                             String host,
335                             int port,
336                             String path,
337                             String query,
338                             String fragment)
339     {
<span class="line-modified">340         StringBuilder sb = new StringBuilder();</span>
341         if (scheme != null) {
342             sb.append(scheme);
343             sb.append(&#39;:&#39;);
344         }
345         appendSchemeSpecificPart(sb, opaquePart,
346                                  authority, userInfo, host, port,
347                                  path, query);
348         appendFragment(sb, fragment);
349         return sb.toString();
350     }
351 
<span class="line-modified">352     private static void appendSchemeSpecificPart(StringBuilder sb,</span>
353                                           String opaquePart,
354                                           String authority,
355                                           String userInfo,
356                                           String host,
357                                           int port,
358                                           String path,
359                                           String query)
360     {
361         if (opaquePart != null) {
362             /* check if SSP begins with an IPv6 address
363              * because we must not quote a literal IPv6 address
364              */
365             if (opaquePart.startsWith(&quot;//[&quot;)) {
366                 int end =  opaquePart.indexOf(&#39;]&#39;);
367                 if (end != -1 &amp;&amp; opaquePart.indexOf(&#39;:&#39;)!=-1) {
368                     String doquote, dontquote;
369                     if (end == opaquePart.length()) {
370                         dontquote = opaquePart;
371                         doquote = &quot;&quot;;
372                     } else {
373                         dontquote = opaquePart.substring(0,end+1);
374                         doquote = opaquePart.substring(end+1);
375                     }
376                     sb.append (dontquote);
377                     sb.append(quote(doquote, L_URIC, H_URIC));
378                 }
379             } else {
380                 sb.append(quote(opaquePart, L_URIC, H_URIC));
381             }
382         } else {
383             appendAuthority(sb, authority, userInfo, host, port);
384             if (path != null)
385                 sb.append(quote(path, L_PATH, H_PATH));
386             if (query != null) {
387                 sb.append(&#39;?&#39;);
388                 sb.append(quote(query, L_URIC, H_URIC));
389             }
390         }
391     }
392 
<span class="line-modified">393     private static void appendAuthority(StringBuilder sb,</span>
394                                  String authority,
395                                  String userInfo,
396                                  String host,
397                                  int port)
398     {
399         if (host != null) {
400             sb.append(&quot;//&quot;);
401             if (userInfo != null) {
402                 sb.append(quote(userInfo, L_USERINFO, H_USERINFO));
403                 sb.append(&#39;@&#39;);
404             }
405             boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)
406                                     &amp;&amp; !host.startsWith(&quot;[&quot;)
407                                     &amp;&amp; !host.endsWith(&quot;]&quot;));
408             if (needBrackets) sb.append(&#39;[&#39;);
409             sb.append(host);
410             if (needBrackets) sb.append(&#39;]&#39;);
411             if (port != -1) {
412                 sb.append(&#39;:&#39;);
413                 sb.append(port);
</pre>
<hr />
<pre>
421                     if (end == authority.length()) {
422                         dontquote = authority;
423                         doquote = &quot;&quot;;
424                     } else {
425                         dontquote = authority.substring(0,end+1);
426                         doquote = authority.substring(end+1);
427                     }
428                     sb.append (dontquote);
429                     sb.append(quote(doquote,
430                             L_REG_NAME | L_SERVER,
431                             H_REG_NAME | H_SERVER));
432                 }
433             } else {
434                 sb.append(quote(authority,
435                             L_REG_NAME | L_SERVER,
436                             H_REG_NAME | H_SERVER));
437             }
438         }
439     }
440 
<span class="line-modified">441     private static void appendFragment(StringBuilder sb, String fragment) {</span>
442         if (fragment != null) {
443             sb.append(&#39;#&#39;);
444             sb.append(quote(fragment, L_URIC, H_URIC));
445         }
446     }
447 
448     // Quote any characters in s that are not permitted
449     // by the given mask pair
450     //
451     private static String quote(String s, long lowMask, long highMask) {
452         int n = s.length();
<span class="line-modified">453         StringBuilder sb = null;</span>
454         boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);
455         for (int i = 0; i &lt; s.length(); i++) {
456             char c = s.charAt(i);
457             if (c &lt; &#39;\u0080&#39;) {
458                 if (!match(c, lowMask, highMask) &amp;&amp; !isEscaped(s, i)) {
459                     if (sb == null) {
<span class="line-modified">460                         sb = new StringBuilder();</span>
461                         sb.append(s, 0, i);
462                     }
463                     appendEscape(sb, (byte)c);
464                 } else {
465                     if (sb != null)
466                         sb.append(c);
467                 }
468             } else if (allowNonASCII
469                        &amp;&amp; (Character.isSpaceChar(c)
470                            || Character.isISOControl(c))) {
471                 if (sb == null) {
<span class="line-modified">472                     sb = new StringBuilder();</span>
473                     sb.append(s, 0, i);
474                 }
475                 appendEncoded(sb, c);
476             } else {
477                 if (sb != null)
478                     sb.append(c);
479             }
480         }
481         return (sb == null) ? s : sb.toString();
482     }
483 
484     //
485     // To check if the given string has an escaped triplet
486     // at the given position
487     //
488     private static boolean isEscaped(String s, int pos) {
489         if (s == null || (s.length() &lt;= (pos + 2)))
490             return false;
491 
492         return s.charAt(pos) == &#39;%&#39;
493                &amp;&amp; match(s.charAt(pos + 1), L_HEX, H_HEX)
494                &amp;&amp; match(s.charAt(pos + 2), L_HEX, H_HEX);
495     }
496 
<span class="line-modified">497     private static void appendEncoded(StringBuilder sb, char c) {</span>
498         ByteBuffer bb = null;
499         try {
<span class="line-modified">500             bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)</span>
501                 .encode(CharBuffer.wrap(&quot;&quot; + c));
502         } catch (CharacterCodingException x) {
503             assert false;
504         }
505         while (bb.hasRemaining()) {
506             int b = bb.get() &amp; 0xff;
507             if (b &gt;= 0x80)
508                 appendEscape(sb, (byte)b);
509             else
510                 sb.append((char)b);
511         }
512     }
513 
514     private static final char[] hexDigits = {
515         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
516         &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
517     };
518 
<span class="line-modified">519     private static void appendEscape(StringBuilder sb, byte b) {</span>
520         sb.append(&#39;%&#39;);
521         sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);
522         sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);
523     }
524 
525     // Tell whether the given character is permitted by the given mask pair
526     private static boolean match(char c, long lowMask, long highMask) {
527         if (c &lt; 64)
528             return ((1L &lt;&lt; c) &amp; lowMask) != 0;
529         if (c &lt; 128)
530             return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;
531         return false;
532     }
533 
534     // If a scheme is given then the path, if given, must be absolute
535     //
536     private static void checkPath(String s, String scheme, String path)
537         throws URISyntaxException
538     {
539         if (scheme != null) {
</pre>
</td>
</tr>
</table>
<center><a href="MessageHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="http/ChunkedInputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
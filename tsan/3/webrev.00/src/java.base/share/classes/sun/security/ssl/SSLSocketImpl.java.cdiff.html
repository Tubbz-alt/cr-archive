<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSessionImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketInputRecord.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,12 ---</span>
  import java.net.SocketAddress;
  import java.net.SocketException;
  import java.net.UnknownHostException;
  import java.nio.ByteBuffer;
  import java.util.List;
<span class="line-added">+ import java.util.concurrent.TimeUnit;</span>
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import java.util.function.BiFunction;
  import javax.net.ssl.HandshakeCompletedListener;
  import javax.net.ssl.SSLException;
  import javax.net.ssl.SSLHandshakeException;
  import javax.net.ssl.SSLParameters;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,10 ***</span>
<span class="line-new-header">--- 84,13 ---</span>
      private String                  peerHost;
      private boolean                 autoClose;
      private boolean                 isConnected = false;
      private volatile boolean        tlsIsClosed = false;
  
<span class="line-added">+     private final ReentrantLock     socketLock = new ReentrantLock();</span>
<span class="line-added">+     private final ReentrantLock     handshakeLock = new ReentrantLock();</span>
<span class="line-added">+ </span>
      /*
       * Is the local name service trustworthy?
       *
       * If the local name service is not trustworthy, reverse host name
       * resolution should not be performed for endpoint identification.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,40 ***</span>
      public String[] getSupportedCipherSuites() {
          return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
      }
  
      @Override
<span class="line-modified">!     public synchronized String[] getEnabledCipherSuites() {</span>
<span class="line-modified">!         return CipherSuite.namesOf(conContext.sslConfig.enabledCipherSuites);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified">!         conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-modified">!                 CipherSuite.validValuesOf(suites);</span>
      }
  
      @Override
      public String[] getSupportedProtocols() {
          return ProtocolVersion.toStringArray(
                  sslContext.getSupportedProtocolVersions());
      }
  
      @Override
<span class="line-modified">!     public synchronized String[] getEnabledProtocols() {</span>
<span class="line-modified">!         return ProtocolVersion.toStringArray(</span>
<span class="line-modified">!                 conContext.sslConfig.enabledProtocols);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnabledProtocols(String[] protocols) {</span>
          if (protocols == null) {
              throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
          }
  
<span class="line-modified">!         conContext.sslConfig.enabledProtocols =</span>
<span class="line-modified">!                 ProtocolVersion.namesOf(protocols);</span>
      }
  
      @Override
      public SSLSession getSession() {
          try {
<span class="line-new-header">--- 295,61 ---</span>
      public String[] getSupportedCipherSuites() {
          return CipherSuite.namesOf(sslContext.getSupportedCipherSuites());
      }
  
      @Override
<span class="line-modified">!     public String[] getEnabledCipherSuites() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return CipherSuite.namesOf(</span>
<span class="line-added">+                     conContext.sslConfig.enabledCipherSuites);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnabledCipherSuites(String[] suites) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             conContext.sslConfig.enabledCipherSuites =</span>
<span class="line-added">+                     CipherSuite.validValuesOf(suites);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public String[] getSupportedProtocols() {
          return ProtocolVersion.toStringArray(
                  sslContext.getSupportedProtocolVersions());
      }
  
      @Override
<span class="line-modified">!     public String[] getEnabledProtocols() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             return ProtocolVersion.toStringArray(</span>
<span class="line-added">+                     conContext.sslConfig.enabledProtocols);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnabledProtocols(String[] protocols) {</span>
          if (protocols == null) {
              throw new IllegalArgumentException(&quot;Protocols cannot be null&quot;);
          }
  
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             conContext.sslConfig.enabledProtocols =</span>
<span class="line-added">+                     ProtocolVersion.namesOf(protocols);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public SSLSession getSession() {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,40 ***</span>
  
          return conContext.conSession;
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLSession getHandshakeSession() {</span>
<span class="line-modified">!         if (conContext.handshakeContext != null) {</span>
<span class="line-modified">!             synchronized (this) {</span>
<span class="line-modified">!                 if (conContext.handshakeContext != null) {</span>
<span class="line-modified">!                     return conContext.handshakeContext.handshakeSession;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         return null;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void addHandshakeCompletedListener(</span>
              HandshakeCompletedListener listener) {
          if (listener == null) {
              throw new IllegalArgumentException(&quot;listener is null&quot;);
          }
  
<span class="line-modified">!         conContext.sslConfig.addHandshakeCompletedListener(listener);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void removeHandshakeCompletedListener(</span>
              HandshakeCompletedListener listener) {
          if (listener == null) {
              throw new IllegalArgumentException(&quot;listener is null&quot;);
          }
  
<span class="line-modified">!         conContext.sslConfig.removeHandshakeCompletedListener(listener);</span>
      }
  
      @Override
      public void startHandshake() throws IOException {
          if (!isConnected) {
<span class="line-new-header">--- 365,48 ---</span>
  
          return conContext.conSession;
      }
  
      @Override
<span class="line-modified">!     public SSLSession getHandshakeSession() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return conContext.handshakeContext == null ?</span>
<span class="line-modified">!                     null : conContext.handshakeContext.handshakeSession;</span>
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             socketLock.unlock();</span>
          }
      }
  
      @Override
<span class="line-modified">!     public void addHandshakeCompletedListener(</span>
              HandshakeCompletedListener listener) {
          if (listener == null) {
              throw new IllegalArgumentException(&quot;listener is null&quot;);
          }
  
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.addHandshakeCompletedListener(listener);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void removeHandshakeCompletedListener(</span>
              HandshakeCompletedListener listener) {
          if (listener == null) {
              throw new IllegalArgumentException(&quot;listener is null&quot;);
          }
  
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.removeHandshakeCompletedListener(listener);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public void startHandshake() throws IOException {
          if (!isConnected) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,11 ***</span>
          if (conContext.isBroken || conContext.isInboundClosed() ||
                  conContext.isOutboundClosed()) {
              throw new SocketException(&quot;Socket has been closed or broken&quot;);
          }
  
<span class="line-modified">!         synchronized (conContext) {     // handshake lock</span>
              // double check the context status
              if (conContext.isBroken || conContext.isInboundClosed() ||
                      conContext.isOutboundClosed()) {
                  throw new SocketException(&quot;Socket has been closed or broken&quot;);
              }
<span class="line-new-header">--- 416,12 ---</span>
          if (conContext.isBroken || conContext.isInboundClosed() ||
                  conContext.isOutboundClosed()) {
              throw new SocketException(&quot;Socket has been closed or broken&quot;);
          }
  
<span class="line-modified">!         handshakeLock.lock();</span>
<span class="line-added">+         try {</span>
              // double check the context status
              if (conContext.isBroken || conContext.isInboundClosed() ||
                      conContext.isOutboundClosed()) {
                  throw new SocketException(&quot;Socket has been closed or broken&quot;);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,57 ***</span>
                  throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
              } catch (Exception oe) {    // including RuntimeException
                  handleException(oe);
              }
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized void setUseClientMode(boolean mode) {</span>
<span class="line-modified">!         conContext.setUseClientMode(mode);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getUseClientMode() {</span>
<span class="line-modified">!         return conContext.sslConfig.isClientMode;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setNeedClientAuth(boolean need) {</span>
<span class="line-modified">!         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified">!                 (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_NONE);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getNeedClientAuth() {</span>
<span class="line-modified">!         return (conContext.sslConfig.clientAuthType ==</span>
                          ClientAuthType.CLIENT_AUTH_REQUIRED);
      }
  
      @Override
<span class="line-modified">!     public synchronized void setWantClientAuth(boolean want) {</span>
<span class="line-modified">!         conContext.sslConfig.clientAuthType =</span>
<span class="line-modified">!                 (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-modified">!                         ClientAuthType.CLIENT_AUTH_NONE);</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getWantClientAuth() {</span>
<span class="line-modified">!         return (conContext.sslConfig.clientAuthType ==</span>
                          ClientAuthType.CLIENT_AUTH_REQUESTED);
      }
  
      @Override
<span class="line-modified">!     public synchronized void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified">!         conContext.sslConfig.enableSessionCreation = flag;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean getEnableSessionCreation() {</span>
<span class="line-modified">!         return conContext.sslConfig.enableSessionCreation;</span>
      }
  
      @Override
      public boolean isClosed() {
          return tlsIsClosed;
<span class="line-new-header">--- 440,99 ---</span>
                  throw conContext.fatal(Alert.HANDSHAKE_FAILURE,
                      &quot;Couldn&#39;t kickstart handshaking&quot;, ioe);
              } catch (Exception oe) {    // including RuntimeException
                  handleException(oe);
              }
<span class="line-added">+         } finally {</span>
<span class="line-added">+             handshakeLock.unlock();</span>
          }
      }
  
      @Override
<span class="line-modified">!     public void setUseClientMode(boolean mode) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.setUseClientMode(mode);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getUseClientMode() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.isClientMode;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setNeedClientAuth(boolean need) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             conContext.sslConfig.clientAuthType =</span>
<span class="line-added">+                     (need ? ClientAuthType.CLIENT_AUTH_REQUIRED :</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getNeedClientAuth() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return (conContext.sslConfig.clientAuthType ==</span>
                          ClientAuthType.CLIENT_AUTH_REQUIRED);
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setWantClientAuth(boolean want) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             conContext.sslConfig.clientAuthType =</span>
<span class="line-added">+                     (want ? ClientAuthType.CLIENT_AUTH_REQUESTED :</span>
<span class="line-added">+                             ClientAuthType.CLIENT_AUTH_NONE);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getWantClientAuth() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return (conContext.sslConfig.clientAuthType ==</span>
                          ClientAuthType.CLIENT_AUTH_REQUESTED);
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setEnableSessionCreation(boolean flag) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.enableSessionCreation = flag;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public boolean getEnableSessionCreation() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.enableSessionCreation;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
      public boolean isClosed() {
          return tlsIsClosed;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 540,33 ***</span>
              }
          }
  
          // Need a lock here so that the user_canceled alert and the
          // close_notify alert can be delivered together.
<span class="line-modified">!         try {</span>
<span class="line-modified">!             synchronized (conContext.outputRecord) {</span>
<span class="line-modified">!                 // send a user_canceled alert if needed.</span>
<span class="line-modified">!                 if (useUserCanceled) {</span>
<span class="line-modified">!                     conContext.warning(Alert.USER_CANCELED);</span>
                  }
  
<span class="line-modified">!                 // send a close_notify alert</span>
<span class="line-modified">!                 conContext.warning(Alert.CLOSE_NOTIFY);</span>
              }
          } finally {
              if (!conContext.isOutboundClosed()) {
                  conContext.outputRecord.close();
              }
  
<span class="line-modified">!             if ((autoClose || !isLayered()) &amp;&amp; !super.isOutputShutdown()) {</span>
                  super.shutdownOutput();
              }
          }
<span class="line-removed">- </span>
<span class="line-removed">-         if (!isInputShutdown()) {</span>
<span class="line-removed">-             bruteForceCloseInput(hasCloseReceipt);</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * Duplex close, start from closing inbound.
       *
<span class="line-new-header">--- 617,107 ---</span>
              }
          }
  
          // Need a lock here so that the user_canceled alert and the
          // close_notify alert can be delivered together.
<span class="line-modified">!         int linger = getSoLinger();</span>
<span class="line-modified">!         if (linger &gt;= 0) {</span>
<span class="line-modified">!             // don&#39;t wait more than SO_LINGER for obtaining the</span>
<span class="line-modified">!             // the lock.</span>
<span class="line-modified">!             //</span>
<span class="line-added">+             // keep and clear the current thread interruption status.</span>
<span class="line-added">+             boolean interrupted = Thread.interrupted();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 if (conContext.outputRecord.recordLock.tryLock() ||</span>
<span class="line-added">+                         conContext.outputRecord.recordLock.tryLock(</span>
<span class="line-added">+                                 linger, TimeUnit.SECONDS)) {</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         handleClosedNotifyAlert(useUserCanceled);</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         conContext.outputRecord.recordLock.unlock();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // For layered, non-autoclose sockets, we are not</span>
<span class="line-added">+                     // able to bring them into a usable state, so we</span>
<span class="line-added">+                     // treat it as fatal error.</span>
<span class="line-added">+                     if (!super.isOutputShutdown()) {</span>
<span class="line-added">+                         if (isLayered() &amp;&amp; !autoClose) {</span>
<span class="line-added">+                             throw new SSLException(</span>
<span class="line-added">+                                     &quot;SO_LINGER timeout, &quot; +</span>
<span class="line-added">+                                     &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             super.shutdownOutput();</span>
<span class="line-added">+                             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                                 SSLLogger.warning(</span>
<span class="line-added">+                                     &quot;SSLSocket output duplex close failed: &quot; +</span>
<span class="line-added">+                                     &quot;SO_LINGER timeout, &quot; +</span>
<span class="line-added">+                                     &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // RFC2246 requires that the session becomes</span>
<span class="line-added">+                     // unresumable if any connection is terminated</span>
<span class="line-added">+                     // without proper close_notify messages with</span>
<span class="line-added">+                     // level equal to warning.</span>
<span class="line-added">+                     //</span>
<span class="line-added">+                     // RFC4346 no longer requires that a session not be</span>
<span class="line-added">+                     // resumed if failure to properly close a connection.</span>
<span class="line-added">+                     //</span>
<span class="line-added">+                     // We choose to make the session unresumable if</span>
<span class="line-added">+                     // failed to send the close_notify message.</span>
<span class="line-added">+                     //</span>
<span class="line-added">+                     conContext.conSession.invalidate();</span>
<span class="line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                         SSLLogger.warning(</span>
<span class="line-added">+                                 &quot;Invalidate the session: SO_LINGER timeout, &quot; +</span>
<span class="line-added">+                                 &quot;close_notify message cannot be sent.&quot;);</span>
<span class="line-added">+                     }</span>
                  }
<span class="line-added">+             } catch (InterruptedException ex) {</span>
<span class="line-added">+                 // keep interrupted status</span>
<span class="line-added">+                 interrupted = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // restore the interrupted status</span>
<span class="line-added">+             if (interrupted) {</span>
<span class="line-added">+                 Thread.currentThread().interrupt();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             conContext.outputRecord.recordLock.lock();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 handleClosedNotifyAlert(useUserCanceled);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 conContext.outputRecord.recordLock.unlock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (!isInputShutdown()) {</span>
<span class="line-modified">!             bruteForceCloseInput(hasCloseReceipt);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void handleClosedNotifyAlert(</span>
<span class="line-added">+             boolean useUserCanceled) throws IOException {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             // send a user_canceled alert if needed.</span>
<span class="line-added">+             if (useUserCanceled) {</span>
<span class="line-added">+                 conContext.warning(Alert.USER_CANCELED);</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             // send a close_notify alert</span>
<span class="line-added">+             conContext.warning(Alert.CLOSE_NOTIFY);</span>
          } finally {
              if (!conContext.isOutboundClosed()) {
                  conContext.outputRecord.close();
              }
  
<span class="line-modified">!             if (!super.isOutputShutdown() &amp;&amp;</span>
<span class="line-added">+                     (autoClose || !isLayered())) {</span>
                  super.shutdownOutput();
              }
          }
      }
  
      /**
       * Duplex close, start from closing inbound.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,41 ***</span>
          return conContext.isOutboundClosed() &amp;&amp;
                  ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
      }
  
      @Override
<span class="line-modified">!     public synchronized InputStream getInputStream() throws IOException {</span>
<span class="line-modified">!         if (isClosed()) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (!isConnected) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (conContext.isInboundClosed() || isInputShutdown()) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket input is already shutdown&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         return appInput;</span>
      }
  
      private void ensureNegotiated() throws IOException {
          if (conContext.isNegotiated || conContext.isBroken ||
                  conContext.isInboundClosed() || conContext.isOutboundClosed()) {
              return;
          }
  
<span class="line-modified">!         synchronized (conContext) {     // handshake lock</span>
              // double check the context status
              if (conContext.isNegotiated || conContext.isBroken ||
                      conContext.isInboundClosed() ||
                      conContext.isOutboundClosed()) {
                  return;
              }
  
              startHandshake();
          }
      }
  
      /**
       * InputStream for application data as returned by
<span class="line-new-header">--- 837,49 ---</span>
          return conContext.isOutboundClosed() &amp;&amp;
                  ((autoClose || !isLayered()) ? super.isOutputShutdown(): true);
      }
  
      @Override
<span class="line-modified">!     public InputStream getInputStream() throws IOException {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isClosed()) {</span>
<span class="line-added">+                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (!isConnected) {</span>
<span class="line-modified">!                 throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             if (conContext.isInboundClosed() || isInputShutdown()) {</span>
<span class="line-modified">!                 throw new SocketException(&quot;Socket input is already shutdown&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             return appInput;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      private void ensureNegotiated() throws IOException {
          if (conContext.isNegotiated || conContext.isBroken ||
                  conContext.isInboundClosed() || conContext.isOutboundClosed()) {
              return;
          }
  
<span class="line-modified">!         handshakeLock.lock();</span>
<span class="line-added">+         try {</span>
              // double check the context status
              if (conContext.isNegotiated || conContext.isBroken ||
                      conContext.isInboundClosed() ||
                      conContext.isOutboundClosed()) {
                  return;
              }
  
              startHandshake();
<span class="line-added">+         } finally {</span>
<span class="line-added">+             handshakeLock.unlock();</span>
          }
      }
  
      /**
       * InputStream for application data as returned by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,10 ***</span>
<span class="line-new-header">--- 893,17 ---</span>
          private ByteBuffer buffer;
  
          // Is application data available in the stream?
          private volatile boolean appDataIsAvailable;
  
<span class="line-added">+         // reading lock</span>
<span class="line-added">+         private final ReentrantLock readLock = new ReentrantLock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // closing status</span>
<span class="line-added">+         private volatile boolean isClosing;</span>
<span class="line-added">+         private volatile boolean hasDepleted;</span>
<span class="line-added">+ </span>
          AppInputStream() {
              this.appDataIsAvailable = false;
              this.buffer = ByteBuffer.allocate(4096);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 779,12 ***</span>
           * If the layer above needs more data, it asks for more, so we
           * are responsible only for blocking to fill at most one buffer,
           * and returning &quot;-1&quot; on non-fault EOF status.
           */
          @Override
<span class="line-modified">!         public int read(byte[] b, int off, int len)</span>
<span class="line-removed">-                 throws IOException {</span>
              if (b == null) {
                  throw new NullPointerException(&quot;the target buffer is null&quot;);
              } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
                  throw new IndexOutOfBoundsException(
                          &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
<span class="line-new-header">--- 945,11 ---</span>
           * If the layer above needs more data, it asks for more, so we
           * are responsible only for blocking to fill at most one buffer,
           * and returning &quot;-1&quot; on non-fault EOF status.
           */
          @Override
<span class="line-modified">!         public int read(byte[] b, int off, int len) throws IOException {</span>
              if (b == null) {
                  throw new NullPointerException(&quot;the target buffer is null&quot;);
              } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {
                  throw new IndexOutOfBoundsException(
                          &quot;buffer length: &quot; + b.length + &quot;, offset; &quot; + off +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 808,15 ***</span>
              if (!conContext.isNegotiated ||
                      conContext.isBroken || conContext.isInboundClosed()) {
                  throw new SocketException(&quot;Connection or inbound has closed&quot;);
              }
  
              // Read the available bytes at first.
              //
              // Note that the receiving and processing of post-handshake message
              // are also synchronized with the read lock.
<span class="line-modified">!             synchronized (this) {</span>
                  int remains = available();
                  if (remains &gt; 0) {
                      int howmany = Math.min(remains, len);
                      buffer.get(b, off, howmany);
  
<span class="line-new-header">--- 973,44 ---</span>
              if (!conContext.isNegotiated ||
                      conContext.isBroken || conContext.isInboundClosed()) {
                  throw new SocketException(&quot;Connection or inbound has closed&quot;);
              }
  
<span class="line-added">+             // Check if the input stream has been depleted.</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // Note that the &quot;hasDepleted&quot; rather than the isClosing</span>
<span class="line-added">+             // filed is checked here, in case the closing process is</span>
<span class="line-added">+             // still in progress.</span>
<span class="line-added">+             if (hasDepleted) {</span>
<span class="line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                     SSLLogger.fine(&quot;The input stream has been depleted&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 return -1;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              // Read the available bytes at first.
              //
              // Note that the receiving and processing of post-handshake message
              // are also synchronized with the read lock.
<span class="line-modified">!             readLock.lock();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 // Double check if the Socket is invalid (error or closed).</span>
<span class="line-added">+                 if (conContext.isBroken || conContext.isInboundClosed()) {</span>
<span class="line-added">+                     throw new SocketException(</span>
<span class="line-added">+                             &quot;Connection or inbound has closed&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Double check if the input stream has been depleted.</span>
<span class="line-added">+                 if (hasDepleted) {</span>
<span class="line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                         SSLLogger.fine(&quot;The input stream is closing&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     return -1;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
                  int remains = available();
                  if (remains &gt; 0) {
                      int howmany = Math.min(remains, len);
                      buffer.get(b, off, howmany);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,10 ***</span>
<span class="line-new-header">--- 1038,22 ---</span>
                      handleException(e);
  
                      // dummy for compiler
                      return -1;
                  }
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 // Check if the input stream is closing.</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // If the deplete() did not hold the lock, clean up the</span>
<span class="line-added">+                 // input stream here.</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     if (isClosing) {</span>
<span class="line-added">+                         readLockedDeplete();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     readLock.unlock();</span>
<span class="line-added">+                 }</span>
              }
          }
  
          /**
           * Skip n bytes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 855,23 ***</span>
           * This implementation is somewhat less efficient than possible, but
           * not badly so (redundant copy).  We reuse the read() code to keep
           * things simpler.
           */
          @Override
<span class="line-modified">!         public synchronized long skip(long n) throws IOException {</span>
              // dummy array used to implement skip()
              byte[] skipArray = new byte[256];
<span class="line-removed">- </span>
              long skipped = 0;
<span class="line-modified">!             while (n &gt; 0) {</span>
<span class="line-modified">!                 int len = (int)Math.min(n, skipArray.length);</span>
<span class="line-modified">!                 int r = read(skipArray, 0, len);</span>
<span class="line-modified">!                 if (r &lt;= 0) {</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-modified">!                 n -= r;</span>
<span class="line-modified">!                 skipped += r;</span>
              }
  
              return skipped;
          }
  
<span class="line-new-header">--- 1061,28 ---</span>
           * This implementation is somewhat less efficient than possible, but
           * not badly so (redundant copy).  We reuse the read() code to keep
           * things simpler.
           */
          @Override
<span class="line-modified">!         public long skip(long n) throws IOException {</span>
              // dummy array used to implement skip()
              byte[] skipArray = new byte[256];
              long skipped = 0;
<span class="line-modified">! </span>
<span class="line-modified">!             readLock.lock();</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 while (n &gt; 0) {</span>
<span class="line-modified">!                     int len = (int)Math.min(n, skipArray.length);</span>
<span class="line-added">+                     int r = read(skipArray, 0, len);</span>
<span class="line-added">+                     if (r &lt;= 0) {</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     n -= r;</span>
<span class="line-added">+                     skipped += r;</span>
                  }
<span class="line-modified">!             } finally {</span>
<span class="line-modified">!                 readLock.unlock();</span>
              }
  
              return skipped;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,11 ***</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                  SSLLogger.finest(&quot;Closing input stream&quot;);
              }
  
              try {
<span class="line-modified">!                 shutdownInput(false);</span>
              } catch (IOException ioe) {
                  // ignore the exception
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                      SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
                  }
<span class="line-new-header">--- 1091,11 ---</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                  SSLLogger.finest(&quot;Closing input stream&quot;);
              }
  
              try {
<span class="line-modified">!                 SSLSocketImpl.this.close();</span>
              } catch (IOException ioe) {
                  // ignore the exception
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                      SSLLogger.warning(&quot;input stream close failed&quot;, ioe);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 915,46 ***</span>
  
          /**
           * Try the best to use up the input records so as to close the
           * socket gracefully, without impact the performance too much.
           */
<span class="line-modified">!         private synchronized void deplete() {</span>
<span class="line-modified">!             if (!conContext.isInboundClosed()) {</span>
<span class="line-modified">!                 if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {</span>
<span class="line-modified">!                     return;</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 SSLSocketInputRecord socketInputRecord =</span>
<span class="line-modified">!                         (SSLSocketInputRecord)conContext.inputRecord;</span>
                  try {
<span class="line-modified">!                     socketInputRecord.deplete(</span>
<span class="line-modified">!                         conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));</span>
<span class="line-modified">!                 } catch (IOException ioe) {</span>
<span class="line-removed">-                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-removed">-                         SSLLogger.warning(</span>
<span class="line-removed">-                             &quot;input stream close depletion failed&quot;, ioe);</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized OutputStream getOutputStream() throws IOException {</span>
<span class="line-modified">!         if (isClosed()) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (!isConnected) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (conContext.isOutboundDone() || isOutputShutdown()) {</span>
<span class="line-modified">!             throw new SocketException(&quot;Socket output is already shutdown&quot;);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         return appOutput;</span>
      }
  
  
      /**
       * OutputStream for application data as returned by
<span class="line-new-header">--- 1126,77 ---</span>
  
          /**
           * Try the best to use up the input records so as to close the
           * socket gracefully, without impact the performance too much.
           */
<span class="line-modified">!         private void deplete() {</span>
<span class="line-modified">!             if (conContext.isInboundClosed() || isClosing) {</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             isClosing = true;</span>
<span class="line-modified">!             if (readLock.tryLock()) {</span>
                  try {
<span class="line-modified">!                     readLockedDeplete();</span>
<span class="line-modified">!                 } finally {</span>
<span class="line-modified">!                     readLock.unlock();</span>
                  }
              }
          }
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Try to use up the input records.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * Please don&#39;t call this method unless the readLock is held by</span>
<span class="line-added">+          * the current thread.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private void readLockedDeplete() {</span>
<span class="line-added">+             // double check</span>
<span class="line-added">+             if (hasDepleted || conContext.isInboundClosed()) {</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!(conContext.inputRecord instanceof SSLSocketInputRecord)) {</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             SSLSocketInputRecord socketInputRecord =</span>
<span class="line-added">+                     (SSLSocketInputRecord)conContext.inputRecord;</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 socketInputRecord.deplete(</span>
<span class="line-added">+                     conContext.isNegotiated &amp;&amp; (getSoTimeout() &gt; 0));</span>
<span class="line-added">+             } catch (Exception ex) {</span>
<span class="line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                     SSLLogger.warning(</span>
<span class="line-added">+                         &quot;input stream close depletion failed&quot;, ex);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 hasDepleted = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public OutputStream getOutputStream() throws IOException {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (isClosed()) {</span>
<span class="line-added">+                 throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (!isConnected) {</span>
<span class="line-modified">!                 throw new SocketException(&quot;Socket is not connected&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             if (conContext.isOutboundDone() || isOutputShutdown()) {</span>
<span class="line-modified">!                 throw new SocketException(&quot;Socket output is already shutdown&quot;);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             return appOutput;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
  
      /**
       * OutputStream for application data as returned by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1010,78 ***</span>
              try {
                  conContext.outputRecord.deliver(b, off, len);
              } catch (SSLHandshakeException she) {
                  // may be record sequence number overflow
                  throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
<span class="line-modified">!             } catch (IOException e) {</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);</span>
<span class="line-modified">!             }</span>
  
              // Is the sequence number is nearly overflow, or has the key usage
              // limit been reached?
              if (conContext.outputRecord.seqNumIsHuge() ||
                      conContext.outputRecord.writeCipher.atKeyLimit()) {
                  tryKeyUpdate();
              }
          }
  
          @Override
          public void close() throws IOException {
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                  SSLLogger.finest(&quot;Closing output stream&quot;);
              }
  
              try {
<span class="line-modified">!                 shutdownOutput();</span>
              } catch (IOException ioe) {
                  // ignore the exception
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                      SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
                  }
              }
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized SSLParameters getSSLParameters() {</span>
<span class="line-modified">!         return conContext.sslConfig.getSSLParameters();</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">!         conContext.sslConfig.setSSLParameters(params);</span>
  
<span class="line-modified">!         if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">!             conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">!                     conContext.sslConfig.maximumPacketSize);</span>
          }
      }
  
      @Override
<span class="line-modified">!     public synchronized String getApplicationProtocol() {</span>
<span class="line-modified">!         return conContext.applicationProtocol;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">!         if (conContext.handshakeContext != null) {</span>
<span class="line-modified">!             return conContext.handshakeContext.applicationProtocol;</span>
          }
  
          return null;
      }
  
      @Override
<span class="line-modified">!     public synchronized void setHandshakeApplicationProtocolSelector(</span>
              BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">!         conContext.sslConfig.socketAPSelector = selector;</span>
      }
  
      @Override
<span class="line-modified">!     public synchronized BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;</span>
              getHandshakeApplicationProtocolSelector() {
<span class="line-modified">!         return conContext.sslConfig.socketAPSelector;</span>
      }
  
      /**
       * Read the initial handshake records.
       */
<span class="line-new-header">--- 1252,115 ---</span>
              try {
                  conContext.outputRecord.deliver(b, off, len);
              } catch (SSLHandshakeException she) {
                  // may be record sequence number overflow
                  throw conContext.fatal(Alert.HANDSHAKE_FAILURE, she);
<span class="line-modified">!             } catch (SSLException ssle) {</span>
<span class="line-modified">!                 throw conContext.fatal(Alert.UNEXPECTED_MESSAGE, ssle);</span>
<span class="line-modified">!             }   // re-throw other IOException, which should be caused by</span>
<span class="line-added">+                 // the underlying plain socket and could be handled by</span>
<span class="line-added">+                 // applications (for example, re-try the connection).</span>
  
              // Is the sequence number is nearly overflow, or has the key usage
              // limit been reached?
              if (conContext.outputRecord.seqNumIsHuge() ||
                      conContext.outputRecord.writeCipher.atKeyLimit()) {
                  tryKeyUpdate();
              }
<span class="line-added">+             // Check if NewSessionTicket PostHandshake message needs to be sent</span>
<span class="line-added">+             if (conContext.conSession.updateNST) {</span>
<span class="line-added">+                 conContext.conSession.updateNST = false;</span>
<span class="line-added">+                 tryNewSessionTicket();</span>
<span class="line-added">+             }</span>
          }
  
          @Override
          public void close() throws IOException {
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                  SSLLogger.finest(&quot;Closing output stream&quot;);
              }
  
              try {
<span class="line-modified">!                 SSLSocketImpl.this.close();</span>
              } catch (IOException ioe) {
                  // ignore the exception
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
                      SSLLogger.warning(&quot;output stream close failed&quot;, ioe);
                  }
              }
          }
      }
  
      @Override
<span class="line-modified">!     public SSLParameters getSSLParameters() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.getSSLParameters();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void setSSLParameters(SSLParameters params) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.setSSLParameters(params);</span>
  
<span class="line-modified">!             if (conContext.sslConfig.maximumPacketSize != 0) {</span>
<span class="line-modified">!                 conContext.outputRecord.changePacketSize(</span>
<span class="line-modified">!                         conContext.sslConfig.maximumPacketSize);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
          }
      }
  
      @Override
<span class="line-modified">!     public String getApplicationProtocol() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.applicationProtocol;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public String getHandshakeApplicationProtocol() {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             if (conContext.handshakeContext != null) {</span>
<span class="line-added">+                 return conContext.handshakeContext.applicationProtocol;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
          }
  
          return null;
      }
  
      @Override
<span class="line-modified">!     public void setHandshakeApplicationProtocolSelector(</span>
              BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt; selector) {
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             conContext.sslConfig.socketAPSelector = selector;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public BiFunction&lt;SSLSocket, List&lt;String&gt;, String&gt;</span>
              getHandshakeApplicationProtocolSelector() {
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return conContext.sslConfig.socketAPSelector;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Read the initial handshake records.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1147,12 ***</span>
                  buffer = ByteBuffer.allocate(inLen);
              }
  
              try {
                  Plaintext plainText;
<span class="line-modified">!                 synchronized (this) {</span>
                      plainText = decode(buffer);
                  }
                  if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
                          buffer.position() &gt; 0) {
                      return buffer;
                  }
<span class="line-new-header">--- 1426,15 ---</span>
                  buffer = ByteBuffer.allocate(inLen);
              }
  
              try {
                  Plaintext plainText;
<span class="line-modified">!                 socketLock.lock();</span>
<span class="line-added">+                 try {</span>
                      plainText = decode(buffer);
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     socketLock.unlock();</span>
                  }
                  if (plainText.contentType == ContentType.APPLICATION_DATA.id &amp;&amp;
                          buffer.position() &gt; 0) {
                      return buffer;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1222,36 ***</span>
              }
              startHandshake();
          }
      }
  
      /**
       * Initialize the handshaker and socket streams.
       *
       * Called by connect, the layered constructor, and SSLServerSocket.
       */
<span class="line-modified">!     synchronized void doneConnect() throws IOException {</span>
<span class="line-modified">!         // In server mode, it is not necessary to set host and serverNames.</span>
<span class="line-modified">!         // Otherwise, would require a reverse DNS lookup to get the hostname.</span>
<span class="line-modified">!         if (peerHost == null || peerHost.isEmpty()) {</span>
<span class="line-modified">!             boolean useNameService =</span>
<span class="line-modified">!                     trustNameService &amp;&amp; conContext.sslConfig.isClientMode;</span>
<span class="line-modified">!             useImplicitHost(useNameService);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             conContext.sslConfig.serverNames =</span>
<span class="line-modified">!                     Utilities.addToSNIServerNameList(</span>
<span class="line-modified">!                             conContext.sslConfig.serverNames, peerHost);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         InputStream sockInput = super.getInputStream();</span>
<span class="line-modified">!         conContext.inputRecord.setReceiverStream(sockInput);</span>
  
<span class="line-modified">!         OutputStream sockOutput = super.getOutputStream();</span>
<span class="line-modified">!         conContext.inputRecord.setDeliverStream(sockOutput);</span>
<span class="line-modified">!         conContext.outputRecord.setDeliverStream(sockOutput);</span>
  
<span class="line-modified">!         this.isConnected = true;</span>
      }
  
      private void useImplicitHost(boolean useNameService) {
          // Note: If the local name service is not trustworthy, reverse
          // host name resolution should not be performed for endpoint
<span class="line-new-header">--- 1504,61 ---</span>
              }
              startHandshake();
          }
      }
  
<span class="line-added">+     // Try to generate a PostHandshake NewSessionTicket message.  This is</span>
<span class="line-added">+     // TLS 1.3 only.</span>
<span class="line-added">+     private void tryNewSessionTicket() throws IOException {</span>
<span class="line-added">+         // Don&#39;t bother to kickstart if handshaking is in progress, or if the</span>
<span class="line-added">+         // connection is not duplex-open.</span>
<span class="line-added">+         if (!conContext.sslConfig.isClientMode &amp;&amp;</span>
<span class="line-added">+                 conContext.protocolVersion.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">+                 conContext.handshakeContext == null &amp;&amp;</span>
<span class="line-added">+                 !conContext.isOutboundClosed() &amp;&amp;</span>
<span class="line-added">+                 !conContext.isInboundClosed() &amp;&amp;</span>
<span class="line-added">+                 !conContext.isBroken) {</span>
<span class="line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">+                 SSLLogger.finest(&quot;trigger new session ticket&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             NewSessionTicket.kickstartProducer.produce(</span>
<span class="line-added">+                     new PostHandshakeContext(conContext));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Initialize the handshaker and socket streams.
       *
       * Called by connect, the layered constructor, and SSLServerSocket.
       */
<span class="line-modified">!     void doneConnect() throws IOException {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // In server mode, it is not necessary to set host and serverNames.</span>
<span class="line-modified">!             // Otherwise, would require a reverse DNS lookup to get</span>
<span class="line-modified">!             // the hostname.</span>
<span class="line-modified">!             if (peerHost == null || peerHost.isEmpty()) {</span>
<span class="line-modified">!                 boolean useNameService =</span>
<span class="line-modified">!                         trustNameService &amp;&amp; conContext.sslConfig.isClientMode;</span>
<span class="line-modified">!                 useImplicitHost(useNameService);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 conContext.sslConfig.serverNames =</span>
<span class="line-added">+                         Utilities.addToSNIServerNameList(</span>
<span class="line-added">+                                 conContext.sslConfig.serverNames, peerHost);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             InputStream sockInput = super.getInputStream();</span>
<span class="line-modified">!             conContext.inputRecord.setReceiverStream(sockInput);</span>
  
<span class="line-modified">!             OutputStream sockOutput = super.getOutputStream();</span>
<span class="line-modified">!             conContext.inputRecord.setDeliverStream(sockOutput);</span>
<span class="line-modified">!             conContext.outputRecord.setDeliverStream(sockOutput);</span>
  
<span class="line-modified">!             this.isConnected = true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      private void useImplicitHost(boolean useNameService) {
          // Note: If the local name service is not trustworthy, reverse
          // host name resolution should not be performed for endpoint
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1293,15 ***</span>
      // ONLY used by HttpsClient to setup the URI specified hostname
      //
      // Please NOTE that this method MUST be called before calling to
      // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
      // may override SNIHostName in the customized server name indication.
<span class="line-modified">!     public synchronized void setHost(String host) {</span>
<span class="line-modified">!         this.peerHost = host;</span>
<span class="line-modified">!         this.conContext.sslConfig.serverNames =</span>
<span class="line-modified">!                 Utilities.addToSNIServerNameList(</span>
<span class="line-modified">!                         conContext.sslConfig.serverNames, host);</span>
      }
  
      /**
       * Handle an exception.
       *
<span class="line-new-header">--- 1600,20 ---</span>
      // ONLY used by HttpsClient to setup the URI specified hostname
      //
      // Please NOTE that this method MUST be called before calling to
      // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
      // may override SNIHostName in the customized server name indication.
<span class="line-modified">!     public void setHost(String host) {</span>
<span class="line-modified">!         socketLock.lock();</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             this.peerHost = host;</span>
<span class="line-modified">!             this.conContext.sslConfig.serverNames =</span>
<span class="line-added">+                     Utilities.addToSNIServerNameList(</span>
<span class="line-added">+                             conContext.sslConfig.serverNames, host);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             socketLock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Handle an exception.
       *
</pre>
<center><a href="SSLSessionImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLSocketInputRecord.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
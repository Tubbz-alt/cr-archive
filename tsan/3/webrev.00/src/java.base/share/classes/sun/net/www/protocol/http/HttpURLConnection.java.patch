diff a/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java b/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
--- a/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
+++ b/src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -66,10 +66,11 @@
 import java.util.Set;
 import java.util.StringJoiner;
 import jdk.internal.access.JavaNetHttpCookieAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.net.*;
+import sun.net.util.IPAddressUtil;
 import sun.net.www.*;
 import sun.net.www.http.HttpClient;
 import sun.net.www.http.PosterOutputStream;
 import sun.net.www.http.ChunkedInputStream;
 import sun.net.www.http.ChunkedOutputStream;
@@ -309,19 +310,20 @@
     protected volatile String authenticatorKey;
 
     private CookieHandler cookieHandler;
     private final ResponseCache cacheHandler;
 
+    private volatile boolean usingProxy;
+
     // the cached response, and cached response headers and body
     protected CacheResponse cachedResponse;
     private MessageHeader cachedHeaders;
     private InputStream cachedInputStream;
 
     /* output stream to server */
     protected PrintStream ps = null;
 
-
     /* buffered error stream */
     private InputStream errorStream = null;
 
     /* User set Cookies */
     private boolean setUserCookies = true;
@@ -866,12 +868,17 @@
         if (u != null) {
             if (u.toExternalForm().indexOf('\n') > -1) {
                 throw new MalformedURLException("Illegal character in URL");
             }
         }
+        String s = IPAddressUtil.checkAuthority(u);
+        if (s != null) {
+            throw new MalformedURLException(s);
+        }
         return u;
     }
+
     protected HttpURLConnection(URL u, Proxy p, Handler handler)
             throws IOException {
         super(checkURL(u));
         requests = new MessageHeader();
         responses = new MessageHeader();
@@ -1170,11 +1177,17 @@
                 if (sel != null) {
                     URI uri = sun.net.www.ParseUtil.toURI(url);
                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
                         logger.finest("ProxySelector Request for " + uri);
                     }
-                    Iterator<Proxy> it = sel.select(uri).iterator();
+                    final List<Proxy> proxies;
+                    try {
+                        proxies = sel.select(uri);
+                    } catch (IllegalArgumentException iae) {
+                        throw new IOException("Failed to select a proxy", iae);
+                    }
+                    final Iterator<Proxy> it = proxies.iterator();
                     Proxy p;
                     while (it.hasNext()) {
                         p = it.next();
                         try {
                             if (!failedOnce) {
@@ -1226,10 +1239,11 @@
                     http = getNewHttpClient(url, instProxy, connectTimeout, false);
                     http.setReadTimeout(readTimeout);
                 }
             }
 
+            usingProxy = usingProxy || usingProxyInternal();
             ps = (PrintStream)http.getOutputStream();
         } catch (IOException e) {
             throw e;
         }
         // constructor to HTTP client calls openserver
@@ -2157,10 +2171,14 @@
                 setTunnelState(TunnelState.NONE);
                 break;
             } while (retryTunnel < maxRedirects);
 
             if (retryTunnel >= maxRedirects || (respCode != HTTP_OK)) {
+                if (respCode != HTTP_PROXY_AUTH) {
+                    // remove all but authenticate responses
+                    responses.reset();
+                }
                 throw new IOException("Unable to tunnel through proxy."+
                                       " Proxy returns \"" +
                                       statusLine + "\"");
             }
         } finally  {
@@ -2257,10 +2275,12 @@
         String host = http.getProxyHostUsed();
         int port = http.getProxyPortUsed();
         if (host != null && authhdr.isPresent()) {
             HeaderParser p = authhdr.headerParser();
             String realm = p.findValue("realm");
+            String charset = p.findValue("charset");
+            boolean isUTF8 = (charset != null && charset.equalsIgnoreCase("UTF-8"));
             String scheme = authhdr.scheme();
             AuthScheme authScheme = UNKNOWN;
             if ("basic".equalsIgnoreCase(scheme)) {
                 authScheme = BASIC;
             } else if ("digest".equalsIgnoreCase(scheme)) {
@@ -2302,11 +2322,11 @@
                                     authenticator,
                                     host, addr, port, "http",
                                     realm, scheme, url, RequestorType.PROXY);
                     if (a != null) {
                         ret = new BasicAuthentication(true, host, port, realm, a,
-                                             getAuthenticatorKey());
+                                             isUTF8, getAuthenticatorKey());
                     }
                     break;
                 case DIGEST:
                     a = privilegedRequestPasswordAuthentication(
                                     authenticator,
@@ -2420,10 +2440,12 @@
         /* When we get an NTLM auth from cache, don't set any special headers */
         if (authhdr.isPresent()) {
             HeaderParser p = authhdr.headerParser();
             String realm = p.findValue("realm");
             String scheme = authhdr.scheme();
+            String charset = p.findValue("charset");
+            boolean isUTF8 = (charset != null && charset.equalsIgnoreCase("UTF-8"));
             AuthScheme authScheme = UNKNOWN;
             if ("basic".equalsIgnoreCase(scheme)) {
                 authScheme = BASIC;
             } else if ("digest".equalsIgnoreCase(scheme)) {
                 authScheme = DIGEST;
@@ -2471,11 +2493,11 @@
                             authenticator,
                             url.getHost(), addr, port, url.getProtocol(),
                             realm, scheme, url, RequestorType.SERVER);
                     if (a != null) {
                         ret = new BasicAuthentication(false, url, realm, a,
-                                    getAuthenticatorKey());
+                                    isUTF8, getAuthenticatorKey());
                     }
                     break;
                 case DIGEST:
                     a = privilegedRequestPasswordAuthentication(
                             authenticator,
@@ -2895,11 +2917,11 @@
      * Disconnect from the web server at the first 401 error. Do not
      * disconnect when using a proxy, a good proxy should have already
      * closed the connection to the web server.
      */
     private void disconnectWeb() throws IOException {
-        if (usingProxy() && http.isKeepingAlive()) {
+        if (usingProxyInternal() && http.isKeepingAlive()) {
             responseCode = -1;
             // clean up, particularly, skip the content part
             // of a 401 error response
             reset();
         } else {
@@ -2998,17 +3020,35 @@
         if (cachedHeaders != null) {
             cachedHeaders.reset();
         }
     }
 
-    public boolean usingProxy() {
+    /**
+     * Returns true only if the established connection is using a proxy
+     */
+    boolean usingProxyInternal() {
         if (http != null) {
             return (http.getProxyHostUsed() != null);
         }
         return false;
     }
 
+    /**
+     * Returns true if the established connection is using a proxy
+     * or if a proxy is specified for the inactive connection
+     */
+    @Override
+    public boolean usingProxy() {
+        if (usingProxy || usingProxyInternal())
+            return true;
+
+        if (instProxy != null)
+            return instProxy.type().equals(Proxy.Type.HTTP);
+
+        return false;
+    }
+
     // constant strings represent set-cookie header names
     private static final String SET_COOKIE = "set-cookie";
     private static final String SET_COOKIE2 = "set-cookie2";
 
     /**

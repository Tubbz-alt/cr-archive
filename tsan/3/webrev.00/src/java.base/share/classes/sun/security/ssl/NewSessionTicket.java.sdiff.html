<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyShareExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.math.BigInteger;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
<span class="line-removed"> 31 import java.security.ProviderException;</span>
 32 import java.security.SecureRandom;
 33 import java.text.MessageFormat;
 34 import java.util.Locale;
<span class="line-removed"> 35 import java.util.Optional;</span>
 36 import javax.crypto.SecretKey;
 37 import javax.net.ssl.SSLHandshakeException;
 38 import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
<span class="line-modified"> 39 </span>
 40 import sun.security.ssl.SSLHandshake.HandshakeMessage;



 41 
 42 /**
 43  * Pack of the NewSessionTicket handshake message.
 44  */
 45 final class NewSessionTicket {
<span class="line-modified"> 46     private static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days</span>
<span class="line-removed"> 47 </span>
 48     static final SSLConsumer handshakeConsumer =
<span class="line-modified"> 49         new NewSessionTicketConsumer();</span>


 50     static final SSLProducer kickstartProducer =
 51         new NewSessionTicketKickstartProducer();
<span class="line-modified"> 52     static final HandshakeProducer handshakeProducer =</span>
<span class="line-modified"> 53         new NewSessionTicketProducer();</span>
 54 
 55     /**
<span class="line-modified"> 56      * The NewSessionTicketMessage handshake message.</span>
 57      */
<span class="line-modified"> 58     static final class NewSessionTicketMessage extends HandshakeMessage {</span>
<span class="line-modified"> 59         final int ticketLifetime;</span>
<span class="line-modified"> 60         final int ticketAgeAdd;</span>
<span class="line-modified"> 61         final byte[] ticketNonce;</span>
<span class="line-modified"> 62         final byte[] ticket;</span>
<span class="line-modified"> 63         final SSLExtensions extensions;</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65         NewSessionTicketMessage(HandshakeContext context,</span>


































































































 66                 int ticketLifetime, SecureRandom generator,
 67                 byte[] ticketNonce, byte[] ticket) {
 68             super(context);
 69 
 70             this.ticketLifetime = ticketLifetime;
 71             this.ticketAgeAdd = generator.nextInt();
 72             this.ticketNonce = ticketNonce;
 73             this.ticket = ticket;
 74             this.extensions = new SSLExtensions(this);
 75         }
 76 
<span class="line-modified"> 77         NewSessionTicketMessage(HandshakeContext context,</span>
 78                 ByteBuffer m) throws IOException {
 79             super(context);
 80 
 81             // struct {
 82             //     uint32 ticket_lifetime;
 83             //     uint32 ticket_age_add;
 84             //     opaque ticket_nonce&lt;0..255&gt;;
 85             //     opaque ticket&lt;1..2^16-1&gt;;
 86             //     Extension extensions&lt;0..2^16-2&gt;;
 87             // } NewSessionTicket;

 88             if (m.remaining() &lt; 14) {
 89                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified"> 90                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>
 91             }
 92 
 93             this.ticketLifetime = Record.getInt32(m);
 94             this.ticketAgeAdd = Record.getInt32(m);
 95             this.ticketNonce = Record.getBytes8(m);
 96 
 97             if (m.remaining() &lt; 5) {
 98                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified"> 99                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>

100             }
101 
102             this.ticket = Record.getBytes16(m);
103             if (ticket.length == 0) {
<span class="line-modified">104                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

105                     &quot;No ticket in the NewSessionTicket handshake message&quot;);

106             }
107 
108             if (m.remaining() &lt; 2) {
109                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">110                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>
111             }
112 
113             SSLExtension[] supportedExtensions =
114                     context.sslConfig.getEnabledExtensions(
<span class="line-modified">115                             SSLHandshake.NEW_SESSION_TICKET);</span>
116             this.extensions = new SSLExtensions(this, m, supportedExtensions);
117         }
118 
119         @Override
120         public SSLHandshake handshakeType() {
<span class="line-modified">121             return SSLHandshake.NEW_SESSION_TICKET;</span>








122         }
123 
124         @Override
125         public int messageLength() {

126             int extLen = extensions.length();
127             if (extLen == 0) {
128                 extLen = 2;     // empty extensions
129             }
130 
<span class="line-modified">131             return 8 + ticketNonce.length + 1 +</span>
<span class="line-modified">132                        ticket.length + 2 + extLen;</span>



133         }
134 
135         @Override
136         public void send(HandshakeOutStream hos) throws IOException {
137             hos.putInt32(ticketLifetime);
138             hos.putInt32(ticketAgeAdd);
139             hos.putBytes8(ticketNonce);
140             hos.putBytes16(ticket);
141 
142             // Is it an empty extensions?
143             if (extensions.length() == 0) {
144                 hos.putInt16(0);
145             } else {
146                 extensions.send(hos);
147             }
148         }
149 
150         @Override
151         public String toString() {
152             MessageFormat messageFormat = new MessageFormat(
153                 &quot;\&quot;NewSessionTicket\&quot;: &#39;{&#39;\n&quot; +
154                 &quot;  \&quot;ticket_lifetime\&quot;      : \&quot;{0}\&quot;,\n&quot; +
155                 &quot;  \&quot;ticket_age_add\&quot;       : \&quot;{1}\&quot;,\n&quot; +
156                 &quot;  \&quot;ticket_nonce\&quot;         : \&quot;{2}\&quot;,\n&quot; +
<span class="line-modified">157                 &quot;  \&quot;ticket\&quot;               : \&quot;{3}\&quot;,\n&quot; +</span>


158                 &quot;  \&quot;extensions\&quot;           : [\n&quot; +
159                 &quot;{4}\n&quot; +
160                 &quot;  ]\n&quot; +
161                 &quot;&#39;}&#39;&quot;,
162                 Locale.ENGLISH);
163 

164             Object[] messageFields = {
165                 ticketLifetime,
166                 &quot;&lt;omitted&gt;&quot;,    //ticketAgeAdd should not be logged
167                 Utilities.toHexString(ticketNonce),
<span class="line-modified">168                 Utilities.toHexString(ticket),</span>
169                 Utilities.indent(extensions.toString(), &quot;    &quot;)
170             };
171 
172             return messageFormat.format(messageFields);
173         }
174     }
175 
176     private static SecretKey derivePreSharedKey(CipherSuite.HashAlg hashAlg,
177             SecretKey resumptionMasterSecret, byte[] nonce) throws IOException {
178         try {
179             HKDF hkdf = new HKDF(hashAlg.name);
180             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
181                     &quot;tls13 resumption&quot;.getBytes(), nonce, hashAlg.hashLength);
182             return hkdf.expand(resumptionMasterSecret, hkdfInfo,
183                     hashAlg.hashLength, &quot;TlsPreSharedKey&quot;);
184         } catch  (GeneralSecurityException gse) {
185             throw (SSLHandshakeException) new SSLHandshakeException(
186                     &quot;Could not derive PSK&quot;).initCause(gse);
187         }
188     }
189 
190     private static final
191             class NewSessionTicketKickstartProducer implements SSLProducer {
192         // Prevent instantiation of this class.
193         private NewSessionTicketKickstartProducer() {
194             // blank
195         }
196 
197         @Override
198         public byte[] produce(ConnectionContext context) throws IOException {


199             // The producing happens in server side only.
<span class="line-modified">200             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>




201 
<span class="line-modified">202             // Is this session resumable?</span>
<span class="line-modified">203             if (!shc.handshakeSession.isRejoinable()) {</span>
<span class="line-modified">204                 return null;</span>
<span class="line-modified">205             }</span>










206 
<span class="line-modified">207             // What&#39;s the requested PSK key exchange modes?</span>
<span class="line-modified">208             //</span>
<span class="line-modified">209             // Note that currently, the NewSessionTicket post-handshake is</span>
<span class="line-modified">210             // produced and delivered only in the current handshake context</span>
<span class="line-modified">211             // if required.</span>
<span class="line-removed">212             PskKeyExchangeModesSpec pkemSpec =</span>
<span class="line-removed">213                     (PskKeyExchangeModesSpec)shc.handshakeExtensions.get(</span>
<span class="line-removed">214                             SSLExtension.PSK_KEY_EXCHANGE_MODES);</span>
<span class="line-removed">215             if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="line-removed">216                 PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="line-removed">217                 // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>
<span class="line-removed">218                 return null;</span>
219             }
220 
221             // get a new session ID
222             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
<span class="line-modified">223                 shc.sslContext.engineGetServerSessionContext();</span>
224             SessionId newId = new SessionId(true,
<span class="line-modified">225                 shc.sslContext.getSecureRandom());</span>
226 
<span class="line-modified">227             Optional&lt;SecretKey&gt; resumptionMasterSecret =</span>
<span class="line-modified">228                 shc.handshakeSession.getResumptionMasterSecret();</span>
<span class="line-modified">229             if (!resumptionMasterSecret.isPresent()) {</span>
230                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
231                     SSLLogger.fine(
232                         &quot;Session has no resumption secret. No ticket sent.&quot;);
233                 }
234                 return null;
235             }
236 
237             // construct the PSK and handshake message
<span class="line-modified">238             BigInteger nonce = shc.handshakeSession.incrTicketNonceCounter();</span>
239             byte[] nonceArr = nonce.toByteArray();
240             SecretKey psk = derivePreSharedKey(
<span class="line-modified">241                     shc.negotiatedCipherSuite.hashAlg,</span>
<span class="line-modified">242                     resumptionMasterSecret.get(), nonceArr);</span>
243 
244             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
245             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
246                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
247                     SSLLogger.fine(
248                         &quot;Session timeout is too long. No ticket sent.&quot;);
249                 }
250                 return null;
251             }
<span class="line-removed">252             NewSessionTicketMessage nstm = new NewSessionTicketMessage(shc,</span>
<span class="line-removed">253                 sessionTimeoutSeconds, shc.sslContext.getSecureRandom(),</span>
<span class="line-removed">254                 nonceArr, newId.getId());</span>
<span class="line-removed">255             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-removed">256                 SSLLogger.fine(</span>
<span class="line-removed">257                         &quot;Produced NewSessionTicket handshake message&quot;, nstm);</span>
<span class="line-removed">258             }</span>
259 
<span class="line-modified">260             // create and cache the new session</span>
<span class="line-modified">261             // The new session must be a child of the existing session so</span>
<span class="line-removed">262             // they will be invalidated together, etc.</span>
263             SSLSessionImpl sessionCopy =
<span class="line-modified">264                     new SSLSessionImpl(shc.handshakeSession, newId);</span>
<span class="line-removed">265             shc.handshakeSession.addChild(sessionCopy);</span>
266             sessionCopy.setPreSharedKey(psk);
267             sessionCopy.setPskIdentity(newId.getId());
<span class="line-modified">268             sessionCopy.setTicketAgeAdd(nstm.ticketAgeAdd);</span>
<span class="line-modified">269             sessionCache.put(sessionCopy);</span>



































270 
271             // Output the handshake message.
<span class="line-modified">272             nstm.write(shc.handshakeOutput);</span>
<span class="line-modified">273             shc.handshakeOutput.flush();</span>







274 
275             // The message has been delivered.
276             return null;
277         }
278     }
279 
280     /**
<span class="line-modified">281      * The &quot;NewSessionTicket&quot; handshake message producer.</span>
282      */
<span class="line-modified">283     private static final class NewSessionTicketProducer</span>
284             implements HandshakeProducer {
285 
286         // Prevent instantiation of this class.
<span class="line-modified">287         private NewSessionTicketProducer() {</span>
288             // blank
289         }
290 
291         @Override
292         public byte[] produce(ConnectionContext context,
293                 HandshakeMessage message) throws IOException {
294 
<span class="line-modified">295             // NSTM may be sent in response to handshake messages.</span>
<span class="line-removed">296             // For example: key update</span>
297 
<span class="line-modified">298             throw new ProviderException(</span>
<span class="line-modified">299                 &quot;NewSessionTicket handshake producer not implemented&quot;);</span>



































300         }
301     }
302 
303     private static final
<span class="line-modified">304             class NewSessionTicketConsumer implements SSLConsumer {</span>
305         // Prevent instantiation of this class.
<span class="line-modified">306         private NewSessionTicketConsumer() {</span>
307             // blank
308         }
309 
310         @Override
311         public void consume(ConnectionContext context,
<span class="line-modified">312                             ByteBuffer message) throws IOException {</span>
313 
314             // Note: Although the resumption master secret depends on the
315             // client&#39;s second flight, servers which do not request client
316             // authentication MAY compute the remainder of the transcript
317             // independently and then send a NewSessionTicket immediately
318             // upon sending its Finished rather than waiting for the client
319             // Finished.
320             //
<span class="line-modified">321             // The consuming happens in client side only.  As the server</span>
<span class="line-modified">322             // may send the NewSessionTicket before handshake complete, the</span>
<span class="line-modified">323             // context may be a PostHandshakeContext or HandshakeContext</span>
<span class="line-removed">324             // instance.</span>
325             HandshakeContext hc = (HandshakeContext)context;
326             NewSessionTicketMessage nstm =
<span class="line-modified">327                     new NewSessionTicketMessage(hc, message);</span>
328             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
329                 SSLLogger.fine(
330                 &quot;Consuming NewSessionTicket message&quot;, nstm);
331             }
332 



333             // discard tickets with timeout 0
334             if (nstm.ticketLifetime &lt;= 0 ||
335                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
336                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
337                     SSLLogger.fine(
338                     &quot;Discarding NewSessionTicket with lifetime &quot;
339                         + nstm.ticketLifetime, nstm);
340                 }

341                 return;
342             }
343 
<span class="line-removed">344             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-removed">345                 hc.sslContext.engineGetClientSessionContext();</span>
<span class="line-removed">346 </span>
347             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
348                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
349                     SSLLogger.fine(
350                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);
351                 }
352                 return;
353             }
354 
355             SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="line-modified">356 </span>
<span class="line-modified">357             Optional&lt;SecretKey&gt; resumptionMasterSecret =</span>
<span class="line-modified">358                 sessionToSave.getResumptionMasterSecret();</span>
<span class="line-modified">359             if (!resumptionMasterSecret.isPresent()) {</span>
<span class="line-modified">360                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">361                     SSLLogger.fine(</span>
<span class="line-modified">362                     &quot;Session has no resumption master secret. Ignoring ticket.&quot;);</span>




363                 }
<span class="line-removed">364                 return;</span>
<span class="line-removed">365             }</span>
366 
<span class="line-modified">367             // derive the PSK</span>
<span class="line-modified">368             SecretKey psk = derivePreSharedKey(</span>
<span class="line-modified">369                 sessionToSave.getSuite().hashAlg, resumptionMasterSecret.get(),</span>
<span class="line-modified">370                 nstm.ticketNonce);</span>

371 
372             // create and cache the new session
373             // The new session must be a child of the existing session so
374             // they will be invalidated together, etc.
375             SessionId newId =
<span class="line-modified">376                 new SessionId(true, hc.sslContext.getSecureRandom());</span>
377             SSLSessionImpl sessionCopy = new SSLSessionImpl(sessionToSave,
378                     newId);
379             sessionToSave.addChild(sessionCopy);
380             sessionCopy.setPreSharedKey(psk);
<span class="line-modified">381             sessionCopy.setTicketAgeAdd(nstm.ticketAgeAdd);</span>
382             sessionCopy.setPskIdentity(nstm.ticket);
383             sessionCache.put(sessionCopy);
384 
385             // clean handshake context
<span class="line-modified">386             hc.conContext.finishPostHandshake();</span>























































387         }
388     }
389 }
390 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.math.BigInteger;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;

 31 import java.security.SecureRandom;
 32 import java.text.MessageFormat;
 33 import java.util.Locale;

 34 import javax.crypto.SecretKey;
 35 import javax.net.ssl.SSLHandshakeException;
 36 import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
<span class="line-modified"> 37 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;</span>
 38 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-added"> 39 import sun.security.util.HexDumpEncoder;</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 import static sun.security.ssl.SSLHandshake.NEW_SESSION_TICKET;</span>
 42 
 43 /**
 44  * Pack of the NewSessionTicket handshake message.
 45  */
 46 final class NewSessionTicket {
<span class="line-modified"> 47     static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days</span>

 48     static final SSLConsumer handshakeConsumer =
<span class="line-modified"> 49         new T13NewSessionTicketConsumer();</span>
<span class="line-added"> 50     static final SSLConsumer handshake12Consumer =</span>
<span class="line-added"> 51         new T12NewSessionTicketConsumer();</span>
 52     static final SSLProducer kickstartProducer =
 53         new NewSessionTicketKickstartProducer();
<span class="line-modified"> 54     static final HandshakeProducer handshake12Producer =</span>
<span class="line-modified"> 55         new T12NewSessionTicketProducer();</span>
 56 
 57     /**
<span class="line-modified"> 58      * The NewSessionTicketMessage handshake messages.</span>
 59      */
<span class="line-modified"> 60     abstract static class NewSessionTicketMessage extends HandshakeMessage {</span>
<span class="line-modified"> 61         int ticketLifetime;</span>
<span class="line-modified"> 62         byte[] ticket = new byte[0];</span>
<span class="line-modified"> 63 </span>
<span class="line-modified"> 64         NewSessionTicketMessage(HandshakeContext context) {</span>
<span class="line-modified"> 65             super(context);</span>
<span class="line-modified"> 66         }</span>
<span class="line-modified"> 67 </span>
<span class="line-added"> 68         @Override</span>
<span class="line-added"> 69         public SSLHandshake handshakeType() {</span>
<span class="line-added"> 70             return NEW_SESSION_TICKET;</span>
<span class="line-added"> 71         }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73         // For TLS 1.3 only</span>
<span class="line-added"> 74         int getTicketAgeAdd() throws IOException {</span>
<span class="line-added"> 75             throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added"> 76                     &quot;TicketAgeAdd not part of RFC 5077.&quot;);</span>
<span class="line-added"> 77         }</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79         // For TLS 1.3 only</span>
<span class="line-added"> 80         byte[] getTicketNonce() throws IOException {</span>
<span class="line-added"> 81             throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added"> 82                     &quot;TicketNonce not part of RFC 5077.&quot;);</span>
<span class="line-added"> 83         }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85         boolean isValid() {</span>
<span class="line-added"> 86             return (ticket.length &gt; 0);</span>
<span class="line-added"> 87         }</span>
<span class="line-added"> 88     }</span>
<span class="line-added"> 89     /**</span>
<span class="line-added"> 90      * NewSessionTicket for TLS 1.2 and below (RFC 5077)</span>
<span class="line-added"> 91      */</span>
<span class="line-added"> 92     static final class T12NewSessionTicketMessage extends NewSessionTicketMessage {</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94         T12NewSessionTicketMessage(HandshakeContext context,</span>
<span class="line-added"> 95                 int ticketLifetime, byte[] ticket) {</span>
<span class="line-added"> 96             super(context);</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98             this.ticketLifetime = ticketLifetime;</span>
<span class="line-added"> 99             this.ticket = ticket;</span>
<span class="line-added">100         }</span>
<span class="line-added">101 </span>
<span class="line-added">102         T12NewSessionTicketMessage(HandshakeContext context,</span>
<span class="line-added">103                 ByteBuffer m) throws IOException {</span>
<span class="line-added">104 </span>
<span class="line-added">105             // RFC5077 struct {</span>
<span class="line-added">106             //     uint32 ticket_lifetime;</span>
<span class="line-added">107             //     opaque ticket&lt;0..2^16-1&gt;;</span>
<span class="line-added">108             // } NewSessionTicket;</span>
<span class="line-added">109 </span>
<span class="line-added">110             super(context);</span>
<span class="line-added">111             if (m.remaining() &lt; 6) {</span>
<span class="line-added">112                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">113                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);</span>
<span class="line-added">114             }</span>
<span class="line-added">115 </span>
<span class="line-added">116             this.ticketLifetime = Record.getInt32(m);</span>
<span class="line-added">117             this.ticket = Record.getBytes16(m);</span>
<span class="line-added">118         }</span>
<span class="line-added">119 </span>
<span class="line-added">120         @Override</span>
<span class="line-added">121         public SSLHandshake handshakeType() {</span>
<span class="line-added">122             return NEW_SESSION_TICKET;</span>
<span class="line-added">123         }</span>
<span class="line-added">124 </span>
<span class="line-added">125         @Override</span>
<span class="line-added">126         public int messageLength() {</span>
<span class="line-added">127             return 4 + // ticketLifetime</span>
<span class="line-added">128                     2 + ticket.length;  // len of ticket + ticket</span>
<span class="line-added">129         }</span>
<span class="line-added">130 </span>
<span class="line-added">131         @Override</span>
<span class="line-added">132         public void send(HandshakeOutStream hos) throws IOException {</span>
<span class="line-added">133             hos.putInt32(ticketLifetime);</span>
<span class="line-added">134             hos.putBytes16(ticket);</span>
<span class="line-added">135         }</span>
<span class="line-added">136 </span>
<span class="line-added">137         @Override</span>
<span class="line-added">138         public String toString() {</span>
<span class="line-added">139             MessageFormat messageFormat = new MessageFormat(</span>
<span class="line-added">140                     &quot;\&quot;NewSessionTicket\&quot;: &#39;{&#39;\n&quot; +</span>
<span class="line-added">141                             &quot;  \&quot;ticket_lifetime\&quot;      : \&quot;{0}\&quot;,\n&quot; +</span>
<span class="line-added">142                             &quot;  \&quot;ticket\&quot;               : &#39;{&#39;\n&quot; +</span>
<span class="line-added">143                             &quot;{1}\n&quot; +</span>
<span class="line-added">144                             &quot;  &#39;}&#39;&quot; +</span>
<span class="line-added">145                             &quot;&#39;}&#39;&quot;,</span>
<span class="line-added">146                 Locale.ENGLISH);</span>
<span class="line-added">147 </span>
<span class="line-added">148             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
<span class="line-added">149             Object[] messageFields = {</span>
<span class="line-added">150                     ticketLifetime,</span>
<span class="line-added">151                     Utilities.indent(hexEncoder.encode(ticket), &quot;    &quot;),</span>
<span class="line-added">152             };</span>
<span class="line-added">153             return messageFormat.format(messageFields);</span>
<span class="line-added">154         }</span>
<span class="line-added">155     }</span>
<span class="line-added">156 </span>
<span class="line-added">157     /**</span>
<span class="line-added">158      * NewSessionTicket defined by the TLS 1.3</span>
<span class="line-added">159      */</span>
<span class="line-added">160     static final class T13NewSessionTicketMessage extends NewSessionTicketMessage {</span>
<span class="line-added">161         int ticketAgeAdd;</span>
<span class="line-added">162         byte[] ticketNonce;</span>
<span class="line-added">163         SSLExtensions extensions;</span>
<span class="line-added">164 </span>
<span class="line-added">165         T13NewSessionTicketMessage(HandshakeContext context,</span>
166                 int ticketLifetime, SecureRandom generator,
167                 byte[] ticketNonce, byte[] ticket) {
168             super(context);
169 
170             this.ticketLifetime = ticketLifetime;
171             this.ticketAgeAdd = generator.nextInt();
172             this.ticketNonce = ticketNonce;
173             this.ticket = ticket;
174             this.extensions = new SSLExtensions(this);
175         }
176 
<span class="line-modified">177         T13NewSessionTicketMessage(HandshakeContext context,</span>
178                 ByteBuffer m) throws IOException {
179             super(context);
180 
181             // struct {
182             //     uint32 ticket_lifetime;
183             //     uint32 ticket_age_add;
184             //     opaque ticket_nonce&lt;0..255&gt;;
185             //     opaque ticket&lt;1..2^16-1&gt;;
186             //     Extension extensions&lt;0..2^16-2&gt;;
187             // } NewSessionTicket;
<span class="line-added">188 </span>
189             if (m.remaining() &lt; 14) {
190                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">191                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);</span>
192             }
193 
194             this.ticketLifetime = Record.getInt32(m);
195             this.ticketAgeAdd = Record.getInt32(m);
196             this.ticketNonce = Record.getBytes8(m);
197 
198             if (m.remaining() &lt; 5) {
199                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">200                     &quot;Invalid NewSessionTicket message: insufficient ticket&quot; +</span>
<span class="line-added">201                             &quot; data&quot;);</span>
202             }
203 
204             this.ticket = Record.getBytes16(m);
205             if (ticket.length == 0) {
<span class="line-modified">206                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">207                     SSLLogger.fine(</span>
208                     &quot;No ticket in the NewSessionTicket handshake message&quot;);
<span class="line-added">209                 }</span>
210             }
211 
212             if (m.remaining() &lt; 2) {
213                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">214                     &quot;Invalid NewSessionTicket message: extra data&quot;);</span>
215             }
216 
217             SSLExtension[] supportedExtensions =
218                     context.sslConfig.getEnabledExtensions(
<span class="line-modified">219                             NEW_SESSION_TICKET);</span>
220             this.extensions = new SSLExtensions(this, m, supportedExtensions);
221         }
222 
223         @Override
224         public SSLHandshake handshakeType() {
<span class="line-modified">225             return NEW_SESSION_TICKET;</span>
<span class="line-added">226         }</span>
<span class="line-added">227 </span>
<span class="line-added">228         int getTicketAgeAdd() {</span>
<span class="line-added">229             return ticketAgeAdd;</span>
<span class="line-added">230         }</span>
<span class="line-added">231 </span>
<span class="line-added">232         byte[] getTicketNonce() {</span>
<span class="line-added">233             return ticketNonce;</span>
234         }
235 
236         @Override
237         public int messageLength() {
<span class="line-added">238 </span>
239             int extLen = extensions.length();
240             if (extLen == 0) {
241                 extLen = 2;     // empty extensions
242             }
243 
<span class="line-modified">244             return 4 +// ticketLifetime</span>
<span class="line-modified">245                     4 + // ticketAgeAdd</span>
<span class="line-added">246                     1 + ticketNonce.length + // len of nonce + nonce</span>
<span class="line-added">247                     2 + ticket.length + // len of ticket + ticket</span>
<span class="line-added">248                     extLen;</span>
249         }
250 
251         @Override
252         public void send(HandshakeOutStream hos) throws IOException {
253             hos.putInt32(ticketLifetime);
254             hos.putInt32(ticketAgeAdd);
255             hos.putBytes8(ticketNonce);
256             hos.putBytes16(ticket);
257 
258             // Is it an empty extensions?
259             if (extensions.length() == 0) {
260                 hos.putInt16(0);
261             } else {
262                 extensions.send(hos);
263             }
264         }
265 
266         @Override
267         public String toString() {
268             MessageFormat messageFormat = new MessageFormat(
269                 &quot;\&quot;NewSessionTicket\&quot;: &#39;{&#39;\n&quot; +
270                 &quot;  \&quot;ticket_lifetime\&quot;      : \&quot;{0}\&quot;,\n&quot; +
271                 &quot;  \&quot;ticket_age_add\&quot;       : \&quot;{1}\&quot;,\n&quot; +
272                 &quot;  \&quot;ticket_nonce\&quot;         : \&quot;{2}\&quot;,\n&quot; +
<span class="line-modified">273                 &quot;  \&quot;ticket\&quot;               : &#39;{&#39;\n&quot; +</span>
<span class="line-added">274                 &quot;{3}\n&quot; +</span>
<span class="line-added">275                 &quot;  &#39;}&#39;&quot; +</span>
276                 &quot;  \&quot;extensions\&quot;           : [\n&quot; +
277                 &quot;{4}\n&quot; +
278                 &quot;  ]\n&quot; +
279                 &quot;&#39;}&#39;&quot;,
280                 Locale.ENGLISH);
281 
<span class="line-added">282             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
283             Object[] messageFields = {
284                 ticketLifetime,
285                 &quot;&lt;omitted&gt;&quot;,    //ticketAgeAdd should not be logged
286                 Utilities.toHexString(ticketNonce),
<span class="line-modified">287                 Utilities.indent(hexEncoder.encode(ticket), &quot;    &quot;),</span>
288                 Utilities.indent(extensions.toString(), &quot;    &quot;)
289             };
290 
291             return messageFormat.format(messageFields);
292         }
293     }
294 
295     private static SecretKey derivePreSharedKey(CipherSuite.HashAlg hashAlg,
296             SecretKey resumptionMasterSecret, byte[] nonce) throws IOException {
297         try {
298             HKDF hkdf = new HKDF(hashAlg.name);
299             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
300                     &quot;tls13 resumption&quot;.getBytes(), nonce, hashAlg.hashLength);
301             return hkdf.expand(resumptionMasterSecret, hkdfInfo,
302                     hashAlg.hashLength, &quot;TlsPreSharedKey&quot;);
303         } catch  (GeneralSecurityException gse) {
304             throw (SSLHandshakeException) new SSLHandshakeException(
305                     &quot;Could not derive PSK&quot;).initCause(gse);
306         }
307     }
308 
309     private static final
310             class NewSessionTicketKickstartProducer implements SSLProducer {
311         // Prevent instantiation of this class.
312         private NewSessionTicketKickstartProducer() {
313             // blank
314         }
315 
316         @Override
317         public byte[] produce(ConnectionContext context) throws IOException {
<span class="line-added">318             HandshakeContext hc = (HandshakeContext)context;</span>
<span class="line-added">319 </span>
320             // The producing happens in server side only.
<span class="line-modified">321             if (hc instanceof ServerHandshakeContext) {</span>
<span class="line-added">322                 // Is this session resumable?</span>
<span class="line-added">323                 if (!hc.handshakeSession.isRejoinable()) {</span>
<span class="line-added">324                     return null;</span>
<span class="line-added">325                 }</span>
326 
<span class="line-modified">327                 // What&#39;s the requested PSK key exchange modes?</span>
<span class="line-modified">328                 //</span>
<span class="line-modified">329                 // Note that currently, the NewSessionTicket post-handshake is</span>
<span class="line-modified">330                 // produced and delivered only in the current handshake context</span>
<span class="line-added">331                 // if required.</span>
<span class="line-added">332                 PskKeyExchangeModesSpec pkemSpec =</span>
<span class="line-added">333                         (PskKeyExchangeModesSpec) hc.handshakeExtensions.get(</span>
<span class="line-added">334                                 SSLExtension.PSK_KEY_EXCHANGE_MODES);</span>
<span class="line-added">335                 if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="line-added">336                         PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="line-added">337                     // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>
<span class="line-added">338                     return null;</span>
<span class="line-added">339                 }</span>
<span class="line-added">340             } else { // PostHandshakeContext</span>
341 
<span class="line-modified">342                 // Check if we have sent a PSK already, then we know it is using a</span>
<span class="line-modified">343                 // allowable PSK exchange key mode</span>
<span class="line-modified">344                 if (!hc.handshakeSession.isPSKable()) {</span>
<span class="line-modified">345                     return null;</span>
<span class="line-modified">346                 }</span>







347             }
348 
349             // get a new session ID
350             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
<span class="line-modified">351                 hc.sslContext.engineGetServerSessionContext();</span>
352             SessionId newId = new SessionId(true,
<span class="line-modified">353                 hc.sslContext.getSecureRandom());</span>
354 
<span class="line-modified">355             SecretKey resumptionMasterSecret =</span>
<span class="line-modified">356                 hc.handshakeSession.getResumptionMasterSecret();</span>
<span class="line-modified">357             if (resumptionMasterSecret == null) {</span>
358                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
359                     SSLLogger.fine(
360                         &quot;Session has no resumption secret. No ticket sent.&quot;);
361                 }
362                 return null;
363             }
364 
365             // construct the PSK and handshake message
<span class="line-modified">366             BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();</span>
367             byte[] nonceArr = nonce.toByteArray();
368             SecretKey psk = derivePreSharedKey(
<span class="line-modified">369                     hc.negotiatedCipherSuite.hashAlg,</span>
<span class="line-modified">370                     resumptionMasterSecret, nonceArr);</span>
371 
372             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
373             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
374                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
375                     SSLLogger.fine(
376                         &quot;Session timeout is too long. No ticket sent.&quot;);
377                 }
378                 return null;
379             }







380 
<span class="line-modified">381             NewSessionTicketMessage nstm = null;</span>
<span class="line-modified">382 </span>

383             SSLSessionImpl sessionCopy =
<span class="line-modified">384                     new SSLSessionImpl(hc.handshakeSession, newId);</span>

385             sessionCopy.setPreSharedKey(psk);
386             sessionCopy.setPskIdentity(newId.getId());
<span class="line-modified">387 </span>
<span class="line-modified">388             // If a stateless ticket is allowed, attempt to make one</span>
<span class="line-added">389             if (hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="line-added">390                 nstm = new T13NewSessionTicketMessage(hc,</span>
<span class="line-added">391                         sessionTimeoutSeconds,</span>
<span class="line-added">392                         hc.sslContext.getSecureRandom(),</span>
<span class="line-added">393                         nonceArr,</span>
<span class="line-added">394                         new SessionTicketSpec().encrypt(hc, sessionCopy));</span>
<span class="line-added">395                 // If ticket construction failed, switch to session cache</span>
<span class="line-added">396                 if (!nstm.isValid()) {</span>
<span class="line-added">397                     hc.statelessResumption = false;</span>
<span class="line-added">398                 } else {</span>
<span class="line-added">399                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">400                         SSLLogger.fine(</span>
<span class="line-added">401                                 &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="line-added">402                                         &quot;handshake message&quot;, nstm);</span>
<span class="line-added">403                     }</span>
<span class="line-added">404                 }</span>
<span class="line-added">405             }</span>
<span class="line-added">406             // If a session cache ticket is being used, make one</span>
<span class="line-added">407             if (!hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="line-added">408                 nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,</span>
<span class="line-added">409                         hc.sslContext.getSecureRandom(), nonceArr,</span>
<span class="line-added">410                         newId.getId());</span>
<span class="line-added">411                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">412                     SSLLogger.fine(</span>
<span class="line-added">413                             &quot;Produced NewSessionTicket handshake message&quot;,</span>
<span class="line-added">414                             nstm);</span>
<span class="line-added">415                 }</span>
<span class="line-added">416 </span>
<span class="line-added">417                 // create and cache the new session</span>
<span class="line-added">418                 // The new session must be a child of the existing session so</span>
<span class="line-added">419                 // they will be invalidated together, etc.</span>
<span class="line-added">420                 hc.handshakeSession.addChild(sessionCopy);</span>
<span class="line-added">421                 sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());</span>
<span class="line-added">422                 sessionCache.put(sessionCopy);</span>
<span class="line-added">423             }</span>
424 
425             // Output the handshake message.
<span class="line-modified">426             if (nstm != null) {</span>
<span class="line-modified">427                 // should never be null</span>
<span class="line-added">428                 nstm.write(hc.handshakeOutput);</span>
<span class="line-added">429                 hc.handshakeOutput.flush();</span>
<span class="line-added">430             }</span>
<span class="line-added">431 </span>
<span class="line-added">432             if (hc instanceof PostHandshakeContext) {</span>
<span class="line-added">433                 ((PostHandshakeContext) hc).finish();</span>
<span class="line-added">434             }</span>
435 
436             // The message has been delivered.
437             return null;
438         }
439     }
440 
441     /**
<span class="line-modified">442      * The &quot;NewSessionTicket&quot; handshake message producer for RFC 5077</span>
443      */
<span class="line-modified">444     private static final class T12NewSessionTicketProducer</span>
445             implements HandshakeProducer {
446 
447         // Prevent instantiation of this class.
<span class="line-modified">448         private T12NewSessionTicketProducer() {</span>
449             // blank
450         }
451 
452         @Override
453         public byte[] produce(ConnectionContext context,
454                 HandshakeMessage message) throws IOException {
455 
<span class="line-modified">456             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>

457 
<span class="line-modified">458             // Is this session resumable?</span>
<span class="line-modified">459             if (!shc.handshakeSession.isRejoinable()) {</span>
<span class="line-added">460                 return null;</span>
<span class="line-added">461             }</span>
<span class="line-added">462 </span>
<span class="line-added">463             // get a new session ID</span>
<span class="line-added">464             SessionId newId = shc.handshakeSession.getSessionId();</span>
<span class="line-added">465 </span>
<span class="line-added">466             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-added">467                     shc.sslContext.engineGetServerSessionContext();</span>
<span class="line-added">468             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();</span>
<span class="line-added">469             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {</span>
<span class="line-added">470                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">471                     SSLLogger.fine(</span>
<span class="line-added">472                         &quot;Session timeout is too long. No ticket sent.&quot;);</span>
<span class="line-added">473                 }</span>
<span class="line-added">474                 return null;</span>
<span class="line-added">475             }</span>
<span class="line-added">476 </span>
<span class="line-added">477             SSLSessionImpl sessionCopy =</span>
<span class="line-added">478                     new SSLSessionImpl(shc.handshakeSession, newId);</span>
<span class="line-added">479             sessionCopy.setPskIdentity(newId.getId());</span>
<span class="line-added">480 </span>
<span class="line-added">481             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(shc,</span>
<span class="line-added">482                     sessionTimeoutSeconds,</span>
<span class="line-added">483                     new SessionTicketSpec().encrypt(shc, sessionCopy));</span>
<span class="line-added">484             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">485                 SSLLogger.fine(</span>
<span class="line-added">486                         &quot;Produced NewSessionTicket stateless handshake message&quot;, nstm);</span>
<span class="line-added">487             }</span>
<span class="line-added">488 </span>
<span class="line-added">489             // Output the handshake message.</span>
<span class="line-added">490             nstm.write(shc.handshakeOutput);</span>
<span class="line-added">491             shc.handshakeOutput.flush();</span>
<span class="line-added">492 </span>
<span class="line-added">493             // The message has been delivered.</span>
<span class="line-added">494             return null;</span>
495         }
496     }
497 
498     private static final
<span class="line-modified">499     class T13NewSessionTicketConsumer implements SSLConsumer {</span>
500         // Prevent instantiation of this class.
<span class="line-modified">501         private T13NewSessionTicketConsumer() {</span>
502             // blank
503         }
504 
505         @Override
506         public void consume(ConnectionContext context,
<span class="line-modified">507                 ByteBuffer message) throws IOException {</span>
508 
509             // Note: Although the resumption master secret depends on the
510             // client&#39;s second flight, servers which do not request client
511             // authentication MAY compute the remainder of the transcript
512             // independently and then send a NewSessionTicket immediately
513             // upon sending its Finished rather than waiting for the client
514             // Finished.
515             //
<span class="line-modified">516             // The consuming happens in client side only and is received after</span>
<span class="line-modified">517             // the server&#39;s Finished message with PostHandshakeContext.</span>
<span class="line-modified">518 </span>

519             HandshakeContext hc = (HandshakeContext)context;
520             NewSessionTicketMessage nstm =
<span class="line-modified">521                     new T13NewSessionTicketMessage(hc, message);</span>
522             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
523                 SSLLogger.fine(
524                 &quot;Consuming NewSessionTicket message&quot;, nstm);
525             }
526 
<span class="line-added">527             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-added">528                     hc.sslContext.engineGetClientSessionContext();</span>
<span class="line-added">529 </span>
530             // discard tickets with timeout 0
531             if (nstm.ticketLifetime &lt;= 0 ||
532                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
533                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
534                     SSLLogger.fine(
535                     &quot;Discarding NewSessionTicket with lifetime &quot;
536                         + nstm.ticketLifetime, nstm);
537                 }
<span class="line-added">538                 sessionCache.remove(hc.handshakeSession.getSessionId());</span>
539                 return;
540             }
541 



542             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
543                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
544                     SSLLogger.fine(
545                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);
546                 }
547                 return;
548             }
549 
550             SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="line-modified">551             SecretKey psk = null;</span>
<span class="line-modified">552             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-modified">553                 SecretKey resumptionMasterSecret =</span>
<span class="line-modified">554                         sessionToSave.getResumptionMasterSecret();</span>
<span class="line-modified">555                 if (resumptionMasterSecret == null) {</span>
<span class="line-modified">556                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">557                         SSLLogger.fine(</span>
<span class="line-added">558                                 &quot;Session has no resumption master secret.&quot; +</span>
<span class="line-added">559                                         &quot; Ignoring ticket.&quot;);</span>
<span class="line-added">560                     }</span>
<span class="line-added">561                     return;</span>
562                 }


563 
<span class="line-modified">564                 // derive the PSK</span>
<span class="line-modified">565                 psk = derivePreSharedKey(</span>
<span class="line-modified">566                         sessionToSave.getSuite().hashAlg,</span>
<span class="line-modified">567                         resumptionMasterSecret, nstm.getTicketNonce());</span>
<span class="line-added">568             }</span>
569 
570             // create and cache the new session
571             // The new session must be a child of the existing session so
572             // they will be invalidated together, etc.
573             SessionId newId =
<span class="line-modified">574                     new SessionId(true, hc.sslContext.getSecureRandom());</span>
575             SSLSessionImpl sessionCopy = new SSLSessionImpl(sessionToSave,
576                     newId);
577             sessionToSave.addChild(sessionCopy);
578             sessionCopy.setPreSharedKey(psk);
<span class="line-modified">579             sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());</span>
580             sessionCopy.setPskIdentity(nstm.ticket);
581             sessionCache.put(sessionCopy);
582 
583             // clean handshake context
<span class="line-modified">584             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-added">585                 hc.conContext.finishPostHandshake();</span>
<span class="line-added">586             }</span>
<span class="line-added">587         }</span>
<span class="line-added">588     }</span>
<span class="line-added">589 </span>
<span class="line-added">590     private static final</span>
<span class="line-added">591     class T12NewSessionTicketConsumer implements SSLConsumer {</span>
<span class="line-added">592         // Prevent instantiation of this class.</span>
<span class="line-added">593         private T12NewSessionTicketConsumer() {</span>
<span class="line-added">594             // blank</span>
<span class="line-added">595         }</span>
<span class="line-added">596 </span>
<span class="line-added">597         @Override</span>
<span class="line-added">598         public void consume(ConnectionContext context,</span>
<span class="line-added">599                 ByteBuffer message) throws IOException {</span>
<span class="line-added">600 </span>
<span class="line-added">601             HandshakeContext hc = (HandshakeContext)context;</span>
<span class="line-added">602             hc.handshakeConsumers.remove(NEW_SESSION_TICKET.id);</span>
<span class="line-added">603 </span>
<span class="line-added">604             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(hc,</span>
<span class="line-added">605                     message);</span>
<span class="line-added">606             if (nstm.ticket.length == 0) {</span>
<span class="line-added">607                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">608                     SSLLogger.fine(&quot;NewSessionTicket ticket was empty&quot;);</span>
<span class="line-added">609                 }</span>
<span class="line-added">610                 return;</span>
<span class="line-added">611             }</span>
<span class="line-added">612 </span>
<span class="line-added">613             // discard tickets with timeout 0</span>
<span class="line-added">614             if (nstm.ticketLifetime &lt;= 0 ||</span>
<span class="line-added">615                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {</span>
<span class="line-added">616                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">617                     SSLLogger.fine(</span>
<span class="line-added">618                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="line-added">619                         + nstm.ticketLifetime, nstm);</span>
<span class="line-added">620                 }</span>
<span class="line-added">621                 return;</span>
<span class="line-added">622             }</span>
<span class="line-added">623 </span>
<span class="line-added">624             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="line-added">625                     hc.sslContext.engineGetClientSessionContext();</span>
<span class="line-added">626 </span>
<span class="line-added">627             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {</span>
<span class="line-added">628                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">629                     SSLLogger.fine(</span>
<span class="line-added">630                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>
<span class="line-added">631                 }</span>
<span class="line-added">632                 return;</span>
<span class="line-added">633             }</span>
<span class="line-added">634 </span>
<span class="line-added">635             hc.handshakeSession.setPskIdentity(nstm.ticket);</span>
<span class="line-added">636             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">637                 SSLLogger.fine(&quot;Consuming NewSessionTicket\n&quot; +</span>
<span class="line-added">638                         nstm.toString());</span>
<span class="line-added">639             }</span>
640         }
641     }
642 }
643 
</pre>
</td>
</tr>
</table>
<center><a href="KeyShareExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OutputRecord.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
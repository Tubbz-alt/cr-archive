<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/CurveDB.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstraintsParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerIndefLenConverter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/CurveDB.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45     private static final int PD = 5; // prime curve, mark as default
 46     private static final int BD = 6; // binary curve, mark as default
 47 
 48     private static final Map&lt;String,NamedCurve&gt; oidMap =
 49         new LinkedHashMap&lt;String,NamedCurve&gt;();
 50     private static final Map&lt;String,NamedCurve&gt; nameMap =
 51         new HashMap&lt;String,NamedCurve&gt;();
 52     private static final Map&lt;Integer,NamedCurve&gt; lengthMap =
 53         new HashMap&lt;Integer,NamedCurve&gt;();
 54 
 55     private static Collection&lt;? extends NamedCurve&gt; specCollection;
 56 
 57     public static final String SPLIT_PATTERN = &quot;,|\\[|\\]&quot;;
 58 
 59     // Used by SunECEntries
 60     public static Collection&lt;? extends NamedCurve&gt;getSupportedCurves() {
 61         return specCollection;
 62     }
 63 
 64     // Return a NamedCurve for the specified OID/name or null if unknown.
<span class="line-modified"> 65     static NamedCurve lookup(String name) {</span>
 66         NamedCurve spec = oidMap.get(name);
 67         if (spec != null) {
 68             return spec;
 69         }
 70 
<span class="line-modified"> 71         return nameMap.get(name);</span>
 72     }
 73 
 74     // Return EC parameters for the specified field size. If there are known
 75     // NIST recommended parameters for the given length, they are returned.
 76     // Otherwise, if there are multiple matches for the given size, an
 77     // arbitrary one is returns.
 78     // If no parameters are known, the method returns null.
 79     // NOTE that this method returns both prime and binary curves.
 80     static NamedCurve lookup(int length) {
 81         return lengthMap.get(length);
 82     }
 83 
 84     // Convert the given ECParameterSpec object to a NamedCurve object.
 85     // If params does not represent a known named curve, return null.
<span class="line-modified"> 86     static NamedCurve lookup(ECParameterSpec params) {</span>
 87         if ((params instanceof NamedCurve) || (params == null)) {
 88             return (NamedCurve)params;
 89         }
 90 
 91         // This is a hack to allow SunJSSE to work with 3rd party crypto
 92         // providers for ECC and not just SunPKCS11.
 93         // This can go away once we decide how to expose curve names in the
 94         // public API.
 95         // Note that it assumes that the 3rd party provider encodes named
 96         // curves using the short form, not explicitly. If it did that, then
 97         // the SunJSSE TLS ECC extensions are wrong, which could lead to
 98         // interoperability problems.
 99         int fieldSize = params.getCurve().getField().getFieldSize();
100         for (NamedCurve namedCurve : specCollection) {
101             // ECParameterSpec does not define equals, so check all the
102             // components ourselves.
103             // Quick field size check first
104             if (namedCurve.getCurve().getField().getFieldSize() != fieldSize) {
105                 continue;
106             }
<span class="line-modified">107             if (namedCurve.getCurve().equals(params.getCurve()) == false) {</span>
<span class="line-modified">108                 continue;</span>
<span class="line-modified">109             }</span>
<span class="line-removed">110             if (namedCurve.getGenerator().equals(params.getGenerator()) ==</span>
<span class="line-removed">111                     false) {</span>
<span class="line-removed">112                 continue;</span>
<span class="line-removed">113             }</span>
<span class="line-removed">114             if (namedCurve.getOrder().equals(params.getOrder()) == false) {</span>
<span class="line-removed">115                 continue;</span>
<span class="line-removed">116             }</span>
<span class="line-removed">117             if (namedCurve.getCofactor() != params.getCofactor()) {</span>
<span class="line-removed">118                 continue;</span>
119             }
<span class="line-removed">120             // everything matches our named curve, return it</span>
<span class="line-removed">121             return namedCurve;</span>
122         }
123         // no match found
124         return null;
125     }
126 
127     private static BigInteger bi(String s) {
128         return new BigInteger(s, 16);
129     }
130 
131     private static void add(String name, String soid, int type, String sfield,
132             String a, String b, String x, String y, String n, int h,
133             Pattern nameSplitPattern) {
134         BigInteger p = bi(sfield);
135         ECField field;
136         if ((type == P) || (type == PD)) {
137             field = new ECFieldFp(p);
138         } else if ((type == B) || (type == BD)) {
139             field = new ECFieldF2m(p.bitLength() - 1, p);
140         } else {
141             throw new RuntimeException(&quot;Invalid type: &quot; + type);
142         }
143 
144         EllipticCurve curve = new EllipticCurve(field, bi(a), bi(b));
145         ECPoint g = new ECPoint(bi(x), bi(y));
146 
147         NamedCurve params = new NamedCurve(name, soid, curve, g, bi(n), h);
148         if (oidMap.put(soid, params) != null) {
149             throw new RuntimeException(&quot;Duplication oid: &quot; + soid);
150         }
151 
152         String[] commonNames = nameSplitPattern.split(name);
153         for (String commonName : commonNames) {
<span class="line-modified">154             if (nameMap.put(commonName.trim(), params) != null) {</span>

155                 throw new RuntimeException(&quot;Duplication name: &quot; + commonName);
156             }
157         }
158 
159         int len = field.getFieldSize();
160         if ((type == PD) || (type == BD) || (lengthMap.get(len) == null)) {
161             // add entry if none present for this field size or if
162             // the curve is marked as a default curve.
163             lengthMap.put(len, params);
164         }
165     }
166 



















167     static {
<span class="line-modified">168         Pattern nameSplitPattern = Pattern.compile(SPLIT_PATTERN);</span>
169 
170         /* SEC2 prime curves */
171         add(&quot;secp112r1&quot;, &quot;1.3.132.0.6&quot;, P,
172             &quot;DB7C2ABF62E35E668076BEAD208B&quot;,
173             &quot;DB7C2ABF62E35E668076BEAD2088&quot;,
174             &quot;659EF8BA043916EEDE8911702B22&quot;,
175             &quot;09487239995A5EE76B55F9C2F098&quot;,
176             &quot;A89CE5AF8724C0A23E0E0FF77500&quot;,
177             &quot;DB7C2ABF62E35E7628DFAC6561C5&quot;,
178             1, nameSplitPattern);
179 
180         add(&quot;secp112r2&quot;, &quot;1.3.132.0.7&quot;, P,
181             &quot;DB7C2ABF62E35E668076BEAD208B&quot;,
182             &quot;6127C24C05F38A0AAAF65C0EF02C&quot;,
183             &quot;51DEF1815DB5ED74FCC34C85D709&quot;,
184             &quot;4BA30AB5E892B4E1649DD0928643&quot;,
185             &quot;adcd46f5882e3747def36e956e97&quot;,
186             &quot;36DF0AAFD8B8D7597CA10520D04B&quot;,
187             4, nameSplitPattern);
188 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45     private static final int PD = 5; // prime curve, mark as default
 46     private static final int BD = 6; // binary curve, mark as default
 47 
 48     private static final Map&lt;String,NamedCurve&gt; oidMap =
 49         new LinkedHashMap&lt;String,NamedCurve&gt;();
 50     private static final Map&lt;String,NamedCurve&gt; nameMap =
 51         new HashMap&lt;String,NamedCurve&gt;();
 52     private static final Map&lt;Integer,NamedCurve&gt; lengthMap =
 53         new HashMap&lt;Integer,NamedCurve&gt;();
 54 
 55     private static Collection&lt;? extends NamedCurve&gt; specCollection;
 56 
 57     public static final String SPLIT_PATTERN = &quot;,|\\[|\\]&quot;;
 58 
 59     // Used by SunECEntries
 60     public static Collection&lt;? extends NamedCurve&gt;getSupportedCurves() {
 61         return specCollection;
 62     }
 63 
 64     // Return a NamedCurve for the specified OID/name or null if unknown.
<span class="line-modified"> 65     public static NamedCurve lookup(String name) {</span>
 66         NamedCurve spec = oidMap.get(name);
 67         if (spec != null) {
 68             return spec;
 69         }
 70 
<span class="line-modified"> 71         return nameMap.get(name.toLowerCase(Locale.ENGLISH));</span>
 72     }
 73 
 74     // Return EC parameters for the specified field size. If there are known
 75     // NIST recommended parameters for the given length, they are returned.
 76     // Otherwise, if there are multiple matches for the given size, an
 77     // arbitrary one is returns.
 78     // If no parameters are known, the method returns null.
 79     // NOTE that this method returns both prime and binary curves.
 80     static NamedCurve lookup(int length) {
 81         return lengthMap.get(length);
 82     }
 83 
 84     // Convert the given ECParameterSpec object to a NamedCurve object.
 85     // If params does not represent a known named curve, return null.
<span class="line-modified"> 86     public static NamedCurve lookup(ECParameterSpec params) {</span>
 87         if ((params instanceof NamedCurve) || (params == null)) {
 88             return (NamedCurve)params;
 89         }
 90 
 91         // This is a hack to allow SunJSSE to work with 3rd party crypto
 92         // providers for ECC and not just SunPKCS11.
 93         // This can go away once we decide how to expose curve names in the
 94         // public API.
 95         // Note that it assumes that the 3rd party provider encodes named
 96         // curves using the short form, not explicitly. If it did that, then
 97         // the SunJSSE TLS ECC extensions are wrong, which could lead to
 98         // interoperability problems.
 99         int fieldSize = params.getCurve().getField().getFieldSize();
100         for (NamedCurve namedCurve : specCollection) {
101             // ECParameterSpec does not define equals, so check all the
102             // components ourselves.
103             // Quick field size check first
104             if (namedCurve.getCurve().getField().getFieldSize() != fieldSize) {
105                 continue;
106             }
<span class="line-modified">107             if (ECUtil.equals(namedCurve, params)) {</span>
<span class="line-modified">108                 // everything matches our named curve, return it</span>
<span class="line-modified">109                 return namedCurve;</span>









110             }


111         }
112         // no match found
113         return null;
114     }
115 
116     private static BigInteger bi(String s) {
117         return new BigInteger(s, 16);
118     }
119 
120     private static void add(String name, String soid, int type, String sfield,
121             String a, String b, String x, String y, String n, int h,
122             Pattern nameSplitPattern) {
123         BigInteger p = bi(sfield);
124         ECField field;
125         if ((type == P) || (type == PD)) {
126             field = new ECFieldFp(p);
127         } else if ((type == B) || (type == BD)) {
128             field = new ECFieldF2m(p.bitLength() - 1, p);
129         } else {
130             throw new RuntimeException(&quot;Invalid type: &quot; + type);
131         }
132 
133         EllipticCurve curve = new EllipticCurve(field, bi(a), bi(b));
134         ECPoint g = new ECPoint(bi(x), bi(y));
135 
136         NamedCurve params = new NamedCurve(name, soid, curve, g, bi(n), h);
137         if (oidMap.put(soid, params) != null) {
138             throw new RuntimeException(&quot;Duplication oid: &quot; + soid);
139         }
140 
141         String[] commonNames = nameSplitPattern.split(name);
142         for (String commonName : commonNames) {
<span class="line-modified">143             if (nameMap.put(commonName.trim().toLowerCase(Locale.ENGLISH),</span>
<span class="line-added">144                             params) != null) {</span>
145                 throw new RuntimeException(&quot;Duplication name: &quot; + commonName);
146             }
147         }
148 
149         int len = field.getFieldSize();
150         if ((type == PD) || (type == BD) || (lengthMap.get(len) == null)) {
151             // add entry if none present for this field size or if
152             // the curve is marked as a default curve.
153             lengthMap.put(len, params);
154         }
155     }
156 
<span class="line-added">157     private static class Holder {</span>
<span class="line-added">158         private static final Pattern nameSplitPattern = Pattern.compile(</span>
<span class="line-added">159                 SPLIT_PATTERN);</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     // Return all the names the EC curve could be using.</span>
<span class="line-added">163     static String[] getNamesByOID(String oid) {</span>
<span class="line-added">164         NamedCurve nc = oidMap.get(oid);</span>
<span class="line-added">165         if (nc == null) {</span>
<span class="line-added">166             return new String[0];</span>
<span class="line-added">167         }</span>
<span class="line-added">168         String[] list = Holder.nameSplitPattern.split(nc.getName());</span>
<span class="line-added">169         int i = 0;</span>
<span class="line-added">170         do {</span>
<span class="line-added">171             list[i] = list[i].trim();</span>
<span class="line-added">172         } while (++i &lt; list.length);</span>
<span class="line-added">173         return list;</span>
<span class="line-added">174     }</span>
<span class="line-added">175 </span>
176     static {
<span class="line-modified">177         Pattern nameSplitPattern = Holder.nameSplitPattern;</span>
178 
179         /* SEC2 prime curves */
180         add(&quot;secp112r1&quot;, &quot;1.3.132.0.6&quot;, P,
181             &quot;DB7C2ABF62E35E668076BEAD208B&quot;,
182             &quot;DB7C2ABF62E35E668076BEAD2088&quot;,
183             &quot;659EF8BA043916EEDE8911702B22&quot;,
184             &quot;09487239995A5EE76B55F9C2F098&quot;,
185             &quot;A89CE5AF8724C0A23E0E0FF77500&quot;,
186             &quot;DB7C2ABF62E35E7628DFAC6561C5&quot;,
187             1, nameSplitPattern);
188 
189         add(&quot;secp112r2&quot;, &quot;1.3.132.0.7&quot;, P,
190             &quot;DB7C2ABF62E35E668076BEAD208B&quot;,
191             &quot;6127C24C05F38A0AAAF65C0EF02C&quot;,
192             &quot;51DEF1815DB5ED74FCC34C85D709&quot;,
193             &quot;4BA30AB5E892B4E1649DD0928643&quot;,
194             &quot;adcd46f5882e3747def36e956e97&quot;,
195             &quot;36DF0AAFD8B8D7597CA10520D04B&quot;,
196             4, nameSplitPattern);
197 
</pre>
</td>
</tr>
</table>
<center><a href="ConstraintsParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DerIndefLenConverter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
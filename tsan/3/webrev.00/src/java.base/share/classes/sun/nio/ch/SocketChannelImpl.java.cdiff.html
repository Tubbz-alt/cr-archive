<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketAdaptor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketOptionRegistry.java.template.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,19 ***</span>
<span class="line-new-header">--- 30,22 ---</span>
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.ProtocolFamily;
  import java.net.Socket;
  import java.net.SocketAddress;
<span class="line-added">+ import java.net.SocketException;</span>
  import java.net.SocketOption;
<span class="line-added">+ import java.net.SocketTimeoutException;</span>
  import java.net.StandardProtocolFamily;
  import java.net.StandardSocketOptions;
  import java.nio.ByteBuffer;
  import java.nio.channels.AlreadyBoundException;
  import java.nio.channels.AlreadyConnectedException;
  import java.nio.channels.AsynchronousCloseException;
  import java.nio.channels.ClosedChannelException;
  import java.nio.channels.ConnectionPendingException;
<span class="line-added">+ import java.nio.channels.IllegalBlockingModeException;</span>
  import java.nio.channels.NoConnectionPendingException;
  import java.nio.channels.NotYetConnectedException;
  import java.nio.channels.SelectionKey;
  import java.nio.channels.SocketChannel;
  import java.nio.channels.spi.SelectorProvider;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,10 ***</span>
<span class="line-new-header">--- 53,11 ---</span>
  import java.util.HashSet;
  import java.util.Objects;
  import java.util.Set;
  import java.util.concurrent.locks.ReentrantLock;
  
<span class="line-added">+ import sun.net.ConnectionResetException;</span>
  import sun.net.NetHooks;
  import sun.net.ext.ExtendedSocketOptions;
  import sun.net.util.SocketExceptions;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,22 ***</span>
  
      // Input/Output closed
      private volatile boolean isInputClosed;
      private volatile boolean isOutputClosed;
  
      // -- The following fields are protected by stateLock
  
      // set true when exclusive binding is on and SO_REUSEADDR is emulated
      private boolean isReuseAddress;
  
      // State, increases monotonically
      private static final int ST_UNCONNECTED = 0;
      private static final int ST_CONNECTIONPENDING = 1;
      private static final int ST_CONNECTED = 2;
      private static final int ST_CLOSING = 3;
<span class="line-modified">!     private static final int ST_KILLPENDING = 4;</span>
<span class="line-removed">-     private static final int ST_KILLED = 5;</span>
      private volatile int state;  // need stateLock to change
  
      // IDs of native threads doing reads and writes, for signalling
      private long readerThread;
      private long writerThread;
<span class="line-new-header">--- 87,24 ---</span>
  
      // Input/Output closed
      private volatile boolean isInputClosed;
      private volatile boolean isOutputClosed;
  
<span class="line-added">+     // Connection reset protected by readLock</span>
<span class="line-added">+     private boolean connectionReset;</span>
<span class="line-added">+ </span>
      // -- The following fields are protected by stateLock
  
      // set true when exclusive binding is on and SO_REUSEADDR is emulated
      private boolean isReuseAddress;
  
      // State, increases monotonically
      private static final int ST_UNCONNECTED = 0;
      private static final int ST_CONNECTIONPENDING = 1;
      private static final int ST_CONNECTED = 2;
      private static final int ST_CLOSING = 3;
<span class="line-modified">!     private static final int ST_CLOSED = 4;</span>
      private volatile int state;  // need stateLock to change
  
      // IDs of native threads doing reads and writes, for signalling
      private long readerThread;
      private long writerThread;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,10 ***</span>
<span class="line-new-header">--- 216,12 ---</span>
          throws IOException
      {
          Objects.requireNonNull(name);
          if (!supportedOptions().contains(name))
              throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="line-added">+         if (!name.type().isInstance(value))</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
  
          synchronized (stateLock) {
              ensureOpen();
  
              if (name == StandardSocketOptions.IP_TOS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
                  isReuseAddress = (Boolean)value;
                  return this;
              }
  
              // no options that require special handling
<span class="line-modified">!             Net.setSocketOption(fd, Net.UNSPEC, name, value);</span>
              return this;
          }
      }
  
      @Override
<span class="line-new-header">--- 236,11 ---</span>
                  isReuseAddress = (Boolean)value;
                  return this;
              }
  
              // no options that require special handling
<span class="line-modified">!             Net.setSocketOption(fd, name, value);</span>
              return this;
          }
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,11 ***</span>
                      StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
                  return (T) Net.getSocketOption(fd, family, name);
              }
  
              // no options that require special handling
<span class="line-modified">!             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);</span>
          }
      }
  
      private static class DefaultOptionsHolder {
          static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
<span class="line-new-header">--- 266,11 ---</span>
                      StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;
                  return (T) Net.getSocketOption(fd, family, name);
              }
  
              // no options that require special handling
<span class="line-modified">!             return (T) Net.getSocketOption(fd, name);</span>
          }
      }
  
      private static class DefaultOptionsHolder {
          static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,20 ***</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  readerThread = 0;
<span class="line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     stateLock.notifyAll();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
      }
  
      @Override
      public int read(ByteBuffer buf) throws IOException {
          Objects.requireNonNull(buf);
  
          readLock.lock();
<span class="line-new-header">--- 330,23 ---</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  readerThread = 0;
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     tryFinishClose();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
      }
  
<span class="line-added">+     private void throwConnectionReset() throws SocketException {</span>
<span class="line-added">+         throw new SocketException(&quot;Connection reset&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public int read(ByteBuffer buf) throws IOException {
          Objects.requireNonNull(buf);
  
          readLock.lock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,21 ***</span>
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking);
  
                  // check if input is shutdown
                  if (isInputClosed)
                      return IOStatus.EOF;
  
                  if (blocking) {
<span class="line-modified">!                     do {</span>
                          n = IOUtil.read(fd, buf, -1, nd);
<span class="line-modified">!                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     n = IOUtil.read(fd, buf, -1, nd);</span>
                  }
              } finally {
                  endRead(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isInputClosed)
                      return IOStatus.EOF;
              }
<span class="line-new-header">--- 354,28 ---</span>
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking);
  
<span class="line-added">+                 // check if connection has been reset</span>
<span class="line-added">+                 if (connectionReset)</span>
<span class="line-added">+                     throwConnectionReset();</span>
<span class="line-added">+ </span>
                  // check if input is shutdown
                  if (isInputClosed)
                      return IOStatus.EOF;
  
<span class="line-added">+                 n = IOUtil.read(fd, buf, -1, nd);</span>
                  if (blocking) {
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
                          n = IOUtil.read(fd, buf, -1, nd);
<span class="line-modified">!                     }</span>
                  }
<span class="line-added">+             } catch (ConnectionResetException e) {</span>
<span class="line-added">+                 connectionReset = true;</span>
<span class="line-added">+                 throwConnectionReset();</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isInputClosed)
                      return IOStatus.EOF;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,21 ***</span>
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking);
  
                  // check if input is shutdown
                  if (isInputClosed)
                      return IOStatus.EOF;
  
                  if (blocking) {
<span class="line-modified">!                     do {</span>
                          n = IOUtil.read(fd, dsts, offset, length, nd);
<span class="line-modified">!                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
                  }
              } finally {
                  endRead(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isInputClosed)
                      return IOStatus.EOF;
              }
<span class="line-new-header">--- 396,28 ---</span>
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking);
  
<span class="line-added">+                 // check if connection has been reset</span>
<span class="line-added">+                 if (connectionReset)</span>
<span class="line-added">+                     throwConnectionReset();</span>
<span class="line-added">+ </span>
                  // check if input is shutdown
                  if (isInputClosed)
                      return IOStatus.EOF;
  
<span class="line-added">+                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
                  if (blocking) {
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
                          n = IOUtil.read(fd, dsts, offset, length, nd);
<span class="line-modified">!                     }</span>
                  }
<span class="line-added">+             } catch (ConnectionResetException e) {</span>
<span class="line-added">+                 connectionReset = true;</span>
<span class="line-added">+                 throwConnectionReset();</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isInputClosed)
                      return IOStatus.EOF;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,13 ***</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  writerThread = 0;
<span class="line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     stateLock.notifyAll();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
<span class="line-new-header">--- 460,12 ---</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  writerThread = 0;
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     tryFinishClose();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,16 ***</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginWrite(blocking);
                  if (blocking) {
<span class="line-modified">!                     do {</span>
                          n = IOUtil.write(fd, buf, -1, nd);
<span class="line-modified">!                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     n = IOUtil.write(fd, buf, -1, nd);</span>
                  }
              } finally {
                  endWrite(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isOutputClosed)
                      throw new AsynchronousCloseException();
<span class="line-new-header">--- 479,16 ---</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginWrite(blocking);
<span class="line-added">+                 n = IOUtil.write(fd, buf, -1, nd);</span>
                  if (blocking) {
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLOUT);</span>
                          n = IOUtil.write(fd, buf, -1, nd);
<span class="line-modified">!                     }</span>
                  }
              } finally {
                  endWrite(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isOutputClosed)
                      throw new AsynchronousCloseException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,16 ***</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginWrite(blocking);
                  if (blocking) {
<span class="line-modified">!                     do {</span>
                          n = IOUtil.write(fd, srcs, offset, length, nd);
<span class="line-modified">!                     } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
                  }
              } finally {
                  endWrite(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isOutputClosed)
                      throw new AsynchronousCloseException();
<span class="line-new-header">--- 509,16 ---</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginWrite(blocking);
<span class="line-added">+                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
                  if (blocking) {
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLOUT);</span>
                          n = IOUtil.write(fd, srcs, offset, length, nd);
<span class="line-modified">!                     }</span>
                  }
              } finally {
                  endWrite(blocking, n &gt; 0);
                  if (n &lt;= 0 &amp;&amp; isOutputClosed)
                      throw new AsynchronousCloseException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,22 ***</span>
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              writeLock.lock();
              try {
<span class="line-modified">!                 synchronized (stateLock) {</span>
<span class="line-removed">-                     ensureOpen();</span>
<span class="line-removed">-                     IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed">-                 }</span>
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
      }
  
      /**
       * Returns the local address, or null if not bound
       */
      InetSocketAddress localAddress() {
          synchronized (stateLock) {
<span class="line-new-header">--- 561,49 ---</span>
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              writeLock.lock();
              try {
<span class="line-modified">!                 lockedConfigureBlocking(block);</span>
              } finally {
                  writeLock.unlock();
              }
          } finally {
              readLock.unlock();
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adjusts the blocking mode. readLock or writeLock must already be held.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adjusts the blocking mode if the channel is open. readLock or writeLock</span>
<span class="line-added">+      * must already be held.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-added">+      *         the blocking mode was not adjusted because the channel is closed</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-added">+         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             if (isOpen()) {</span>
<span class="line-added">+                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the local address, or null if not bound
       */
      InetSocketAddress localAddress() {
          synchronized (stateLock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,38 ***</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public boolean connect(SocketAddress sa) throws IOException {</span>
          InetSocketAddress isa = Net.checkAddress(sa);
          SecurityManager sm = System.getSecurityManager();
<span class="line-modified">!         if (sm != null)</span>
              sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
  
<span class="line-modified">!         InetAddress ia = isa.getAddress();</span>
<span class="line-modified">!         if (ia.isAnyLocalAddress())</span>
<span class="line-modified">!             ia = InetAddress.getLocalHost();</span>
<span class="line-removed">- </span>
          try {
              readLock.lock();
              try {
                  writeLock.lock();
                  try {
<span class="line-removed">-                     int n = 0;</span>
                      boolean blocking = isBlocking();
                      try {
                          beginConnect(blocking, isa);
<span class="line-modified">!                         do {</span>
<span class="line-modified">!                             n = Net.connect(fd, ia, isa.getPort());</span>
<span class="line-modified">!                         } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>
                      } finally {
<span class="line-modified">!                         endConnect(blocking, (n &gt; 0));</span>
                      }
<span class="line-modified">!                     assert IOStatus.check(n);</span>
<span class="line-removed">-                     return n &gt; 0;</span>
                  } finally {
                      writeLock.unlock();
                  }
              } finally {
                  readLock.unlock();
<span class="line-new-header">--- 718,54 ---</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Checks the remote address to which this channel is to be connected.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private InetSocketAddress checkRemote(SocketAddress sa) throws IOException {</span>
          InetSocketAddress isa = Net.checkAddress(sa);
          SecurityManager sm = System.getSecurityManager();
<span class="line-modified">!         if (sm != null) {</span>
              sm.checkConnect(isa.getAddress().getHostAddress(), isa.getPort());
<span class="line-added">+         }</span>
<span class="line-added">+         if (isa.getAddress().isAnyLocalAddress()) {</span>
<span class="line-added">+             return new InetSocketAddress(InetAddress.getLocalHost(), isa.getPort());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return isa;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public boolean connect(SocketAddress remote) throws IOException {</span>
<span class="line-modified">!         InetSocketAddress isa = checkRemote(remote);</span>
          try {
              readLock.lock();
              try {
                  writeLock.lock();
                  try {
                      boolean blocking = isBlocking();
<span class="line-added">+                     boolean connected = false;</span>
                      try {
                          beginConnect(blocking, isa);
<span class="line-modified">!                         int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-modified">!                         if (n &gt; 0) {</span>
<span class="line-modified">!                             connected = true;</span>
<span class="line-added">+                         } else if (blocking) {</span>
<span class="line-added">+                             assert IOStatus.okayToRetry(n);</span>
<span class="line-added">+                             boolean polled = false;</span>
<span class="line-added">+                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added">+                                 park(Net.POLLOUT);</span>
<span class="line-added">+                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             connected = polled &amp;&amp; isOpen();</span>
<span class="line-added">+                         }</span>
                      } finally {
<span class="line-modified">!                         endConnect(blocking, connected);</span>
                      }
<span class="line-modified">!                     return connected;</span>
                  } finally {
                      writeLock.unlock();
                  }
              } finally {
                  readLock.unlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,19 ***</span>
  
                      boolean blocking = isBlocking();
                      boolean connected = false;
                      try {
                          beginFinishConnect(blocking);
<span class="line-modified">!                         int n = 0;</span>
                          if (blocking) {
<span class="line-modified">!                             do {</span>
<span class="line-modified">!                                 n = Net.pollConnect(fd, -1);</span>
<span class="line-modified">!                             } while ((n == 0 || n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
<span class="line-modified">!                         } else {</span>
<span class="line-removed">-                             n = Net.pollConnect(fd, 0);</span>
                          }
<span class="line-modified">!                         connected = (n &gt; 0);</span>
                      } finally {
                          endFinishConnect(blocking, connected);
                      }
                      assert (blocking &amp;&amp; connected) ^ !blocking;
                      return connected;
<span class="line-new-header">--- 834,18 ---</span>
  
                      boolean blocking = isBlocking();
                      boolean connected = false;
                      try {
                          beginFinishConnect(blocking);
<span class="line-modified">!                         boolean polled = Net.pollConnectNow(fd);</span>
                          if (blocking) {
<span class="line-modified">!                             while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                                 park(Net.POLLOUT);</span>
<span class="line-modified">!                                 polled = Net.pollConnectNow(fd);</span>
<span class="line-modified">!                             }</span>
                          }
<span class="line-modified">!                         connected = polled &amp;&amp; isOpen();</span>
                      } finally {
                          endFinishConnect(blocking, connected);
                      }
                      assert (blocking &amp;&amp; connected) ^ !blocking;
                      return connected;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,87 ***</span>
              throw SocketExceptions.of(ioe, remoteAddress);
          }
      }
  
      /**
<span class="line-modified">!      * Invoked by implCloseChannel to close the channel.</span>
       *
<span class="line-modified">!      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-modified">!      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-modified">!      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-modified">!      * complete quickly.</span>
       *
<span class="line-modified">!      * If the socket is connected then it is shutdown by this method. The</span>
<span class="line-modified">!      * shutdown ensures that the peer reads EOF for the case that the socket is</span>
<span class="line-modified">!      * not pre-closed or closed by this method.</span>
       *
<span class="line-modified">!      * The socket is closed by this method when it is not registered with a</span>
<span class="line-modified">!      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-modified">!      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">-      * to blocking mode before the key is flushed from the Selector.</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-removed">-     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-removed">-         assert !isOpen();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         boolean blocking;</span>
<span class="line-removed">-         boolean connected;</span>
<span class="line-removed">-         boolean interrupted = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // set state to ST_CLOSING</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
<span class="line-removed">-             blocking = isBlocking();</span>
<span class="line-removed">-             connected = (state == ST_CONNECTED);</span>
              state = ST_CLOSING;
<span class="line-modified">!         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // wait for any outstanding I/O operations to complete</span>
<span class="line-removed">-         if (blocking) {</span>
<span class="line-removed">-             synchronized (stateLock) {</span>
<span class="line-removed">-                 assert state == ST_CLOSING;</span>
                  long reader = readerThread;
                  long writer = writerThread;
                  if (reader != 0 || writer != 0) {
                      nd.preClose(fd);
<span class="line-removed">-                     connected = false; // fd is no longer connected socket</span>
<span class="line-removed">- </span>
                      if (reader != 0)
                          NativeThread.signal(reader);
                      if (writer != 0)
                          NativeThread.signal(writer);
<span class="line-removed">- </span>
<span class="line-removed">-                     // wait for blocking I/O operations to end</span>
<span class="line-removed">-                     while (readerThread != 0 || writerThread != 0) {</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             stateLock.wait();</span>
<span class="line-removed">-                         } catch (InterruptedException e) {</span>
<span class="line-removed">-                             interrupted = true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
                  }
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // non-blocking mode: wait for read/write to complete</span>
<span class="line-removed">-             readLock.lock();</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 writeLock.lock();</span>
<span class="line-removed">-                 writeLock.unlock();</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 readLock.unlock();</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         // set state to ST_KILLPENDING</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert state == ST_CLOSING;</span>
<span class="line-removed">-             // if connected and the channel is registered with a Selector then</span>
<span class="line-removed">-             // shutdown the output if possible so that the peer reads EOF. If</span>
<span class="line-removed">-             // SO_LINGER is enabled and set to a non-zero value then it needs to</span>
<span class="line-removed">-             // be disabled so that the Selector does not wait when it closes</span>
<span class="line-removed">-             // the socket.</span>
<span class="line-removed">-             if (connected &amp;&amp; isRegistered()) {</span>
                  try {
                      SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
                      int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
                      if (interval != 0) {
                          if (interval &gt; 0) {
<span class="line-new-header">--- 861,93 ---</span>
              throw SocketExceptions.of(ioe, remoteAddress);
          }
      }
  
      /**
<span class="line-modified">!      * Closes the socket if there are no I/O operations in progress and the</span>
<span class="line-added">+      * channel is not registered with a Selector.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean tryClose() throws IOException {</span>
<span class="line-added">+         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-added">+         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">+             state = ST_CLOSED;</span>
<span class="line-added">+             nd.close(fd);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Invokes tryClose to attempt to close the socket.</span>
       *
<span class="line-modified">!      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private void tryFinishClose() {</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             tryClose();</span>
<span class="line-added">+         } catch (IOException ignore) { }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Closes this channel when configured in blocking mode.</span>
       *
<span class="line-modified">!      * If there is an I/O operation in progress then the socket is pre-closed</span>
<span class="line-modified">!      * and the I/O threads signalled, in which case the final close is deferred</span>
<span class="line-modified">!      * until all I/O operations complete.</span>
       *
<span class="line-modified">!      * Note that a channel configured blocking may be registered with a Selector</span>
<span class="line-modified">!      * This arises when a key is canceled and the channel configured to blocking</span>
<span class="line-modified">!      * mode before the key is flushed from the Selector.</span>
       */
<span class="line-modified">!     private void implCloseBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
              state = ST_CLOSING;
<span class="line-modified">!             if (!tryClose()) {</span>
                  long reader = readerThread;
                  long writer = writerThread;
                  if (reader != 0 || writer != 0) {
                      nd.preClose(fd);
                      if (reader != 0)
                          NativeThread.signal(reader);
                      if (writer != 0)
                          NativeThread.signal(writer);
                  }
              }
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">+      * until the channel is flushed from all Selectors.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If the socket is connected and the channel is registered with a Selector</span>
<span class="line-added">+      * then the socket is shutdown for writing so that the peer reads EOF. In</span>
<span class="line-added">+      * addition, if SO_LINGER is set to a non-zero value then it is disabled so</span>
<span class="line-added">+      * that the deferred close does not wait.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="line-added">+         boolean connected;</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             assert state &lt; ST_CLOSING;</span>
<span class="line-added">+             connected = (state == ST_CONNECTED);</span>
<span class="line-added">+             state = ST_CLOSING;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // wait for any read/write operations to complete</span>
<span class="line-added">+         readLock.lock();</span>
<span class="line-added">+         readLock.unlock();</span>
<span class="line-added">+         writeLock.lock();</span>
<span class="line-added">+         writeLock.unlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // if the socket cannot be closed because it&#39;s registered with a Selector</span>
<span class="line-added">+         // then shutdown the socket for writing.</span>
          synchronized (stateLock) {
<span class="line-modified">!             if (state == ST_CLOSING &amp;&amp; !tryClose() &amp;&amp; connected &amp;&amp; isRegistered()) {</span>
                  try {
                      SocketOption&lt;Integer&gt; opt = StandardSocketOptions.SO_LINGER;
                      int interval = (int) Net.getSocketOption(fd, Net.UNSPEC, opt);
                      if (interval != 0) {
                          if (interval &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 884,28 ***</span>
                          }
                          Net.shutdown(fd, Net.SHUT_WR);
                      }
                  } catch (IOException ignore) { }
              }
<span class="line-removed">-             state = ST_KILLPENDING;</span>
          }
  
<span class="line-modified">!         // close socket if not registered with Selector</span>
<span class="line-modified">!         if (!isRegistered())</span>
<span class="line-modified">!             kill();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // restore interrupt status</span>
<span class="line-modified">!         if (interrupted)</span>
<span class="line-modified">!             Thread.currentThread().interrupt();</span>
      }
  
      @Override
<span class="line-modified">!     public void kill() throws IOException {</span>
          synchronized (stateLock) {
<span class="line-modified">!             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">!                 state = ST_KILLED;</span>
<span class="line-removed">-                 nd.close(fd);</span>
              }
          }
      }
  
      @Override
<span class="line-new-header">--- 956,31 ---</span>
                          }
                          Net.shutdown(fd, Net.SHUT_WR);
                      }
                  } catch (IOException ignore) { }
              }
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">!         assert !isOpen();</span>
<span class="line-modified">!         if (isBlocking()) {</span>
<span class="line-added">+             implCloseBlockingMode();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             implCloseNonBlockingMode();</span>
<span class="line-added">+         }</span>
      }
  
      @Override
<span class="line-modified">!     public void kill() {</span>
          synchronized (stateLock) {
<span class="line-modified">!             if (state == ST_CLOSING) {</span>
<span class="line-modified">!                 tryFinishClose();</span>
              }
          }
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 949,62 ***</span>
      boolean isOutputOpen() {
          return !isOutputClosed;
      }
  
      /**
<span class="line-modified">!      * Poll this channel&#39;s socket for reading up to the given timeout.</span>
<span class="line-modified">!      * @return {@code true} if the socket is polled</span>
       */
<span class="line-modified">!     boolean pollRead(long timeout) throws IOException {</span>
<span class="line-modified">!         boolean blocking = isBlocking();</span>
<span class="line-modified">!         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>
  
          readLock.lock();
          try {
<span class="line-modified">!             boolean polled = false;</span>
              try {
<span class="line-modified">!                 beginRead(blocking);</span>
<span class="line-modified">!                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-modified">!                 polled = (events != 0);</span>
              } finally {
<span class="line-modified">!                 endRead(blocking, polled);</span>
              }
<span class="line-modified">!             return polled;</span>
          } finally {
              readLock.unlock();
          }
      }
  
      /**
<span class="line-modified">!      * Poll this channel&#39;s socket for a connection, up to the given timeout.</span>
<span class="line-modified">!      * @return {@code true} if the socket is polled</span>
       */
<span class="line-modified">!     boolean pollConnected(long timeout) throws IOException {</span>
<span class="line-modified">!         boolean blocking = isBlocking();</span>
<span class="line-modified">!         assert Thread.holdsLock(blockingLock()) &amp;&amp; blocking;</span>
  
<span class="line-modified">!         readLock.lock();</span>
          try {
<span class="line-modified">!             writeLock.lock();</span>
              try {
<span class="line-modified">!                 boolean polled = false;</span>
<span class="line-modified">!                 try {</span>
<span class="line-modified">!                     beginFinishConnect(blocking);</span>
<span class="line-modified">!                     int events = Net.poll(fd, Net.POLLCONN, timeout);</span>
<span class="line-modified">!                     polled = (events != 0);</span>
<span class="line-modified">!                 } finally {</span>
<span class="line-modified">!                     // invoke endFinishConnect with completed = false so that</span>
<span class="line-modified">!                     // the state is not changed to ST_CONNECTED. The socket</span>
<span class="line-modified">!                     // adaptor will use finishConnect to finish.</span>
<span class="line-modified">!                     endFinishConnect(blocking, /*completed*/false);</span>
                  }
<span class="line-removed">-                 return polled;</span>
              } finally {
<span class="line-modified">!                 writeLock.unlock();</span>
              }
          } finally {
<span class="line-modified">!             readLock.unlock();</span>
          }
      }
  
      /**
       * Translates native poll revent ops into a ready operation ops
<span class="line-new-header">--- 1024,241 ---</span>
      boolean isOutputOpen() {
          return !isOutputClosed;
      }
  
      /**
<span class="line-modified">!      * Waits for a connection attempt to finish with a timeout</span>
<span class="line-modified">!      * @throws SocketTimeoutException if the connect timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean finishTimedConnect(long nanos) throws IOException {</span>
<span class="line-added">+         long startNanos = System.nanoTime();</span>
<span class="line-added">+         boolean polled = Net.pollConnectNow(fd);</span>
<span class="line-added">+         while (!polled &amp;&amp; isOpen()) {</span>
<span class="line-added">+             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">+             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">+                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             park(Net.POLLOUT, remainingNanos);</span>
<span class="line-added">+             polled = Net.pollConnectNow(fd);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return polled &amp;&amp; isOpen();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Attempts to establish a connection to the given socket address with a</span>
<span class="line-added">+      * timeout. Closes the socket if connection cannot be established.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">+      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void blockingConnect(SocketAddress remote, long nanos) throws IOException {</span>
<span class="line-added">+         InetSocketAddress isa = checkRemote(remote);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             readLock.lock();</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 writeLock.lock();</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     if (!isBlocking())</span>
<span class="line-added">+                         throw new IllegalBlockingModeException();</span>
<span class="line-added">+                     boolean connected = false;</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         beginConnect(true, isa);</span>
<span class="line-added">+                         // change socket to non-blocking</span>
<span class="line-added">+                         lockedConfigureBlocking(false);</span>
<span class="line-added">+                         try {</span>
<span class="line-added">+                             int n = Net.connect(fd, isa.getAddress(), isa.getPort());</span>
<span class="line-added">+                             connected = (n &gt; 0) ? true : finishTimedConnect(nanos);</span>
<span class="line-added">+                         } finally {</span>
<span class="line-added">+                             // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">+                             tryLockedConfigureBlocking(true);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         endConnect(true, connected);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     writeLock.unlock();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 readLock.unlock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } catch (IOException ioe) {</span>
<span class="line-added">+             // connect failed, close the channel</span>
<span class="line-added">+             close();</span>
<span class="line-added">+             throw SocketExceptions.of(ioe, isa);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Attempts to read bytes from the socket into the given byte array.</span>
       */
<span class="line-modified">!     private int tryRead(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">!         ByteBuffer dst = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">!         assert dst.position() == 0;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             int n = nd.read(fd, ((DirectBuffer)dst).address(), len);</span>
<span class="line-added">+             if (n &gt; 0) {</span>
<span class="line-added">+                 dst.get(b, off, n);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return n;</span>
<span class="line-added">+         } finally{</span>
<span class="line-added">+             Util.offerFirstTemporaryDirectBuffer(dst);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads bytes from the socket into the given byte array with a timeout.</span>
<span class="line-added">+      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int timedRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">+         long startNanos = System.nanoTime();</span>
<span class="line-added">+         int n = tryRead(b, off, len);</span>
<span class="line-added">+         while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-added">+             long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">+             if (remainingNanos &lt;= 0) {</span>
<span class="line-added">+                 throw new SocketTimeoutException(&quot;Read timed out&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">+             n = tryRead(b, off, len);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return n;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reads bytes from the socket into the given byte array.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalBlockingModeException if the channel is non-blocking</span>
<span class="line-added">+      * @throws SocketTimeoutException if the read timeout elapses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     int blockingRead(byte[] b, int off, int len, long nanos) throws IOException {</span>
<span class="line-added">+         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">+         if (len == 0) {</span>
<span class="line-added">+             // nothing to do</span>
<span class="line-added">+             return 0;</span>
<span class="line-added">+         }</span>
  
          readLock.lock();
          try {
<span class="line-modified">!             // check that channel is configured blocking</span>
<span class="line-added">+             if (!isBlocking())</span>
<span class="line-added">+                 throw new IllegalBlockingModeException();</span>
<span class="line-added">+ </span>
<span class="line-added">+             int n = 0;</span>
              try {
<span class="line-modified">!                 beginRead(true);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // check if connection has been reset</span>
<span class="line-added">+                 if (connectionReset)</span>
<span class="line-added">+                     throwConnectionReset();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // check if input is shutdown</span>
<span class="line-added">+                 if (isInputClosed)</span>
<span class="line-added">+                     return IOStatus.EOF;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (nanos &gt; 0) {</span>
<span class="line-added">+                     // change socket to non-blocking</span>
<span class="line-added">+                     lockedConfigureBlocking(false);</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         n = timedRead(b, off, len, nanos);</span>
<span class="line-added">+                     } finally {</span>
<span class="line-added">+                         // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">+                         tryLockedConfigureBlocking(true);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // read, no timeout</span>
<span class="line-added">+                     n = tryRead(b, off, len);</span>
<span class="line-added">+                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = tryRead(b, off, len);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } catch (ConnectionResetException e) {</span>
<span class="line-added">+                 connectionReset = true;</span>
<span class="line-added">+                 throwConnectionReset();</span>
              } finally {
<span class="line-modified">!                 endRead(true, n &gt; 0);</span>
<span class="line-added">+                 if (n &lt;= 0 &amp;&amp; isInputClosed)</span>
<span class="line-added">+                     return IOStatus.EOF;</span>
              }
<span class="line-modified">!             assert n &gt; 0 || n == -1;</span>
<span class="line-added">+             return n;</span>
          } finally {
              readLock.unlock();
          }
      }
  
      /**
<span class="line-modified">!      * Attempts to write a sequence of bytes to the socket from the given</span>
<span class="line-modified">!      * byte array.</span>
       */
<span class="line-modified">!     private int tryWrite(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">!         ByteBuffer src = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">!         assert src.position() == 0;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             src.put(b, off, len);</span>
<span class="line-added">+             return nd.write(fd, ((DirectBuffer)src).address(), len);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             Util.offerFirstTemporaryDirectBuffer(src);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Writes a sequence of bytes to the socket from the given byte array.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     void blockingWriteFully(byte[] b, int off, int len) throws IOException {</span>
<span class="line-added">+         Objects.checkFromIndexSize(off, len, b.length);</span>
<span class="line-added">+         if (len == 0) {</span>
<span class="line-added">+             // nothing to do</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         writeLock.lock();</span>
          try {
<span class="line-modified">!             // check that channel is configured blocking</span>
<span class="line-added">+             if (!isBlocking())</span>
<span class="line-added">+                 throw new IllegalBlockingModeException();</span>
<span class="line-added">+ </span>
<span class="line-added">+             // loop until all bytes have been written</span>
<span class="line-added">+             int pos = off;</span>
<span class="line-added">+             int end = off + len;</span>
<span class="line-added">+             beginWrite(true);</span>
              try {
<span class="line-modified">!                 while (pos &lt; end &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                     int size = end - pos;</span>
<span class="line-modified">!                     int n = tryWrite(b, pos, size);</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-modified">!                         park(Net.POLLOUT);</span>
<span class="line-modified">!                         n = tryWrite(b, pos, size);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (n &gt; 0) {</span>
<span class="line-modified">!                         pos += n;</span>
<span class="line-modified">!                     }</span>
                  }
              } finally {
<span class="line-modified">!                 endWrite(true, pos &gt;= end);</span>
              }
          } finally {
<span class="line-modified">!             writeLock.unlock();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return the number of bytes in the socket input buffer.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     int available() throws IOException {</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             ensureOpenAndConnected();</span>
<span class="line-added">+             if (isInputClosed) {</span>
<span class="line-added">+                 return 0;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return Net.available(fd);</span>
<span class="line-added">+             }</span>
          }
      }
  
      /**
       * Translates native poll revent ops into a ready operation ops
</pre>
<center><a href="SocketAdaptor.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketOptionRegistry.java.template.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SSLHandshake.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.util.AbstractMap.SimpleImmutableEntry;
 31 import java.util.Map;
 32 import javax.net.ssl.SSLException;
 33 
 34 enum SSLHandshake implements SSLConsumer, HandshakeProducer {
 35     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 36     HELLO_REQUEST ((byte)0x00, &quot;hello_request&quot;,
 37         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 38             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 39                 HelloRequest.handshakeConsumer,
 40                 ProtocolVersion.PROTOCOLS_TO_12
 41             )
 42         }),
 43         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 44             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 45                 HelloRequest.handshakeProducer,
 46                 ProtocolVersion.PROTOCOLS_TO_12
 47             )
 48         })),
 49 
 50     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 51     CLIENT_HELLO ((byte)0x01, &quot;client_hello&quot;,
 52         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 53             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 54                 ClientHello.handshakeConsumer,
 55                 ProtocolVersion.PROTOCOLS_TO_13
 56             )
 57         }),
 58         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 59             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 60                 ClientHello.handshakeProducer,
 61                 ProtocolVersion.PROTOCOLS_TO_13
 62             )
 63         })),
 64 
 65     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 66     SERVER_HELLO ((byte)0x02, &quot;server_hello&quot;,
 67         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 68             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 69                 ServerHello.handshakeConsumer,
 70                 ProtocolVersion.PROTOCOLS_TO_13
 71             )
 72         }),
 73         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 74             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 75                 ServerHello.t12HandshakeProducer,
 76                 ProtocolVersion.PROTOCOLS_TO_12
 77             ),
 78             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 79                 ServerHello.t13HandshakeProducer,
 80                 ProtocolVersion.PROTOCOLS_OF_13
 81             )
 82         })),
 83 
 84     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 85     HELLO_RETRY_REQUEST ((byte)0x02, &quot;hello_retry_request&quot;,
 86         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 87             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 88                 ServerHello.handshakeConsumer,      // Use ServerHello consumer
 89                 ProtocolVersion.PROTOCOLS_TO_13
 90             )
 91         }),
 92         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 93             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 94                 ServerHello.hrrHandshakeProducer,
 95                 ProtocolVersion.PROTOCOLS_OF_13
 96             )
 97         })),
 98 
 99     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
100     HELLO_VERIFY_REQUEST        ((byte)0x03, &quot;hello_verify_request&quot;,
101         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
102             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
103                 HelloVerifyRequest.handshakeConsumer,
104                 ProtocolVersion.PROTOCOLS_TO_12
105             )
106         }),
107         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
108             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
109                 HelloVerifyRequest.handshakeProducer,
110                 ProtocolVersion.PROTOCOLS_TO_12
111             )
112         })),
113 
114     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
115     NEW_SESSION_TICKET          ((byte)0x04, &quot;new_session_ticket&quot;,
116         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
117             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
118                 NewSessionTicket.handshakeConsumer,
119                 ProtocolVersion.PROTOCOLS_OF_13
120         )
121         }),
122         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
123             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
124                 NewSessionTicket.handshakeProducer,
125                 ProtocolVersion.PROTOCOLS_OF_13
126         )
127         })),
128     END_OF_EARLY_DATA           ((byte)0x05, &quot;end_of_early_data&quot;),
129 
130     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
131     ENCRYPTED_EXTENSIONS        ((byte)0x08, &quot;encrypted_extensions&quot;,
132         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
133             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
134                 EncryptedExtensions.handshakeConsumer,
135                 ProtocolVersion.PROTOCOLS_OF_13
136             )
137         }),
138         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
139             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
140                 EncryptedExtensions.handshakeProducer,
141                 ProtocolVersion.PROTOCOLS_OF_13
142             )
143         })),
144 
145     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
146     CERTIFICATE                 ((byte)0x0B, &quot;certificate&quot;,
147         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
148             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
149                 CertificateMessage.t12HandshakeConsumer,
150                 ProtocolVersion.PROTOCOLS_TO_12
151             ),
152             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
153                 CertificateMessage.t13HandshakeConsumer,
154                 ProtocolVersion.PROTOCOLS_OF_13
155             )
156         }),
157         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
158             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
159                 CertificateMessage.t12HandshakeProducer,
160                 ProtocolVersion.PROTOCOLS_TO_12
161             ),
162             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
163                 CertificateMessage.t13HandshakeProducer,
164                 ProtocolVersion.PROTOCOLS_OF_13
165             )
166         })),
167 
168     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
169     SERVER_KEY_EXCHANGE         ((byte)0x0C, &quot;server_key_exchange&quot;,
170         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
171             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
172                 ServerKeyExchange.handshakeConsumer,
173                 ProtocolVersion.PROTOCOLS_TO_12
174             )
175         }),
176         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
177             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
178                 ServerKeyExchange.handshakeProducer,
179                 ProtocolVersion.PROTOCOLS_TO_12
180             )
181         })),
182 
183     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
184     CERTIFICATE_REQUEST         ((byte)0x0D, &quot;certificate_request&quot;,
185         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
186             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
187                 CertificateRequest.t10HandshakeConsumer,
188                 ProtocolVersion.PROTOCOLS_TO_11
189             ),
190             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
191                 CertificateRequest.t12HandshakeConsumer,
192                 ProtocolVersion.PROTOCOLS_OF_12
193             ),
194             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
195                 CertificateRequest.t13HandshakeConsumer,
196                 ProtocolVersion.PROTOCOLS_OF_13
197             )
198         }),
199         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
200             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
201                 CertificateRequest.t10HandshakeProducer,
202                 ProtocolVersion.PROTOCOLS_TO_11
203             ),
204             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
205                 CertificateRequest.t12HandshakeProducer,
206                 ProtocolVersion.PROTOCOLS_OF_12
207             ),
208             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
209                 CertificateRequest.t13HandshakeProducer,
210                 ProtocolVersion.PROTOCOLS_OF_13
211             )
212         })),
213 
214     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
215     SERVER_HELLO_DONE           ((byte)0x0E, &quot;server_hello_done&quot;,
216         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
217             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
218                 ServerHelloDone.handshakeConsumer,
219                 ProtocolVersion.PROTOCOLS_TO_12
220             )
221         }),
222         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
223             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
224                 ServerHelloDone.handshakeProducer,
225                 ProtocolVersion.PROTOCOLS_TO_12
226             )
227         })),
228 
229     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
230     CERTIFICATE_VERIFY          ((byte)0x0F, &quot;certificate_verify&quot;,
231         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
232             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
233                 CertificateVerify.s30HandshakeConsumer,
234                 ProtocolVersion.PROTOCOLS_OF_30
235             ),
236             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
237                 CertificateVerify.t10HandshakeConsumer,
238                 ProtocolVersion.PROTOCOLS_10_11
239             ),
240             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
241                 CertificateVerify.t12HandshakeConsumer,
242                 ProtocolVersion.PROTOCOLS_OF_12
243             ),
244             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
245                 CertificateVerify.t13HandshakeConsumer,
246                 ProtocolVersion.PROTOCOLS_OF_13
247             )
248         }),
249         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
250             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
251                 CertificateVerify.s30HandshakeProducer,
252                 ProtocolVersion.PROTOCOLS_OF_30
253             ),
254             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
255                 CertificateVerify.t10HandshakeProducer,
256                 ProtocolVersion.PROTOCOLS_10_11
257             ),
258             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
259                 CertificateVerify.t12HandshakeProducer,
260                 ProtocolVersion.PROTOCOLS_OF_12
261             ),
262             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
263                 CertificateVerify.t13HandshakeProducer,
264                 ProtocolVersion.PROTOCOLS_OF_13
265             )
266         })),
267 
268     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
269     CLIENT_KEY_EXCHANGE         ((byte)0x10, &quot;client_key_exchange&quot;,
270         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
271             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
272                 ClientKeyExchange.handshakeConsumer,
273                 ProtocolVersion.PROTOCOLS_TO_12
274             )
275         }),
276         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
277             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
278                 ClientKeyExchange.handshakeProducer,
279                 ProtocolVersion.PROTOCOLS_TO_12
280             )
281         })),
282 
283     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
284     FINISHED                    ((byte)0x14, &quot;finished&quot;,
285         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
286             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
287                 Finished.t12HandshakeConsumer,
288                 ProtocolVersion.PROTOCOLS_TO_12
289             ),
290             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
291                 Finished.t13HandshakeConsumer,
292                 ProtocolVersion.PROTOCOLS_OF_13
293             )
294         }),
295         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
296             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
297                 Finished.t12HandshakeProducer,
298                 ProtocolVersion.PROTOCOLS_TO_12
299             ),
300             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
301                 Finished.t13HandshakeProducer,
302                 ProtocolVersion.PROTOCOLS_OF_13
303             )
304         })),
305 
306     CERTIFICATE_URL             ((byte)0x15, &quot;certificate_url&quot;),
307 
308     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
309     CERTIFICATE_STATUS          ((byte)0x16, &quot;certificate_status&quot;,
310         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
311             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
312                 CertificateStatus.handshakeConsumer,
313                 ProtocolVersion.PROTOCOLS_TO_12
314             )
315         }),
316         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
317             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
318                 CertificateStatus.handshakeProducer,
319                 ProtocolVersion.PROTOCOLS_TO_12
320             )
321         }),
322         (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(new Map.Entry[] {
323             new SimpleImmutableEntry&lt;HandshakeAbsence, ProtocolVersion[]&gt;(
324                 CertificateStatus.handshakeAbsence,
325                 ProtocolVersion.PROTOCOLS_TO_12
326             )
327         })),
328 
329     SUPPLEMENTAL_DATA           ((byte)0x17, &quot;supplemental_data&quot;),
330 
331     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
332     KEY_UPDATE                  ((byte)0x18, &quot;key_update&quot;,
333             (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
334                     new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
335                             KeyUpdate.handshakeConsumer,
336                             ProtocolVersion.PROTOCOLS_OF_13
337                     )
338             }),
339             (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
340                     new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
341                             KeyUpdate.handshakeProducer,
342                             ProtocolVersion.PROTOCOLS_OF_13
343                     )
344             })),
345     MESSAGE_HASH                ((byte)0xFE, &quot;message_hash&quot;),
346     NOT_APPLICABLE              ((byte)0xFF, &quot;not_applicable&quot;);
347 
348     final byte id;
349     final String name;
350     final Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers;
351     final Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers;
352     final Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[] handshakeAbsences;
353 
354     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
355     SSLHandshake(byte id, String name) {
356         this(id, name,
357                 (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(
358                         new Map.Entry[0]),
359                 (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(
360                         new Map.Entry[0]),
361                 (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(
362                         new Map.Entry[0]));
363     }
364 
365     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
366     SSLHandshake(byte id, String name,
367         Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers,
368         Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers) {
369 
370         this(id, name, handshakeConsumers, handshakeProducers,
371                 (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(
372                         new Map.Entry[0]));
373     }
374 
375     SSLHandshake(byte id, String name,
376         Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers,
377         Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers,
378         Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[] handshakeAbsence) {
379 
380         this.id = id;
381         this.name = name;
382         this.handshakeConsumers = handshakeConsumers;
383         this.handshakeProducers = handshakeProducers;
384         this.handshakeAbsences = handshakeAbsence;
385     }
386 
387     @Override
388     public void consume(ConnectionContext context,
389             ByteBuffer message) throws IOException {
390         SSLConsumer hc = getHandshakeConsumer(context);
391         if (hc != null) {
392             hc.consume(context, message);
393         } else {
394             throw new UnsupportedOperationException(
395                     &quot;Unsupported handshake consumer: &quot; + this.name);
396         }
397     }
398 
399     private SSLConsumer getHandshakeConsumer(ConnectionContext context) {
400         if (handshakeConsumers.length == 0) {
401             return null;
402         }
403 
404         // The consuming happens in handshake context only.
405         HandshakeContext hc = (HandshakeContext)context;
406         ProtocolVersion protocolVersion;
407         if ((hc.negotiatedProtocol == null) ||
408                 (hc.negotiatedProtocol == ProtocolVersion.NONE)) {
409             if (hc.conContext.isNegotiated &amp;&amp;
410                     hc.conContext.protocolVersion != ProtocolVersion.NONE) {
411                 protocolVersion = hc.conContext.protocolVersion;
412             } else {
413                 protocolVersion = hc.maximumActiveProtocol;
414             }
415         } else {
416             protocolVersion = hc.negotiatedProtocol;
417         }
418 
419         for (Map.Entry&lt;SSLConsumer,
420                 ProtocolVersion[]&gt; phe : handshakeConsumers) {
421             for (ProtocolVersion pv : phe.getValue()) {
422                 if (protocolVersion == pv) {
423                     return phe.getKey();
424                 }
425             }
426         }
427 
428         return null;
429     }
430 
431     @Override
432     public byte[] produce(ConnectionContext context,
433             HandshakeMessage message) throws IOException {
434         HandshakeProducer hp = getHandshakeProducer(context);
435         if (hp != null) {
436             return hp.produce(context, message);
437         } else {
438             throw new UnsupportedOperationException(
439                     &quot;Unsupported handshake producer: &quot; + this.name);
440         }
441     }
442 
443     private HandshakeProducer getHandshakeProducer(
444             ConnectionContext context) {
445         if (handshakeConsumers.length == 0) {
446             return null;
447         }
448 
449         // The consuming happens in handshake context only.
450         HandshakeContext hc = (HandshakeContext)context;
451         ProtocolVersion protocolVersion;
452         if ((hc.negotiatedProtocol == null) ||
453                 (hc.negotiatedProtocol == ProtocolVersion.NONE)) {
454             if (hc.conContext.isNegotiated &amp;&amp;
455                     hc.conContext.protocolVersion != ProtocolVersion.NONE) {
456                 protocolVersion = hc.conContext.protocolVersion;
457             } else {
458                 protocolVersion = hc.maximumActiveProtocol;
459             }
460         } else {
461             protocolVersion = hc.negotiatedProtocol;
462         }
463 
464         for (Map.Entry&lt;HandshakeProducer,
465                 ProtocolVersion[]&gt; phe : handshakeProducers) {
466             for (ProtocolVersion pv : phe.getValue()) {
467                 if (protocolVersion == pv) {
468                     return phe.getKey();
469                 }
470             }
471         }
472 
473         return null;
474     }
475 
476     @Override
477     public String toString() {
478         return name;
479     }
480 
481     static String nameOf(byte id) {
482         // If two handshake message share the same handshake type, returns
483         // the first handshake message name.
484         //
485         // It is not a big issue at present as only ServerHello and
486         // HellRetryRequest share a handshake type.
487         for (SSLHandshake hs : SSLHandshake.values()) {
488             if (hs.id == id) {
489                 return hs.name;
490             }
491         }
492 
493         return &quot;UNKNOWN-HANDSHAKE-MESSAGE(&quot; + id + &quot;)&quot;;
494     }
495 
496     static final void kickstart(HandshakeContext context) throws IOException {
497         if (context instanceof ClientHandshakeContext) {
498             // For initial handshaking, including session resumption,
499             // ClientHello message is used as the kickstart message.
500             //
501             // (D)TLS 1.2 and older protocols support renegotiation on existing
502             // connections.  A ClientHello messages is used to kickstart the
503             // renegotiation.
504             //
505             // (D)TLS 1.3 forbids renegotiation.  The post-handshake KeyUpdate
506             // message is used to update the sending cryptographic keys.
507             if (context.conContext.isNegotiated &amp;&amp;
508                     context.conContext.protocolVersion.useTLS13PlusSpec()) {
509                 // Use KeyUpdate message for renegotiation.
510                 KeyUpdate.kickstartProducer.produce(context);
511             } else {
512                 // Using ClientHello message for the initial handshaking
513                 // (including session resumption) or renegotiation.
514                 // SSLHandshake.CLIENT_HELLO.produce(context);
515                 ClientHello.kickstartProducer.produce(context);
516             }
517         } else {
518             // The server side can delivering kickstart message after the
519             // connection has established.
520             //
521             // (D)TLS 1.2 and older protocols use HelloRequest to begin a
522             // negotiation process anew.
523             //
524             // While (D)TLS 1.3 uses the post-handshake KeyUpdate message
525             // to update the sending cryptographic keys.
526             if (context.conContext.protocolVersion.useTLS13PlusSpec()) {
527                 // Use KeyUpdate message for renegotiation.
528                 KeyUpdate.kickstartProducer.produce(context);
529             } else {
530                 // SSLHandshake.HELLO_REQUEST.produce(context);
531                 HelloRequest.kickstartProducer.produce(context);
532             }
533         }
534     }
535 
536     /**
537      * A (transparent) specification of handshake message.
538      */
539     static abstract class HandshakeMessage {
540         final HandshakeContext      handshakeContext;
541 
542         HandshakeMessage(HandshakeContext handshakeContext) {
543             this.handshakeContext = handshakeContext;
544         }
545 
546         abstract SSLHandshake handshakeType();
547         abstract int messageLength();
548         abstract void send(HandshakeOutStream hos) throws IOException;
549 
550         void write(HandshakeOutStream hos) throws IOException {
551             int len = messageLength();
552             if (len &gt;= Record.OVERFLOW_OF_INT24) {
553                 throw new SSLException(&quot;Handshake message is overflow&quot;
554                         + &quot;, type = &quot; + handshakeType() + &quot;, len = &quot; + len);
555             }
556             hos.write(handshakeType().id);
557             hos.putInt24(len);
558             send(hos);
559             hos.complete();
560         }
561     }
562 }
    </pre>
  </body>
</html>
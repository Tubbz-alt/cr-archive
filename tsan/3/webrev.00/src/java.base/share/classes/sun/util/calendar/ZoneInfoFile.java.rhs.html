<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/util/calendar/ZoneInfoFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.util.calendar;
  27 
  28 import java.io.ByteArrayInputStream;
  29 import java.io.BufferedInputStream;
  30 import java.io.DataInput;
  31 import java.io.DataInputStream;
  32 import java.io.File;
  33 import java.io.FileInputStream;
  34 import java.io.IOException;
  35 import java.io.StreamCorruptedException;
  36 import java.security.AccessController;
  37 import java.security.PrivilegedAction;
  38 import java.time.LocalDateTime;
  39 import java.time.ZoneOffset;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.Calendar;
  43 import java.util.Collections;
  44 import java.util.HashMap;
  45 import java.util.List;
  46 import java.util.Locale;
  47 import java.util.Map;
  48 import java.util.SimpleTimeZone;
  49 import java.util.concurrent.ConcurrentHashMap;
  50 import java.util.zip.CRC32;
  51 
  52 import jdk.internal.util.StaticProperty;
  53 import sun.security.action.GetPropertyAction;
  54 
  55 /**
  56  * Loads TZDB time-zone rules for j.u.TimeZone
  57  * &lt;p&gt;
  58  * @since 1.8
  59  */
  60 public final class ZoneInfoFile {
  61 
  62     /**
  63      * Gets all available IDs supported in the Java run-time.
  64      *
  65      * @return a set of time zone IDs.
  66      */
  67     public static String[] getZoneIds() {
  68         int len = regions.length + oldMappings.length;
  69         if (!USE_OLDMAPPING) {
  70             len += 3;    // EST/HST/MST not in tzdb.dat
  71         }
  72         String[] ids = Arrays.copyOf(regions, len);
  73         int i = regions.length;
  74         if (!USE_OLDMAPPING) {
  75             ids[i++] = &quot;EST&quot;;
  76             ids[i++] = &quot;HST&quot;;
  77             ids[i++] = &quot;MST&quot;;
  78         }
  79         for (int j = 0; j &lt; oldMappings.length; j++) {
  80             ids[i++] = oldMappings[j][0];
  81         }
  82         return ids;
  83     }
  84 
  85     /**
  86      * Gets all available IDs that have the same value as the
  87      * specified raw GMT offset.
  88      *
  89      * @param rawOffset  the GMT offset in milliseconds. This
  90      *                   value should not include any daylight saving time.
  91      * @return an array of time zone IDs.
  92      */
  93     public static String[] getZoneIds(int rawOffset) {
  94         List&lt;String&gt; ids = new ArrayList&lt;&gt;();
  95         for (String id : getZoneIds()) {
  96             ZoneInfo zi = getZoneInfo(id);
  97             if (zi.getRawOffset() == rawOffset) {
  98                 ids.add(id);
  99             }
 100         }
 101         // It appears the &quot;zi&quot; implementation returns the
 102         // sorted list, though the specification does not
 103         // specify it. Keep the same behavior for better
 104         // compatibility.
 105         String[] list = ids.toArray(new String[ids.size()]);
 106         Arrays.sort(list);
 107         return list;
 108     }
 109 
 110     public static ZoneInfo getZoneInfo(String zoneId) {
 111         if (zoneId == null) {
 112             return null;
 113         }
 114         ZoneInfo zi = getZoneInfo0(zoneId);
 115         if (zi != null) {
 116             zi = (ZoneInfo)zi.clone();
 117             zi.setID(zoneId);
 118         }
 119         return zi;
 120     }
 121 
 122     private static ZoneInfo getZoneInfo0(String zoneId) {
 123         try {
 124             ZoneInfo zi = zones.get(zoneId);
 125             if (zi != null) {
 126                 return zi;
 127             }
 128             String zid = zoneId;
 129             if (aliases.containsKey(zoneId)) {
 130                 zid = aliases.get(zoneId);
 131             }
 132             int index = Arrays.binarySearch(regions, zid);
 133             if (index &lt; 0) {
 134                 return null;
 135             }
 136             byte[] bytes = ruleArray[indices[index]];
 137             DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));
 138             zi = getZoneInfo(dis, zid);
 139             zones.put(zoneId, zi);
 140             return zi;
 141         } catch (Exception ex) {
 142             throw new RuntimeException(&quot;Invalid binary time-zone data: TZDB:&quot; +
 143                 zoneId + &quot;, version: &quot; + versionId, ex);
 144         }
 145     }
 146 
 147     /**
 148      * Returns a Map from alias time zone IDs to their standard
 149      * time zone IDs.
 150      *
 151      * @return an unmodified alias mapping
 152      */
 153     public static Map&lt;String, String&gt; getAliasMap() {
 154         return Collections.unmodifiableMap(aliases);
 155     }
 156 
 157     /**
 158      * Gets the version of this tz data.
 159      *
 160      * @return the tzdb version
 161      */
 162     public static String getVersion() {
 163         return versionId;
 164     }
 165 
 166     /**
 167      * Gets a ZoneInfo with the given GMT offset. The object
 168      * has its ID in the format of GMT{+|-}hh:mm.
 169      *
 170      * @param originalId  the given custom id (before normalized such as &quot;GMT+9&quot;)
 171      * @param gmtOffset   GMT offset &lt;em&gt;in milliseconds&lt;/em&gt;
 172      * @return a ZoneInfo constructed with the given GMT offset
 173      */
 174     public static ZoneInfo getCustomTimeZone(String originalId, int gmtOffset) {
 175         String id = toCustomID(gmtOffset);
 176         return new ZoneInfo(id, gmtOffset);
 177     }
 178 
 179     public static String toCustomID(int gmtOffset) {
 180         char sign;
 181         int offset = gmtOffset / 60000;
 182         if (offset &gt;= 0) {
 183             sign = &#39;+&#39;;
 184         } else {
 185             sign = &#39;-&#39;;
 186             offset = -offset;
 187         }
 188         int hh = offset / 60;
 189         int mm = offset % 60;
 190 
 191         char[] buf = new char[] { &#39;G&#39;, &#39;M&#39;, &#39;T&#39;, sign, &#39;0&#39;, &#39;0&#39;, &#39;:&#39;, &#39;0&#39;, &#39;0&#39; };
 192         if (hh &gt;= 10) {
 193             buf[4] += hh / 10;
 194         }
 195         buf[5] += hh % 10;
 196         if (mm != 0) {
 197             buf[7] += mm / 10;
 198             buf[8] += mm % 10;
 199         }
 200         return new String(buf);
 201     }
 202 
 203     ///////////////////////////////////////////////////////////
 204     private ZoneInfoFile() {
 205     }
 206 
 207     private static String versionId;
 208     private static final Map&lt;String, ZoneInfo&gt; zones = new ConcurrentHashMap&lt;&gt;();
 209     private static Map&lt;String, String&gt; aliases = new HashMap&lt;&gt;();
 210 
 211     private static byte[][] ruleArray;
 212     private static String[] regions;
 213     private static int[] indices;
 214 
 215     // Flag for supporting JDK backward compatible IDs, such as &quot;EST&quot;.
 216     private static final boolean USE_OLDMAPPING;
 217 
 218     private static String[][] oldMappings = new String[][] {
 219         { &quot;ACT&quot;, &quot;Australia/Darwin&quot; },
 220         { &quot;AET&quot;, &quot;Australia/Sydney&quot; },
 221         { &quot;AGT&quot;, &quot;America/Argentina/Buenos_Aires&quot; },
 222         { &quot;ART&quot;, &quot;Africa/Cairo&quot; },
 223         { &quot;AST&quot;, &quot;America/Anchorage&quot; },
 224         { &quot;BET&quot;, &quot;America/Sao_Paulo&quot; },
 225         { &quot;BST&quot;, &quot;Asia/Dhaka&quot; },
 226         { &quot;CAT&quot;, &quot;Africa/Harare&quot; },
 227         { &quot;CNT&quot;, &quot;America/St_Johns&quot; },
 228         { &quot;CST&quot;, &quot;America/Chicago&quot; },
 229         { &quot;CTT&quot;, &quot;Asia/Shanghai&quot; },
 230         { &quot;EAT&quot;, &quot;Africa/Addis_Ababa&quot; },
 231         { &quot;ECT&quot;, &quot;Europe/Paris&quot; },
 232         { &quot;IET&quot;, &quot;America/Indiana/Indianapolis&quot; },
 233         { &quot;IST&quot;, &quot;Asia/Kolkata&quot; },
 234         { &quot;JST&quot;, &quot;Asia/Tokyo&quot; },
 235         { &quot;MIT&quot;, &quot;Pacific/Apia&quot; },
 236         { &quot;NET&quot;, &quot;Asia/Yerevan&quot; },
 237         { &quot;NST&quot;, &quot;Pacific/Auckland&quot; },
 238         { &quot;PLT&quot;, &quot;Asia/Karachi&quot; },
 239         { &quot;PNT&quot;, &quot;America/Phoenix&quot; },
 240         { &quot;PRT&quot;, &quot;America/Puerto_Rico&quot; },
 241         { &quot;PST&quot;, &quot;America/Los_Angeles&quot; },
 242         { &quot;SST&quot;, &quot;Pacific/Guadalcanal&quot; },
 243         { &quot;VST&quot;, &quot;Asia/Ho_Chi_Minh&quot; },
 244     };
 245 
 246     static {
 247         String oldmapping = GetPropertyAction
 248                 .privilegedGetProperty(&quot;sun.timezone.ids.oldmapping&quot;, &quot;false&quot;)
 249                 .toLowerCase(Locale.ROOT);
 250         USE_OLDMAPPING = (oldmapping.equals(&quot;yes&quot;) || oldmapping.equals(&quot;true&quot;));
 251         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 252             public Void run() {
 253                 try {
 254                     String libDir = StaticProperty.javaHome() + File.separator + &quot;lib&quot;;
 255                     try (DataInputStream dis = new DataInputStream(
 256                              new BufferedInputStream(new FileInputStream(
 257                                  new File(libDir, &quot;tzdb.dat&quot;))))) {
 258                         load(dis);
 259                     }
 260                 } catch (Exception x) {
 261                     throw new Error(x);
 262                 }
 263                 return null;
 264             }
 265         });
 266     }
 267 
 268     private static void addOldMapping() {
 269         for (String[] alias : oldMappings) {
 270             aliases.put(alias[0], alias[1]);
 271         }
 272         if (USE_OLDMAPPING) {
 273             aliases.put(&quot;EST&quot;, &quot;America/New_York&quot;);
 274             aliases.put(&quot;MST&quot;, &quot;America/Denver&quot;);
 275             aliases.put(&quot;HST&quot;, &quot;Pacific/Honolulu&quot;);
 276         } else {
 277             zones.put(&quot;EST&quot;, new ZoneInfo(&quot;EST&quot;, -18000000));
 278             zones.put(&quot;MST&quot;, new ZoneInfo(&quot;MST&quot;, -25200000));
 279             zones.put(&quot;HST&quot;, new ZoneInfo(&quot;HST&quot;, -36000000));
 280         }
 281     }
 282 
 283     public static boolean useOldMapping() {
 284        return USE_OLDMAPPING;
 285     }
 286 
 287     /**
 288      * Loads the rules from a DateInputStream
 289      *
 290      * @param dis  the DateInputStream to load, not null
 291      * @throws Exception if an error occurs
 292      */
 293     private static void load(DataInputStream dis) throws ClassNotFoundException, IOException {
 294         if (dis.readByte() != 1) {
 295             throw new StreamCorruptedException(&quot;File format not recognised&quot;);
 296         }
 297         // group
 298         String groupId = dis.readUTF();
 299         if (&quot;TZDB&quot;.equals(groupId) == false) {
 300             throw new StreamCorruptedException(&quot;File format not recognised&quot;);
 301         }
 302         // versions, only keep the last one
 303         int versionCount = dis.readShort();
 304         for (int i = 0; i &lt; versionCount; i++) {
 305             versionId = dis.readUTF();
 306 
 307         }
 308         // regions
 309         int regionCount = dis.readShort();
 310         String[] regionArray = new String[regionCount];
 311         for (int i = 0; i &lt; regionCount; i++) {
 312             regionArray[i] = dis.readUTF();
 313         }
 314         // rules
 315         int ruleCount = dis.readShort();
 316         ruleArray = new byte[ruleCount][];
 317         for (int i = 0; i &lt; ruleCount; i++) {
 318             byte[] bytes = new byte[dis.readShort()];
 319             dis.readFully(bytes);
 320             ruleArray[i] = bytes;
 321         }
 322         // link version-region-rules, only keep the last version, if more than one
 323         for (int i = 0; i &lt; versionCount; i++) {
 324             regionCount = dis.readShort();
 325             regions = new String[regionCount];
 326             indices = new int[regionCount];
 327             for (int j = 0; j &lt; regionCount; j++) {
 328                 regions[j] = regionArray[dis.readShort()];
 329                 indices[j] = dis.readShort();
 330             }
 331         }
 332         // remove the following ids from the map, they
 333         // are exclued from the &quot;old&quot; ZoneInfo
 334         zones.remove(&quot;ROC&quot;);
 335         for (int i = 0; i &lt; versionCount; i++) {
 336             int aliasCount = dis.readShort();
 337             aliases.clear();
 338             for (int j = 0; j &lt; aliasCount; j++) {
 339                 String alias = regionArray[dis.readShort()];
 340                 String region = regionArray[dis.readShort()];
 341                 aliases.put(alias, region);
 342             }
 343         }
 344         // old us time-zone names
 345         addOldMapping();
 346     }
 347 
 348     /////////////////////////Ser/////////////////////////////////
 349     public static ZoneInfo getZoneInfo(DataInput in, String zoneId) throws Exception {
 350         byte type = in.readByte();
 351         // TBD: assert ZRULES:
 352         int stdSize = in.readInt();
 353         long[] stdTrans = new long[stdSize];
 354         for (int i = 0; i &lt; stdSize; i++) {
 355             stdTrans[i] = readEpochSec(in);
 356         }
 357         int [] stdOffsets = new int[stdSize + 1];
 358         for (int i = 0; i &lt; stdOffsets.length; i++) {
 359             stdOffsets[i] = readOffset(in);
 360         }
 361         int savSize = in.readInt();
 362         long[] savTrans = new long[savSize];
 363         for (int i = 0; i &lt; savSize; i++) {
 364             savTrans[i] = readEpochSec(in);
 365         }
 366         int[] savOffsets = new int[savSize + 1];
 367         for (int i = 0; i &lt; savOffsets.length; i++) {
 368             savOffsets[i] = readOffset(in);
 369         }
 370         int ruleSize = in.readByte();
 371         ZoneOffsetTransitionRule[] rules = new ZoneOffsetTransitionRule[ruleSize];
 372         for (int i = 0; i &lt; ruleSize; i++) {
 373             rules[i] = new ZoneOffsetTransitionRule(in);
 374         }
 375         return getZoneInfo(zoneId, stdTrans, stdOffsets, savTrans, savOffsets, rules);
 376     }
 377 
 378     public static int readOffset(DataInput in) throws IOException {
 379         int offsetByte = in.readByte();
 380         return offsetByte == 127 ? in.readInt() : offsetByte * 900;
 381     }
 382 
 383     static long readEpochSec(DataInput in) throws IOException {
 384         int hiByte = in.readByte() &amp; 255;
 385         if (hiByte == 255) {
 386             return in.readLong();
 387         } else {
 388             int midByte = in.readByte() &amp; 255;
 389             int loByte = in.readByte() &amp; 255;
 390             long tot = ((hiByte &lt;&lt; 16) + (midByte &lt;&lt; 8) + loByte);
 391             return (tot * 900) - 4575744000L;
 392         }
 393     }
 394 
 395     /////////////////////////ZoneRules --&gt; ZoneInfo/////////////////////////////////
 396 
 397     // ZoneInfo starts with UTC1900
 398     private static final long UTC1900 = -2208988800L;
 399 
 400     // ZoneInfo ends with   UTC2037
 401     // LocalDateTime.of(2038, 1, 1, 0, 0, 0).toEpochSecond(ZoneOffset.UTC) - 1;
 402     private static final long UTC2037 = 2145916799L;
 403 
 404     // ZoneInfo has an ending entry for 2037, this need to be offset by
 405     // a &quot;rawOffset&quot;
 406     // LocalDateTime.of(2037, 1, 1, 0, 0, 0).toEpochSecond(ZoneOffset.UTC));
 407     private static final long LDT2037 = 2114380800L;
 408 
 409     //Current time. Used to determine future GMToffset transitions
 410     private static final long CURRT = System.currentTimeMillis()/1000;
 411 
 412     /* Get a ZoneInfo instance.
 413      *
 414      * @param standardTransitions  the standard transitions, not null
 415      * @param standardOffsets  the standard offsets, not null
 416      * @param savingsInstantTransitions  the standard transitions, not null
 417      * @param wallOffsets  the wall offsets, not null
 418      * @param lastRules  the recurring last rules, size 15 or less, not null
 419      */
 420     private static ZoneInfo getZoneInfo(String zoneId,
 421                                         long[] standardTransitions,
 422                                         int[] standardOffsets,
 423                                         long[] savingsInstantTransitions,
 424                                         int[] wallOffsets,
 425                                         ZoneOffsetTransitionRule[] lastRules) {
 426         int rawOffset = 0;
 427         int dstSavings = 0;
 428         int checksum = 0;
 429         int[] params = null;
 430         boolean willGMTOffsetChange = false;
 431 
 432         // rawOffset, pick the last one
 433         if (standardTransitions.length &gt; 0) {
 434             rawOffset = standardOffsets[standardOffsets.length - 1] * 1000;
 435             willGMTOffsetChange = standardTransitions[standardTransitions.length - 1] &gt; CURRT;
 436         }
 437         else
 438             rawOffset = standardOffsets[0] * 1000;
 439 
 440         // transitions, offsets;
 441         long[] transitions = null;
 442         int[]  offsets = null;
 443         int    nOffsets = 0;
 444         int    nTrans = 0;
 445 
 446         if (savingsInstantTransitions.length != 0) {
 447             transitions = new long[250];
 448             offsets = new int[100];    // TBD: ZoneInfo actually can&#39;t handle
 449                                        // offsets.length &gt; 16 (4-bit index limit)
 450             // last year in trans table
 451             // It should not matter to use before or after offset for year
 452             int lastyear = getYear(savingsInstantTransitions[savingsInstantTransitions.length - 1],
 453                                    wallOffsets[savingsInstantTransitions.length - 1]);
 454             int i = 0, k = 1;
 455             while (i &lt; savingsInstantTransitions.length &amp;&amp;
 456                    savingsInstantTransitions[i] &lt; UTC1900) {
 457                 i++;     // skip any date before UTC1900
 458             }
 459             if (i &lt; savingsInstantTransitions.length) {
 460                 // javazic writes the last GMT offset into index 0!
 461                 if (i &lt; savingsInstantTransitions.length) {
 462                     offsets[0] = standardOffsets[standardOffsets.length - 1] * 1000;
 463                     nOffsets = 1;
 464                 }
 465                 // ZoneInfo has a beginning entry for 1900.
 466                 // Only add it if this is not the only one in table
 467                 nOffsets = addTrans(transitions, nTrans++,
 468                                     offsets, nOffsets,
 469                                     UTC1900,
 470                                     wallOffsets[i],
 471                                     getStandardOffset(standardTransitions, standardOffsets, UTC1900));
 472             }
 473 
 474             for (; i &lt; savingsInstantTransitions.length; i++) {
 475                 long trans = savingsInstantTransitions[i];
 476                 if (trans &gt; UTC2037) {
 477                     // no trans beyond LASTYEAR
 478                     lastyear = LASTYEAR;
 479                     break;
 480                 }
 481                 while (k &lt; standardTransitions.length) {
 482                     // some standard offset transitions don&#39;t exist in
 483                     // savingInstantTrans, if the offset &quot;change&quot; doesn&#39;t
 484                     // really change the &quot;effectiveWallOffset&quot;. For example
 485                     // the 1999/2000 pair in Zone Arg/Buenos_Aires, in which
 486                     // the daylightsaving &quot;happened&quot; but it actually does
 487                     // not result in the timezone switch. ZoneInfo however
 488                     // needs them in its transitions table
 489                     long trans_s = standardTransitions[k];
 490                     if (trans_s &gt;= UTC1900) {
 491                         if (trans_s &gt; trans)
 492                             break;
 493                         if (trans_s &lt; trans) {
 494                             if (nOffsets + 2 &gt;= offsets.length) {
 495                                 offsets = Arrays.copyOf(offsets, offsets.length + 100);
 496                             }
 497                             if (nTrans + 1 &gt;= transitions.length) {
 498                                 transitions = Arrays.copyOf(transitions, transitions.length + 100);
 499                             }
 500                             nOffsets = addTrans(transitions, nTrans++, offsets, nOffsets,
 501                                                 trans_s,
 502                                                 wallOffsets[i],
 503                                                 standardOffsets[k+1]);
 504 
 505                         }
 506                     }
 507                     k++;
 508                 }
 509                 if (nOffsets + 2 &gt;= offsets.length) {
 510                     offsets = Arrays.copyOf(offsets, offsets.length + 100);
 511                 }
 512                 if (nTrans + 1 &gt;= transitions.length) {
 513                     transitions = Arrays.copyOf(transitions, transitions.length + 100);
 514                 }
 515                 nOffsets = addTrans(transitions, nTrans++, offsets, nOffsets,
 516                                     trans,
 517                                     wallOffsets[i + 1],
 518                                     getStandardOffset(standardTransitions, standardOffsets, trans));
 519 
 520             }
 521             // append any leftover standard trans
 522             while (k &lt; standardTransitions.length) {
 523                 long trans = standardTransitions[k];
 524                 if (trans &gt;= UTC1900) {
 525                     int offset = wallOffsets[i];
 526                     int offsetIndex = indexOf(offsets, 0, nOffsets, offset);
 527                     if (offsetIndex == nOffsets)
 528                         nOffsets++;
 529                     transitions[nTrans++] = ((trans * 1000) &lt;&lt; TRANSITION_NSHIFT) |
 530                                             (offsetIndex &amp; OFFSET_MASK);
 531                 }
 532                 k++;
 533             }
 534             if (lastRules.length &gt; 1) {
 535                 // fill the gap between the last trans until LASTYEAR
 536                 while (lastyear++ &lt; LASTYEAR) {
 537                     for (ZoneOffsetTransitionRule zotr : lastRules) {
 538                         long trans = zotr.getTransitionEpochSecond(lastyear);
 539                         if (nOffsets + 2 &gt;= offsets.length) {
 540                             offsets = Arrays.copyOf(offsets, offsets.length + 100);
 541                         }
 542                         if (nTrans + 1 &gt;= transitions.length) {
 543                             transitions = Arrays.copyOf(transitions, transitions.length + 100);
 544                         }
 545                         nOffsets = addTrans(transitions, nTrans++,
 546                                             offsets, nOffsets,
 547                                             trans,
 548                                             zotr.offsetAfter,
 549                                             zotr.standardOffset);
 550                     }
 551                 }
 552                 ZoneOffsetTransitionRule startRule =  lastRules[lastRules.length - 2];
 553                 ZoneOffsetTransitionRule endRule =  lastRules[lastRules.length - 1];
 554                 params = new int[10];
 555                 if (startRule.offsetAfter - startRule.offsetBefore &lt; 0 &amp;&amp;
 556                     endRule.offsetAfter - endRule.offsetBefore &gt; 0) {
 557                     ZoneOffsetTransitionRule tmp;
 558                     tmp = startRule;
 559                     startRule = endRule;
 560                     endRule = tmp;
 561                 }
 562                 params[0] = startRule.month - 1;
 563                 int dom = startRule.dom;
 564                 int dow = startRule.dow;
 565                 if (dow == -1) {
 566                     params[1] = dom;
 567                     params[2] = 0;
 568                 } else {
 569                     // ZoneRulesBuilder adjusts &lt; 0 case (-1, for last, don&#39;t have
 570                     // &quot;&lt;=&quot; case yet) to positive value if not February (it appears
 571                     // we don&#39;t have February cutoff in tzdata table yet)
 572                     // Ideally, if JSR310 can just pass in the nagative and
 573                     // we can then pass in the dom = -1, dow &gt; 0 into ZoneInfo
 574                     //
 575                     // hacking, assume the &gt;=24 is the result of ZRB optimization for
 576                     // &quot;last&quot;, it works for now.
 577                     if (dom &lt; 0 || dom &gt;= 24) {
 578                         params[1] = -1;
 579                         params[2] = toCalendarDOW[dow];
 580                     } else {
 581                         params[1] = dom;
 582                         // To specify a day of week on or after an exact day of month,
 583                         // set the month to an exact month value, day-of-month to the
 584                         // day on or after which the rule is applied, and day-of-week
 585                         // to a negative Calendar.DAY_OF_WEEK DAY_OF_WEEK field value.
 586                         params[2] = -toCalendarDOW[dow];
 587                     }
 588                 }
 589                 params[3] = startRule.secondOfDay * 1000;
 590                 params[4] = toSTZTime[startRule.timeDefinition];
 591                 params[5] = endRule.month - 1;
 592                 dom = endRule.dom;
 593                 dow = endRule.dow;
 594                 if (dow == -1) {
 595                     params[6] = dom;
 596                     params[7] = 0;
 597                 } else {
 598                     // hacking: see comment above
 599                     if (dom &lt; 0 || dom &gt;= 24) {
 600                         params[6] = -1;
 601                         params[7] = toCalendarDOW[dow];
 602                     } else {
 603                         params[6] = dom;
 604                         params[7] = -toCalendarDOW[dow];
 605                     }
 606                 }
 607                 params[8] = endRule.secondOfDay * 1000;
 608                 params[9] = toSTZTime[endRule.timeDefinition];
 609                 dstSavings = (startRule.offsetAfter - startRule.offsetBefore) * 1000;
 610 
 611                 // Note: known mismatching -&gt; Asia/Amman
<a name="2" id="anc2"></a>

 612                 // ZoneInfo :      startDayOfWeek=5     &lt;= Thursday
 613                 //                 startTime=86400000   &lt;= 24 hours
 614                 // This:           startDayOfWeek=6
 615                 //                 startTime=0
 616                 // Similar workaround needs to be applied to Africa/Cairo and
 617                 // its endDayOfWeek and endTime
 618                 // Below is the workarounds, it probably slows down everyone a little
 619                 if (params[2] == 6 &amp;&amp; params[3] == 0 &amp;&amp;
<a name="3" id="anc3"></a><span class="line-modified"> 620                     (zoneId.equals(&quot;Asia/Amman&quot;))) {</span>


 621                     params[2] = 5;
 622                     params[3] = 86400000;
 623                 }
 624                 // Additional check for startDayOfWeek=6 and starTime=86400000
<a name="4" id="anc4"></a><span class="line-modified"> 625                 // is needed for Asia/Amman;</span>
 626                 if (params[2] == 7 &amp;&amp; params[3] == 0 &amp;&amp;
<a name="5" id="anc5"></a><span class="line-modified"> 627                      (zoneId.equals(&quot;Asia/Amman&quot;))) {</span>


 628                     params[2] = 6;        // Friday
 629                     params[3] = 86400000; // 24h
 630                 }
 631                 //endDayOfWeek and endTime workaround
 632                 if (params[7] == 6 &amp;&amp; params[8] == 0 &amp;&amp;
 633                     (zoneId.equals(&quot;Africa/Cairo&quot;))) {
 634                     params[7] = 5;
 635                     params[8] = 86400000;
 636                 }
 637 
 638             } else if (nTrans &gt; 0) {  // only do this if there is something in table already
 639                 if (lastyear &lt; LASTYEAR) {
 640                     // ZoneInfo has an ending entry for 2037
 641                     //long trans = OffsetDateTime.of(LASTYEAR, 1, 1, 0, 0, 0, 0,
 642                     //                               ZoneOffset.ofTotalSeconds(rawOffset/1000))
 643                     //                           .toEpochSecond();
 644                     long trans = LDT2037 - rawOffset/1000;
 645 
 646                     int offsetIndex = indexOf(offsets, 0, nOffsets, rawOffset/1000);
 647                     if (offsetIndex == nOffsets)
 648                         nOffsets++;
 649                     transitions[nTrans++] = (trans * 1000) &lt;&lt; TRANSITION_NSHIFT |
 650                                        (offsetIndex &amp; OFFSET_MASK);
 651 
 652                 } else if (savingsInstantTransitions.length &gt; 2) {
 653                     // Workaround: create the params based on the last pair for
 654                     // zones like Israel and Iran which have trans defined
 655                     // up until 2037, but no &quot;transition rule&quot; defined
 656                     //
 657                     // Note: Known mismatching for Israel, Asia/Jerusalem/Tel Aviv
 658                     // ZoneInfo:        startMode=3
 659                     //                  startMonth=2
 660                     //                  startDay=26
 661                     //                  startDayOfWeek=6
 662                     //
 663                     // This:            startMode=1
 664                     //                  startMonth=2
 665                     //                  startDay=27
 666                     //                  startDayOfWeek=0
 667                     // these two are actually the same for 2037, the SimpleTimeZone
 668                     // for the last &quot;known&quot; year
 669                     int m = savingsInstantTransitions.length;
 670                     long startTrans = savingsInstantTransitions[m - 2];
 671                     int startOffset = wallOffsets[m - 2 + 1];
 672                     int startStd = getStandardOffset(standardTransitions, standardOffsets, startTrans);
 673                     long endTrans =  savingsInstantTransitions[m - 1];
 674                     int endOffset = wallOffsets[m - 1 + 1];
 675                     int endStd = getStandardOffset(standardTransitions, standardOffsets, endTrans);
 676                     if (startOffset &gt; startStd &amp;&amp; endOffset == endStd) {
 677                         // last - 1 trans
 678                         m = savingsInstantTransitions.length - 2;
 679                         ZoneOffset before = ZoneOffset.ofTotalSeconds(wallOffsets[m]);
 680                         ZoneOffset after = ZoneOffset.ofTotalSeconds(wallOffsets[m + 1]);
 681                         LocalDateTime ldt = LocalDateTime.ofEpochSecond(savingsInstantTransitions[m], 0, before);
 682                         LocalDateTime startLDT;
 683                         if (after.getTotalSeconds() &gt; before.getTotalSeconds()) {  // isGap()
 684                             startLDT = ldt;
 685                         } else {
 686                             startLDT = ldt.plusSeconds(wallOffsets[m + 1] - wallOffsets[m]);
 687                         }
 688                         // last trans
 689                         m = savingsInstantTransitions.length - 1;
 690                         before = ZoneOffset.ofTotalSeconds(wallOffsets[m]);
 691                         after = ZoneOffset.ofTotalSeconds(wallOffsets[m + 1]);
 692                         ldt = LocalDateTime.ofEpochSecond(savingsInstantTransitions[m], 0, before);
 693                         LocalDateTime endLDT;
 694                         if (after.getTotalSeconds() &gt; before.getTotalSeconds()) {  // isGap()
 695                             endLDT = ldt.plusSeconds(wallOffsets[m + 1] - wallOffsets[m]);
 696                         } else {
 697                             endLDT = ldt;
 698                         }
 699                         params = new int[10];
 700                         params[0] = startLDT.getMonthValue() - 1;
 701                         params[1] = startLDT.getDayOfMonth();
 702                         params[2] = 0;
 703                         params[3] = startLDT.toLocalTime().toSecondOfDay() * 1000;
 704                         params[4] = SimpleTimeZone.WALL_TIME;
 705                         params[5] = endLDT.getMonthValue() - 1;
 706                         params[6] = endLDT.getDayOfMonth();
 707                         params[7] = 0;
 708                         params[8] = endLDT.toLocalTime().toSecondOfDay() * 1000;
 709                         params[9] = SimpleTimeZone.WALL_TIME;
 710                         dstSavings = (startOffset - startStd) * 1000;
 711                     }
 712                 }
 713             }
 714             if (transitions != null &amp;&amp; transitions.length != nTrans) {
 715                 if (nTrans == 0) {
 716                     transitions = null;
 717                 } else {
 718                     transitions = Arrays.copyOf(transitions, nTrans);
 719                 }
 720             }
 721             if (offsets != null &amp;&amp; offsets.length != nOffsets) {
 722                 if (nOffsets == 0) {
 723                     offsets = null;
 724                 } else {
 725                     offsets = Arrays.copyOf(offsets, nOffsets);
 726                 }
 727             }
 728             if (transitions != null) {
 729                 Checksum sum = new Checksum();
 730                 for (i = 0; i &lt; transitions.length; i++) {
 731                     long val = transitions[i];
 732                     int dst = (int)((val &gt;&gt;&gt; DST_NSHIFT) &amp; 0xfL);
 733                     int saving = (dst == 0) ? 0 : offsets[dst];
 734                     int index = (int)(val &amp; OFFSET_MASK);
 735                     int offset = offsets[index];
 736                     long second = (val &gt;&gt; TRANSITION_NSHIFT);
 737                     // javazic uses &quot;index of the offset in offsets&quot;,
 738                     // instead of the real offset value itself to
 739                     // calculate the checksum. Have to keep doing
 740                     // the same thing, checksum is part of the
 741                     // ZoneInfo serialization form.
 742                     sum.update(second + index);
 743                     sum.update(index);
 744                     sum.update(dst == 0 ? -1 : dst);
 745                 }
 746                 checksum = (int)sum.getValue();
 747             }
 748         }
 749         return new ZoneInfo(zoneId, rawOffset, dstSavings, checksum, transitions,
 750                             offsets, params, willGMTOffsetChange);
 751     }
 752 
 753     private static int getStandardOffset(long[] standardTransitions,
 754                                          int[] standardOffsets,
 755                                          long epochSec) {
 756         // The size of stdOffsets is [0..9], with most are
 757         // [1..4] entries , simple loop search is faster
 758         //
 759         // int index  = Arrays.binarySearch(standardTransitions, epochSec);
 760         // if (index &lt; 0) {
 761         //    // switch negative insert position to start of matched range
 762         //    index = -index - 2;
 763         // }
 764         // return standardOffsets[index + 1];
 765         int index = 0;
 766         for (; index &lt; standardTransitions.length; index++) {
 767             if (epochSec &lt; standardTransitions[index]) {
 768                 break;
 769             }
 770         }
 771         return standardOffsets[index];
 772     }
 773 
 774     static final int SECONDS_PER_DAY = 86400;
 775     static final int DAYS_PER_CYCLE = 146097;
 776     static final long DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);
 777 
 778     private static int getYear(long epochSecond, int offset) {
 779         long second = epochSecond + offset;  // overflow caught later
 780         long epochDay = Math.floorDiv(second, SECONDS_PER_DAY);
 781         long zeroDay = epochDay + DAYS_0000_TO_1970;
 782         // find the march-based year
 783         zeroDay -= 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle
 784         long adjust = 0;
 785         if (zeroDay &lt; 0) {
 786             // adjust negative years to positive for calculation
 787             long adjustCycles = (zeroDay + 1) / DAYS_PER_CYCLE - 1;
 788             adjust = adjustCycles * 400;
 789             zeroDay += -adjustCycles * DAYS_PER_CYCLE;
 790         }
 791         long yearEst = (400 * zeroDay + 591) / DAYS_PER_CYCLE;
 792         long doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);
 793         if (doyEst &lt; 0) {
 794             // fix estimate
 795             yearEst--;
 796             doyEst = zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);
 797         }
 798         yearEst += adjust;  // reset any negative year
 799         int marchDoy0 = (int) doyEst;
 800         // convert march-based values back to january-based
 801         int marchMonth0 = (marchDoy0 * 5 + 2) / 153;
 802         int month = (marchMonth0 + 2) % 12 + 1;
 803         int dom = marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;
 804         yearEst += marchMonth0 / 10;
 805         return (int)yearEst;
 806     }
 807 
 808     private static final int toCalendarDOW[] = new int[] {
 809         -1,
 810         Calendar.MONDAY,
 811         Calendar.TUESDAY,
 812         Calendar.WEDNESDAY,
 813         Calendar.THURSDAY,
 814         Calendar.FRIDAY,
 815         Calendar.SATURDAY,
 816         Calendar.SUNDAY
 817     };
 818 
 819     private static final int toSTZTime[] = new int[] {
 820         SimpleTimeZone.UTC_TIME,
 821         SimpleTimeZone.WALL_TIME,
 822         SimpleTimeZone.STANDARD_TIME,
 823     };
 824 
 825     private static final long OFFSET_MASK = 0x0fL;
 826     private static final long DST_MASK = 0xf0L;
 827     private static final int  DST_NSHIFT = 4;
 828     private static final int  TRANSITION_NSHIFT = 12;
 829     private static final int  LASTYEAR = 2037;
 830 
 831     // from: 0 for offset lookup, 1 for dstsvings lookup
 832     private static int indexOf(int[] offsets, int from, int nOffsets, int offset) {
 833         offset *= 1000;
 834         for (; from &lt; nOffsets; from++) {
 835             if (offsets[from] == offset)
 836                 return from;
 837         }
 838         offsets[from] = offset;
 839         return from;
 840     }
 841 
 842     // return updated nOffsets
 843     private static int addTrans(long transitions[], int nTrans,
 844                                 int offsets[], int nOffsets,
 845                                 long trans, int offset, int stdOffset) {
 846         int offsetIndex = indexOf(offsets, 0, nOffsets, offset);
 847         if (offsetIndex == nOffsets)
 848             nOffsets++;
 849         int dstIndex = 0;
 850         if (offset != stdOffset) {
 851             dstIndex = indexOf(offsets, 1, nOffsets, offset - stdOffset);
 852             if (dstIndex == nOffsets)
 853                 nOffsets++;
 854         }
 855         transitions[nTrans] = ((trans * 1000) &lt;&lt; TRANSITION_NSHIFT) |
 856                               ((dstIndex &lt;&lt; DST_NSHIFT) &amp; DST_MASK) |
 857                               (offsetIndex &amp; OFFSET_MASK);
 858         return nOffsets;
 859     }
 860 
 861     // ZoneInfo checksum, copy/pasted from javazic
 862     private static class Checksum extends CRC32 {
 863         public void update(int val) {
 864             byte[] b = new byte[4];
 865             b[0] = (byte)(val &gt;&gt;&gt; 24);
 866             b[1] = (byte)(val &gt;&gt;&gt; 16);
 867             b[2] = (byte)(val &gt;&gt;&gt; 8);
 868             b[3] = (byte)(val);
 869             update(b);
 870         }
 871         void update(long val) {
 872             byte[] b = new byte[8];
 873             b[0] = (byte)(val &gt;&gt;&gt; 56);
 874             b[1] = (byte)(val &gt;&gt;&gt; 48);
 875             b[2] = (byte)(val &gt;&gt;&gt; 40);
 876             b[3] = (byte)(val &gt;&gt;&gt; 32);
 877             b[4] = (byte)(val &gt;&gt;&gt; 24);
 878             b[5] = (byte)(val &gt;&gt;&gt; 16);
 879             b[6] = (byte)(val &gt;&gt;&gt; 8);
 880             b[7] = (byte)(val);
 881             update(b);
 882         }
 883     }
 884 
 885     // A simple/raw version of j.t.ZoneOffsetTransitionRule
 886     private static class ZoneOffsetTransitionRule {
 887         private final int month;
 888         private final byte dom;
 889         private final int dow;
 890         private final int secondOfDay;
 891         private final boolean timeEndOfDay;
 892         private final int timeDefinition;
 893         private final int standardOffset;
 894         private final int offsetBefore;
 895         private final int offsetAfter;
 896 
 897         ZoneOffsetTransitionRule(DataInput in) throws IOException {
 898             int data = in.readInt();
 899             int dowByte = (data &amp; (7 &lt;&lt; 19)) &gt;&gt;&gt; 19;
 900             int timeByte = (data &amp; (31 &lt;&lt; 14)) &gt;&gt;&gt; 14;
 901             int stdByte = (data &amp; (255 &lt;&lt; 4)) &gt;&gt;&gt; 4;
 902             int beforeByte = (data &amp; (3 &lt;&lt; 2)) &gt;&gt;&gt; 2;
 903             int afterByte = (data &amp; 3);
 904 
 905             this.month = data &gt;&gt;&gt; 28;
 906             this.dom = (byte)(((data &amp; (63 &lt;&lt; 22)) &gt;&gt;&gt; 22) - 32);
 907             this.dow = dowByte == 0 ? -1 : dowByte;
 908             this.secondOfDay = timeByte == 31 ? in.readInt() : timeByte * 3600;
 909             this.timeEndOfDay = timeByte == 24;
 910             this.timeDefinition = (data &amp; (3 &lt;&lt; 12)) &gt;&gt;&gt; 12;
 911 
 912             this.standardOffset = stdByte == 255 ? in.readInt() : (stdByte - 128) * 900;
 913             this.offsetBefore = beforeByte == 3 ? in.readInt() : standardOffset + beforeByte * 1800;
 914             this.offsetAfter = afterByte == 3 ? in.readInt() : standardOffset + afterByte * 1800;
 915         }
 916 
 917         long getTransitionEpochSecond(int year) {
 918             long epochDay = 0;
 919             if (dom &lt; 0) {
 920                 epochDay = toEpochDay(year, month, lengthOfMonth(year, month) + 1 + dom);
 921                 if (dow != -1) {
 922                     epochDay = previousOrSame(epochDay, dow);
 923                 }
 924             } else {
 925                 epochDay = toEpochDay(year, month, dom);
 926                 if (dow != -1) {
 927                     epochDay = nextOrSame(epochDay, dow);
 928                 }
 929             }
 930             if (timeEndOfDay) {
 931                 epochDay += 1;
 932             }
 933             int difference = 0;
 934             switch (timeDefinition) {
 935                 case 0:    // UTC
 936                     difference = 0;
 937                     break;
 938                 case 1:    // WALL
 939                     difference = -offsetBefore;
 940                     break;
 941                 case 2:    //STANDARD
 942                     difference = -standardOffset;
 943                     break;
 944             }
 945             return epochDay * 86400 + secondOfDay + difference;
 946         }
 947 
 948         static final boolean isLeapYear(int year) {
 949             return ((year &amp; 3) == 0) &amp;&amp; ((year % 100) != 0 || (year % 400) == 0);
 950         }
 951 
 952         static final int lengthOfMonth(int year, int month) {
 953             switch (month) {
 954                 case 2:        //FEBRUARY:
 955                     return isLeapYear(year)? 29 : 28;
 956                 case 4:        //APRIL:
 957                 case 6:        //JUNE:
 958                 case 9:        //SEPTEMBER:
 959                 case 11:       //NOVEMBER:
 960                     return 30;
 961                 default:
 962                     return 31;
 963             }
 964         }
 965 
 966         static final long toEpochDay(int year, int month, int day) {
 967             long y = year;
 968             long m = month;
 969             long total = 0;
 970             total += 365 * y;
 971             if (y &gt;= 0) {
 972                 total += (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;
 973             } else {
 974                 total -= y / -4 - y / -100 + y / -400;
 975             }
 976             total += ((367 * m - 362) / 12);
 977             total += day - 1;
 978             if (m &gt; 2) {
 979                 total--;
 980                 if (!isLeapYear(year)) {
 981                     total--;
 982                 }
 983             }
 984             return total - DAYS_0000_TO_1970;
 985         }
 986 
 987         static final long previousOrSame(long epochDay, int dayOfWeek) {
 988             return adjust(epochDay, dayOfWeek, 1);
 989         }
 990 
 991         static final long nextOrSame(long epochDay, int dayOfWeek) {
 992            return adjust(epochDay, dayOfWeek, 0);
 993         }
 994 
 995         static final long adjust(long epochDay, int dow, int relative) {
 996             int calDow = (int)Math.floorMod(epochDay + 3, 7L) + 1;
 997             if (relative &lt; 2 &amp;&amp; calDow == dow) {
 998                 return epochDay;
 999             }
1000             if ((relative &amp; 1) == 0) {
1001                 int daysDiff = calDow - dow;
1002                 return epochDay + (daysDiff &gt;= 0 ? 7 - daysDiff : -daysDiff);
1003             } else {
1004                 int daysDiff = dow - calDow;
1005                 return epochDay - (daysDiff &gt;= 0 ? 7 - daysDiff : -daysDiff);
1006             }
1007         }
1008     }
1009 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
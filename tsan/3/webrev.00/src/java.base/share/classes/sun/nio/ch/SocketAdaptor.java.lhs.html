<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.OutputStream;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.net.Socket;
 34 import java.net.SocketAddress;
 35 import java.net.SocketException;
<a name="2" id="anc2"></a><span class="line-removed"> 36 import java.net.SocketImpl;</span>
 37 import java.net.SocketOption;
<a name="3" id="anc3"></a><span class="line-removed"> 38 import java.net.SocketTimeoutException;</span>
 39 import java.net.StandardSocketOptions;
<a name="4" id="anc4"></a><span class="line-removed"> 40 import java.nio.ByteBuffer;</span>
<span class="line-removed"> 41 import java.nio.channels.Channels;</span>
<span class="line-removed"> 42 import java.nio.channels.ClosedChannelException;</span>
<span class="line-removed"> 43 import java.nio.channels.IllegalBlockingModeException;</span>
 44 import java.nio.channels.SocketChannel;
 45 import java.security.AccessController;
<a name="5" id="anc5"></a>
 46 import java.security.PrivilegedExceptionAction;
<a name="6" id="anc6"></a><span class="line-modified"> 47 import static java.util.concurrent.TimeUnit.*;</span>


 48 
 49 // Make a socket channel look like a socket.
 50 //
 51 // The methods in this class are defined in exactly the same order as in
 52 // java.net.Socket so as to simplify tracking future changes to that class.
 53 //
 54 
 55 class SocketAdaptor
 56     extends Socket
 57 {
 58     // The channel being adapted
 59     private final SocketChannelImpl sc;
 60 
 61     // Timeout &quot;option&quot; value for reads
 62     private volatile int timeout;
 63 
 64     private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
<a name="7" id="anc7"></a><span class="line-modified"> 65         super((SocketImpl) null);</span>
 66         this.sc = sc;
 67     }
 68 
<a name="8" id="anc8"></a><span class="line-modified"> 69     public static Socket create(SocketChannelImpl sc) {</span>

 70         try {
<a name="9" id="anc9"></a><span class="line-modified"> 71             return new SocketAdaptor(sc);</span>
<span class="line-modified"> 72         } catch (SocketException e) {</span>
<span class="line-modified"> 73             throw new InternalError(&quot;Should not reach here&quot;);</span>
 74         }
 75     }
 76 
<a name="10" id="anc10"></a><span class="line-modified"> 77     public SocketChannel getChannel() {</span>
<span class="line-removed"> 78         return sc;</span>
<span class="line-removed"> 79     }</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81     // Override this method just to protect against changes in the superclass</span>
<span class="line-removed"> 82     //</span>
 83     public void connect(SocketAddress remote) throws IOException {
 84         connect(remote, 0);
 85     }
 86 
<a name="11" id="anc11"></a>
 87     public void connect(SocketAddress remote, int timeout) throws IOException {
 88         if (remote == null)
 89             throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
 90         if (timeout &lt; 0)
 91             throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 92 </span>
<span class="line-modified"> 93         synchronized (sc.blockingLock()) {</span>
<span class="line-modified"> 94             if (!sc.isBlocking())</span>
<span class="line-modified"> 95                 throw new IllegalBlockingModeException();</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97             try {</span>
<span class="line-removed"> 98                 // no timeout</span>
<span class="line-removed"> 99                 if (timeout == 0) {</span>
<span class="line-removed">100                     sc.connect(remote);</span>
<span class="line-removed">101                     return;</span>
<span class="line-removed">102                 }</span>
<span class="line-removed">103 </span>
<span class="line-removed">104                 // timed connect</span>
<span class="line-removed">105                 sc.configureBlocking(false);</span>
<span class="line-removed">106                 try {</span>
<span class="line-removed">107                     if (sc.connect(remote))</span>
<span class="line-removed">108                         return;</span>
<span class="line-removed">109                 } finally {</span>
<span class="line-removed">110                     try {</span>
<span class="line-removed">111                         sc.configureBlocking(true);</span>
<span class="line-removed">112                     } catch (ClosedChannelException e) { }</span>
<span class="line-removed">113                 }</span>
<span class="line-removed">114 </span>
<span class="line-removed">115                 long timeoutNanos = NANOSECONDS.convert(timeout, MILLISECONDS);</span>
<span class="line-removed">116                 long to = timeout;</span>
<span class="line-removed">117                 for (;;) {</span>
<span class="line-removed">118                     long startTime = System.nanoTime();</span>
<span class="line-removed">119                     if (sc.pollConnected(to)) {</span>
<span class="line-removed">120                         boolean connected = sc.finishConnect();</span>
<span class="line-removed">121                         assert connected;</span>
<span class="line-removed">122                         break;</span>
<span class="line-removed">123                     }</span>
<span class="line-removed">124                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">125                     if (timeoutNanos &lt;= 0) {</span>
<span class="line-removed">126                         try {</span>
<span class="line-removed">127                             sc.close();</span>
<span class="line-removed">128                         } catch (IOException x) { }</span>
<span class="line-removed">129                         throw new SocketTimeoutException();</span>
<span class="line-removed">130                     }</span>
<span class="line-removed">131                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">132                 }</span>
<span class="line-removed">133 </span>
<span class="line-removed">134             } catch (Exception x) {</span>
<span class="line-removed">135                 Net.translateException(x, true);</span>
136             }
<a name="13" id="anc13"></a>

137         }
<a name="14" id="anc14"></a><span class="line-removed">138 </span>
139     }
140 
<a name="15" id="anc15"></a>
141     public void bind(SocketAddress local) throws IOException {
142         try {
143             sc.bind(local);
144         } catch (Exception x) {
145             Net.translateException(x);
146         }
147     }
148 
<a name="16" id="anc16"></a>
149     public InetAddress getInetAddress() {
150         InetSocketAddress remote = sc.remoteAddress();
151         if (remote == null) {
152             return null;
153         } else {
154             return remote.getAddress();
155         }
156     }
157 
<a name="17" id="anc17"></a>
158     public InetAddress getLocalAddress() {
159         if (sc.isOpen()) {
160             InetSocketAddress local = sc.localAddress();
161             if (local != null) {
162                 return Net.getRevealedLocalAddress(local).getAddress();
163             }
164         }
165         return new InetSocketAddress(0).getAddress();
166     }
167 
<a name="18" id="anc18"></a>
168     public int getPort() {
169         InetSocketAddress remote = sc.remoteAddress();
170         if (remote == null) {
171             return 0;
172         } else {
173             return remote.getPort();
174         }
175     }
176 
<a name="19" id="anc19"></a>
177     public int getLocalPort() {
178         InetSocketAddress local = sc.localAddress();
179         if (local == null) {
180             return -1;
181         } else {
182             return local.getPort();
183         }
184     }
185 
<a name="20" id="anc20"></a><span class="line-modified">186     private class SocketInputStream</span>
<span class="line-modified">187         extends ChannelInputStream</span>
<span class="line-modified">188     {</span>
<span class="line-modified">189         private SocketInputStream() {</span>
<span class="line-removed">190             super(sc);</span>
<span class="line-removed">191         }</span>
192 
<a name="21" id="anc21"></a><span class="line-modified">193         protected int read(ByteBuffer bb)</span>
<span class="line-modified">194             throws IOException</span>
<span class="line-modified">195         {</span>
<span class="line-modified">196             synchronized (sc.blockingLock()) {</span>
<span class="line-modified">197                 if (!sc.isBlocking())</span>
<span class="line-modified">198                     throw new IllegalBlockingModeException();</span>
<span class="line-modified">199 </span>
<span class="line-removed">200                 // no timeout</span>
<span class="line-removed">201                 long to = SocketAdaptor.this.timeout;</span>
<span class="line-removed">202                 if (to == 0)</span>
<span class="line-removed">203                     return sc.read(bb);</span>
<span class="line-removed">204 </span>
<span class="line-removed">205                 // timed read</span>
<span class="line-removed">206                 long timeoutNanos = NANOSECONDS.convert(to, MILLISECONDS);</span>
<span class="line-removed">207                 for (;;) {</span>
<span class="line-removed">208                     long startTime = System.nanoTime();</span>
<span class="line-removed">209                     if (sc.pollRead(to)) {</span>
<span class="line-removed">210                         return sc.read(bb);</span>
<span class="line-removed">211                     }</span>
<span class="line-removed">212                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">213                     if (timeoutNanos &lt;= 0)</span>
<span class="line-removed">214                         throw new SocketTimeoutException();</span>
<span class="line-removed">215                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">216                 }</span>
<span class="line-removed">217             }</span>
218         }
219     }
220 
<a name="22" id="anc22"></a><span class="line-modified">221     private InputStream socketInputStream = null;</span>



222 
<a name="23" id="anc23"></a>
223     public InputStream getInputStream() throws IOException {
224         if (!sc.isOpen())
225             throw new SocketException(&quot;Socket is closed&quot;);
226         if (!sc.isConnected())
227             throw new SocketException(&quot;Socket is not connected&quot;);
228         if (!sc.isInputOpen())
229             throw new SocketException(&quot;Socket input is shutdown&quot;);
<a name="24" id="anc24"></a><span class="line-modified">230         if (socketInputStream == null) {</span>
<span class="line-modified">231             try {</span>
<span class="line-modified">232                 socketInputStream = AccessController.doPrivileged(</span>
<span class="line-modified">233                     new PrivilegedExceptionAction&lt;InputStream&gt;() {</span>
<span class="line-modified">234                         public InputStream run() throws IOException {</span>
<span class="line-modified">235                             return new SocketInputStream();</span>
<span class="line-removed">236                         }</span>
<span class="line-removed">237                     });</span>
<span class="line-removed">238             } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed">239                 throw (IOException)e.getException();</span>
240             }
<a name="25" id="anc25"></a><span class="line-modified">241         }</span>
<span class="line-modified">242         return socketInputStream;</span>

















243     }
244 
<a name="26" id="anc26"></a>
245     public OutputStream getOutputStream() throws IOException {
246         if (!sc.isOpen())
247             throw new SocketException(&quot;Socket is closed&quot;);
248         if (!sc.isConnected())
249             throw new SocketException(&quot;Socket is not connected&quot;);
250         if (!sc.isOutputOpen())
251             throw new SocketException(&quot;Socket output is shutdown&quot;);
<a name="27" id="anc27"></a><span class="line-modified">252         OutputStream os = null;</span>
<span class="line-modified">253         try {</span>
<span class="line-modified">254             os = AccessController.doPrivileged(</span>
<span class="line-modified">255                 new PrivilegedExceptionAction&lt;OutputStream&gt;() {</span>
<span class="line-modified">256                     public OutputStream run() throws IOException {</span>
<span class="line-modified">257                         return Channels.newOutputStream(sc);</span>
<span class="line-modified">258                     }</span>
<span class="line-modified">259                 });</span>
<span class="line-modified">260         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified">261             throw (IOException)e.getException();</span>
<span class="line-modified">262         }</span>
<span class="line-modified">263         return os;</span>



264     }
265 
266     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
267         throws SocketException
268     {
269         try {
270             sc.setOption(name, value);
271         } catch (IOException x) {
272             Net.translateToSocketException(x);
273         }
274     }
275 
276     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
277         throws SocketException
278     {
279         try {
280             sc.setOption(name, value);
281         } catch (IOException x) {
282             Net.translateToSocketException(x);
283         }
284     }
285 
286     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
287         try {
288             return sc.getOption(name).booleanValue();
289         } catch (IOException x) {
290             Net.translateToSocketException(x);
291             return false;       // keep compiler happy
292         }
293     }
294 
295     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
296         try {
297             return sc.getOption(name).intValue();
298         } catch (IOException x) {
299             Net.translateToSocketException(x);
300             return -1;          // keep compiler happy
301         }
302     }
303 
<a name="28" id="anc28"></a>
304     public void setTcpNoDelay(boolean on) throws SocketException {
305         setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
306     }
307 
<a name="29" id="anc29"></a>
308     public boolean getTcpNoDelay() throws SocketException {
309         return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
310     }
311 
<a name="30" id="anc30"></a>
312     public void setSoLinger(boolean on, int linger) throws SocketException {
313         if (!on)
314             linger = -1;
315         setIntOption(StandardSocketOptions.SO_LINGER, linger);
316     }
317 
<a name="31" id="anc31"></a>
318     public int getSoLinger() throws SocketException {
319         return getIntOption(StandardSocketOptions.SO_LINGER);
320     }
321 
<a name="32" id="anc32"></a>
322     public void sendUrgentData(int data) throws IOException {
323         int n = sc.sendOutOfBandData((byte) data);
324         if (n == 0)
325             throw new IOException(&quot;Socket buffer full&quot;);
326     }
327 
<a name="33" id="anc33"></a>
328     public void setOOBInline(boolean on) throws SocketException {
329         setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
330     }
331 
<a name="34" id="anc34"></a>
332     public boolean getOOBInline() throws SocketException {
333         return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
334     }
335 
<a name="35" id="anc35"></a>
336     public void setSoTimeout(int timeout) throws SocketException {
<a name="36" id="anc36"></a>

337         if (timeout &lt; 0)
<a name="37" id="anc37"></a><span class="line-modified">338             throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);</span>
339         this.timeout = timeout;
340     }
341 
<a name="38" id="anc38"></a>
342     public int getSoTimeout() throws SocketException {
<a name="39" id="anc39"></a>

343         return timeout;
344     }
345 
<a name="40" id="anc40"></a>
346     public void setSendBufferSize(int size) throws SocketException {
347         // size 0 valid for SocketChannel, invalid for Socket
348         if (size &lt;= 0)
349             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
350         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
351     }
352 
<a name="41" id="anc41"></a>
353     public int getSendBufferSize() throws SocketException {
354         return getIntOption(StandardSocketOptions.SO_SNDBUF);
355     }
356 
<a name="42" id="anc42"></a>
357     public void setReceiveBufferSize(int size) throws SocketException {
358         // size 0 valid for SocketChannel, invalid for Socket
359         if (size &lt;= 0)
360             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
361         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
362     }
363 
<a name="43" id="anc43"></a>
364     public int getReceiveBufferSize() throws SocketException {
365         return getIntOption(StandardSocketOptions.SO_RCVBUF);
366     }
367 
<a name="44" id="anc44"></a>
368     public void setKeepAlive(boolean on) throws SocketException {
369         setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
370     }
371 
<a name="45" id="anc45"></a>
372     public boolean getKeepAlive() throws SocketException {
373         return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
374     }
375 
<a name="46" id="anc46"></a>
376     public void setTrafficClass(int tc) throws SocketException {
377         setIntOption(StandardSocketOptions.IP_TOS, tc);
378     }
379 
<a name="47" id="anc47"></a>
380     public int getTrafficClass() throws SocketException {
381         return getIntOption(StandardSocketOptions.IP_TOS);
382     }
383 
<a name="48" id="anc48"></a>
384     public void setReuseAddress(boolean on) throws SocketException {
385         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
386     }
387 
<a name="49" id="anc49"></a>
388     public boolean getReuseAddress() throws SocketException {
389         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
390     }
391 
<a name="50" id="anc50"></a>
392     public void close() throws IOException {
393         sc.close();
394     }
395 
<a name="51" id="anc51"></a>
396     public void shutdownInput() throws IOException {
397         try {
398             sc.shutdownInput();
399         } catch (Exception x) {
400             Net.translateException(x);
401         }
402     }
403 
<a name="52" id="anc52"></a>
404     public void shutdownOutput() throws IOException {
405         try {
406             sc.shutdownOutput();
407         } catch (Exception x) {
408             Net.translateException(x);
409         }
410     }
411 
<a name="53" id="anc53"></a>
412     public String toString() {
413         if (sc.isConnected())
414             return &quot;Socket[addr=&quot; + getInetAddress() +
415                 &quot;,port=&quot; + getPort() +
416                 &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
417         return &quot;Socket[unconnected]&quot;;
418     }
419 
<a name="54" id="anc54"></a>
420     public boolean isConnected() {
421         return sc.isConnected();
422     }
423 
<a name="55" id="anc55"></a>
424     public boolean isBound() {
425         return sc.localAddress() != null;
426     }
427 
<a name="56" id="anc56"></a>
428     public boolean isClosed() {
429         return !sc.isOpen();
430     }
431 
<a name="57" id="anc57"></a>
432     public boolean isInputShutdown() {
433         return !sc.isInputOpen();
434     }
435 
<a name="58" id="anc58"></a>
436     public boolean isOutputShutdown() {
437         return !sc.isOutputOpen();
438     }
<a name="59" id="anc59"></a>















439 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
diff a/src/java.base/share/classes/sun/nio/ch/ServerSocketAdaptor.java b/src/java.base/share/classes/sun/nio/ch/ServerSocketAdaptor.java
--- a/src/java.base/share/classes/sun/nio/ch/ServerSocketAdaptor.java
+++ b/src/java.base/share/classes/sun/nio/ch/ServerSocketAdaptor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,16 +30,21 @@
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.SocketException;
-import java.net.SocketTimeoutException;
+import java.net.SocketOption;
 import java.net.StandardSocketOptions;
 import java.nio.channels.IllegalBlockingModeException;
-import java.nio.channels.NotYetBoundException;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.Set;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 
 // Make a server-socket channel look like a server socket.
 //
 // The methods in this class are defined in exactly the same order as in
@@ -54,138 +59,146 @@
     private final ServerSocketChannelImpl ssc;
 
     // Timeout "option" value for accepts
     private volatile int timeout;
 
-    public static ServerSocket create(ServerSocketChannelImpl ssc) {
+    static ServerSocket create(ServerSocketChannelImpl ssc) {
+        PrivilegedExceptionAction<ServerSocket> pa = () -> new ServerSocketAdaptor(ssc);
         try {
-            return new ServerSocketAdaptor(ssc);
-        } catch (IOException x) {
-            throw new Error(x);
+            return AccessController.doPrivileged(pa);
+        } catch (PrivilegedActionException pae) {
+            throw new InternalError("Should not reach here", pae);
         }
     }
 
-    // ## super will create a useless impl
-    private ServerSocketAdaptor(ServerSocketChannelImpl ssc) throws IOException {
+    private ServerSocketAdaptor(ServerSocketChannelImpl ssc) {
+        super(DummySocketImpl.create());
         this.ssc = ssc;
     }
 
+    @Override
     public void bind(SocketAddress local) throws IOException {
         bind(local, 50);
     }
 
+    @Override
     public void bind(SocketAddress local, int backlog) throws IOException {
         if (local == null)
             local = new InetSocketAddress(0);
         try {
             ssc.bind(local, backlog);
         } catch (Exception x) {
             Net.translateException(x);
         }
     }
 
+    @Override
     public InetAddress getInetAddress() {
         InetSocketAddress local = ssc.localAddress();
         if (local == null) {
             return null;
         } else {
             return Net.getRevealedLocalAddress(local).getAddress();
         }
     }
 
+    @Override
     public int getLocalPort() {
         InetSocketAddress local = ssc.localAddress();
         if (local == null) {
             return -1;
         } else {
             return local.getPort();
         }
     }
 
+    @Override
     public Socket accept() throws IOException {
-        synchronized (ssc.blockingLock()) {
-            try {
-                if (!ssc.isBound())
-                    throw new NotYetBoundException();
-
-                long to = this.timeout;
-                if (to == 0) {
-                    // for compatibility reasons: accept connection if available
-                    // when configured non-blocking
-                    SocketChannel sc = ssc.accept();
-                    if (sc == null && !ssc.isBlocking())
-                        throw new IllegalBlockingModeException();
-                    return sc.socket();
-                }
-
-                if (!ssc.isBlocking())
+        SocketChannel sc = null;
+        try {
+            int timeout = this.timeout;
+            if (timeout > 0) {
+                long nanos = MILLISECONDS.toNanos(timeout);
+                sc = ssc.blockingAccept(nanos);
+            } else {
+                // accept connection if possible when non-blocking (to preserve
+                // long standing behavior)
+                sc = ssc.accept();
+                if (sc == null) {
                     throw new IllegalBlockingModeException();
-                for (;;) {
-                    long st = System.currentTimeMillis();
-                    if (ssc.pollAccept(to))
-                        return ssc.accept().socket();
-                    to -= System.currentTimeMillis() - st;
-                    if (to <= 0)
-                        throw new SocketTimeoutException();
                 }
-
-            } catch (Exception x) {
-                Net.translateException(x);
-                assert false;
-                return null;            // Never happens
             }
+        } catch (Exception e) {
+            Net.translateException(e);
         }
+        return sc.socket();
     }
 
+    @Override
     public void close() throws IOException {
         ssc.close();
     }
 
+    @Override
     public ServerSocketChannel getChannel() {
         return ssc;
     }
 
+    @Override
     public boolean isBound() {
         return ssc.isBound();
     }
 
+    @Override
     public boolean isClosed() {
         return !ssc.isOpen();
     }
 
+    @Override
     public void setSoTimeout(int timeout) throws SocketException {
+        if (!ssc.isOpen())
+            throw new SocketException("Socket is closed");
+        if (timeout < 0)
+            throw new IllegalArgumentException("timeout < 0");
         this.timeout = timeout;
     }
 
+    @Override
     public int getSoTimeout() throws SocketException {
+        if (!ssc.isOpen())
+            throw new SocketException("Socket is closed");
         return timeout;
     }
 
+    @Override
     public void setReuseAddress(boolean on) throws SocketException {
         try {
             ssc.setOption(StandardSocketOptions.SO_REUSEADDR, on);
         } catch (IOException x) {
             Net.translateToSocketException(x);
         }
     }
 
+    @Override
     public boolean getReuseAddress() throws SocketException {
         try {
             return ssc.getOption(StandardSocketOptions.SO_REUSEADDR).booleanValue();
         } catch (IOException x) {
             Net.translateToSocketException(x);
             return false;       // Never happens
         }
     }
 
+    @Override
     public String toString() {
         if (!isBound())
             return "ServerSocket[unbound]";
         return "ServerSocket[addr=" + getInetAddress() +
                ",localport=" + getLocalPort()  + "]";
     }
 
+    @Override
     public void setReceiveBufferSize(int size) throws SocketException {
         // size 0 valid for ServerSocketChannel, invalid for ServerSocket
         if (size <= 0)
             throw new IllegalArgumentException("size cannot be 0 or negative");
         try {
@@ -193,14 +206,31 @@
         } catch (IOException x) {
             Net.translateToSocketException(x);
         }
     }
 
+    @Override
     public int getReceiveBufferSize() throws SocketException {
         try {
             return ssc.getOption(StandardSocketOptions.SO_RCVBUF).intValue();
         } catch (IOException x) {
             Net.translateToSocketException(x);
             return -1;          // Never happens
         }
     }
+
+    @Override
+    public <T> ServerSocket setOption(SocketOption<T> name, T value) throws IOException {
+        ssc.setOption(name, value);
+        return this;
+    }
+
+    @Override
+    public <T> T getOption(SocketOption<T> name) throws IOException {
+        return ssc.getOption(name);
+    }
+
+    @Override
+    public Set<SocketOption<?>> supportedOptions() {
+        return ssc.supportedOptions();
+    }
 }

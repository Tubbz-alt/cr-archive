<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertificateVerify.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertificateStatus.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CipherSuite.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertificateVerify.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.*;
  31 import java.text.MessageFormat;
  32 import java.util.Arrays;
  33 import java.util.Locale;

  34 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  35 import sun.security.ssl.X509Authentication.X509Credentials;
  36 import sun.security.ssl.X509Authentication.X509Possession;
  37 import sun.security.util.HexDumpEncoder;
  38 
  39 /**
  40  * Pack of the CertificateVerify handshake message.
  41  */
  42 final class CertificateVerify {
  43     static final SSLConsumer s30HandshakeConsumer =
  44         new S30CertificateVerifyConsumer();
  45     static final HandshakeProducer s30HandshakeProducer =
  46         new S30CertificateVerifyProducer();
  47 
  48     static final SSLConsumer t10HandshakeConsumer =
  49         new T10CertificateVerifyConsumer();
  50     static final HandshakeProducer t10HandshakeProducer =
  51         new T10CertificateVerifyProducer();
  52 
  53     static final SSLConsumer t12HandshakeConsumer =
</pre>
<hr />
<pre>
 269             // The handshake message has been delivered.
 270             return null;
 271         }
 272     }
 273 
 274     /**
 275      * The &quot;CertificateVerify&quot; handshake message consumer.
 276      */
 277     private static final
 278             class S30CertificateVerifyConsumer implements SSLConsumer {
 279         // Prevent instantiation of this class.
 280         private S30CertificateVerifyConsumer() {
 281             // blank
 282         }
 283 
 284         @Override
 285         public void consume(ConnectionContext context,
 286                 ByteBuffer message) throws IOException {
 287             // The consuming happens in server side only.
 288             ServerHandshakeContext shc = (ServerHandshakeContext)context;











 289             S30CertificateVerifyMessage cvm =
 290                     new S30CertificateVerifyMessage(shc, message);
 291             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 292                 SSLLogger.fine(
 293                     &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 294             }
 295 
 296             //
 297             // update
 298             //
 299             // Need no additional validation.
 300 
 301             //
 302             // produce
 303             //
 304             // Need no new handshake message producers here.
 305         }
 306     }
 307 
 308     /**
</pre>
<hr />
<pre>
 511             // The handshake message has been delivered.
 512             return null;
 513         }
 514     }
 515 
 516     /**
 517      * The &quot;CertificateVerify&quot; handshake message consumer.
 518      */
 519     private static final
 520             class T10CertificateVerifyConsumer implements SSLConsumer {
 521         // Prevent instantiation of this class.
 522         private T10CertificateVerifyConsumer() {
 523             // blank
 524         }
 525 
 526         @Override
 527         public void consume(ConnectionContext context,
 528                 ByteBuffer message) throws IOException {
 529             // The consuming happens in server side only.
 530             ServerHandshakeContext shc = (ServerHandshakeContext)context;











 531             T10CertificateVerifyMessage cvm =
 532                     new T10CertificateVerifyMessage(shc, message);
 533             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 534                 SSLLogger.fine(
 535                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 536             }
 537 
 538             //
 539             // update
 540             //
 541             // Need no additional validation.
 542 
 543             //
 544             // produce
 545             //
 546             // Need no new handshake message producers here.        }
 547         }
 548     }
 549 
 550     /**
 551      * The CertificateVerify handshake message (TLS 1.2).
 552      */
 553     static final class T12CertificateVerifyMessage extends HandshakeMessage {
 554         // the signature algorithm
 555         private final SignatureScheme signatureScheme;
 556 
 557         // signature bytes
 558         private final byte[] signature;
 559 
 560         T12CertificateVerifyMessage(HandshakeContext context,
 561                 X509Possession x509Possession) throws IOException {
 562             super(context);
 563 
 564             // This happens in client side only.
 565             ClientHandshakeContext chc = (ClientHandshakeContext)context;
<span class="line-modified"> 566             this.signatureScheme = SignatureScheme.getPreferableAlgorithm(</span>


 567                     chc.peerRequestedSignatureSchemes,
<span class="line-modified"> 568                     x509Possession.popPrivateKey,</span>
 569                     chc.negotiatedProtocol);
<span class="line-modified"> 570             if (signatureScheme == null) {</span>
 571                 // Unlikely, the credentials generator should have
 572                 // selected the preferable signature algorithm properly.
 573                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified"> 574                     &quot;No preferred signature algorithm for CertificateVerify&quot;);</span>


 575             }
 576 

 577             byte[] temproary = null;
 578             try {
<span class="line-modified"> 579                 Signature signer =</span>
<span class="line-removed"> 580                     signatureScheme.getSignature(x509Possession.popPrivateKey);</span>
 581                 signer.update(chc.handshakeHash.archived());
 582                 temproary = signer.sign();
<span class="line-modified"> 583             } catch (NoSuchAlgorithmException |</span>
<span class="line-removed"> 584                     InvalidAlgorithmParameterException nsae) {</span>
<span class="line-removed"> 585                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-removed"> 586                         &quot;Unsupported signature algorithm (&quot; +</span>
<span class="line-removed"> 587                         signatureScheme.name +</span>
<span class="line-removed"> 588                         &quot;) used in CertificateVerify handshake message&quot;, nsae);</span>
<span class="line-removed"> 589             } catch (InvalidKeyException | SignatureException ikse) {</span>
 590                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 591                         &quot;Cannot produce CertificateVerify signature&quot;, ikse);
 592             }
 593 
 594             this.signature = temproary;
 595         }
 596 
 597         T12CertificateVerifyMessage(HandshakeContext handshakeContext,
 598                 ByteBuffer m) throws IOException {
 599             super(handshakeContext);
 600 
 601             // This happens in server side only.
 602             ServerHandshakeContext shc =
 603                     (ServerHandshakeContext)handshakeContext;
 604 
 605             // struct {
 606             //     SignatureAndHashAlgorithm algorithm;
 607             //     opaque signature&lt;0..2^16-1&gt;;
 608             // } DigitallySigned;
 609             if (m.remaining() &lt; 4) {
</pre>
<hr />
<pre>
 629 
 630             // read and verify the signature
 631             X509Credentials x509Credentials = null;
 632             for (SSLCredentials cd : shc.handshakeCredentials) {
 633                 if (cd instanceof X509Credentials) {
 634                     x509Credentials = (X509Credentials)cd;
 635                     break;
 636                 }
 637             }
 638 
 639             if (x509Credentials == null ||
 640                     x509Credentials.popPublicKey == null) {
 641                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 642                     &quot;No X509 credentials negotiated for CertificateVerify&quot;);
 643             }
 644 
 645             // opaque signature&lt;0..2^16-1&gt;;
 646             this.signature = Record.getBytes16(m);
 647             try {
 648                 Signature signer =
<span class="line-modified"> 649                     signatureScheme.getSignature(x509Credentials.popPublicKey);</span>
 650                 signer.update(shc.handshakeHash.archived());
 651                 if (!signer.verify(signature)) {
 652                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 653                         &quot;Invalid CertificateVerify signature&quot;);
 654                 }
 655             } catch (NoSuchAlgorithmException |
 656                     InvalidAlgorithmParameterException nsae) {
 657                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 658                         &quot;Unsupported signature algorithm (&quot; +
 659                         signatureScheme.name +
 660                         &quot;) used in CertificateVerify handshake message&quot;, nsae);
 661             } catch (InvalidKeyException | SignatureException ikse) {
 662                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 663                         &quot;Cannot verify CertificateVerify signature&quot;, ikse);
 664             }
 665         }
 666 
 667         @Override
 668         public SSLHandshake handshakeType() {
 669             return SSLHandshake.CERTIFICATE_VERIFY;
</pre>
<hr />
<pre>
 751             // The handshake message has been delivered.
 752             return null;
 753         }
 754     }
 755 
 756     /**
 757      * The &quot;CertificateVerify&quot; handshake message consumer.
 758      */
 759     private static final
 760             class T12CertificateVerifyConsumer implements SSLConsumer {
 761         // Prevent instantiation of this class.
 762         private T12CertificateVerifyConsumer() {
 763             // blank
 764         }
 765 
 766         @Override
 767         public void consume(ConnectionContext context,
 768                 ByteBuffer message) throws IOException {
 769             // The consuming happens in server side only.
 770             ServerHandshakeContext shc = (ServerHandshakeContext)context;











 771             T12CertificateVerifyMessage cvm =
 772                     new T12CertificateVerifyMessage(shc, message);
 773             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 774                 SSLLogger.fine(
 775                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 776             }
 777 
 778             //
 779             // update
 780             //
 781             // Need no additional validation.
 782 
 783             //
 784             // produce
 785             //
 786             // Need no new handshake message producers here.
 787         }
 788     }
 789 
 790     /**
</pre>
<hr />
<pre>
 847             (byte)0x20, (byte)0x63, (byte)0x6c, (byte)0x69,
 848             (byte)0x65, (byte)0x6e, (byte)0x74, (byte)0x20,
 849             (byte)0x43, (byte)0x65, (byte)0x72, (byte)0x74,
 850             (byte)0x69, (byte)0x66, (byte)0x69, (byte)0x63,
 851             (byte)0x61, (byte)0x74, (byte)0x65, (byte)0x56,
 852             (byte)0x65, (byte)0x72, (byte)0x69, (byte)0x66,
 853             (byte)0x79, (byte)0x00
 854         };
 855 
 856 
 857         // the signature algorithm
 858         private final SignatureScheme signatureScheme;
 859 
 860         // signature bytes
 861         private final byte[] signature;
 862 
 863         T13CertificateVerifyMessage(HandshakeContext context,
 864                 X509Possession x509Possession) throws IOException {
 865             super(context);
 866 
<span class="line-modified"> 867             this.signatureScheme = SignatureScheme.getPreferableAlgorithm(</span>


 868                     context.peerRequestedSignatureSchemes,
<span class="line-modified"> 869                     x509Possession.popPrivateKey,</span>
 870                     context.negotiatedProtocol);
<span class="line-modified"> 871             if (signatureScheme == null) {</span>
 872                 // Unlikely, the credentials generator should have
 873                 // selected the preferable signature algorithm properly.
 874                 throw context.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified"> 875                     &quot;No preferred signature algorithm for CertificateVerify&quot;);</span>


 876             }
 877 


 878             byte[] hashValue = context.handshakeHash.digest();
 879             byte[] contentCovered;
 880             if (context.sslConfig.isClientMode) {
 881                 contentCovered = Arrays.copyOf(clientSignHead,
 882                         clientSignHead.length + hashValue.length);
 883                 System.arraycopy(hashValue, 0, contentCovered,
 884                         clientSignHead.length, hashValue.length);
 885             } else {
 886                 contentCovered = Arrays.copyOf(serverSignHead,
 887                         serverSignHead.length + hashValue.length);
 888                 System.arraycopy(hashValue, 0, contentCovered,
 889                         serverSignHead.length, hashValue.length);
 890             }
 891 
 892             byte[] temproary = null;
 893             try {
<span class="line-modified"> 894                 Signature signer =</span>
<span class="line-removed"> 895                     signatureScheme.getSignature(x509Possession.popPrivateKey);</span>
 896                 signer.update(contentCovered);
 897                 temproary = signer.sign();
<span class="line-modified"> 898             } catch (NoSuchAlgorithmException |</span>
<span class="line-removed"> 899                     InvalidAlgorithmParameterException nsae) {</span>
<span class="line-removed"> 900                 throw context.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-removed"> 901                         &quot;Unsupported signature algorithm (&quot; +</span>
<span class="line-removed"> 902                         signatureScheme.name +</span>
<span class="line-removed"> 903                         &quot;) used in CertificateVerify handshake message&quot;, nsae);</span>
<span class="line-removed"> 904             } catch (InvalidKeyException | SignatureException ikse) {</span>
 905                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 906                         &quot;Cannot produce CertificateVerify signature&quot;, ikse);
 907             }
 908 
 909             this.signature = temproary;
 910         }
 911 
 912         T13CertificateVerifyMessage(HandshakeContext context,
 913                 ByteBuffer m) throws IOException {
 914              super(context);
 915 
 916             // struct {
 917             //     SignatureAndHashAlgorithm algorithm;
 918             //     opaque signature&lt;0..2^16-1&gt;;
 919             // } DigitallySigned;
 920             if (m.remaining() &lt; 4) {
 921                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 922                     &quot;Invalid CertificateVerify message: no sufficient data&quot;);
 923             }
 924 
</pre>
<hr />
<pre>
 955 
 956             // opaque signature&lt;0..2^16-1&gt;;
 957             this.signature = Record.getBytes16(m);
 958 
 959             byte[] hashValue = context.handshakeHash.digest();
 960             byte[] contentCovered;
 961             if (context.sslConfig.isClientMode) {
 962                 contentCovered = Arrays.copyOf(serverSignHead,
 963                         serverSignHead.length + hashValue.length);
 964                 System.arraycopy(hashValue, 0, contentCovered,
 965                         serverSignHead.length, hashValue.length);
 966             } else {
 967                 contentCovered = Arrays.copyOf(clientSignHead,
 968                         clientSignHead.length + hashValue.length);
 969                 System.arraycopy(hashValue, 0, contentCovered,
 970                         clientSignHead.length, hashValue.length);
 971             }
 972 
 973             try {
 974                 Signature signer =
<span class="line-modified"> 975                     signatureScheme.getSignature(x509Credentials.popPublicKey);</span>
 976                 signer.update(contentCovered);
 977                 if (!signer.verify(signature)) {
 978                     throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 979                         &quot;Invalid CertificateVerify signature&quot;);
 980                 }
 981             } catch (NoSuchAlgorithmException |
 982                     InvalidAlgorithmParameterException nsae) {
 983                 throw context.conContext.fatal(Alert.INTERNAL_ERROR,
 984                         &quot;Unsupported signature algorithm (&quot; +
 985                         signatureScheme.name +
 986                         &quot;) used in CertificateVerify handshake message&quot;, nsae);
 987             } catch (InvalidKeyException | SignatureException ikse) {
 988                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 989                         &quot;Cannot verify CertificateVerify signature&quot;, ikse);
 990             }
 991         }
 992 
 993         @Override
 994         public SSLHandshake handshakeType() {
 995             return SSLHandshake.CERTIFICATE_VERIFY;
</pre>
<hr />
<pre>
1105             // The handshake message has been delivered.
1106             return null;
1107         }
1108     }
1109 
1110     /**
1111      * The &quot;CertificateVerify&quot; handshake message consumer.
1112      */
1113     private static final
1114             class T13CertificateVerifyConsumer implements SSLConsumer {
1115         // Prevent instantiation of this class.
1116         private T13CertificateVerifyConsumer() {
1117             // blank
1118         }
1119 
1120         @Override
1121         public void consume(ConnectionContext context,
1122                 ByteBuffer message) throws IOException {
1123             // The producing happens in handshake context only.
1124             HandshakeContext hc = (HandshakeContext)context;




1125             T13CertificateVerifyMessage cvm =
1126                     new T13CertificateVerifyMessage(hc, message);
1127             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1128                 SSLLogger.fine(
1129                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
1130             }
1131 
1132             //
1133             // update
1134             //
1135             // Need no additional validation.
1136 
1137             //
1138             // produce
1139             //
1140             // Need no new handshake message producers here.
1141         }
1142     }
1143 }
</pre>
</td>
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.*;
  31 import java.text.MessageFormat;
  32 import java.util.Arrays;
  33 import java.util.Locale;
<span class="line-added">  34 import java.util.Map;</span>
  35 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  36 import sun.security.ssl.X509Authentication.X509Credentials;
  37 import sun.security.ssl.X509Authentication.X509Possession;
  38 import sun.security.util.HexDumpEncoder;
  39 
  40 /**
  41  * Pack of the CertificateVerify handshake message.
  42  */
  43 final class CertificateVerify {
  44     static final SSLConsumer s30HandshakeConsumer =
  45         new S30CertificateVerifyConsumer();
  46     static final HandshakeProducer s30HandshakeProducer =
  47         new S30CertificateVerifyProducer();
  48 
  49     static final SSLConsumer t10HandshakeConsumer =
  50         new T10CertificateVerifyConsumer();
  51     static final HandshakeProducer t10HandshakeProducer =
  52         new T10CertificateVerifyProducer();
  53 
  54     static final SSLConsumer t12HandshakeConsumer =
</pre>
<hr />
<pre>
 270             // The handshake message has been delivered.
 271             return null;
 272         }
 273     }
 274 
 275     /**
 276      * The &quot;CertificateVerify&quot; handshake message consumer.
 277      */
 278     private static final
 279             class S30CertificateVerifyConsumer implements SSLConsumer {
 280         // Prevent instantiation of this class.
 281         private S30CertificateVerifyConsumer() {
 282             // blank
 283         }
 284 
 285         @Override
 286         public void consume(ConnectionContext context,
 287                 ByteBuffer message) throws IOException {
 288             // The consuming happens in server side only.
 289             ServerHandshakeContext shc = (ServerHandshakeContext)context;
<span class="line-added"> 290 </span>
<span class="line-added"> 291             // Clean up this consumer</span>
<span class="line-added"> 292             shc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_VERIFY.id);</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294             // Ensure that the CV message follows the CKE</span>
<span class="line-added"> 295             if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 296                     SSLHandshake.CLIENT_KEY_EXCHANGE.id)) {</span>
<span class="line-added"> 297                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 298                         &quot;Unexpected CertificateVerify handshake message&quot;);</span>
<span class="line-added"> 299             }</span>
<span class="line-added"> 300 </span>
 301             S30CertificateVerifyMessage cvm =
 302                     new S30CertificateVerifyMessage(shc, message);
 303             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 304                 SSLLogger.fine(
 305                     &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 306             }
 307 
 308             //
 309             // update
 310             //
 311             // Need no additional validation.
 312 
 313             //
 314             // produce
 315             //
 316             // Need no new handshake message producers here.
 317         }
 318     }
 319 
 320     /**
</pre>
<hr />
<pre>
 523             // The handshake message has been delivered.
 524             return null;
 525         }
 526     }
 527 
 528     /**
 529      * The &quot;CertificateVerify&quot; handshake message consumer.
 530      */
 531     private static final
 532             class T10CertificateVerifyConsumer implements SSLConsumer {
 533         // Prevent instantiation of this class.
 534         private T10CertificateVerifyConsumer() {
 535             // blank
 536         }
 537 
 538         @Override
 539         public void consume(ConnectionContext context,
 540                 ByteBuffer message) throws IOException {
 541             // The consuming happens in server side only.
 542             ServerHandshakeContext shc = (ServerHandshakeContext)context;
<span class="line-added"> 543 </span>
<span class="line-added"> 544             // Clean up this consumer</span>
<span class="line-added"> 545             shc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_VERIFY.id);</span>
<span class="line-added"> 546 </span>
<span class="line-added"> 547             // Ensure that the CV message follows the CKE</span>
<span class="line-added"> 548             if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 549                     SSLHandshake.CLIENT_KEY_EXCHANGE.id)) {</span>
<span class="line-added"> 550                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 551                         &quot;Unexpected CertificateVerify handshake message&quot;);</span>
<span class="line-added"> 552             }</span>
<span class="line-added"> 553 </span>
 554             T10CertificateVerifyMessage cvm =
 555                     new T10CertificateVerifyMessage(shc, message);
 556             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 557                 SSLLogger.fine(
 558                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 559             }
 560 
 561             //
 562             // update
 563             //
 564             // Need no additional validation.
 565 
 566             //
 567             // produce
 568             //
 569             // Need no new handshake message producers here.        }
 570         }
 571     }
 572 
 573     /**
 574      * The CertificateVerify handshake message (TLS 1.2).
 575      */
 576     static final class T12CertificateVerifyMessage extends HandshakeMessage {
 577         // the signature algorithm
 578         private final SignatureScheme signatureScheme;
 579 
 580         // signature bytes
 581         private final byte[] signature;
 582 
 583         T12CertificateVerifyMessage(HandshakeContext context,
 584                 X509Possession x509Possession) throws IOException {
 585             super(context);
 586 
 587             // This happens in client side only.
 588             ClientHandshakeContext chc = (ClientHandshakeContext)context;
<span class="line-modified"> 589             Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-added"> 590                     SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-added"> 591                     chc.algorithmConstraints,</span>
 592                     chc.peerRequestedSignatureSchemes,
<span class="line-modified"> 593                     x509Possession,</span>
 594                     chc.negotiatedProtocol);
<span class="line-modified"> 595             if (schemeAndSigner == null) {</span>
 596                 // Unlikely, the credentials generator should have
 597                 // selected the preferable signature algorithm properly.
 598                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified"> 599                     &quot;No supported CertificateVerify signature algorithm for &quot; +</span>
<span class="line-added"> 600                     x509Possession.popPrivateKey.getAlgorithm() +</span>
<span class="line-added"> 601                     &quot;  key&quot;);</span>
 602             }
 603 
<span class="line-added"> 604             this.signatureScheme = schemeAndSigner.getKey();</span>
 605             byte[] temproary = null;
 606             try {
<span class="line-modified"> 607                 Signature signer = schemeAndSigner.getValue();</span>

 608                 signer.update(chc.handshakeHash.archived());
 609                 temproary = signer.sign();
<span class="line-modified"> 610             } catch (SignatureException ikse) {</span>






 611                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 612                         &quot;Cannot produce CertificateVerify signature&quot;, ikse);
 613             }
 614 
 615             this.signature = temproary;
 616         }
 617 
 618         T12CertificateVerifyMessage(HandshakeContext handshakeContext,
 619                 ByteBuffer m) throws IOException {
 620             super(handshakeContext);
 621 
 622             // This happens in server side only.
 623             ServerHandshakeContext shc =
 624                     (ServerHandshakeContext)handshakeContext;
 625 
 626             // struct {
 627             //     SignatureAndHashAlgorithm algorithm;
 628             //     opaque signature&lt;0..2^16-1&gt;;
 629             // } DigitallySigned;
 630             if (m.remaining() &lt; 4) {
</pre>
<hr />
<pre>
 650 
 651             // read and verify the signature
 652             X509Credentials x509Credentials = null;
 653             for (SSLCredentials cd : shc.handshakeCredentials) {
 654                 if (cd instanceof X509Credentials) {
 655                     x509Credentials = (X509Credentials)cd;
 656                     break;
 657                 }
 658             }
 659 
 660             if (x509Credentials == null ||
 661                     x509Credentials.popPublicKey == null) {
 662                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 663                     &quot;No X509 credentials negotiated for CertificateVerify&quot;);
 664             }
 665 
 666             // opaque signature&lt;0..2^16-1&gt;;
 667             this.signature = Record.getBytes16(m);
 668             try {
 669                 Signature signer =
<span class="line-modified"> 670                     signatureScheme.getVerifier(x509Credentials.popPublicKey);</span>
 671                 signer.update(shc.handshakeHash.archived());
 672                 if (!signer.verify(signature)) {
 673                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 674                         &quot;Invalid CertificateVerify signature&quot;);
 675                 }
 676             } catch (NoSuchAlgorithmException |
 677                     InvalidAlgorithmParameterException nsae) {
 678                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 679                         &quot;Unsupported signature algorithm (&quot; +
 680                         signatureScheme.name +
 681                         &quot;) used in CertificateVerify handshake message&quot;, nsae);
 682             } catch (InvalidKeyException | SignatureException ikse) {
 683                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 684                         &quot;Cannot verify CertificateVerify signature&quot;, ikse);
 685             }
 686         }
 687 
 688         @Override
 689         public SSLHandshake handshakeType() {
 690             return SSLHandshake.CERTIFICATE_VERIFY;
</pre>
<hr />
<pre>
 772             // The handshake message has been delivered.
 773             return null;
 774         }
 775     }
 776 
 777     /**
 778      * The &quot;CertificateVerify&quot; handshake message consumer.
 779      */
 780     private static final
 781             class T12CertificateVerifyConsumer implements SSLConsumer {
 782         // Prevent instantiation of this class.
 783         private T12CertificateVerifyConsumer() {
 784             // blank
 785         }
 786 
 787         @Override
 788         public void consume(ConnectionContext context,
 789                 ByteBuffer message) throws IOException {
 790             // The consuming happens in server side only.
 791             ServerHandshakeContext shc = (ServerHandshakeContext)context;
<span class="line-added"> 792 </span>
<span class="line-added"> 793             // Clean up this consumer</span>
<span class="line-added"> 794             shc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_VERIFY.id);</span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796             // Ensure that the CV message follows the CKE</span>
<span class="line-added"> 797             if (shc.handshakeConsumers.containsKey(</span>
<span class="line-added"> 798                     SSLHandshake.CLIENT_KEY_EXCHANGE.id)) {</span>
<span class="line-added"> 799                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-added"> 800                         &quot;Unexpected CertificateVerify handshake message&quot;);</span>
<span class="line-added"> 801             }</span>
<span class="line-added"> 802 </span>
 803             T12CertificateVerifyMessage cvm =
 804                     new T12CertificateVerifyMessage(shc, message);
 805             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 806                 SSLLogger.fine(
 807                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
 808             }
 809 
 810             //
 811             // update
 812             //
 813             // Need no additional validation.
 814 
 815             //
 816             // produce
 817             //
 818             // Need no new handshake message producers here.
 819         }
 820     }
 821 
 822     /**
</pre>
<hr />
<pre>
 879             (byte)0x20, (byte)0x63, (byte)0x6c, (byte)0x69,
 880             (byte)0x65, (byte)0x6e, (byte)0x74, (byte)0x20,
 881             (byte)0x43, (byte)0x65, (byte)0x72, (byte)0x74,
 882             (byte)0x69, (byte)0x66, (byte)0x69, (byte)0x63,
 883             (byte)0x61, (byte)0x74, (byte)0x65, (byte)0x56,
 884             (byte)0x65, (byte)0x72, (byte)0x69, (byte)0x66,
 885             (byte)0x79, (byte)0x00
 886         };
 887 
 888 
 889         // the signature algorithm
 890         private final SignatureScheme signatureScheme;
 891 
 892         // signature bytes
 893         private final byte[] signature;
 894 
 895         T13CertificateVerifyMessage(HandshakeContext context,
 896                 X509Possession x509Possession) throws IOException {
 897             super(context);
 898 
<span class="line-modified"> 899             Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-added"> 900                     SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-added"> 901                     context.algorithmConstraints,</span>
 902                     context.peerRequestedSignatureSchemes,
<span class="line-modified"> 903                     x509Possession,</span>
 904                     context.negotiatedProtocol);
<span class="line-modified"> 905             if (schemeAndSigner == null) {</span>
 906                 // Unlikely, the credentials generator should have
 907                 // selected the preferable signature algorithm properly.
 908                 throw context.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified"> 909                     &quot;No supported CertificateVerify signature algorithm for &quot; +</span>
<span class="line-added"> 910                     x509Possession.popPrivateKey.getAlgorithm() +</span>
<span class="line-added"> 911                     &quot;  key&quot;);</span>
 912             }
 913 
<span class="line-added"> 914             this.signatureScheme = schemeAndSigner.getKey();</span>
<span class="line-added"> 915 </span>
 916             byte[] hashValue = context.handshakeHash.digest();
 917             byte[] contentCovered;
 918             if (context.sslConfig.isClientMode) {
 919                 contentCovered = Arrays.copyOf(clientSignHead,
 920                         clientSignHead.length + hashValue.length);
 921                 System.arraycopy(hashValue, 0, contentCovered,
 922                         clientSignHead.length, hashValue.length);
 923             } else {
 924                 contentCovered = Arrays.copyOf(serverSignHead,
 925                         serverSignHead.length + hashValue.length);
 926                 System.arraycopy(hashValue, 0, contentCovered,
 927                         serverSignHead.length, hashValue.length);
 928             }
 929 
 930             byte[] temproary = null;
 931             try {
<span class="line-modified"> 932                 Signature signer = schemeAndSigner.getValue();</span>

 933                 signer.update(contentCovered);
 934                 temproary = signer.sign();
<span class="line-modified"> 935             } catch (SignatureException ikse) {</span>






 936                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 937                         &quot;Cannot produce CertificateVerify signature&quot;, ikse);
 938             }
 939 
 940             this.signature = temproary;
 941         }
 942 
 943         T13CertificateVerifyMessage(HandshakeContext context,
 944                 ByteBuffer m) throws IOException {
 945              super(context);
 946 
 947             // struct {
 948             //     SignatureAndHashAlgorithm algorithm;
 949             //     opaque signature&lt;0..2^16-1&gt;;
 950             // } DigitallySigned;
 951             if (m.remaining() &lt; 4) {
 952                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 953                     &quot;Invalid CertificateVerify message: no sufficient data&quot;);
 954             }
 955 
</pre>
<hr />
<pre>
 986 
 987             // opaque signature&lt;0..2^16-1&gt;;
 988             this.signature = Record.getBytes16(m);
 989 
 990             byte[] hashValue = context.handshakeHash.digest();
 991             byte[] contentCovered;
 992             if (context.sslConfig.isClientMode) {
 993                 contentCovered = Arrays.copyOf(serverSignHead,
 994                         serverSignHead.length + hashValue.length);
 995                 System.arraycopy(hashValue, 0, contentCovered,
 996                         serverSignHead.length, hashValue.length);
 997             } else {
 998                 contentCovered = Arrays.copyOf(clientSignHead,
 999                         clientSignHead.length + hashValue.length);
1000                 System.arraycopy(hashValue, 0, contentCovered,
1001                         clientSignHead.length, hashValue.length);
1002             }
1003 
1004             try {
1005                 Signature signer =
<span class="line-modified">1006                     signatureScheme.getVerifier(x509Credentials.popPublicKey);</span>
1007                 signer.update(contentCovered);
1008                 if (!signer.verify(signature)) {
1009                     throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1010                         &quot;Invalid CertificateVerify signature&quot;);
1011                 }
1012             } catch (NoSuchAlgorithmException |
1013                     InvalidAlgorithmParameterException nsae) {
1014                 throw context.conContext.fatal(Alert.INTERNAL_ERROR,
1015                         &quot;Unsupported signature algorithm (&quot; +
1016                         signatureScheme.name +
1017                         &quot;) used in CertificateVerify handshake message&quot;, nsae);
1018             } catch (InvalidKeyException | SignatureException ikse) {
1019                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1020                         &quot;Cannot verify CertificateVerify signature&quot;, ikse);
1021             }
1022         }
1023 
1024         @Override
1025         public SSLHandshake handshakeType() {
1026             return SSLHandshake.CERTIFICATE_VERIFY;
</pre>
<hr />
<pre>
1136             // The handshake message has been delivered.
1137             return null;
1138         }
1139     }
1140 
1141     /**
1142      * The &quot;CertificateVerify&quot; handshake message consumer.
1143      */
1144     private static final
1145             class T13CertificateVerifyConsumer implements SSLConsumer {
1146         // Prevent instantiation of this class.
1147         private T13CertificateVerifyConsumer() {
1148             // blank
1149         }
1150 
1151         @Override
1152         public void consume(ConnectionContext context,
1153                 ByteBuffer message) throws IOException {
1154             // The producing happens in handshake context only.
1155             HandshakeContext hc = (HandshakeContext)context;
<span class="line-added">1156 </span>
<span class="line-added">1157             // Clean up this consumer</span>
<span class="line-added">1158             hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_VERIFY.id);</span>
<span class="line-added">1159 </span>
1160             T13CertificateVerifyMessage cvm =
1161                     new T13CertificateVerifyMessage(hc, message);
1162             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1163                 SSLLogger.fine(
1164                         &quot;Consuming CertificateVerify handshake message&quot;, cvm);
1165             }
1166 
1167             //
1168             // update
1169             //
1170             // Need no additional validation.
1171 
1172             //
1173             // produce
1174             //
1175             // Need no new handshake message producers here.
1176         }
1177     }
1178 }
</pre>
</td>
</tr>
</table>
<center><a href="CertificateStatus.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CipherSuite.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
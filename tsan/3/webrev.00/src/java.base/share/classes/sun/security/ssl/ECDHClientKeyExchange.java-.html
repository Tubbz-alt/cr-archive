<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.CryptoPrimitive;
 32 import java.security.GeneralSecurityException;
 33 import java.security.KeyFactory;
 34 import java.security.PrivateKey;
 35 import java.security.PublicKey;
 36 import java.security.interfaces.ECPrivateKey;
 37 import java.security.interfaces.ECPublicKey;
 38 import java.security.spec.ECParameterSpec;
 39 import java.security.spec.ECPoint;
 40 import java.security.spec.ECPublicKeySpec;
 41 import java.text.MessageFormat;
 42 import java.util.EnumSet;
 43 import java.util.Locale;
 44 import javax.crypto.SecretKey;
 45 import javax.net.ssl.SSLHandshakeException;
 46 import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;
 47 import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;
 48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 49 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;
 50 import sun.security.ssl.X509Authentication.X509Credentials;
 51 import sun.security.ssl.X509Authentication.X509Possession;
 52 import sun.security.util.ECUtil;
 53 import sun.security.util.HexDumpEncoder;
 54 
 55 /**
 56  * Pack of the &quot;ClientKeyExchange&quot; handshake message.
 57  */
 58 final class ECDHClientKeyExchange {
 59     static final SSLConsumer ecdhHandshakeConsumer =
 60             new ECDHClientKeyExchangeConsumer();
 61     static final HandshakeProducer ecdhHandshakeProducer =
 62             new ECDHClientKeyExchangeProducer();
 63 
 64     static final SSLConsumer ecdheHandshakeConsumer =
 65             new ECDHEClientKeyExchangeConsumer();
 66     static final HandshakeProducer ecdheHandshakeProducer =
 67             new ECDHEClientKeyExchangeProducer();
 68 
 69     /**
 70      * The ECDH/ECDHE ClientKeyExchange handshake message.
 71      */
 72     private static final
 73             class ECDHClientKeyExchangeMessage extends HandshakeMessage {
 74         private final byte[] encodedPoint;
 75 
 76         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 77                 ECPublicKey publicKey) {
 78             super(handshakeContext);
 79 
 80             ECPoint point = publicKey.getW();
 81             ECParameterSpec params = publicKey.getParams();
 82             encodedPoint = ECUtil.encodePoint(point, params.getCurve());
 83         }
 84 
 85         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 86                 ByteBuffer m) throws IOException {
 87             super(handshakeContext);
 88             if (m.remaining() != 0) {       // explicit PublicValueEncoding
 89                 this.encodedPoint = Record.getBytes8(m);
 90             } else {
 91                 this.encodedPoint = new byte[0];
 92             }
 93         }
 94 
 95         // Check constraints of the specified EC public key.
 96         static void checkConstraints(AlgorithmConstraints constraints,
 97                 ECPublicKey publicKey,
 98                 byte[] encodedPoint) throws SSLHandshakeException {
 99 
100             try {
101                 ECParameterSpec params = publicKey.getParams();
102                 ECPoint point =
103                         ECUtil.decodePoint(encodedPoint, params.getCurve());
104                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
105 
106                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
107                 ECPublicKey peerPublicKey =
108                         (ECPublicKey)kf.generatePublic(spec);
109 
110                 // check constraints of ECPublicKey
111                 if (!constraints.permits(
112                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
113                         peerPublicKey)) {
114                     throw new SSLHandshakeException(
115                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
116                 }
117             } catch (GeneralSecurityException | java.io.IOException e) {
118                 throw (SSLHandshakeException) new SSLHandshakeException(
119                         &quot;Could not generate ECPublicKey&quot;).initCause(e);
120             }
121         }
122 
123         @Override
124         public SSLHandshake handshakeType() {
125             return SSLHandshake.CLIENT_KEY_EXCHANGE;
126         }
127 
128         @Override
129         public int messageLength() {
130             if (encodedPoint == null || encodedPoint.length == 0) {
131                 return 0;
132             } else {
133                 return 1 + encodedPoint.length;
134             }
135         }
136 
137         @Override
138         public void send(HandshakeOutStream hos) throws IOException {
139             if (encodedPoint != null &amp;&amp; encodedPoint.length != 0) {
140                 hos.putBytes8(encodedPoint);
141             }
142         }
143 
144         @Override
145         public String toString() {
146             MessageFormat messageFormat = new MessageFormat(
147                 &quot;\&quot;ECDH ClientKeyExchange\&quot;: &#39;{&#39;\n&quot; +
148                 &quot;  \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
149                 &quot;{0}\n&quot; +
150                 &quot;  &#39;}&#39;,\n&quot; +
151                 &quot;&#39;}&#39;&quot;,
152                 Locale.ENGLISH);
153             if (encodedPoint == null || encodedPoint.length == 0) {
154                 Object[] messageFields = {
155                     &quot;    &lt;implicit&gt;&quot;
156                 };
157                 return messageFormat.format(messageFields);
158             } else {
159                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
160                 Object[] messageFields = {
161                     Utilities.indent(
162                             hexEncoder.encodeBuffer(encodedPoint), &quot;    &quot;),
163                 };
164                 return messageFormat.format(messageFields);
165             }
166         }
167     }
168 
169     /**
170      * The ECDH &quot;ClientKeyExchange&quot; handshake message producer.
171      */
172     private static final
173             class ECDHClientKeyExchangeProducer implements HandshakeProducer {
174         // Prevent instantiation of this class.
175         private ECDHClientKeyExchangeProducer() {
176             // blank
177         }
178 
179         @Override
180         public byte[] produce(ConnectionContext context,
181                 HandshakeMessage message) throws IOException {
182             // The producing happens in client side only.
183             ClientHandshakeContext chc = (ClientHandshakeContext)context;
184 
185             X509Credentials x509Credentials = null;
186             for (SSLCredentials credential : chc.handshakeCredentials) {
187                 if (credential instanceof X509Credentials) {
188                     x509Credentials = (X509Credentials)credential;
189                     break;
190                 }
191             }
192 
193             if (x509Credentials == null) {
194                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
195                     &quot;No server certificate for ECDH client key exchange&quot;);
196             }
197 
198             PublicKey publicKey = x509Credentials.popPublicKey;
199             if (!publicKey.getAlgorithm().equals(&quot;EC&quot;)) {
200                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
201                     &quot;Not EC server certificate for ECDH client key exchange&quot;);
202             }
203 
204             ECParameterSpec params = ((ECPublicKey)publicKey).getParams();
205             NamedGroup namedGroup = NamedGroup.valueOf(params);
206             if (namedGroup == null) {
207                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
208                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);
209             }
210 
211             ECDHEPossession ecdhePossession = new ECDHEPossession(
212                     namedGroup, chc.sslContext.getSecureRandom());
213             chc.handshakePossessions.add(ecdhePossession);
214             ECDHClientKeyExchangeMessage cke =
215                     new ECDHClientKeyExchangeMessage(
216                             chc, ecdhePossession.publicKey);
217             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
218                 SSLLogger.fine(
219                     &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
220             }
221 
222             // Output the handshake message.
223             cke.write(chc.handshakeOutput);
224             chc.handshakeOutput.flush();
225 
226             // update the states
227             SSLKeyExchange ke = SSLKeyExchange.valueOf(
228                     chc.negotiatedCipherSuite.keyExchange,
229                     chc.negotiatedProtocol);
230             if (ke == null) {
231                 // unlikely
232                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
233                         &quot;Not supported key exchange type&quot;);
234             } else {
235                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
236                 SecretKey masterSecret =
237                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
238                 chc.handshakeSession.setMasterSecret(masterSecret);
239 
240                 SSLTrafficKeyDerivation kd =
241                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
242                 if (kd == null) {
243                     // unlikely
244                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
245                             &quot;Not supported key derivation: &quot; +
246                             chc.negotiatedProtocol);
247                 } else {
248                     chc.handshakeKeyDerivation =
249                         kd.createKeyDerivation(chc, masterSecret);
250                 }
251             }
252 
253             // The handshake message has been delivered.
254             return null;
255         }
256     }
257 
258     /**
259      * The ECDH &quot;ClientKeyExchange&quot; handshake message consumer.
260      */
261     private static final
262             class ECDHClientKeyExchangeConsumer implements SSLConsumer {
263         // Prevent instantiation of this class.
264         private ECDHClientKeyExchangeConsumer() {
265             // blank
266         }
267 
268         @Override
269         public void consume(ConnectionContext context,
270                 ByteBuffer message) throws IOException {
271             // The consuming happens in server side only.
272             ServerHandshakeContext shc = (ServerHandshakeContext)context;
273 
274             X509Possession x509Possession = null;
275             for (SSLPossession possession : shc.handshakePossessions) {
276                 if (possession instanceof X509Possession) {
277                     x509Possession = (X509Possession)possession;
278                     break;
279                 }
280             }
281 
282             if (x509Possession == null) {
283                 // unlikely, have been checked during cipher suite negotiation.
284                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
285                     &quot;No expected EC server cert for ECDH client key exchange&quot;);
286             }
287 
288             PrivateKey privateKey = x509Possession.popPrivateKey;
289             if (!privateKey.getAlgorithm().equals(&quot;EC&quot;)) {
290                 // unlikely, have been checked during cipher suite negotiation.
291                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
292                     &quot;Not EC server cert for ECDH client key exchange&quot;);
293             }
294 
295             ECParameterSpec params = ((ECPrivateKey)privateKey).getParams();
296             NamedGroup namedGroup = NamedGroup.valueOf(params);
297             if (namedGroup == null) {
298                 // unlikely, have been checked during cipher suite negotiation.
299                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
300                     &quot;Unsupported EC server cert for ECDH client key exchange&quot;);
301             }
302 
303             SSLKeyExchange ke = SSLKeyExchange.valueOf(
304                     shc.negotiatedCipherSuite.keyExchange,
305                     shc.negotiatedProtocol);
306             if (ke == null) {
307                 // unlikely
308                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
309                         &quot;Not supported key exchange type&quot;);
310             }
311 
312             // parse the handshake message
313             ECDHClientKeyExchangeMessage cke =
314                     new ECDHClientKeyExchangeMessage(shc, message);
315             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
316                 SSLLogger.fine(
317                     &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
318             }
319 
320             // create the credentials
321             try {
322                 ECPoint point =
323                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());
324                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
325 
326                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
327                 ECPublicKey peerPublicKey =
328                         (ECPublicKey)kf.generatePublic(spec);
329 
330                 // check constraints of peer ECPublicKey
331                 if (!shc.algorithmConstraints.permits(
332                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
333                         peerPublicKey)) {
334                     throw new SSLHandshakeException(
335                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
336                 }
337 
338                 shc.handshakeCredentials.add(new ECDHECredentials(
339                         peerPublicKey, namedGroup));
340             } catch (GeneralSecurityException | java.io.IOException e) {
341                 throw (SSLHandshakeException)(new SSLHandshakeException(
342                         &quot;Could not generate ECPublicKey&quot;).initCause(e));
343             }
344 
345             // update the states
346             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
347             SecretKey masterSecret =
348                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
349             shc.handshakeSession.setMasterSecret(masterSecret);
350 
351             SSLTrafficKeyDerivation kd =
352                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
353             if (kd == null) {
354                 // unlikely
355                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
356                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
357             } else {
358                 shc.handshakeKeyDerivation =
359                     kd.createKeyDerivation(shc, masterSecret);
360             }
361         }
362     }
363 
364     /**
365      * The ECDHE &quot;ClientKeyExchange&quot; handshake message producer.
366      */
367     private static final
368             class ECDHEClientKeyExchangeProducer implements HandshakeProducer {
369         // Prevent instantiation of this class.
370         private ECDHEClientKeyExchangeProducer() {
371             // blank
372         }
373 
374         @Override
375         public byte[] produce(ConnectionContext context,
376                 HandshakeMessage message) throws IOException {
377             // The producing happens in client side only.
378             ClientHandshakeContext chc = (ClientHandshakeContext)context;
379 
380             ECDHECredentials ecdheCredentials = null;
381             for (SSLCredentials cd : chc.handshakeCredentials) {
382                 if (cd instanceof ECDHECredentials) {
383                     ecdheCredentials = (ECDHECredentials)cd;
384                     break;
385                 }
386             }
387 
388             if (ecdheCredentials == null) {
389                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
390                     &quot;No ECDHE credentials negotiated for client key exchange&quot;);
391             }
392 
393             ECDHEPossession ecdhePossession = new ECDHEPossession(
394                     ecdheCredentials, chc.sslContext.getSecureRandom());
395             chc.handshakePossessions.add(ecdhePossession);
396             ECDHClientKeyExchangeMessage cke =
397                     new ECDHClientKeyExchangeMessage(
398                             chc, ecdhePossession.publicKey);
399             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                 SSLLogger.fine(
401                     &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
402             }
403 
404             // Output the handshake message.
405             cke.write(chc.handshakeOutput);
406             chc.handshakeOutput.flush();
407 
408             // update the states
409             SSLKeyExchange ke = SSLKeyExchange.valueOf(
410                     chc.negotiatedCipherSuite.keyExchange,
411                     chc.negotiatedProtocol);
412             if (ke == null) {
413                 // unlikely
414                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
415                         &quot;Not supported key exchange type&quot;);
416             } else {
417                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
418                 SecretKey masterSecret =
419                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
420                 chc.handshakeSession.setMasterSecret(masterSecret);
421 
422                 SSLTrafficKeyDerivation kd =
423                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
424                 if (kd == null) {
425                     // unlikely
426                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
427                             &quot;Not supported key derivation: &quot; +
428                             chc.negotiatedProtocol);
429                 } else {
430                     chc.handshakeKeyDerivation =
431                         kd.createKeyDerivation(chc, masterSecret);
432                 }
433             }
434 
435             // The handshake message has been delivered.
436             return null;
437         }
438     }
439 
440     /**
441      * The ECDHE &quot;ClientKeyExchange&quot; handshake message consumer.
442      */
443     private static final
444             class ECDHEClientKeyExchangeConsumer implements SSLConsumer {
445         // Prevent instantiation of this class.
446         private ECDHEClientKeyExchangeConsumer() {
447             // blank
448         }
449 
450         @Override
451         public void consume(ConnectionContext context,
452                 ByteBuffer message) throws IOException {
453             // The consuming happens in server side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
456             ECDHEPossession ecdhePossession = null;
457             for (SSLPossession possession : shc.handshakePossessions) {
458                 if (possession instanceof ECDHEPossession) {
459                     ecdhePossession = (ECDHEPossession)possession;
460                     break;
461                 }
462             }
463             if (ecdhePossession == null) {
464                 // unlikely
465                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
466                     &quot;No expected ECDHE possessions for client key exchange&quot;);
467             }
468 
469             ECParameterSpec params = ecdhePossession.publicKey.getParams();
470             NamedGroup namedGroup = NamedGroup.valueOf(params);
471             if (namedGroup == null) {
472                 // unlikely, have been checked during cipher suite negotiation.
473                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
474                     &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
475             }
476 
477             SSLKeyExchange ke = SSLKeyExchange.valueOf(
478                     shc.negotiatedCipherSuite.keyExchange,
479                     shc.negotiatedProtocol);
480             if (ke == null) {
481                 // unlikely
482                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
483                         &quot;Not supported key exchange type&quot;);
484             }
485 
486             // parse the handshake message
487             ECDHClientKeyExchangeMessage cke =
488                     new ECDHClientKeyExchangeMessage(shc, message);
489             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
490                 SSLLogger.fine(
491                     &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
492             }
493 
494             // create the credentials
495             try {
496                 ECPoint point =
497                     ECUtil.decodePoint(cke.encodedPoint, params.getCurve());
498                 ECPublicKeySpec spec = new ECPublicKeySpec(point, params);
499 
500                 KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;);
501                 ECPublicKey peerPublicKey =
502                         (ECPublicKey)kf.generatePublic(spec);
503 
504                 // check constraints of peer ECPublicKey
505                 if (!shc.algorithmConstraints.permits(
506                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
507                         peerPublicKey)) {
508                     throw new SSLHandshakeException(
509                         &quot;ECPublicKey does not comply to algorithm constraints&quot;);
510                 }
511 
512                 shc.handshakeCredentials.add(new ECDHECredentials(
513                         peerPublicKey, namedGroup));
514             } catch (GeneralSecurityException | java.io.IOException e) {
515                 throw (SSLHandshakeException)(new SSLHandshakeException(
516                         &quot;Could not generate ECPublicKey&quot;).initCause(e));
517             }
518 
519             // update the states
520             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
521             SecretKey masterSecret =
522                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
523             shc.handshakeSession.setMasterSecret(masterSecret);
524 
525             SSLTrafficKeyDerivation kd =
526                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
527             if (kd == null) {
528                 // unlikely
529                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
530                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
531             } else {
532                 shc.handshakeKeyDerivation =
533                     kd.createKeyDerivation(shc, masterSecret);
534             }
535         }
536     }
537 }
    </pre>
  </body>
</html>
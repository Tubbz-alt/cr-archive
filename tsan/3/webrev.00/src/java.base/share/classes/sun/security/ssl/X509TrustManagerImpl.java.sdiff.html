<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/X509TrustManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X509KeyManagerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/X509TrustManagerImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.net.Socket;
 29 import java.security.*;
 30 import java.security.cert.*;
 31 import java.util.*;

 32 import javax.net.ssl.*;
 33 import sun.security.util.AnchorCertificates;
 34 import sun.security.util.HostnameChecker;
 35 import sun.security.validator.*;
 36 
 37 /**
 38  * This class implements the SunJSSE X.509 trust manager using the internal
 39  * validator API in J2SE core. The logic in this class is minimal.&lt;p&gt;
 40  * &lt;p&gt;
 41  * This class supports both the Simple validation algorithm from previous
 42  * JSSE versions and PKIX validation. Currently, it is not possible for the
 43  * application to specify PKIX parameters other than trust anchors. This will
 44  * be fixed in a future release using new APIs. When that happens, it may also
 45  * make sense to separate the Simple and PKIX trust managers into separate
 46  * classes.
 47  *
 48  * @author Andreas Sterbenz
 49  */
 50 final class X509TrustManagerImpl extends X509ExtendedTrustManager
 51         implements X509TrustManager {
 52 
 53     private final String validatorType;
 54 
 55     /**
 56      * The Set of trusted X509Certificates.
 57      */
 58     private final Collection&lt;X509Certificate&gt; trustedCerts;
 59 
 60     private final PKIXBuilderParameters pkixParams;
 61 
 62     // note that we need separate validator for client and server due to
 63     // the different extension checks. They are initialized lazily on demand.
 64     private volatile Validator clientValidator, serverValidator;
 65 


 66     X509TrustManagerImpl(String validatorType,
 67             Collection&lt;X509Certificate&gt; trustedCerts) {
 68 
 69         this.validatorType = validatorType;
 70         this.pkixParams = null;
 71 
 72         if (trustedCerts == null) {
 73             trustedCerts = Collections.&lt;X509Certificate&gt;emptySet();
 74         }
 75 
 76         this.trustedCerts = trustedCerts;
 77 
 78         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
 79             SSLLogger.fine(&quot;adding as trusted certificates&quot;,
 80                     (Object[])trustedCerts.toArray(new X509Certificate[0]));
 81         }
 82     }
 83 
 84     X509TrustManagerImpl(String validatorType, PKIXBuilderParameters params) {
 85         this.validatorType = validatorType;
</pre>
<hr />
<pre>
125 
126     @Override
127     public void checkServerTrusted(X509Certificate[] chain, String authType,
128             Socket socket) throws CertificateException {
129         checkTrusted(chain, authType, socket, false);
130     }
131 
132     @Override
133     public void checkClientTrusted(X509Certificate[] chain, String authType,
134             SSLEngine engine) throws CertificateException {
135         checkTrusted(chain, authType, engine, true);
136     }
137 
138     @Override
139     public void checkServerTrusted(X509Certificate[] chain, String authType,
140             SSLEngine engine) throws CertificateException {
141         checkTrusted(chain, authType, engine, false);
142     }
143 
144     private Validator checkTrustedInit(X509Certificate[] chain,
<span class="line-modified">145                                         String authType, boolean isClient) {</span>
146         if (chain == null || chain.length == 0) {
147             throw new IllegalArgumentException(
148                 &quot;null or zero-length certificate chain&quot;);
149         }
150 
151         if (authType == null || authType.isEmpty()) {
152             throw new IllegalArgumentException(
153                 &quot;null or zero-length authentication type&quot;);
154         }
155 
156         Validator v = null;
<span class="line-modified">157         if (isClient) {</span>
158             v = clientValidator;
159             if (v == null) {
<span class="line-modified">160                 synchronized (this) {</span>

161                     v = clientValidator;
162                     if (v == null) {
163                         v = getValidator(Validator.VAR_TLS_CLIENT);
164                         clientValidator = v;
165                     }


166                 }
167             }
168         } else {
169             // assume double checked locking with a volatile flag works
170             // (guaranteed under the new Tiger memory model)
171             v = serverValidator;
172             if (v == null) {
<span class="line-modified">173                 synchronized (this) {</span>

174                     v = serverValidator;
175                     if (v == null) {
176                         v = getValidator(Validator.VAR_TLS_SERVER);
177                         serverValidator = v;
178                     }


179                 }
180             }
181         }
182 
183         return v;
184     }
185 
<span class="line-modified">186     private void checkTrusted(X509Certificate[] chain, String authType,</span>
<span class="line-modified">187                 Socket socket, boolean isClient) throws CertificateException {</span>
<span class="line-modified">188         Validator v = checkTrustedInit(chain, authType, isClient);</span>

189 
190         X509Certificate[] trustedChain = null;
191         if ((socket != null) &amp;&amp; socket.isConnected() &amp;&amp;
192                                         (socket instanceof SSLSocket)) {
193 
194             SSLSocket sslSocket = (SSLSocket)socket;
195             SSLSession session = sslSocket.getHandshakeSession();
196             if (session == null) {
197                 throw new CertificateException(&quot;No handshake session&quot;);
198             }
199 
200             // create the algorithm constraints
201             boolean isExtSession = (session instanceof ExtendedSSLSession);
202             AlgorithmConstraints constraints;
203             if (isExtSession &amp;&amp;
204                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
205                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
206                 String[] localSupportedSignAlgs =
207                         extSession.getLocalSupportedSignatureAlgorithms();
208 
209                 constraints = new SSLAlgorithmConstraints(
210                                 sslSocket, localSupportedSignAlgs, false);
211             } else {
212                 constraints = new SSLAlgorithmConstraints(sslSocket, false);
213             }
214 
215             // Grab any stapled OCSP responses for use in validation
216             List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">217             if (!isClient &amp;&amp; isExtSession) {</span>
218                 responseList =
219                         ((ExtendedSSLSession)session).getStatusResponses();
220             }
221             trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">222                     constraints, isClient ? null : authType);</span>
<span class="line-removed">223 </span>
<span class="line-removed">224             // check if EE certificate chains to a public root CA (as</span>
<span class="line-removed">225             // pre-installed in cacerts)</span>
<span class="line-removed">226             boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-removed">227                     trustedChain[trustedChain.length-1]);</span>
228 
229             // check endpoint identity
230             String identityAlg = sslSocket.getSSLParameters().
231                     getEndpointIdentificationAlgorithm();
232             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">233                 checkIdentity(session, trustedChain[0], identityAlg, isClient,</span>
<span class="line-modified">234                         getRequestedServerNames(socket), chainsToPublicCA);</span>
235             }
236         } else {
237             trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">238                     null, isClient ? null : authType);</span>
239         }
240 
241         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
242             SSLLogger.fine(&quot;Found trusted certificate&quot;,
243                     trustedChain[trustedChain.length - 1]);
244         }
245     }
246 
<span class="line-modified">247     private void checkTrusted(X509Certificate[] chain, String authType,</span>
<span class="line-modified">248             SSLEngine engine, boolean isClient) throws CertificateException {</span>
<span class="line-modified">249         Validator v = checkTrustedInit(chain, authType, isClient);</span>

250 
251         X509Certificate[] trustedChain = null;
252         if (engine != null) {
253             SSLSession session = engine.getHandshakeSession();
254             if (session == null) {
255                 throw new CertificateException(&quot;No handshake session&quot;);
256             }
257 
258             // create the algorithm constraints
259             boolean isExtSession = (session instanceof ExtendedSSLSession);
260             AlgorithmConstraints constraints;
261             if (isExtSession &amp;&amp;
262                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
263                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
264                 String[] localSupportedSignAlgs =
265                         extSession.getLocalSupportedSignatureAlgorithms();
266 
267                 constraints = new SSLAlgorithmConstraints(
268                                 engine, localSupportedSignAlgs, false);
269             } else {
270                 constraints = new SSLAlgorithmConstraints(engine, false);
271             }
272 
273             // Grab any stapled OCSP responses for use in validation
274             List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">275             if (!isClient &amp;&amp; isExtSession) {</span>
276                 responseList =
277                         ((ExtendedSSLSession)session).getStatusResponses();
278             }
279             trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">280                     constraints, isClient ? null : authType);</span>
<span class="line-removed">281 </span>
<span class="line-removed">282             // check if EE certificate chains to a public root CA (as</span>
<span class="line-removed">283             // pre-installed in cacerts)</span>
<span class="line-removed">284             boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-removed">285                     trustedChain[trustedChain.length-1]);</span>
286 
287             // check endpoint identity
288             String identityAlg = engine.getSSLParameters().
289                     getEndpointIdentificationAlgorithm();
290             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">291                 checkIdentity(session, trustedChain[0], identityAlg, isClient,</span>
<span class="line-modified">292                         getRequestedServerNames(engine), chainsToPublicCA);</span>
293             }
294         } else {
295             trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">296                     null, isClient ? null : authType);</span>
297         }
298 
299         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
300             SSLLogger.fine(&quot;Found trusted certificate&quot;,
301                     trustedChain[trustedChain.length - 1]);
302         }
303     }
304 
305     private Validator getValidator(String variant) {
306         Validator v;
307         if (pkixParams == null) {
308             v = Validator.getInstance(validatorType, variant, trustedCerts);
309         } else {
310             v = Validator.getInstance(validatorType, variant, pkixParams);
311         }
312         return v;
313     }
314 
315     // Get string representation of HostName from a list of server names.
316     //
</pre>
<hr />
<pre>
334                         SSLLogger.fine(&quot;Illegal server name: &quot; + sniName);
335                     }
336                 }
337             }
338 
339             // no more than server name of the same name type
340             break;
341         }
342 
343         if (hostname != null) {
344             return hostname.getAsciiName();
345         }
346 
347         return null;
348     }
349 
350     // Also used by X509KeyManagerImpl
351     static List&lt;SNIServerName&gt; getRequestedServerNames(Socket socket) {
352         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
353                                         socket instanceof SSLSocket) {
<span class="line-modified">354 </span>
<span class="line-modified">355             SSLSocket sslSocket = (SSLSocket)socket;</span>
<span class="line-removed">356             SSLSession session = sslSocket.getHandshakeSession();</span>
<span class="line-removed">357 </span>
<span class="line-removed">358             if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-removed">359                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;</span>
<span class="line-removed">360                 return extSession.getRequestedServerNames();</span>
<span class="line-removed">361             }</span>
362         }
363 
364         return Collections.&lt;SNIServerName&gt;emptyList();
365     }
366 
367     // Also used by X509KeyManagerImpl
368     static List&lt;SNIServerName&gt; getRequestedServerNames(SSLEngine engine) {
369         if (engine != null) {
<span class="line-modified">370             SSLSession session = engine.getHandshakeSession();</span>

371 
<span class="line-modified">372             if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-modified">373                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;</span>
<span class="line-modified">374                 return extSession.getRequestedServerNames();</span>
<span class="line-modified">375             }</span>



376         }
377 
378         return Collections.&lt;SNIServerName&gt;emptyList();
379     }
380 
381     /*
382      * Per RFC 6066, if an application negotiates a server name using an
383      * application protocol and then upgrades to TLS, and if a server_name
384      * extension is sent, then the extension SHOULD contain the same name
385      * that was negotiated in the application protocol.  If the server_name
386      * is established in the TLS session handshake, the client SHOULD NOT
387      * attempt to request a different server name at the application layer.
388      *
389      * According to the above spec, we only need to check either the identity
390      * in server_name extension or the peer host of the connection.  Peer host
391      * is not always a reliable fully qualified domain name. The HostName in
392      * server_name extension is more reliable than peer host. So we prefer
393      * the identity checking aginst the server_name extension if present, and
394      * may failove to peer host checking.
395      */
<span class="line-modified">396     private static void checkIdentity(SSLSession session,</span>
<span class="line-modified">397             X509Certificate cert,</span>
398             String algorithm,
<span class="line-modified">399             boolean isClient,</span>
<span class="line-modified">400             List&lt;SNIServerName&gt; sniNames,</span>
<span class="line-modified">401             boolean chainsToPublicCA) throws CertificateException {</span>



402 
403         boolean identifiable = false;
404         String peerHost = session.getPeerHost();
<span class="line-modified">405         if (isClient) {</span>
<span class="line-modified">406             String hostname = getHostNameInSNI(sniNames);</span>
<span class="line-modified">407             if (hostname != null) {</span>

408                 try {
<span class="line-modified">409                     checkIdentity(hostname, cert, algorithm, chainsToPublicCA);</span>

410                     identifiable = true;
411                 } catch (CertificateException ce) {
<span class="line-modified">412                     if (hostname.equalsIgnoreCase(peerHost)) {</span>
413                         throw ce;
414                     }
415 
416                     // otherwisw, failover to check peer host
417                 }
418             }
419         }
420 
421         if (!identifiable) {
<span class="line-modified">422             checkIdentity(peerHost, cert, algorithm, chainsToPublicCA);</span>

423         }
424     }
425 
426     /*
427      * Identify the peer by its certificate and hostname.
428      *
429      * Lifted from sun.net.www.protocol.https.HttpsClient.
430      */
431     static void checkIdentity(String hostname, X509Certificate cert,
432             String algorithm) throws CertificateException {
433         checkIdentity(hostname, cert, algorithm, false);
434     }
435 
436     private static void checkIdentity(String hostname, X509Certificate cert,
437             String algorithm, boolean chainsToPublicCA)
438             throws CertificateException {
439         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
440             // if IPv6 strip off the &quot;[]&quot;
441             if ((hostname != null) &amp;&amp; hostname.startsWith(&quot;[&quot;) &amp;&amp;
442                     hostname.endsWith(&quot;]&quot;)) {
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.net.Socket;
 29 import java.security.*;
 30 import java.security.cert.*;
 31 import java.util.*;
<span class="line-added"> 32 import java.util.concurrent.locks.ReentrantLock;</span>
 33 import javax.net.ssl.*;
 34 import sun.security.util.AnchorCertificates;
 35 import sun.security.util.HostnameChecker;
 36 import sun.security.validator.*;
 37 
 38 /**
 39  * This class implements the SunJSSE X.509 trust manager using the internal
 40  * validator API in J2SE core. The logic in this class is minimal.&lt;p&gt;
 41  * &lt;p&gt;
 42  * This class supports both the Simple validation algorithm from previous
 43  * JSSE versions and PKIX validation. Currently, it is not possible for the
 44  * application to specify PKIX parameters other than trust anchors. This will
 45  * be fixed in a future release using new APIs. When that happens, it may also
 46  * make sense to separate the Simple and PKIX trust managers into separate
 47  * classes.
 48  *
 49  * @author Andreas Sterbenz
 50  */
 51 final class X509TrustManagerImpl extends X509ExtendedTrustManager
 52         implements X509TrustManager {
 53 
 54     private final String validatorType;
 55 
 56     /**
 57      * The Set of trusted X509Certificates.
 58      */
 59     private final Collection&lt;X509Certificate&gt; trustedCerts;
 60 
 61     private final PKIXBuilderParameters pkixParams;
 62 
 63     // note that we need separate validator for client and server due to
 64     // the different extension checks. They are initialized lazily on demand.
 65     private volatile Validator clientValidator, serverValidator;
 66 
<span class="line-added"> 67     private final ReentrantLock validatorLock = new ReentrantLock();</span>
<span class="line-added"> 68 </span>
 69     X509TrustManagerImpl(String validatorType,
 70             Collection&lt;X509Certificate&gt; trustedCerts) {
 71 
 72         this.validatorType = validatorType;
 73         this.pkixParams = null;
 74 
 75         if (trustedCerts == null) {
 76             trustedCerts = Collections.&lt;X509Certificate&gt;emptySet();
 77         }
 78 
 79         this.trustedCerts = trustedCerts;
 80 
 81         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
 82             SSLLogger.fine(&quot;adding as trusted certificates&quot;,
 83                     (Object[])trustedCerts.toArray(new X509Certificate[0]));
 84         }
 85     }
 86 
 87     X509TrustManagerImpl(String validatorType, PKIXBuilderParameters params) {
 88         this.validatorType = validatorType;
</pre>
<hr />
<pre>
128 
129     @Override
130     public void checkServerTrusted(X509Certificate[] chain, String authType,
131             Socket socket) throws CertificateException {
132         checkTrusted(chain, authType, socket, false);
133     }
134 
135     @Override
136     public void checkClientTrusted(X509Certificate[] chain, String authType,
137             SSLEngine engine) throws CertificateException {
138         checkTrusted(chain, authType, engine, true);
139     }
140 
141     @Override
142     public void checkServerTrusted(X509Certificate[] chain, String authType,
143             SSLEngine engine) throws CertificateException {
144         checkTrusted(chain, authType, engine, false);
145     }
146 
147     private Validator checkTrustedInit(X509Certificate[] chain,
<span class="line-modified">148             String authType, boolean checkClientTrusted) {</span>
149         if (chain == null || chain.length == 0) {
150             throw new IllegalArgumentException(
151                 &quot;null or zero-length certificate chain&quot;);
152         }
153 
154         if (authType == null || authType.isEmpty()) {
155             throw new IllegalArgumentException(
156                 &quot;null or zero-length authentication type&quot;);
157         }
158 
159         Validator v = null;
<span class="line-modified">160         if (checkClientTrusted) {</span>
161             v = clientValidator;
162             if (v == null) {
<span class="line-modified">163                 validatorLock.lock();</span>
<span class="line-added">164                 try {</span>
165                     v = clientValidator;
166                     if (v == null) {
167                         v = getValidator(Validator.VAR_TLS_CLIENT);
168                         clientValidator = v;
169                     }
<span class="line-added">170                 } finally {</span>
<span class="line-added">171                     validatorLock.unlock();</span>
172                 }
173             }
174         } else {
175             // assume double checked locking with a volatile flag works
176             // (guaranteed under the new Tiger memory model)
177             v = serverValidator;
178             if (v == null) {
<span class="line-modified">179                 validatorLock.lock();</span>
<span class="line-added">180                 try {</span>
181                     v = serverValidator;
182                     if (v == null) {
183                         v = getValidator(Validator.VAR_TLS_SERVER);
184                         serverValidator = v;
185                     }
<span class="line-added">186                 } finally {</span>
<span class="line-added">187                     validatorLock.unlock();</span>
188                 }
189             }
190         }
191 
192         return v;
193     }
194 
<span class="line-modified">195     private void checkTrusted(X509Certificate[] chain,</span>
<span class="line-modified">196             String authType, Socket socket,</span>
<span class="line-modified">197             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-added">198         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);</span>
199 
200         X509Certificate[] trustedChain = null;
201         if ((socket != null) &amp;&amp; socket.isConnected() &amp;&amp;
202                                         (socket instanceof SSLSocket)) {
203 
204             SSLSocket sslSocket = (SSLSocket)socket;
205             SSLSession session = sslSocket.getHandshakeSession();
206             if (session == null) {
207                 throw new CertificateException(&quot;No handshake session&quot;);
208             }
209 
210             // create the algorithm constraints
211             boolean isExtSession = (session instanceof ExtendedSSLSession);
212             AlgorithmConstraints constraints;
213             if (isExtSession &amp;&amp;
214                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
215                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
216                 String[] localSupportedSignAlgs =
217                         extSession.getLocalSupportedSignatureAlgorithms();
218 
219                 constraints = new SSLAlgorithmConstraints(
220                                 sslSocket, localSupportedSignAlgs, false);
221             } else {
222                 constraints = new SSLAlgorithmConstraints(sslSocket, false);
223             }
224 
225             // Grab any stapled OCSP responses for use in validation
226             List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">227             if (!checkClientTrusted &amp;&amp; isExtSession) {</span>
228                 responseList =
229                         ((ExtendedSSLSession)session).getStatusResponses();
230             }
231             trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">232                     constraints, checkClientTrusted ? null : authType);</span>





233 
234             // check endpoint identity
235             String identityAlg = sslSocket.getSSLParameters().
236                     getEndpointIdentificationAlgorithm();
237             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">238                 checkIdentity(session,</span>
<span class="line-modified">239                         trustedChain, identityAlg, checkClientTrusted);</span>
240             }
241         } else {
242             trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">243                     null, checkClientTrusted ? null : authType);</span>
244         }
245 
246         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
247             SSLLogger.fine(&quot;Found trusted certificate&quot;,
248                     trustedChain[trustedChain.length - 1]);
249         }
250     }
251 
<span class="line-modified">252     private void checkTrusted(X509Certificate[] chain,</span>
<span class="line-modified">253             String authType, SSLEngine engine,</span>
<span class="line-modified">254             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-added">255         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);</span>
256 
257         X509Certificate[] trustedChain = null;
258         if (engine != null) {
259             SSLSession session = engine.getHandshakeSession();
260             if (session == null) {
261                 throw new CertificateException(&quot;No handshake session&quot;);
262             }
263 
264             // create the algorithm constraints
265             boolean isExtSession = (session instanceof ExtendedSSLSession);
266             AlgorithmConstraints constraints;
267             if (isExtSession &amp;&amp;
268                     ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
269                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;
270                 String[] localSupportedSignAlgs =
271                         extSession.getLocalSupportedSignatureAlgorithms();
272 
273                 constraints = new SSLAlgorithmConstraints(
274                                 engine, localSupportedSignAlgs, false);
275             } else {
276                 constraints = new SSLAlgorithmConstraints(engine, false);
277             }
278 
279             // Grab any stapled OCSP responses for use in validation
280             List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">281             if (!checkClientTrusted &amp;&amp; isExtSession) {</span>
282                 responseList =
283                         ((ExtendedSSLSession)session).getStatusResponses();
284             }
285             trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">286                     constraints, checkClientTrusted ? null : authType);</span>





287 
288             // check endpoint identity
289             String identityAlg = engine.getSSLParameters().
290                     getEndpointIdentificationAlgorithm();
291             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">292                 checkIdentity(session, trustedChain,</span>
<span class="line-modified">293                         identityAlg, checkClientTrusted);</span>
294             }
295         } else {
296             trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">297                     null, checkClientTrusted ? null : authType);</span>
298         }
299 
300         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
301             SSLLogger.fine(&quot;Found trusted certificate&quot;,
302                     trustedChain[trustedChain.length - 1]);
303         }
304     }
305 
306     private Validator getValidator(String variant) {
307         Validator v;
308         if (pkixParams == null) {
309             v = Validator.getInstance(validatorType, variant, trustedCerts);
310         } else {
311             v = Validator.getInstance(validatorType, variant, pkixParams);
312         }
313         return v;
314     }
315 
316     // Get string representation of HostName from a list of server names.
317     //
</pre>
<hr />
<pre>
335                         SSLLogger.fine(&quot;Illegal server name: &quot; + sniName);
336                     }
337                 }
338             }
339 
340             // no more than server name of the same name type
341             break;
342         }
343 
344         if (hostname != null) {
345             return hostname.getAsciiName();
346         }
347 
348         return null;
349     }
350 
351     // Also used by X509KeyManagerImpl
352     static List&lt;SNIServerName&gt; getRequestedServerNames(Socket socket) {
353         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
354                                         socket instanceof SSLSocket) {
<span class="line-modified">355             return getRequestedServerNames(</span>
<span class="line-modified">356                     ((SSLSocket)socket).getHandshakeSession());</span>






357         }
358 
359         return Collections.&lt;SNIServerName&gt;emptyList();
360     }
361 
362     // Also used by X509KeyManagerImpl
363     static List&lt;SNIServerName&gt; getRequestedServerNames(SSLEngine engine) {
364         if (engine != null) {
<span class="line-modified">365             return getRequestedServerNames(engine.getHandshakeSession());</span>
<span class="line-added">366         }</span>
367 
<span class="line-modified">368         return Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="line-modified">369     }</span>
<span class="line-modified">370 </span>
<span class="line-modified">371     private static List&lt;SNIServerName&gt; getRequestedServerNames(</span>
<span class="line-added">372             SSLSession session) {</span>
<span class="line-added">373         if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-added">374             return ((ExtendedSSLSession)session).getRequestedServerNames();</span>
375         }
376 
377         return Collections.&lt;SNIServerName&gt;emptyList();
378     }
379 
380     /*
381      * Per RFC 6066, if an application negotiates a server name using an
382      * application protocol and then upgrades to TLS, and if a server_name
383      * extension is sent, then the extension SHOULD contain the same name
384      * that was negotiated in the application protocol.  If the server_name
385      * is established in the TLS session handshake, the client SHOULD NOT
386      * attempt to request a different server name at the application layer.
387      *
388      * According to the above spec, we only need to check either the identity
389      * in server_name extension or the peer host of the connection.  Peer host
390      * is not always a reliable fully qualified domain name. The HostName in
391      * server_name extension is more reliable than peer host. So we prefer
392      * the identity checking aginst the server_name extension if present, and
393      * may failove to peer host checking.
394      */
<span class="line-modified">395     static void checkIdentity(SSLSession session,</span>
<span class="line-modified">396             X509Certificate[] trustedChain,</span>
397             String algorithm,
<span class="line-modified">398             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-modified">399 </span>
<span class="line-modified">400         // check if EE certificate chains to a public root CA (as</span>
<span class="line-added">401         // pre-installed in cacerts)</span>
<span class="line-added">402         boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-added">403                 trustedChain[trustedChain.length - 1]);</span>
404 
405         boolean identifiable = false;
406         String peerHost = session.getPeerHost();
<span class="line-modified">407         if (!checkClientTrusted) {</span>
<span class="line-modified">408             List&lt;SNIServerName&gt; sniNames = getRequestedServerNames(session);</span>
<span class="line-modified">409             String sniHostName = getHostNameInSNI(sniNames);</span>
<span class="line-added">410             if (sniHostName != null) {</span>
411                 try {
<span class="line-modified">412                     checkIdentity(sniHostName,</span>
<span class="line-added">413                             trustedChain[0], algorithm, chainsToPublicCA);</span>
414                     identifiable = true;
415                 } catch (CertificateException ce) {
<span class="line-modified">416                     if (sniHostName.equalsIgnoreCase(peerHost)) {</span>
417                         throw ce;
418                     }
419 
420                     // otherwisw, failover to check peer host
421                 }
422             }
423         }
424 
425         if (!identifiable) {
<span class="line-modified">426             checkIdentity(peerHost,</span>
<span class="line-added">427                     trustedChain[0], algorithm, chainsToPublicCA);</span>
428         }
429     }
430 
431     /*
432      * Identify the peer by its certificate and hostname.
433      *
434      * Lifted from sun.net.www.protocol.https.HttpsClient.
435      */
436     static void checkIdentity(String hostname, X509Certificate cert,
437             String algorithm) throws CertificateException {
438         checkIdentity(hostname, cert, algorithm, false);
439     }
440 
441     private static void checkIdentity(String hostname, X509Certificate cert,
442             String algorithm, boolean chainsToPublicCA)
443             throws CertificateException {
444         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
445             // if IPv6 strip off the &quot;[]&quot;
446             if ((hostname != null) &amp;&amp; hostname.startsWith(&quot;[&quot;) &amp;&amp;
447                     hostname.endsWith(&quot;]&quot;)) {
</pre>
</td>
</tr>
</table>
<center><a href="X509KeyManagerImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
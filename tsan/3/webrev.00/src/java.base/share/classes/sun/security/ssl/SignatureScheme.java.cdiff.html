<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SessionId.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SunJSSE.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SignatureScheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,26 ***</span>
   */
  
  package sun.security.ssl;
  
  import java.security.*;
<span class="line-removed">- import java.security.interfaces.ECPrivateKey;</span>
  import java.security.spec.AlgorithmParameterSpec;
  import java.security.spec.ECParameterSpec;
  import java.security.spec.MGF1ParameterSpec;
  import java.security.spec.PSSParameterSpec;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.EnumSet;
  import java.util.LinkedList;
  import java.util.List;
  import java.util.Set;
<span class="line-modified">! import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-modified">! import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
  import sun.security.util.KeyUtil;
  
  enum SignatureScheme {
      // EdDSA algorithms
      ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
                                      &quot;ed25519&quot;,
<span class="line-new-header">--- 24,29 ---</span>
   */
  
  package sun.security.ssl;
  
  import java.security.*;
  import java.security.spec.AlgorithmParameterSpec;
  import java.security.spec.ECParameterSpec;
  import java.security.spec.MGF1ParameterSpec;
  import java.security.spec.PSSParameterSpec;
<span class="line-added">+ import java.util.AbstractMap.SimpleImmutableEntry;</span>
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.EnumSet;
  import java.util.LinkedList;
  import java.util.List;
<span class="line-added">+ import java.util.Map;</span>
  import java.util.Set;
<span class="line-modified">! import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>
<span class="line-modified">! import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;</span>
<span class="line-added">+ import sun.security.ssl.X509Authentication.X509Possession;</span>
  import sun.security.util.KeyUtil;
<span class="line-added">+ import sun.security.util.SignatureUtil;</span>
  
  enum SignatureScheme {
      // EdDSA algorithms
      ED25519                 (0x0807, &quot;ed25519&quot;, &quot;ed25519&quot;,
                                      &quot;ed25519&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
  
      final int id;                       // hash + signature
      final String name;                  // literal name
      private final String algorithm;     // signature algorithm
      final String keyAlgorithm;          // signature key algorithm
<span class="line-modified">!     private final AlgorithmParameterSpec signAlgParameter;</span>
      private final NamedGroup namedGroup;    // associated named group
  
      // The minimal required key size in bits.
      //
      // Only need to check RSA algorithm at present. RSA keys of 512 bits
<span class="line-new-header">--- 149,11 ---</span>
  
      final int id;                       // hash + signature
      final String name;                  // literal name
      private final String algorithm;     // signature algorithm
      final String keyAlgorithm;          // signature key algorithm
<span class="line-modified">!     private final SigAlgParamSpec signAlgParams;    // signature parameters</span>
      private final NamedGroup namedGroup;    // associated named group
  
      // The minimal required key size in bits.
      //
      // Only need to check RSA algorithm at present. RSA keys of 512 bits
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,39 ***</span>
      static enum SigAlgParamSpec {   // support RSASSA-PSS only now
          RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
          RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
          RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
  
<span class="line-modified">!         final private AlgorithmParameterSpec parameterSpec;</span>
<span class="line-modified">!         final boolean isAvailable;</span>
  
          SigAlgParamSpec(String hash, int saltLength) {
              // See RFC 8017
              PSSParameterSpec pssParamSpec =
                      new PSSParameterSpec(hash, &quot;MGF1&quot;,
                              new MGF1ParameterSpec(hash), saltLength, 1);
  
              boolean mediator = true;
              try {
                  Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
                  signer.setParameter(pssParamSpec);
              } catch (InvalidAlgorithmParameterException |
<span class="line-modified">!                     NoSuchAlgorithmException exp) {</span>
                  mediator = false;
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.warning(
                          &quot;RSASSA-PSS signature with &quot; + hash +
                          &quot; is not supported by the underlying providers&quot;, exp);
                  }
              }
  
              this.isAvailable = mediator;
              this.parameterSpec = mediator ? pssParamSpec : null;
<span class="line-modified">!         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         AlgorithmParameterSpec getParameterSpec() {</span>
<span class="line-removed">-             return parameterSpec;</span>
          }
      }
  
      // performance optimization
      private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
<span class="line-new-header">--- 184,40 ---</span>
      static enum SigAlgParamSpec {   // support RSASSA-PSS only now
          RSA_PSS_SHA256 (&quot;SHA-256&quot;, 32),
          RSA_PSS_SHA384 (&quot;SHA-384&quot;, 48),
          RSA_PSS_SHA512 (&quot;SHA-512&quot;, 64);
  
<span class="line-modified">!         private final AlgorithmParameterSpec parameterSpec;</span>
<span class="line-modified">!         private final AlgorithmParameters parameters;</span>
<span class="line-added">+         private final boolean isAvailable;</span>
  
          SigAlgParamSpec(String hash, int saltLength) {
              // See RFC 8017
              PSSParameterSpec pssParamSpec =
                      new PSSParameterSpec(hash, &quot;MGF1&quot;,
                              new MGF1ParameterSpec(hash), saltLength, 1);
<span class="line-added">+             AlgorithmParameters pssParams = null;</span>
  
              boolean mediator = true;
              try {
                  Signature signer = Signature.getInstance(&quot;RSASSA-PSS&quot;);
                  signer.setParameter(pssParamSpec);
<span class="line-added">+                 pssParams = signer.getParameters();</span>
              } catch (InvalidAlgorithmParameterException |
<span class="line-modified">!                     NoSuchAlgorithmException | RuntimeException exp) {</span>
<span class="line-added">+                 // Signature.getParameters() may throw RuntimeException.</span>
                  mediator = false;
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.warning(
                          &quot;RSASSA-PSS signature with &quot; + hash +
                          &quot; is not supported by the underlying providers&quot;, exp);
                  }
              }
  
              this.isAvailable = mediator;
              this.parameterSpec = mediator ? pssParamSpec : null;
<span class="line-modified">!             this.parameters = mediator ? pssParams : null;</span>
          }
      }
  
      // performance optimization
      private static final Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,38 ***</span>
                  supportedProtocols, supportedProtocols);
      }
  
      private SignatureScheme(int id, String name,
              String algorithm, String keyAlgorithm,
<span class="line-modified">!             SigAlgParamSpec signAlgParamSpec,</span>
              NamedGroup namedGroup, int minimalKeySize,
              ProtocolVersion[] supportedProtocols,
              ProtocolVersion[] handshakeSupportedProtocols) {
          this.id = id;
          this.name = name;
          this.algorithm = algorithm;
          this.keyAlgorithm = keyAlgorithm;
<span class="line-modified">!         this.signAlgParameter =</span>
<span class="line-removed">-             signAlgParamSpec != null ? signAlgParamSpec.parameterSpec : null;</span>
          this.namedGroup = namedGroup;
          this.minimalKeySize = minimalKeySize;
          this.supportedProtocols = Arrays.asList(supportedProtocols);
          this.handshakeSupportedProtocols =
                  Arrays.asList(handshakeSupportedProtocols);
  
          boolean mediator = true;
<span class="line-modified">!         if (signAlgParamSpec != null) {</span>
<span class="line-modified">!             mediator = signAlgParamSpec.isAvailable;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 Signature.getInstance(algorithm);</span>
<span class="line-modified">!             } catch (Exception e) {</span>
<span class="line-modified">!                 mediator = false;</span>
<span class="line-modified">!                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-modified">!                     SSLLogger.warning(</span>
<span class="line-modified">!                         &quot;Signature algorithm, &quot; + algorithm +</span>
<span class="line-modified">!                         &quot;, is not supported by the underlying providers&quot;);</span>
                  }
              }
          }
  
          if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
<span class="line-new-header">--- 256,48 ---</span>
                  supportedProtocols, supportedProtocols);
      }
  
      private SignatureScheme(int id, String name,
              String algorithm, String keyAlgorithm,
<span class="line-modified">!             SigAlgParamSpec signAlgParams,</span>
              NamedGroup namedGroup, int minimalKeySize,
              ProtocolVersion[] supportedProtocols,
              ProtocolVersion[] handshakeSupportedProtocols) {
          this.id = id;
          this.name = name;
          this.algorithm = algorithm;
          this.keyAlgorithm = keyAlgorithm;
<span class="line-modified">!         this.signAlgParams = signAlgParams;</span>
          this.namedGroup = namedGroup;
          this.minimalKeySize = minimalKeySize;
          this.supportedProtocols = Arrays.asList(supportedProtocols);
          this.handshakeSupportedProtocols =
                  Arrays.asList(handshakeSupportedProtocols);
  
          boolean mediator = true;
<span class="line-modified">!         // An EC provider, for example the SunEC provider, may support</span>
<span class="line-modified">!         // AlgorithmParameters but not KeyPairGenerator or Signature.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // Note: Please be careful if removing this block!</span>
<span class="line-modified">!         if (&quot;EC&quot;.equals(keyAlgorithm)) {</span>
<span class="line-modified">!             mediator = JsseJce.isEcAvailable();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Check the specific algorithm and parameters.</span>
<span class="line-modified">!         if (mediator) {</span>
<span class="line-modified">!             if (signAlgParams != null) {</span>
<span class="line-added">+                 mediator = signAlgParams.isAvailable;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     Signature.getInstance(algorithm);</span>
<span class="line-added">+                 } catch (Exception e) {</span>
<span class="line-added">+                     mediator = false;</span>
<span class="line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-added">+                         SSLLogger.warning(</span>
<span class="line-added">+                             &quot;Signature algorithm, &quot; + algorithm +</span>
<span class="line-added">+                             &quot;, is not supported by the underlying providers&quot;);</span>
<span class="line-added">+                     }</span>
                  }
              }
          }
  
          if (mediator &amp;&amp; ((id &gt;&gt; 8) &amp; 0xFF) == 0x03) {   // SHA224
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,10 ***</span>
<span class="line-new-header">--- 342,22 ---</span>
      // Return the size of a SignatureScheme structure in TLS record
      static int sizeInRecord() {
          return 2;
      }
  
<span class="line-added">+     private boolean isPermitted(AlgorithmConstraints constraints) {</span>
<span class="line-added">+         return constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">+                         this.name, null) &amp;&amp;</span>
<span class="line-added">+                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">+                         this.keyAlgorithm, null) &amp;&amp;</span>
<span class="line-added">+                constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-added">+                         this.algorithm, (signAlgParams != null ?</span>
<span class="line-added">+                                 signAlgParams.parameters : null)) &amp;&amp;</span>
<span class="line-added">+                (namedGroup != null ?</span>
<span class="line-added">+                         namedGroup.isPermitted(constraints) : true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Get local supported algorithm collection complying to algorithm
      // constraints.
      static List&lt;SignatureScheme&gt; getSupportedAlgorithms(
              AlgorithmConstraints constraints,
              List&lt;ProtocolVersion&gt; activeProtocols) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,12 ***</span>
                      break;
                  }
              }
  
              if (isMatch) {
<span class="line-modified">!                 if (constraints.permits(</span>
<span class="line-removed">-                         SIGNATURE_PRIMITIVE_SET, ss.algorithm, null)) {</span>
                      supported.add(ss);
                  } else if (SSLLogger.isOn &amp;&amp;
                          SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
                      SSLLogger.finest(
                          &quot;Ignore disabled signature scheme: &quot; + ss.name);
<span class="line-new-header">--- 374,11 ---</span>
                      break;
                  }
              }
  
              if (isMatch) {
<span class="line-modified">!                 if (ss.isPermitted(constraints)) {</span>
                      supported.add(ss);
                  } else if (SSLLogger.isOn &amp;&amp;
                          SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
                      SSLLogger.finest(
                          &quot;Ignore disabled signature scheme: &quot; + ss.name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,12 ***</span>
                              &quot;Unsupported signature scheme: &quot; +
                              SignatureScheme.nameOf(ssid));
                  }
              } else if (ss.isAvailable &amp;&amp;
                      ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
<span class="line-modified">!                     constraints.permits(SIGNATURE_PRIMITIVE_SET,</span>
<span class="line-removed">-                            ss.algorithm, null)) {</span>
                  supported.add(ss);
              } else {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.warning(
                              &quot;Unsupported signature scheme: &quot; + ss.name);
<span class="line-new-header">--- 405,11 ---</span>
                              &quot;Unsupported signature scheme: &quot; +
                              SignatureScheme.nameOf(ssid));
                  }
              } else if (ss.isAvailable &amp;&amp;
                      ss.supportedProtocols.contains(protocolVersion) &amp;&amp;
<span class="line-modified">!                     ss.isPermitted(constraints)) {</span>
                  supported.add(ss);
              } else {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.warning(
                              &quot;Unsupported signature scheme: &quot; + ss.name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,31 ***</span>
  
          return supported;
      }
  
      static SignatureScheme getPreferableAlgorithm(
              List&lt;SignatureScheme&gt; schemes,
              SignatureScheme certScheme,
              ProtocolVersion version) {
  
          for (SignatureScheme ss : schemes) {
              if (ss.isAvailable &amp;&amp;
                      ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
<span class="line-modified">!                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm)) {</span>
<span class="line-modified">! </span>
                  return ss;
              }
          }
  
          return null;
      }
  
<span class="line-modified">!     static SignatureScheme getPreferableAlgorithm(</span>
              List&lt;SignatureScheme&gt; schemes,
<span class="line-modified">!             PrivateKey signingKey,</span>
              ProtocolVersion version) {
  
          String keyAlgorithm = signingKey.getAlgorithm();
          int keySize;
          // Only need to check RSA algorithm at present.
          if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
                  keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
<span class="line-new-header">--- 419,34 ---</span>
  
          return supported;
      }
  
      static SignatureScheme getPreferableAlgorithm(
<span class="line-added">+             AlgorithmConstraints constraints,</span>
              List&lt;SignatureScheme&gt; schemes,
              SignatureScheme certScheme,
              ProtocolVersion version) {
  
          for (SignatureScheme ss : schemes) {
              if (ss.isAvailable &amp;&amp;
                      ss.handshakeSupportedProtocols.contains(version) &amp;&amp;
<span class="line-modified">!                     certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">!                     ss.isPermitted(constraints)) {</span>
                  return ss;
              }
          }
  
          return null;
      }
  
<span class="line-modified">!     static Map.Entry&lt;SignatureScheme, Signature&gt; getSignerOfPreferableAlgorithm(</span>
<span class="line-added">+             AlgorithmConstraints constraints,</span>
              List&lt;SignatureScheme&gt; schemes,
<span class="line-modified">!             X509Possession x509Possession,</span>
              ProtocolVersion version) {
  
<span class="line-added">+         PrivateKey signingKey = x509Possession.popPrivateKey;</span>
          String keyAlgorithm = signingKey.getAlgorithm();
          int keySize;
          // Only need to check RSA algorithm at present.
          if (keyAlgorithm.equalsIgnoreCase(&quot;RSA&quot;) ||
                  keyAlgorithm.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,21 ***</span>
          } else {
              keySize = Integer.MAX_VALUE;
          }
          for (SignatureScheme ss : schemes) {
              if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
<span class="line-modified">!                 ss.handshakeSupportedProtocols.contains(version) &amp;&amp;</span>
<span class="line-modified">!                 keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm)) {</span>
<span class="line-modified">!                 if (ss.namedGroup != null &amp;&amp;</span>
<span class="line-modified">!                     ss.namedGroup.type == NamedGroupType.NAMED_GROUP_ECDHE) {</span>
                      ECParameterSpec params =
<span class="line-modified">!                                 ((ECPrivateKey)signingKey).getParams();</span>
<span class="line-modified">!                     if (ss.namedGroup == NamedGroup.valueOf(params)) {</span>
<span class="line-modified">!                         return ss;</span>
                      }
                  } else {
<span class="line-modified">!                     return ss;</span>
                  }
              }
          }
  
          return null;
<span class="line-new-header">--- 454,65 ---</span>
          } else {
              keySize = Integer.MAX_VALUE;
          }
          for (SignatureScheme ss : schemes) {
              if (ss.isAvailable &amp;&amp; (keySize &gt;= ss.minimalKeySize) &amp;&amp;
<span class="line-modified">!                     ss.handshakeSupportedProtocols.contains(version) &amp;&amp;</span>
<span class="line-modified">!                     keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &amp;&amp;</span>
<span class="line-modified">!                     ss.isPermitted(constraints)) {</span>
<span class="line-modified">!                 if ((ss.namedGroup != null) &amp;&amp; (ss.namedGroup.spec ==</span>
<span class="line-added">+                         NamedGroupSpec.NAMED_GROUP_ECDHE)) {</span>
                      ECParameterSpec params =
<span class="line-modified">!                             x509Possession.getECParameterSpec();</span>
<span class="line-modified">!                     if (params != null &amp;&amp;</span>
<span class="line-modified">!                             ss.namedGroup == NamedGroup.valueOf(params)) {</span>
<span class="line-added">+                         Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">+                         if (signer != null) {</span>
<span class="line-added">+                             return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">+                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">+                         SSLLogger.finest(</span>
<span class="line-added">+                             &quot;Ignore the signature algorithm (&quot; + ss +</span>
<span class="line-added">+                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else if (&quot;EC&quot;.equals(ss.keyAlgorithm)) {</span>
<span class="line-added">+                     // Must be a legacy signature algorithm, which does not</span>
<span class="line-added">+                     // specify the associated named groups.  The connection</span>
<span class="line-added">+                     // cannot be established if the peer cannot recognize</span>
<span class="line-added">+                     // the named group used for the signature.  RFC 8446</span>
<span class="line-added">+                     // does not define countermeasures for the corner cases.</span>
<span class="line-added">+                     // In order to mitigate the impact, we choose to check</span>
<span class="line-added">+                     // against the local supported named groups.  The risk</span>
<span class="line-added">+                     // should be minimal as applications should not use</span>
<span class="line-added">+                     // unsupported named groups for its certificates.</span>
<span class="line-added">+                     ECParameterSpec params =</span>
<span class="line-added">+                             x509Possession.getECParameterSpec();</span>
<span class="line-added">+                     if (params != null) {</span>
<span class="line-added">+                         NamedGroup keyGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">+                         if (keyGroup != null &amp;&amp;</span>
<span class="line-added">+                                 SupportedGroups.isSupported(keyGroup)) {</span>
<span class="line-added">+                             Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">+                             if (signer != null) {</span>
<span class="line-added">+                                 return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">+                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">+                         SSLLogger.finest(</span>
<span class="line-added">+                             &quot;Ignore the legacy signature algorithm (&quot; + ss +</span>
<span class="line-added">+                             &quot;), unsupported EC parameter spec: &quot; + params);</span>
                      }
                  } else {
<span class="line-modified">!                     Signature signer = ss.getSigner(signingKey);</span>
<span class="line-added">+                     if (signer != null) {</span>
<span class="line-added">+                         return new SimpleImmutableEntry&lt;&gt;(ss, signer);</span>
<span class="line-added">+                     }</span>
                  }
              }
          }
  
          return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,28 ***</span>
          }
  
          return new String[0];
      }
  
<span class="line-modified">!     Signature getSignature(Key key) throws NoSuchAlgorithmException,</span>
              InvalidAlgorithmParameterException, InvalidKeyException {
          if (!isAvailable) {
              return null;
          }
  
<span class="line-modified">!         Signature signer = Signature.getInstance(algorithm);</span>
<span class="line-modified">!         if (key instanceof PublicKey) {</span>
<span class="line-modified">!             signer.initVerify((PublicKey)(key));</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             signer.initSign((PrivateKey)key);</span>
          }
  
<span class="line-modified">!         // Important note:  Please don&#39;t set the parameters before signature</span>
<span class="line-modified">!         // or verification initialization, so that the crypto provider can</span>
<span class="line-modified">!         // be selected properly.</span>
<span class="line-modified">!         if (signAlgParameter != null) {</span>
<span class="line-modified">!             signer.setParameter(signAlgParameter);</span>
          }
  
<span class="line-modified">!         return signer;</span>
      }
  }
<span class="line-new-header">--- 529,51 ---</span>
          }
  
          return new String[0];
      }
  
<span class="line-modified">!     // This method is used to get the signature instance of this signature</span>
<span class="line-added">+     // scheme for the specific public key.  Unlike getSigner(), the exception</span>
<span class="line-added">+     // is bubbled up.  If the public key does not support this signature</span>
<span class="line-added">+     // scheme, it normally means the TLS handshaking cannot continue and</span>
<span class="line-added">+     // the connection should be terminated.</span>
<span class="line-added">+     Signature getVerifier(PublicKey publicKey) throws NoSuchAlgorithmException,</span>
              InvalidAlgorithmParameterException, InvalidKeyException {
          if (!isAvailable) {
              return null;
          }
  
<span class="line-modified">!         Signature verifier = Signature.getInstance(algorithm);</span>
<span class="line-modified">!         SignatureUtil.initVerifyWithParam(verifier, publicKey,</span>
<span class="line-modified">!                 (signAlgParams != null ? signAlgParams.parameterSpec : null));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         return verifier;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This method is also used to choose preferable signature scheme for the</span>
<span class="line-added">+     // specific private key.  If the private key does not support the signature</span>
<span class="line-added">+     // scheme, {@code null} is returned, and the caller may fail back to next</span>
<span class="line-added">+     // available signature scheme.</span>
<span class="line-added">+     private Signature getSigner(PrivateKey privateKey) {</span>
<span class="line-added">+         if (!isAvailable) {</span>
<span class="line-added">+             return null;</span>
          }
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             Signature signer = Signature.getInstance(algorithm);</span>
<span class="line-modified">!             SignatureUtil.initSignWithParam(signer, privateKey,</span>
<span class="line-modified">!                 (signAlgParams != null ? signAlgParams.parameterSpec : null),</span>
<span class="line-modified">!                 null);</span>
<span class="line-added">+             return signer;</span>
<span class="line-added">+         } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-added">+                 InvalidAlgorithmParameterException nsae) {</span>
<span class="line-added">+             if (SSLLogger.isOn &amp;&amp;</span>
<span class="line-added">+                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {</span>
<span class="line-added">+                 SSLLogger.finest(</span>
<span class="line-added">+                     &quot;Ignore unsupported signature algorithm (&quot; +</span>
<span class="line-added">+                     this.name + &quot;)&quot;, nsae);</span>
<span class="line-added">+             }</span>
          }
  
<span class="line-modified">!         return null;</span>
      }
  }
</pre>
<center><a href="SessionId.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SunJSSE.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/util/ManifestDigester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.security.*;
 29 import java.util.ArrayList;
 30 import java.util.HashMap;
 31 import java.io.ByteArrayOutputStream;
 32 import java.util.List;
 33 
 34 import static java.nio.charset.StandardCharsets.UTF_8;
 35 
 36 /**
 37  * This class is used to compute digests on sections of the Manifest.
 38  * Please note that multiple sections might have the same name, and they
 39  * all belong to a single Entry.
 40  */
 41 public class ManifestDigester {
 42 
 43     public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
 44 
 45     /** the raw bytes of the manifest */
 46     private byte[] rawBytes;
 47 
 48     /** the entries grouped by names */
 49     private HashMap&lt;String, Entry&gt; entries; // key is a UTF-8 string
 50 
 51     /** state returned by findSection */
 52     static class Position {
 53         int endOfFirstLine; // not including newline character
 54 
 55         int endOfSection; // end of section, not including the blank line
 56                           // between sections
 57         int startOfNext;  // the start of the next section
 58     }
 59 
 60     /**
 61      * find a section in the manifest.
 62      *
 63      * @param offset should point to the starting offset with in the
 64      * raw bytes of the next section.
 65      *
 66      * @pos set by
 67      *
 68      * @return false if end of bytes has been reached, otherwise returns
 69      *          true
 70      */
 71     @SuppressWarnings(&quot;fallthrough&quot;)
 72     private boolean findSection(int offset, Position pos)
 73     {
 74         int i = offset, len = rawBytes.length;
 75         int last = offset;
 76         int next;
 77         boolean allBlank = true;
 78 
 79         pos.endOfFirstLine = -1;
 80 
 81         while (i &lt; len) {
 82             byte b = rawBytes[i];
 83             switch(b) {
 84             case &#39;\r&#39;:
 85                 if (pos.endOfFirstLine == -1)
 86                     pos.endOfFirstLine = i-1;
 87                 if ((i &lt; len) &amp;&amp;  (rawBytes[i+1] == &#39;\n&#39;))
 88                     i++;
 89                 /* fall through */
 90             case &#39;\n&#39;:
 91                 if (pos.endOfFirstLine == -1)
 92                     pos.endOfFirstLine = i-1;
 93                 if (allBlank || (i == len-1)) {
 94                     if (i == len-1)
 95                         pos.endOfSection = i;
 96                     else
 97                         pos.endOfSection = last;
 98                     pos.startOfNext = i+1;
 99                     return true;
100                 }
101                 else {
102                     // start of a new line
103                     last = i;
104                     allBlank = true;
105                 }
106                 break;
107             default:
108                 allBlank = false;
109                 break;
110             }
111             i++;
112         }
113         return false;
114     }
115 
116     public ManifestDigester(byte[] bytes)
117     {
118         rawBytes = bytes;
119         entries = new HashMap&lt;&gt;();
120 
121         Position pos = new Position();
122 
123         if (!findSection(0, pos))
124             return; // XXX: exception?
125 
126         // create an entry for main attributes
127         entries.put(MF_MAIN_ATTRS, new Entry().addSection(
128                 new Section(0, pos.endOfSection + 1, pos.startOfNext, rawBytes)));
129 
130         int start = pos.startOfNext;
131         while(findSection(start, pos)) {
132             int len = pos.endOfFirstLine-start+1;
133             int sectionLen = pos.endOfSection-start+1;
134             int sectionLenWithBlank = pos.startOfNext-start;
135 
136             if (len &gt; 6) {
137                 if (isNameAttr(bytes, start)) {
138                     ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
139                     nameBuf.write(bytes, start+6, len-6);
140 
141                     int i = start + len;
142                     if ((i-start) &lt; sectionLen) {
143                         if (bytes[i] == &#39;\r&#39;) {
144                             i += 2;
145                         } else {
146                             i += 1;
147                         }
148                     }
149 
150                     while ((i-start) &lt; sectionLen) {
151                         if (bytes[i++] == &#39; &#39;) {
152                             // name is wrapped
153                             int wrapStart = i;
154                             while (((i-start) &lt; sectionLen)
155                                     &amp;&amp; (bytes[i++] != &#39;\n&#39;));
156                             if (bytes[i-1] != &#39;\n&#39;)
157                                 return; // XXX: exception?
158                             int wrapLen;
159                             if (bytes[i-2] == &#39;\r&#39;)
160                                 wrapLen = i-wrapStart-2;
161                             else
162                                 wrapLen = i-wrapStart-1;
163 
164                             nameBuf.write(bytes, wrapStart, wrapLen);
165                         } else {
166                             break;
167                         }
168                     }
169 
170                     entries.computeIfAbsent(new String(nameBuf.toByteArray(), UTF_8),
171                                             dummy -&gt; new Entry())
172                             .addSection(new Section(start, sectionLen,
173                                     sectionLenWithBlank, rawBytes));
174                 }
175             }
176             start = pos.startOfNext;
177         }
178     }
179 
180     private boolean isNameAttr(byte[] bytes, int start)
181     {
182         return ((bytes[start] == &#39;N&#39;) || (bytes[start] == &#39;n&#39;)) &amp;&amp;
183                ((bytes[start+1] == &#39;a&#39;) || (bytes[start+1] == &#39;A&#39;)) &amp;&amp;
184                ((bytes[start+2] == &#39;m&#39;) || (bytes[start+2] == &#39;M&#39;)) &amp;&amp;
185                ((bytes[start+3] == &#39;e&#39;) || (bytes[start+3] == &#39;E&#39;)) &amp;&amp;
186                (bytes[start+4] == &#39;:&#39;) &amp;&amp;
187                (bytes[start+5] == &#39; &#39;);
188     }
189 
190     public static class Entry {
191 
192         // One Entry for one name, and one name can have multiple sections.
193         // According to the JAR File Specification: &quot;If there are multiple
194         // individual sections for the same file entry, the attributes in
195         // these sections are merged.&quot;
196         private List&lt;Section&gt; sections = new ArrayList&lt;&gt;();
197         boolean oldStyle;
198 
199         private Entry addSection(Section sec)
200         {
201             sections.add(sec);
202             return this;
203         }
204 
205         public byte[] digest(MessageDigest md)
206         {
207             md.reset();
208             for (Section sec : sections) {
209                 if (oldStyle) {
210                     Section.doOldStyle(md, sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
211                 } else {
212                     md.update(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);
213                 }
214             }
215             return md.digest();
216         }
217 
218         /** Netscape doesn&#39;t include the new line. Intel and JavaSoft do */
219 
220         public byte[] digestWorkaround(MessageDigest md)
221         {
222             md.reset();
223             for (Section sec : sections) {
224                 md.update(sec.rawBytes, sec.offset, sec.length);
225             }
226             return md.digest();
227         }
228     }
229 
230     private static class Section {
231         int offset;
232         int length;
233         int lengthWithBlankLine;
234         byte[] rawBytes;
235 
236         public Section(int offset, int length,
237                      int lengthWithBlankLine, byte[] rawBytes)
238         {
239             this.offset = offset;
240             this.length = length;
241             this.lengthWithBlankLine = lengthWithBlankLine;
242             this.rawBytes = rawBytes;
243         }
244 
245         private static void doOldStyle(MessageDigest md,
246                                 byte[] bytes,
247                                 int offset,
248                                 int length)
249         {
250             // this is too gross to even document, but here goes
251             // the 1.1 jar verification code ignored spaces at the
252             // end of lines when calculating digests, so that is
253             // what this code does. It only gets called if we
254             // are parsing a 1.1 signed signature file
255             int i = offset;
256             int start = offset;
257             int max = offset + length;
258             int prev = -1;
259             while(i &lt;max) {
260                 if ((bytes[i] == &#39;\r&#39;) &amp;&amp; (prev == &#39; &#39;)) {
261                     md.update(bytes, start, i-start-1);
262                     start = i;
263                 }
264                 prev = bytes[i];
265                 i++;
266             }
267             md.update(bytes, start, i-start);
268         }
269     }
270 
271     public Entry get(String name, boolean oldStyle) {
272         Entry e = entries.get(name);
273         if (e != null)
274             e.oldStyle = oldStyle;
275         return e;
276     }
277 
278     public byte[] manifestDigest(MessageDigest md) {
279         md.reset();
280         md.update(rawBytes, 0, rawBytes.length);
281         return md.digest();
282     }
283 
284 }
    </pre>
  </body>
</html>
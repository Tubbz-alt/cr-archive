<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/reflect/generics/reflectiveObjects/ParameterizedTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.reflect.generics.reflectiveObjects;
 27 
 28 import sun.reflect.generics.tree.FieldTypeSignature;
 29 
 30 import java.lang.reflect.MalformedParameterizedTypeException;
 31 import java.lang.reflect.Method;
 32 import java.lang.reflect.ParameterizedType;
 33 import java.lang.reflect.Type;
 34 import java.lang.reflect.TypeVariable;
 35 import java.util.Arrays;
 36 import java.util.StringJoiner;
 37 import java.util.Objects;
 38 
 39 /** Implementing class for ParameterizedType interface. */
 40 
 41 public class ParameterizedTypeImpl implements ParameterizedType {
 42     private final Type[] actualTypeArguments;
 43     private final Class&lt;?&gt;  rawType;
 44     private final Type   ownerType;
 45 
 46     private ParameterizedTypeImpl(Class&lt;?&gt; rawType,
 47                                   Type[] actualTypeArguments,
 48                                   Type ownerType) {
 49         this.actualTypeArguments = actualTypeArguments;
 50         this.rawType             = rawType;
 51         this.ownerType = (ownerType != null) ? ownerType : rawType.getDeclaringClass();
 52         validateConstructorArguments();
 53     }
 54 
 55     private void validateConstructorArguments() {
 56         TypeVariable&lt;?&gt;[] formals = rawType.getTypeParameters();
 57         // check correct arity of actual type args
 58         if (formals.length != actualTypeArguments.length) {
 59             throw new MalformedParameterizedTypeException(String.format(&quot;Mismatch of count of &quot; +
 60                                                                         &quot;formal and actual type &quot; +
 61                                                                         &quot;arguments in constructor &quot; +
 62                                                                         &quot;of %s: %d formal argument(s) &quot;+
 63                                                                         &quot;%d actual argument(s)&quot;,
 64                                                                         rawType.getName(),
 65                                                                         formals.length,
 66                                                                         actualTypeArguments.length));
 67         }
 68         for (int i = 0; i &lt; actualTypeArguments.length; i++) {
 69             // check actuals against formals&#39; bounds
 70         }
 71     }
 72 
 73     /**
 74      * Static factory. Given a (generic) class, actual type arguments
 75      * and an owner type, creates a parameterized type.
 76      * This class can be instantiated with a raw type that does not
 77      * represent a generic type, provided the list of actual type
 78      * arguments is empty.
 79      * If the ownerType argument is null, the declaring class of the
 80      * raw type is used as the owner type.
 81      * &lt;p&gt; This method throws a MalformedParameterizedTypeException
 82      * under the following circumstances:
 83      * If the number of actual type arguments (i.e., the size of the
 84      * array {@code typeArgs}) does not correspond to the number of
 85      * formal type arguments.
 86      * If any of the actual type arguments is not an instance of the
 87      * bounds on the corresponding formal.
 88      * @param rawType the Class representing the generic type declaration being
 89      * instantiated
 90      * @param actualTypeArguments a (possibly empty) array of types
 91      * representing the actual type arguments to the parameterized type
 92      * @param ownerType the enclosing type, if known.
 93      * @return An instance of {@code ParameterizedType}
 94      * @throws MalformedParameterizedTypeException if the instantiation
 95      * is invalid
 96      */
 97     public static ParameterizedTypeImpl make(Class&lt;?&gt; rawType,
 98                                              Type[] actualTypeArguments,
 99                                              Type ownerType) {
100         return new ParameterizedTypeImpl(rawType, actualTypeArguments,
101                                          ownerType);
102     }
103 
104 
105     /**
106      * Returns an array of {@code Type} objects representing the actual type
107      * arguments to this type.
108      *
109      * &lt;p&gt;Note that in some cases, the returned array be empty. This can occur
110      * if this type represents a non-parameterized type nested within
111      * a parameterized type.
112      *
113      * @return an array of {@code Type} objects representing the actual type
114      *     arguments to this type
115      * @throws TypeNotPresentException if any of the
116      *     actual type arguments refers to a non-existent type declaration
117      * @throws MalformedParameterizedTypeException if any of the
118      *     actual type parameters refer to a parameterized type that cannot
119      *     be instantiated for any reason
120      * @since 1.5
121      */
122     public Type[] getActualTypeArguments() {
123         return actualTypeArguments.clone();
124     }
125 
126     /**
127      * Returns the {@code Type} object representing the class or interface
128      * that declared this type.
129      *
130      * @return the {@code Type} object representing the class or interface
131      *     that declared this type
132      */
133     public Class&lt;?&gt; getRawType() {
134         return rawType;
135     }
136 
137 
138     /**
139      * Returns a {@code Type} object representing the type that this type
140      * is a member of.  For example, if this type is {@code O&lt;T&gt;.I&lt;S&gt;},
141      * return a representation of {@code O&lt;T&gt;}.
142      *
143      * &lt;p&gt;If this type is a top-level type, {@code null} is returned.
144      *
145      * @return a {@code Type} object representing the type that
146      *     this type is a member of. If this type is a top-level type,
147      *     {@code null} is returned
148      * @throws TypeNotPresentException if the owner type
149      *     refers to a non-existent type declaration
150      * @throws MalformedParameterizedTypeException if the owner type
151      *     refers to a parameterized type that cannot be instantiated
152      *     for any reason
153      *
154      */
155     public Type getOwnerType() {
156         return ownerType;
157     }
158 
159     /*
160      * From the JavaDoc for java.lang.reflect.ParameterizedType
161      * &quot;Instances of classes that implement this interface must
162      * implement an equals() method that equates any two instances
163      * that share the same generic type declaration and have equal
164      * type parameters.&quot;
165      */
166     @Override
167     public boolean equals(Object o) {
168         if (o instanceof ParameterizedType) {
169             // Check that information is equivalent
170             ParameterizedType that = (ParameterizedType) o;
171 
172             if (this == that)
173                 return true;
174 
175             Type thatOwner   = that.getOwnerType();
176             Type thatRawType = that.getRawType();
177 
178             if (false) { // Debugging
179                 boolean ownerEquality = (ownerType == null ?
180                                          thatOwner == null :
181                                          ownerType.equals(thatOwner));
182                 boolean rawEquality = (rawType == null ?
183                                        thatRawType == null :
184                                        rawType.equals(thatRawType));
185 
186                 boolean typeArgEquality = Arrays.equals(actualTypeArguments, // avoid clone
187                                                         that.getActualTypeArguments());
188                 for (Type t : actualTypeArguments) {
189                     System.out.printf(&quot;\t\t%s%s%n&quot;, t, t.getClass());
190                 }
191 
192                 System.out.printf(&quot;\towner %s\traw %s\ttypeArg %s%n&quot;,
193                                   ownerEquality, rawEquality, typeArgEquality);
194                 return ownerEquality &amp;&amp; rawEquality &amp;&amp; typeArgEquality;
195             }
196 
197             return
198                 Objects.equals(ownerType, thatOwner) &amp;&amp;
199                 Objects.equals(rawType, thatRawType) &amp;&amp;
200                 Arrays.equals(actualTypeArguments, // avoid clone
201                               that.getActualTypeArguments());
202         } else
203             return false;
204     }
205 
206     @Override
207     public int hashCode() {
208         return
209             Arrays.hashCode(actualTypeArguments) ^
210             Objects.hashCode(ownerType) ^
211             Objects.hashCode(rawType);
212     }
213 
214     public String toString() {
215         StringBuilder sb = new StringBuilder();
216 
217         if (ownerType != null) {
218             sb.append(ownerType.getTypeName());
219 
220             sb.append(&quot;$&quot;);
221 
222             if (ownerType instanceof ParameterizedTypeImpl) {
223                 // Find simple name of nested type by removing the
224                 // shared prefix with owner.
225                 sb.append(rawType.getName().replace( ((ParameterizedTypeImpl)ownerType).rawType.getName() + &quot;$&quot;,
226                                          &quot;&quot;));
227             } else
228                sb.append(rawType.getSimpleName());
229         } else
230             sb.append(rawType.getName());
231 
232         if (actualTypeArguments != null) {
233             StringJoiner sj = new StringJoiner(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;);
234             sj.setEmptyValue(&quot;&quot;);
235             for(Type t: actualTypeArguments) {
236                 sj.add(t.getTypeName());
237             }
238             sb.append(sj.toString());
239         }
240 
241         return sb.toString();
242     }
243 }
    </pre>
  </body>
</html>
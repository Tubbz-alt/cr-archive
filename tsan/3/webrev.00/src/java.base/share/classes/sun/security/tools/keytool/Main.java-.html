<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/tools/keytool/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.keytool;
  27 
  28 import java.io.*;
  29 import java.nio.file.Files;
  30 import java.nio.file.Path;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CodeSigner;
  33 import java.security.CryptoPrimitive;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreException;
  36 import java.security.MessageDigest;
  37 import java.security.Key;
  38 import java.security.PublicKey;
  39 import java.security.PrivateKey;
  40 import java.security.Signature;
  41 import java.security.Timestamp;
  42 import java.security.UnrecoverableEntryException;
  43 import java.security.UnrecoverableKeyException;
  44 import java.security.Principal;
  45 import java.security.cert.Certificate;
  46 import java.security.cert.CertificateFactory;
  47 import java.security.cert.CertStoreException;
  48 import java.security.cert.CRL;
  49 import java.security.cert.X509Certificate;
  50 import java.security.cert.CertificateException;
  51 import java.security.cert.URICertStoreParameters;
  52 
  53 
  54 import java.security.interfaces.ECKey;
  55 import java.security.spec.AlgorithmParameterSpec;
  56 import java.security.spec.ECParameterSpec;
  57 import java.text.Collator;
  58 import java.text.MessageFormat;
  59 import java.util.*;
  60 import java.util.jar.JarEntry;
  61 import java.util.jar.JarFile;
  62 import java.math.BigInteger;
  63 import java.net.URI;
  64 import java.net.URL;
  65 import java.net.URLClassLoader;
  66 import java.security.cert.CertStore;
  67 
  68 import java.security.cert.X509CRL;
  69 import java.security.cert.X509CRLEntry;
  70 import java.security.cert.X509CRLSelector;
  71 import javax.security.auth.x500.X500Principal;
  72 import java.util.Base64;
  73 
  74 import sun.security.pkcs12.PKCS12KeyStore;
  75 import sun.security.util.ECKeySizeParameterSpec;
  76 import sun.security.util.KeyUtil;
  77 import sun.security.util.NamedCurve;
  78 import sun.security.util.ObjectIdentifier;
  79 import sun.security.pkcs10.PKCS10;
  80 import sun.security.pkcs10.PKCS10Attribute;
  81 import sun.security.provider.X509Factory;
  82 import sun.security.provider.certpath.ssl.SSLServerCertStore;
  83 import sun.security.util.Password;
  84 import sun.security.util.SecurityProperties;
  85 import sun.security.util.SecurityProviderConstants;
  86 import javax.crypto.KeyGenerator;
  87 import javax.crypto.SecretKey;
  88 import javax.crypto.SecretKeyFactory;
  89 import javax.crypto.spec.PBEKeySpec;
  90 
  91 import sun.security.pkcs.PKCS9Attribute;
  92 import sun.security.tools.KeyStoreUtil;
  93 import sun.security.tools.PathList;
  94 import sun.security.util.DerValue;
  95 import sun.security.util.Pem;
  96 import sun.security.x509.*;
  97 
  98 import static java.security.KeyStore.*;
  99 import java.security.Security;
 100 import static sun.security.tools.keytool.Main.Command.*;
 101 import static sun.security.tools.keytool.Main.Option.*;
 102 import sun.security.util.DisabledAlgorithmConstraints;
 103 
 104 /**
 105  * This tool manages keystores.
 106  *
 107  * @author Jan Luehe
 108  *
 109  *
 110  * @see java.security.KeyStore
 111  * @see sun.security.provider.KeyProtector
 112  * @see sun.security.provider.JavaKeyStore
 113  *
 114  * @since 1.2
 115  */
 116 public final class Main {
 117 
 118     private static final byte[] CRLF = new byte[] {&#39;\r&#39;, &#39;\n&#39;};
 119 
 120     private boolean debug = false;
 121     private Command command = null;
 122     private String sigAlgName = null;
 123     private String keyAlgName = null;
 124     private boolean verbose = false;
 125     private int keysize = -1;
 126     private String groupName = null;
 127     private boolean rfc = false;
 128     private long validity = (long)90;
 129     private String alias = null;
 130     private String dname = null;
 131     private String dest = null;
 132     private String filename = null;
 133     private String infilename = null;
 134     private String outfilename = null;
 135     private String srcksfname = null;
 136 
 137     // User-specified providers are added before any command is called.
 138     // However, they are not removed before the end of the main() method.
 139     // If you&#39;re calling KeyTool.main() directly in your own Java program,
 140     // please programtically add any providers you need and do not specify
 141     // them through the command line.
 142 
 143     private Set&lt;Pair &lt;String, String&gt;&gt; providers = null;
 144     private Set&lt;Pair &lt;String, String&gt;&gt; providerClasses = null;
 145     private String storetype = null;
 146     private String srcProviderName = null;
 147     private String providerName = null;
 148     private String pathlist = null;
 149     private char[] storePass = null;
 150     private char[] storePassNew = null;
 151     private char[] keyPass = null;
 152     private char[] keyPassNew = null;
 153     private char[] newPass = null;
 154     private char[] destKeyPass = null;
 155     private char[] srckeyPass = null;
 156     private String ksfname = null;
 157     private File ksfile = null;
 158     private InputStream ksStream = null; // keystore stream
 159     private String sslserver = null;
 160     private String jarfile = null;
 161     private KeyStore keyStore = null;
 162     private boolean token = false;
 163     private boolean nullStream = false;
 164     private boolean kssave = false;
 165     private boolean noprompt = false;
 166     private boolean trustcacerts = false;
 167     private boolean protectedPath = false;
 168     private boolean srcprotectedPath = false;
 169     private boolean cacerts = false;
 170     private boolean nowarn = false;
 171     private KeyStore caks = null; // &quot;cacerts&quot; keystore
 172     private char[] srcstorePass = null;
 173     private String srcstoretype = null;
 174     private Set&lt;char[]&gt; passwords = new HashSet&lt;&gt;();
 175     private String startDate = null;
 176 
 177     private List&lt;String&gt; ids = new ArrayList&lt;&gt;();   // used in GENCRL
 178     private List&lt;String&gt; v3ext = new ArrayList&lt;&gt;();
 179 
 180     // In-place importkeystore is special.
 181     // A backup is needed, and no need to prompt for deststorepass.
 182     private boolean inplaceImport = false;
 183     private String inplaceBackupName = null;
 184 
 185     // Warnings on weak algorithms etc
 186     private List&lt;String&gt; weakWarnings = new ArrayList&lt;&gt;();
 187 
 188     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 189             new DisabledAlgorithmConstraints(
 190                     DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);
 191 
 192     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 193             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 194     private boolean isPasswordlessKeyStore = false;
 195 
 196     enum Command {
 197         CERTREQ(&quot;Generates.a.certificate.request&quot;,
 198             ALIAS, SIGALG, FILEOUT, KEYPASS, KEYSTORE, DNAME,
 199             EXT, STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 200             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 201         CHANGEALIAS(&quot;Changes.an.entry.s.alias&quot;,
 202             ALIAS, DESTALIAS, KEYPASS, KEYSTORE, CACERTS, STOREPASS,
 203             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 204             PROVIDERPATH, V, PROTECTED),
 205         DELETE(&quot;Deletes.an.entry&quot;,
 206             ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 207             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 208             PROVIDERPATH, V, PROTECTED),
 209         EXPORTCERT(&quot;Exports.certificate&quot;,
 210             RFC, ALIAS, FILEOUT, KEYSTORE, CACERTS, STOREPASS,
 211             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 212             PROVIDERPATH, V, PROTECTED),
 213         GENKEYPAIR(&quot;Generates.a.key.pair&quot;,
 214             ALIAS, KEYALG, KEYSIZE, CURVENAME, SIGALG, DNAME,
 215             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 216             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 217             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 218         GENSECKEY(&quot;Generates.a.secret.key&quot;,
 219             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 220             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 221             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 222         GENCERT(&quot;Generates.certificate.from.a.certificate.request&quot;,
 223             RFC, INFILE, OUTFILE, ALIAS, SIGALG, DNAME,
 224             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 225             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 226             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 227         IMPORTCERT(&quot;Imports.a.certificate.or.a.certificate.chain&quot;,
 228             NOPROMPT, TRUSTCACERTS, PROTECTED, ALIAS, FILEIN,
 229             KEYPASS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 230             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 231             PROVIDERPATH, V),
 232         IMPORTPASS(&quot;Imports.a.password&quot;,
 233             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 234             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 235             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 236         IMPORTKEYSTORE(&quot;Imports.one.or.all.entries.from.another.keystore&quot;,
 237             SRCKEYSTORE, DESTKEYSTORE, SRCSTORETYPE,
 238             DESTSTORETYPE, SRCSTOREPASS, DESTSTOREPASS,
 239             SRCPROTECTED, DESTPROTECTED, SRCPROVIDERNAME, DESTPROVIDERNAME,
 240             SRCALIAS, DESTALIAS, SRCKEYPASS, DESTKEYPASS,
 241             NOPROMPT, ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH,
 242             V),
 243         KEYPASSWD(&quot;Changes.the.key.password.of.an.entry&quot;,
 244             ALIAS, KEYPASS, NEW, KEYSTORE, STOREPASS,
 245             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 246             PROVIDERPATH, V),
 247         LIST(&quot;Lists.entries.in.a.keystore&quot;,
 248             RFC, ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 249             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 250             PROVIDERPATH, V, PROTECTED),
 251         PRINTCERT(&quot;Prints.the.content.of.a.certificate&quot;,
 252             RFC, FILEIN, SSLSERVER, JARFILE,
 253             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 254             PROVIDERPATH, V),
 255         PRINTCERTREQ(&quot;Prints.the.content.of.a.certificate.request&quot;,
 256             FILEIN, V),
 257         PRINTCRL(&quot;Prints.the.content.of.a.CRL.file&quot;,
 258             FILEIN, V),
 259         STOREPASSWD(&quot;Changes.the.store.password.of.a.keystore&quot;,
 260             NEW, KEYSTORE, CACERTS, STOREPASS, STORETYPE, PROVIDERNAME,
 261             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 262 
 263         // Undocumented start here, KEYCLONE is used a marker in -help;
 264 
 265         KEYCLONE(&quot;Clones.a.key.entry&quot;,
 266             ALIAS, DESTALIAS, KEYPASS, NEW, STORETYPE,
 267             KEYSTORE, STOREPASS, PROVIDERNAME, ADDPROVIDER,
 268             PROVIDERCLASS, PROVIDERPATH, V),
 269         SELFCERT(&quot;Generates.a.self.signed.certificate&quot;,
 270             ALIAS, SIGALG, DNAME, STARTDATE, EXT, VALIDITY, KEYPASS,
 271             STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 272             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 273         GENCRL(&quot;Generates.CRL&quot;,
 274             RFC, FILEOUT, ID,
 275             ALIAS, SIGALG, KEYPASS, KEYSTORE,
 276             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 277             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 278         IDENTITYDB(&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
 279             FILEIN, STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 280             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V);
 281 
 282         final String description;
 283         final Option[] options;
 284         final String name;
 285 
 286         String altName;     // &quot;genkey&quot; is altName for &quot;genkeypair&quot;
 287 
 288         Command(String d, Option... o) {
 289             description = d;
 290             options = o;
 291             name = &quot;-&quot; + name().toLowerCase(Locale.ENGLISH);
 292         }
 293         @Override
 294         public String toString() {
 295             return name;
 296         }
 297         public String getAltName() {
 298             return altName;
 299         }
 300         public void setAltName(String altName) {
 301             this.altName = altName;
 302         }
 303         public static Command getCommand(String cmd) {
 304             for (Command c: Command.values()) {
 305                 if (collator.compare(cmd, c.name) == 0
 306                         || (c.altName != null
 307                             &amp;&amp; collator.compare(cmd, c.altName) == 0)) {
 308                     return c;
 309                 }
 310             }
 311             return null;
 312         }
 313     };
 314 
 315     static {
 316         Command.GENKEYPAIR.setAltName(&quot;-genkey&quot;);
 317         Command.IMPORTCERT.setAltName(&quot;-import&quot;);
 318         Command.EXPORTCERT.setAltName(&quot;-export&quot;);
 319         Command.IMPORTPASS.setAltName(&quot;-importpassword&quot;);
 320     }
 321 
 322     // If an option is allowed multiple times, remember to record it
 323     // in the optionsSet.contains() block in parseArgs().
 324     enum Option {
 325         ALIAS(&quot;alias&quot;, &quot;&lt;alias&gt;&quot;, &quot;alias.name.of.the.entry.to.process&quot;),
 326         CURVENAME(&quot;groupname&quot;, &quot;&lt;name&gt;&quot;, &quot;groupname.option.help&quot;),
 327         DESTALIAS(&quot;destalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;destination.alias&quot;),
 328         DESTKEYPASS(&quot;destkeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.key.password&quot;),
 329         DESTKEYSTORE(&quot;destkeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;destination.keystore.name&quot;),
 330         DESTPROTECTED(&quot;destprotected&quot;, null, &quot;destination.keystore.password.protected&quot;),
 331         DESTPROVIDERNAME(&quot;destprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;destination.keystore.provider.name&quot;),
 332         DESTSTOREPASS(&quot;deststorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.keystore.password&quot;),
 333         DESTSTORETYPE(&quot;deststoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;destination.keystore.type&quot;),
 334         DNAME(&quot;dname&quot;, &quot;&lt;name&gt;&quot;, &quot;distinguished.name&quot;),
 335         EXT(&quot;ext&quot;, &quot;&lt;value&gt;&quot;, &quot;X.509.extension&quot;),
 336         FILEOUT(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 337         FILEIN(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 338         ID(&quot;id&quot;, &quot;&lt;id:reason&gt;&quot;, &quot;Serial.ID.of.cert.to.revoke&quot;),
 339         INFILE(&quot;infile&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 340         KEYALG(&quot;keyalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;key.algorithm.name&quot;),
 341         KEYPASS(&quot;keypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;key.password&quot;),
 342         KEYSIZE(&quot;keysize&quot;, &quot;&lt;size&gt;&quot;, &quot;key.bit.size&quot;),
 343         KEYSTORE(&quot;keystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;keystore.name&quot;),
 344         CACERTS(&quot;cacerts&quot;, null, &quot;access.the.cacerts.keystore&quot;),
 345         NEW(&quot;new&quot;, &quot;&lt;arg&gt;&quot;, &quot;new.password&quot;),
 346         NOPROMPT(&quot;noprompt&quot;, null, &quot;do.not.prompt&quot;),
 347         OUTFILE(&quot;outfile&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 348         PROTECTED(&quot;protected&quot;, null, &quot;password.through.protected.mechanism&quot;),
 349         PROVIDERCLASS(&quot;providerclass&quot;, &quot;&lt;class&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;provider.class.option&quot;),
 350         ADDPROVIDER(&quot;addprovider&quot;, &quot;&lt;name&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;addprovider.option&quot;),
 351         PROVIDERNAME(&quot;providername&quot;, &quot;&lt;name&gt;&quot;, &quot;provider.name&quot;),
 352         PROVIDERPATH(&quot;providerpath&quot;, &quot;&lt;list&gt;&quot;, &quot;provider.classpath&quot;),
 353         RFC(&quot;rfc&quot;, null, &quot;output.in.RFC.style&quot;),
 354         SIGALG(&quot;sigalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;signature.algorithm.name&quot;),
 355         SRCALIAS(&quot;srcalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;source.alias&quot;),
 356         SRCKEYPASS(&quot;srckeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.key.password&quot;),
 357         SRCKEYSTORE(&quot;srckeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;source.keystore.name&quot;),
 358         SRCPROTECTED(&quot;srcprotected&quot;, null, &quot;source.keystore.password.protected&quot;),
 359         SRCPROVIDERNAME(&quot;srcprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;source.keystore.provider.name&quot;),
 360         SRCSTOREPASS(&quot;srcstorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.keystore.password&quot;),
 361         SRCSTORETYPE(&quot;srcstoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;source.keystore.type&quot;),
 362         SSLSERVER(&quot;sslserver&quot;, &quot;&lt;server[:port]&gt;&quot;, &quot;SSL.server.host.and.port&quot;),
 363         JARFILE(&quot;jarfile&quot;, &quot;&lt;file&gt;&quot;, &quot;signed.jar.file&quot;),
 364         STARTDATE(&quot;startdate&quot;, &quot;&lt;date&gt;&quot;, &quot;certificate.validity.start.date.time&quot;),
 365         STOREPASS(&quot;storepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;keystore.password&quot;),
 366         STORETYPE(&quot;storetype&quot;, &quot;&lt;type&gt;&quot;, &quot;keystore.type&quot;),
 367         TRUSTCACERTS(&quot;trustcacerts&quot;, null, &quot;trust.certificates.from.cacerts&quot;),
 368         V(&quot;v&quot;, null, &quot;verbose.output&quot;),
 369         VALIDITY(&quot;validity&quot;, &quot;&lt;days&gt;&quot;, &quot;validity.number.of.days&quot;);
 370 
 371         final String name, arg, description;
 372         Option(String name, String arg, String description) {
 373             this.name = name;
 374             this.arg = arg;
 375             this.description = description;
 376         }
 377         @Override
 378         public String toString() {
 379             return &quot;-&quot; + name;
 380         }
 381     };
 382 
 383     private static final String NONE = &quot;NONE&quot;;
 384     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 385     private static final String P12KEYSTORE = &quot;PKCS12&quot;;
 386     private static final String keyAlias = &quot;mykey&quot;;
 387 
 388     // for i18n
 389     private static final java.util.ResourceBundle rb =
 390         java.util.ResourceBundle.getBundle(
 391             &quot;sun.security.tools.keytool.Resources&quot;);
 392     private static final Collator collator = Collator.getInstance();
 393     static {
 394         // this is for case insensitive string comparisons
 395         collator.setStrength(Collator.PRIMARY);
 396     };
 397 
 398     private Main() { }
 399 
 400     public static void main(String[] args) throws Exception {
 401         Main kt = new Main();
 402         kt.run(args, System.out);
 403     }
 404 
 405     private void run(String[] args, PrintStream out) throws Exception {
 406         try {
 407             args = parseArgs(args);
 408             if (command != null) {
 409                 doCommands(out);
 410             }
 411         } catch (Exception e) {
 412             System.out.println(rb.getString(&quot;keytool.error.&quot;) + e);
 413             if (verbose) {
 414                 e.printStackTrace(System.out);
 415             }
 416             if (!debug) {
 417                 System.exit(1);
 418             } else {
 419                 throw e;
 420             }
 421         } finally {
 422             printWeakWarnings(false);
 423             for (char[] pass : passwords) {
 424                 if (pass != null) {
 425                     Arrays.fill(pass, &#39; &#39;);
 426                     pass = null;
 427                 }
 428             }
 429 
 430             if (ksStream != null) {
 431                 ksStream.close();
 432             }
 433         }
 434     }
 435 
 436     /**
 437      * Parse command line arguments.
 438      */
 439     String[] parseArgs(String[] args) throws Exception {
 440 
 441         int i=0;
 442         boolean help = args.length == 0;
 443 
 444         String confFile = null;
 445 
 446         // Records all commands and options set. Used to check dups.
 447         Set&lt;String&gt; optionsSet = new HashSet&lt;&gt;();
 448 
 449         for (i=0; i &lt; args.length; i++) {
 450             String flags = args[i];
 451             if (flags.startsWith(&quot;-&quot;)) {
 452                 String lowerFlags = flags.toLowerCase(Locale.ROOT);
 453                 if (optionsSet.contains(lowerFlags)) {
 454                     switch (lowerFlags) {
 455                         case &quot;-ext&quot;:
 456                         case &quot;-id&quot;:
 457                         case &quot;-provider&quot;:
 458                         case &quot;-addprovider&quot;:
 459                         case &quot;-providerclass&quot;:
 460                         case &quot;-providerarg&quot;:
 461                             // These options are allowed multiple times
 462                             break;
 463                         default:
 464                             weakWarnings.add(String.format(
 465                                     rb.getString(&quot;option.1.set.twice&quot;),
 466                                     lowerFlags));
 467                     }
 468                 } else {
 469                     optionsSet.add(lowerFlags);
 470                 }
 471                 if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 472                     if (i == args.length - 1) {
 473                         errorNeedArgument(flags);
 474                     }
 475                     confFile = args[++i];
 476                 } else {
 477                     Command c = Command.getCommand(flags);
 478                     if (c != null) {
 479                         if (command == null) {
 480                             command = c;
 481                         } else {
 482                             throw new Exception(String.format(
 483                                     rb.getString(&quot;multiple.commands.1.2&quot;),
 484                                     command.name, c.name));
 485                         }
 486                     }
 487                 }
 488             }
 489         }
 490 
 491         if (confFile != null &amp;&amp; command != null) {
 492             args = KeyStoreUtil.expandArgs(&quot;keytool&quot;, confFile,
 493                     command.toString(),
 494                     command.getAltName(), args);
 495         }
 496 
 497         debug = Arrays.stream(args).anyMatch(
 498                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 499 
 500         if (debug) {
 501             // No need to localize debug output
 502             System.out.println(&quot;Command line args: &quot; +
 503                     Arrays.toString(args));
 504         }
 505 
 506         for (i=0; (i &lt; args.length) &amp;&amp; args[i].startsWith(&quot;-&quot;); i++) {
 507 
 508             String flags = args[i];
 509 
 510             // Check if the last option needs an arg
 511             if (i == args.length - 1) {
 512                 for (Option option: Option.values()) {
 513                     // Only options with an arg need to be checked
 514                     if (collator.compare(flags, option.toString()) == 0) {
 515                         if (option.arg != null) errorNeedArgument(flags);
 516                         break;
 517                     }
 518                 }
 519             }
 520 
 521             /*
 522              * Check modifiers
 523              */
 524             String modifier = null;
 525             int pos = flags.indexOf(&#39;:&#39;);
 526             if (pos &gt; 0) {
 527                 modifier = flags.substring(pos+1);
 528                 flags = flags.substring(0, pos);
 529             }
 530 
 531             /*
 532              * command modes
 533              */
 534             Command c = Command.getCommand(flags);
 535 
 536             if (c != null) {
 537                 command = c;
 538             } else if (collator.compare(flags, &quot;--help&quot;) == 0 ||
 539                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 540                        collator.compare(flags, &quot;-?&quot;) == 0 ||
 541                        // -help: legacy.
 542                        collator.compare(flags, &quot;-help&quot;) == 0) {
 543                 help = true;
 544             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 545                 i++;
 546             } else if (collator.compare(flags, &quot;-nowarn&quot;) == 0) {
 547                 nowarn = true;
 548             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 549                 ksfname = args[++i];
 550                 if (new File(ksfname).getCanonicalPath().equals(
 551                         new File(KeyStoreUtil.getCacerts()).getCanonicalPath())) {
 552                     System.err.println(rb.getString(&quot;warning.cacerts.option&quot;));
 553                 }
 554             } else if (collator.compare(flags, &quot;-destkeystore&quot;) == 0) {
 555                 ksfname = args[++i];
 556             } else if (collator.compare(flags, &quot;-cacerts&quot;) == 0) {
 557                 cacerts = true;
 558             } else if (collator.compare(flags, &quot;-storepass&quot;) == 0 ||
 559                     collator.compare(flags, &quot;-deststorepass&quot;) == 0) {
 560                 storePass = getPass(modifier, args[++i]);
 561                 passwords.add(storePass);
 562             } else if (collator.compare(flags, &quot;-storetype&quot;) == 0 ||
 563                     collator.compare(flags, &quot;-deststoretype&quot;) == 0) {
 564                 storetype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 565             } else if (collator.compare(flags, &quot;-srcstorepass&quot;) == 0) {
 566                 srcstorePass = getPass(modifier, args[++i]);
 567                 passwords.add(srcstorePass);
 568             } else if (collator.compare(flags, &quot;-srcstoretype&quot;) == 0) {
 569                 srcstoretype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 570             } else if (collator.compare(flags, &quot;-srckeypass&quot;) == 0) {
 571                 srckeyPass = getPass(modifier, args[++i]);
 572                 passwords.add(srckeyPass);
 573             } else if (collator.compare(flags, &quot;-srcprovidername&quot;) == 0) {
 574                 srcProviderName = args[++i];
 575             } else if (collator.compare(flags, &quot;-providername&quot;) == 0 ||
 576                     collator.compare(flags, &quot;-destprovidername&quot;) == 0) {
 577                 providerName = args[++i];
 578             } else if (collator.compare(flags, &quot;-providerpath&quot;) == 0) {
 579                 pathlist = args[++i];
 580             } else if (collator.compare(flags, &quot;-keypass&quot;) == 0) {
 581                 keyPass = getPass(modifier, args[++i]);
 582                 passwords.add(keyPass);
 583             } else if (collator.compare(flags, &quot;-new&quot;) == 0) {
 584                 newPass = getPass(modifier, args[++i]);
 585                 passwords.add(newPass);
 586             } else if (collator.compare(flags, &quot;-destkeypass&quot;) == 0) {
 587                 destKeyPass = getPass(modifier, args[++i]);
 588                 passwords.add(destKeyPass);
 589             } else if (collator.compare(flags, &quot;-alias&quot;) == 0 ||
 590                     collator.compare(flags, &quot;-srcalias&quot;) == 0) {
 591                 alias = args[++i];
 592             } else if (collator.compare(flags, &quot;-dest&quot;) == 0 ||
 593                     collator.compare(flags, &quot;-destalias&quot;) == 0) {
 594                 dest = args[++i];
 595             } else if (collator.compare(flags, &quot;-dname&quot;) == 0) {
 596                 dname = args[++i];
 597             } else if (collator.compare(flags, &quot;-keysize&quot;) == 0) {
 598                 keysize = Integer.parseInt(args[++i]);
 599             } else if (collator.compare(flags, &quot;-groupname&quot;) == 0) {
 600                 groupName = args[++i];
 601             } else if (collator.compare(flags, &quot;-keyalg&quot;) == 0) {
 602                 keyAlgName = args[++i];
 603             } else if (collator.compare(flags, &quot;-sigalg&quot;) == 0) {
 604                 sigAlgName = args[++i];
 605             } else if (collator.compare(flags, &quot;-startdate&quot;) == 0) {
 606                 startDate = args[++i];
 607             } else if (collator.compare(flags, &quot;-validity&quot;) == 0) {
 608                 validity = Long.parseLong(args[++i]);
 609             } else if (collator.compare(flags, &quot;-ext&quot;) == 0) {
 610                 v3ext.add(args[++i]);
 611             } else if (collator.compare(flags, &quot;-id&quot;) == 0) {
 612                 ids.add(args[++i]);
 613             } else if (collator.compare(flags, &quot;-file&quot;) == 0) {
 614                 filename = args[++i];
 615             } else if (collator.compare(flags, &quot;-infile&quot;) == 0) {
 616                 infilename = args[++i];
 617             } else if (collator.compare(flags, &quot;-outfile&quot;) == 0) {
 618                 outfilename = args[++i];
 619             } else if (collator.compare(flags, &quot;-sslserver&quot;) == 0) {
 620                 sslserver = args[++i];
 621             } else if (collator.compare(flags, &quot;-jarfile&quot;) == 0) {
 622                 jarfile = args[++i];
 623             } else if (collator.compare(flags, &quot;-srckeystore&quot;) == 0) {
 624                 srcksfname = args[++i];
 625             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 626                         collator.compare(flags, &quot;-providerclass&quot;) == 0) {
 627                 if (providerClasses == null) {
 628                     providerClasses = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 629                 }
 630                 String providerClass = args[++i];
 631                 String providerArg = null;
 632 
 633                 if (args.length &gt; (i+1)) {
 634                     flags = args[i+1];
 635                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 636                         if (args.length == (i+2)) errorNeedArgument(flags);
 637                         providerArg = args[i+2];
 638                         i += 2;
 639                     }
 640                 }
 641                 providerClasses.add(
 642                         Pair.of(providerClass, providerArg));
 643             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 644                 if (providers == null) {
 645                     providers = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 646                 }
 647                 String provider = args[++i];
 648                 String providerArg = null;
 649 
 650                 if (args.length &gt; (i+1)) {
 651                     flags = args[i+1];
 652                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 653                         if (args.length == (i+2)) errorNeedArgument(flags);
 654                         providerArg = args[i+2];
 655                         i += 2;
 656                     }
 657                 }
 658                 providers.add(
 659                         Pair.of(provider, providerArg));
 660             }
 661 
 662             /*
 663              * options
 664              */
 665             else if (collator.compare(flags, &quot;-v&quot;) == 0) {
 666                 verbose = true;
 667             } else if (collator.compare(flags, &quot;-debug&quot;) == 0) {
 668                 // Already processed
 669             } else if (collator.compare(flags, &quot;-rfc&quot;) == 0) {
 670                 rfc = true;
 671             } else if (collator.compare(flags, &quot;-noprompt&quot;) == 0) {
 672                 noprompt = true;
 673             } else if (collator.compare(flags, &quot;-trustcacerts&quot;) == 0) {
 674                 trustcacerts = true;
 675             } else if (collator.compare(flags, &quot;-protected&quot;) == 0 ||
 676                     collator.compare(flags, &quot;-destprotected&quot;) == 0) {
 677                 protectedPath = true;
 678             } else if (collator.compare(flags, &quot;-srcprotected&quot;) == 0) {
 679                 srcprotectedPath = true;
 680             } else  {
 681                 System.err.println(rb.getString(&quot;Illegal.option.&quot;) + flags);
 682                 tinyHelp();
 683             }
 684         }
 685 
 686         if (i&lt;args.length) {
 687             System.err.println(rb.getString(&quot;Illegal.option.&quot;) + args[i]);
 688             tinyHelp();
 689         }
 690 
 691         if (command == null) {
 692             if (help) {
 693                 usage();
 694             } else {
 695                 System.err.println(rb.getString(&quot;Usage.error.no.command.provided&quot;));
 696                 tinyHelp();
 697             }
 698         } else if (help) {
 699             usage();
 700             command = null;
 701         }
 702 
 703         return args;
 704     }
 705 
 706     boolean isKeyStoreRelated(Command cmd) {
 707         return cmd != PRINTCERT &amp;&amp; cmd != PRINTCERTREQ;
 708     }
 709 
 710     /**
 711      * Execute the commands.
 712      */
 713     void doCommands(PrintStream out) throws Exception {
 714 
 715         if (cacerts) {
 716             if (ksfname != null || storetype != null) {
 717                 throw new IllegalArgumentException(rb.getString
 718                         (&quot;the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option&quot;));
 719             }
 720             ksfname = KeyStoreUtil.getCacerts();
 721         }
 722 
 723         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 724                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 725             token = true;
 726             if (ksfname == null) {
 727                 ksfname = NONE;
 728             }
 729         }
 730         if (NONE.equals(ksfname)) {
 731             nullStream = true;
 732         }
 733 
 734         if (token &amp;&amp; !nullStream) {
 735             System.err.println(MessageFormat.format(rb.getString
 736                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 737             System.err.println();
 738             tinyHelp();
 739         }
 740 
 741         if (token &amp;&amp;
 742             (command == KEYPASSWD || command == STOREPASSWD)) {
 743             throw new UnsupportedOperationException(MessageFormat.format(rb.getString
 744                         (&quot;.storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}&quot;), storetype));
 745         }
 746 
 747         if (token &amp;&amp; (keyPass != null || newPass != null || destKeyPass != null)) {
 748             throw new IllegalArgumentException(MessageFormat.format(rb.getString
 749                 (&quot;.keypass.and.new.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 750         }
 751 
 752         if (protectedPath) {
 753             if (storePass != null || keyPass != null ||
 754                     newPass != null || destKeyPass != null) {
 755                 throw new IllegalArgumentException(rb.getString
 756                         (&quot;if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 757             }
 758         }
 759 
 760         if (srcprotectedPath) {
 761             if (srcstorePass != null || srckeyPass != null) {
 762                 throw new IllegalArgumentException(rb.getString
 763                         (&quot;if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 764             }
 765         }
 766 
 767         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 768             if (storePass != null || keyPass != null ||
 769                     newPass != null || destKeyPass != null) {
 770                 throw new IllegalArgumentException(rb.getString
 771                         (&quot;if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 772             }
 773         }
 774 
 775         if (KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
 776             if (srcstorePass != null || srckeyPass != null) {
 777                 throw new IllegalArgumentException(rb.getString
 778                         (&quot;if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 779             }
 780         }
 781 
 782         if (validity &lt;= (long)0) {
 783             throw new Exception
 784                 (rb.getString(&quot;Validity.must.be.greater.than.zero&quot;));
 785         }
 786 
 787         // Try to load and install specified provider
 788         if (providers != null) {
 789             for (Pair&lt;String, String&gt; provider : providers) {
 790                 try {
 791                     KeyStoreUtil.loadProviderByName(
 792                             provider.fst, provider.snd);
 793                     if (debug) {
 794                         System.out.println(&quot;loadProviderByName: &quot; + provider.fst);
 795                     }
 796                 } catch (IllegalArgumentException e) {
 797                     throw new Exception(String.format(rb.getString(
 798                             &quot;provider.name.not.found&quot;), provider.fst));
 799                 }
 800             }
 801         }
 802         if (providerClasses != null) {
 803             ClassLoader cl = null;
 804             if (pathlist != null) {
 805                 String path = null;
 806                 path = PathList.appendPath(
 807                         path, System.getProperty(&quot;java.class.path&quot;));
 808                 path = PathList.appendPath(
 809                         path, System.getProperty(&quot;env.class.path&quot;));
 810                 path = PathList.appendPath(path, pathlist);
 811 
 812                 URL[] urls = PathList.pathToURLs(path);
 813                 cl = new URLClassLoader(urls);
 814             } else {
 815                 cl = ClassLoader.getSystemClassLoader();
 816             }
 817             for (Pair&lt;String, String&gt; provider : providerClasses) {
 818                 try {
 819                     KeyStoreUtil.loadProviderByClass(
 820                             provider.fst, provider.snd, cl);
 821                     if (debug) {
 822                         System.out.println(&quot;loadProviderByClass: &quot; + provider.fst);
 823                     }
 824                 } catch (ClassCastException cce) {
 825                     throw new Exception(String.format(rb.getString(
 826                             &quot;provclass.not.a.provider&quot;), provider.fst));
 827                 } catch (IllegalArgumentException e) {
 828                     throw new Exception(String.format(rb.getString(
 829                             &quot;provider.class.not.found&quot;), provider.fst), e.getCause());
 830                 }
 831             }
 832         }
 833 
 834         if (command == LIST &amp;&amp; verbose &amp;&amp; rfc) {
 835             System.err.println(rb.getString
 836                 (&quot;Must.not.specify.both.v.and.rfc.with.list.command&quot;));
 837             tinyHelp();
 838         }
 839 
 840         // Make sure provided passwords are at least 6 characters long
 841         if (command == GENKEYPAIR &amp;&amp; keyPass!=null &amp;&amp; keyPass.length &lt; 6) {
 842             throw new Exception(rb.getString
 843                 (&quot;Key.password.must.be.at.least.6.characters&quot;));
 844         }
 845         if (newPass != null &amp;&amp; newPass.length &lt; 6) {
 846             throw new Exception(rb.getString
 847                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 848         }
 849         if (destKeyPass != null &amp;&amp; destKeyPass.length &lt; 6) {
 850             throw new Exception(rb.getString
 851                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 852         }
 853 
 854         // Set this before inplaceImport check so we can compare name.
 855         if (ksfname == null) {
 856             ksfname = System.getProperty(&quot;user.home&quot;) + File.separator
 857                     + &quot;.keystore&quot;;
 858         }
 859 
 860         KeyStore srcKeyStore = null;
 861         if (command == IMPORTKEYSTORE) {
 862             inplaceImport = inplaceImportCheck();
 863             if (inplaceImport) {
 864                 // We load srckeystore first so we have srcstorePass that
 865                 // can be assigned to storePass
 866                 srcKeyStore = loadSourceKeyStore();
 867                 if (storePass == null) {
 868                     storePass = srcstorePass;
 869                 }
 870             }
 871         }
 872 
 873         // Check if keystore exists.
 874         // If no keystore has been specified at the command line, try to use
 875         // the default, which is located in $HOME/.keystore.
 876         // If the command is &quot;genkey&quot;, &quot;identitydb&quot;, &quot;import&quot;, or &quot;printcert&quot;,
 877         // it is OK not to have a keystore.
 878 
 879         // DO NOT open the existing keystore if this is an in-place import.
 880         // The keystore should be created as brand new.
 881         if (isKeyStoreRelated(command) &amp;&amp; !nullStream &amp;&amp; !inplaceImport) {
 882             try {
 883                 ksfile = new File(ksfname);
 884                 // Check if keystore file is empty
 885                 if (ksfile.exists() &amp;&amp; ksfile.length() == 0) {
 886                     throw new Exception(rb.getString
 887                             (&quot;Keystore.file.exists.but.is.empty.&quot;) + ksfname);
 888                 }
 889                 ksStream = new FileInputStream(ksfile);
 890             } catch (FileNotFoundException e) {
 891                 if (command != GENKEYPAIR &amp;&amp;
 892                         command != GENSECKEY &amp;&amp;
 893                         command != IDENTITYDB &amp;&amp;
 894                         command != IMPORTCERT &amp;&amp;
 895                         command != IMPORTPASS &amp;&amp;
 896                         command != IMPORTKEYSTORE &amp;&amp;
 897                         command != PRINTCRL) {
 898                     throw new Exception(rb.getString
 899                             (&quot;Keystore.file.does.not.exist.&quot;) + ksfname);
 900                 }
 901             }
 902         }
 903 
 904         if ((command == KEYCLONE || command == CHANGEALIAS)
 905                 &amp;&amp; dest == null) {
 906             dest = getAlias(&quot;destination&quot;);
 907             if (&quot;&quot;.equals(dest)) {
 908                 throw new Exception(rb.getString
 909                         (&quot;Must.specify.destination.alias&quot;));
 910             }
 911         }
 912 
 913         if (command == DELETE &amp;&amp; alias == null) {
 914             alias = getAlias(null);
 915             if (&quot;&quot;.equals(alias)) {
 916                 throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
 917             }
 918         }
 919 
 920         // Create new keystore
 921         // Probe for keystore type when filename is available
 922         if (ksfile != null &amp;&amp; ksStream != null &amp;&amp; providerName == null &amp;&amp;
 923                 storetype == null &amp;&amp; !inplaceImport) {
 924             keyStore = KeyStore.getInstance(ksfile, storePass);
 925             storetype = keyStore.getType();
 926             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 927                 isPasswordlessKeyStore = PKCS12KeyStore.isPasswordless(ksfile);
 928             }
 929         } else {
 930             if (storetype == null) {
 931                 storetype = KeyStore.getDefaultType();
 932             }
 933             if (providerName == null) {
 934                 keyStore = KeyStore.getInstance(storetype);
 935             } else {
 936                 keyStore = KeyStore.getInstance(storetype, providerName);
 937             }
 938             // When creating a new pkcs12 file, Do not prompt for storepass
 939             // if certProtectionAlgorithm and macAlgorithm are both NONE.
 940             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 941                 isPasswordlessKeyStore =
 942                         &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 943                                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;))
 944                         &amp;&amp; &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 945                                 &quot;keystore.pkcs12.macAlgorithm&quot;));
 946             }
 947 
 948             /*
 949              * Load the keystore data.
 950              *
 951              * At this point, it&#39;s OK if no keystore password has been provided.
 952              * We want to make sure that we can load the keystore data, i.e.,
 953              * the keystore data has the right format. If we cannot load the
 954              * keystore, why bother asking the user for his or her password?
 955              * Only if we were able to load the keystore, and no keystore
 956              * password has been provided, will we prompt the user for the
 957              * keystore password to verify the keystore integrity.
 958              * This means that the keystore is loaded twice: first load operation
 959              * checks the keystore format, second load operation verifies the
 960              * keystore integrity.
 961              *
 962              * If the keystore password has already been provided (at the
 963              * command line), however, the keystore is loaded only once, and the
 964              * keystore format and integrity are checked &quot;at the same time&quot;.
 965              *
 966              * Null stream keystores are loaded later.
 967              */
 968             if (!nullStream) {
 969                 if (inplaceImport) {
 970                     keyStore.load(null, storePass);
 971                 } else {
 972                     keyStore.load(ksStream, storePass);
 973                 }
 974                 if (ksStream != null) {
 975                     ksStream.close();
 976                 }
 977             }
 978         }
 979 
 980         if (P12KEYSTORE.equalsIgnoreCase(storetype) &amp;&amp; command == KEYPASSWD) {
 981             throw new UnsupportedOperationException(rb.getString
 982                     (&quot;.keypasswd.commands.not.supported.if.storetype.is.PKCS12&quot;));
 983         }
 984 
 985         // All commands that create or modify the keystore require a keystore
 986         // password.
 987 
 988         if (nullStream &amp;&amp; storePass != null) {
 989             keyStore.load(null, storePass);
 990         } else if (!nullStream &amp;&amp; storePass != null) {
 991             // If we are creating a new non nullStream-based keystore,
 992             // insist that the password be at least 6 characters
 993             if (ksStream == null &amp;&amp; storePass.length &lt; 6) {
 994                 throw new Exception(rb.getString
 995                         (&quot;Keystore.password.must.be.at.least.6.characters&quot;));
 996             }
 997         } else if (storePass == null) {
 998             if (!protectedPath &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
 999                     &amp;&amp; isKeyStoreRelated(command)
1000                     &amp;&amp; !isPasswordlessKeyStore) {
1001                 if (command == CERTREQ ||
1002                         command == DELETE ||
1003                         command == GENKEYPAIR ||
1004                         command == GENSECKEY ||
1005                         command == IMPORTCERT ||
1006                         command == IMPORTPASS ||
1007                         command == IMPORTKEYSTORE ||
1008                         command == KEYCLONE ||
1009                         command == CHANGEALIAS ||
1010                         command == SELFCERT ||
1011                         command == STOREPASSWD ||
1012                         command == KEYPASSWD ||
1013                         command == IDENTITYDB) {
1014                     int count = 0;
1015                     do {
1016                         if (command == IMPORTKEYSTORE) {
1017                             System.err.print
1018                                     (rb.getString(&quot;Enter.destination.keystore.password.&quot;));
1019                         } else {
1020                             System.err.print
1021                                     (rb.getString(&quot;Enter.keystore.password.&quot;));
1022                         }
1023                         System.err.flush();
1024                         storePass = Password.readPassword(System.in);
1025                         passwords.add(storePass);
1026 
1027                         // If we are creating a new non nullStream-based keystore,
1028                         // insist that the password be at least 6 characters
1029                         if (!nullStream &amp;&amp; (storePass == null || storePass.length &lt; 6)) {
1030                             System.err.println(rb.getString
1031                                     (&quot;Keystore.password.is.too.short.must.be.at.least.6.characters&quot;));
1032                             storePass = null;
1033                         }
1034 
1035                         // If the keystore file does not exist and needs to be
1036                         // created, the storepass should be prompted twice.
1037                         if (storePass != null &amp;&amp; !nullStream &amp;&amp; ksStream == null) {
1038                             System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1039                             char[] storePassAgain = Password.readPassword(System.in);
1040                             passwords.add(storePassAgain);
1041                             if (!Arrays.equals(storePass, storePassAgain)) {
1042                                 System.err.println
1043                                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1044                                 storePass = null;
1045                             }
1046                         }
1047 
1048                         count++;
1049                     } while ((storePass == null) &amp;&amp; count &lt; 3);
1050 
1051 
1052                     if (storePass == null) {
1053                         System.err.println
1054                                 (rb.getString(&quot;Too.many.failures.try.later&quot;));
1055                         return;
1056                     }
1057                 } else {
1058                     // here we have EXPORTCERT and LIST (info valid until STOREPASSWD)
1059                     if (command != PRINTCRL) {
1060                         System.err.print(rb.getString(&quot;Enter.keystore.password.&quot;));
1061                         System.err.flush();
1062                         storePass = Password.readPassword(System.in);
1063                         passwords.add(storePass);
1064                     }
1065                 }
1066             }
1067 
1068             // Now load a nullStream-based keystore,
1069             // or verify the integrity of an input stream-based keystore
1070             if (nullStream) {
1071                 keyStore.load(null, storePass);
1072             } else if (ksStream != null) {
1073                 ksStream = new FileInputStream(ksfile);
1074                 keyStore.load(ksStream, storePass);
1075                 ksStream.close();
1076             }
1077         }
1078 
1079         if (storePass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1080             MessageFormat form = new MessageFormat(rb.getString(
1081                 &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
1082             if (keyPass != null &amp;&amp; !Arrays.equals(storePass, keyPass)) {
1083                 Object[] source = {&quot;-keypass&quot;};
1084                 System.err.println(form.format(source));
1085                 keyPass = storePass;
1086             }
1087             if (destKeyPass != null &amp;&amp; !Arrays.equals(storePass, destKeyPass)) {
1088                 Object[] source = {&quot;-destkeypass&quot;};
1089                 System.err.println(form.format(source));
1090                 destKeyPass = storePass;
1091             }
1092         }
1093 
1094         // -trustcacerts can only be specified on -importcert.
1095         // Reset it so that warnings on CA cert will remain for
1096         // -printcert, etc.
1097         if (command != IMPORTCERT) {
1098             trustcacerts = false;
1099         }
1100 
1101         if (trustcacerts) {
1102             caks = KeyStoreUtil.getCacertsKeyStore();
1103         }
1104 
1105         // Perform the specified command
1106         if (command == CERTREQ) {
1107             if (filename != null) {
1108                 try (PrintStream ps = new PrintStream(new FileOutputStream
1109                                                       (filename))) {
1110                     doCertReq(alias, sigAlgName, ps);
1111                 }
1112             } else {
1113                 doCertReq(alias, sigAlgName, out);
1114             }
1115             if (verbose &amp;&amp; filename != null) {
1116                 MessageFormat form = new MessageFormat(rb.getString
1117                         (&quot;Certification.request.stored.in.file.filename.&quot;));
1118                 Object[] source = {filename};
1119                 System.err.println(form.format(source));
1120                 System.err.println(rb.getString(&quot;Submit.this.to.your.CA&quot;));
1121             }
1122         } else if (command == DELETE) {
1123             doDeleteEntry(alias);
1124             kssave = true;
1125         } else if (command == EXPORTCERT) {
1126             if (filename != null) {
1127                 try (PrintStream ps = new PrintStream(new FileOutputStream
1128                                                    (filename))) {
1129                     doExportCert(alias, ps);
1130                 }
1131             } else {
1132                 doExportCert(alias, out);
1133             }
1134             if (filename != null) {
1135                 MessageFormat form = new MessageFormat(rb.getString
1136                         (&quot;Certificate.stored.in.file.filename.&quot;));
1137                 Object[] source = {filename};
1138                 System.err.println(form.format(source));
1139             }
1140         } else if (command == GENKEYPAIR) {
1141             if (keyAlgName == null) {
1142                 keyAlgName = &quot;DSA&quot;;
1143                 weakWarnings.add(String.format(rb.getString(
1144                         &quot;keyalg.option.1.missing.warning&quot;), keyAlgName));
1145             }
1146             doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);
1147             kssave = true;
1148         } else if (command == GENSECKEY) {
1149             if (keyAlgName == null) {
1150                 keyAlgName = &quot;DES&quot;;
1151                 weakWarnings.add(String.format(rb.getString(
1152                         &quot;keyalg.option.1.missing.warning&quot;), keyAlgName));
1153             }
1154             doGenSecretKey(alias, keyAlgName, keysize);
1155             kssave = true;
1156         } else if (command == IMPORTPASS) {
1157             if (keyAlgName == null) {
1158                 keyAlgName = &quot;PBE&quot;;
1159             }
1160             // password is stored as a secret key
1161             doGenSecretKey(alias, keyAlgName, keysize);
1162             kssave = true;
1163         } else if (command == IDENTITYDB) {
1164             if (filename != null) {
1165                 try (InputStream inStream = new FileInputStream(filename)) {
1166                     doImportIdentityDatabase(inStream);
1167                 }
1168             } else {
1169                 doImportIdentityDatabase(System.in);
1170             }
1171         } else if (command == IMPORTCERT) {
1172             InputStream inStream = System.in;
1173             if (filename != null) {
1174                 inStream = new FileInputStream(filename);
1175             }
1176             String importAlias = (alias!=null)?alias:keyAlias;
1177             try {
1178                 if (keyStore.entryInstanceOf(
1179                         importAlias, KeyStore.PrivateKeyEntry.class)) {
1180                     kssave = installReply(importAlias, inStream);
1181                     if (kssave) {
1182                         System.err.println(rb.getString
1183                             (&quot;Certificate.reply.was.installed.in.keystore&quot;));
1184                     } else {
1185                         System.err.println(rb.getString
1186                             (&quot;Certificate.reply.was.not.installed.in.keystore&quot;));
1187                     }
1188                 } else if (!keyStore.containsAlias(importAlias) ||
1189                         keyStore.entryInstanceOf(importAlias,
1190                             KeyStore.TrustedCertificateEntry.class)) {
1191                     kssave = addTrustedCert(importAlias, inStream);
1192                     if (kssave) {
1193                         System.err.println(rb.getString
1194                             (&quot;Certificate.was.added.to.keystore&quot;));
1195                     } else {
1196                         System.err.println(rb.getString
1197                             (&quot;Certificate.was.not.added.to.keystore&quot;));
1198                     }
1199                 }
1200             } finally {
1201                 if (inStream != System.in) {
1202                     inStream.close();
1203                 }
1204             }
1205         } else if (command == IMPORTKEYSTORE) {
1206             // When not in-place import, srcKeyStore is not loaded yet.
1207             if (srcKeyStore == null) {
1208                 srcKeyStore = loadSourceKeyStore();
1209             }
1210             doImportKeyStore(srcKeyStore);
1211             kssave = true;
1212         } else if (command == KEYCLONE) {
1213             keyPassNew = newPass;
1214 
1215             // added to make sure only key can go thru
1216             if (alias == null) {
1217                 alias = keyAlias;
1218             }
1219             if (keyStore.containsAlias(alias) == false) {
1220                 MessageFormat form = new MessageFormat
1221                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1222                 Object[] source = {alias};
1223                 throw new Exception(form.format(source));
1224             }
1225             if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
1226                 MessageFormat form = new MessageFormat(rb.getString(
1227                         &quot;Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key&quot;));
1228                 Object[] source = {alias};
1229                 throw new Exception(form.format(source));
1230             }
1231 
1232             doCloneEntry(alias, dest, true);  // Now everything can be cloned
1233             kssave = true;
1234         } else if (command == CHANGEALIAS) {
1235             if (alias == null) {
1236                 alias = keyAlias;
1237             }
1238             doCloneEntry(alias, dest, false);
1239             // in PKCS11, clone a PrivateKeyEntry will delete the old one
1240             if (keyStore.containsAlias(alias)) {
1241                 doDeleteEntry(alias);
1242             }
1243             kssave = true;
1244         } else if (command == KEYPASSWD) {
1245             keyPassNew = newPass;
1246             doChangeKeyPasswd(alias);
1247             kssave = true;
1248         } else if (command == LIST) {
1249             if (storePass == null
1250                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1251                     &amp;&amp; !isPasswordlessKeyStore) {
1252                 printNoIntegrityWarning();
1253             }
1254 
1255             if (alias != null) {
1256                 doPrintEntry(rb.getString(&quot;the.certificate&quot;), alias, out);
1257             } else {
1258                 doPrintEntries(out);
1259             }
1260         } else if (command == PRINTCERT) {
1261             doPrintCert(out);
1262         } else if (command == SELFCERT) {
1263             doSelfCert(alias, dname, sigAlgName);
1264             kssave = true;
1265         } else if (command == STOREPASSWD) {
1266             doChangeStorePasswd();
1267             kssave = true;
1268         } else if (command == GENCERT) {
1269             if (alias == null) {
1270                 alias = keyAlias;
1271             }
1272             InputStream inStream = System.in;
1273             if (infilename != null) {
1274                 inStream = new FileInputStream(infilename);
1275             }
1276             PrintStream ps = null;
1277             if (outfilename != null) {
1278                 ps = new PrintStream(new FileOutputStream(outfilename));
1279                 out = ps;
1280             }
1281             try {
1282                 doGenCert(alias, sigAlgName, inStream, out);
1283             } finally {
1284                 if (inStream != System.in) {
1285                     inStream.close();
1286                 }
1287                 if (ps != null) {
1288                     ps.close();
1289                 }
1290             }
1291         } else if (command == GENCRL) {
1292             if (alias == null) {
1293                 alias = keyAlias;
1294             }
1295             if (filename != null) {
1296                 try (PrintStream ps =
1297                          new PrintStream(new FileOutputStream(filename))) {
1298                     doGenCRL(ps);
1299                 }
1300             } else {
1301                 doGenCRL(out);
1302             }
1303         } else if (command == PRINTCERTREQ) {
1304             if (filename != null) {
1305                 try (InputStream inStream = new FileInputStream(filename)) {
1306                     doPrintCertReq(inStream, out);
1307                 }
1308             } else {
1309                 doPrintCertReq(System.in, out);
1310             }
1311         } else if (command == PRINTCRL) {
1312             doPrintCRL(filename, out);
1313         }
1314 
1315         // If we need to save the keystore, do so.
1316         if (kssave) {
1317             if (verbose) {
1318                 MessageFormat form = new MessageFormat
1319                         (rb.getString(&quot;.Storing.ksfname.&quot;));
1320                 Object[] source = {nullStream ? &quot;keystore&quot; : ksfname};
1321                 System.err.println(form.format(source));
1322             }
1323 
1324             if (token) {
1325                 keyStore.store(null, null);
1326             } else {
1327                 char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1328                 if (nullStream) {
1329                     keyStore.store(null, pass);
1330                 } else {
1331                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
1332                     keyStore.store(bout, pass);
1333                     try (FileOutputStream fout = new FileOutputStream(ksfname)) {
1334                         fout.write(bout.toByteArray());
1335                     }
1336                 }
1337             }
1338         }
1339 
1340         if (isKeyStoreRelated(command)
1341                 &amp;&amp; !token &amp;&amp; !nullStream &amp;&amp; ksfname != null) {
1342 
1343             // JKS storetype warning on the final result keystore
1344             File f = new File(ksfname);
1345             char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1346             if (f.exists()) {
1347                 // Probe for real type. A JKS can be loaded as PKCS12 because
1348                 // DualFormat support, vice versa.
1349                 String realType = storetype;
1350                 try {
1351                     keyStore = KeyStore.getInstance(f, pass);
1352                     realType = keyStore.getType();
1353                     if (realType.equalsIgnoreCase(&quot;JKS&quot;)
1354                             || realType.equalsIgnoreCase(&quot;JCEKS&quot;)) {
1355                         boolean allCerts = true;
1356                         for (String a : Collections.list(keyStore.aliases())) {
1357                             if (!keyStore.entryInstanceOf(
1358                                     a, TrustedCertificateEntry.class)) {
1359                                 allCerts = false;
1360                                 break;
1361                             }
1362                         }
1363                         // Don&#39;t warn for &quot;cacerts&quot; style keystore.
1364                         if (!allCerts) {
1365                             weakWarnings.add(String.format(
1366                                     rb.getString(&quot;jks.storetype.warning&quot;),
1367                                     realType, ksfname));
1368                         }
1369                     }
1370                 } catch (KeyStoreException e) {
1371                     // Probing not supported, therefore cannot be JKS or JCEKS.
1372                     // Skip the legacy type warning at all.
1373                 }
1374                 if (inplaceImport) {
1375                     String realSourceStoreType = srcstoretype;
1376                     try {
1377                         realSourceStoreType = KeyStore.getInstance(
1378                                 new File(inplaceBackupName), srcstorePass).getType();
1379                     } catch (KeyStoreException e) {
1380                         // Probing not supported. Assuming srcstoretype.
1381                     }
1382                     String format =
1383                             realType.equalsIgnoreCase(realSourceStoreType) ?
1384                             rb.getString(&quot;backup.keystore.warning&quot;) :
1385                             rb.getString(&quot;migrate.keystore.warning&quot;);
1386                     weakWarnings.add(
1387                             String.format(format,
1388                                     srcksfname,
1389                                     realSourceStoreType,
1390                                     inplaceBackupName,
1391                                     realType));
1392                 }
1393             }
1394         }
1395     }
1396 
1397     /**
1398      * Generate a certificate: Read PKCS10 request from in, and print
1399      * certificate to out. Use alias as CA, sigAlgName as the signature
1400      * type.
1401      */
1402     private void doGenCert(String alias, String sigAlgName, InputStream in, PrintStream out)
1403             throws Exception {
1404 
1405 
1406         if (keyStore.containsAlias(alias) == false) {
1407             MessageFormat form = new MessageFormat
1408                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1409             Object[] source = {alias};
1410             throw new Exception(form.format(source));
1411         }
1412         Certificate signerCert = keyStore.getCertificate(alias);
1413         byte[] encoded = signerCert.getEncoded();
1414         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1415         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1416                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1417         X500Name issuer = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1418                                            X509CertInfo.DN_NAME);
1419 
1420         Date firstDate = getStartDate(startDate);
1421         Date lastDate = new Date();
1422         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
1423         CertificateValidity interval = new CertificateValidity(firstDate,
1424                                                                lastDate);
1425 
1426         PrivateKey privateKey =
1427                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1428         if (sigAlgName == null) {
1429             sigAlgName = getCompatibleSigAlgName(privateKey);
1430         }
1431         Signature signature = Signature.getInstance(sigAlgName);
1432         signature.initSign(privateKey);
1433 
1434         X509CertInfo info = new X509CertInfo();
1435         AlgorithmParameterSpec params = AlgorithmId
1436                 .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);
1437         AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);
1438         info.set(X509CertInfo.VALIDITY, interval);
1439         info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(
1440                     new java.util.Random().nextInt() &amp; 0x7fffffff));
1441         info.set(X509CertInfo.VERSION,
1442                     new CertificateVersion(CertificateVersion.V3));
1443         info.set(X509CertInfo.ALGORITHM_ID,
1444                     new CertificateAlgorithmId(algID));
1445         info.set(X509CertInfo.ISSUER, issuer);
1446 
1447         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1448         boolean canRead = false;
1449         StringBuffer sb = new StringBuffer();
1450         while (true) {
1451             String s = reader.readLine();
1452             if (s == null) break;
1453             // OpenSSL does not use NEW
1454             //if (s.startsWith(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;)) {
1455             if (s.startsWith(&quot;-----BEGIN&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1456                 canRead = true;
1457             //} else if (s.startsWith(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;)) {
1458             } else if (s.startsWith(&quot;-----END&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1459                 break;
1460             } else if (canRead) {
1461                 sb.append(s);
1462             }
1463         }
1464         byte[] rawReq = Pem.decode(new String(sb));
1465         PKCS10 req = new PKCS10(rawReq);
1466 
1467         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
1468 
1469         info.set(X509CertInfo.KEY, new CertificateX509Key(req.getSubjectPublicKeyInfo()));
1470         info.set(X509CertInfo.SUBJECT,
1471                     dname==null?req.getSubjectName():new X500Name(dname));
1472         CertificateExtensions reqex = null;
1473         Iterator&lt;PKCS10Attribute&gt; attrs = req.getAttributes().getAttributes().iterator();
1474         while (attrs.hasNext()) {
1475             PKCS10Attribute attr = attrs.next();
1476             if (attr.getAttributeId().equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
1477                 reqex = (CertificateExtensions)attr.getAttributeValue();
1478             }
1479         }
1480         CertificateExtensions ext = createV3Extensions(
1481                 reqex,
1482                 null,
1483                 v3ext,
1484                 req.getSubjectPublicKeyInfo(),
1485                 signerCert.getPublicKey());
1486         info.set(X509CertInfo.EXTENSIONS, ext);
1487         X509CertImpl cert = new X509CertImpl(info);
1488         cert.sign(privateKey, params, sigAlgName, null);
1489         dumpCert(cert, out);
1490         for (Certificate ca: keyStore.getCertificateChain(alias)) {
1491             if (ca instanceof X509Certificate) {
1492                 X509Certificate xca = (X509Certificate)ca;
1493                 if (!KeyStoreUtil.isSelfSigned(xca)) {
1494                     dumpCert(xca, out);
1495                 }
1496             }
1497         }
1498 
1499         checkWeak(rb.getString(&quot;the.issuer&quot;), keyStore.getCertificateChain(alias));
1500         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), cert);
1501     }
1502 
1503     private void doGenCRL(PrintStream out)
1504             throws Exception {
1505         if (ids == null) {
1506             throw new Exception(&quot;Must provide -id when -gencrl&quot;);
1507         }
1508         Certificate signerCert = keyStore.getCertificate(alias);
1509         byte[] encoded = signerCert.getEncoded();
1510         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1511         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1512                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1513         X500Name owner = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1514                                                       X509CertInfo.DN_NAME);
1515 
1516         Date firstDate = getStartDate(startDate);
1517         Date lastDate = (Date) firstDate.clone();
1518         lastDate.setTime(lastDate.getTime() + validity*1000*24*60*60);
1519         CertificateValidity interval = new CertificateValidity(firstDate,
1520                                                                lastDate);
1521 
1522 
1523         PrivateKey privateKey =
1524                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1525         if (sigAlgName == null) {
1526             sigAlgName = getCompatibleSigAlgName(privateKey);
1527         }
1528 
1529         X509CRLEntry[] badCerts = new X509CRLEntry[ids.size()];
1530         for (int i=0; i&lt;ids.size(); i++) {
1531             String id = ids.get(i);
1532             int d = id.indexOf(&#39;:&#39;);
1533             if (d &gt;= 0) {
1534                 CRLExtensions ext = new CRLExtensions();
1535                 ext.set(&quot;Reason&quot;, new CRLReasonCodeExtension(Integer.parseInt(id.substring(d+1))));
1536                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(id.substring(0, d)),
1537                         firstDate, ext);
1538             } else {
1539                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(ids.get(i)), firstDate);
1540             }
1541         }
1542         X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts);
1543         crl.sign(privateKey, sigAlgName);
1544         if (rfc) {
1545             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
1546             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(crl.getEncodedInternal()));
1547             out.println(&quot;-----END X509 CRL-----&quot;);
1548         } else {
1549             out.write(crl.getEncodedInternal());
1550         }
1551         checkWeak(rb.getString(&quot;the.generated.crl&quot;), crl, privateKey);
1552     }
1553 
1554     /**
1555      * Creates a PKCS#10 cert signing request, corresponding to the
1556      * keys (and name) associated with a given alias.
1557      */
1558     private void doCertReq(String alias, String sigAlgName, PrintStream out)
1559         throws Exception
1560     {
1561         if (alias == null) {
1562             alias = keyAlias;
1563         }
1564 
1565         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
1566         PrivateKey privKey = (PrivateKey)objs.fst;
1567         if (keyPass == null) {
1568             keyPass = objs.snd;
1569         }
1570 
1571         Certificate cert = keyStore.getCertificate(alias);
1572         if (cert == null) {
1573             MessageFormat form = new MessageFormat
1574                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
1575             Object[] source = {alias};
1576             throw new Exception(form.format(source));
1577         }
1578         PKCS10 request = new PKCS10(cert.getPublicKey());
1579         CertificateExtensions ext = createV3Extensions(null, null, v3ext, cert.getPublicKey(), null);
1580         // Attribute name is not significant
1581         request.getAttributes().setAttribute(X509CertInfo.EXTENSIONS,
1582                 new PKCS10Attribute(PKCS9Attribute.EXTENSION_REQUEST_OID, ext));
1583 
1584         // Construct a Signature object, so that we can sign the request
1585         if (sigAlgName == null) {
1586             sigAlgName = getCompatibleSigAlgName(privKey);
1587         }
1588 
1589         Signature signature = Signature.getInstance(sigAlgName);
1590         signature.initSign(privKey);
1591         AlgorithmParameterSpec params = AlgorithmId
1592                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
1593         if (params != null) {
1594             signature.setParameter(params);
1595         }
1596 
1597         X500Name subject = dname == null?
1598                 new X500Name(((X509Certificate)cert).getSubjectDN().toString()):
1599                 new X500Name(dname);
1600 
1601         // Sign the request and base-64 encode it
1602         request.encodeAndSign(subject, signature);
1603         request.print(out);
1604 
1605         checkWeak(rb.getString(&quot;the.generated.certificate.request&quot;), request);
1606     }
1607 
1608     /**
1609      * Deletes an entry from the keystore.
1610      */
1611     private void doDeleteEntry(String alias) throws Exception {
1612         if (keyStore.containsAlias(alias) == false) {
1613             MessageFormat form = new MessageFormat
1614                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1615             Object[] source = {alias};
1616             throw new Exception(form.format(source));
1617         }
1618         keyStore.deleteEntry(alias);
1619     }
1620 
1621     /**
1622      * Exports a certificate from the keystore.
1623      */
1624     private void doExportCert(String alias, PrintStream out)
1625         throws Exception
1626     {
1627         if (storePass == null
1628                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1629                 &amp;&amp; !isPasswordlessKeyStore) {
1630             printNoIntegrityWarning();
1631         }
1632         if (alias == null) {
1633             alias = keyAlias;
1634         }
1635         if (keyStore.containsAlias(alias) == false) {
1636             MessageFormat form = new MessageFormat
1637                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1638             Object[] source = {alias};
1639             throw new Exception(form.format(source));
1640         }
1641 
1642         X509Certificate cert = (X509Certificate)keyStore.getCertificate(alias);
1643         if (cert == null) {
1644             MessageFormat form = new MessageFormat
1645                 (rb.getString(&quot;Alias.alias.has.no.certificate&quot;));
1646             Object[] source = {alias};
1647             throw new Exception(form.format(source));
1648         }
1649         dumpCert(cert, out);
1650         checkWeak(rb.getString(&quot;the.certificate&quot;), cert);
1651     }
1652 
1653     /**
1654      * Prompt the user for a keypass when generating a key entry.
1655      * @param alias the entry we will set password for
1656      * @param orig the original entry of doing a dup, null if generate new
1657      * @param origPass the password to copy from if user press ENTER
1658      */
1659     private char[] promptForKeyPass(String alias, String orig, char[] origPass) throws Exception{
1660         if (origPass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1661             return origPass;
1662         } else if (!token &amp;&amp; !protectedPath) {
1663             // Prompt for key password
1664             int count;
1665             for (count = 0; count &lt; 3; count++) {
1666                 MessageFormat form = new MessageFormat(rb.getString
1667                         (&quot;Enter.key.password.for.alias.&quot;));
1668                 Object[] source = {alias};
1669                 System.err.print(form.format(source));
1670                 if (origPass != null) {
1671                     System.err.println();
1672                     if (orig == null) {
1673                         System.err.print(rb.getString
1674                                 (&quot;.RETURN.if.same.as.keystore.password.&quot;));
1675                     } else {
1676                         form = new MessageFormat(rb.getString
1677                                 (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
1678                         Object[] src = {orig};
1679                         System.err.print(form.format(src));
1680                     }
1681                 }
1682                 System.err.flush();
1683                 char[] entered = Password.readPassword(System.in);
1684                 passwords.add(entered);
1685                 if (entered == null &amp;&amp; origPass != null) {
1686                     return origPass;
1687                 } else if (entered != null &amp;&amp; entered.length &gt;= 6) {
1688                     System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1689                     char[] passAgain = Password.readPassword(System.in);
1690                     passwords.add(passAgain);
1691                     if (!Arrays.equals(entered, passAgain)) {
1692                         System.err.println
1693                             (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1694                         continue;
1695                     }
1696                     return entered;
1697                 } else {
1698                     System.err.println(rb.getString
1699                         (&quot;Key.password.is.too.short.must.be.at.least.6.characters&quot;));
1700                 }
1701             }
1702             if (count == 3) {
1703                 if (command == KEYCLONE) {
1704                     throw new Exception(rb.getString
1705                         (&quot;Too.many.failures.Key.entry.not.cloned&quot;));
1706                 } else {
1707                     throw new Exception(rb.getString
1708                             (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1709                 }
1710             }
1711         }
1712         return null;    // PKCS11, MSCAPI, or -protected
1713     }
1714 
1715     /*
1716      * Prompt the user for the password credential to be stored.
1717      */
1718     private char[] promptForCredential() throws Exception {
1719         // Handle password supplied via stdin
1720         if (System.console() == null) {
1721             char[] importPass = Password.readPassword(System.in);
1722             passwords.add(importPass);
1723             return importPass;
1724         }
1725 
1726         int count;
1727         for (count = 0; count &lt; 3; count++) {
1728             System.err.print(
1729                 rb.getString(&quot;Enter.the.password.to.be.stored.&quot;));
1730             System.err.flush();
1731             char[] entered = Password.readPassword(System.in);
1732             passwords.add(entered);
1733             System.err.print(rb.getString(&quot;Re.enter.password.&quot;));
1734             char[] passAgain = Password.readPassword(System.in);
1735             passwords.add(passAgain);
1736             if (!Arrays.equals(entered, passAgain)) {
1737                 System.err.println(rb.getString(&quot;They.don.t.match.Try.again&quot;));
1738                 continue;
1739             }
1740             return entered;
1741         }
1742 
1743         if (count == 3) {
1744             throw new Exception(rb.getString
1745                 (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1746         }
1747 
1748         return null;
1749     }
1750 
1751     /**
1752      * Creates a new secret key.
1753      */
1754     private void doGenSecretKey(String alias, String keyAlgName,
1755                               int keysize)
1756         throws Exception
1757     {
1758         if (alias == null) {
1759             alias = keyAlias;
1760         }
1761         if (keyStore.containsAlias(alias)) {
1762             MessageFormat form = new MessageFormat(rb.getString
1763                 (&quot;Secret.key.not.generated.alias.alias.already.exists&quot;));
1764             Object[] source = {alias};
1765             throw new Exception(form.format(source));
1766         }
1767 
1768         // Use the keystore&#39;s default PBE algorithm for entry protection
1769         boolean useDefaultPBEAlgorithm = true;
1770         SecretKey secKey = null;
1771 
1772         if (keyAlgName.toUpperCase(Locale.ENGLISH).startsWith(&quot;PBE&quot;)) {
1773             SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBE&quot;);
1774 
1775             // User is prompted for PBE credential
1776             secKey =
1777                 factory.generateSecret(new PBEKeySpec(promptForCredential()));
1778 
1779             // Check whether a specific PBE algorithm was specified
1780             if (!&quot;PBE&quot;.equalsIgnoreCase(keyAlgName)) {
1781                 useDefaultPBEAlgorithm = false;
1782             }
1783 
1784             if (verbose) {
1785                 MessageFormat form = new MessageFormat(rb.getString(
1786                     &quot;Generated.keyAlgName.secret.key&quot;));
1787                 Object[] source =
1788                     {useDefaultPBEAlgorithm ? &quot;PBE&quot; : secKey.getAlgorithm()};
1789                 System.err.println(form.format(source));
1790             }
1791         } else {
1792             KeyGenerator keygen = KeyGenerator.getInstance(keyAlgName);
1793             if (keysize == -1) {
1794                 if (&quot;DES&quot;.equalsIgnoreCase(keyAlgName)) {
1795                     keysize = 56;
1796                 } else if (&quot;DESede&quot;.equalsIgnoreCase(keyAlgName)) {
1797                     keysize = 168;
1798                 } else {
1799                     throw new Exception(rb.getString
1800                         (&quot;Please.provide.keysize.for.secret.key.generation&quot;));
1801                 }
1802             }
1803             keygen.init(keysize);
1804             secKey = keygen.generateKey();
1805 
1806             MessageFormat form = new MessageFormat(rb.getString
1807                 (&quot;Generated.keysize.bit.keyAlgName.secret.key&quot;));
1808             Object[] source = {keysize,
1809                                 secKey.getAlgorithm()};
1810             System.err.println(form.format(source));
1811         }
1812 
1813         if (keyPass == null) {
1814             keyPass = promptForKeyPass(alias, null, storePass);
1815         }
1816 
1817         if (useDefaultPBEAlgorithm) {
1818             keyStore.setKeyEntry(alias, secKey, keyPass, null);
1819         } else {
1820             keyStore.setEntry(alias, new KeyStore.SecretKeyEntry(secKey),
1821                 new KeyStore.PasswordProtection(keyPass, keyAlgName, null));
1822         }
1823     }
1824 
1825     /**
1826      * If no signature algorithm was specified at the command line,
1827      * we choose one that is compatible with the selected private key
1828      */
1829     private static String getCompatibleSigAlgName(PrivateKey key)
1830             throws Exception {
1831         String result = AlgorithmId.getDefaultSigAlgForKey(key);
1832         if (result != null) {
1833             return result;
1834         } else {
1835             throw new Exception(rb.getString
1836                     (&quot;Cannot.derive.signature.algorithm&quot;));
1837         }
1838     }
1839 
1840     /**
1841      * Creates a new key pair and self-signed certificate.
1842      */
1843     private void doGenKeyPair(String alias, String dname, String keyAlgName,
1844                               int keysize, String groupName, String sigAlgName)
1845         throws Exception
1846     {
1847         if (groupName != null) {
1848             if (keysize != -1) {
1849                 throw new Exception(rb.getString(&quot;groupname.keysize.coexist&quot;));
1850             }
1851         } else {
1852             if (keysize == -1) {
1853                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1854                     keysize = SecurityProviderConstants.DEF_EC_KEY_SIZE;
1855                 } else if (&quot;RSA&quot;.equalsIgnoreCase(keyAlgName)) {
1856                     keysize = SecurityProviderConstants.DEF_RSA_KEY_SIZE;
1857                 } else if (&quot;DSA&quot;.equalsIgnoreCase(keyAlgName)) {
1858                     keysize = SecurityProviderConstants.DEF_DSA_KEY_SIZE;
1859                 }
1860             } else {
1861                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1862                     weakWarnings.add(String.format(
1863                             rb.getString(&quot;deprecate.keysize.for.ec&quot;),
1864                             ecGroupNameForSize(keysize)));
1865                 }
1866             }
1867         }
1868 
1869         if (alias == null) {
1870             alias = keyAlias;
1871         }
1872 
1873         if (keyStore.containsAlias(alias)) {
1874             MessageFormat form = new MessageFormat(rb.getString
1875                 (&quot;Key.pair.not.generated.alias.alias.already.exists&quot;));
1876             Object[] source = {alias};
1877             throw new Exception(form.format(source));
1878         }
1879 
1880         CertAndKeyGen keypair =
1881                 new CertAndKeyGen(keyAlgName, sigAlgName, providerName);
1882 
1883 
1884         // If DN is provided, parse it. Otherwise, prompt the user for it.
1885         X500Name x500Name;
1886         if (dname == null) {
1887             printWeakWarnings(true);
1888             x500Name = getX500Name();
1889         } else {
1890             x500Name = new X500Name(dname);
1891         }
1892 
1893         if (groupName != null) {
1894             keypair.generate(groupName);
1895         } else {
1896             // This covers keysize both specified and unspecified
1897             keypair.generate(keysize);
1898         }
1899 
1900         PrivateKey privKey = keypair.getPrivateKey();
1901 
1902         CertificateExtensions ext = createV3Extensions(
1903                 null,
1904                 null,
1905                 v3ext,
1906                 keypair.getPublicKeyAnyway(),
1907                 null);
1908 
1909         X509Certificate[] chain = new X509Certificate[1];
1910         chain[0] = keypair.getSelfCertificate(
1911                 x500Name, getStartDate(startDate), validity*24L*60L*60L, ext);
1912 
1913         MessageFormat form = new MessageFormat(rb.getString
1914             (&quot;Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for&quot;));
1915         Object[] source = {
1916                 groupName == null ? keysize : KeyUtil.getKeySize(privKey),
1917                 fullDisplayAlgName(privKey),
1918                 chain[0].getSigAlgName(),
1919                 validity,
1920                 x500Name};
1921         System.err.println(form.format(source));
1922 
1923         if (keyPass == null) {
1924             keyPass = promptForKeyPass(alias, null, storePass);
1925         }
1926         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), chain[0]);
1927         keyStore.setKeyEntry(alias, privKey, keyPass, chain);
1928     }
1929 
1930     private String ecGroupNameForSize(int size) throws Exception {
1931         AlgorithmParameters ap = AlgorithmParameters.getInstance(&quot;EC&quot;);
1932         ap.init(new ECKeySizeParameterSpec(size));
1933         // The following line assumes the toString value is &quot;name (oid)&quot;
1934         return ap.toString().split(&quot; &quot;)[0];
1935     }
1936 
1937     /**
1938      * Clones an entry
1939      * @param orig original alias
1940      * @param dest destination alias
1941      * @changePassword if the password can be changed
1942      */
1943     private void doCloneEntry(String orig, String dest, boolean changePassword)
1944         throws Exception
1945     {
1946         if (orig == null) {
1947             orig = keyAlias;
1948         }
1949 
1950         if (keyStore.containsAlias(dest)) {
1951             MessageFormat form = new MessageFormat
1952                 (rb.getString(&quot;Destination.alias.dest.already.exists&quot;));
1953             Object[] source = {dest};
1954             throw new Exception(form.format(source));
1955         }
1956 
1957         Pair&lt;Entry,char[]&gt; objs = recoverEntry(keyStore, orig, storePass, keyPass);
1958         Entry entry = objs.fst;
1959         keyPass = objs.snd;
1960 
1961         PasswordProtection pp = null;
1962 
1963         if (keyPass != null) {  // protected
1964             if (!changePassword || P12KEYSTORE.equalsIgnoreCase(storetype)) {
1965                 keyPassNew = keyPass;
1966             } else {
1967                 if (keyPassNew == null) {
1968                     keyPassNew = promptForKeyPass(dest, orig, keyPass);
1969                 }
1970             }
1971             pp = new PasswordProtection(keyPassNew);
1972         }
1973         keyStore.setEntry(dest, entry, pp);
1974     }
1975 
1976     /**
1977      * Changes a key password.
1978      */
1979     private void doChangeKeyPasswd(String alias) throws Exception
1980     {
1981 
1982         if (alias == null) {
1983             alias = keyAlias;
1984         }
1985         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
1986         Key privKey = objs.fst;
1987         if (keyPass == null) {
1988             keyPass = objs.snd;
1989         }
1990 
1991         if (keyPassNew == null) {
1992             MessageFormat form = new MessageFormat
1993                 (rb.getString(&quot;key.password.for.alias.&quot;));
1994             Object[] source = {alias};
1995             keyPassNew = getNewPasswd(form.format(source), keyPass);
1996         }
1997         keyStore.setKeyEntry(alias, privKey, keyPassNew,
1998                              keyStore.getCertificateChain(alias));
1999     }
2000 
2001     /**
2002      * Imports a JDK 1.1-style identity database. We can only store one
2003      * certificate per identity, because we use the identity&#39;s name as the
2004      * alias (which references a keystore entry), and aliases must be unique.
2005      */
2006     private void doImportIdentityDatabase(InputStream in)
2007         throws Exception
2008     {
2009         System.err.println(rb.getString
2010             (&quot;No.entries.from.identity.database.added&quot;));
2011     }
2012 
2013     /**
2014      * Prints a single keystore entry.
2015      */
2016     private void doPrintEntry(String label, String alias, PrintStream out)
2017         throws Exception
2018     {
2019         if (keyStore.containsAlias(alias) == false) {
2020             MessageFormat form = new MessageFormat
2021                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
2022             Object[] source = {alias};
2023             throw new Exception(form.format(source));
2024         }
2025 
2026         if (verbose || rfc || debug) {
2027             MessageFormat form = new MessageFormat
2028                 (rb.getString(&quot;Alias.name.alias&quot;));
2029             Object[] source = {alias};
2030             out.println(form.format(source));
2031 
2032             if (!token) {
2033                 form = new MessageFormat(rb.getString
2034                     (&quot;Creation.date.keyStore.getCreationDate.alias.&quot;));
2035                 Object[] src = {keyStore.getCreationDate(alias)};
2036                 out.println(form.format(src));
2037             }
2038         } else {
2039             if (!token) {
2040                 MessageFormat form = new MessageFormat
2041                     (rb.getString(&quot;alias.keyStore.getCreationDate.alias.&quot;));
2042                 Object[] source = {alias, keyStore.getCreationDate(alias)};
2043                 out.print(form.format(source));
2044             } else {
2045                 MessageFormat form = new MessageFormat
2046                     (rb.getString(&quot;alias.&quot;));
2047                 Object[] source = {alias};
2048                 out.print(form.format(source));
2049             }
2050         }
2051 
2052         if (keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
2053             if (verbose || rfc || debug) {
2054                 Object[] source = {&quot;SecretKeyEntry&quot;};
2055                 out.println(new MessageFormat(
2056                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2057             } else {
2058                 out.println(&quot;SecretKeyEntry, &quot;);
2059             }
2060         } else if (keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
2061             if (verbose || rfc || debug) {
2062                 Object[] source = {&quot;PrivateKeyEntry&quot;};
2063                 out.println(new MessageFormat(
2064                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2065             } else {
2066                 out.println(&quot;PrivateKeyEntry, &quot;);
2067             }
2068 
2069             // Get the chain
2070             Certificate[] chain = keyStore.getCertificateChain(alias);
2071             if (chain != null) {
2072                 if (verbose || rfc || debug) {
2073                     out.println(rb.getString
2074                         (&quot;Certificate.chain.length.&quot;) + chain.length);
2075                     for (int i = 0; i &lt; chain.length; i ++) {
2076                         MessageFormat form = new MessageFormat
2077                                 (rb.getString(&quot;Certificate.i.1.&quot;));
2078                         Object[] source = {(i + 1)};
2079                         out.println(form.format(source));
2080                         if (verbose &amp;&amp; (chain[i] instanceof X509Certificate)) {
2081                             printX509Cert((X509Certificate)(chain[i]), out);
2082                         } else if (debug) {
2083                             out.println(chain[i].toString());
2084                         } else {
2085                             dumpCert(chain[i], out);
2086                         }
2087                         checkWeak(label, chain[i]);
2088                     }
2089                 } else {
2090                     // Print the digest of the user cert only
2091                     out.println
2092                         (rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;) +
2093                         getCertFingerPrint(&quot;SHA-256&quot;, chain[0]));
2094                     checkWeak(label, chain);
2095                 }
2096             } else {
2097                 out.println(rb.getString
2098                         (&quot;Certificate.chain.length.&quot;) + 0);
2099             }
2100         } else if (keyStore.entryInstanceOf(alias,
2101                 KeyStore.TrustedCertificateEntry.class)) {
2102             // We have a trusted certificate entry
2103             Certificate cert = keyStore.getCertificate(alias);
2104             Object[] source = {&quot;trustedCertEntry&quot;};
2105             String mf = new MessageFormat(
2106                     rb.getString(&quot;Entry.type.type.&quot;)).format(source) + &quot;\n&quot;;
2107             if (verbose &amp;&amp; (cert instanceof X509Certificate)) {
2108                 out.println(mf);
2109                 printX509Cert((X509Certificate)cert, out);
2110             } else if (rfc) {
2111                 out.println(mf);
2112                 dumpCert(cert, out);
2113             } else if (debug) {
2114                 out.println(cert.toString());
2115             } else {
2116                 out.println(&quot;trustedCertEntry, &quot;);
2117                 out.println(rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;)
2118                             + getCertFingerPrint(&quot;SHA-256&quot;, cert));
2119             }
2120             checkWeak(label, cert);
2121         } else {
2122             out.println(rb.getString(&quot;Unknown.Entry.Type&quot;));
2123         }
2124     }
2125 
2126     boolean inplaceImportCheck() throws Exception {
2127         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2128                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2129             return false;
2130         }
2131 
2132         if (srcksfname != null) {
2133             File srcksfile = new File(srcksfname);
2134             if (srcksfile.exists() &amp;&amp; srcksfile.length() == 0) {
2135                 throw new Exception(rb.getString
2136                         (&quot;Source.keystore.file.exists.but.is.empty.&quot;) +
2137                         srcksfname);
2138             }
2139             if (srcksfile.getCanonicalFile()
2140                     .equals(new File(ksfname).getCanonicalFile())) {
2141                 return true;
2142             } else {
2143                 // Informational, especially if destkeystore is not
2144                 // provided, which default to ~/.keystore.
2145                 System.err.println(String.format(rb.getString(
2146                         &quot;importing.keystore.status&quot;), srcksfname, ksfname));
2147                 return false;
2148             }
2149         } else {
2150             throw new Exception(rb.getString
2151                     (&quot;Please.specify.srckeystore&quot;));
2152         }
2153     }
2154 
2155     /**
2156      * Load the srckeystore from a stream, used in -importkeystore
2157      * @return the src KeyStore
2158      */
2159     KeyStore loadSourceKeyStore() throws Exception {
2160 
2161         InputStream is = null;
2162         File srcksfile = null;
2163         boolean srcIsPasswordless = false;
2164 
2165         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2166                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2167             if (!NONE.equals(srcksfname)) {
2168                 System.err.println(MessageFormat.format(rb.getString
2169                     (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), srcstoretype));
2170                 System.err.println();
2171                 tinyHelp();
2172             }
2173         } else {
2174             srcksfile = new File(srcksfname);
2175             is = new FileInputStream(srcksfile);
2176         }
2177 
2178         KeyStore store;
2179         try {
2180             // Probe for keystore type when filename is available
2181             if (srcksfile != null &amp;&amp; is != null &amp;&amp; srcProviderName == null &amp;&amp;
2182                     srcstoretype == null) {
2183                 store = KeyStore.getInstance(srcksfile, srcstorePass);
2184                 srcstoretype = store.getType();
2185                 if (srcstoretype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
2186                     srcIsPasswordless = PKCS12KeyStore.isPasswordless(srcksfile);
2187                 }
2188             } else {
2189                 if (srcstoretype == null) {
2190                     srcstoretype = KeyStore.getDefaultType();
2191                 }
2192                 if (srcProviderName == null) {
2193                     store = KeyStore.getInstance(srcstoretype);
2194                 } else {
2195                     store = KeyStore.getInstance(srcstoretype, srcProviderName);
2196                 }
2197             }
2198 
2199             if (srcstorePass == null
2200                     &amp;&amp; !srcprotectedPath
2201                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)
2202                     &amp;&amp; !srcIsPasswordless) {
2203                 System.err.print(rb.getString(&quot;Enter.source.keystore.password.&quot;));
2204                 System.err.flush();
2205                 srcstorePass = Password.readPassword(System.in);
2206                 passwords.add(srcstorePass);
2207             }
2208 
2209             // always let keypass be storepass when using pkcs12
2210             if (P12KEYSTORE.equalsIgnoreCase(srcstoretype)) {
2211                 if (srckeyPass != null &amp;&amp; srcstorePass != null &amp;&amp;
2212                         !Arrays.equals(srcstorePass, srckeyPass)) {
2213                     MessageFormat form = new MessageFormat(rb.getString(
2214                         &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
2215                     Object[] source = {&quot;-srckeypass&quot;};
2216                     System.err.println(form.format(source));
2217                     srckeyPass = srcstorePass;
2218                 }
2219             }
2220 
2221             store.load(is, srcstorePass);   // &quot;is&quot; already null in PKCS11
2222         } finally {
2223             if (is != null) {
2224                 is.close();
2225             }
2226         }
2227 
2228         if (srcstorePass == null
2229                 &amp;&amp; !srcIsPasswordless
2230                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2231             // anti refactoring, copied from printNoIntegrityWarning(),
2232             // but change 2 lines
2233             System.err.println();
2234             System.err.println(rb.getString
2235                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2236             System.err.println(rb.getString
2237                 (&quot;.The.integrity.of.the.information.stored.in.the.srckeystore.&quot;));
2238             System.err.println(rb.getString
2239                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2240             System.err.println();
2241         }
2242 
2243         return store;
2244     }
2245 
2246     /**
2247      * import all keys and certs from importkeystore.
2248      * keep alias unchanged if no name conflict, otherwise, prompt.
2249      * keep keypass unchanged for keys
2250      */
2251     private void doImportKeyStore(KeyStore srcKS) throws Exception {
2252 
2253         if (alias != null) {
2254             doImportKeyStoreSingle(srcKS, alias);
2255         } else {
2256             if (dest != null || srckeyPass != null) {
2257                 throw new Exception(rb.getString(
2258                         &quot;if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified&quot;));
2259             }
2260             doImportKeyStoreAll(srcKS);
2261         }
2262 
2263         if (inplaceImport) {
2264             // Backup to file.old or file.old2...
2265             // The keystore is not rewritten yet now.
2266             for (int n = 1; /* forever */; n++) {
2267                 inplaceBackupName = srcksfname + &quot;.old&quot; + (n == 1 ? &quot;&quot; : n);
2268                 File bkFile = new File(inplaceBackupName);
2269                 if (!bkFile.exists()) {
2270                     Files.copy(Path.of(srcksfname), bkFile.toPath());
2271                     break;
2272                 }
2273             }
2274 
2275         }
2276 
2277         /*
2278          * Information display rule of -importkeystore
2279          * 1. inside single, shows failure
2280          * 2. inside all, shows sucess
2281          * 3. inside all where there is a failure, prompt for continue
2282          * 4. at the final of all, shows summary
2283          */
2284     }
2285 
2286     /**
2287      * Import a single entry named alias from srckeystore
2288      * @return  1 if the import action succeed
2289      *          0 if user choose to ignore an alias-dumplicated entry
2290      *          2 if setEntry throws Exception
2291      */
2292     private int doImportKeyStoreSingle(KeyStore srckeystore, String alias)
2293             throws Exception {
2294 
2295         String newAlias = (dest==null) ? alias : dest;
2296 
2297         if (keyStore.containsAlias(newAlias)) {
2298             Object[] source = {alias};
2299             if (noprompt) {
2300                 System.err.println(new MessageFormat(rb.getString(
2301                         &quot;Warning.Overwriting.existing.alias.alias.in.destination.keystore&quot;)).format(source));
2302             } else {
2303                 String reply = getYesNoReply(new MessageFormat(rb.getString(
2304                         &quot;Existing.entry.alias.alias.exists.overwrite.no.&quot;)).format(source));
2305                 if (&quot;NO&quot;.equals(reply)) {
2306                     newAlias = inputStringFromStdin(rb.getString
2307                             (&quot;Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.&quot;));
2308                     if (&quot;&quot;.equals(newAlias)) {
2309                         System.err.println(new MessageFormat(rb.getString(
2310                                 &quot;Entry.for.alias.alias.not.imported.&quot;)).format(
2311                                 source));
2312                         return 0;
2313                     }
2314                 }
2315             }
2316         }
2317 
2318         Pair&lt;Entry,char[]&gt; objs = recoverEntry(srckeystore, alias, srcstorePass, srckeyPass);
2319         Entry entry = objs.fst;
2320 
2321         PasswordProtection pp = null;
2322 
2323         // According to keytool.html, &quot;The destination entry will be protected
2324         // using destkeypass. If destkeypass is not provided, the destination
2325         // entry will be protected with the source entry password.&quot;
2326         // so always try to protect with destKeyPass.
2327         char[] newPass = null;
2328         if (destKeyPass != null) {
2329             newPass = destKeyPass;
2330             pp = new PasswordProtection(destKeyPass);
2331         } else if (objs.snd != null) {
2332             newPass = P12KEYSTORE.equalsIgnoreCase(storetype) ?
2333                     storePass : objs.snd;
2334             pp = new PasswordProtection(newPass);
2335         }
2336 
2337         try {
2338             Certificate c = srckeystore.getCertificate(alias);
2339             if (c != null) {
2340                 checkWeak(&quot;&lt;&quot; + newAlias + &quot;&gt;&quot;, c);
2341             }
2342             keyStore.setEntry(newAlias, entry, pp);
2343             // Place the check so that only successful imports are blocked.
2344             // For example, we don&#39;t block a failed SecretEntry import.
2345             if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2346                 if (newPass != null &amp;&amp; !Arrays.equals(newPass, storePass)) {
2347                     throw new Exception(rb.getString(
2348                             &quot;The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.&quot;));
2349                 }
2350             }
2351             return 1;
2352         } catch (KeyStoreException kse) {
2353             Object[] source2 = {alias, kse.toString()};
2354             MessageFormat form = new MessageFormat(rb.getString(
2355                     &quot;Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.&quot;));
2356             System.err.println(form.format(source2));
2357             return 2;
2358         }
2359     }
2360 
2361     private void doImportKeyStoreAll(KeyStore srckeystore) throws Exception {
2362 
2363         int ok = 0;
2364         int count = srckeystore.size();
2365         for (Enumeration&lt;String&gt; e = srckeystore.aliases();
2366                                         e.hasMoreElements(); ) {
2367             String alias = e.nextElement();
2368             int result = doImportKeyStoreSingle(srckeystore, alias);
2369             if (result == 1) {
2370                 ok++;
2371                 Object[] source = {alias};
2372                 MessageFormat form = new MessageFormat(rb.getString(&quot;Entry.for.alias.alias.successfully.imported.&quot;));
2373                 System.err.println(form.format(source));
2374             } else if (result == 2) {
2375                 if (!noprompt) {
2376                     String reply = getYesNoReply(&quot;Do you want to quit the import process? [no]:  &quot;);
2377                     if (&quot;YES&quot;.equals(reply)) {
2378                         break;
2379                     }
2380                 }
2381             }
2382         }
2383         Object[] source = {ok, count-ok};
2384         MessageFormat form = new MessageFormat(rb.getString(
2385                 &quot;Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled&quot;));
2386         System.err.println(form.format(source));
2387     }
2388 
2389     /**
2390      * Prints all keystore entries.
2391      */
2392     private void doPrintEntries(PrintStream out)
2393         throws Exception
2394     {
2395         out.println(rb.getString(&quot;Keystore.type.&quot;) + keyStore.getType());
2396         out.println(rb.getString(&quot;Keystore.provider.&quot;) +
2397                 keyStore.getProvider().getName());
2398         out.println();
2399 
2400         MessageFormat form;
2401         form = (keyStore.size() == 1) ?
2402                 new MessageFormat(rb.getString
2403                         (&quot;Your.keystore.contains.keyStore.size.entry&quot;)) :
2404                 new MessageFormat(rb.getString
2405                         (&quot;Your.keystore.contains.keyStore.size.entries&quot;));
2406         Object[] source = {keyStore.size()};
2407         out.println(form.format(source));
2408         out.println();
2409 
2410         for (Enumeration&lt;String&gt; e = keyStore.aliases();
2411                                         e.hasMoreElements(); ) {
2412             String alias = e.nextElement();
2413             doPrintEntry(&quot;&lt;&quot; + alias + &quot;&gt;&quot;, alias, out);
2414             if (verbose || rfc) {
2415                 out.println(rb.getString(&quot;NEWLINE&quot;));
2416                 out.println(rb.getString
2417                         (&quot;STAR&quot;));
2418                 out.println(rb.getString
2419                         (&quot;STARNN&quot;));
2420             }
2421         }
2422     }
2423 
2424     private static &lt;T&gt; Iterable&lt;T&gt; e2i(final Enumeration&lt;T&gt; e) {
2425         return new Iterable&lt;T&gt;() {
2426             @Override
2427             public Iterator&lt;T&gt; iterator() {
2428                 return new Iterator&lt;T&gt;() {
2429                     @Override
2430                     public boolean hasNext() {
2431                         return e.hasMoreElements();
2432                     }
2433                     @Override
2434                     public T next() {
2435                         return e.nextElement();
2436                     }
2437                     public void remove() {
2438                         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
2439                     }
2440                 };
2441             }
2442         };
2443     }
2444 
2445     /**
2446      * Loads CRLs from a source. This method is also called in JarSigner.
2447      * @param src the source, which means System.in if null, or a URI,
2448      *        or a bare file path name
2449      */
2450     public static Collection&lt;? extends CRL&gt; loadCRLs(String src) throws Exception {
2451         InputStream in = null;
2452         URI uri = null;
2453         if (src == null) {
2454             in = System.in;
2455         } else {
2456             try {
2457                 uri = new URI(src);
2458                 if (uri.getScheme().equals(&quot;ldap&quot;)) {
2459                     // No input stream for LDAP
2460                 } else {
2461                     in = uri.toURL().openStream();
2462                 }
2463             } catch (Exception e) {
2464                 try {
2465                     in = new FileInputStream(src);
2466                 } catch (Exception e2) {
2467                     if (uri == null || uri.getScheme() == null) {
2468                         throw e2;   // More likely a bare file path
2469                     } else {
2470                         throw e;    // More likely a protocol or network problem
2471                     }
2472                 }
2473             }
2474         }
2475         if (in != null) {
2476             try {
2477                 // Read the full stream before feeding to X509Factory,
2478                 // otherwise, keytool -gencrl | keytool -printcrl
2479                 // might not work properly, since -gencrl is slow
2480                 // and there&#39;s no data in the pipe at the beginning.
2481                 ByteArrayOutputStream bout = new ByteArrayOutputStream();
2482                 byte[] b = new byte[4096];
2483                 while (true) {
2484                     int len = in.read(b);
2485                     if (len &lt; 0) break;
2486                     bout.write(b, 0, len);
2487                 }
2488                 return CertificateFactory.getInstance(&quot;X509&quot;).generateCRLs(
2489                         new ByteArrayInputStream(bout.toByteArray()));
2490             } finally {
2491                 if (in != System.in) {
2492                     in.close();
2493                 }
2494             }
2495         } else {    // must be LDAP, and uri is not null
2496             URICertStoreParameters params =
2497                 new URICertStoreParameters(uri);
2498             CertStore s = CertStore.getInstance(&quot;LDAP&quot;, params);
2499             return s.getCRLs(new X509CRLSelector());
2500         }
2501     }
2502 
2503     /**
2504      * Returns CRLs described in a X509Certificate&#39;s CRLDistributionPoints
2505      * Extension. Only those containing a general name of type URI are read.
2506      */
2507     public static List&lt;CRL&gt; readCRLsFromCert(X509Certificate cert)
2508             throws Exception {
2509         List&lt;CRL&gt; crls = new ArrayList&lt;&gt;();
2510         CRLDistributionPointsExtension ext =
2511                 X509CertImpl.toImpl(cert).getCRLDistributionPointsExtension();
2512         if (ext == null) return crls;
2513         List&lt;DistributionPoint&gt; distPoints =
2514                 ext.get(CRLDistributionPointsExtension.POINTS);
2515         for (DistributionPoint o: distPoints) {
2516             GeneralNames names = o.getFullName();
2517             if (names != null) {
2518                 for (GeneralName name: names.names()) {
2519                     if (name.getType() == GeneralNameInterface.NAME_URI) {
2520                         URIName uriName = (URIName)name.getName();
2521                         for (CRL crl: loadCRLs(uriName.getName())) {
2522                             if (crl instanceof X509CRL) {
2523                                 crls.add((X509CRL)crl);
2524                             }
2525                         }
2526                         break;  // Different name should point to same CRL
2527                     }
2528                 }
2529             }
2530         }
2531         return crls;
2532     }
2533 
2534     private static String verifyCRL(KeyStore ks, CRL crl)
2535             throws Exception {
2536         X509CRLImpl xcrl = (X509CRLImpl)crl;
2537         X500Principal issuer = xcrl.getIssuerX500Principal();
2538         for (String s: e2i(ks.aliases())) {
2539             Certificate cert = ks.getCertificate(s);
2540             if (cert instanceof X509Certificate) {
2541                 X509Certificate xcert = (X509Certificate)cert;
2542                 if (xcert.getSubjectX500Principal().equals(issuer)) {
2543                     try {
2544                         ((X509CRLImpl)crl).verify(cert.getPublicKey());
2545                         return s;
2546                     } catch (Exception e) {
2547                     }
2548                 }
2549             }
2550         }
2551         return null;
2552     }
2553 
2554     private void doPrintCRL(String src, PrintStream out)
2555             throws Exception {
2556         for (CRL crl: loadCRLs(src)) {
2557             printCRL(crl, out);
2558             String issuer = null;
2559             Certificate signer = null;
2560             if (caks != null) {
2561                 issuer = verifyCRL(caks, crl);
2562                 if (issuer != null) {
2563                     signer = caks.getCertificate(issuer);
2564                     out.printf(rb.getString(
2565                             &quot;verified.by.s.in.s.weak&quot;),
2566                             issuer,
2567                             &quot;cacerts&quot;,
2568                             withWeak(signer.getPublicKey()));
2569                     out.println();
2570                 }
2571             }
2572             if (issuer == null &amp;&amp; keyStore != null) {
2573                 issuer = verifyCRL(keyStore, crl);
2574                 if (issuer != null) {
2575                     signer = keyStore.getCertificate(issuer);
2576                     out.printf(rb.getString(
2577                             &quot;verified.by.s.in.s.weak&quot;),
2578                             issuer,
2579                             &quot;keystore&quot;,
2580                             withWeak(signer.getPublicKey()));
2581                     out.println();
2582                 }
2583             }
2584             if (issuer == null) {
2585                 out.println(rb.getString
2586                         (&quot;STAR&quot;));
2587                 out.println(rb.getString
2588                         (&quot;warning.not.verified.make.sure.keystore.is.correct&quot;));
2589                 out.println(rb.getString
2590                         (&quot;STARNN&quot;));
2591             }
2592             checkWeak(rb.getString(&quot;the.crl&quot;), crl, signer == null ? null : signer.getPublicKey());
2593         }
2594     }
2595 
2596     private void printCRL(CRL crl, PrintStream out)
2597             throws Exception {
2598         X509CRL xcrl = (X509CRL)crl;
2599         if (rfc) {
2600             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
2601             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(xcrl.getEncoded()));
2602             out.println(&quot;-----END X509 CRL-----&quot;);
2603         } else {
2604             String s;
2605             if (crl instanceof X509CRLImpl) {
2606                 X509CRLImpl x509crl = (X509CRLImpl) crl;
2607                 s = x509crl.toStringWithAlgName(withWeak(&quot;&quot; + x509crl.getSigAlgId()));
2608             } else {
2609                 s = crl.toString();
2610             }
2611             out.println(s);
2612         }
2613     }
2614 
2615     private void doPrintCertReq(InputStream in, PrintStream out)
2616             throws Exception {
2617 
2618         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
2619         StringBuffer sb = new StringBuffer();
2620         boolean started = false;
2621         while (true) {
2622             String s = reader.readLine();
2623             if (s == null) break;
2624             if (!started) {
2625                 if (s.startsWith(&quot;-----&quot;)) {
2626                     started = true;
2627                 }
2628             } else {
2629                 if (s.startsWith(&quot;-----&quot;)) {
2630                     break;
2631                 }
2632                 sb.append(s);
2633             }
2634         }
2635         PKCS10 req = new PKCS10(Pem.decode(new String(sb)));
2636 
2637         PublicKey pkey = req.getSubjectPublicKeyInfo();
2638         out.printf(rb.getString(&quot;PKCS.10.with.weak&quot;),
2639                 req.getSubjectName(),
2640                 pkey.getFormat(),
2641                 withWeak(pkey),
2642                 withWeak(req.getSigAlg()));
2643         for (PKCS10Attribute attr: req.getAttributes().getAttributes()) {
2644             ObjectIdentifier oid = attr.getAttributeId();
2645             if (oid.equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
2646                 CertificateExtensions exts = (CertificateExtensions)attr.getAttributeValue();
2647                 if (exts != null) {
2648                     printExtensions(rb.getString(&quot;Extension.Request.&quot;), exts, out);
2649                 }
2650             } else {
2651                 out.println(&quot;Attribute: &quot; + attr.getAttributeId());
2652                 PKCS9Attribute pkcs9Attr =
2653                         new PKCS9Attribute(attr.getAttributeId(),
2654                                            attr.getAttributeValue());
2655                 out.print(pkcs9Attr.getName() + &quot;: &quot;);
2656                 Object attrVal = attr.getAttributeValue();
2657                 out.println(attrVal instanceof String[] ?
2658                             Arrays.toString((String[]) attrVal) :
2659                             attrVal);
2660             }
2661         }
2662         if (debug) {
2663             out.println(req);   // Just to see more, say, public key length...
2664         }
2665         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
2666     }
2667 
2668     /**
2669      * Reads a certificate (or certificate chain) and prints its contents in
2670      * a human readable format.
2671      */
2672     private void printCertFromStream(InputStream in, PrintStream out)
2673         throws Exception
2674     {
2675         Collection&lt;? extends Certificate&gt; c = null;
2676         try {
2677             c = generateCertificates(in);
2678         } catch (CertificateException ce) {
2679             throw new Exception(rb.getString(&quot;Failed.to.parse.input&quot;), ce);
2680         }
2681         if (c.isEmpty()) {
2682             throw new Exception(rb.getString(&quot;Empty.input&quot;));
2683         }
2684         Certificate[] certs = c.toArray(new Certificate[c.size()]);
2685         for (int i=0; i&lt;certs.length; i++) {
2686             X509Certificate x509Cert = null;
2687             try {
2688                 x509Cert = (X509Certificate)certs[i];
2689             } catch (ClassCastException cce) {
2690                 throw new Exception(rb.getString(&quot;Not.X.509.certificate&quot;));
2691             }
2692             if (certs.length &gt; 1) {
2693                 MessageFormat form = new MessageFormat
2694                         (rb.getString(&quot;Certificate.i.1.&quot;));
2695                 Object[] source = {i + 1};
2696                 out.println(form.format(source));
2697             }
2698             if (rfc)
2699                 dumpCert(x509Cert, out);
2700             else
2701                 printX509Cert(x509Cert, out);
2702             if (i &lt; (certs.length-1)) {
2703                 out.println();
2704             }
2705             checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i, certs.length), x509Cert);
2706         }
2707     }
2708 
2709     private Collection&lt;? extends Certificate&gt; generateCertificates(InputStream in)
2710             throws CertificateException, IOException {
2711         byte[] data = in.readAllBytes();
2712         try {
2713             return CertificateFactory.getInstance(&quot;X.509&quot;)
2714                     .generateCertificates(new ByteArrayInputStream(data));
2715         } catch (CertificateException e) {
2716             if (providerName != null) {
2717                 try {
2718                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2719                             .generateCertificates(new ByteArrayInputStream(data));
2720                 } catch (Exception e2) {
2721                     e.addSuppressed(e2);
2722                 }
2723             }
2724             throw e;
2725         }
2726     }
2727 
2728     private Certificate generateCertificate(InputStream in)
2729             throws CertificateException, IOException {
2730         byte[] data = in.readAllBytes();
2731         try {
2732             return CertificateFactory.getInstance(&quot;X.509&quot;)
2733                     .generateCertificate(new ByteArrayInputStream(data));
2734         } catch (CertificateException e) {
2735             if (providerName != null) {
2736                 try {
2737                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2738                             .generateCertificate(new ByteArrayInputStream(data));
2739                 } catch (Exception e2) {
2740                     e.addSuppressed(e2);
2741                 }
2742             }
2743             throw e;
2744         }
2745     }
2746 
2747     private static String oneInMany(String label, int i, int num) {
2748         if (num == 1) {
2749             return label;
2750         } else {
2751             return String.format(rb.getString(&quot;one.in.many&quot;), label, i+1, num);
2752         }
2753     }
2754 
2755     private void doPrintCert(final PrintStream out) throws Exception {
2756         if (jarfile != null) {
2757             // reset &quot;jdk.certpath.disabledAlgorithms&quot; security property
2758             // to be able to read jars which were signed with weak algorithms
2759             Security.setProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS, &quot;&quot;);
2760 
2761             JarFile jf = new JarFile(jarfile, true);
2762             Enumeration&lt;JarEntry&gt; entries = jf.entries();
2763             Set&lt;CodeSigner&gt; ss = new HashSet&lt;&gt;();
2764             byte[] buffer = new byte[8192];
2765             int pos = 0;
2766             while (entries.hasMoreElements()) {
2767                 JarEntry je = entries.nextElement();
2768                 try (InputStream is = jf.getInputStream(je)) {
2769                     while (is.read(buffer) != -1) {
2770                         // we just read. this will throw a SecurityException
2771                         // if a signature/digest check fails. This also
2772                         // populate the signers
2773                     }
2774                 }
2775                 CodeSigner[] signers = je.getCodeSigners();
2776                 if (signers != null) {
2777                     for (CodeSigner signer: signers) {
2778                         if (!ss.contains(signer)) {
2779                             ss.add(signer);
2780                             out.printf(rb.getString(&quot;Signer.d.&quot;), ++pos);
2781                             out.println();
2782                             out.println();
2783                             out.println(rb.getString(&quot;Signature.&quot;));
2784                             out.println();
2785 
2786                             List&lt;? extends Certificate&gt; certs
2787                                     = signer.getSignerCertPath().getCertificates();
2788                             int cc = 0;
2789                             for (Certificate cert: certs) {
2790                                 X509Certificate x = (X509Certificate)cert;
2791                                 if (rfc) {
2792                                     out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2793                                     dumpCert(x, out);
2794                                 } else {
2795                                     printX509Cert(x, out);
2796                                 }
2797                                 out.println();
2798                                 checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), cc++, certs.size()), x);
2799                             }
2800                             Timestamp ts = signer.getTimestamp();
2801                             if (ts != null) {
2802                                 out.println(rb.getString(&quot;Timestamp.&quot;));
2803                                 out.println();
2804                                 certs = ts.getSignerCertPath().getCertificates();
2805                                 cc = 0;
2806                                 for (Certificate cert: certs) {
2807                                     X509Certificate x = (X509Certificate)cert;
2808                                     if (rfc) {
2809                                         out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2810                                         dumpCert(x, out);
2811                                     } else {
2812                                         printX509Cert(x, out);
2813                                     }
2814                                     out.println();
2815                                     checkWeak(oneInMany(rb.getString(&quot;the.tsa.certificate&quot;), cc++, certs.size()), x);
2816                                 }
2817                             }
2818                         }
2819                     }
2820                 }
2821             }
2822             jf.close();
2823             if (ss.isEmpty()) {
2824                 out.println(rb.getString(&quot;Not.a.signed.jar.file&quot;));
2825             }
2826         } else if (sslserver != null) {
2827             CertStore cs = SSLServerCertStore.getInstance(new URI(&quot;https://&quot; + sslserver));
2828             Collection&lt;? extends Certificate&gt; chain;
2829             try {
2830                 chain = cs.getCertificates(null);
2831                 if (chain.isEmpty()) {
2832                     // If the certs are not retrieved, we consider it an error
2833                     // even if the URL connection is successful.
2834                     throw new Exception(rb.getString(
2835                                         &quot;No.certificate.from.the.SSL.server&quot;));
2836                 }
2837             } catch (CertStoreException cse) {
2838                 if (cse.getCause() instanceof IOException) {
2839                     throw new Exception(rb.getString(
2840                                         &quot;No.certificate.from.the.SSL.server&quot;),
2841                                         cse.getCause());
2842                 } else {
2843                     throw cse;
2844                 }
2845             }
2846 
2847             int i = 0;
2848             for (Certificate cert : chain) {
2849                 try {
2850                     if (rfc) {
2851                         dumpCert(cert, out);
2852                     } else {
2853                         out.println(&quot;Certificate #&quot; + i);
2854                         out.println(&quot;====================================&quot;);
2855                         printX509Cert((X509Certificate)cert, out);
2856                         out.println();
2857                     }
2858                     checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i++, chain.size()), cert);
2859                 } catch (Exception e) {
2860                     if (debug) {
2861                         e.printStackTrace();
2862                     }
2863                 }
2864             }
2865         } else {
2866             if (filename != null) {
2867                 try (FileInputStream inStream = new FileInputStream(filename)) {
2868                     printCertFromStream(inStream, out);
2869                 }
2870             } else {
2871                 printCertFromStream(System.in, out);
2872             }
2873         }
2874     }
2875 
2876     private void doChangeStorePasswd() throws Exception {
2877         storePassNew = newPass;
2878         if (storePassNew == null) {
2879             storePassNew = getNewPasswd(&quot;keystore password&quot;, storePass);
2880         }
2881         if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2882             // When storetype is PKCS12, we need to change all keypass as well
2883             for (String alias : Collections.list(keyStore.aliases())) {
2884                 if (!keyStore.isCertificateEntry(alias)) {
2885                     // keyPass should be either null or same with storePass,
2886                     // but keep it in case one day we want to &quot;normalize&quot;
2887                     // a PKCS12 keystore having different passwords.
2888                     Pair&lt;Entry, char[]&gt; objs
2889                             = recoverEntry(keyStore, alias, storePass, keyPass);
2890                     keyStore.setEntry(alias, objs.fst,
2891                             new PasswordProtection(storePassNew));
2892                 }
2893             }
2894         }
2895     }
2896 
2897     /**
2898      * Creates a self-signed certificate, and stores it as a single-element
2899      * certificate chain.
2900      */
2901     private void doSelfCert(String alias, String dname, String sigAlgName)
2902         throws Exception
2903     {
2904         if (alias == null) {
2905             alias = keyAlias;
2906         }
2907 
2908         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
2909         PrivateKey privKey = (PrivateKey)objs.fst;
2910         if (keyPass == null)
2911             keyPass = objs.snd;
2912 
2913         // Determine the signature algorithm
2914         if (sigAlgName == null) {
2915             sigAlgName = getCompatibleSigAlgName(privKey);
2916         }
2917 
2918         // Get the old certificate
2919         Certificate oldCert = keyStore.getCertificate(alias);
2920         if (oldCert == null) {
2921             MessageFormat form = new MessageFormat
2922                 (rb.getString(&quot;alias.has.no.public.key&quot;));
2923             Object[] source = {alias};
2924             throw new Exception(form.format(source));
2925         }
2926         if (!(oldCert instanceof X509Certificate)) {
2927             MessageFormat form = new MessageFormat
2928                 (rb.getString(&quot;alias.has.no.X.509.certificate&quot;));
2929             Object[] source = {alias};
2930             throw new Exception(form.format(source));
2931         }
2932 
2933         // convert to X509CertImpl, so that we can modify selected fields
2934         // (no public APIs available yet)
2935         byte[] encoded = oldCert.getEncoded();
2936         X509CertImpl certImpl = new X509CertImpl(encoded);
2937         X509CertInfo certInfo = (X509CertInfo)certImpl.get(X509CertImpl.NAME
2938                                                            + &quot;.&quot; +
2939                                                            X509CertImpl.INFO);
2940 
2941         // Extend its validity
2942         Date firstDate = getStartDate(startDate);
2943         Date lastDate = new Date();
2944         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
2945         CertificateValidity interval = new CertificateValidity(firstDate,
2946                                                                lastDate);
2947         certInfo.set(X509CertInfo.VALIDITY, interval);
2948 
2949         // Make new serial number
2950         certInfo.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(
2951                     new java.util.Random().nextInt() &amp; 0x7fffffff));
2952 
2953         // Set owner and issuer fields
2954         X500Name owner;
2955         if (dname == null) {
2956             // Get the owner name from the certificate
2957             owner = (X500Name)certInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
2958                                            X509CertInfo.DN_NAME);
2959         } else {
2960             // Use the owner name specified at the command line
2961             owner = new X500Name(dname);
2962             certInfo.set(X509CertInfo.SUBJECT + &quot;.&quot; +
2963                          X509CertInfo.DN_NAME, owner);
2964         }
2965         // Make issuer same as owner (self-signed!)
2966         certInfo.set(X509CertInfo.ISSUER + &quot;.&quot; +
2967                      X509CertInfo.DN_NAME, owner);
2968 
2969         // The inner and outer signature algorithms have to match.
2970         // The way we achieve that is really ugly, but there seems to be no
2971         // other solution: We first sign the cert, then retrieve the
2972         // outer sigalg and use it to set the inner sigalg
2973         X509CertImpl newCert = new X509CertImpl(certInfo);
2974         AlgorithmParameterSpec params = AlgorithmId
2975                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
2976         newCert.sign(privKey, params, sigAlgName, null);
2977         AlgorithmId sigAlgid = (AlgorithmId)newCert.get(X509CertImpl.SIG_ALG);
2978         certInfo.set(CertificateAlgorithmId.NAME + &quot;.&quot; +
2979                      CertificateAlgorithmId.ALGORITHM, sigAlgid);
2980 
2981         certInfo.set(X509CertInfo.VERSION,
2982                         new CertificateVersion(CertificateVersion.V3));
2983 
2984         CertificateExtensions ext = createV3Extensions(
2985                 null,
2986                 (CertificateExtensions)certInfo.get(X509CertInfo.EXTENSIONS),
2987                 v3ext,
2988                 oldCert.getPublicKey(),
2989                 null);
2990         certInfo.set(X509CertInfo.EXTENSIONS, ext);
2991         // Sign the new certificate
2992         newCert = new X509CertImpl(certInfo);
2993         newCert.sign(privKey, params, sigAlgName, null);
2994 
2995         // Store the new certificate as a single-element certificate chain
2996         keyStore.setKeyEntry(alias, privKey,
2997                              (keyPass != null) ? keyPass : storePass,
2998                              new Certificate[] { newCert } );
2999 
3000         if (verbose) {
3001             System.err.println(rb.getString(&quot;New.certificate.self.signed.&quot;));
3002             System.err.print(newCert.toString());
3003             System.err.println();
3004         }
3005     }
3006 
3007     /**
3008      * Processes a certificate reply from a certificate authority.
3009      *
3010      * &lt;p&gt;Builds a certificate chain on top of the certificate reply,
3011      * using trusted certificates from the keystore. The chain is complete
3012      * after a self-signed certificate has been encountered. The self-signed
3013      * certificate is considered a root certificate authority, and is stored
3014      * at the end of the chain.
3015      *
3016      * &lt;p&gt;The newly generated chain replaces the old chain associated with the
3017      * key entry.
3018      *
3019      * @return true if the certificate reply was installed, otherwise false.
3020      */
3021     private boolean installReply(String alias, InputStream in)
3022         throws Exception
3023     {
3024         if (alias == null) {
3025             alias = keyAlias;
3026         }
3027 
3028         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
3029         PrivateKey privKey = (PrivateKey)objs.fst;
3030         if (keyPass == null) {
3031             keyPass = objs.snd;
3032         }
3033 
3034         Certificate userCert = keyStore.getCertificate(alias);
3035         if (userCert == null) {
3036             MessageFormat form = new MessageFormat
3037                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
3038             Object[] source = {alias};
3039             throw new Exception(form.format(source));
3040         }
3041 
3042         // Read the certificates in the reply
3043         Collection&lt;? extends Certificate&gt; c = generateCertificates(in);
3044         if (c.isEmpty()) {
3045             throw new Exception(rb.getString(&quot;Reply.has.no.certificates&quot;));
3046         }
3047         Certificate[] replyCerts = c.toArray(new Certificate[c.size()]);
3048         Certificate[] newChain;
3049         if (replyCerts.length == 1) {
3050             // single-cert reply
3051             newChain = establishCertChain(userCert, replyCerts[0]);
3052         } else {
3053             // cert-chain reply (e.g., PKCS#7)
3054             newChain = validateReply(alias, userCert, replyCerts);
3055         }
3056 
3057         // Now store the newly established chain in the keystore. The new
3058         // chain replaces the old one. The chain can be null if user chooses no.
3059         if (newChain != null) {
3060             keyStore.setKeyEntry(alias, privKey,
3061                                  (keyPass != null) ? keyPass : storePass,
3062                                  newChain);
3063             return true;
3064         } else {
3065             return false;
3066         }
3067     }
3068 
3069     /**
3070      * Imports a certificate and adds it to the list of trusted certificates.
3071      *
3072      * @return true if the certificate was added, otherwise false.
3073      */
3074     private boolean addTrustedCert(String alias, InputStream in)
3075         throws Exception
3076     {
3077         if (alias == null) {
3078             throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
3079         }
3080         if (keyStore.containsAlias(alias)) {
3081             MessageFormat form = new MessageFormat(rb.getString
3082                 (&quot;Certificate.not.imported.alias.alias.already.exists&quot;));
3083             Object[] source = {alias};
3084             throw new Exception(form.format(source));
3085         }
3086 
3087         // Read the certificate
3088         X509Certificate cert = null;
3089         try {
3090             cert = (X509Certificate)generateCertificate(in);
3091         } catch (ClassCastException | CertificateException ce) {
3092             throw new Exception(rb.getString(&quot;Input.not.an.X.509.certificate&quot;));
3093         }
3094 
3095         if (noprompt) {
3096             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3097             keyStore.setCertificateEntry(alias, cert);
3098             return true;
3099         }
3100 
3101         // if certificate is self-signed, make sure it verifies
3102         boolean selfSigned = false;
3103         if (KeyStoreUtil.isSelfSigned(cert)) {
3104             cert.verify(cert.getPublicKey());
3105             selfSigned = true;
3106         }
3107 
3108         // check if cert already exists in keystore
3109         String reply = null;
3110         String trustalias = keyStore.getCertificateAlias(cert);
3111         if (trustalias != null) {
3112             MessageFormat form = new MessageFormat(rb.getString
3113                 (&quot;Certificate.already.exists.in.keystore.under.alias.trustalias.&quot;));
3114             Object[] source = {trustalias};
3115             System.err.println(form.format(source));
3116             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3117             printWeakWarnings(true);
3118             reply = getYesNoReply
3119                 (rb.getString(&quot;Do.you.still.want.to.add.it.no.&quot;));
3120         } else if (selfSigned) {
3121             if (trustcacerts &amp;&amp; (caks != null) &amp;&amp;
3122                     ((trustalias=caks.getCertificateAlias(cert)) != null)) {
3123                 MessageFormat form = new MessageFormat(rb.getString
3124                         (&quot;Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.&quot;));
3125                 Object[] source = {trustalias};
3126                 System.err.println(form.format(source));
3127                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3128                 printWeakWarnings(true);
3129                 reply = getYesNoReply
3130                         (rb.getString(&quot;Do.you.still.want.to.add.it.to.your.own.keystore.no.&quot;));
3131             }
3132             if (trustalias == null) {
3133                 // Print the cert and ask user if they really want to add
3134                 // it to their keystore
3135                 printX509Cert(cert, System.out);
3136                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3137                 printWeakWarnings(true);
3138                 reply = getYesNoReply
3139                         (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3140             }
3141         }
3142         if (reply != null) {
3143             if (&quot;YES&quot;.equals(reply)) {
3144                 keyStore.setCertificateEntry(alias, cert);
3145                 return true;
3146             } else {
3147                 return false;
3148             }
3149         }
3150 
3151         // Not found in this keystore and not self-signed
3152         // Try to establish trust chain
3153         try {
3154             Certificate[] chain = establishCertChain(null, cert);
3155             if (chain != null) {
3156                 keyStore.setCertificateEntry(alias, cert);
3157                 return true;
3158             }
3159         } catch (Exception e) {
3160             // Print the cert and ask user if they really want to add it to
3161             // their keystore
3162             printX509Cert(cert, System.out);
3163             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3164             printWeakWarnings(true);
3165             reply = getYesNoReply
3166                 (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3167             if (&quot;YES&quot;.equals(reply)) {
3168                 keyStore.setCertificateEntry(alias, cert);
3169                 return true;
3170             } else {
3171                 return false;
3172             }
3173         }
3174 
3175         return false;
3176     }
3177 
3178     /**
3179      * Prompts user for new password. New password must be different from
3180      * old one.
3181      *
3182      * @param prompt the message that gets prompted on the screen
3183      * @param oldPasswd the current (i.e., old) password
3184      */
3185     private char[] getNewPasswd(String prompt, char[] oldPasswd)
3186         throws Exception
3187     {
3188         char[] entered = null;
3189         char[] reentered = null;
3190 
3191         for (int count = 0; count &lt; 3; count++) {
3192             MessageFormat form = new MessageFormat
3193                 (rb.getString(&quot;New.prompt.&quot;));
3194             Object[] source = {prompt};
3195             System.err.print(form.format(source));
3196             entered = Password.readPassword(System.in);
3197             passwords.add(entered);
3198             if (entered == null || entered.length &lt; 6) {
3199                 System.err.println(rb.getString
3200                     (&quot;Password.is.too.short.must.be.at.least.6.characters&quot;));
3201             } else if (Arrays.equals(entered, oldPasswd)) {
3202                 System.err.println(rb.getString(&quot;Passwords.must.differ&quot;));
3203             } else {
3204                 form = new MessageFormat
3205                         (rb.getString(&quot;Re.enter.new.prompt.&quot;));
3206                 Object[] src = {prompt};
3207                 System.err.print(form.format(src));
3208                 reentered = Password.readPassword(System.in);
3209                 passwords.add(reentered);
3210                 if (!Arrays.equals(entered, reentered)) {
3211                     System.err.println
3212                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
3213                 } else {
3214                     Arrays.fill(reentered, &#39; &#39;);
3215                     return entered;
3216                 }
3217             }
3218             if (entered != null) {
3219                 Arrays.fill(entered, &#39; &#39;);
3220                 entered = null;
3221             }
3222             if (reentered != null) {
3223                 Arrays.fill(reentered, &#39; &#39;);
3224                 reentered = null;
3225             }
3226         }
3227         throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3228     }
3229 
3230     /**
3231      * Prompts user for alias name.
3232      * @param prompt the {0} of &quot;Enter {0} alias name:  &quot; in prompt line
3233      * @return the string entered by the user, without the \n at the end
3234      */
3235     private String getAlias(String prompt) throws Exception {
3236         if (prompt != null) {
3237             MessageFormat form = new MessageFormat
3238                 (rb.getString(&quot;Enter.prompt.alias.name.&quot;));
3239             Object[] source = {prompt};
3240             System.err.print(form.format(source));
3241         } else {
3242             System.err.print(rb.getString(&quot;Enter.alias.name.&quot;));
3243         }
3244         return (new BufferedReader(new InputStreamReader(
3245                                         System.in))).readLine();
3246     }
3247 
3248     /**
3249      * Prompts user for an input string from the command line (System.in)
3250      * @prompt the prompt string printed
3251      * @return the string entered by the user, without the \n at the end
3252      */
3253     private String inputStringFromStdin(String prompt) throws Exception {
3254         System.err.print(prompt);
3255         return (new BufferedReader(new InputStreamReader(
3256                                         System.in))).readLine();
3257     }
3258 
3259     /**
3260      * Prompts user for key password. User may select to choose the same
3261      * password (&lt;code&gt;otherKeyPass&lt;/code&gt;) as for &lt;code&gt;otherAlias&lt;/code&gt;.
3262      */
3263     private char[] getKeyPasswd(String alias, String otherAlias,
3264                                 char[] otherKeyPass)
3265         throws Exception
3266     {
3267         int count = 0;
3268         char[] keyPass = null;
3269 
3270         do {
3271             if (otherKeyPass != null) {
3272                 MessageFormat form = new MessageFormat(rb.getString
3273                         (&quot;Enter.key.password.for.alias.&quot;));
3274                 Object[] source = {alias};
3275                 System.err.println(form.format(source));
3276 
3277                 form = new MessageFormat(rb.getString
3278                         (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
3279                 Object[] src = {otherAlias};
3280                 System.err.print(form.format(src));
3281             } else {
3282                 MessageFormat form = new MessageFormat(rb.getString
3283                         (&quot;Enter.key.password.for.alias.&quot;));
3284                 Object[] source = {alias};
3285                 System.err.print(form.format(source));
3286             }
3287             System.err.flush();
3288             keyPass = Password.readPassword(System.in);
3289             passwords.add(keyPass);
3290             if (keyPass == null) {
3291                 keyPass = otherKeyPass;
3292             }
3293             count++;
3294         } while ((keyPass == null) &amp;&amp; count &lt; 3);
3295 
3296         if (keyPass == null) {
3297             throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3298         }
3299 
3300         return keyPass;
3301     }
3302 
3303     private String withWeak(String alg) {
3304         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, alg, null)) {
3305             return alg;
3306         } else {
3307             return String.format(rb.getString(&quot;with.weak&quot;), alg);
3308         }
3309     }
3310 
3311     private String fullDisplayAlgName(Key key) {
3312         String result = key.getAlgorithm();
3313         if (key instanceof ECKey) {
3314             ECParameterSpec paramSpec = ((ECKey) key).getParams();
3315             if (paramSpec instanceof NamedCurve) {
3316                 result += &quot; (&quot; + paramSpec.toString().split(&quot; &quot;)[0] + &quot;)&quot;;
3317             }
3318         }
3319         return result;
3320     }
3321 
3322     private String withWeak(Key key) {
3323         int kLen = KeyUtil.getKeySize(key);
3324         String displayAlg = fullDisplayAlgName(key);
3325         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
3326             if (kLen &gt;= 0) {
3327                 return String.format(rb.getString(&quot;key.bit&quot;), kLen, displayAlg);
3328             } else {
3329                 return String.format(rb.getString(&quot;unknown.size.1&quot;), displayAlg);
3330             }
3331         } else {
3332             return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen, displayAlg);
3333         }
3334     }
3335 
3336     /**
3337      * Prints a certificate in a human readable format.
3338      */
3339     private void printX509Cert(X509Certificate cert, PrintStream out)
3340         throws Exception
3341     {
3342 
3343         MessageFormat form = new MessageFormat
3344                 (rb.getString(&quot;.PATTERN.printX509Cert.with.weak&quot;));
3345         PublicKey pkey = cert.getPublicKey();
3346         String sigName = cert.getSigAlgName();
3347         // No need to warn about sigalg of a trust anchor
3348         if (!isTrustedCert(cert)) {
3349             sigName = withWeak(sigName);
3350         }
3351         Object[] source = {cert.getSubjectDN().toString(),
3352                         cert.getIssuerDN().toString(),
3353                         cert.getSerialNumber().toString(16),
3354                         cert.getNotBefore().toString(),
3355                         cert.getNotAfter().toString(),
3356                         getCertFingerPrint(&quot;SHA-1&quot;, cert),
3357                         getCertFingerPrint(&quot;SHA-256&quot;, cert),
3358                         sigName,
3359                         withWeak(pkey),
3360                         cert.getVersion()
3361                         };
3362         out.println(form.format(source));
3363 
3364         if (cert instanceof X509CertImpl) {
3365             X509CertImpl impl = (X509CertImpl)cert;
3366             X509CertInfo certInfo = (X509CertInfo)impl.get(X509CertImpl.NAME
3367                                                            + &quot;.&quot; +
3368                                                            X509CertImpl.INFO);
3369             CertificateExtensions exts = (CertificateExtensions)
3370                     certInfo.get(X509CertInfo.EXTENSIONS);
3371             if (exts != null) {
3372                 printExtensions(rb.getString(&quot;Extensions.&quot;), exts, out);
3373             }
3374         }
3375     }
3376 
3377     private static void printExtensions(String title, CertificateExtensions exts, PrintStream out)
3378             throws Exception {
3379         int extnum = 0;
3380         Iterator&lt;Extension&gt; i1 = exts.getAllExtensions().iterator();
3381         Iterator&lt;Extension&gt; i2 = exts.getUnparseableExtensions().values().iterator();
3382         while (i1.hasNext() || i2.hasNext()) {
3383             Extension ext = i1.hasNext()?i1.next():i2.next();
3384             if (extnum == 0) {
3385                 out.println();
3386                 out.println(title);
3387                 out.println();
3388             }
3389             out.print(&quot;#&quot;+(++extnum)+&quot;: &quot;+ ext);
3390             if (ext.getClass() == Extension.class) {
3391                 byte[] v = ext.getExtensionValue();
3392                 if (v.length == 0) {
3393                     out.println(rb.getString(&quot;.Empty.value.&quot;));
3394                 } else {
3395                     new sun.security.util.HexDumpEncoder().encodeBuffer(ext.getExtensionValue(), out);
3396                     out.println();
3397                 }
3398             }
3399             out.println();
3400         }
3401     }
3402 
3403     /**
3404      * Locates a signer for a given certificate from a given keystore and
3405      * returns the signer&#39;s certificate.
3406      * @param cert the certificate whose signer is searched, not null
3407      * @param ks the keystore to search with, not null
3408      * @return &lt;code&gt;cert&lt;/code&gt; itself if it&#39;s already inside &lt;code&gt;ks&lt;/code&gt;,
3409      * or a certificate inside &lt;code&gt;ks&lt;/code&gt; who signs &lt;code&gt;cert&lt;/code&gt;,
3410      * or null otherwise. A label is added.
3411      */
3412     private static Pair&lt;String,Certificate&gt;
3413             getSigner(Certificate cert, KeyStore ks) throws Exception {
3414         if (ks.getCertificateAlias(cert) != null) {
3415             return new Pair&lt;&gt;(&quot;&quot;, cert);
3416         }
3417         for (Enumeration&lt;String&gt; aliases = ks.aliases();
3418                 aliases.hasMoreElements(); ) {
3419             String name = aliases.nextElement();
3420             Certificate trustedCert = ks.getCertificate(name);
3421             if (trustedCert != null) {
3422                 try {
3423                     cert.verify(trustedCert.getPublicKey());
3424                     return new Pair&lt;&gt;(name, trustedCert);
3425                 } catch (Exception e) {
3426                     // Not verified, skip to the next one
3427                 }
3428             }
3429         }
3430         return null;
3431     }
3432 
3433     /**
3434      * Gets an X.500 name suitable for inclusion in a certification request.
3435      */
3436     private X500Name getX500Name() throws IOException {
3437         BufferedReader in;
3438         in = new BufferedReader(new InputStreamReader(System.in));
3439         String commonName = &quot;Unknown&quot;;
3440         String organizationalUnit = &quot;Unknown&quot;;
3441         String organization = &quot;Unknown&quot;;
3442         String city = &quot;Unknown&quot;;
3443         String state = &quot;Unknown&quot;;
3444         String country = &quot;Unknown&quot;;
3445         X500Name name;
3446         String userInput = null;
3447 
3448         int maxRetry = 20;
3449         do {
3450             if (maxRetry-- &lt; 0) {
3451                 throw new RuntimeException(rb.getString(
3452                         &quot;Too.many.retries.program.terminated&quot;));
3453             }
3454             commonName = inputString(in,
3455                     rb.getString(&quot;What.is.your.first.and.last.name.&quot;),
3456                     commonName);
3457             organizationalUnit = inputString(in,
3458                     rb.getString
3459                         (&quot;What.is.the.name.of.your.organizational.unit.&quot;),
3460                     organizationalUnit);
3461             organization = inputString(in,
3462                     rb.getString(&quot;What.is.the.name.of.your.organization.&quot;),
3463                     organization);
3464             city = inputString(in,
3465                     rb.getString(&quot;What.is.the.name.of.your.City.or.Locality.&quot;),
3466                     city);
3467             state = inputString(in,
3468                     rb.getString(&quot;What.is.the.name.of.your.State.or.Province.&quot;),
3469                     state);
3470             country = inputString(in,
3471                     rb.getString
3472                         (&quot;What.is.the.two.letter.country.code.for.this.unit.&quot;),
3473                     country);
3474             name = new X500Name(commonName, organizationalUnit, organization,
3475                                 city, state, country);
3476             MessageFormat form = new MessageFormat
3477                 (rb.getString(&quot;Is.name.correct.&quot;));
3478             Object[] source = {name};
3479             userInput = inputString
3480                 (in, form.format(source), rb.getString(&quot;no&quot;));
3481         } while (collator.compare(userInput, rb.getString(&quot;yes&quot;)) != 0 &amp;&amp;
3482                  collator.compare(userInput, rb.getString(&quot;y&quot;)) != 0);
3483 
3484         System.err.println();
3485         return name;
3486     }
3487 
3488     private String inputString(BufferedReader in, String prompt,
3489                                String defaultValue)
3490         throws IOException
3491     {
3492         System.err.println(prompt);
3493         MessageFormat form = new MessageFormat
3494                 (rb.getString(&quot;.defaultValue.&quot;));
3495         Object[] source = {defaultValue};
3496         System.err.print(form.format(source));
3497         System.err.flush();
3498 
3499         String value = in.readLine();
3500         if (value == null || collator.compare(value, &quot;&quot;) == 0) {
3501             value = defaultValue;
3502         }
3503         return value;
3504     }
3505 
3506     /**
3507      * Writes an X.509 certificate in base64 or binary encoding to an output
3508      * stream.
3509      */
3510     private void dumpCert(Certificate cert, PrintStream out)
3511         throws IOException, CertificateException
3512     {
3513         if (rfc) {
3514             out.println(X509Factory.BEGIN_CERT);
3515             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(cert.getEncoded()));
3516             out.println(X509Factory.END_CERT);
3517         } else {
3518             out.write(cert.getEncoded()); // binary
3519         }
3520     }
3521 
3522     /**
3523      * Converts a byte to hex digit and writes to the supplied buffer
3524      */
3525     private void byte2hex(byte b, StringBuffer buf) {
3526         char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
3527                             &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
3528         int high = ((b &amp; 0xf0) &gt;&gt; 4);
3529         int low = (b &amp; 0x0f);
3530         buf.append(hexChars[high]);
3531         buf.append(hexChars[low]);
3532     }
3533 
3534     /**
3535      * Converts a byte array to hex string
3536      */
3537     private String toHexString(byte[] block) {
3538         StringBuffer buf = new StringBuffer();
3539         int len = block.length;
3540         for (int i = 0; i &lt; len; i++) {
3541              byte2hex(block[i], buf);
3542              if (i &lt; len-1) {
3543                  buf.append(&quot;:&quot;);
3544              }
3545         }
3546         return buf.toString();
3547     }
3548 
3549     /**
3550      * Recovers (private) key associated with given alias.
3551      *
3552      * @return an array of objects, where the 1st element in the array is the
3553      * recovered private key, and the 2nd element is the password used to
3554      * recover it.
3555      */
3556     private Pair&lt;Key,char[]&gt; recoverKey(String alias, char[] storePass,
3557                                        char[] keyPass)
3558         throws Exception
3559     {
3560         Key key = null;
3561 
3562         if (keyStore.containsAlias(alias) == false) {
3563             MessageFormat form = new MessageFormat
3564                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3565             Object[] source = {alias};
3566             throw new Exception(form.format(source));
3567         }
3568         if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class) &amp;&amp;
3569                 !keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
3570             MessageFormat form = new MessageFormat
3571                 (rb.getString(&quot;Alias.alias.has.no.key&quot;));
3572             Object[] source = {alias};
3573             throw new Exception(form.format(source));
3574         }
3575 
3576         if (keyPass == null) {
3577             // Try to recover the key using the keystore password
3578             if (storePass != null) {
3579                 try {
3580                     key = keyStore.getKey(alias, storePass);
3581                     passwords.add(storePass);
3582                     return Pair.of(key, storePass);
3583                 } catch (UnrecoverableKeyException e) {
3584                     if (token) {
3585                         throw e;
3586                     }
3587                 }
3588             }
3589             // prompt user for key password
3590             keyPass = getKeyPasswd(alias, null, null);
3591             key = keyStore.getKey(alias, keyPass);
3592             return Pair.of(key, keyPass);
3593         } else {
3594             key = keyStore.getKey(alias, keyPass);
3595             return Pair.of(key, keyPass);
3596         }
3597     }
3598 
3599     /**
3600      * Recovers entry associated with given alias.
3601      *
3602      * @return an array of objects, where the 1st element in the array is the
3603      * recovered entry, and the 2nd element is the password used to
3604      * recover it (null if no password).
3605      */
3606     private Pair&lt;Entry,char[]&gt; recoverEntry(KeyStore ks,
3607                             String alias,
3608                             char[] pstore,
3609                             char[] pkey) throws Exception {
3610 
3611         if (!ks.containsAlias(alias)) {
3612             MessageFormat form = new MessageFormat(
3613                     rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3614             Object[] source = {alias};
3615             throw new Exception(form.format(source));
3616         }
3617 
3618         // Step 1: First attempt to access entry without key password
3619         // (PKCS11 entry or trusted certificate entry, for example).
3620         // If fail, go next.
3621         try {
3622             Entry entry = ks.getEntry(alias, null);
3623             return Pair.of(entry, null);
3624         } catch (UnrecoverableEntryException une) {
3625             if(P11KEYSTORE.equalsIgnoreCase(ks.getType()) ||
3626                     KeyStoreUtil.isWindowsKeyStore(ks.getType())) {
3627                 // should not happen, but a possibility
3628                 throw une;
3629             }
3630         }
3631 
3632         // entry is protected
3633 
3634         // Step 2: try pkey if not null. If fail, fail.
3635         if (pkey != null) {
3636             PasswordProtection pp = new PasswordProtection(pkey);
3637             Entry entry = ks.getEntry(alias, pp);
3638             return Pair.of(entry, pkey);
3639         }
3640 
3641         // Step 3: try pstore if not null. If fail, go next.
3642         if (pstore != null) {
3643             try {
3644                 PasswordProtection pp = new PasswordProtection(pstore);
3645                 Entry entry = ks.getEntry(alias, pp);
3646                 return Pair.of(entry, pstore);
3647             } catch (UnrecoverableEntryException une) {
3648                 if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {
3649                     // P12 keystore currently does not support separate
3650                     // store and entry passwords. We will not prompt for
3651                     // entry password.
3652                     throw une;
3653                 }
3654             }
3655         }
3656 
3657         // Step 4: prompt for entry password
3658         pkey = getKeyPasswd(alias, null, null);
3659         PasswordProtection pp = new PasswordProtection(pkey);
3660         Entry entry = ks.getEntry(alias, pp);
3661         return Pair.of(entry, pkey);
3662     }
3663 
3664     /**
3665      * Gets the requested finger print of the certificate.
3666      */
3667     private String getCertFingerPrint(String mdAlg, Certificate cert)
3668         throws Exception
3669     {
3670         byte[] encCertInfo = cert.getEncoded();
3671         MessageDigest md = MessageDigest.getInstance(mdAlg);
3672         byte[] digest = md.digest(encCertInfo);
3673         return toHexString(digest);
3674     }
3675 
3676     /**
3677      * Prints warning about missing integrity check.
3678      */
3679     private void printNoIntegrityWarning() {
3680         System.err.println();
3681         System.err.println(rb.getString
3682             (&quot;.WARNING.WARNING.WARNING.&quot;));
3683         System.err.println(rb.getString
3684             (&quot;.The.integrity.of.the.information.stored.in.your.keystore.&quot;));
3685         System.err.println(rb.getString
3686             (&quot;.WARNING.WARNING.WARNING.&quot;));
3687         System.err.println();
3688     }
3689 
3690     /**
3691      * Validates chain in certification reply, and returns the ordered
3692      * elements of the chain (with user certificate first, and root
3693      * certificate last in the array).
3694      *
3695      * @param alias the alias name
3696      * @param userCert the user certificate of the alias
3697      * @param replyCerts the chain provided in the reply
3698      */
3699     private Certificate[] validateReply(String alias,
3700                                         Certificate userCert,
3701                                         Certificate[] replyCerts)
3702         throws Exception
3703     {
3704 
3705         checkWeak(rb.getString(&quot;reply&quot;), replyCerts);
3706 
3707         // order the certs in the reply (bottom-up).
3708         // we know that all certs in the reply are of type X.509, because
3709         // we parsed them using an X.509 certificate factory
3710         int i;
3711         PublicKey userPubKey = userCert.getPublicKey();
3712 
3713         // Remove duplicated certificates.
3714         HashSet&lt;Certificate&gt; nodup = new HashSet&lt;&gt;(Arrays.asList(replyCerts));
3715         replyCerts = nodup.toArray(new Certificate[nodup.size()]);
3716 
3717         for (i=0; i&lt;replyCerts.length; i++) {
3718             if (userPubKey.equals(replyCerts[i].getPublicKey())) {
3719                 break;
3720             }
3721         }
3722         if (i == replyCerts.length) {
3723             MessageFormat form = new MessageFormat(rb.getString
3724                 (&quot;Certificate.reply.does.not.contain.public.key.for.alias.&quot;));
3725             Object[] source = {alias};
3726             throw new Exception(form.format(source));
3727         }
3728 
3729         Certificate tmpCert = replyCerts[0];
3730         replyCerts[0] = replyCerts[i];
3731         replyCerts[i] = tmpCert;
3732 
3733         X509Certificate thisCert = (X509Certificate)replyCerts[0];
3734 
3735         for (i=1; i &lt; replyCerts.length-1; i++) {
3736             // find a cert in the reply who signs thisCert
3737             int j;
3738             for (j=i; j&lt;replyCerts.length; j++) {
3739                 if (KeyStoreUtil.signedBy(thisCert, (X509Certificate)replyCerts[j])) {
3740                     tmpCert = replyCerts[i];
3741                     replyCerts[i] = replyCerts[j];
3742                     replyCerts[j] = tmpCert;
3743                     thisCert = (X509Certificate)replyCerts[i];
3744                     break;
3745                 }
3746             }
3747             if (j == replyCerts.length) {
3748                 throw new Exception
3749                     (rb.getString(&quot;Incomplete.certificate.chain.in.reply&quot;));
3750             }
3751         }
3752 
3753         if (noprompt) {
3754             return replyCerts;
3755         }
3756 
3757         // do we trust the cert at the top?
3758         Certificate topCert = replyCerts[replyCerts.length-1];
3759         boolean fromKeyStore = true;
3760         Pair&lt;String,Certificate&gt; root = getSigner(topCert, keyStore);
3761         if (root == null &amp;&amp; trustcacerts &amp;&amp; caks != null) {
3762             root = getSigner(topCert, caks);
3763             fromKeyStore = false;
3764         }
3765         if (root == null) {
3766             System.err.println();
3767             System.err.println
3768                     (rb.getString(&quot;Top.level.certificate.in.reply.&quot;));
3769             printX509Cert((X509Certificate)topCert, System.out);
3770             System.err.println();
3771             System.err.print(rb.getString(&quot;.is.not.trusted.&quot;));
3772             printWeakWarnings(true);
3773             String reply = getYesNoReply
3774                     (rb.getString(&quot;Install.reply.anyway.no.&quot;));
3775             if (&quot;NO&quot;.equals(reply)) {
3776                 return null;
3777             }
3778         } else {
3779             if (root.snd != topCert) {
3780                 // append the root CA cert to the chain
3781                 Certificate[] tmpCerts =
3782                     new Certificate[replyCerts.length+1];
3783                 System.arraycopy(replyCerts, 0, tmpCerts, 0,
3784                                  replyCerts.length);
3785                 tmpCerts[tmpCerts.length-1] = root.snd;
3786                 replyCerts = tmpCerts;
3787                 checkWeak(String.format(fromKeyStore
3788                                 ? rb.getString(&quot;alias.in.keystore&quot;)
3789                                 : rb.getString(&quot;alias.in.cacerts&quot;),
3790                                         root.fst),
3791                           root.snd);
3792             }
3793         }
3794         return replyCerts;
3795     }
3796 
3797     /**
3798      * Establishes a certificate chain (using trusted certificates in the
3799      * keystore and cacerts), starting with the reply (certToVerify)
3800      * and ending at a self-signed certificate found in the keystore.
3801      *
3802      * @param userCert optional existing certificate, mostly likely be the
3803      *                 original self-signed cert created by -genkeypair.
3804      *                 It must have the same public key as certToVerify
3805      *                 but cannot be the same cert.
3806      * @param certToVerify the starting certificate to build the chain
3807      * @returns the established chain, might be null if user decides not
3808      */
3809     private Certificate[] establishCertChain(Certificate userCert,
3810                                              Certificate certToVerify)
3811         throws Exception
3812     {
3813         if (userCert != null) {
3814             // Make sure that the public key of the certificate reply matches
3815             // the original public key in the keystore
3816             PublicKey origPubKey = userCert.getPublicKey();
3817             PublicKey replyPubKey = certToVerify.getPublicKey();
3818             if (!origPubKey.equals(replyPubKey)) {
3819                 throw new Exception(rb.getString
3820                         (&quot;Public.keys.in.reply.and.keystore.don.t.match&quot;));
3821             }
3822 
3823             // If the two certs are identical, we&#39;re done: no need to import
3824             // anything
3825             if (certToVerify.equals(userCert)) {
3826                 throw new Exception(rb.getString
3827                         (&quot;Certificate.reply.and.certificate.in.keystore.are.identical&quot;));
3828             }
3829         }
3830 
3831         // Build a hash table of all certificates in the keystore.
3832         // Use the subject distinguished name as the key into the hash table.
3833         // All certificates associated with the same subject distinguished
3834         // name are stored in the same hash table entry as a vector.
3835         Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs = null;
3836         if (keyStore.size() &gt; 0) {
3837             certs = new Hashtable&lt;&gt;(11);
3838             keystorecerts2Hashtable(keyStore, certs);
3839         }
3840         if (trustcacerts) {
3841             if (caks!=null &amp;&amp; caks.size()&gt;0) {
3842                 if (certs == null) {
3843                     certs = new Hashtable&lt;&gt;(11);
3844                 }
3845                 keystorecerts2Hashtable(caks, certs);
3846             }
3847         }
3848 
3849         // start building chain
3850         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain = new Vector&lt;&gt;(2);
3851         if (buildChain(
3852                 new Pair&lt;&gt;(rb.getString(&quot;the.input&quot;),
3853                            (X509Certificate) certToVerify),
3854                 chain, certs)) {
3855             for (Pair&lt;String,X509Certificate&gt; p : chain) {
3856                 checkWeak(p.fst, p.snd);
3857             }
3858             Certificate[] newChain =
3859                     new Certificate[chain.size()];
3860             // buildChain() returns chain with self-signed root-cert first and
3861             // user-cert last, so we need to invert the chain before we store
3862             // it
3863             int j=0;
3864             for (int i=chain.size()-1; i&gt;=0; i--) {
3865                 newChain[j] = chain.elementAt(i).snd;
3866                 j++;
3867             }
3868             return newChain;
3869         } else {
3870             throw new Exception
3871                 (rb.getString(&quot;Failed.to.establish.chain.from.reply&quot;));
3872         }
3873     }
3874 
3875     /**
3876      * Recursively tries to establish chain from pool of certs starting from
3877      * certToVerify until a self-signed cert is found, and fill the certs found
3878      * into chain. Each cert in the chain signs the next one.
3879      *
3880      * This method is able to recover from an error, say, if certToVerify
3881      * is signed by certA but certA has no issuer in certs and itself is not
3882      * self-signed, the method can try another certB that also signs
3883      * certToVerify and look for signer of certB, etc, etc.
3884      *
3885      * Each cert in chain comes with a label showing its origin. The label is
3886      * used in the warning message when the cert is considered a risk.
3887      *
3888      * @param certToVerify the cert that needs to be verified.
3889      * @param chain the chain that&#39;s being built.
3890      * @param certs the pool of trusted certs
3891      *
3892      * @return true if successful, false otherwise.
3893      */
3894     private boolean buildChain(Pair&lt;String,X509Certificate&gt; certToVerify,
3895             Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain,
3896             Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs) {
3897         if (KeyStoreUtil.isSelfSigned(certToVerify.snd)) {
3898             // reached self-signed root cert;
3899             // no verification needed because it&#39;s trusted.
3900             chain.addElement(certToVerify);
3901             return true;
3902         }
3903 
3904         Principal issuer = certToVerify.snd.getIssuerDN();
3905 
3906         // Get the issuer&#39;s certificate(s)
3907         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = certs.get(issuer);
3908         if (vec == null) {
3909             return false;
3910         }
3911 
3912         // Try out each certificate in the vector, until we find one
3913         // whose public key verifies the signature of the certificate
3914         // in question.
3915         for (Enumeration&lt;Pair&lt;String,X509Certificate&gt;&gt; issuerCerts = vec.elements();
3916                 issuerCerts.hasMoreElements(); ) {
3917             Pair&lt;String,X509Certificate&gt; issuerCert = issuerCerts.nextElement();
3918             PublicKey issuerPubKey = issuerCert.snd.getPublicKey();
3919             try {
3920                 certToVerify.snd.verify(issuerPubKey);
3921             } catch (Exception e) {
3922                 continue;
3923             }
3924             if (buildChain(issuerCert, chain, certs)) {
3925                 chain.addElement(certToVerify);
3926                 return true;
3927             }
3928         }
3929         return false;
3930     }
3931 
3932     /**
3933      * Prompts user for yes/no decision.
3934      *
3935      * @return the user&#39;s decision, can only be &quot;YES&quot; or &quot;NO&quot;
3936      */
3937     private String getYesNoReply(String prompt)
3938         throws IOException
3939     {
3940         String reply = null;
3941         int maxRetry = 20;
3942         do {
3943             if (maxRetry-- &lt; 0) {
3944                 throw new RuntimeException(rb.getString(
3945                         &quot;Too.many.retries.program.terminated&quot;));
3946             }
3947             System.err.print(prompt);
3948             System.err.flush();
3949             reply = (new BufferedReader(new InputStreamReader
3950                                         (System.in))).readLine();
3951             if (reply == null ||
3952                 collator.compare(reply, &quot;&quot;) == 0 ||
3953                 collator.compare(reply, rb.getString(&quot;n&quot;)) == 0 ||
3954                 collator.compare(reply, rb.getString(&quot;no&quot;)) == 0) {
3955                 reply = &quot;NO&quot;;
3956             } else if (collator.compare(reply, rb.getString(&quot;y&quot;)) == 0 ||
3957                        collator.compare(reply, rb.getString(&quot;yes&quot;)) == 0) {
3958                 reply = &quot;YES&quot;;
3959             } else {
3960                 System.err.println(rb.getString(&quot;Wrong.answer.try.again&quot;));
3961                 reply = null;
3962             }
3963         } while (reply == null);
3964         return reply;
3965     }
3966 
3967     /**
3968      * Stores the (leaf) certificates of a keystore in a hashtable.
3969      * All certs belonging to the same CA are stored in a vector that
3970      * in turn is stored in the hashtable, keyed by the CA&#39;s subject DN.
3971      * Each cert comes with a string label that shows its origin and alias.
3972      */
3973     private void keystorecerts2Hashtable(KeyStore ks,
3974                 Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; hash)
3975         throws Exception {
3976 
3977         for (Enumeration&lt;String&gt; aliases = ks.aliases();
3978                                         aliases.hasMoreElements(); ) {
3979             String alias = aliases.nextElement();
3980             Certificate cert = ks.getCertificate(alias);
3981             if (cert != null) {
3982                 Principal subjectDN = ((X509Certificate)cert).getSubjectDN();
3983                 Pair&lt;String,X509Certificate&gt; pair = new Pair&lt;&gt;(
3984                         String.format(
3985                                 rb.getString(ks == caks ?
3986                                         &quot;alias.in.cacerts&quot; :
3987                                         &quot;alias.in.keystore&quot;),
3988                                 alias),
3989                         (X509Certificate)cert);
3990                 Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = hash.get(subjectDN);
3991                 if (vec == null) {
3992                     vec = new Vector&lt;&gt;();
3993                     vec.addElement(pair);
3994                 } else {
3995                     if (!vec.contains(pair)) {
3996                         vec.addElement(pair);
3997                     }
3998                 }
3999                 hash.put(subjectDN, vec);
4000             }
4001         }
4002     }
4003 
4004     /**
4005      * Returns the issue time that&#39;s specified the -startdate option
4006      * @param s the value of -startdate option
4007      */
4008     private static Date getStartDate(String s) throws IOException {
4009         Calendar c = new GregorianCalendar();
4010         if (s != null) {
4011             IOException ioe = new IOException(
4012                     rb.getString(&quot;Illegal.startdate.value&quot;));
4013             int len = s.length();
4014             if (len == 0) {
4015                 throw ioe;
4016             }
4017             if (s.charAt(0) == &#39;-&#39; || s.charAt(0) == &#39;+&#39;) {
4018                 // Form 1: ([+-]nnn[ymdHMS])+
4019                 int start = 0;
4020                 while (start &lt; len) {
4021                     int sign = 0;
4022                     switch (s.charAt(start)) {
4023                         case &#39;+&#39;: sign = 1; break;
4024                         case &#39;-&#39;: sign = -1; break;
4025                         default: throw ioe;
4026                     }
4027                     int i = start+1;
4028                     for (; i&lt;len; i++) {
4029                         char ch = s.charAt(i);
4030                         if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) break;
4031                     }
4032                     if (i == start+1) throw ioe;
4033                     int number = Integer.parseInt(s.substring(start+1, i));
4034                     if (i &gt;= len) throw ioe;
4035                     int unit = 0;
4036                     switch (s.charAt(i)) {
4037                         case &#39;y&#39;: unit = Calendar.YEAR; break;
4038                         case &#39;m&#39;: unit = Calendar.MONTH; break;
4039                         case &#39;d&#39;: unit = Calendar.DATE; break;
4040                         case &#39;H&#39;: unit = Calendar.HOUR; break;
4041                         case &#39;M&#39;: unit = Calendar.MINUTE; break;
4042                         case &#39;S&#39;: unit = Calendar.SECOND; break;
4043                         default: throw ioe;
4044                     }
4045                     c.add(unit, sign * number);
4046                     start = i + 1;
4047                 }
4048             } else  {
4049                 // Form 2: [yyyy/mm/dd] [HH:MM:SS]
4050                 String date = null, time = null;
4051                 if (len == 19) {
4052                     date = s.substring(0, 10);
4053                     time = s.substring(11);
4054                     if (s.charAt(10) != &#39; &#39;)
4055                         throw ioe;
4056                 } else if (len == 10) {
4057                     date = s;
4058                 } else if (len == 8) {
4059                     time = s;
4060                 } else {
4061                     throw ioe;
4062                 }
4063                 if (date != null) {
4064                     if (date.matches(&quot;\\d\\d\\d\\d\\/\\d\\d\\/\\d\\d&quot;)) {
4065                         c.set(Integer.valueOf(date.substring(0, 4)),
4066                                 Integer.valueOf(date.substring(5, 7))-1,
4067                                 Integer.valueOf(date.substring(8, 10)));
4068                     } else {
4069                         throw ioe;
4070                     }
4071                 }
4072                 if (time != null) {
4073                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4074                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4075                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4076                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4077                         c.set(Calendar.MILLISECOND, 0);
4078                     } else {
4079                         throw ioe;
4080                     }
4081                 }
4082             }
4083         }
4084         return c.getTime();
4085     }
4086 
4087     /**
4088      * Match a command (may be abbreviated) with a command set.
4089      * @param s the command provided
4090      * @param list the legal command set. If there is a null, commands after it
4091      * are regarded experimental, which means they are supported but their
4092      * existence should not be revealed to user.
4093      * @return the position of a single match, or -1 if none matched
4094      * @throws Exception if s is ambiguous
4095      */
4096     private static int oneOf(String s, String... list) throws Exception {
4097         int[] match = new int[list.length];
4098         int nmatch = 0;
4099         int experiment = Integer.MAX_VALUE;
4100         for (int i = 0; i&lt;list.length; i++) {
4101             String one = list[i];
4102             if (one == null) {
4103                 experiment = i;
4104                 continue;
4105             }
4106             if (one.toLowerCase(Locale.ENGLISH)
4107                     .startsWith(s.toLowerCase(Locale.ENGLISH))) {
4108                 match[nmatch++] = i;
4109             } else {
4110                 StringBuilder sb = new StringBuilder();
4111                 boolean first = true;
4112                 for (char c: one.toCharArray()) {
4113                     if (first) {
4114                         sb.append(c);
4115                         first = false;
4116                     } else {
4117                         if (!Character.isLowerCase(c)) {
4118                             sb.append(c);
4119                         }
4120                     }
4121                 }
4122                 if (sb.toString().equalsIgnoreCase(s)) {
4123                     match[nmatch++] = i;
4124                 }
4125             }
4126         }
4127         if (nmatch == 0) {
4128             return -1;
4129         } else if (nmatch == 1) {
4130             return match[0];
4131         } else {
4132             // If multiple matches is in experimental commands, ignore them
4133             if (match[1] &gt; experiment) {
4134                 return match[0];
4135             }
4136             StringBuilder sb = new StringBuilder();
4137             MessageFormat form = new MessageFormat(rb.getString
4138                 (&quot;command.{0}.is.ambiguous.&quot;));
4139             Object[] source = {s};
4140             sb.append(form.format(source));
4141             sb.append(&quot;\n    &quot;);
4142             for (int i=0; i&lt;nmatch &amp;&amp; match[i]&lt;experiment; i++) {
4143                 sb.append(&#39; &#39;);
4144                 sb.append(list[match[i]]);
4145             }
4146             throw new Exception(sb.toString());
4147         }
4148     }
4149 
4150     /**
4151      * Create a GeneralName object from known types
4152      * @param t one of 5 known types
4153      * @param v value
4154      * @return which one
4155      */
4156     private GeneralName createGeneralName(String t, String v)
4157             throws Exception {
4158         GeneralNameInterface gn;
4159         int p = oneOf(t, &quot;EMAIL&quot;, &quot;URI&quot;, &quot;DNS&quot;, &quot;IP&quot;, &quot;OID&quot;);
4160         if (p &lt; 0) {
4161             throw new Exception(rb.getString(
4162                     &quot;Unrecognized.GeneralName.type.&quot;) + t);
4163         }
4164         switch (p) {
4165             case 0: gn = new RFC822Name(v); break;
4166             case 1: gn = new URIName(v); break;
4167             case 2: gn = new DNSName(v); break;
4168             case 3: gn = new IPAddressName(v); break;
4169             default: gn = new OIDName(v); break; //4
4170         }
4171         return new GeneralName(gn);
4172     }
4173 
4174     private static final String[] extSupported = {
4175                         &quot;BasicConstraints&quot;,
4176                         &quot;KeyUsage&quot;,
4177                         &quot;ExtendedKeyUsage&quot;,
4178                         &quot;SubjectAlternativeName&quot;,
4179                         &quot;IssuerAlternativeName&quot;,
4180                         &quot;SubjectInfoAccess&quot;,
4181                         &quot;AuthorityInfoAccess&quot;,
4182                         null,
4183                         &quot;CRLDistributionPoints&quot;,
4184     };
4185 
4186     private ObjectIdentifier findOidForExtName(String type)
4187             throws Exception {
4188         switch (oneOf(type, extSupported)) {
4189             case 0: return PKIXExtensions.BasicConstraints_Id;
4190             case 1: return PKIXExtensions.KeyUsage_Id;
4191             case 2: return PKIXExtensions.ExtendedKeyUsage_Id;
4192             case 3: return PKIXExtensions.SubjectAlternativeName_Id;
4193             case 4: return PKIXExtensions.IssuerAlternativeName_Id;
4194             case 5: return PKIXExtensions.SubjectInfoAccess_Id;
4195             case 6: return PKIXExtensions.AuthInfoAccess_Id;
4196             case 8: return PKIXExtensions.CRLDistributionPoints_Id;
4197             default: return new ObjectIdentifier(type);
4198         }
4199     }
4200 
4201     // Add an extension into a CertificateExtensions, always using OID as key
4202     private static void setExt(CertificateExtensions result, Extension ex)
4203             throws IOException {
4204         result.set(ex.getId(), ex);
4205     }
4206 
4207     /**
4208      * Create X509v3 extensions from a string representation. Note that the
4209      * SubjectKeyIdentifierExtension will always be created non-critical besides
4210      * the extension requested in the &lt;code&gt;extstr&lt;/code&gt; argument.
4211      *
4212      * @param requestedEx the requested extensions, can be null, used for -gencert
4213      * @param existingEx the original extensions, can be null, used for -selfcert
4214      * @param extstrs -ext values, Read keytool doc
4215      * @param pkey the public key for the certificate
4216      * @param akey the public key for the authority (issuer)
4217      * @return the created CertificateExtensions
4218      */
4219     private CertificateExtensions createV3Extensions(
4220             CertificateExtensions requestedEx,
4221             CertificateExtensions existingEx,
4222             List &lt;String&gt; extstrs,
4223             PublicKey pkey,
4224             PublicKey akey) throws Exception {
4225 
4226         // By design, inside a CertificateExtensions object, all known
4227         // extensions uses name (say, &quot;BasicConstraints&quot;) as key and
4228         // a child Extension type (say, &quot;BasicConstraintsExtension&quot;)
4229         // as value, unknown extensions uses OID as key and bare
4230         // Extension object as value. This works fine inside JDK.
4231         //
4232         // However, in keytool, there is no way to prevent people
4233         // using OID in -ext, either as a new extension, or in a
4234         // honored value. Thus here we (ab)use CertificateExtensions
4235         // by always using OID as key and value can be of any type.
4236 
4237         if (existingEx != null &amp;&amp; requestedEx != null) {
4238             // This should not happen
4239             throw new Exception(&quot;One of request and original should be null.&quot;);
4240         }
4241         // A new extensions always using OID as key
4242         CertificateExtensions result = new CertificateExtensions();
4243         if (existingEx != null) {
4244             for (Extension ex: existingEx.getAllExtensions()) {
4245                 setExt(result, ex);
4246             }
4247         }
4248         try {
4249             // name{:critical}{=value}
4250             // Honoring requested extensions
4251             if (requestedEx != null) {
4252                 // The existing requestedEx might use names as keys,
4253                 // translate to all-OID first.
4254                 CertificateExtensions request2 = new CertificateExtensions();
4255                 for (sun.security.x509.Extension ex: requestedEx.getAllExtensions()) {
4256                     request2.set(ex.getId(), ex);
4257                 }
4258                 for(String extstr: extstrs) {
4259                     if (extstr.toLowerCase(Locale.ENGLISH).startsWith(&quot;honored=&quot;)) {
4260                         List&lt;String&gt; list = Arrays.asList(
4261                                 extstr.toLowerCase(Locale.ENGLISH).substring(8).split(&quot;,&quot;));
4262                         // First check existence of &quot;all&quot;
4263                         if (list.contains(&quot;all&quot;)) {
4264                             for (Extension ex: request2.getAllExtensions()) {
4265                                 setExt(result, ex);
4266                             }
4267                         }
4268                         // one by one for others
4269                         for (String item: list) {
4270                             if (item.equals(&quot;all&quot;)) continue;
4271 
4272                             // add or remove
4273                             boolean add;
4274                             // -1, unchanged, 0 critical, 1 non-critical
4275                             int action = -1;
4276                             String type = null;
4277                             if (item.startsWith(&quot;-&quot;)) {
4278                                 add = false;
4279                                 type = item.substring(1);
4280                             } else {
4281                                 add = true;
4282                                 int colonpos = item.indexOf(&#39;:&#39;);
4283                                 if (colonpos &gt;= 0) {
4284                                     type = item.substring(0, colonpos);
4285                                     action = oneOf(item.substring(colonpos+1),
4286                                             &quot;critical&quot;, &quot;non-critical&quot;);
4287                                     if (action == -1) {
4288                                         throw new Exception(rb.getString
4289                                             (&quot;Illegal.value.&quot;) + item);
4290                                     }
4291                                 } else {
4292                                     type = item;
4293                                 }
4294                             }
4295                             String n = findOidForExtName(type).toString();
4296                             if (add) {
4297                                 Extension e = request2.get(n);
4298                                 if (!e.isCritical() &amp;&amp; action == 0
4299                                         || e.isCritical() &amp;&amp; action == 1) {
4300                                     e = Extension.newExtension(
4301                                             e.getExtensionId(),
4302                                             !e.isCritical(),
4303                                             e.getExtensionValue());
4304                                 }
4305                                 setExt(result, e);
4306                             } else {
4307                                 result.delete(n);
4308                             }
4309                         }
4310                         break;
4311                     }
4312                 }
4313             }
4314             for(String extstr: extstrs) {
4315                 String name, value;
4316                 boolean isCritical = false;
4317 
4318                 int eqpos = extstr.indexOf(&#39;=&#39;);
4319                 if (eqpos &gt;= 0) {
4320                     name = extstr.substring(0, eqpos);
4321                     value = extstr.substring(eqpos+1);
4322                 } else {
4323                     name = extstr;
4324                     value = null;
4325                 }
4326 
4327                 int colonpos = name.indexOf(&#39;:&#39;);
4328                 if (colonpos &gt;= 0) {
4329                     if (oneOf(name.substring(colonpos+1), &quot;critical&quot;) == 0) {
4330                         isCritical = true;
4331                     }
4332                     name = name.substring(0, colonpos);
4333                 }
4334 
4335                 if (name.equalsIgnoreCase(&quot;honored&quot;)) {
4336                     continue;
4337                 }
4338                 int exttype = oneOf(name, extSupported);
4339                 switch (exttype) {
4340                     case 0:     // BC
4341                         int pathLen = -1;
4342                         boolean isCA = false;
4343                         if (value == null) {
4344                             isCA = true;
4345                         } else {
4346                             try {   // the abbr format
4347                                 pathLen = Integer.parseInt(value);
4348                                 isCA = true;
4349                             } catch (NumberFormatException ufe) {
4350                                 // ca:true,pathlen:1
4351                                 for (String part: value.split(&quot;,&quot;)) {
4352                                     String[] nv = part.split(&quot;:&quot;);
4353                                     if (nv.length != 2) {
4354                                         throw new Exception(rb.getString
4355                                                 (&quot;Illegal.value.&quot;) + extstr);
4356                                     } else {
4357                                         if (nv[0].equalsIgnoreCase(&quot;ca&quot;)) {
4358                                             isCA = Boolean.parseBoolean(nv[1]);
4359                                         } else if (nv[0].equalsIgnoreCase(&quot;pathlen&quot;)) {
4360                                             pathLen = Integer.parseInt(nv[1]);
4361                                         } else {
4362                                             throw new Exception(rb.getString
4363                                                 (&quot;Illegal.value.&quot;) + extstr);
4364                                         }
4365                                     }
4366                                 }
4367                             }
4368                         }
4369                         setExt(result, new BasicConstraintsExtension(isCritical, isCA,
4370                                 pathLen));
4371                         break;
4372                     case 1:     // KU
4373                         if(value != null) {
4374                             boolean[] ok = new boolean[9];
4375                             for (String s: value.split(&quot;,&quot;)) {
4376                                 int p = oneOf(s,
4377                                        &quot;digitalSignature&quot;,  // (0),
4378                                        &quot;nonRepudiation&quot;,    // (1)
4379                                        &quot;keyEncipherment&quot;,   // (2),
4380                                        &quot;dataEncipherment&quot;,  // (3),
4381                                        &quot;keyAgreement&quot;,      // (4),
4382                                        &quot;keyCertSign&quot;,       // (5),
4383                                        &quot;cRLSign&quot;,           // (6),
4384                                        &quot;encipherOnly&quot;,      // (7),
4385                                        &quot;decipherOnly&quot;,      // (8)
4386                                        &quot;contentCommitment&quot;  // also (1)
4387                                        );
4388                                 if (p &lt; 0) {
4389                                     throw new Exception(rb.getString(&quot;Unknown.keyUsage.type.&quot;) + s);
4390                                 }
4391                                 if (p == 9) p = 1;
4392                                 ok[p] = true;
4393                             }
4394                             KeyUsageExtension kue = new KeyUsageExtension(ok);
4395                             // The above KeyUsageExtension constructor does not
4396                             // allow isCritical value, so...
4397                             setExt(result, Extension.newExtension(
4398                                     kue.getExtensionId(),
4399                                     isCritical,
4400                                     kue.getExtensionValue()));
4401                         } else {
4402                             throw new Exception(rb.getString
4403                                     (&quot;Illegal.value.&quot;) + extstr);
4404                         }
4405                         break;
4406                     case 2:     // EKU
4407                         if(value != null) {
4408                             Vector&lt;ObjectIdentifier&gt; v = new Vector&lt;&gt;();
4409                             for (String s: value.split(&quot;,&quot;)) {
4410                                 int p = oneOf(s,
4411                                         &quot;anyExtendedKeyUsage&quot;,
4412                                         &quot;serverAuth&quot;,       //1
4413                                         &quot;clientAuth&quot;,       //2
4414                                         &quot;codeSigning&quot;,      //3
4415                                         &quot;emailProtection&quot;,  //4
4416                                         &quot;&quot;,                 //5
4417                                         &quot;&quot;,                 //6
4418                                         &quot;&quot;,                 //7
4419                                         &quot;timeStamping&quot;,     //8
4420                                         &quot;OCSPSigning&quot;       //9
4421                                        );
4422                                 if (p &lt; 0) {
4423                                     try {
4424                                         v.add(new ObjectIdentifier(s));
4425                                     } catch (Exception e) {
4426                                         throw new Exception(rb.getString(
4427                                                 &quot;Unknown.extendedkeyUsage.type.&quot;) + s);
4428                                     }
4429                                 } else if (p == 0) {
4430                                     v.add(new ObjectIdentifier(&quot;2.5.29.37.0&quot;));
4431                                 } else {
4432                                     v.add(new ObjectIdentifier(&quot;1.3.6.1.5.5.7.3.&quot; + p));
4433                                 }
4434                             }
4435                             setExt(result, new ExtendedKeyUsageExtension(isCritical, v));
4436                         } else {
4437                             throw new Exception(rb.getString
4438                                     (&quot;Illegal.value.&quot;) + extstr);
4439                         }
4440                         break;
4441                     case 3:     // SAN
4442                     case 4:     // IAN
4443                         if(value != null) {
4444                             String[] ps = value.split(&quot;,&quot;);
4445                             GeneralNames gnames = new GeneralNames();
4446                             for(String item: ps) {
4447                                 colonpos = item.indexOf(&#39;:&#39;);
4448                                 if (colonpos &lt; 0) {
4449                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4450                                 }
4451                                 String t = item.substring(0, colonpos);
4452                                 String v = item.substring(colonpos+1);
4453                                 gnames.add(createGeneralName(t, v));
4454                             }
4455                             if (exttype == 3) {
4456                                 setExt(result, new SubjectAlternativeNameExtension(
4457                                         isCritical, gnames));
4458                             } else {
4459                                 setExt(result, new IssuerAlternativeNameExtension(
4460                                         isCritical, gnames));
4461                             }
4462                         } else {
4463                             throw new Exception(rb.getString
4464                                     (&quot;Illegal.value.&quot;) + extstr);
4465                         }
4466                         break;
4467                     case 5:     // SIA, always non-critical
4468                     case 6:     // AIA, always non-critical
4469                         if (isCritical) {
4470                             throw new Exception(rb.getString(
4471                                     &quot;This.extension.cannot.be.marked.as.critical.&quot;) + extstr);
4472                         }
4473                         if(value != null) {
4474                             List&lt;AccessDescription&gt; accessDescriptions =
4475                                     new ArrayList&lt;&gt;();
4476                             String[] ps = value.split(&quot;,&quot;);
4477                             for(String item: ps) {
4478                                 colonpos = item.indexOf(&#39;:&#39;);
4479                                 int colonpos2 = item.indexOf(&#39;:&#39;, colonpos+1);
4480                                 if (colonpos &lt; 0 || colonpos2 &lt; 0) {
4481                                     throw new Exception(rb.getString
4482                                             (&quot;Illegal.value.&quot;) + extstr);
4483                                 }
4484                                 String m = item.substring(0, colonpos);
4485                                 String t = item.substring(colonpos+1, colonpos2);
4486                                 String v = item.substring(colonpos2+1);
4487                                 int p = oneOf(m,
4488                                         &quot;&quot;,
4489                                         &quot;ocsp&quot;,         //1
4490                                         &quot;caIssuers&quot;,    //2
4491                                         &quot;timeStamping&quot;, //3
4492                                         &quot;&quot;,
4493                                         &quot;caRepository&quot;  //5
4494                                         );
4495                                 ObjectIdentifier oid;
4496                                 if (p &lt; 0) {
4497                                     try {
4498                                         oid = new ObjectIdentifier(m);
4499                                     } catch (Exception e) {
4500                                         throw new Exception(rb.getString(
4501                                                 &quot;Unknown.AccessDescription.type.&quot;) + m);
4502                                     }
4503                                 } else {
4504                                     oid = new ObjectIdentifier(&quot;1.3.6.1.5.5.7.48.&quot; + p);
4505                                 }
4506                                 accessDescriptions.add(new AccessDescription(
4507                                         oid, createGeneralName(t, v)));
4508                             }
4509                             if (exttype == 5) {
4510                                 setExt(result, new SubjectInfoAccessExtension(accessDescriptions));
4511                             } else {
4512                                 setExt(result, new AuthorityInfoAccessExtension(accessDescriptions));
4513                             }
4514                         } else {
4515                             throw new Exception(rb.getString
4516                                     (&quot;Illegal.value.&quot;) + extstr);
4517                         }
4518                         break;
4519                     case 8: // CRL, experimental, only support 1 distributionpoint
4520                         if(value != null) {
4521                             String[] ps = value.split(&quot;,&quot;);
4522                             GeneralNames gnames = new GeneralNames();
4523                             for(String item: ps) {
4524                                 colonpos = item.indexOf(&#39;:&#39;);
4525                                 if (colonpos &lt; 0) {
4526                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4527                                 }
4528                                 String t = item.substring(0, colonpos);
4529                                 String v = item.substring(colonpos+1);
4530                                 gnames.add(createGeneralName(t, v));
4531                             }
4532                             setExt(result, new CRLDistributionPointsExtension(
4533                                     isCritical, Collections.singletonList(
4534                                     new DistributionPoint(gnames, null, null))));
4535                         } else {
4536                             throw new Exception(rb.getString
4537                                     (&quot;Illegal.value.&quot;) + extstr);
4538                         }
4539                         break;
4540                     case -1:
4541                         ObjectIdentifier oid = new ObjectIdentifier(name);
4542                         byte[] data = null;
4543                         if (value != null) {
4544                             data = new byte[value.length() / 2 + 1];
4545                             int pos = 0;
4546                             for (char c: value.toCharArray()) {
4547                                 int hex;
4548                                 if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
4549                                     hex = c - &#39;0&#39; ;
4550                                 } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
4551                                     hex = c - &#39;A&#39; + 10;
4552                                 } else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
4553                                     hex = c - &#39;a&#39; + 10;
4554                                 } else {
4555                                     continue;
4556                                 }
4557                                 if (pos % 2 == 0) {
4558                                     data[pos/2] = (byte)(hex &lt;&lt; 4);
4559                                 } else {
4560                                     data[pos/2] += hex;
4561                                 }
4562                                 pos++;
4563                             }
4564                             if (pos % 2 != 0) {
4565                                 throw new Exception(rb.getString(
4566                                         &quot;Odd.number.of.hex.digits.found.&quot;) + extstr);
4567                             }
4568                             data = Arrays.copyOf(data, pos/2);
4569                         } else {
4570                             data = new byte[0];
4571                         }
4572                         setExt(result, new Extension(oid, isCritical,
4573                                 new DerValue(DerValue.tag_OctetString, data)
4574                                         .toByteArray()));
4575                         break;
4576                     default:
4577                         throw new Exception(rb.getString(
4578                                 &quot;Unknown.extension.type.&quot;) + extstr);
4579                 }
4580             }
4581             // always non-critical
4582             setExt(result, new SubjectKeyIdentifierExtension(
4583                     new KeyIdentifier(pkey).getIdentifier()));
4584             if (akey != null &amp;&amp; !pkey.equals(akey)) {
4585                 setExt(result, new AuthorityKeyIdentifierExtension(
4586                                 new KeyIdentifier(akey), null, null));
4587             }
4588         } catch(IOException e) {
4589             throw new RuntimeException(e);
4590         }
4591         return result;
4592     }
4593 
4594     private boolean isTrustedCert(Certificate cert) throws KeyStoreException {
4595         if (caks != null &amp;&amp; caks.getCertificateAlias(cert) != null) {
4596             return true;
4597         } else {
4598             String inKS = keyStore.getCertificateAlias(cert);
4599             return inKS != null &amp;&amp; keyStore.isCertificateEntry(inKS);
4600         }
4601     }
4602 
4603     private void checkWeak(String label, String sigAlg, Key key) {
4604 
4605         if (sigAlg != null &amp;&amp; !DISABLED_CHECK.permits(
4606                 SIG_PRIMITIVE_SET, sigAlg, null)) {
4607             weakWarnings.add(String.format(
4608                     rb.getString(&quot;whose.sigalg.risk&quot;), label, sigAlg));
4609         }
4610         if (key != null &amp;&amp; !DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4611             weakWarnings.add(String.format(
4612                     rb.getString(&quot;whose.key.risk&quot;),
4613                     label,
4614                     String.format(rb.getString(&quot;key.bit&quot;),
4615                             KeyUtil.getKeySize(key), key.getAlgorithm())));
4616         }
4617     }
4618 
4619     private void checkWeak(String label, Certificate[] certs)
4620             throws KeyStoreException {
4621         for (int i = 0; i &lt; certs.length; i++) {
4622             Certificate cert = certs[i];
4623             if (cert instanceof X509Certificate) {
4624                 X509Certificate xc = (X509Certificate)cert;
4625                 String fullLabel = label;
4626                 if (certs.length &gt; 1) {
4627                     fullLabel = oneInMany(label, i, certs.length);
4628                 }
4629                 checkWeak(fullLabel, xc);
4630             }
4631         }
4632     }
4633 
4634     private void checkWeak(String label, Certificate cert)
4635             throws KeyStoreException {
4636         if (cert instanceof X509Certificate) {
4637             X509Certificate xc = (X509Certificate)cert;
4638             // No need to check the sigalg of a trust anchor
4639             String sigAlg = isTrustedCert(cert) ? null : xc.getSigAlgName();
4640             checkWeak(label, sigAlg, xc.getPublicKey());
4641         }
4642     }
4643 
4644     private void checkWeak(String label, PKCS10 p10) {
4645         checkWeak(label, p10.getSigAlg(), p10.getSubjectPublicKeyInfo());
4646     }
4647 
4648     private void checkWeak(String label, CRL crl, Key key) {
4649         if (crl instanceof X509CRLImpl) {
4650             X509CRLImpl impl = (X509CRLImpl)crl;
4651             checkWeak(label, impl.getSigAlgName(), key);
4652         }
4653     }
4654 
4655     private void printWeakWarnings(boolean newLine) {
4656         if (!weakWarnings.isEmpty() &amp;&amp; !nowarn) {
4657             System.err.println(&quot;\nWarning:&quot;);
4658             for (String warning : weakWarnings) {
4659                 System.err.println(warning);
4660             }
4661             if (newLine) {
4662                 // When calling before a yes/no prompt, add a new line
4663                 System.err.println();
4664             }
4665         }
4666         weakWarnings.clear();
4667     }
4668 
4669     /**
4670      * Prints the usage of this tool.
4671      */
4672     private void usage() {
4673         if (command != null) {
4674             System.err.println(&quot;keytool &quot; + command +
4675                     rb.getString(&quot;.OPTION.&quot;));
4676             System.err.println();
4677             System.err.println(rb.getString(command.description));
4678             System.err.println();
4679             System.err.println(rb.getString(&quot;Options.&quot;));
4680             System.err.println();
4681 
4682             // Left and right sides of the options list. Both might
4683             // contain &quot;\n&quot; and span multiple lines
4684             String[] left = new String[command.options.length];
4685             String[] right = new String[command.options.length];
4686 
4687             // Length of left side of options list
4688             int lenLeft = 0;
4689 
4690             for (int j = 0; j &lt; command.options.length; j++) {
4691                 Option opt = command.options[j];
4692                 left[j] = opt.toString();
4693                 if (opt.arg != null) {
4694                     left[j] += &quot; &quot; + opt.arg;
4695                 }
4696                 String[] lefts = left[j].split(&quot;\n&quot;);
4697                 for (String s : lefts) {
4698                     if (s.length() &gt; lenLeft) {
4699                         lenLeft = s.length();
4700                     }
4701                 }
4702                 right[j] = rb.getString(opt.description);
4703             }
4704             for (int j = 0; j &lt; left.length; j++) {
4705                 String[] lefts = left[j].split(&quot;\n&quot;);
4706                 String[] rights = right[j].split(&quot;\n&quot;);
4707                 for (int i = 0; i &lt; lefts.length &amp;&amp; i &lt; rights.length; i++) {
4708                     String s1 = i &lt; lefts.length ? lefts[i] : &quot;&quot;;
4709                     String s2 = i &lt; rights.length ? rights[i] : &quot;&quot;;
4710                     if (i == 0) {
4711                         System.err.printf(&quot; %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4712                     } else {
4713                         System.err.printf(&quot;   %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4714                     }
4715                 }
4716             }
4717             System.err.println();
4718             System.err.println(rb.getString(
4719                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4720         } else {
4721             System.err.println(rb.getString(
4722                     &quot;Key.and.Certificate.Management.Tool&quot;));
4723             System.err.println();
4724             System.err.println(rb.getString(&quot;Commands.&quot;));
4725             System.err.println();
4726             for (Command c: Command.values()) {
4727                 if (c == KEYCLONE) break;
4728                 System.err.printf(&quot; %-20s%s\n&quot;, c, rb.getString(c.description));
4729             }
4730             System.err.println();
4731             System.err.println(rb.getString(
4732                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4733             System.err.println(rb.getString(
4734                     &quot;Use.keytool.command.name.help.for.usage.of.command.name&quot;));
4735         }
4736     }
4737 
4738     private void tinyHelp() {
4739         usage();
4740         if (debug) {
4741             throw new RuntimeException(&quot;NO BIG ERROR, SORRY&quot;);
4742         } else {
4743             System.exit(1);
4744         }
4745     }
4746 
4747     private void errorNeedArgument(String flag) {
4748         Object[] source = {flag};
4749         System.err.println(new MessageFormat(
4750                 rb.getString(&quot;Command.option.flag.needs.an.argument.&quot;)).format(source));
4751         tinyHelp();
4752     }
4753 
4754     private char[] getPass(String modifier, String arg) {
4755         char[] output = KeyStoreUtil.getPassWithModifier(modifier, arg, rb);
4756         if (output != null) return output;
4757         tinyHelp();
4758         return null;    // Useless, tinyHelp() already exits.
4759     }
4760 }
4761 
4762 // This class is exactly the same as com.sun.tools.javac.util.Pair,
4763 // it&#39;s copied here since the original one is not included in JRE.
4764 class Pair&lt;A, B&gt; {
4765 
4766     public final A fst;
4767     public final B snd;
4768 
4769     public Pair(A fst, B snd) {
4770         this.fst = fst;
4771         this.snd = snd;
4772     }
4773 
4774     public String toString() {
4775         return &quot;Pair[&quot; + fst + &quot;,&quot; + snd + &quot;]&quot;;
4776     }
4777 
4778     public boolean equals(Object other) {
4779         return
4780             other instanceof Pair &amp;&amp;
4781             Objects.equals(fst, ((Pair)other).fst) &amp;&amp;
4782             Objects.equals(snd, ((Pair)other).snd);
4783     }
4784 
4785     public int hashCode() {
4786         if (fst == null) return (snd == null) ? 0 : snd.hashCode() + 1;
4787         else if (snd == null) return fst.hashCode() + 2;
4788         else return fst.hashCode() * 17 + snd.hashCode();
4789     }
4790 
4791     public static &lt;A,B&gt; Pair&lt;A,B&gt; of(A a, B b) {
4792         return new Pair&lt;&gt;(a,b);
4793     }
4794 }
4795 
    </pre>
  </body>
</html>
diff a/src/java.base/share/classes/sun/nio/ch/Util.java b/src/java.base/share/classes/sun/nio/ch/Util.java
--- a/src/java.base/share/classes/sun/nio/ch/Util.java
+++ b/src/java.base/share/classes/sun/nio/ch/Util.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,10 +35,11 @@
 import java.security.PrivilegedAction;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.TerminatingThreadLocal;
 import jdk.internal.misc.Unsafe;
 import sun.security.action.GetPropertyAction;
 
 public class Util {
@@ -413,11 +414,12 @@
                         Class<?> cl = Class.forName("java.nio.DirectByteBuffer");
                         Constructor<?> ctor = cl.getDeclaredConstructor(
                             new Class<?>[] { int.class,
                                              long.class,
                                              FileDescriptor.class,
-                                             Runnable.class });
+                                             Runnable.class,
+                                             boolean.class, MemorySegmentProxy.class});
                         ctor.setAccessible(true);
                         directByteBufferConstructor = ctor;
                     } catch (ClassNotFoundException   |
                              NoSuchMethodException    |
                              IllegalArgumentException |
@@ -428,21 +430,23 @@
                 }});
     }
 
     static MappedByteBuffer newMappedByteBuffer(int size, long addr,
                                                 FileDescriptor fd,
-                                                Runnable unmapper)
+                                                Runnable unmapper,
+                                                boolean isSync)
     {
         MappedByteBuffer dbb;
         if (directByteBufferConstructor == null)
             initDBBConstructor();
         try {
             dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(
               new Object[] { size,
                              addr,
                              fd,
-                             unmapper });
+                             unmapper,
+                             isSync, null});
         } catch (InstantiationException |
                  IllegalAccessException |
                  InvocationTargetException e) {
             throw new InternalError(e);
         }
@@ -458,11 +462,12 @@
                         Class<?> cl = Class.forName("java.nio.DirectByteBufferR");
                         Constructor<?> ctor = cl.getDeclaredConstructor(
                             new Class<?>[] { int.class,
                                              long.class,
                                              FileDescriptor.class,
-                                             Runnable.class });
+                                             Runnable.class,
+                                             boolean.class, MemorySegmentProxy.class });
                         ctor.setAccessible(true);
                         directByteBufferRConstructor = ctor;
                     } catch (ClassNotFoundException |
                              NoSuchMethodException |
                              IllegalArgumentException |
@@ -473,21 +478,23 @@
                 }});
     }
 
     static MappedByteBuffer newMappedByteBufferR(int size, long addr,
                                                  FileDescriptor fd,
-                                                 Runnable unmapper)
+                                                 Runnable unmapper,
+                                                 boolean isSync)
     {
         MappedByteBuffer dbb;
         if (directByteBufferRConstructor == null)
             initDBBRConstructor();
         try {
             dbb = (MappedByteBuffer)directByteBufferRConstructor.newInstance(
               new Object[] { size,
                              addr,
                              fd,
-                             unmapper });
+                             unmapper,
+                             isSync, null});
         } catch (InstantiationException |
                  IllegalAccessException |
                  InvocationTargetException e) {
             throw new InternalError(e);
         }

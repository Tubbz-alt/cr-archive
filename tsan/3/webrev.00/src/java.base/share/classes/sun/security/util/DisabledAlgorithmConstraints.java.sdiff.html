<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DisabledAlgorithmConstraints.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DomainName.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DisabledAlgorithmConstraints.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import sun.security.validator.Validator;
 29 
<span class="line-removed"> 30 import java.io.ByteArrayOutputStream;</span>
<span class="line-removed"> 31 import java.io.PrintStream;</span>
 32 import java.security.CryptoPrimitive;
 33 import java.security.AlgorithmParameters;
 34 import java.security.Key;
 35 import java.security.cert.CertPathValidatorException;
 36 import java.security.cert.CertPathValidatorException.BasicReason;
 37 import java.security.cert.X509Certificate;
 38 import java.text.SimpleDateFormat;
 39 import java.util.ArrayList;

 40 import java.util.Calendar;
 41 import java.util.Date;
 42 import java.util.HashMap;
 43 import java.util.HashSet;
 44 import java.util.List;
 45 import java.util.Locale;
 46 import java.util.Map;
 47 import java.util.Set;
 48 import java.util.Collection;
 49 import java.util.StringTokenizer;
 50 import java.util.TimeZone;
 51 import java.util.regex.Pattern;
 52 import java.util.regex.Matcher;
 53 
 54 /**
 55  * Algorithm constraints for disabled algorithms property
 56  *
 57  * See the &quot;jdk.certpath.disabledAlgorithms&quot; specification in java.security
 58  * for the syntax of the disabled algorithm string.
 59  */
 60 public class DisabledAlgorithmConstraints extends AbstractAlgorithmConstraints {
 61     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 62 
<span class="line-modified"> 63     // the known security property, jdk.certpath.disabledAlgorithms</span>
 64     public static final String PROPERTY_CERTPATH_DISABLED_ALGS =
 65             &quot;jdk.certpath.disabledAlgorithms&quot;;
 66 
<span class="line-modified"> 67     // the known security property, jdk.tls.disabledAlgorithms</span>
 68     public static final String PROPERTY_TLS_DISABLED_ALGS =
 69             &quot;jdk.tls.disabledAlgorithms&quot;;
 70 
<span class="line-modified"> 71     // the known security property, jdk.jar.disabledAlgorithms</span>
 72     public static final String PROPERTY_JAR_DISABLED_ALGS =
 73             &quot;jdk.jar.disabledAlgorithms&quot;;
 74 
<span class="line-modified"> 75     private final String[] disabledAlgorithms;</span>




 76     private final Constraints algorithmConstraints;
 77 
 78     /**
 79      * Initialize algorithm constraints with the specified security property.
 80      *
 81      * @param propertyName the security property name that define the disabled
 82      *        algorithm constraints
 83      */
 84     public DisabledAlgorithmConstraints(String propertyName) {
 85         this(propertyName, new AlgorithmDecomposer());
 86     }
 87 
 88     /**
 89      * Initialize algorithm constraints with the specified security property
 90      * for a specific usage type.
 91      *
 92      * @param propertyName the security property name that define the disabled
 93      *        algorithm constraints
 94      * @param decomposer an alternate AlgorithmDecomposer.
 95      */
 96     public DisabledAlgorithmConstraints(String propertyName,
 97             AlgorithmDecomposer decomposer) {
 98         super(decomposer);
 99         disabledAlgorithms = getAlgorithms(propertyName);


















100         algorithmConstraints = new Constraints(disabledAlgorithms);
101     }
102 
103     /*
104      * This only checks if the algorithm has been completely disabled.  If
105      * there are keysize or other limit, this method allow the algorithm.
106      */
107     @Override
108     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
109             String algorithm, AlgorithmParameters parameters) {





110         if (!checkAlgorithm(disabledAlgorithms, algorithm, decomposer)) {
111             return false;
112         }
113 
114         if (parameters != null) {
115             return algorithmConstraints.permits(algorithm, parameters);
116         }
117 
118         return true;
119     }
120 
121     /*
122      * Checks if the key algorithm has been disabled or constraints have been
123      * placed on the key.
124      */
125     @Override
126     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
127         return checkConstraints(primitives, &quot;&quot;, key, null);
128     }
129 
</pre>
<hr />
<pre>
147         permits(cp.getAlgorithm(), cp);
148     }
149 
150     public final void permits(String algorithm, Key key,
151             AlgorithmParameters params, String variant)
152             throws CertPathValidatorException {
153         permits(algorithm, new ConstraintsParameters(algorithm, params, key,
154                 (variant == null) ? Validator.VAR_GENERIC : variant));
155     }
156 
157     /*
158      * Check if a x509Certificate object is permitted.  Check if all
159      * algorithms are allowed, certificate constraints, and the
160      * public key against key constraints.
161      *
162      * Uses new style permit() which throws exceptions.
163      */
164 
165     public final void permits(String algorithm, ConstraintsParameters cp)
166             throws CertPathValidatorException {













167         algorithmConstraints.permits(algorithm, cp);
168     }
169 
170     // Check if a string is contained inside the property
171     public boolean checkProperty(String param) {
172         param = param.toLowerCase(Locale.ENGLISH);
173         for (String block : disabledAlgorithms) {
174             if (block.toLowerCase(Locale.ENGLISH).indexOf(param) &gt;= 0) {
175                 return true;
176             }
177         }
178         return false;
179     }
180 
181     // Check algorithm constraints with key and algorithm
182     private boolean checkConstraints(Set&lt;CryptoPrimitive&gt; primitives,
183             String algorithm, Key key, AlgorithmParameters parameters) {
184 
<span class="line-modified">185         // check the key parameter, it cannot be null.</span>




186         if (key == null) {
187             throw new IllegalArgumentException(&quot;The key cannot be null&quot;);
188         }
189 
190         // check the signature algorithm with parameters
191         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
192             if (!permits(primitives, algorithm, parameters)) {
193                 return false;
194             }
195         }
196 
197         // check the key algorithm
198         if (!permits(primitives, key.getAlgorithm(), null)) {
199             return false;
200         }
201 







202         // check the key constraints
203         return algorithmConstraints.permits(key);
204     }
205 
206 
207     /**
208      * Key and Certificate Constraints
209      *
210      * The complete disabling of an algorithm is not handled by Constraints or
211      * Constraint classes.  That is addressed with
212      *   permit(Set&lt;CryptoPrimitive&gt;, String, AlgorithmParameters)
213      *
214      * When passing a Key to permit(), the boolean return values follow the
215      * same as the interface class AlgorithmConstraints.permit().  This is to
216      * maintain compatibility:
217      * &#39;true&#39; means the operation is allowed.
218      * &#39;false&#39; means it failed the constraints and is disallowed.
219      *
220      * When passing ConstraintsParameters through permit(), an exception
221      * will be thrown on a failure to better identify why the operation was
222      * disallowed.
223      */
224 
225     private static class Constraints {
226         private Map&lt;String, List&lt;Constraint&gt;&gt; constraintsMap = new HashMap&lt;&gt;();
227 
228         private static class Holder {
229             private static final Pattern DENY_AFTER_PATTERN = Pattern.compile(
230                     &quot;denyAfter\\s+(\\d{4})-(\\d{2})-(\\d{2})&quot;);
231         }
232 
<span class="line-modified">233         public Constraints(String[] constraintArray) {</span>
234             for (String constraintEntry : constraintArray) {
235                 if (constraintEntry == null || constraintEntry.isEmpty()) {
236                     continue;
237                 }
238 
239                 constraintEntry = constraintEntry.trim();
240                 if (debug != null) {
241                     debug.println(&quot;Constraints: &quot; + constraintEntry);
242                 }
243 
244                 // Check if constraint is a complete disabling of an
245                 // algorithm or has conditions.
246                 int space = constraintEntry.indexOf(&#39; &#39;);
247                 String algorithm = AlgorithmDecomposer.hashName(
248                         ((space &gt; 0 ? constraintEntry.substring(0, space) :
249                                 constraintEntry).
250                                 toUpperCase(Locale.ENGLISH)));
251                 List&lt;Constraint&gt; constraintList =
252                         constraintsMap.getOrDefault(algorithm,
253                                 new ArrayList&lt;&gt;(1));
254 
255                 // Consider the impact of algorithm aliases.
256                 for (String alias : AlgorithmDecomposer.getAliases(algorithm)) {
257                     constraintsMap.putIfAbsent(alias, constraintList);
258                 }
259 
<span class="line-modified">260                 if (space &lt;= 0) {</span>


261                     constraintList.add(new DisabledConstraint(algorithm));
262                     continue;
263                 }
264 
265                 String policy = constraintEntry.substring(space + 1);
266 
267                 // Convert constraint conditions into Constraint classes
268                 Constraint c, lastConstraint = null;
269                 // Allow only one jdkCA entry per constraint entry
270                 boolean jdkCALimit = false;
271                 // Allow only one denyAfter entry per constraint entry
272                 boolean denyAfterLimit = false;
273 
274                 for (String entry : policy.split(&quot;&amp;&quot;)) {
275                     entry = entry.trim();
276 
277                     Matcher matcher;
278                     if (entry.startsWith(&quot;keySize&quot;)) {
279                         if (debug != null) {
280                             debug.println(&quot;Constraints set to keySize: &quot; +
</pre>
<hr />
<pre>
339                     }
340                     lastConstraint = c;
341                 }
342             }
343         }
344 
345         // Get applicable constraints based off the signature algorithm
346         private List&lt;Constraint&gt; getConstraints(String algorithm) {
347             return constraintsMap.get(algorithm);
348         }
349 
350         // Check if KeySizeConstraints permit the specified key
351         public boolean permits(Key key) {
352             List&lt;Constraint&gt; list = getConstraints(key.getAlgorithm());
353             if (list == null) {
354                 return true;
355             }
356             for (Constraint constraint : list) {
357                 if (!constraint.permits(key)) {
358                     if (debug != null) {
<span class="line-modified">359                         debug.println(&quot;keySizeConstraint: failed key &quot; +</span>
360                                 &quot;constraint check &quot; + KeyUtil.getKeySize(key));
361                     }
362                     return false;
363                 }
364             }
365             return true;
366         }
367 
368         // Check if constraints permit this AlgorithmParameters.
369         public boolean permits(String algorithm, AlgorithmParameters aps) {
370             List&lt;Constraint&gt; list = getConstraints(algorithm);
371             if (list == null) {
372                 return true;
373             }
374 
375             for (Constraint constraint : list) {
376                 if (!constraint.permits(aps)) {
377                     if (debug != null) {
<span class="line-modified">378                         debug.println(&quot;keySizeConstraint: failed algorithm &quot; +</span>
379                                 &quot;parameters constraint check &quot; + aps);
380                     }
381 
382                     return false;
383                 }
384             }
385 
386             return true;
387         }
388 
389         // Check if constraints permit this cert.
390         public void permits(String algorithm, ConstraintsParameters cp)
391                 throws CertPathValidatorException {
392             X509Certificate cert = cp.getCertificate();
393 
394             if (debug != null) {
<span class="line-modified">395                 debug.println(&quot;Constraints.permits(): &quot; + algorithm +</span>
<span class="line-removed">396                         &quot; Variant: &quot; + cp.getVariant());</span>
397             }
398 
399             // Get all signature algorithms to check for constraints
400             Set&lt;String&gt; algorithms = new HashSet&lt;&gt;();
401             if (algorithm != null) {
402                 algorithms.addAll(AlgorithmDecomposer.decomposeOneHash(algorithm));
403             }
404 
405             // Attempt to add the public key algorithm if cert provided
406             if (cert != null) {
407                 algorithms.add(cert.getPublicKey().getAlgorithm());
408             }
<span class="line-modified">409             if (cp.getPublicKey() != null) {</span>
<span class="line-modified">410                 algorithms.add(cp.getPublicKey().getAlgorithm());</span>
411             }
412             // Check all applicable constraints
413             for (String alg : algorithms) {
414                 List&lt;Constraint&gt; list = getConstraints(alg);
415                 if (list == null) {
416                     continue;
417                 }
418                 for (Constraint constraint : list) {
419                     constraint.permits(cp);
420                 }
421             }
422         }
423     }
424 
425     /**
426      * This abstract Constraint class for algorithm-based checking
427      * may contain one or more constraints.  If the &#39;&amp;&#39; on the {@Security}
428      * property is used, multiple constraints have been grouped together
429      * requiring all the constraints to fail for the check to be disallowed.
430      *
</pre>
<hr />
<pre>
529                 return true;
530             }
531             return false;
532         }
533 
534         /**
535          * Recursively check if this constraint is allowed,
536          *
537          * If {@code nextConstraint} is non-null, this method will
538          * call {@code nextConstraint}&#39;s {@code permit()} to check if the
539          * constraint is allowed or denied.  If the constraint&#39;s
540          * {@code permit()} is allowed, this method will exit this and any
541          * recursive next() calls, returning &#39;true&#39;.  If the constraints
542          * called were disallowed the check will exit with &#39;false&#39;.
543          *
544          * @param key Public key
545          * @return &#39;true&#39; if constraint allows the operation, &#39;false&#39; if
546          * the constraint denies the operation.
547          */
548         boolean next(Key key) {
<span class="line-modified">549             if (nextConstraint != null &amp;&amp; nextConstraint.permits(key)) {</span>
<span class="line-removed">550                 return true;</span>
<span class="line-removed">551             }</span>
<span class="line-removed">552             return false;</span>
553         }
554 
555         String extendedMsg(ConstraintsParameters cp) {
556             return (cp.getCertificate() == null ? &quot;.&quot; :
557                     &quot; used with certificate: &quot; +
558                             cp.getCertificate().getSubjectX500Principal() +
559                     (cp.getVariant() != Validator.VAR_GENERIC ?
560                             &quot;.  Usage was &quot; + cp.getVariant() : &quot;.&quot;));
561         }
562     }
563 
564     /*
565      * This class contains constraints dealing with the certificate chain
566      * of the certificate.
567      */
568     private static class jdkCAConstraint extends Constraint {
569         jdkCAConstraint(String algo) {
570             algorithm = algo;
571         }
572 
</pre>
<hr />
<pre>
782                     this.maxSize = length &gt; 1 ? (length - 1) : 0;
783                     break;
784                 default:
785                     // unlikely to happen
786                     this.minSize = Integer.MAX_VALUE;
787                     this.maxSize = -1;
788             }
789         }
790 
791         /*
792          * If we are passed a certificate, extract the public key and use it.
793          *
794          * Check if each constraint fails and check if there is a linked
795          * constraint  Any permitted constraint will exit the linked list
796          * to allow the operation.
797          */
798         @Override
799         public void permits(ConstraintsParameters cp)
800                 throws CertPathValidatorException {
801             Key key = null;
<span class="line-modified">802             if (cp.getPublicKey() != null) {</span>
<span class="line-modified">803                 key = cp.getPublicKey();</span>
804             } else if (cp.getCertificate() != null) {
805                 key = cp.getCertificate().getPublicKey();
806             }
807             if (key != null &amp;&amp; !permitsImpl(key)) {
808                 if (nextConstraint != null) {
809                     nextConstraint.permits(cp);
810                     return;
811                 }
812                 throw new CertPathValidatorException(
813                         &quot;Algorithm constraints check failed on keysize limits. &quot; +
814                         algorithm + &quot; &quot; + KeyUtil.getKeySize(key) + &quot;bit key&quot; +
815                         extendedMsg(cp),
816                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
817             }
818         }
819 
820 
821         // Check if key constraint disable the specified key
822         // Uses old style permit()
823         @Override
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import sun.security.validator.Validator;
 29 


 30 import java.security.CryptoPrimitive;
 31 import java.security.AlgorithmParameters;
 32 import java.security.Key;
 33 import java.security.cert.CertPathValidatorException;
 34 import java.security.cert.CertPathValidatorException.BasicReason;
 35 import java.security.cert.X509Certificate;
 36 import java.text.SimpleDateFormat;
 37 import java.util.ArrayList;
<span class="line-added"> 38 import java.util.Arrays;</span>
 39 import java.util.Calendar;
 40 import java.util.Date;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.List;
 44 import java.util.Locale;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.Collection;
 48 import java.util.StringTokenizer;
 49 import java.util.TimeZone;
 50 import java.util.regex.Pattern;
 51 import java.util.regex.Matcher;
 52 
 53 /**
 54  * Algorithm constraints for disabled algorithms property
 55  *
 56  * See the &quot;jdk.certpath.disabledAlgorithms&quot; specification in java.security
 57  * for the syntax of the disabled algorithm string.
 58  */
 59 public class DisabledAlgorithmConstraints extends AbstractAlgorithmConstraints {
 60     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 61 
<span class="line-modified"> 62     // Disabled algorithm security property for certificate path</span>
 63     public static final String PROPERTY_CERTPATH_DISABLED_ALGS =
 64             &quot;jdk.certpath.disabledAlgorithms&quot;;
 65 
<span class="line-modified"> 66     // Disabled algorithm security property for TLS</span>
 67     public static final String PROPERTY_TLS_DISABLED_ALGS =
 68             &quot;jdk.tls.disabledAlgorithms&quot;;
 69 
<span class="line-modified"> 70     // Disabled algorithm security property for jar</span>
 71     public static final String PROPERTY_JAR_DISABLED_ALGS =
 72             &quot;jdk.jar.disabledAlgorithms&quot;;
 73 
<span class="line-modified"> 74     // Property for disabled EC named curves</span>
<span class="line-added"> 75     private static final String PROPERTY_DISABLED_EC_CURVES =</span>
<span class="line-added"> 76             &quot;jdk.disabled.namedCurves&quot;;</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     private final List&lt;String&gt; disabledAlgorithms;</span>
 79     private final Constraints algorithmConstraints;
 80 
 81     /**
 82      * Initialize algorithm constraints with the specified security property.
 83      *
 84      * @param propertyName the security property name that define the disabled
 85      *        algorithm constraints
 86      */
 87     public DisabledAlgorithmConstraints(String propertyName) {
 88         this(propertyName, new AlgorithmDecomposer());
 89     }
 90 
 91     /**
 92      * Initialize algorithm constraints with the specified security property
 93      * for a specific usage type.
 94      *
 95      * @param propertyName the security property name that define the disabled
 96      *        algorithm constraints
 97      * @param decomposer an alternate AlgorithmDecomposer.
 98      */
 99     public DisabledAlgorithmConstraints(String propertyName,
100             AlgorithmDecomposer decomposer) {
101         super(decomposer);
102         disabledAlgorithms = getAlgorithms(propertyName);
<span class="line-added">103 </span>
<span class="line-added">104         // Check for alias</span>
<span class="line-added">105         int ecindex = -1, i = 0;</span>
<span class="line-added">106         for (String s : disabledAlgorithms) {</span>
<span class="line-added">107             if (s.regionMatches(true, 0,&quot;include &quot;, 0, 8)) {</span>
<span class="line-added">108                 if (s.regionMatches(true, 8, PROPERTY_DISABLED_EC_CURVES, 0,</span>
<span class="line-added">109                         PROPERTY_DISABLED_EC_CURVES.length())) {</span>
<span class="line-added">110                     ecindex = i;</span>
<span class="line-added">111                     break;</span>
<span class="line-added">112                 }</span>
<span class="line-added">113             }</span>
<span class="line-added">114             i++;</span>
<span class="line-added">115         }</span>
<span class="line-added">116         if (ecindex &gt; -1) {</span>
<span class="line-added">117             disabledAlgorithms.remove(ecindex);</span>
<span class="line-added">118             disabledAlgorithms.addAll(ecindex,</span>
<span class="line-added">119                     getAlgorithms(PROPERTY_DISABLED_EC_CURVES));</span>
<span class="line-added">120         }</span>
121         algorithmConstraints = new Constraints(disabledAlgorithms);
122     }
123 
124     /*
125      * This only checks if the algorithm has been completely disabled.  If
126      * there are keysize or other limit, this method allow the algorithm.
127      */
128     @Override
129     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
130             String algorithm, AlgorithmParameters parameters) {
<span class="line-added">131         if (primitives == null || primitives.isEmpty()) {</span>
<span class="line-added">132             throw new IllegalArgumentException(&quot;The primitives cannot be null&quot; +</span>
<span class="line-added">133                     &quot; or empty.&quot;);</span>
<span class="line-added">134         }</span>
<span class="line-added">135 </span>
136         if (!checkAlgorithm(disabledAlgorithms, algorithm, decomposer)) {
137             return false;
138         }
139 
140         if (parameters != null) {
141             return algorithmConstraints.permits(algorithm, parameters);
142         }
143 
144         return true;
145     }
146 
147     /*
148      * Checks if the key algorithm has been disabled or constraints have been
149      * placed on the key.
150      */
151     @Override
152     public final boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
153         return checkConstraints(primitives, &quot;&quot;, key, null);
154     }
155 
</pre>
<hr />
<pre>
173         permits(cp.getAlgorithm(), cp);
174     }
175 
176     public final void permits(String algorithm, Key key,
177             AlgorithmParameters params, String variant)
178             throws CertPathValidatorException {
179         permits(algorithm, new ConstraintsParameters(algorithm, params, key,
180                 (variant == null) ? Validator.VAR_GENERIC : variant));
181     }
182 
183     /*
184      * Check if a x509Certificate object is permitted.  Check if all
185      * algorithms are allowed, certificate constraints, and the
186      * public key against key constraints.
187      *
188      * Uses new style permit() which throws exceptions.
189      */
190 
191     public final void permits(String algorithm, ConstraintsParameters cp)
192             throws CertPathValidatorException {
<span class="line-added">193 </span>
<span class="line-added">194         // Check if named curves in the ConstraintParameters are disabled.</span>
<span class="line-added">195         if (cp.getNamedCurve() != null) {</span>
<span class="line-added">196             for (String curve : cp.getNamedCurve()) {</span>
<span class="line-added">197                 if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {</span>
<span class="line-added">198                     throw new CertPathValidatorException(</span>
<span class="line-added">199                             &quot;Algorithm constraints check failed on disabled &quot; +</span>
<span class="line-added">200                                     &quot;algorithm: &quot; + curve,</span>
<span class="line-added">201                             null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);</span>
<span class="line-added">202                 }</span>
<span class="line-added">203             }</span>
<span class="line-added">204         }</span>
<span class="line-added">205 </span>
206         algorithmConstraints.permits(algorithm, cp);
207     }
208 
209     // Check if a string is contained inside the property
210     public boolean checkProperty(String param) {
211         param = param.toLowerCase(Locale.ENGLISH);
212         for (String block : disabledAlgorithms) {
213             if (block.toLowerCase(Locale.ENGLISH).indexOf(param) &gt;= 0) {
214                 return true;
215             }
216         }
217         return false;
218     }
219 
220     // Check algorithm constraints with key and algorithm
221     private boolean checkConstraints(Set&lt;CryptoPrimitive&gt; primitives,
222             String algorithm, Key key, AlgorithmParameters parameters) {
223 
<span class="line-modified">224         if (primitives == null || primitives.isEmpty()) {</span>
<span class="line-added">225             throw new IllegalArgumentException(&quot;The primitives cannot be null&quot; +</span>
<span class="line-added">226                     &quot; or empty.&quot;);</span>
<span class="line-added">227         }</span>
<span class="line-added">228 </span>
229         if (key == null) {
230             throw new IllegalArgumentException(&quot;The key cannot be null&quot;);
231         }
232 
233         // check the signature algorithm with parameters
234         if (algorithm != null &amp;&amp; !algorithm.isEmpty()) {
235             if (!permits(primitives, algorithm, parameters)) {
236                 return false;
237             }
238         }
239 
240         // check the key algorithm
241         if (!permits(primitives, key.getAlgorithm(), null)) {
242             return false;
243         }
244 
<span class="line-added">245         // If this is an elliptic curve, check disabled the named curve.</span>
<span class="line-added">246         for (String curve : ConstraintsParameters.getNamedCurveFromKey(key)) {</span>
<span class="line-added">247             if (!permits(primitives, curve, null)) {</span>
<span class="line-added">248                 return false;</span>
<span class="line-added">249             }</span>
<span class="line-added">250         }</span>
<span class="line-added">251 </span>
252         // check the key constraints
253         return algorithmConstraints.permits(key);
254     }
255 
256 
257     /**
258      * Key and Certificate Constraints
259      *
260      * The complete disabling of an algorithm is not handled by Constraints or
261      * Constraint classes.  That is addressed with
262      *   permit(Set&lt;CryptoPrimitive&gt;, String, AlgorithmParameters)
263      *
264      * When passing a Key to permit(), the boolean return values follow the
265      * same as the interface class AlgorithmConstraints.permit().  This is to
266      * maintain compatibility:
267      * &#39;true&#39; means the operation is allowed.
268      * &#39;false&#39; means it failed the constraints and is disallowed.
269      *
270      * When passing ConstraintsParameters through permit(), an exception
271      * will be thrown on a failure to better identify why the operation was
272      * disallowed.
273      */
274 
275     private static class Constraints {
276         private Map&lt;String, List&lt;Constraint&gt;&gt; constraintsMap = new HashMap&lt;&gt;();
277 
278         private static class Holder {
279             private static final Pattern DENY_AFTER_PATTERN = Pattern.compile(
280                     &quot;denyAfter\\s+(\\d{4})-(\\d{2})-(\\d{2})&quot;);
281         }
282 
<span class="line-modified">283         public Constraints(List&lt;String&gt; constraintArray) {</span>
284             for (String constraintEntry : constraintArray) {
285                 if (constraintEntry == null || constraintEntry.isEmpty()) {
286                     continue;
287                 }
288 
289                 constraintEntry = constraintEntry.trim();
290                 if (debug != null) {
291                     debug.println(&quot;Constraints: &quot; + constraintEntry);
292                 }
293 
294                 // Check if constraint is a complete disabling of an
295                 // algorithm or has conditions.
296                 int space = constraintEntry.indexOf(&#39; &#39;);
297                 String algorithm = AlgorithmDecomposer.hashName(
298                         ((space &gt; 0 ? constraintEntry.substring(0, space) :
299                                 constraintEntry).
300                                 toUpperCase(Locale.ENGLISH)));
301                 List&lt;Constraint&gt; constraintList =
302                         constraintsMap.getOrDefault(algorithm,
303                                 new ArrayList&lt;&gt;(1));
304 
305                 // Consider the impact of algorithm aliases.
306                 for (String alias : AlgorithmDecomposer.getAliases(algorithm)) {
307                     constraintsMap.putIfAbsent(alias, constraintList);
308                 }
309 
<span class="line-modified">310                 // If there is no whitespace, it is a algorithm name; however,</span>
<span class="line-added">311                 // if there is a whitespace, could be a multi-word EC curve too.</span>
<span class="line-added">312                 if (space &lt;= 0 || CurveDB.lookup(constraintEntry) != null) {</span>
313                     constraintList.add(new DisabledConstraint(algorithm));
314                     continue;
315                 }
316 
317                 String policy = constraintEntry.substring(space + 1);
318 
319                 // Convert constraint conditions into Constraint classes
320                 Constraint c, lastConstraint = null;
321                 // Allow only one jdkCA entry per constraint entry
322                 boolean jdkCALimit = false;
323                 // Allow only one denyAfter entry per constraint entry
324                 boolean denyAfterLimit = false;
325 
326                 for (String entry : policy.split(&quot;&amp;&quot;)) {
327                     entry = entry.trim();
328 
329                     Matcher matcher;
330                     if (entry.startsWith(&quot;keySize&quot;)) {
331                         if (debug != null) {
332                             debug.println(&quot;Constraints set to keySize: &quot; +
</pre>
<hr />
<pre>
391                     }
392                     lastConstraint = c;
393                 }
394             }
395         }
396 
397         // Get applicable constraints based off the signature algorithm
398         private List&lt;Constraint&gt; getConstraints(String algorithm) {
399             return constraintsMap.get(algorithm);
400         }
401 
402         // Check if KeySizeConstraints permit the specified key
403         public boolean permits(Key key) {
404             List&lt;Constraint&gt; list = getConstraints(key.getAlgorithm());
405             if (list == null) {
406                 return true;
407             }
408             for (Constraint constraint : list) {
409                 if (!constraint.permits(key)) {
410                     if (debug != null) {
<span class="line-modified">411                         debug.println(&quot;Constraints: failed key size&quot; +</span>
412                                 &quot;constraint check &quot; + KeyUtil.getKeySize(key));
413                     }
414                     return false;
415                 }
416             }
417             return true;
418         }
419 
420         // Check if constraints permit this AlgorithmParameters.
421         public boolean permits(String algorithm, AlgorithmParameters aps) {
422             List&lt;Constraint&gt; list = getConstraints(algorithm);
423             if (list == null) {
424                 return true;
425             }
426 
427             for (Constraint constraint : list) {
428                 if (!constraint.permits(aps)) {
429                     if (debug != null) {
<span class="line-modified">430                         debug.println(&quot;Constraints: failed algorithm &quot; +</span>
431                                 &quot;parameters constraint check &quot; + aps);
432                     }
433 
434                     return false;
435                 }
436             }
437 
438             return true;
439         }
440 
441         // Check if constraints permit this cert.
442         public void permits(String algorithm, ConstraintsParameters cp)
443                 throws CertPathValidatorException {
444             X509Certificate cert = cp.getCertificate();
445 
446             if (debug != null) {
<span class="line-modified">447                 debug.println(&quot;Constraints.permits(): &quot; + cp.toString());</span>

448             }
449 
450             // Get all signature algorithms to check for constraints
451             Set&lt;String&gt; algorithms = new HashSet&lt;&gt;();
452             if (algorithm != null) {
453                 algorithms.addAll(AlgorithmDecomposer.decomposeOneHash(algorithm));
454             }
455 
456             // Attempt to add the public key algorithm if cert provided
457             if (cert != null) {
458                 algorithms.add(cert.getPublicKey().getAlgorithm());
459             }
<span class="line-modified">460             if (cp.getKey() != null) {</span>
<span class="line-modified">461                 algorithms.add(cp.getKey().getAlgorithm());</span>
462             }
463             // Check all applicable constraints
464             for (String alg : algorithms) {
465                 List&lt;Constraint&gt; list = getConstraints(alg);
466                 if (list == null) {
467                     continue;
468                 }
469                 for (Constraint constraint : list) {
470                     constraint.permits(cp);
471                 }
472             }
473         }
474     }
475 
476     /**
477      * This abstract Constraint class for algorithm-based checking
478      * may contain one or more constraints.  If the &#39;&amp;&#39; on the {@Security}
479      * property is used, multiple constraints have been grouped together
480      * requiring all the constraints to fail for the check to be disallowed.
481      *
</pre>
<hr />
<pre>
580                 return true;
581             }
582             return false;
583         }
584 
585         /**
586          * Recursively check if this constraint is allowed,
587          *
588          * If {@code nextConstraint} is non-null, this method will
589          * call {@code nextConstraint}&#39;s {@code permit()} to check if the
590          * constraint is allowed or denied.  If the constraint&#39;s
591          * {@code permit()} is allowed, this method will exit this and any
592          * recursive next() calls, returning &#39;true&#39;.  If the constraints
593          * called were disallowed the check will exit with &#39;false&#39;.
594          *
595          * @param key Public key
596          * @return &#39;true&#39; if constraint allows the operation, &#39;false&#39; if
597          * the constraint denies the operation.
598          */
599         boolean next(Key key) {
<span class="line-modified">600             return nextConstraint != null &amp;&amp; nextConstraint.permits(key);</span>



601         }
602 
603         String extendedMsg(ConstraintsParameters cp) {
604             return (cp.getCertificate() == null ? &quot;.&quot; :
605                     &quot; used with certificate: &quot; +
606                             cp.getCertificate().getSubjectX500Principal() +
607                     (cp.getVariant() != Validator.VAR_GENERIC ?
608                             &quot;.  Usage was &quot; + cp.getVariant() : &quot;.&quot;));
609         }
610     }
611 
612     /*
613      * This class contains constraints dealing with the certificate chain
614      * of the certificate.
615      */
616     private static class jdkCAConstraint extends Constraint {
617         jdkCAConstraint(String algo) {
618             algorithm = algo;
619         }
620 
</pre>
<hr />
<pre>
830                     this.maxSize = length &gt; 1 ? (length - 1) : 0;
831                     break;
832                 default:
833                     // unlikely to happen
834                     this.minSize = Integer.MAX_VALUE;
835                     this.maxSize = -1;
836             }
837         }
838 
839         /*
840          * If we are passed a certificate, extract the public key and use it.
841          *
842          * Check if each constraint fails and check if there is a linked
843          * constraint  Any permitted constraint will exit the linked list
844          * to allow the operation.
845          */
846         @Override
847         public void permits(ConstraintsParameters cp)
848                 throws CertPathValidatorException {
849             Key key = null;
<span class="line-modified">850             if (cp.getKey() != null) {</span>
<span class="line-modified">851                 key = cp.getKey();</span>
852             } else if (cp.getCertificate() != null) {
853                 key = cp.getCertificate().getPublicKey();
854             }
855             if (key != null &amp;&amp; !permitsImpl(key)) {
856                 if (nextConstraint != null) {
857                     nextConstraint.permits(cp);
858                     return;
859                 }
860                 throw new CertPathValidatorException(
861                         &quot;Algorithm constraints check failed on keysize limits. &quot; +
862                         algorithm + &quot; &quot; + KeyUtil.getKeySize(key) + &quot;bit key&quot; +
863                         extendedMsg(cp),
864                         null, null, -1, BasicReason.ALGORITHM_CONSTRAINED);
865             }
866         }
867 
868 
869         // Check if key constraint disable the specified key
870         // Uses old style permit()
871         @Override
</pre>
</td>
</tr>
</table>
<center><a href="DerValue.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DomainName.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
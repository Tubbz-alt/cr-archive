<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ECDHClientKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
<a name="1" id="anc1"></a>

 30 import java.security.GeneralSecurityException;
<a name="2" id="anc2"></a>

 31 import java.security.PublicKey;
<a name="3" id="anc3"></a>
 32 import java.security.interfaces.ECPublicKey;
<a name="4" id="anc4"></a><span class="line-added"> 33 import java.security.interfaces.XECPublicKey;</span>
<span class="line-added"> 34 import java.security.spec.AlgorithmParameterSpec;</span>
 35 import java.security.spec.ECParameterSpec;
<a name="5" id="anc5"></a><span class="line-modified"> 36 import java.security.spec.NamedParameterSpec;</span>

 37 import java.text.MessageFormat;
<a name="6" id="anc6"></a>
 38 import java.util.Locale;
 39 import javax.crypto.SecretKey;
<a name="7" id="anc7"></a>


 40 import sun.security.ssl.SSLHandshake.HandshakeMessage;
<a name="8" id="anc8"></a>
 41 import sun.security.ssl.X509Authentication.X509Credentials;
 42 import sun.security.ssl.X509Authentication.X509Possession;
<a name="9" id="anc9"></a>
 43 import sun.security.util.HexDumpEncoder;
 44 
 45 /**
 46  * Pack of the &quot;ClientKeyExchange&quot; handshake message.
<a name="10" id="anc10"></a><span class="line-added"> 47  *</span>
<span class="line-added"> 48  * This file is used by both the ECDH/ECDHE/XDH code since much of the</span>
<span class="line-added"> 49  * code is the same between the EC named groups (i.e.</span>
<span class="line-added"> 50  * x25519/x448/secp*r1), even though the APIs are very different (i.e.</span>
<span class="line-added"> 51  * ECPublicKey/XECPublicKey, KeyExchange.getInstance(&quot;EC&quot;/&quot;XDH&quot;), etc.).</span>
 52  */
 53 final class ECDHClientKeyExchange {
 54     static final SSLConsumer ecdhHandshakeConsumer =
 55             new ECDHClientKeyExchangeConsumer();
 56     static final HandshakeProducer ecdhHandshakeProducer =
 57             new ECDHClientKeyExchangeProducer();
 58 
 59     static final SSLConsumer ecdheHandshakeConsumer =
 60             new ECDHEClientKeyExchangeConsumer();
 61     static final HandshakeProducer ecdheHandshakeProducer =
 62             new ECDHEClientKeyExchangeProducer();
 63 
 64     /**
<a name="11" id="anc11"></a><span class="line-modified"> 65      * The ECDH/ECDHE/XDH ClientKeyExchange handshake message.</span>
 66      */
 67     private static final
 68             class ECDHClientKeyExchangeMessage extends HandshakeMessage {
 69         private final byte[] encodedPoint;
 70 
 71         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
<a name="12" id="anc12"></a><span class="line-modified"> 72                 byte[] encodedPublicKey) {</span>
 73             super(handshakeContext);
 74 
<a name="13" id="anc13"></a><span class="line-modified"> 75             this.encodedPoint = encodedPublicKey;</span>


 76         }
 77 
 78         ECDHClientKeyExchangeMessage(HandshakeContext handshakeContext,
 79                 ByteBuffer m) throws IOException {
 80             super(handshakeContext);
 81             if (m.remaining() != 0) {       // explicit PublicValueEncoding
 82                 this.encodedPoint = Record.getBytes8(m);
 83             } else {
 84                 this.encodedPoint = new byte[0];
 85             }
 86         }
 87 
<a name="14" id="anc14"></a>



























 88         @Override
 89         public SSLHandshake handshakeType() {
 90             return SSLHandshake.CLIENT_KEY_EXCHANGE;
 91         }
 92 
 93         @Override
 94         public int messageLength() {
 95             if (encodedPoint == null || encodedPoint.length == 0) {
 96                 return 0;
 97             } else {
 98                 return 1 + encodedPoint.length;
 99             }
100         }
101 
102         @Override
103         public void send(HandshakeOutStream hos) throws IOException {
104             if (encodedPoint != null &amp;&amp; encodedPoint.length != 0) {
105                 hos.putBytes8(encodedPoint);
106             }
107         }
108 
109         @Override
110         public String toString() {
111             MessageFormat messageFormat = new MessageFormat(
112                 &quot;\&quot;ECDH ClientKeyExchange\&quot;: &#39;{&#39;\n&quot; +
113                 &quot;  \&quot;ecdh public\&quot;: &#39;{&#39;\n&quot; +
114                 &quot;{0}\n&quot; +
115                 &quot;  &#39;}&#39;,\n&quot; +
116                 &quot;&#39;}&#39;&quot;,
117                 Locale.ENGLISH);
118             if (encodedPoint == null || encodedPoint.length == 0) {
119                 Object[] messageFields = {
120                     &quot;    &lt;implicit&gt;&quot;
121                 };
122                 return messageFormat.format(messageFields);
123             } else {
124                 HexDumpEncoder hexEncoder = new HexDumpEncoder();
125                 Object[] messageFields = {
126                     Utilities.indent(
127                             hexEncoder.encodeBuffer(encodedPoint), &quot;    &quot;),
128                 };
129                 return messageFormat.format(messageFields);
130             }
131         }
132     }
133 
134     /**
135      * The ECDH &quot;ClientKeyExchange&quot; handshake message producer.
136      */
137     private static final
138             class ECDHClientKeyExchangeProducer implements HandshakeProducer {
139         // Prevent instantiation of this class.
140         private ECDHClientKeyExchangeProducer() {
141             // blank
142         }
143 
144         @Override
145         public byte[] produce(ConnectionContext context,
146                 HandshakeMessage message) throws IOException {
147             // The producing happens in client side only.
148             ClientHandshakeContext chc = (ClientHandshakeContext)context;
149 
150             X509Credentials x509Credentials = null;
151             for (SSLCredentials credential : chc.handshakeCredentials) {
152                 if (credential instanceof X509Credentials) {
153                     x509Credentials = (X509Credentials)credential;
154                     break;
155                 }
156             }
157 
158             if (x509Credentials == null) {
159                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
160                     &quot;No server certificate for ECDH client key exchange&quot;);
161             }
162 
163             PublicKey publicKey = x509Credentials.popPublicKey;
<a name="15" id="anc15"></a><span class="line-modified">164 </span>
<span class="line-added">165             NamedGroup namedGroup = null;</span>
<span class="line-added">166             String algorithm = publicKey.getAlgorithm();</span>
<span class="line-added">167 </span>
<span class="line-added">168             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-added">169             // the creator functions.</span>
<span class="line-added">170             if (algorithm.equals(&quot;EC&quot;)) {</span>
<span class="line-added">171                 ECParameterSpec params = ((ECPublicKey)publicKey).getParams();</span>
<span class="line-added">172                 namedGroup = NamedGroup.valueOf(params);</span>
<span class="line-added">173             } else if (algorithm.equals(&quot;XDH&quot;)) {</span>
<span class="line-added">174                 AlgorithmParameterSpec params =</span>
<span class="line-added">175                         ((XECPublicKey)publicKey).getParams();</span>
<span class="line-added">176                 if (params instanceof NamedParameterSpec) {</span>
<span class="line-added">177                     String name = ((NamedParameterSpec)params).getName();</span>
<span class="line-added">178                     namedGroup = NamedGroup.nameOf(name);</span>
<span class="line-added">179                 }</span>
<span class="line-added">180             } else {</span>
181                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="16" id="anc16"></a><span class="line-modified">182                     &quot;Not EC/XDH server certificate for &quot; +</span>
<span class="line-added">183                             &quot;ECDH client key exchange&quot;);</span>
184             }
185 
<a name="17" id="anc17"></a>

186             if (namedGroup == null) {
187                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="18" id="anc18"></a><span class="line-modified">188                     &quot;Unsupported EC/XDH server cert for &quot; +</span>
<span class="line-added">189                         &quot;ECDH client key exchange&quot;);</span>
190             }
191 
<a name="19" id="anc19"></a><span class="line-modified">192             SSLPossession sslPossession = namedGroup.createPossession(</span>
<span class="line-modified">193                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">194 </span>
<span class="line-added">195             chc.handshakePossessions.add(sslPossession);</span>
196             ECDHClientKeyExchangeMessage cke =
197                     new ECDHClientKeyExchangeMessage(
<a name="20" id="anc20"></a><span class="line-modified">198                             chc, sslPossession.encode());</span>
199             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
200                 SSLLogger.fine(
201                     &quot;Produced ECDH ClientKeyExchange handshake message&quot;, cke);
202             }
203 
204             // Output the handshake message.
205             cke.write(chc.handshakeOutput);
206             chc.handshakeOutput.flush();
207 
208             // update the states
209             SSLKeyExchange ke = SSLKeyExchange.valueOf(
210                     chc.negotiatedCipherSuite.keyExchange,
211                     chc.negotiatedProtocol);
212             if (ke == null) {
213                 // unlikely
214                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
215                         &quot;Not supported key exchange type&quot;);
216             } else {
217                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
218                 SecretKey masterSecret =
219                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
220                 chc.handshakeSession.setMasterSecret(masterSecret);
221 
222                 SSLTrafficKeyDerivation kd =
223                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
224                 if (kd == null) {
225                     // unlikely
226                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
227                             &quot;Not supported key derivation: &quot; +
228                             chc.negotiatedProtocol);
229                 } else {
230                     chc.handshakeKeyDerivation =
231                         kd.createKeyDerivation(chc, masterSecret);
232                 }
233             }
234 
235             // The handshake message has been delivered.
236             return null;
237         }
238     }
239 
240     /**
241      * The ECDH &quot;ClientKeyExchange&quot; handshake message consumer.
242      */
243     private static final
244             class ECDHClientKeyExchangeConsumer implements SSLConsumer {
245         // Prevent instantiation of this class.
246         private ECDHClientKeyExchangeConsumer() {
247             // blank
248         }
249 
250         @Override
251         public void consume(ConnectionContext context,
252                 ByteBuffer message) throws IOException {
253             // The consuming happens in server side only.
254             ServerHandshakeContext shc = (ServerHandshakeContext)context;
255 
256             X509Possession x509Possession = null;
257             for (SSLPossession possession : shc.handshakePossessions) {
258                 if (possession instanceof X509Possession) {
259                     x509Possession = (X509Possession)possession;
260                     break;
261                 }
262             }
263 
264             if (x509Possession == null) {
265                 // unlikely, have been checked during cipher suite negotiation.
266                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
267                     &quot;No expected EC server cert for ECDH client key exchange&quot;);
268             }
269 
<a name="21" id="anc21"></a><span class="line-modified">270             // Determine which NamedGroup we&#39;ll be using, then use</span>
<span class="line-modified">271             // the creator functions.</span>
<span class="line-added">272             NamedGroup namedGroup = null;</span>
<span class="line-added">273 </span>
<span class="line-added">274             // Iteratively determine the X509Possession type&#39;s ParameterSpec.</span>
<span class="line-added">275             ECParameterSpec ecParams = x509Possession.getECParameterSpec();</span>
<span class="line-added">276             NamedParameterSpec namedParams = null;</span>
<span class="line-added">277             if (ecParams != null) {</span>
<span class="line-added">278                 namedGroup = NamedGroup.valueOf(ecParams);</span>
<span class="line-added">279             }</span>
<span class="line-added">280 </span>
<span class="line-added">281             // Wasn&#39;t EC, try XEC.</span>
<span class="line-added">282             if (ecParams == null) {</span>
<span class="line-added">283                 namedParams = x509Possession.getXECParameterSpec();</span>
<span class="line-added">284                 namedGroup = NamedGroup.nameOf(namedParams.getName());</span>
<span class="line-added">285             }</span>
<span class="line-added">286 </span>
<span class="line-added">287             // Can&#39;t figure this out, bail.</span>
<span class="line-added">288             if ((ecParams == null) &amp;&amp; (namedParams == null)) {</span>
289                 // unlikely, have been checked during cipher suite negotiation.
290                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="22" id="anc22"></a><span class="line-modified">291                     &quot;Not EC/XDH server cert for ECDH client key exchange&quot;);</span>
292             }
293 
<a name="23" id="anc23"></a><span class="line-modified">294             // unlikely, have been checked during cipher suite negotiation.</span>

295             if (namedGroup == null) {
<a name="24" id="anc24"></a>
296                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<a name="25" id="anc25"></a><span class="line-modified">297                     &quot;Unknown named group in server cert for &quot; +</span>
<span class="line-added">298                         &quot;ECDH client key exchange&quot;);</span>
299             }
300 
301             SSLKeyExchange ke = SSLKeyExchange.valueOf(
302                     shc.negotiatedCipherSuite.keyExchange,
303                     shc.negotiatedProtocol);
304             if (ke == null) {
305                 // unlikely
306                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
307                         &quot;Not supported key exchange type&quot;);
308             }
309 
<a name="26" id="anc26"></a><span class="line-modified">310             // parse either handshake message containing either EC/XEC.</span>
311             ECDHClientKeyExchangeMessage cke =
312                     new ECDHClientKeyExchangeMessage(shc, message);
313             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
314                 SSLLogger.fine(
315                     &quot;Consuming ECDH ClientKeyExchange handshake message&quot;, cke);
316             }
317 
318             // create the credentials
319             try {
<a name="27" id="anc27"></a><span class="line-modified">320                 NamedGroup ng = namedGroup;  // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">321                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">322                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">323                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">324                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">325                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">326 </span>
<span class="line-modified">327                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">328             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">329                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">330                         &quot;Cannot decode ECDH PublicKey: &quot; + namedGroup);</span>










331             }
332 
333             // update the states
334             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
335             SecretKey masterSecret =
336                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
337             shc.handshakeSession.setMasterSecret(masterSecret);
338 
339             SSLTrafficKeyDerivation kd =
340                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
341             if (kd == null) {
342                 // unlikely
343                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
344                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
345             } else {
346                 shc.handshakeKeyDerivation =
347                     kd.createKeyDerivation(shc, masterSecret);
348             }
349         }
350     }
351 
352     /**
353      * The ECDHE &quot;ClientKeyExchange&quot; handshake message producer.
354      */
355     private static final
356             class ECDHEClientKeyExchangeProducer implements HandshakeProducer {
357         // Prevent instantiation of this class.
358         private ECDHEClientKeyExchangeProducer() {
359             // blank
360         }
361 
362         @Override
363         public byte[] produce(ConnectionContext context,
364                 HandshakeMessage message) throws IOException {
365             // The producing happens in client side only.
366             ClientHandshakeContext chc = (ClientHandshakeContext)context;
367 
<a name="28" id="anc28"></a><span class="line-modified">368             SSLCredentials sslCredentials = null;</span>
<span class="line-added">369             NamedGroup ng = null;</span>
<span class="line-added">370             PublicKey publicKey = null;</span>
<span class="line-added">371 </span>
<span class="line-added">372             // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">373             // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
374             for (SSLCredentials cd : chc.handshakeCredentials) {
<a name="29" id="anc29"></a><span class="line-modified">375                 if (cd instanceof NamedGroupCredentials) {</span>
<span class="line-modified">376                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;</span>
<span class="line-added">377                     ng = creds.getNamedGroup();</span>
<span class="line-added">378                     publicKey = creds.getPublicKey();</span>
<span class="line-added">379                     sslCredentials = cd;</span>
380                     break;
381                 }
382             }
383 
<a name="30" id="anc30"></a><span class="line-modified">384             if (sslCredentials == null) {</span>
385                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
386                     &quot;No ECDHE credentials negotiated for client key exchange&quot;);
387             }
388 
<a name="31" id="anc31"></a><span class="line-modified">389             SSLPossession sslPossession = ng.createPossession(</span>
<span class="line-modified">390                     chc.sslContext.getSecureRandom());</span>
<span class="line-modified">391 </span>
<span class="line-added">392             chc.handshakePossessions.add(sslPossession);</span>
<span class="line-added">393 </span>
<span class="line-added">394             // Write the EC/XEC message.</span>
395             ECDHClientKeyExchangeMessage cke =
396                     new ECDHClientKeyExchangeMessage(
<a name="32" id="anc32"></a><span class="line-modified">397                             chc, sslPossession.encode());</span>
<span class="line-added">398 </span>
399             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
400                 SSLLogger.fine(
401                     &quot;Produced ECDHE ClientKeyExchange handshake message&quot;, cke);
402             }
403 
404             // Output the handshake message.
405             cke.write(chc.handshakeOutput);
406             chc.handshakeOutput.flush();
407 
408             // update the states
409             SSLKeyExchange ke = SSLKeyExchange.valueOf(
410                     chc.negotiatedCipherSuite.keyExchange,
411                     chc.negotiatedProtocol);
412             if (ke == null) {
413                 // unlikely
414                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
415                         &quot;Not supported key exchange type&quot;);
416             } else {
417                 SSLKeyDerivation masterKD = ke.createKeyDerivation(chc);
418                 SecretKey masterSecret =
419                         masterKD.deriveKey(&quot;MasterSecret&quot;, null);
420                 chc.handshakeSession.setMasterSecret(masterSecret);
421 
422                 SSLTrafficKeyDerivation kd =
423                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
424                 if (kd == null) {
425                     // unlikely
426                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
427                             &quot;Not supported key derivation: &quot; +
428                             chc.negotiatedProtocol);
429                 } else {
430                     chc.handshakeKeyDerivation =
431                         kd.createKeyDerivation(chc, masterSecret);
432                 }
433             }
434 
435             // The handshake message has been delivered.
436             return null;
437         }
438     }
439 
440     /**
441      * The ECDHE &quot;ClientKeyExchange&quot; handshake message consumer.
442      */
443     private static final
444             class ECDHEClientKeyExchangeConsumer implements SSLConsumer {
445         // Prevent instantiation of this class.
446         private ECDHEClientKeyExchangeConsumer() {
447             // blank
448         }
449 
450         @Override
451         public void consume(ConnectionContext context,
452                 ByteBuffer message) throws IOException {
453             // The consuming happens in server side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
<a name="33" id="anc33"></a><span class="line-modified">456             SSLPossession sslPossession = null;</span>
<span class="line-added">457             NamedGroup namedGroup = null;</span>
<span class="line-added">458 </span>
<span class="line-added">459            // Find a good EC/XEC credential to use, determine the</span>
<span class="line-added">460            // NamedGroup to use for creating Possessions/Credentials/Keys.</span>
461             for (SSLPossession possession : shc.handshakePossessions) {
<a name="34" id="anc34"></a><span class="line-modified">462                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified">463                     NamedGroupPossession poss =</span>
<span class="line-added">464                             (NamedGroupPossession)possession;</span>
<span class="line-added">465                     namedGroup = poss.getNamedGroup();</span>
<span class="line-added">466                     sslPossession = poss;</span>
467                     break;
468                 }
469             }
<a name="35" id="anc35"></a><span class="line-modified">470 </span>
<span class="line-added">471             if (sslPossession == null) {</span>
472                 // unlikely
473                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
474                     &quot;No expected ECDHE possessions for client key exchange&quot;);
475             }
476 
<a name="36" id="anc36"></a>

477             if (namedGroup == null) {
<a name="37" id="anc37"></a><span class="line-modified">478                 // unlikely, have been checked during cipher suite negotiation</span>
479                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
480                     &quot;Unsupported EC server cert for ECDHE client key exchange&quot;);
481             }
482 
483             SSLKeyExchange ke = SSLKeyExchange.valueOf(
484                     shc.negotiatedCipherSuite.keyExchange,
485                     shc.negotiatedProtocol);
486             if (ke == null) {
487                 // unlikely
488                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
489                         &quot;Not supported key exchange type&quot;);
490             }
491 
<a name="38" id="anc38"></a><span class="line-modified">492             // parse the EC/XEC handshake message</span>
493             ECDHClientKeyExchangeMessage cke =
494                     new ECDHClientKeyExchangeMessage(shc, message);
495             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
496                 SSLLogger.fine(
497                     &quot;Consuming ECDHE ClientKeyExchange handshake message&quot;, cke);
498             }
499 
500             // create the credentials
501             try {
<a name="39" id="anc39"></a><span class="line-modified">502                 NamedGroup ng = namedGroup; // &quot;effectively final&quot; the lambda</span>
<span class="line-modified">503                 // AlgorithmConstraints are checked internally.</span>
<span class="line-modified">504                 SSLCredentials sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">505                         cke.encodedPoint, shc.algorithmConstraints,</span>
<span class="line-modified">506                         s -&gt; shc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">507                         &quot;ClientKeyExchange &quot; + ng + &quot;: &quot; + s));</span>
<span class="line-modified">508 </span>
<span class="line-modified">509                 shc.handshakeCredentials.add(sslCredentials);</span>
<span class="line-modified">510             } catch (GeneralSecurityException e) {</span>
<span class="line-modified">511                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">512                         &quot;Cannot decode named group: &quot; + namedGroup);</span>










513             }
514 
515             // update the states
516             SSLKeyDerivation masterKD = ke.createKeyDerivation(shc);
517             SecretKey masterSecret =
518                     masterKD.deriveKey(&quot;MasterSecret&quot;, null);
519             shc.handshakeSession.setMasterSecret(masterSecret);
520 
521             SSLTrafficKeyDerivation kd =
522                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
523             if (kd == null) {
524                 // unlikely
525                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
526                     &quot;Not supported key derivation: &quot; + shc.negotiatedProtocol);
527             } else {
528                 shc.handshakeKeyDerivation =
529                     kd.createKeyDerivation(shc, masterSecret);
530             }
531         }
532     }
533 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.io.ByteArrayInputStream;
  30 import java.nio.ByteBuffer;
  31 import java.security.cert.Extension;
  32 import java.security.cert.CertificateFactory;
  33 import java.security.cert.CertificateException;
  34 import java.security.cert.X509Certificate;
  35 import java.text.MessageFormat;
  36 import java.util.ArrayList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import javax.net.ssl.SSLProtocolException;
  40 import sun.security.provider.certpath.OCSPResponse;
  41 import sun.security.provider.certpath.ResponderId;
  42 import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST;
  43 import static sun.security.ssl.SSLExtension.CH_STATUS_REQUEST_V2;
  44 import sun.security.ssl.SSLExtension.ExtensionConsumer;
  45 import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST;
  46 import static sun.security.ssl.SSLExtension.SH_STATUS_REQUEST_V2;
  47 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  48 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  49 import sun.security.util.DerInputStream;
  50 import sun.security.util.DerValue;
  51 import sun.security.util.HexDumpEncoder;
  52 
  53 /**
  54  * Pack of &quot;status_request&quot; and &quot;status_request_v2&quot; extensions.
  55  */
  56 final class CertStatusExtension {
  57     static final HandshakeProducer chNetworkProducer =
  58             new CHCertStatusReqProducer();
  59     static final ExtensionConsumer chOnLoadConsumer =
  60             new CHCertStatusReqConsumer();
  61 
  62     static final HandshakeProducer shNetworkProducer =
  63             new SHCertStatusReqProducer();
  64     static final ExtensionConsumer shOnLoadConsumer =
  65             new SHCertStatusReqConsumer();
  66 
  67     static final HandshakeProducer ctNetworkProducer =
  68             new CTCertStatusResponseProducer();
  69     static final ExtensionConsumer ctOnLoadConsumer =
  70             new CTCertStatusResponseConsumer();
  71 
  72     static final SSLStringizer certStatusReqStringizer =
  73             new CertStatusRequestStringizer();
  74 
  75     static final HandshakeProducer chV2NetworkProducer =
  76             new CHCertStatusReqV2Producer();
  77     static final ExtensionConsumer chV2OnLoadConsumer =
  78             new CHCertStatusReqV2Consumer();
  79 
  80     static final HandshakeProducer shV2NetworkProducer =
  81             new SHCertStatusReqV2Producer();
  82     static final ExtensionConsumer shV2OnLoadConsumer =
  83             new SHCertStatusReqV2Consumer();
  84 
  85     static final SSLStringizer certStatusReqV2Stringizer =
  86             new CertStatusRequestsStringizer();
  87 
  88     static final SSLStringizer certStatusRespStringizer =
  89             new CertStatusRespStringizer();
  90 
  91     /**
  92      * The &quot;status_request&quot; extension.
  93      *
  94      * RFC6066 defines the TLS extension,&quot;status_request&quot; (type 0x5),
  95      * which allows the client to request that the server perform OCSP
  96      * on the client&#39;s behalf.
  97      *
  98      * The &quot;extension data&quot; field of this extension contains a
  99      * &quot;CertificateStatusRequest&quot; structure:
 100      *
 101      *      struct {
 102      *          CertificateStatusType status_type;
 103      *          select (status_type) {
 104      *              case ocsp: OCSPStatusRequest;
 105      *          } request;
 106      *      } CertificateStatusRequest;
 107      *
 108      *      enum { ocsp(1), (255) } CertificateStatusType;
 109      *
 110      *      struct {
 111      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 112      *          Extensions  request_extensions;
 113      *      } OCSPStatusRequest;
 114      *
 115      *      opaque ResponderID&lt;1..2^16-1&gt;;
 116      *      opaque Extensions&lt;0..2^16-1&gt;;
 117      */
 118     static final class CertStatusRequestSpec implements SSLExtensionSpec {
 119         static final CertStatusRequestSpec DEFAULT =
 120                 new CertStatusRequestSpec(OCSPStatusRequest.EMPTY_OCSP);
 121 
 122         final CertStatusRequest statusRequest;
 123 
 124         private CertStatusRequestSpec(CertStatusRequest statusRequest) {
 125             this.statusRequest = statusRequest;
 126         }
 127 
 128         private CertStatusRequestSpec(ByteBuffer buffer) throws IOException {
 129             // Is it a empty extension_data?
 130             if (buffer.remaining() == 0) {
 131                 // server response
 132                 this.statusRequest = null;
 133                 return;
 134             }
 135 
 136             if (buffer.remaining() &lt; 1) {
 137                 throw new SSLProtocolException(
 138                     &quot;Invalid status_request extension: insufficient data&quot;);
 139             }
 140 
 141             byte statusType = (byte)Record.getInt8(buffer);
 142             byte[] encoded = new byte[buffer.remaining()];
 143             if (encoded.length != 0) {
 144                 buffer.get(encoded);
 145             }
 146             if (statusType == CertStatusRequestType.OCSP.id) {
 147                 this.statusRequest = new OCSPStatusRequest(statusType, encoded);
 148             } else {
 149                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 150                     SSLLogger.info(
 151                         &quot;Unknown certificate status request &quot; +
 152                         &quot;(status type: &quot; + statusType + &quot;)&quot;);
 153                 }
 154 
 155                 this.statusRequest = new CertStatusRequest(statusType, encoded);
 156             }
 157         }
 158 
 159         @Override
 160         public String toString() {
 161             return statusRequest == null ?
 162                         &quot;&lt;empty&gt;&quot; : statusRequest.toString();
 163         }
 164     }
 165 
 166     /**
 167      * Defines the CertificateStatus response structure as outlined in
 168      * RFC 6066.  This will contain a status response type, plus a single,
 169      * non-empty OCSP response in DER-encoded form.
 170      *
 171      * struct {
 172      *     CertificateStatusType status_type;
 173      *     select (status_type) {
 174      *         case ocsp: OCSPResponse;
 175      *     } response;
 176      * } CertificateStatus;
 177      */
 178     static final class CertStatusResponseSpec implements SSLExtensionSpec {
 179         final CertStatusResponse statusResponse;
 180 
 181         private CertStatusResponseSpec(CertStatusResponse resp) {
 182             this.statusResponse = resp;
 183         }
 184 
 185         private CertStatusResponseSpec(ByteBuffer buffer) throws IOException {
 186             if (buffer.remaining() &lt; 2) {
 187                 throw new SSLProtocolException(
 188                     &quot;Invalid status_request extension: insufficient data&quot;);
 189             }
 190 
 191             // Get the status type (1 byte) and response data (vector)
 192             byte type = (byte)Record.getInt8(buffer);
 193             byte[] respData = Record.getBytes24(buffer);
 194 
 195             // Create the CertStatusResponse based on the type
 196             if (type == CertStatusRequestType.OCSP.id) {
 197                 this.statusResponse = new OCSPStatusResponse(type, respData);
 198             } else {
 199                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 200                     SSLLogger.info(
 201                         &quot;Unknown certificate status response &quot; +
 202                         &quot;(status type: &quot; + type + &quot;)&quot;);
 203                 }
 204 
 205                 this.statusResponse = new CertStatusResponse(type, respData);
 206             }
 207         }
 208 
 209         @Override
 210         public String toString() {
 211             return statusResponse == null ?
 212                         &quot;&lt;empty&gt;&quot; : statusResponse.toString();
 213         }
 214     }
 215 
 216     private static final
 217             class CertStatusRequestStringizer implements SSLStringizer {
 218         @Override
 219         public String toString(ByteBuffer buffer) {
 220             try {
 221                 return (new CertStatusRequestSpec(buffer)).toString();
 222             } catch (IOException ioe) {
 223                 // For debug logging only, so please swallow exceptions.
 224                 return ioe.getMessage();
 225             }
 226         }
 227     }
 228 
 229     private static final
 230             class CertStatusRespStringizer implements SSLStringizer {
 231         @Override
 232         public String toString(ByteBuffer buffer) {
 233             try {
 234                 return (new CertStatusResponseSpec(buffer)).toString();
 235             } catch (IOException ioe) {
 236                  // For debug logging only, so please swallow exceptions.
 237                 return ioe.getMessage();
 238             }
 239         }
 240     }
 241 
 242     static enum CertStatusRequestType {
 243         OCSP        ((byte)0x01,    &quot;ocsp&quot;),        // RFC 6066/6961
 244         OCSP_MULTI  ((byte)0x02,    &quot;ocsp_multi&quot;);  // RFC 6961
 245 
 246         final byte id;
 247         final String name;
 248 
 249         private CertStatusRequestType(byte id, String name) {
 250             this.id = id;
 251             this.name = name;
 252         }
 253 
 254         /**
 255          * Returns the enum constant of the specified id (see RFC 6066).
 256          */
 257         static CertStatusRequestType valueOf(byte id) {
 258             for (CertStatusRequestType srt : CertStatusRequestType.values()) {
 259                 if (srt.id == id) {
 260                     return srt;
 261                 }
 262             }
 263 
 264             return null;
 265         }
 266 
 267         static String nameOf(byte id) {
 268             for (CertStatusRequestType srt : CertStatusRequestType.values()) {
 269                 if (srt.id == id) {
 270                     return srt.name;
 271                 }
 272             }
 273 
 274             return &quot;UNDEFINED-CERT-STATUS-TYPE(&quot; + id + &quot;)&quot;;
 275         }
 276     }
 277 
 278     static class CertStatusRequest {
 279         final byte statusType;
 280         final byte[] encodedRequest;
 281 
 282         protected CertStatusRequest(byte statusType, byte[] encodedRequest) {
 283             this.statusType = statusType;
 284             this.encodedRequest = encodedRequest;
 285         }
 286 
 287         @Override
 288         public String toString() {
 289             MessageFormat messageFormat = new MessageFormat(
 290                 &quot;\&quot;certificate status type\&quot;: {0}\n&quot; +
 291                 &quot;\&quot;encoded certificate status\&quot;: &#39;{&#39;\n&quot; +
 292                 &quot;{1}\n&quot; +
 293                 &quot;&#39;}&#39;&quot;,
 294                 Locale.ENGLISH);
 295 
 296             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 297             String encoded = hexEncoder.encodeBuffer(encodedRequest);
 298 
 299             Object[] messageFields = {
 300                 CertStatusRequestType.nameOf(statusType),
 301                 Utilities.indent(encoded)
 302             };
 303 
 304             return messageFormat.format(messageFields);
 305         }
 306     }
 307 
 308     /*
 309      * RFC6066 defines the TLS extension,&quot;status_request&quot; (type 0x5),
 310      * which allows the client to request that the server perform OCSP
 311      * on the client&#39;s behalf.
 312      *
 313      * The RFC defines an OCSPStatusRequest structure:
 314      *
 315      *      struct {
 316      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 317      *          Extensions  request_extensions;
 318      *      } OCSPStatusRequest;
 319      */
 320     static final class OCSPStatusRequest extends CertStatusRequest {
 321         static final OCSPStatusRequest EMPTY_OCSP;
 322         static final OCSPStatusRequest EMPTY_OCSP_MULTI;
 323 
 324         final List&lt;ResponderId&gt; responderIds;
 325         final List&lt;Extension&gt; extensions;
 326         private final int ridListLen;
 327         private final int extListLen;
 328 
 329         static {
 330             OCSPStatusRequest ocspReq = null;
 331             OCSPStatusRequest multiReq = null;
 332 
 333             try {
 334                 ocspReq = new OCSPStatusRequest(
 335                         CertStatusRequestType.OCSP.id,
 336                         new byte[] {0x00, 0x00, 0x00, 0x00});
 337                 multiReq = new OCSPStatusRequest(
 338                     CertStatusRequestType.OCSP_MULTI.id,
 339                     new byte[] {0x00, 0x00, 0x00, 0x00});
 340             } catch (IOException ioe) {
 341                 // unlikely
 342             }
 343 
 344             EMPTY_OCSP = ocspReq;
 345             EMPTY_OCSP_MULTI = multiReq;
 346         }
 347 
 348         private OCSPStatusRequest(byte statusType,
 349                 byte[] encoded) throws IOException {
 350             super(statusType, encoded);
 351 
 352             if (encoded == null || encoded.length &lt; 4) {
 353                                         //  2: length of responder_id_list
 354                                         // +2: length of request_extensions
 355                 throw new SSLProtocolException(
 356                         &quot;Invalid OCSP status request: insufficient data&quot;);
 357             }
 358 
 359             List&lt;ResponderId&gt; rids = new ArrayList&lt;&gt;();
 360             List&lt;Extension&gt; exts = new ArrayList&lt;&gt;();
 361             ByteBuffer m = ByteBuffer.wrap(encoded);
 362 
 363             this.ridListLen = Record.getInt16(m);
 364             if (m.remaining() &lt; (ridListLen + 2)) {
 365                 throw new SSLProtocolException(
 366                         &quot;Invalid OCSP status request: insufficient data&quot;);
 367             }
 368 
 369             int ridListBytesRemaining = ridListLen;
 370             while (ridListBytesRemaining &gt;= 2) {    // 2: length of responder_id
 371                 byte[] ridBytes = Record.getBytes16(m);
 372                 try {
 373                     rids.add(new ResponderId(ridBytes));
 374                 } catch (IOException ioe) {
 375                     throw new SSLProtocolException(
 376                         &quot;Invalid OCSP status request: invalid responder ID&quot;);
 377                 }
 378                 ridListBytesRemaining -= ridBytes.length + 2;
 379             }
 380 
 381             if (ridListBytesRemaining != 0) {
 382                     throw new SSLProtocolException(
 383                         &quot;Invalid OCSP status request: incomplete data&quot;);
 384             }
 385 
 386             byte[] extListBytes = Record.getBytes16(m);
 387             this.extListLen = extListBytes.length;
 388             if (extListLen &gt; 0) {
 389                 try {
 390                     DerInputStream dis = new DerInputStream(extListBytes);
 391                     DerValue[] extSeqContents =
 392                             dis.getSequence(extListBytes.length);
 393                     for (DerValue extDerVal : extSeqContents) {
 394                         exts.add(new sun.security.x509.Extension(extDerVal));
 395                     }
 396                 } catch (IOException ioe) {
 397                     throw new SSLProtocolException(
 398                         &quot;Invalid OCSP status request: invalid extension&quot;);
 399                 }
 400             }
 401 
 402             this.responderIds = rids;
 403             this.extensions = exts;
 404         }
 405 
 406         @Override
 407         public String toString() {
 408             MessageFormat messageFormat = new MessageFormat(
 409                 &quot;\&quot;certificate status type\&quot;: {0}\n&quot; +
 410                 &quot;\&quot;OCSP status request\&quot;: &#39;{&#39;\n&quot; +
 411                 &quot;{1}\n&quot; +
 412                 &quot;&#39;}&#39;&quot;,
 413                 Locale.ENGLISH);
 414 
 415             MessageFormat requestFormat = new MessageFormat(
 416                 &quot;\&quot;responder_id\&quot;: {0}\n&quot; +
 417                 &quot;\&quot;request extensions\&quot;: &#39;{&#39;\n&quot; +
 418                 &quot;{1}\n&quot; +
 419                 &quot;&#39;}&#39;&quot;,
 420                 Locale.ENGLISH);
 421 
 422             String ridStr = &quot;&lt;empty&gt;&quot;;
 423             if (!responderIds.isEmpty()) {
 424                 ridStr = responderIds.toString();
 425             }
 426 
 427             String extsStr = &quot;&lt;empty&gt;&quot;;
 428             if (!extensions.isEmpty()) {
 429                 StringBuilder extBuilder = new StringBuilder(512);
 430                 boolean isFirst = true;
 431                 for (Extension ext : this.extensions) {
 432                     if (isFirst) {
 433                         isFirst = false;
 434                     } else {
 435                         extBuilder.append(&quot;,\n&quot;);
 436                     }
 437                     extBuilder.append(
 438                             &quot;{\n&quot; + Utilities.indent(ext.toString()) + &quot;}&quot;);
 439                 }
 440 
 441                 extsStr = extBuilder.toString();
 442             }
 443 
 444             Object[] requestFields = {
 445                     ridStr,
 446                     Utilities.indent(extsStr)
 447                 };
 448             String ocspStatusRequest = requestFormat.format(requestFields);
 449 
 450             Object[] messageFields = {
 451                     CertStatusRequestType.nameOf(statusType),
 452                     Utilities.indent(ocspStatusRequest)
 453                 };
 454 
 455             return messageFormat.format(messageFields);
 456         }
 457     }
 458 
 459     static class CertStatusResponse {
 460         final byte statusType;
 461         final byte[] encodedResponse;
 462 
 463         protected CertStatusResponse(byte statusType, byte[] respDer) {
 464             this.statusType = statusType;
 465             this.encodedResponse = respDer;
 466         }
 467 
 468         byte[] toByteArray() throws IOException {
 469             // Create a byte array large enough to handle the status_type
 470             // field (1) + OCSP length (3) + OCSP data (variable)
 471             byte[] outData = new byte[encodedResponse.length + 4];
 472             ByteBuffer buf = ByteBuffer.wrap(outData);
 473             Record.putInt8(buf, statusType);
 474             Record.putBytes24(buf, encodedResponse);
 475             return buf.array();
 476         }
 477 
 478         @Override
 479         public String toString() {
 480             MessageFormat messageFormat = new MessageFormat(
 481                 &quot;\&quot;certificate status response type\&quot;: {0}\n&quot; +
 482                 &quot;\&quot;encoded certificate status\&quot;: &#39;{&#39;\n&quot; +
 483                 &quot;{1}\n&quot; +
 484                 &quot;&#39;}&#39;&quot;,
 485                 Locale.ENGLISH);
 486 
 487             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 488             String encoded = hexEncoder.encodeBuffer(encodedResponse);
 489 
 490             Object[] messageFields = {
 491                 CertStatusRequestType.nameOf(statusType),
 492                 Utilities.indent(encoded)
 493             };
 494 
 495             return messageFormat.format(messageFields);
 496         }
 497     }
 498 
 499     static final class OCSPStatusResponse extends CertStatusResponse {
 500         final OCSPResponse ocspResponse;
 501 
 502         private OCSPStatusResponse(byte statusType,
 503                 byte[] encoded) throws IOException {
 504             super(statusType, encoded);
 505 
 506             // The DER-encoded OCSP response must not be zero length
 507             if (encoded == null || encoded.length &lt; 1) {
 508                 throw new SSLProtocolException(
 509                         &quot;Invalid OCSP status response: insufficient data&quot;);
 510             }
 511 
 512             // Otherwise, make an OCSPResponse object from the data
 513             ocspResponse = new OCSPResponse(encoded);
 514         }
 515 
 516         @Override
 517         public String toString() {
 518             MessageFormat messageFormat = new MessageFormat(
 519                 &quot;\&quot;certificate status response type\&quot;: {0}\n&quot; +
 520                 &quot;\&quot;OCSP status response\&quot;: &#39;{&#39;\n&quot; +
 521                 &quot;{1}\n&quot; +
 522                 &quot;&#39;}&#39;&quot;,
 523                 Locale.ENGLISH);
 524 
 525             Object[] messageFields = {
 526                 CertStatusRequestType.nameOf(statusType),
 527                 Utilities.indent(ocspResponse.toString())
 528             };
 529 
 530             return messageFormat.format(messageFields);
 531         }
 532     }
 533 
 534     /**
 535      * Network data producer of a &quot;status_request&quot; extension in the
 536      * ClientHello handshake message.
 537      */
 538     private static final
 539             class CHCertStatusReqProducer implements HandshakeProducer {
 540         // Prevent instantiation of this class.
 541         private CHCertStatusReqProducer() {
 542             // blank
 543         }
 544 
 545         @Override
 546         public byte[] produce(ConnectionContext context,
 547                 HandshakeMessage message) throws IOException {
 548             // The producing happens in client side only.
 549             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 550 
 551             if (!chc.sslContext.isStaplingEnabled(true)) {
 552                 return null;
 553             }
 554 
 555             if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {
 556                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 557                     SSLLogger.fine(
 558                         &quot;Ignore unavailable extension: &quot; +
 559                         CH_STATUS_REQUEST.name);
 560                 }
 561                 return null;
 562             }
 563 
 564             // Produce the extension.
 565             //
 566             // We are using empty OCSPStatusRequest at present. May extend to
 567             // support specific responder or extensions later.
 568             byte[] extData = new byte[] {0x01, 0x00, 0x00, 0x00, 0x00};
 569 
 570             // Update the context.
 571             chc.handshakeExtensions.put(
 572                     CH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
 573 
 574             return extData;
 575         }
 576     }
 577 
 578     /**
 579      * Network data consumer of a &quot;status_request&quot; extension in the
 580      * ClientHello handshake message.
 581      */
 582     private static final
 583             class CHCertStatusReqConsumer implements ExtensionConsumer {
 584         // Prevent instantiation of this class.
 585         private CHCertStatusReqConsumer() {
 586             // blank
 587         }
 588 
 589         @Override
 590         public void consume(ConnectionContext context,
 591             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 592 
 593             // The consuming happens in server side only.
 594             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 595 
 596             if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST)) {
 597                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 598                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
 599                         CH_STATUS_REQUEST.name);
 600                 }
 601                 return;     // ignore the extension
 602             }
 603 
 604             // Parse the extension.
 605             CertStatusRequestSpec spec;
 606             try {
 607                 spec = new CertStatusRequestSpec(buffer);
 608             } catch (IOException ioe) {
 609                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 610             }
 611 
 612             // Update the context.
 613             shc.handshakeExtensions.put(CH_STATUS_REQUEST, spec);
 614             if (!shc.isResumption &amp;&amp;
 615                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 616                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 617                     SSLHandshake.CERTIFICATE_STATUS);
 618             }   // Otherwise, the certificate status presents in server cert.
 619 
 620             // No impact on session resumption.
 621         }
 622     }
 623 
 624     /**
 625      * Network data producer of a &quot;status_request&quot; extension in the
 626      * ServerHello handshake message.
 627      */
 628     private static final
 629             class SHCertStatusReqProducer implements HandshakeProducer {
 630         // Prevent instantiation of this class.
 631         private SHCertStatusReqProducer() {
 632             // blank
 633         }
 634 
 635         @Override
 636         public byte[] produce(ConnectionContext context,
 637                 HandshakeMessage message) throws IOException {
 638             // The producing happens in client side only.
 639             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 640 
 641             // The StaplingParameters in the ServerHandshakeContext will
 642             // contain the info about what kind of stapling (if any) to
 643             // perform and whether this status_request extension should be
 644             // produced or the status_request_v2 (found in a different producer)
 645             // No explicit check is required for isStaplingEnabled here.  If
 646             // it is false then stapleParams will be null.  If it is true
 647             // then stapleParams may or may not be false and the check below
 648             // is sufficient.
 649             if ((shc.stapleParams == null) ||
 650                     (shc.stapleParams.statusRespExt !=
 651                     SSLExtension.CH_STATUS_REQUEST)) {
 652                 return null;    // Do not produce status_request in ServerHello
 653             }
 654 
 655             // In response to &quot;status_request&quot; extension request only.
 656             CertStatusRequestSpec spec = (CertStatusRequestSpec)
 657                     shc.handshakeExtensions.get(CH_STATUS_REQUEST);
 658             if (spec == null) {
 659                 // Ignore, no status_request extension requested.
 660                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 661                     SSLLogger.finest(
 662                         &quot;Ignore unavailable extension: &quot; +
 663                         CH_STATUS_REQUEST.name);
 664                 }
 665 
 666                 return null;        // ignore the extension
 667             }
 668 
 669             // Is it a session resuming?
 670             if (shc.isResumption) {
 671                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 672                     SSLLogger.finest(
 673                         &quot;No status_request response for session resuming&quot;);
 674                 }
 675 
 676                 return null;        // ignore the extension
 677             }
 678 
 679             // The &quot;extension_data&quot; in the extended ServerHello handshake
 680             // message MUST be empty.
 681             byte[] extData = new byte[0];
 682 
 683             // Update the context.
 684             shc.handshakeExtensions.put(
 685                     SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
 686 
 687             return extData;
 688         }
 689     }
 690 
 691     /**
 692      * Network data consumer of a &quot;status_request&quot; extension in the
 693      * ServerHello handshake message.
 694      */
 695     private static final
 696             class SHCertStatusReqConsumer implements ExtensionConsumer {
 697         // Prevent instantiation of this class.
 698         private SHCertStatusReqConsumer() {
 699             // blank
 700         }
 701 
 702         @Override
 703         public void consume(ConnectionContext context,
 704             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 705 
 706             // The producing happens in client side only.
 707             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 708 
 709             // In response to &quot;status_request&quot; extension request only.
 710             CertStatusRequestSpec requestedCsr = (CertStatusRequestSpec)
 711                     chc.handshakeExtensions.get(CH_STATUS_REQUEST);
 712             if (requestedCsr == null) {
 713                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 714                     &quot;Unexpected status_request extension in ServerHello&quot;);
 715             }
 716 
 717             // Parse the extension.
 718             if (buffer.hasRemaining()) {
 719                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 720                   &quot;Invalid status_request extension in ServerHello message: &quot; +
 721                   &quot;the extension data must be empty&quot;);
 722             }
 723 
 724             // Update the context.
 725             chc.handshakeExtensions.put(
 726                     SH_STATUS_REQUEST, CertStatusRequestSpec.DEFAULT);
 727             chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 728                     SSLHandshake.CERTIFICATE_STATUS);
 729 
 730             // Since we&#39;ve received a legitimate status_request in the
 731             // ServerHello, stapling is active if it&#39;s been enabled.
 732             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
 733 
 734             // No impact on session resumption.
 735         }
 736     }
 737 
 738     /**
 739      * The &quot;status_request_v2&quot; extension.
 740      *
 741      * RFC6961 defines the TLS extension,&quot;status_request_v2&quot; (type 0x5),
 742      * which allows the client to request that the server perform OCSP
 743      * on the client&#39;s behalf.
 744      *
 745      * The RFC defines an CertStatusReqItemV2 structure:
 746      *
 747      *      struct {
 748      *          CertificateStatusType status_type;
 749      *          uint16 request_length;
 750      *          select (status_type) {
 751      *              case ocsp: OCSPStatusRequest;
 752      *              case ocsp_multi: OCSPStatusRequest;
 753      *          } request;
 754      *      } CertificateStatusRequestItemV2;
 755      *
 756      *      enum { ocsp(1), ocsp_multi(2), (255) } CertificateStatusType;
 757      *      struct {
 758      *        ResponderID responder_id_list&lt;0..2^16-1&gt;;
 759      *        Extensions request_extensions;
 760      *      } OCSPStatusRequest;
 761      *
 762      *      opaque ResponderID&lt;1..2^16-1&gt;;
 763      *      opaque Extensions&lt;0..2^16-1&gt;;
 764      *
 765      *      struct {
 766      *        CertificateStatusRequestItemV2
 767      *                         certificate_status_req_list&lt;1..2^16-1&gt;;
 768      *      } CertificateStatusRequestListV2;
 769      */
 770     static final class CertStatusRequestV2Spec implements SSLExtensionSpec {
 771         static final CertStatusRequestV2Spec DEFAULT =
 772                 new CertStatusRequestV2Spec(new CertStatusRequest[] {
 773                         OCSPStatusRequest.EMPTY_OCSP_MULTI});
 774 
 775         final CertStatusRequest[] certStatusRequests;
 776 
 777         private CertStatusRequestV2Spec(CertStatusRequest[] certStatusRequests) {
 778             this.certStatusRequests = certStatusRequests;
 779         }
 780 
 781         private CertStatusRequestV2Spec(ByteBuffer message) throws IOException {
 782             // Is it a empty extension_data?
 783             if (message.remaining() == 0) {
 784                 // server response
 785                 this.certStatusRequests = new CertStatusRequest[0];
 786                 return;
 787             }
 788 
 789             if (message.remaining() &lt; 5) {  //  2: certificate_status_req_list
 790                                             // +1: status_type
 791                                             // +2: request_length
 792                 throw new SSLProtocolException(
 793                     &quot;Invalid status_request_v2 extension: insufficient data&quot;);
 794             }
 795 
 796             int listLen = Record.getInt16(message);
 797             if (listLen &lt;= 0) {
 798                 throw new SSLProtocolException(
 799                     &quot;certificate_status_req_list length must be positive &quot; +
 800                     &quot;(received length: &quot; + listLen + &quot;)&quot;);
 801             }
 802 
 803             int remaining = listLen;
 804             List&lt;CertStatusRequest&gt; statusRequests = new ArrayList&lt;&gt;();
 805             while (remaining &gt; 0) {
 806                 byte statusType = (byte)Record.getInt8(message);
 807                 int requestLen = Record.getInt16(message);
 808 
 809                 if (message.remaining() &lt; requestLen) {
 810                     throw new SSLProtocolException(
 811                             &quot;Invalid status_request_v2 extension: &quot; +
 812                             &quot;insufficient data (request_length=&quot; + requestLen +
 813                             &quot;, remining=&quot; + message.remaining() + &quot;)&quot;);
 814                 }
 815 
 816                 byte[] encoded = new byte[requestLen];
 817                 if (encoded.length != 0) {
 818                     message.get(encoded);
 819                 }
 820                 remaining -= 3;     // 1(status type) + 2(request_length) bytes
 821                 remaining -= requestLen;
 822 
 823                 if (statusType == CertStatusRequestType.OCSP.id ||
 824                         statusType == CertStatusRequestType.OCSP_MULTI.id) {
 825                     if (encoded.length &lt; 4) {
 826                                         //  2: length of responder_id_list
 827                                         // +2: length of request_extensions
 828                         throw new SSLProtocolException(
 829                             &quot;Invalid status_request_v2 extension: &quot; +
 830                             &quot;insufficient data&quot;);
 831                     }
 832                     statusRequests.add(
 833                             new OCSPStatusRequest(statusType, encoded));
 834                 } else {
 835                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 836                         SSLLogger.info(
 837                                 &quot;Unknown certificate status request &quot; +
 838                                 &quot;(status type: &quot; + statusType + &quot;)&quot;);
 839                     }
 840                     statusRequests.add(
 841                             new CertStatusRequest(statusType, encoded));
 842                 }
 843             }
 844 
 845             certStatusRequests =
 846                     statusRequests.toArray(new CertStatusRequest[0]);
 847         }
 848 
 849         @Override
 850         public String toString() {
 851             if (certStatusRequests == null || certStatusRequests.length == 0) {
 852                 return &quot;&lt;empty&gt;&quot;;
 853             } else {
 854                 MessageFormat messageFormat = new MessageFormat(
 855                     &quot;\&quot;cert status request\&quot;: &#39;{&#39;\n{0}\n&#39;}&#39;&quot;, Locale.ENGLISH);
 856 
 857                 StringBuilder builder = new StringBuilder(512);
 858                 boolean isFirst = true;
 859                 for (CertStatusRequest csr : certStatusRequests) {
 860                     if (isFirst) {
 861                         isFirst = false;
 862                     } else {
 863                         builder.append(&quot;, &quot;);
 864                     }
 865                     Object[] messageFields = {
 866                             Utilities.indent(csr.toString())
 867                         };
 868                     builder.append(messageFormat.format(messageFields));
 869                 }
 870 
 871                 return builder.toString();
 872             }
 873         }
 874     }
 875 
 876     private static final
 877             class CertStatusRequestsStringizer implements SSLStringizer {
 878         @Override
 879         public String toString(ByteBuffer buffer) {
 880             try {
 881                 return (new CertStatusRequestV2Spec(buffer)).toString();
 882             } catch (IOException ioe) {
 883                 // For debug logging only, so please swallow exceptions.
 884                 return ioe.getMessage();
 885             }
 886         }
 887     }
 888 
 889     /**
 890      * Network data producer of a &quot;status_request_v2&quot; extension in the
 891      * ClientHello handshake message.
 892      */
 893     private static final
 894             class CHCertStatusReqV2Producer implements HandshakeProducer {
 895         // Prevent instantiation of this class.
 896         private CHCertStatusReqV2Producer() {
 897             // blank
 898         }
 899 
 900         @Override
 901         public byte[] produce(ConnectionContext context,
 902                 HandshakeMessage message) throws IOException {
 903             // The producing happens in client side only.
 904             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 905 
 906             if (!chc.sslContext.isStaplingEnabled(true)) {
 907                 return null;
 908             }
 909 
 910             if (!chc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {
 911                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 912                     SSLLogger.finest(
 913                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 914                 }
 915 
 916                 return null;
 917             }
 918 
 919             // Produce the extension.
 920             //
 921             // We are using empty OCSPStatusRequest at present. May extend to
 922             // support specific responder or extensions later.
 923             byte[] extData = new byte[] {
 924                 0x00, 0x07, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00};
 925 
 926             // Update the context.
 927             chc.handshakeExtensions.put(
 928                     CH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
 929 
 930             return extData;
 931         }
 932     }
 933 
 934     /**
 935      * Network data consumer of a &quot;status_request_v2&quot; extension in the
 936      * ClientHello handshake message.
 937      */
 938     private static final
 939             class CHCertStatusReqV2Consumer implements ExtensionConsumer {
 940         // Prevent instantiation of this class.
 941         private CHCertStatusReqV2Consumer() {
 942             // blank
 943         }
 944 
 945         @Override
 946         public void consume(ConnectionContext context,
 947             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 948 
 949             // The consuming happens in server side only.
 950             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 951 
 952             if (!shc.sslConfig.isAvailable(CH_STATUS_REQUEST_V2)) {
 953                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 954                     SSLLogger.finest(
 955                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 956                 }
 957 
 958                 return;     // ignore the extension
 959             }
 960 
 961             // Parse the extension.
 962             CertStatusRequestV2Spec spec;
 963             try {
 964                 spec = new CertStatusRequestV2Spec(buffer);
 965             } catch (IOException ioe) {
 966                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
 967             }
 968 
 969             // Update the context.
 970             shc.handshakeExtensions.put(CH_STATUS_REQUEST_V2, spec);
 971             if (!shc.isResumption) {
 972                 shc.handshakeProducers.putIfAbsent(
 973                         SSLHandshake.CERTIFICATE_STATUS.id,
 974                         SSLHandshake.CERTIFICATE_STATUS);
 975             }
 976 
 977             // No impact on session resumption.
 978         }
 979     }
 980 
 981     /**
 982      * Network data producer of a &quot;status_request_v2&quot; extension in the
 983      * ServerHello handshake message.
 984      */
 985     private static final
 986             class SHCertStatusReqV2Producer implements HandshakeProducer {
 987         // Prevent instantiation of this class.
 988         private SHCertStatusReqV2Producer() {
 989             // blank
 990         }
 991 
 992         @Override
 993         public byte[] produce(ConnectionContext context,
 994                 HandshakeMessage message) throws IOException {
 995             // The producing happens in client side only.
 996 
 997             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 998             // The StaplingParameters in the ServerHandshakeContext will
 999             // contain the info about what kind of stapling (if any) to
1000             // perform and whether this status_request extension should be
1001             // produced or the status_request_v2 (found in a different producer)
1002             // No explicit check is required for isStaplingEnabled here.  If
1003             // it is false then stapleParams will be null.  If it is true
1004             // then stapleParams may or may not be false and the check below
1005             // is sufficient.
1006             if ((shc.stapleParams == null) ||
1007                     (shc.stapleParams.statusRespExt !=
1008                     SSLExtension.CH_STATUS_REQUEST_V2)) {
1009                 return null;    // Do not produce status_request_v2 in SH
1010             }
1011 
1012             // In response to &quot;status_request_v2&quot; extension request only
1013             CertStatusRequestV2Spec spec = (CertStatusRequestV2Spec)
1014                     shc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);
1015             if (spec == null) {
1016                 // Ignore, no status_request_v2 extension requested.
1017                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1018                     SSLLogger.finest(
1019                         &quot;Ignore unavailable status_request_v2 extension&quot;);
1020                 }
1021 
1022                 return null;        // ignore the extension
1023             }
1024 
1025             // Is it a session resuming?
1026             if (shc.isResumption) {
1027                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1028                     SSLLogger.finest(
1029                         &quot;No status_request_v2 response for session resumption&quot;);
1030                 }
1031                 return null;        // ignore the extension
1032             }
1033 
1034             // The &quot;extension_data&quot; in the extended ServerHello handshake
1035             // message MUST be empty.
1036             byte[] extData = new byte[0];
1037 
1038             // Update the context.
1039             shc.handshakeExtensions.put(
1040                     SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
1041 
1042             return extData;
1043         }
1044     }
1045 
1046     /**
1047      * Network data consumer of a &quot;status_request_v2&quot; extension in the
1048      * ServerHello handshake message.
1049      */
1050     private static final
1051             class SHCertStatusReqV2Consumer implements ExtensionConsumer {
1052         // Prevent instantiation of this class.
1053         private SHCertStatusReqV2Consumer() {
1054             // blank
1055         }
1056 
1057         @Override
1058         public void consume(ConnectionContext context,
1059             HandshakeMessage message, ByteBuffer buffer) throws IOException {
1060 
1061             // The consumption happens in client side only.
1062             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1063 
1064             // In response to &quot;status_request&quot; extension request only
1065             CertStatusRequestV2Spec requestedCsr = (CertStatusRequestV2Spec)
1066                     chc.handshakeExtensions.get(CH_STATUS_REQUEST_V2);
1067             if (requestedCsr == null) {
1068                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1069                     &quot;Unexpected status_request_v2 extension in ServerHello&quot;);
1070             }
1071 
1072             // Parse the extension.
1073             if (buffer.hasRemaining()) {
1074                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1075                   &quot;Invalid status_request_v2 extension in ServerHello: &quot; +
1076                   &quot;the extension data must be empty&quot;);
1077             }
1078 
1079             // Update the context.
1080             chc.handshakeExtensions.put(
1081                     SH_STATUS_REQUEST_V2, CertStatusRequestV2Spec.DEFAULT);
1082             chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
1083                     SSLHandshake.CERTIFICATE_STATUS);
1084 
1085             // Since we&#39;ve received a legitimate status_request in the
1086             // ServerHello, stapling is active if it&#39;s been enabled.
1087             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
1088 
1089             // No impact on session resumption.
1090         }
1091     }
1092 
1093     private static final
1094             class CTCertStatusResponseProducer implements HandshakeProducer {
1095         // Prevent instantiation of this class.
1096         private CTCertStatusResponseProducer() {
1097             // blank
1098         }
1099 
1100         @Override
1101         public byte[] produce(ConnectionContext context,
1102                 HandshakeMessage message) throws IOException {
1103             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1104             byte[] producedData = null;
1105 
1106             // Stapling needs to be active and have valid data to proceed
1107             if (shc.stapleParams == null) {
1108                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1109                     SSLLogger.finest(
1110                         &quot;Stapling is disabled for this connection&quot;);
1111                 }
1112                 return null;
1113             }
1114 
1115             // There needs to be a non-null CertificateEntry to proceed
1116             if (shc.currentCertEntry == null) {
1117                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1118                     SSLLogger.finest(&quot;Found null CertificateEntry in context&quot;);
1119                 }
1120                 return null;
1121             }
1122 
1123             // Pull the certificate from the CertificateEntry and find
1124             // a response from the response map.  If one exists we will
1125             // staple it.
1126             try {
1127                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1128                 X509Certificate x509Cert =
1129                         (X509Certificate)cf.generateCertificate(
1130                                 new ByteArrayInputStream(
1131                                         shc.currentCertEntry.encoded));
1132                 byte[] respBytes = shc.stapleParams.responseMap.get(x509Cert);
1133                 if (respBytes == null) {
1134                     // We&#39;re done with this entry.  Clear it from the context
1135                     if (SSLLogger.isOn &amp;&amp;
1136                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1137                         SSLLogger.finest(&quot;No status response found for &quot; +
1138                                 x509Cert.getSubjectX500Principal());
1139                     }
1140                     shc.currentCertEntry = null;
1141                     return null;
1142                 }
1143 
1144                 // Build a proper response buffer from the stapling information
1145                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1146                     SSLLogger.finest(&quot;Found status response for &quot; +
1147                             x509Cert.getSubjectX500Principal() +
1148                             &quot;, response length: &quot; + respBytes.length);
1149                 }
1150                 CertStatusResponse certResp = (shc.stapleParams.statReqType ==
1151                         CertStatusRequestType.OCSP) ?
1152                         new OCSPStatusResponse(shc.stapleParams.statReqType.id,
1153                                 respBytes) :
1154                         new CertStatusResponse(shc.stapleParams.statReqType.id,
1155                                 respBytes);
1156                 producedData = certResp.toByteArray();
1157             } catch (CertificateException ce) {
1158                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1159                         &quot;Failed to parse server certificates&quot;, ce);
1160             } catch (IOException ioe) {
1161                 throw shc.conContext.fatal(Alert.BAD_CERT_STATUS_RESPONSE,
1162                         &quot;Failed to parse certificate status response&quot;, ioe);
1163             }
1164 
1165             // Clear the pinned CertificateEntry from the context
1166             shc.currentCertEntry = null;
1167             return producedData;
1168         }
1169     }
1170 
1171     private static final
1172         class CTCertStatusResponseConsumer implements ExtensionConsumer {
1173         // Prevent instantiation of this class.
1174         private CTCertStatusResponseConsumer() {
1175             // blank
1176         }
1177 
1178         @Override
1179         public void consume(ConnectionContext context,
1180                 HandshakeMessage message, ByteBuffer buffer) throws IOException {
1181             // The consumption happens in client side only.
1182             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1183 
1184             // Parse the extension.
1185             CertStatusResponseSpec spec;
1186             try {
1187                 spec = new CertStatusResponseSpec(buffer);
1188             } catch (IOException ioe) {
1189                 throw chc.conContext.fatal(Alert.DECODE_ERROR, ioe);
1190             }
1191 
1192             if (chc.sslContext.isStaplingEnabled(true)) {
1193                 // Activate stapling
1194                 chc.staplingActive = true;
1195             } else {
1196                 // Do no further processing of stapled responses
1197                 return;
1198             }
1199 
1200             // Get response list from the session.  This is unmodifiable
1201             // so we need to create a new list.  Then add this new response
1202             // to the end and submit it back to the session object.
1203             if ((chc.handshakeSession != null) &amp;&amp; (!chc.isResumption)) {
1204                 List&lt;byte[]&gt; respList = new ArrayList&lt;&gt;(
1205                         chc.handshakeSession.getStatusResponses());
1206                 respList.add(spec.statusResponse.encodedResponse);
1207                 chc.handshakeSession.setStatusResponses(respList);
1208             } else {
1209                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1210                     SSLLogger.finest(
1211                             &quot;Ignoring stapled data on resumed session&quot;);
1212                 }
1213             }
1214         }
1215     }
1216 }
    </pre>
  </body>
</html>
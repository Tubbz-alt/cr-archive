<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/DHKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DHClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHServerKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/DHKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.security.GeneralSecurityException;
 31 import java.security.InvalidKeyException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.PrivateKey;
 37 import java.security.PublicKey;
 38 import java.security.SecureRandom;
<span class="line-removed"> 39 import java.security.spec.AlgorithmParameterSpec;</span>
 40 import java.security.spec.InvalidKeySpecException;
<span class="line-removed"> 41 import javax.crypto.KeyAgreement;</span>
<span class="line-removed"> 42 import javax.crypto.SecretKey;</span>
 43 import javax.crypto.interfaces.DHPublicKey;
 44 import javax.crypto.spec.DHParameterSpec;
 45 import javax.crypto.spec.DHPublicKeySpec;
<span class="line-removed"> 46 import javax.crypto.spec.SecretKeySpec;</span>
<span class="line-removed"> 47 import javax.net.ssl.SSLHandshakeException;</span>
 48 import sun.security.action.GetPropertyAction;
<span class="line-modified"> 49 import sun.security.ssl.CipherSuite.HashAlg;</span>
<span class="line-removed"> 50 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
<span class="line-removed"> 51 import sun.security.ssl.SupportedGroupsExtension.NamedGroupType;</span>
 52 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 53 import sun.security.ssl.X509Authentication.X509Possession;
 54 import sun.security.util.KeyUtil;
 55 
 56 final class DHKeyExchange {
 57     static final SSLPossessionGenerator poGenerator =
 58             new DHEPossessionGenerator(false);
 59     static final SSLPossessionGenerator poExportableGenerator =
 60             new DHEPossessionGenerator(true);
 61     static final SSLKeyAgreementGenerator kaGenerator =
 62             new DHEKAGenerator();
 63 
<span class="line-modified"> 64     static final class DHECredentials implements SSLCredentials {</span>
 65         final DHPublicKey popPublicKey;
 66         final NamedGroup namedGroup;
 67 
 68         DHECredentials(DHPublicKey popPublicKey, NamedGroup namedGroup) {
 69             this.popPublicKey = popPublicKey;
 70             this.namedGroup = namedGroup;
 71         }
 72 










 73         static DHECredentials valueOf(NamedGroup ng,
 74             byte[] encodedPublic) throws IOException, GeneralSecurityException {
 75 
<span class="line-modified"> 76             if (ng.type != NamedGroupType.NAMED_GROUP_FFDHE) {</span>
 77                 throw new RuntimeException(
 78                         &quot;Credentials decoding:  Not FFDHE named group&quot;);
 79             }
 80 
 81             if (encodedPublic == null || encodedPublic.length == 0) {
 82                 return null;
 83             }
 84 
<span class="line-modified"> 85             DHParameterSpec params = (DHParameterSpec)ng.getParameterSpec();</span>
<span class="line-removed"> 86             if (params == null) {</span>
<span class="line-removed"> 87                 return null;</span>
<span class="line-removed"> 88             }</span>
<span class="line-removed"> 89 </span>
 90             KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
 91             DHPublicKeySpec spec = new DHPublicKeySpec(
 92                     new BigInteger(1, encodedPublic),
 93                     params.getP(), params.getG());
 94             DHPublicKey publicKey =
 95                     (DHPublicKey)kf.generatePublic(spec);
 96 
 97             return new DHECredentials(publicKey, ng);
 98         }
 99     }
100 
<span class="line-modified">101     static final class DHEPossession implements SSLPossession {</span>
102         final PrivateKey privateKey;
103         final DHPublicKey publicKey;
104         final NamedGroup namedGroup;
105 
106         DHEPossession(NamedGroup namedGroup, SecureRandom random) {
107             try {
108                 KeyPairGenerator kpg =
109                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
<span class="line-modified">110                 DHParameterSpec params =</span>
<span class="line-removed">111                         (DHParameterSpec)namedGroup.getParameterSpec();</span>
<span class="line-removed">112                 kpg.initialize(params, random);</span>
113                 KeyPair kp = generateDHKeyPair(kpg);
114                 if (kp == null) {
115                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
116                 }
117                 privateKey = kp.getPrivate();
118                 publicKey = (DHPublicKey)kp.getPublic();
119             } catch (GeneralSecurityException gse) {
120                 throw new RuntimeException(
121                         &quot;Could not generate DH keypair&quot;, gse);
122             }
123 
124             this.namedGroup = namedGroup;
125         }
126 
127         DHEPossession(int keyLength, SecureRandom random) {
128             DHParameterSpec params =
129                     PredefinedDHParameterSpecs.definedParams.get(keyLength);
130             try {
131                 KeyPairGenerator kpg =
132                     KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
</pre>
<hr />
<pre>
157                 KeyPairGenerator kpg =
158                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
159                 kpg.initialize(credentials.popPublicKey.getParams(), random);
160                 KeyPair kp = generateDHKeyPair(kpg);
161                 if (kp == null) {
162                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
163                 }
164                 privateKey = kp.getPrivate();
165                 publicKey = (DHPublicKey)kp.getPublic();
166             } catch (GeneralSecurityException gse) {
167                 throw new RuntimeException(
168                         &quot;Could not generate DH keypair&quot;, gse);
169             }
170 
171             this.namedGroup = credentials.namedGroup;
172         }
173 
174         // Generate and validate DHPublicKeySpec
175         private KeyPair generateDHKeyPair(
176                 KeyPairGenerator kpg) throws GeneralSecurityException {
<span class="line-modified">177             boolean doExtraValiadtion =</span>
178                     (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
179             boolean isRecovering = false;
180             for (int i = 0; i &lt;= 2; i++) {      // Try to recover from failure.
181                 KeyPair kp = kpg.generateKeyPair();
182                 // validate the Diffie-Hellman public key
<span class="line-modified">183                 if (doExtraValiadtion) {</span>
184                     DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
185                     try {
186                         KeyUtil.validate(spec);
187                     } catch (InvalidKeyException ivke) {
188                         if (isRecovering) {
189                             throw ivke;
190                         }
191                         // otherwise, ignore the exception and try again
192                         isRecovering = true;
193                         continue;
194                     }
195                 }
196 
197                 return kp;
198             }
199 
200             return null;
201         }
202 
203         private static DHPublicKeySpec getDHPublicKeySpec(PublicKey key) {
</pre>
<hr />
<pre>
214                 // unlikely
215                 throw new RuntimeException(&quot;Unable to get DHPublicKeySpec&quot;, e);
216             }
217         }
218 
219         @Override
220         public byte[] encode() {
221             // Note: the DH public value is encoded as a big-endian integer
222             // and padded to the left with zeros to the size of p in bytes.
223             byte[] encoded = Utilities.toByteArray(publicKey.getY());
224             int pSize = (KeyUtil.getKeySize(publicKey) + 7) &gt;&gt;&gt; 3;
225             if (pSize &gt; 0 &amp;&amp; encoded.length &lt; pSize) {
226                 byte[] buffer = new byte[pSize];
227                 System.arraycopy(encoded, 0,
228                         buffer, pSize - encoded.length, encoded.length);
229                 encoded = buffer;
230             }
231 
232             return encoded;
233         }















234     }
235 
236     private static final class
237             DHEPossessionGenerator implements SSLPossessionGenerator {
238         // Flag to use smart ephemeral DH key which size matches the
239         // corresponding authentication key
240         private static final boolean useSmartEphemeralDHKeys;
241 
242         // Flag to use legacy ephemeral DH key which size is 512 bits for
243         // exportable cipher suites, and 768 bits for others
244         private static final boolean useLegacyEphemeralDHKeys;
245 
246         // The customized ephemeral DH key size for non-exportable
247         // cipher suites.
248         private static final int customizedDHKeySize;
249 
250         // Is it for exportable cipher suite?
251         private final boolean exportable;
252 
253         static {
</pre>
<hr />
<pre>
281                             &quot;Unsupported customized DH key size: &quot; +
282                             customizedDHKeySize + &quot;. &quot; +
283                             &quot;The key size must be multiple of 64, &quot; +
284                             &quot;and range from 1024 to 8192 (inclusive)&quot;);
285                     }
286                 } catch (NumberFormatException nfe) {
287                     throw new IllegalArgumentException(
288                         &quot;Invalid system property jdk.tls.ephemeralDHKeySize&quot;);
289                 }
290             }
291         }
292 
293         // Prevent instantiation of this class.
294         private DHEPossessionGenerator(boolean exportable) {
295             this.exportable = exportable;
296         }
297 
298         // Used for ServerKeyExchange, TLS 1.2 and prior versions.
299         @Override
300         public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">301             NamedGroup preferableNamedGroup = null;</span>
302             if (!useLegacyEphemeralDHKeys &amp;&amp;
303                     (context.clientRequestedNamedGroups != null) &amp;&amp;
304                     (!context.clientRequestedNamedGroups.isEmpty())) {
305                 preferableNamedGroup =
<span class="line-modified">306                         SupportedGroups.getPreferredGroup(</span>
<span class="line-removed">307                                 context.negotiatedProtocol,</span>
308                                 context.algorithmConstraints,
<span class="line-modified">309                                 NamedGroupType.NAMED_GROUP_FFDHE,</span>

310                                 context.clientRequestedNamedGroups);
311                 if (preferableNamedGroup != null) {
312                     return new DHEPossession(preferableNamedGroup,
313                                 context.sslContext.getSecureRandom());
314                 }
315             }
316 
317             /*
318              * 768 bits ephemeral DH private keys were used to be used in
319              * ServerKeyExchange except that exportable ciphers max out at 512
320              * bits modulus values. We still adhere to this behavior in legacy
321              * mode (system property &quot;jdk.tls.ephemeralDHKeySize&quot; is defined
322              * as &quot;legacy&quot;).
323              *
324              * Old JDK (JDK 7 and previous) releases don&#39;t support DH keys
325              * bigger than 1024 bits. We have to consider the compatibility
326              * requirement. 1024 bits DH key is always used for non-exportable
327              * cipher suites in default mode (system property
328              * &quot;jdk.tls.ephemeralDHKeySize&quot; is not defined).
329              *
</pre>
<hr />
<pre>
375                         // Old deployed applications may not be ready to
376                         // support DH key sizes bigger than 2048 bits.  Please
377                         // DON&#39;T use value other than 1024 and 2048 at present.
378                         // May improve the underlying providers and key size
379                         // limit in the future when the compatibility and
380                         // interoperability impact is limited.
381                         keySize = ks &lt;= 1024 ? 1024 : 2048;
382                     } // Otherwise, anonymous cipher suites, 1024-bit is used.
383                 } else if (customizedDHKeySize &gt; 0) {    // customized mode
384                     keySize = customizedDHKeySize;
385                 }
386             }
387 
388             return new DHEPossession(
389                     keySize, context.sslContext.getSecureRandom());
390         }
391     }
392 
393     private static final
394             class DHEKAGenerator implements SSLKeyAgreementGenerator {
<span class="line-modified">395         static private DHEKAGenerator instance = new DHEKAGenerator();</span>
396 
397         // Prevent instantiation of this class.
398         private DHEKAGenerator() {
399             // blank
400         }
401 
402         @Override
403         public SSLKeyDerivation createKeyDerivation(
404                 HandshakeContext context) throws IOException {
405             DHEPossession dhePossession = null;
406             DHECredentials dheCredentials = null;
407             for (SSLPossession poss : context.handshakePossessions) {
408                 if (!(poss instanceof DHEPossession)) {
409                     continue;
410                 }
411 
412                 DHEPossession dhep = (DHEPossession)poss;
413                 for (SSLCredentials cred : context.handshakeCredentials) {
414                     if (!(cred instanceof DHECredentials)) {
415                         continue;
</pre>
<hr />
<pre>
425                         DHParameterSpec cps = dhec.popPublicKey.getParams();
426                         if (pps.getP().equals(cps.getP()) &amp;&amp;
427                                 pps.getG().equals(cps.getG())) {
428                             dheCredentials = (DHECredentials)cred;
429                             break;
430                         }
431                     }
432                 }
433 
434                 if (dheCredentials != null) {
435                     dhePossession = (DHEPossession)poss;
436                     break;
437                 }
438             }
439 
440             if (dhePossession == null || dheCredentials == null) {
441                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
442                     &quot;No sufficient DHE key agreement parameters negotiated&quot;);
443             }
444 
<span class="line-modified">445             return new DHEKAKeyDerivation(context,</span>
446                     dhePossession.privateKey, dheCredentials.popPublicKey);
447         }
<span class="line-removed">448 </span>
<span class="line-removed">449         private static final</span>
<span class="line-removed">450                 class DHEKAKeyDerivation implements SSLKeyDerivation {</span>
<span class="line-removed">451             private final HandshakeContext context;</span>
<span class="line-removed">452             private final PrivateKey localPrivateKey;</span>
<span class="line-removed">453             private final PublicKey peerPublicKey;</span>
<span class="line-removed">454 </span>
<span class="line-removed">455             DHEKAKeyDerivation(HandshakeContext context,</span>
<span class="line-removed">456                     PrivateKey localPrivateKey,</span>
<span class="line-removed">457                     PublicKey peerPublicKey) {</span>
<span class="line-removed">458                 this.context = context;</span>
<span class="line-removed">459                 this.localPrivateKey = localPrivateKey;</span>
<span class="line-removed">460                 this.peerPublicKey = peerPublicKey;</span>
<span class="line-removed">461             }</span>
<span class="line-removed">462 </span>
<span class="line-removed">463             @Override</span>
<span class="line-removed">464             public SecretKey deriveKey(String algorithm,</span>
<span class="line-removed">465                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">466                 if (!context.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="line-removed">467                     return t12DeriveKey(algorithm, params);</span>
<span class="line-removed">468                 } else {</span>
<span class="line-removed">469                     return t13DeriveKey(algorithm, params);</span>
<span class="line-removed">470                 }</span>
<span class="line-removed">471             }</span>
<span class="line-removed">472 </span>
<span class="line-removed">473             private SecretKey t12DeriveKey(String algorithm,</span>
<span class="line-removed">474                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">475                 try {</span>
<span class="line-removed">476                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">477                     ka.init(localPrivateKey);</span>
<span class="line-removed">478                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">479                     SecretKey preMasterSecret =</span>
<span class="line-removed">480                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">481                     SSLMasterKeyDerivation mskd =</span>
<span class="line-removed">482                             SSLMasterKeyDerivation.valueOf(</span>
<span class="line-removed">483                                     context.negotiatedProtocol);</span>
<span class="line-removed">484                     if (mskd == null) {</span>
<span class="line-removed">485                         // unlikely</span>
<span class="line-removed">486                         throw new SSLHandshakeException(</span>
<span class="line-removed">487                             &quot;No expected master key derivation for protocol: &quot; +</span>
<span class="line-removed">488                             context.negotiatedProtocol.name);</span>
<span class="line-removed">489                     }</span>
<span class="line-removed">490                     SSLKeyDerivation kd = mskd.createKeyDerivation(</span>
<span class="line-removed">491                             context, preMasterSecret);</span>
<span class="line-removed">492                     return kd.deriveKey(&quot;MasterSecret&quot;, params);</span>
<span class="line-removed">493                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">494                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">495                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">496                 }</span>
<span class="line-removed">497             }</span>
<span class="line-removed">498 </span>
<span class="line-removed">499             private SecretKey t13DeriveKey(String algorithm,</span>
<span class="line-removed">500                     AlgorithmParameterSpec params) throws IOException {</span>
<span class="line-removed">501                 try {</span>
<span class="line-removed">502                     KeyAgreement ka = KeyAgreement.getInstance(&quot;DiffieHellman&quot;);</span>
<span class="line-removed">503                     ka.init(localPrivateKey);</span>
<span class="line-removed">504                     ka.doPhase(peerPublicKey, true);</span>
<span class="line-removed">505                     SecretKey sharedSecret =</span>
<span class="line-removed">506                             ka.generateSecret(&quot;TlsPremasterSecret&quot;);</span>
<span class="line-removed">507 </span>
<span class="line-removed">508                     HashAlg hashAlg = context.negotiatedCipherSuite.hashAlg;</span>
<span class="line-removed">509                     SSLKeyDerivation kd = context.handshakeKeyDerivation;</span>
<span class="line-removed">510                     HKDF hkdf = new HKDF(hashAlg.name);</span>
<span class="line-removed">511                     if (kd == null) {   // No PSK is in use.</span>
<span class="line-removed">512                         // If PSK is not in use Early Secret will still be</span>
<span class="line-removed">513                         // HKDF-Extract(0, 0).</span>
<span class="line-removed">514                         byte[] zeros = new byte[hashAlg.hashLength];</span>
<span class="line-removed">515                         SecretKeySpec ikm =</span>
<span class="line-removed">516                                 new SecretKeySpec(zeros, &quot;TlsPreSharedSecret&quot;);</span>
<span class="line-removed">517                         SecretKey earlySecret =</span>
<span class="line-removed">518                                 hkdf.extract(zeros, ikm, &quot;TlsEarlySecret&quot;);</span>
<span class="line-removed">519                         kd = new SSLSecretDerivation(context, earlySecret);</span>
<span class="line-removed">520                     }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522                     // derive salt secret</span>
<span class="line-removed">523                     SecretKey saltSecret = kd.deriveKey(&quot;TlsSaltSecret&quot;, null);</span>
<span class="line-removed">524 </span>
<span class="line-removed">525                     // derive handshake secret</span>
<span class="line-removed">526                     return hkdf.extract(saltSecret, sharedSecret, algorithm);</span>
<span class="line-removed">527                 } catch (GeneralSecurityException gse) {</span>
<span class="line-removed">528                     throw (SSLHandshakeException) new SSLHandshakeException(</span>
<span class="line-removed">529                         &quot;Could not generate secret&quot;).initCause(gse);</span>
<span class="line-removed">530                 }</span>
<span class="line-removed">531             }</span>
<span class="line-removed">532         }</span>
533     }
534 }
</pre>
</td>
<td>
<hr />
<pre>
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.math.BigInteger;
 30 import java.security.GeneralSecurityException;
 31 import java.security.InvalidKeyException;
 32 import java.security.KeyFactory;
 33 import java.security.KeyPair;
 34 import java.security.KeyPairGenerator;
 35 import java.security.NoSuchAlgorithmException;
 36 import java.security.PrivateKey;
 37 import java.security.PublicKey;
 38 import java.security.SecureRandom;

 39 import java.security.spec.InvalidKeySpecException;


 40 import javax.crypto.interfaces.DHPublicKey;
 41 import javax.crypto.spec.DHParameterSpec;
 42 import javax.crypto.spec.DHPublicKeySpec;


 43 import sun.security.action.GetPropertyAction;
<span class="line-modified"> 44 import sun.security.ssl.NamedGroup.NamedGroupSpec;</span>


 45 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 46 import sun.security.ssl.X509Authentication.X509Possession;
 47 import sun.security.util.KeyUtil;
 48 
 49 final class DHKeyExchange {
 50     static final SSLPossessionGenerator poGenerator =
 51             new DHEPossessionGenerator(false);
 52     static final SSLPossessionGenerator poExportableGenerator =
 53             new DHEPossessionGenerator(true);
 54     static final SSLKeyAgreementGenerator kaGenerator =
 55             new DHEKAGenerator();
 56 
<span class="line-modified"> 57     static final class DHECredentials implements NamedGroupCredentials {</span>
 58         final DHPublicKey popPublicKey;
 59         final NamedGroup namedGroup;
 60 
 61         DHECredentials(DHPublicKey popPublicKey, NamedGroup namedGroup) {
 62             this.popPublicKey = popPublicKey;
 63             this.namedGroup = namedGroup;
 64         }
 65 
<span class="line-added"> 66         @Override</span>
<span class="line-added"> 67         public PublicKey getPublicKey() {</span>
<span class="line-added"> 68             return popPublicKey;</span>
<span class="line-added"> 69         }</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71         @Override</span>
<span class="line-added"> 72         public NamedGroup getNamedGroup() {</span>
<span class="line-added"> 73             return namedGroup;</span>
<span class="line-added"> 74         }</span>
<span class="line-added"> 75 </span>
 76         static DHECredentials valueOf(NamedGroup ng,
 77             byte[] encodedPublic) throws IOException, GeneralSecurityException {
 78 
<span class="line-modified"> 79             if (ng.spec != NamedGroupSpec.NAMED_GROUP_FFDHE) {</span>
 80                 throw new RuntimeException(
 81                         &quot;Credentials decoding:  Not FFDHE named group&quot;);
 82             }
 83 
 84             if (encodedPublic == null || encodedPublic.length == 0) {
 85                 return null;
 86             }
 87 
<span class="line-modified"> 88             DHParameterSpec params = (DHParameterSpec)ng.keAlgParamSpec;</span>




 89             KeyFactory kf = KeyFactory.getInstance(&quot;DiffieHellman&quot;);
 90             DHPublicKeySpec spec = new DHPublicKeySpec(
 91                     new BigInteger(1, encodedPublic),
 92                     params.getP(), params.getG());
 93             DHPublicKey publicKey =
 94                     (DHPublicKey)kf.generatePublic(spec);
 95 
 96             return new DHECredentials(publicKey, ng);
 97         }
 98     }
 99 
<span class="line-modified">100     static final class DHEPossession implements NamedGroupPossession {</span>
101         final PrivateKey privateKey;
102         final DHPublicKey publicKey;
103         final NamedGroup namedGroup;
104 
105         DHEPossession(NamedGroup namedGroup, SecureRandom random) {
106             try {
107                 KeyPairGenerator kpg =
108                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
<span class="line-modified">109                 kpg.initialize(namedGroup.keAlgParamSpec, random);</span>


110                 KeyPair kp = generateDHKeyPair(kpg);
111                 if (kp == null) {
112                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
113                 }
114                 privateKey = kp.getPrivate();
115                 publicKey = (DHPublicKey)kp.getPublic();
116             } catch (GeneralSecurityException gse) {
117                 throw new RuntimeException(
118                         &quot;Could not generate DH keypair&quot;, gse);
119             }
120 
121             this.namedGroup = namedGroup;
122         }
123 
124         DHEPossession(int keyLength, SecureRandom random) {
125             DHParameterSpec params =
126                     PredefinedDHParameterSpecs.definedParams.get(keyLength);
127             try {
128                 KeyPairGenerator kpg =
129                     KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
</pre>
<hr />
<pre>
154                 KeyPairGenerator kpg =
155                         KeyPairGenerator.getInstance(&quot;DiffieHellman&quot;);
156                 kpg.initialize(credentials.popPublicKey.getParams(), random);
157                 KeyPair kp = generateDHKeyPair(kpg);
158                 if (kp == null) {
159                     throw new RuntimeException(&quot;Could not generate DH keypair&quot;);
160                 }
161                 privateKey = kp.getPrivate();
162                 publicKey = (DHPublicKey)kp.getPublic();
163             } catch (GeneralSecurityException gse) {
164                 throw new RuntimeException(
165                         &quot;Could not generate DH keypair&quot;, gse);
166             }
167 
168             this.namedGroup = credentials.namedGroup;
169         }
170 
171         // Generate and validate DHPublicKeySpec
172         private KeyPair generateDHKeyPair(
173                 KeyPairGenerator kpg) throws GeneralSecurityException {
<span class="line-modified">174             boolean doExtraValidation =</span>
175                     (!KeyUtil.isOracleJCEProvider(kpg.getProvider().getName()));
176             boolean isRecovering = false;
177             for (int i = 0; i &lt;= 2; i++) {      // Try to recover from failure.
178                 KeyPair kp = kpg.generateKeyPair();
179                 // validate the Diffie-Hellman public key
<span class="line-modified">180                 if (doExtraValidation) {</span>
181                     DHPublicKeySpec spec = getDHPublicKeySpec(kp.getPublic());
182                     try {
183                         KeyUtil.validate(spec);
184                     } catch (InvalidKeyException ivke) {
185                         if (isRecovering) {
186                             throw ivke;
187                         }
188                         // otherwise, ignore the exception and try again
189                         isRecovering = true;
190                         continue;
191                     }
192                 }
193 
194                 return kp;
195             }
196 
197             return null;
198         }
199 
200         private static DHPublicKeySpec getDHPublicKeySpec(PublicKey key) {
</pre>
<hr />
<pre>
211                 // unlikely
212                 throw new RuntimeException(&quot;Unable to get DHPublicKeySpec&quot;, e);
213             }
214         }
215 
216         @Override
217         public byte[] encode() {
218             // Note: the DH public value is encoded as a big-endian integer
219             // and padded to the left with zeros to the size of p in bytes.
220             byte[] encoded = Utilities.toByteArray(publicKey.getY());
221             int pSize = (KeyUtil.getKeySize(publicKey) + 7) &gt;&gt;&gt; 3;
222             if (pSize &gt; 0 &amp;&amp; encoded.length &lt; pSize) {
223                 byte[] buffer = new byte[pSize];
224                 System.arraycopy(encoded, 0,
225                         buffer, pSize - encoded.length, encoded.length);
226                 encoded = buffer;
227             }
228 
229             return encoded;
230         }
<span class="line-added">231 </span>
<span class="line-added">232         @Override</span>
<span class="line-added">233         public PublicKey getPublicKey() {</span>
<span class="line-added">234             return publicKey;</span>
<span class="line-added">235         }</span>
<span class="line-added">236 </span>
<span class="line-added">237         @Override</span>
<span class="line-added">238         public NamedGroup getNamedGroup() {</span>
<span class="line-added">239             return namedGroup;</span>
<span class="line-added">240         }</span>
<span class="line-added">241 </span>
<span class="line-added">242         @Override</span>
<span class="line-added">243         public PrivateKey getPrivateKey() {</span>
<span class="line-added">244             return privateKey;</span>
<span class="line-added">245         }</span>
246     }
247 
248     private static final class
249             DHEPossessionGenerator implements SSLPossessionGenerator {
250         // Flag to use smart ephemeral DH key which size matches the
251         // corresponding authentication key
252         private static final boolean useSmartEphemeralDHKeys;
253 
254         // Flag to use legacy ephemeral DH key which size is 512 bits for
255         // exportable cipher suites, and 768 bits for others
256         private static final boolean useLegacyEphemeralDHKeys;
257 
258         // The customized ephemeral DH key size for non-exportable
259         // cipher suites.
260         private static final int customizedDHKeySize;
261 
262         // Is it for exportable cipher suite?
263         private final boolean exportable;
264 
265         static {
</pre>
<hr />
<pre>
293                             &quot;Unsupported customized DH key size: &quot; +
294                             customizedDHKeySize + &quot;. &quot; +
295                             &quot;The key size must be multiple of 64, &quot; +
296                             &quot;and range from 1024 to 8192 (inclusive)&quot;);
297                     }
298                 } catch (NumberFormatException nfe) {
299                     throw new IllegalArgumentException(
300                         &quot;Invalid system property jdk.tls.ephemeralDHKeySize&quot;);
301                 }
302             }
303         }
304 
305         // Prevent instantiation of this class.
306         private DHEPossessionGenerator(boolean exportable) {
307             this.exportable = exportable;
308         }
309 
310         // Used for ServerKeyExchange, TLS 1.2 and prior versions.
311         @Override
312         public SSLPossession createPossession(HandshakeContext context) {
<span class="line-modified">313             NamedGroup preferableNamedGroup;</span>
314             if (!useLegacyEphemeralDHKeys &amp;&amp;
315                     (context.clientRequestedNamedGroups != null) &amp;&amp;
316                     (!context.clientRequestedNamedGroups.isEmpty())) {
317                 preferableNamedGroup =
<span class="line-modified">318                         SupportedGroups.getPreferredGroup(context.negotiatedProtocol,</span>

319                                 context.algorithmConstraints,
<span class="line-modified">320                                 new NamedGroupSpec [] {</span>
<span class="line-added">321                                     NamedGroupSpec.NAMED_GROUP_FFDHE },</span>
322                                 context.clientRequestedNamedGroups);
323                 if (preferableNamedGroup != null) {
324                     return new DHEPossession(preferableNamedGroup,
325                                 context.sslContext.getSecureRandom());
326                 }
327             }
328 
329             /*
330              * 768 bits ephemeral DH private keys were used to be used in
331              * ServerKeyExchange except that exportable ciphers max out at 512
332              * bits modulus values. We still adhere to this behavior in legacy
333              * mode (system property &quot;jdk.tls.ephemeralDHKeySize&quot; is defined
334              * as &quot;legacy&quot;).
335              *
336              * Old JDK (JDK 7 and previous) releases don&#39;t support DH keys
337              * bigger than 1024 bits. We have to consider the compatibility
338              * requirement. 1024 bits DH key is always used for non-exportable
339              * cipher suites in default mode (system property
340              * &quot;jdk.tls.ephemeralDHKeySize&quot; is not defined).
341              *
</pre>
<hr />
<pre>
387                         // Old deployed applications may not be ready to
388                         // support DH key sizes bigger than 2048 bits.  Please
389                         // DON&#39;T use value other than 1024 and 2048 at present.
390                         // May improve the underlying providers and key size
391                         // limit in the future when the compatibility and
392                         // interoperability impact is limited.
393                         keySize = ks &lt;= 1024 ? 1024 : 2048;
394                     } // Otherwise, anonymous cipher suites, 1024-bit is used.
395                 } else if (customizedDHKeySize &gt; 0) {    // customized mode
396                     keySize = customizedDHKeySize;
397                 }
398             }
399 
400             return new DHEPossession(
401                     keySize, context.sslContext.getSecureRandom());
402         }
403     }
404 
405     private static final
406             class DHEKAGenerator implements SSLKeyAgreementGenerator {
<span class="line-modified">407         private static final DHEKAGenerator instance = new DHEKAGenerator();</span>
408 
409         // Prevent instantiation of this class.
410         private DHEKAGenerator() {
411             // blank
412         }
413 
414         @Override
415         public SSLKeyDerivation createKeyDerivation(
416                 HandshakeContext context) throws IOException {
417             DHEPossession dhePossession = null;
418             DHECredentials dheCredentials = null;
419             for (SSLPossession poss : context.handshakePossessions) {
420                 if (!(poss instanceof DHEPossession)) {
421                     continue;
422                 }
423 
424                 DHEPossession dhep = (DHEPossession)poss;
425                 for (SSLCredentials cred : context.handshakeCredentials) {
426                     if (!(cred instanceof DHECredentials)) {
427                         continue;
</pre>
<hr />
<pre>
437                         DHParameterSpec cps = dhec.popPublicKey.getParams();
438                         if (pps.getP().equals(cps.getP()) &amp;&amp;
439                                 pps.getG().equals(cps.getG())) {
440                             dheCredentials = (DHECredentials)cred;
441                             break;
442                         }
443                     }
444                 }
445 
446                 if (dheCredentials != null) {
447                     dhePossession = (DHEPossession)poss;
448                     break;
449                 }
450             }
451 
452             if (dhePossession == null || dheCredentials == null) {
453                 throw context.conContext.fatal(Alert.HANDSHAKE_FAILURE,
454                     &quot;No sufficient DHE key agreement parameters negotiated&quot;);
455             }
456 
<span class="line-modified">457             return new KAKeyDerivation(&quot;DiffieHellman&quot;, context,</span>
458                     dhePossession.privateKey, dheCredentials.popPublicKey);
459         }





















































































460     }
461 }
</pre>
</td>
</tr>
</table>
<center><a href="DHClientKeyExchange.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DHServerKeyExchange.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/util/locale/provider/SPILocaleProviderAdapter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.util.locale.provider;
 27 
 28 import java.security.AccessController;
 29 import java.security.PrivilegedActionException;
 30 import java.security.PrivilegedExceptionAction;
 31 import java.text.BreakIterator;
 32 import java.text.Collator;
 33 import java.text.DateFormat;
 34 import java.text.DateFormatSymbols;
 35 import java.text.DecimalFormatSymbols;
 36 import java.text.NumberFormat;
 37 import java.text.spi.BreakIteratorProvider;
 38 import java.text.spi.CollatorProvider;
 39 import java.text.spi.DateFormatProvider;
 40 import java.text.spi.DateFormatSymbolsProvider;
 41 import java.text.spi.DecimalFormatSymbolsProvider;
 42 import java.text.spi.NumberFormatProvider;
 43 import java.util.Arrays;
 44 import java.util.Locale;
 45 import java.util.Map;
 46 import java.util.ServiceLoader;
 47 import java.util.concurrent.ConcurrentHashMap;
 48 import java.util.concurrent.ConcurrentMap;
 49 import java.util.spi.CalendarDataProvider;
 50 import java.util.spi.CalendarNameProvider;
 51 import java.util.spi.CurrencyNameProvider;
 52 import java.util.spi.LocaleNameProvider;
 53 import java.util.spi.LocaleServiceProvider;
 54 import java.util.spi.TimeZoneNameProvider;
 55 
 56 /**
 57  * LocaleProviderAdapter implementation for the installed SPI implementations.
 58  *
 59  * @author Naoto Sato
 60  * @author Masayoshi Okutsu
 61  */
 62 public class SPILocaleProviderAdapter extends AuxLocaleProviderAdapter {
 63 
 64     /**
 65      * Returns the type of this LocaleProviderAdapter
 66      */
 67     @Override
 68     public LocaleProviderAdapter.Type getAdapterType() {
 69         return LocaleProviderAdapter.Type.SPI;
 70     }
 71 
 72     @Override
 73     protected &lt;P extends LocaleServiceProvider&gt; P findInstalledProvider(final Class&lt;P&gt; c) {
 74         try {
 75             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;P&gt;() {
 76                 @Override
 77                 @SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})
 78                 public P run() {
 79                     P delegate = null;
 80 
 81                     for (LocaleServiceProvider provider :
 82                              ServiceLoader.load(c, ClassLoader.getSystemClassLoader())) {
 83                         if (delegate == null) {
 84                             try {
 85                                 delegate =
 86                                     (P) Class.forName(SPILocaleProviderAdapter.class.getCanonicalName() +
 87                                               &quot;$&quot; +
 88                                               c.getSimpleName() +
 89                                               &quot;Delegate&quot;)
 90                                               .newInstance();
 91                             }  catch (ClassNotFoundException |
 92                                       InstantiationException |
 93                                       IllegalAccessException e) {
 94                                 LocaleServiceProviderPool.config(SPILocaleProviderAdapter.class, e.toString());
 95                                 return null;
 96                             }
 97                         }
 98 
 99                         ((Delegate)delegate).addImpl(provider);
100                     }
101                     return delegate;
102                 }
103             });
104         }  catch (PrivilegedActionException e) {
105             LocaleServiceProviderPool.config(SPILocaleProviderAdapter.class, e.toString());
106         }
107         return null;
108     }
109 
110     /*
111      * Delegate interface. All the implementations have to have the class name
112      * following &quot;&lt;provider class name&gt;Delegate&quot; convention.
113      */
114     private interface Delegate&lt;P extends LocaleServiceProvider&gt; {
115         default public void addImpl(P impl) {
116             for (Locale l : impl.getAvailableLocales()) {
117                 getDelegateMap().putIfAbsent(l, impl);
118             }
119         }
120 
121         /*
122          * Obtain the real SPI implementation, using locale fallback
123          */
124         default public P getImpl(Locale locale) {
125             for (Locale l : LocaleServiceProviderPool.getLookupLocales(locale.stripExtensions())) {
126                 P ret = getDelegateMap().get(l);
127                 if (ret != null) {
128                     return ret;
129                 }
130             }
131             return null;
132         }
133 
134         public Map&lt;Locale, P&gt; getDelegateMap();
135 
136         default public Locale[] getAvailableLocalesDelegate() {
137             return getDelegateMap().keySet().stream().toArray(Locale[]::new);
138         }
139 
140         default public boolean isSupportedLocaleDelegate(Locale locale) {
141             Map&lt;Locale, P&gt; map = getDelegateMap();
142             Locale override = CalendarDataUtility.findRegionOverride(locale);
143 
144             // First, call the method with extensions (if any)
145             P impl = map.get(override);
146             if (impl != null) {
147                 return impl.isSupportedLocale(override);
148             } else {
149                 // The default behavior
150                 Locale overrideNoExt = override.stripExtensions();
151                 impl = map.get(overrideNoExt);
152                 if (impl != null) {
153                     return Arrays.stream(impl.getAvailableLocales())
154                                 .anyMatch(overrideNoExt::equals);
155                 }
156             }
157 
158             return false;
159         }
160     }
161 
162     /*
163      * Delegates for the actual SPI implementations.
164      */
165     static class BreakIteratorProviderDelegate extends BreakIteratorProvider
166                                         implements Delegate&lt;BreakIteratorProvider&gt; {
167         private final Map&lt;Locale, BreakIteratorProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
168 
169         @Override
170         public Map&lt;Locale, BreakIteratorProvider&gt; getDelegateMap() {
171             return map;
172         }
173 
174         @Override
175         public Locale[] getAvailableLocales() {
176             return getAvailableLocalesDelegate();
177         }
178 
179         @Override
180         public boolean isSupportedLocale(Locale locale) {
181             return isSupportedLocaleDelegate(locale);
182         }
183 
184         @Override
185         public BreakIterator getWordInstance(Locale locale) {
186             locale = CalendarDataUtility.findRegionOverride(locale);
187             BreakIteratorProvider bip = getImpl(locale);
188             return bip.getWordInstance(locale);
189         }
190 
191         @Override
192         public BreakIterator getLineInstance(Locale locale) {
193             locale = CalendarDataUtility.findRegionOverride(locale);
194             BreakIteratorProvider bip = getImpl(locale);
195             return bip.getLineInstance(locale);
196         }
197 
198         @Override
199         public BreakIterator getCharacterInstance(Locale locale) {
200             locale = CalendarDataUtility.findRegionOverride(locale);
201             BreakIteratorProvider bip = getImpl(locale);
202             return bip.getCharacterInstance(locale);
203         }
204 
205         @Override
206         public BreakIterator getSentenceInstance(Locale locale) {
207             locale = CalendarDataUtility.findRegionOverride(locale);
208             BreakIteratorProvider bip = getImpl(locale);
209             return bip.getSentenceInstance(locale);
210         }
211 
212     }
213 
214     static class CollatorProviderDelegate extends CollatorProvider implements Delegate&lt;CollatorProvider&gt; {
215         private final Map&lt;Locale, CollatorProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
216 
217         @Override
218         public Map&lt;Locale, CollatorProvider&gt; getDelegateMap() {
219             return map;
220         }
221 
222         @Override
223         public Locale[] getAvailableLocales() {
224             return getAvailableLocalesDelegate();
225         }
226 
227         @Override
228         public boolean isSupportedLocale(Locale locale) {
229             return isSupportedLocaleDelegate(locale);
230         }
231 
232         @Override
233         public Collator getInstance(Locale locale) {
234             locale = CalendarDataUtility.findRegionOverride(locale);
235             CollatorProvider cp = getImpl(locale);
236             return cp.getInstance(locale);
237         }
238     }
239 
240     static class DateFormatProviderDelegate extends DateFormatProvider
241                                      implements Delegate&lt;DateFormatProvider&gt; {
242         private final Map&lt;Locale, DateFormatProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
243 
244         @Override
245         public Map&lt;Locale, DateFormatProvider&gt; getDelegateMap() {
246             return map;
247         }
248 
249         @Override
250         public Locale[] getAvailableLocales() {
251             return getAvailableLocalesDelegate();
252         }
253 
254         @Override
255         public boolean isSupportedLocale(Locale locale) {
256             return isSupportedLocaleDelegate(locale);
257         }
258 
259         @Override
260         public DateFormat getTimeInstance(int style, Locale locale) {
261             locale = CalendarDataUtility.findRegionOverride(locale);
262             DateFormatProvider dfp = getImpl(locale);
263             return dfp.getTimeInstance(style, locale);
264         }
265 
266         @Override
267         public DateFormat getDateInstance(int style, Locale locale) {
268             locale = CalendarDataUtility.findRegionOverride(locale);
269             DateFormatProvider dfp = getImpl(locale);
270             return dfp.getDateInstance(style, locale);
271         }
272 
273         @Override
274         public DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
275             locale = CalendarDataUtility.findRegionOverride(locale);
276             DateFormatProvider dfp = getImpl(locale);
277             return dfp.getDateTimeInstance(dateStyle, timeStyle, locale);
278         }
279     }
280 
281     static class DateFormatSymbolsProviderDelegate extends DateFormatSymbolsProvider
282                                             implements Delegate&lt;DateFormatSymbolsProvider&gt; {
283         private final Map&lt;Locale, DateFormatSymbolsProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
284 
285         @Override
286         public Map&lt;Locale, DateFormatSymbolsProvider&gt; getDelegateMap() {
287             return map;
288         }
289 
290         @Override
291         public Locale[] getAvailableLocales() {
292             return getAvailableLocalesDelegate();
293         }
294 
295         @Override
296         public boolean isSupportedLocale(Locale locale) {
297             return isSupportedLocaleDelegate(locale);
298         }
299 
300         @Override
301         public DateFormatSymbols getInstance(Locale locale) {
302             locale = CalendarDataUtility.findRegionOverride(locale);
303             DateFormatSymbolsProvider dfsp = getImpl(locale);
304             return dfsp.getInstance(locale);
305         }
306     }
307 
308     static class DecimalFormatSymbolsProviderDelegate extends DecimalFormatSymbolsProvider
309                                                implements Delegate&lt;DecimalFormatSymbolsProvider&gt; {
310         private final Map&lt;Locale, DecimalFormatSymbolsProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
311 
312         @Override
313         public Map&lt;Locale, DecimalFormatSymbolsProvider&gt; getDelegateMap() {
314             return map;
315         }
316 
317         @Override
318         public Locale[] getAvailableLocales() {
319             return getAvailableLocalesDelegate();
320         }
321 
322         @Override
323         public boolean isSupportedLocale(Locale locale) {
324             return isSupportedLocaleDelegate(locale);
325         }
326 
327         @Override
328         public DecimalFormatSymbols getInstance(Locale locale) {
329             locale = CalendarDataUtility.findRegionOverride(locale);
330             DecimalFormatSymbolsProvider dfsp = getImpl(locale);
331             return dfsp.getInstance(locale);
332         }
333     }
334 
335     static class NumberFormatProviderDelegate extends NumberFormatProvider
336                                        implements Delegate&lt;NumberFormatProvider&gt; {
337         private final Map&lt;Locale, NumberFormatProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
338 
339         @Override
340         public Map&lt;Locale, NumberFormatProvider&gt; getDelegateMap() {
341             return map;
342         }
343 
344         @Override
345         public Locale[] getAvailableLocales() {
346             return getAvailableLocalesDelegate();
347         }
348 
349         @Override
350         public boolean isSupportedLocale(Locale locale) {
351             return isSupportedLocaleDelegate(locale);
352         }
353 
354         @Override
355         public NumberFormat getCurrencyInstance(Locale locale) {
356             locale = CalendarDataUtility.findRegionOverride(locale);
357             NumberFormatProvider nfp = getImpl(locale);
358             return nfp.getCurrencyInstance(locale);
359         }
360 
361         @Override
362         public NumberFormat getIntegerInstance(Locale locale) {
363             locale = CalendarDataUtility.findRegionOverride(locale);
364             NumberFormatProvider nfp = getImpl(locale);
365             return nfp.getIntegerInstance(locale);
366         }
367 
368         @Override
369         public NumberFormat getNumberInstance(Locale locale) {
370             locale = CalendarDataUtility.findRegionOverride(locale);
371             NumberFormatProvider nfp = getImpl(locale);
372             return nfp.getNumberInstance(locale);
373         }
374 
375         @Override
376         public NumberFormat getPercentInstance(Locale locale) {
377             locale = CalendarDataUtility.findRegionOverride(locale);
378             NumberFormatProvider nfp = getImpl(locale);
379             return nfp.getPercentInstance(locale);
380         }
381     }
382 
383     static class CalendarDataProviderDelegate extends CalendarDataProvider
384                                        implements Delegate&lt;CalendarDataProvider&gt; {
385         private final Map&lt;Locale, CalendarDataProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
386 
387         @Override
388         public Map&lt;Locale, CalendarDataProvider&gt; getDelegateMap() {
389             return map;
390         }
391 
392         @Override
393         public Locale[] getAvailableLocales() {
394             return getAvailableLocalesDelegate();
395         }
396 
397         @Override
398         public boolean isSupportedLocale(Locale locale) {
399             return isSupportedLocaleDelegate(locale);
400         }
401 
402         @Override
403         public int getFirstDayOfWeek(Locale locale) {
404             locale = CalendarDataUtility.findRegionOverride(locale);
405             CalendarDataProvider cdp = getImpl(locale);
406             return cdp.getFirstDayOfWeek(locale);
407         }
408 
409         @Override
410         public int getMinimalDaysInFirstWeek(Locale locale) {
411             locale = CalendarDataUtility.findRegionOverride(locale);
412             CalendarDataProvider cdp = getImpl(locale);
413             return cdp.getMinimalDaysInFirstWeek(locale);
414         }
415     }
416 
417     static class CalendarNameProviderDelegate extends CalendarNameProvider
418                                        implements Delegate&lt;CalendarNameProvider&gt; {
419         private final Map&lt;Locale, CalendarNameProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
420 
421         @Override
422         public Map&lt;Locale, CalendarNameProvider&gt; getDelegateMap() {
423             return map;
424         }
425 
426         @Override
427         public Locale[] getAvailableLocales() {
428             return getAvailableLocalesDelegate();
429         }
430 
431         @Override
432         public boolean isSupportedLocale(Locale locale) {
433             return isSupportedLocaleDelegate(locale);
434         }
435 
436         @Override
437         public String getDisplayName(String calendarType,
438                                               int field, int value,
439                                               int style, Locale locale) {
440             locale = CalendarDataUtility.findRegionOverride(locale);
441             CalendarNameProvider cdp = getImpl(locale);
442             return cdp.getDisplayName(calendarType, field, value, style, locale);
443         }
444 
445         @Override
446         public Map&lt;String, Integer&gt; getDisplayNames(String calendarType,
447                                                              int field, int style,
448                                                              Locale locale) {
449             locale = CalendarDataUtility.findRegionOverride(locale);
450             CalendarNameProvider cdp = getImpl(locale);
451             return cdp.getDisplayNames(calendarType, field, style, locale);
452         }
453     }
454 
455     static class CurrencyNameProviderDelegate extends CurrencyNameProvider
456                                        implements Delegate&lt;CurrencyNameProvider&gt; {
457         private final Map&lt;Locale, CurrencyNameProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
458 
459         @Override
460         public Map&lt;Locale, CurrencyNameProvider&gt; getDelegateMap() {
461             return map;
462         }
463 
464         @Override
465         public Locale[] getAvailableLocales() {
466             return getAvailableLocalesDelegate();
467         }
468 
469         @Override
470         public boolean isSupportedLocale(Locale locale) {
471             return isSupportedLocaleDelegate(locale);
472         }
473 
474         @Override
475         public String getSymbol(String currencyCode, Locale locale) {
476             locale = CalendarDataUtility.findRegionOverride(locale);
477             CurrencyNameProvider cnp = getImpl(locale);
478             return cnp.getSymbol(currencyCode, locale);
479         }
480 
481         @Override
482         public String getDisplayName(String currencyCode, Locale locale) {
483             locale = CalendarDataUtility.findRegionOverride(locale);
484             CurrencyNameProvider cnp = getImpl(locale);
485             return cnp.getDisplayName(currencyCode, locale);
486         }
487     }
488 
489     static class LocaleNameProviderDelegate extends LocaleNameProvider
490                                      implements Delegate&lt;LocaleNameProvider&gt; {
491         private final Map&lt;Locale, LocaleNameProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
492 
493         @Override
494         public Map&lt;Locale, LocaleNameProvider&gt; getDelegateMap() {
495             return map;
496         }
497 
498         @Override
499         public Locale[] getAvailableLocales() {
500             return getAvailableLocalesDelegate();
501         }
502 
503         @Override
504         public boolean isSupportedLocale(Locale locale) {
505             return isSupportedLocaleDelegate(locale);
506         }
507 
508         @Override
509         public String getDisplayLanguage(String languageCode, Locale locale) {
510             locale = CalendarDataUtility.findRegionOverride(locale);
511             LocaleNameProvider lnp = getImpl(locale);
512             return lnp.getDisplayLanguage(languageCode, locale);
513         }
514 
515         @Override
516         public String getDisplayScript(String scriptCode, Locale locale) {
517             locale = CalendarDataUtility.findRegionOverride(locale);
518             LocaleNameProvider lnp = getImpl(locale);
519             return lnp.getDisplayScript(scriptCode, locale);
520         }
521 
522         @Override
523         public String getDisplayCountry(String countryCode, Locale locale) {
524             locale = CalendarDataUtility.findRegionOverride(locale);
525             LocaleNameProvider lnp = getImpl(locale);
526             return lnp.getDisplayCountry(countryCode, locale);
527         }
528 
529         @Override
530         public String getDisplayVariant(String variant, Locale locale) {
531             locale = CalendarDataUtility.findRegionOverride(locale);
532             LocaleNameProvider lnp = getImpl(locale);
533             return lnp.getDisplayVariant(variant, locale);
534         }
535 
536         @Override
537         public String getDisplayUnicodeExtensionKey(String key, Locale locale) {
538             locale = CalendarDataUtility.findRegionOverride(locale);
539             LocaleNameProvider lnp = getImpl(locale);
540             return lnp.getDisplayUnicodeExtensionKey(key, locale);
541         }
542 
543         @Override
544         public String getDisplayUnicodeExtensionType(String extType, String key, Locale locale) {
545             locale = CalendarDataUtility.findRegionOverride(locale);
546             LocaleNameProvider lnp = getImpl(locale);
547             return lnp.getDisplayUnicodeExtensionType(extType, key, locale);
548         }
549     }
550 
551     static class TimeZoneNameProviderDelegate extends TimeZoneNameProvider
552                                      implements Delegate&lt;TimeZoneNameProvider&gt; {
553         private final Map&lt;Locale, TimeZoneNameProvider&gt; map = new ConcurrentHashMap&lt;&gt;();
554 
555         @Override
556         public Map&lt;Locale, TimeZoneNameProvider&gt; getDelegateMap() {
557             return map;
558         }
559 
560         @Override
561         public Locale[] getAvailableLocales() {
562             return getAvailableLocalesDelegate();
563         }
564 
565         @Override
566         public boolean isSupportedLocale(Locale locale) {
567             return isSupportedLocaleDelegate(locale);
568         }
569 
570         @Override
571         public String getDisplayName(String ID, boolean daylight, int style, Locale locale) {
572             locale = CalendarDataUtility.findRegionOverride(locale);
573             TimeZoneNameProvider tznp = getImpl(locale);
574             return tznp.getDisplayName(ID, daylight, style, locale);
575         }
576 
577         @Override
578         public String getGenericDisplayName(String ID, int style, Locale locale) {
579             locale = CalendarDataUtility.findRegionOverride(locale);
580             TimeZoneNameProvider tznp = getImpl(locale);
581             return tznp.getGenericDisplayName(ID, style, locale);
582         }
583     }
584 }
    </pre>
  </body>
</html>
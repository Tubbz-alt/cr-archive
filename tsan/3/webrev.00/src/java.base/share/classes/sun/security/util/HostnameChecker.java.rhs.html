<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/util/HostnameChecker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.IOException;
 29 import java.net.IDN;
 30 import java.net.InetAddress;
 31 import java.net.UnknownHostException;
 32 import java.security.Principal;
 33 import java.security.cert.*;
 34 import java.util.*;
 35 import javax.security.auth.x500.X500Principal;
 36 import javax.net.ssl.SNIHostName;
 37 
 38 import sun.net.util.IPAddressUtil;
 39 import sun.security.x509.X500Name;
 40 import sun.security.ssl.SSLLogger;
 41 
 42 /**
 43  * Class to check hostnames against the names specified in a certificate as
 44  * required for TLS and LDAP.
 45  *
 46  */
 47 public class HostnameChecker {
 48 
 49     // Constant for a HostnameChecker for TLS
 50     public static final byte TYPE_TLS = 1;
 51     private static final HostnameChecker INSTANCE_TLS =
 52                                         new HostnameChecker(TYPE_TLS);
 53 
 54     // Constant for a HostnameChecker for LDAP
 55     public static final byte TYPE_LDAP = 2;
 56     private static final HostnameChecker INSTANCE_LDAP =
 57                                         new HostnameChecker(TYPE_LDAP);
 58 
 59     // constants for subject alt names of type DNS and IP
 60     private static final int ALTNAME_DNS = 2;
 61     private static final int ALTNAME_IP  = 7;
 62 
 63     // the algorithm to follow to perform the check. Currently unused.
 64     private final byte checkType;
 65 
 66     private HostnameChecker(byte checkType) {
 67         this.checkType = checkType;
 68     }
 69 
 70     /**
 71      * Get a HostnameChecker instance. checkType should be one of the
 72      * TYPE_* constants defined in this class.
 73      */
 74     public static HostnameChecker getInstance(byte checkType) {
 75         if (checkType == TYPE_TLS) {
 76             return INSTANCE_TLS;
 77         } else if (checkType == TYPE_LDAP) {
 78             return INSTANCE_LDAP;
 79         }
 80         throw new IllegalArgumentException(&quot;Unknown check type: &quot; + checkType);
 81     }
 82 
 83     /**
 84      * Perform the check.
 85      *
 86      * @param expectedName the expected host name or ip address
 87      * @param cert the certificate to check against
 88      * @param chainsToPublicCA true if the certificate chains to a public
 89      *     root CA (as pre-installed in the cacerts file)
 90      * @throws CertificateException if the name does not match any of
 91      *     the names specified in the certificate
 92      */
 93     public void match(String expectedName, X509Certificate cert,
 94                       boolean chainsToPublicCA) throws CertificateException {
 95         if (expectedName == null) {
 96             throw new CertificateException(&quot;Hostname or IP address is &quot; +
 97                     &quot;undefined.&quot;);
 98         }
 99         if (isIpAddress(expectedName)) {
100            matchIP(expectedName, cert);
101         } else {
102            matchDNS(expectedName, cert, chainsToPublicCA);
103         }
104     }
105 
106     public void match(String expectedName, X509Certificate cert)
107             throws CertificateException {
108         match(expectedName, cert, false);
109     }
110 
111     /**
112      * Test whether the given hostname looks like a literal IPv4 or IPv6
113      * address. The hostname does not need to be a fully qualified name.
114      *
115      * This is not a strict check that performs full input validation.
116      * That means if the method returns true, name need not be a correct
117      * IP address, rather that it does not represent a valid DNS hostname.
118      * Likewise for IP addresses when it returns false.
119      */
120     private static boolean isIpAddress(String name) {
121         if (IPAddressUtil.isIPv4LiteralAddress(name) ||
122             IPAddressUtil.isIPv6LiteralAddress(name)) {
123             return true;
124         } else {
125             return false;
126         }
127     }
128 
129     /**
130      * Check if the certificate allows use of the given IP address.
131      *
132      * From RFC2818:
133      * In some cases, the URI is specified as an IP address rather than a
134      * hostname. In this case, the iPAddress subjectAltName must be present
135      * in the certificate and must exactly match the IP in the URI.
136      */
137     private static void matchIP(String expectedIP, X509Certificate cert)
138             throws CertificateException {
139         Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();
140         if (subjAltNames == null) {
141             throw new CertificateException
142                                 (&quot;No subject alternative names present&quot;);
143         }
144         for (List&lt;?&gt; next : subjAltNames) {
145             // For IP address, it needs to be exact match
146             if (((Integer)next.get(0)).intValue() == ALTNAME_IP) {
147                 String ipAddress = (String)next.get(1);
148                 if (expectedIP.equalsIgnoreCase(ipAddress)) {
149                     return;
150                 } else {
151                     // compare InetAddress objects in order to ensure
152                     // equality between a long IPv6 address and its
153                     // abbreviated form.
154                     try {
155                         if (InetAddress.getByName(expectedIP).equals(
156                                 InetAddress.getByName(ipAddress))) {
157                             return;
158                         }
159                     } catch (UnknownHostException e) {
160                     } catch (SecurityException e) {}
161                 }
162             }
163         }
164         throw new CertificateException(&quot;No subject alternative &quot; +
165                         &quot;names matching &quot; + &quot;IP address &quot; +
166                         expectedIP + &quot; found&quot;);
167     }
168 
169     /**
170      * Check if the certificate allows use of the given DNS name.
171      *
172      * From RFC2818:
173      * If a subjectAltName extension of type dNSName is present, that MUST
174      * be used as the identity. Otherwise, the (most specific) Common Name
175      * field in the Subject field of the certificate MUST be used. Although
176      * the use of the Common Name is existing practice, it is deprecated and
177      * Certification Authorities are encouraged to use the dNSName instead.
178      *
179      * Matching is performed using the matching rules specified by
180      * [RFC5280].  If more than one identity of a given type is present in
181      * the certificate (e.g., more than one dNSName name, a match in any one
182      * of the set is considered acceptable.)
183      */
184     private void matchDNS(String expectedName, X509Certificate cert,
185                           boolean chainsToPublicCA)
186             throws CertificateException {
187         // Check that the expected name is a valid domain name.
188         try {
189             // Using the checking implemented in SNIHostName
190             SNIHostName sni = new SNIHostName(expectedName);
191         } catch (IllegalArgumentException iae) {
192             throw new CertificateException(
193                 &quot;Illegal given domain name: &quot; + expectedName, iae);
194         }
195 
196         Collection&lt;List&lt;?&gt;&gt; subjAltNames = cert.getSubjectAlternativeNames();
197         if (subjAltNames != null) {
198             boolean foundDNS = false;
199             for (List&lt;?&gt; next : subjAltNames) {
200                 if (((Integer)next.get(0)).intValue() == ALTNAME_DNS) {
201                     foundDNS = true;
202                     String dnsName = (String)next.get(1);
203                     if (isMatched(expectedName, dnsName, chainsToPublicCA)) {
204                         return;
205                     }
206                 }
207             }
208             if (foundDNS) {
209                 // if certificate contains any subject alt names of type DNS
210                 // but none match, reject
211                 throw new CertificateException(&quot;No subject alternative DNS &quot;
212                         + &quot;name matching &quot; + expectedName + &quot; found.&quot;);
213             }
214         }
215         X500Name subjectName = getSubjectX500Name(cert);
216         DerValue derValue = subjectName.findMostSpecificAttribute
217                                                     (X500Name.commonName_oid);
218         if (derValue != null) {
219             try {
220                 if (isMatched(expectedName, derValue.getAsString(),
221                               chainsToPublicCA)) {
222                     return;
223                 }
224             } catch (IOException e) {
225                 // ignore
226             }
227         }
228         String msg = &quot;No name matching &quot; + expectedName + &quot; found&quot;;
229         throw new CertificateException(msg);
230     }
231 
232 
233     /**
234      * Return the subject of a certificate as X500Name, by reparsing if
235      * necessary. X500Name should only be used if access to name components
236      * is required, in other cases X500Principal is to be preferred.
237      *
238      * This method is currently used from within JSSE, do not remove.
239      */
240     public static X500Name getSubjectX500Name(X509Certificate cert)
241             throws CertificateParsingException {
242         try {
243             Principal subjectDN = cert.getSubjectDN();
244             if (subjectDN instanceof X500Name) {
245                 return (X500Name)subjectDN;
246             } else {
247                 X500Principal subjectX500 = cert.getSubjectX500Principal();
248                 return new X500Name(subjectX500.getEncoded());
249             }
250         } catch (IOException e) {
251             throw(CertificateParsingException)
252                 new CertificateParsingException().initCause(e);
253         }
254     }
255 
256 
257     /**
258      * Returns true if name matches against template.&lt;p&gt;
259      *
260      * The matching is performed as per RFC 2818 rules for TLS and
261      * RFC 2830 rules for LDAP.&lt;p&gt;
262      *
<a name="2" id="anc2"></a><span class="line-modified">263      * The &lt;code&gt;name&lt;/code&gt; parameter should represent a DNS name.  The</span>
<span class="line-modified">264      * &lt;code&gt;template&lt;/code&gt; parameter may contain the wildcard character &#39;*&#39;.</span>

265      */
266     private boolean isMatched(String name, String template,
267                               boolean chainsToPublicCA) {
268 
269         // Normalize to Unicode, because PSL is in Unicode.
<a name="3" id="anc3"></a><span class="line-modified">270         try {</span>
<span class="line-modified">271             name = IDN.toUnicode(IDN.toASCII(name));</span>
<span class="line-added">272             template = IDN.toUnicode(IDN.toASCII(template));</span>
<span class="line-added">273         } catch (RuntimeException re) {</span>
<span class="line-added">274             if (SSLLogger.isOn) {</span>
<span class="line-added">275                 SSLLogger.fine(&quot;Failed to normalize to Unicode: &quot; + re);</span>
<span class="line-added">276             }</span>
277 
<a name="4" id="anc4"></a><span class="line-modified">278             return false;</span>
<span class="line-added">279         }</span>
<span class="line-added">280 </span>
<span class="line-added">281         if (hasIllegalWildcard(template, chainsToPublicCA)) {</span>
282             return false;
283         }
284 
285         // check the validity of the domain name template.
286         try {
<a name="5" id="anc5"></a><span class="line-modified">287             // Replacing wildcard character &#39;*&#39; with &#39;z&#39; so as to check</span>
288             // the domain name template validity.
289             //
290             // Using the checking implemented in SNIHostName
<a name="6" id="anc6"></a><span class="line-modified">291             new SNIHostName(template.replace(&#39;*&#39;, &#39;z&#39;));</span>
292         } catch (IllegalArgumentException iae) {
293             // It would be nice to add debug log if not matching.
294             return false;
295         }
296 
297         if (checkType == TYPE_TLS) {
298             return matchAllWildcards(name, template);
299         } else if (checkType == TYPE_LDAP) {
300             return matchLeftmostWildcard(name, template);
301         } else {
302             return false;
303         }
304     }
305 
306     /**
307      * Returns true if the template contains an illegal wildcard character.
308      */
<a name="7" id="anc7"></a><span class="line-modified">309     private static boolean hasIllegalWildcard(</span>
<span class="line-modified">310             String template, boolean chainsToPublicCA) {</span>
311         // not ok if it is a single wildcard character or &quot;*.&quot;
312         if (template.equals(&quot;*&quot;) || template.equals(&quot;*.&quot;)) {
313             if (SSLLogger.isOn) {
314                 SSLLogger.fine(
315                     &quot;Certificate domain name has illegal single &quot; +
316                       &quot;wildcard character: &quot; + template);
317             }
318             return true;
319         }
320 
321         int lastWildcardIndex = template.lastIndexOf(&quot;*&quot;);
322 
323         // ok if it has no wildcard character
324         if (lastWildcardIndex == -1) {
325             return false;
326         }
327 
328         String afterWildcard = template.substring(lastWildcardIndex);
329         int firstDotIndex = afterWildcard.indexOf(&quot;.&quot;);
330 
331         // not ok if there is no dot after wildcard (ex: &quot;*com&quot;)
332         if (firstDotIndex == -1) {
333             if (SSLLogger.isOn) {
334                 SSLLogger.fine(
335                     &quot;Certificate domain name has illegal wildcard, &quot; +
336                     &quot;no dot after wildcard character: &quot; + template);
337             }
338             return true;
339         }
340 
<a name="8" id="anc8"></a>


341         if (!chainsToPublicCA) {
342             return false; // skip check for non-public certificates
343         }
<a name="9" id="anc9"></a><span class="line-modified">344 </span>
<span class="line-modified">345         // If the wildcarded domain is a top-level domain under which names</span>
<span class="line-modified">346         // can be registered, then a wildcard is not allowed.</span>
<span class="line-modified">347         String wildcardedDomain = afterWildcard.substring(firstDotIndex + 1);</span>
<span class="line-modified">348         String templateDomainSuffix =</span>
<span class="line-modified">349                 RegisteredDomain.from(&quot;z.&quot; + wildcardedDomain)</span>
<span class="line-modified">350                     .filter(d -&gt; d.type() == RegisteredDomain.Type.ICANN)</span>
<span class="line-modified">351                     .map(RegisteredDomain::publicSuffix).orElse(null);</span>
<span class="line-modified">352         if (templateDomainSuffix == null) {</span>
<span class="line-modified">353             return false;   // skip check if not known public suffix</span>
<span class="line-modified">354         }</span>
<span class="line-modified">355 </span>
<span class="line-added">356         // Is it a top-level domain?</span>
<span class="line-added">357         if (wildcardedDomain.equalsIgnoreCase(templateDomainSuffix)) {</span>
<span class="line-added">358             if (SSLLogger.isOn) {</span>
<span class="line-added">359                 SSLLogger.fine(</span>
<span class="line-added">360                     &quot;Certificate domain name has illegal &quot; +</span>
<span class="line-added">361                     &quot;wildcard for top-level public suffix: &quot; + template);</span>
362             }
<a name="10" id="anc10"></a><span class="line-added">363             return true;</span>
364         }
365 
366         return false;
367     }
368 
369     /**
370      * Returns true if name matches against template.&lt;p&gt;
371      *
372      * According to RFC 2818, section 3.1 -
373      * Names may contain the wildcard character * which is
374      * considered to match any single domain name component
375      * or component fragment.
376      * E.g., *.a.com matches foo.a.com but not
377      * bar.foo.a.com. f*.com matches foo.com but not bar.com.
378      */
379     private static boolean matchAllWildcards(String name,
380          String template) {
381         name = name.toLowerCase(Locale.ENGLISH);
382         template = template.toLowerCase(Locale.ENGLISH);
383         StringTokenizer nameSt = new StringTokenizer(name, &quot;.&quot;);
384         StringTokenizer templateSt = new StringTokenizer(template, &quot;.&quot;);
385 
386         if (nameSt.countTokens() != templateSt.countTokens()) {
387             return false;
388         }
389 
390         while (nameSt.hasMoreTokens()) {
391             if (!matchWildCards(nameSt.nextToken(),
392                         templateSt.nextToken())) {
393                 return false;
394             }
395         }
396         return true;
397     }
398 
399 
400     /**
401      * Returns true if name matches against template.&lt;p&gt;
402      *
403      * As per RFC 2830, section 3.6 -
404      * The &quot;*&quot; wildcard character is allowed.  If present, it applies only
405      * to the left-most name component.
406      * E.g. *.bar.com would match a.bar.com, b.bar.com, etc. but not
407      * bar.com.
408      */
409     private static boolean matchLeftmostWildcard(String name,
410                          String template) {
411         name = name.toLowerCase(Locale.ENGLISH);
412         template = template.toLowerCase(Locale.ENGLISH);
413 
414         // Retrieve leftmost component
415         int templateIdx = template.indexOf(&quot;.&quot;);
416         int nameIdx = name.indexOf(&quot;.&quot;);
417 
418         if (templateIdx == -1)
419             templateIdx = template.length();
420         if (nameIdx == -1)
421             nameIdx = name.length();
422 
423         if (matchWildCards(name.substring(0, nameIdx),
424             template.substring(0, templateIdx))) {
425 
426             // match rest of the name
427             return template.substring(templateIdx).equals(
428                         name.substring(nameIdx));
429         } else {
430             return false;
431         }
432     }
433 
434 
435     /**
436      * Returns true if the name matches against the template that may
437      * contain wildcard char * &lt;p&gt;
438      */
439     private static boolean matchWildCards(String name, String template) {
440 
441         int wildcardIdx = template.indexOf(&quot;*&quot;);
442         if (wildcardIdx == -1)
443             return name.equals(template);
444 
445         boolean isBeginning = true;
446         String beforeWildcard = &quot;&quot;;
447         String afterWildcard = template;
448 
449         while (wildcardIdx != -1) {
450 
451             // match in sequence the non-wildcard chars in the template.
452             beforeWildcard = afterWildcard.substring(0, wildcardIdx);
453             afterWildcard = afterWildcard.substring(wildcardIdx + 1);
454 
455             int beforeStartIdx = name.indexOf(beforeWildcard);
456             if ((beforeStartIdx == -1) ||
457                         (isBeginning &amp;&amp; beforeStartIdx != 0)) {
458                 return false;
459             }
460             isBeginning = false;
461 
462             // update the match scope
463             name = name.substring(beforeStartIdx + beforeWildcard.length());
464             wildcardIdx = afterWildcard.indexOf(&quot;*&quot;);
465         }
466         return name.endsWith(afterWildcard);
467     }
468 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
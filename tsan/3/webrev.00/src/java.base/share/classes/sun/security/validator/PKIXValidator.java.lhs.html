<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/validator/PKIXValidator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.validator;
 27 
 28 import java.util.*;
 29 
 30 import java.security.*;
 31 import java.security.cert.*;
 32 
 33 import javax.security.auth.x500.X500Principal;
 34 import sun.security.action.GetBooleanAction;
<a name="2" id="anc2"></a>
 35 import sun.security.provider.certpath.AlgorithmChecker;
 36 import sun.security.provider.certpath.PKIXExtendedParameters;
 37 
 38 /**
 39  * Validator implementation built on the PKIX CertPath API. This
 40  * implementation will be emphasized going forward.
 41  * &lt;p&gt;
 42  * Note that the validate() implementation tries to use a PKIX validator
 43  * if that appears possible and a PKIX builder otherwise. This increases
 44  * performance and currently also leads to better exception messages
 45  * in case of failures.
 46  * &lt;p&gt;
 47  * {@code PKIXValidator} objects are immutable once they have been created.
 48  * Please DO NOT add methods that can change the state of an instance once
 49  * it has been created.
 50  *
 51  * @author Andreas Sterbenz
 52  */
 53 public final class PKIXValidator extends Validator {
 54 
 55     /**
 56      * Flag indicating whether to enable revocation check for the PKIX trust
 57      * manager. Typically, this will only work if the PKIX implementation
 58      * supports CRL distribution points as we do not manually setup CertStores.
 59      */
 60     private static final boolean checkTLSRevocation = GetBooleanAction
 61             .privilegedGetProperty(&quot;com.sun.net.ssl.checkRevocation&quot;);
 62 
<a name="3" id="anc3"></a>











 63     private final Set&lt;X509Certificate&gt; trustedCerts;
 64     private final PKIXBuilderParameters parameterTemplate;
 65     private int certPathLength = -1;
 66 
 67     // needed only for the validator
 68     private final Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; trustedSubjects;
 69     private final CertificateFactory factory;
 70 
 71     private final boolean plugin;
 72 
 73     PKIXValidator(String variant, Collection&lt;X509Certificate&gt; trustedCerts) {
 74         super(TYPE_PKIX, variant);
 75         this.trustedCerts = (trustedCerts instanceof Set) ?
 76                             (Set&lt;X509Certificate&gt;)trustedCerts :
 77                             new HashSet&lt;X509Certificate&gt;(trustedCerts);
 78 
 79         Set&lt;TrustAnchor&gt; trustAnchors = new HashSet&lt;&gt;();
 80         for (X509Certificate cert : trustedCerts) {
 81             trustAnchors.add(new TrustAnchor(cert, null));
 82         }
 83 
 84         try {
 85             parameterTemplate = new PKIXBuilderParameters(trustAnchors, null);
 86             factory = CertificateFactory.getInstance(&quot;X.509&quot;);
 87         } catch (InvalidAlgorithmParameterException e) {
 88             throw new RuntimeException(&quot;Unexpected error: &quot; + e.toString(), e);
 89         } catch (CertificateException e) {
 90             throw new RuntimeException(&quot;Internal error&quot;, e);
 91         }
 92 
 93         setDefaultParameters(variant);
 94         plugin = variant.equals(VAR_PLUGIN_CODE_SIGNING);
 95 
 96         trustedSubjects = setTrustedSubjects();
 97     }
 98 
 99     PKIXValidator(String variant, PKIXBuilderParameters params) {
100         super(TYPE_PKIX, variant);
101         trustedCerts = new HashSet&lt;X509Certificate&gt;();
102         for (TrustAnchor anchor : params.getTrustAnchors()) {
103             X509Certificate cert = anchor.getTrustedCert();
104             if (cert != null) {
105                 trustedCerts.add(cert);
106             }
107         }
108         parameterTemplate = params;
109 
110         try {
111             factory = CertificateFactory.getInstance(&quot;X.509&quot;);
112         } catch (CertificateException e) {
113             throw new RuntimeException(&quot;Internal error&quot;, e);
114         }
115 
116         plugin = variant.equals(VAR_PLUGIN_CODE_SIGNING);
117 
118         trustedSubjects = setTrustedSubjects();
119     }
120 
121     /**
122      * Populate the trustedSubjects Map using the DN and public keys from
123      * the list of trusted certificates
124      *
125      * @return Map containing each subject DN and one or more public keys
126      *    tied to those DNs.
127      */
128     private Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; setTrustedSubjects() {
129         Map&lt;X500Principal, List&lt;PublicKey&gt;&gt; subjectMap = new HashMap&lt;&gt;();
130 
131         for (X509Certificate cert : trustedCerts) {
132             X500Principal dn = cert.getSubjectX500Principal();
133             List&lt;PublicKey&gt; keys;
134             if (subjectMap.containsKey(dn)) {
135                 keys = subjectMap.get(dn);
136             } else {
137                 keys = new ArrayList&lt;PublicKey&gt;();
138                 subjectMap.put(dn, keys);
139             }
140             keys.add(cert.getPublicKey());
141         }
142 
143         return subjectMap;
144     }
145 
<a name="4" id="anc4"></a>
146     public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
147         return trustedCerts;
148     }
149 
150     /**
151      * Returns the length of the last certification path that is validated by
152      * CertPathValidator. This is intended primarily as a callback mechanism
153      * for PKIXCertPathCheckers to determine the length of the certification
154      * path that is being validated. It is necessary since engineValidate()
155      * may modify the length of the path.
156      *
157      * @return the length of the last certification path passed to
158      *   CertPathValidator.validate, or -1 if it has not been invoked yet
159      */
160     public int getCertPathLength() { // mutable, should be private
161         return certPathLength;
162     }
163 
164     /**
165      * Set J2SE global default PKIX parameters. Currently, hardcoded to disable
166      * revocation checking. In the future, this should be configurable.
167      */
168     private void setDefaultParameters(String variant) {
169         if ((variant == Validator.VAR_TLS_SERVER) ||
170                 (variant == Validator.VAR_TLS_CLIENT)) {
171             parameterTemplate.setRevocationEnabled(checkTLSRevocation);
172         } else {
173             parameterTemplate.setRevocationEnabled(false);
174         }
175     }
176 
177     /**
178      * Return the PKIX parameters used by this instance. An application may
179      * modify the parameters but must make sure not to perform any concurrent
180      * validations.
181      */
182     public PKIXBuilderParameters getParameters() { // mutable, should be private
183         return parameterTemplate;
184     }
185 
186     @Override
187     X509Certificate[] engineValidate(X509Certificate[] chain,
188             Collection&lt;X509Certificate&gt; otherCerts,
189             List&lt;byte[]&gt; responseList,
190             AlgorithmConstraints constraints,
191             Object parameter) throws CertificateException {
192         if ((chain == null) || (chain.length == 0)) {
193             throw new CertificateException
194                 (&quot;null or zero-length certificate chain&quot;);
195         }
196 
<a name="5" id="anc5"></a>
197         // Use PKIXExtendedParameters for timestamp and variant additions
198         PKIXBuilderParameters pkixParameters = null;
199         try {
200             pkixParameters = new PKIXExtendedParameters(
201                     (PKIXBuilderParameters) parameterTemplate.clone(),
202                     (parameter instanceof Timestamp) ?
203                             (Timestamp) parameter : null,
204                     variant);
205         } catch (InvalidAlgorithmParameterException e) {
206             // ignore exception
207         }
208 
209         // add new algorithm constraints checker
210         if (constraints != null) {
211             pkixParameters.addCertPathChecker(
212                     new AlgorithmChecker(constraints, null, variant));
213         }
214 
215         // attach it to the PKIXBuilderParameters.
216         if (!responseList.isEmpty()) {
217             addResponses(pkixParameters, chain, responseList);
218         }
219 
220         // check that chain is in correct order and check if chain contains
221         // trust anchor
222         X500Principal prevIssuer = null;
223         for (int i = 0; i &lt; chain.length; i++) {
224             X509Certificate cert = chain[i];
225             X500Principal dn = cert.getSubjectX500Principal();
<a name="6" id="anc6"></a><span class="line-removed">226             if (i != 0 &amp;&amp; !dn.equals(prevIssuer)) {</span>
<span class="line-removed">227                 // chain is not ordered correctly, call builder instead</span>
<span class="line-removed">228                 return doBuild(chain, otherCerts, pkixParameters);</span>
<span class="line-removed">229             }</span>
230 
<a name="7" id="anc7"></a><span class="line-modified">231             // Check if chain[i] is already trusted. It may be inside</span>
<span class="line-modified">232             // trustedCerts, or has the same dn and public key as a cert</span>
<span class="line-removed">233             // inside trustedCerts. The latter happens when a CA has</span>
<span class="line-removed">234             // updated its cert with a stronger signature algorithm in JRE</span>
<span class="line-removed">235             // but the weak one is still in circulation.</span>
<span class="line-removed">236 </span>
<span class="line-removed">237             if (trustedCerts.contains(cert) ||          // trusted cert</span>
<span class="line-removed">238                     (trustedSubjects.containsKey(dn) &amp;&amp; // replacing ...</span>
<span class="line-removed">239                      trustedSubjects.get(dn).contains(  // ... weak cert</span>
<span class="line-removed">240                         cert.getPublicKey()))) {</span>
<span class="line-removed">241                 if (i == 0) {</span>
242                     return new X509Certificate[] {chain[0]};
243                 }
<a name="8" id="anc8"></a><span class="line-modified">244                 // Remove and call validator on partial chain [0 .. i-1]</span>
<span class="line-modified">245                 X509Certificate[] newChain = new X509Certificate[i];</span>
<span class="line-modified">246                 System.arraycopy(chain, 0, newChain, 0, i);</span>
<span class="line-modified">247                 return doValidate(newChain, pkixParameters);</span>















248             }
249             prevIssuer = cert.getIssuerX500Principal();
250         }
251 
252         // apparently issued by trust anchor?
253         X509Certificate last = chain[chain.length - 1];
254         X500Principal issuer = last.getIssuerX500Principal();
255         X500Principal subject = last.getSubjectX500Principal();
256         if (trustedSubjects.containsKey(issuer) &amp;&amp;
257                 isSignatureValid(trustedSubjects.get(issuer), last)) {
258             return doValidate(chain, pkixParameters);
259         }
260 
261         // don&#39;t fallback to builder if called from plugin/webstart
262         if (plugin) {
263             // Validate chain even if no trust anchor is found. This
264             // allows plugin/webstart to make sure the chain is
265             // otherwise valid
266             if (chain.length &gt; 1) {
267                 X509Certificate[] newChain =
268                     new X509Certificate[chain.length-1];
269                 System.arraycopy(chain, 0, newChain, 0, newChain.length);
270 
271                 // temporarily set last cert as sole trust anchor
272                 try {
273                     pkixParameters.setTrustAnchors
274                         (Collections.singleton(new TrustAnchor
275                             (chain[chain.length-1], null)));
276                 } catch (InvalidAlgorithmParameterException iape) {
277                     // should never occur, but ...
278                     throw new CertificateException(iape);
279                 }
280                 doValidate(newChain, pkixParameters);
281             }
282             // if the rest of the chain is valid, throw exception
283             // indicating no trust anchor was found
284             throw new ValidatorException
285                 (ValidatorException.T_NO_TRUST_ANCHOR);
286         }
287         // otherwise, fall back to builder
288 
289         return doBuild(chain, otherCerts, pkixParameters);
290     }
291 
292     private boolean isSignatureValid(List&lt;PublicKey&gt; keys,
293             X509Certificate sub) {
294         if (plugin) {
295             for (PublicKey key: keys) {
296                 try {
297                     sub.verify(key);
298                     return true;
299                 } catch (Exception ex) {
300                     continue;
301                 }
302             }
303             return false;
304         }
305         return true; // only check if PLUGIN is set
306     }
307 
308     private static X509Certificate[] toArray(CertPath path, TrustAnchor anchor)
309             throws CertificateException {
<a name="9" id="anc9"></a><span class="line-removed">310         List&lt;? extends java.security.cert.Certificate&gt; list =</span>
<span class="line-removed">311                                                 path.getCertificates();</span>
<span class="line-removed">312         X509Certificate[] chain = new X509Certificate[list.size() + 1];</span>
<span class="line-removed">313         list.toArray(chain);</span>
314         X509Certificate trustedCert = anchor.getTrustedCert();
315         if (trustedCert == null) {
316             throw new ValidatorException
317                 (&quot;TrustAnchor must be specified as certificate&quot;);
318         }
<a name="10" id="anc10"></a>






319         chain[chain.length - 1] = trustedCert;
320         return chain;
321     }
322 
323     /**
324      * Set the check date (for debugging).
325      */
326     private void setDate(PKIXBuilderParameters params) {
327         @SuppressWarnings(&quot;deprecation&quot;)
328         Date date = validationDate;
329         if (date != null) {
330             params.setDate(date);
331         }
332     }
333 
334     private X509Certificate[] doValidate(X509Certificate[] chain,
335             PKIXBuilderParameters params) throws CertificateException {
336         try {
337             setDate(params);
338 
339             // do the validation
340             CertPathValidator validator = CertPathValidator.getInstance(&quot;PKIX&quot;);
341             CertPath path = factory.generateCertPath(Arrays.asList(chain));
342             certPathLength = chain.length;
343             PKIXCertPathValidatorResult result =
344                 (PKIXCertPathValidatorResult)validator.validate(path, params);
345 
346             return toArray(path, result.getTrustAnchor());
347         } catch (GeneralSecurityException e) {
348             throw new ValidatorException
349                 (&quot;PKIX path validation failed: &quot; + e.toString(), e);
350         }
351     }
352 
<a name="11" id="anc11"></a>


































353     private X509Certificate[] doBuild(X509Certificate[] chain,
354         Collection&lt;X509Certificate&gt; otherCerts,
355         PKIXBuilderParameters params) throws CertificateException {
356 
357         try {
358             setDate(params);
359 
360             // setup target constraints
361             X509CertSelector selector = new X509CertSelector();
362             selector.setCertificate(chain[0]);
363             params.setTargetCertConstraints(selector);
364 
365             // setup CertStores
366             Collection&lt;X509Certificate&gt; certs =
367                                         new ArrayList&lt;X509Certificate&gt;();
368             certs.addAll(Arrays.asList(chain));
369             if (otherCerts != null) {
370                 certs.addAll(otherCerts);
371             }
372             CertStore store = CertStore.getInstance(&quot;Collection&quot;,
373                                 new CollectionCertStoreParameters(certs));
374             params.addCertStore(store);
375 
376             // do the build
377             CertPathBuilder builder = CertPathBuilder.getInstance(&quot;PKIX&quot;);
378             PKIXCertPathBuilderResult result =
379                 (PKIXCertPathBuilderResult)builder.build(params);
380 
381             return toArray(result.getCertPath(), result.getTrustAnchor());
382         } catch (GeneralSecurityException e) {
383             throw new ValidatorException
384                 (&quot;PKIX path building failed: &quot; + e.toString(), e);
385         }
386     }
387 
388     /**
389      * For OCSP Stapling, add responses that came in during the handshake
390      * into a {@code PKIXRevocationChecker} so we can evaluate them.
391      *
392      * @param pkixParams the pkixParameters object that will be used in
393      * path validation.
394      * @param chain the chain of certificates to verify
395      * @param responseList a {@code List} of zero or more byte arrays, each
396      * one being a DER-encoded OCSP response (per RFC 6960).  Entries
397      * in the List must match the order of the certificates in the
398      * chain parameter.
399      */
400     private static void addResponses(PKIXBuilderParameters pkixParams,
401             X509Certificate[] chain, List&lt;byte[]&gt; responseList) {
<a name="12" id="anc12"></a><span class="line-modified">402 </span>
<span class="line-modified">403         if (pkixParams.isRevocationEnabled()) {</span>
<span class="line-modified">404             try {</span>
<span class="line-modified">405                 // Make a modifiable copy of the CertPathChecker list</span>
<span class="line-modified">406                 PKIXRevocationChecker revChecker = null;</span>
<span class="line-modified">407                 List&lt;PKIXCertPathChecker&gt; checkerList =</span>
<span class="line-modified">408                         new ArrayList&lt;&gt;(pkixParams.getCertPathCheckers());</span>
<span class="line-modified">409 </span>
<span class="line-modified">410                 // Find the first PKIXRevocationChecker in the list</span>
<span class="line-modified">411                 for (PKIXCertPathChecker checker : checkerList) {</span>
<span class="line-modified">412                     if (checker instanceof PKIXRevocationChecker) {</span>
<span class="line-modified">413                         revChecker = (PKIXRevocationChecker)checker;</span>
<span class="line-modified">414                         break;</span>
<span class="line-removed">415                     }</span>
416                 }
<a name="13" id="anc13"></a>
417 
<a name="14" id="anc14"></a><span class="line-modified">418                 // If we still haven&#39;t found one, make one</span>
<span class="line-modified">419                 if (revChecker == null) {</span>






420                     revChecker = (PKIXRevocationChecker)CertPathValidator.
421                             getInstance(&quot;PKIX&quot;).getRevocationChecker();
<a name="15" id="anc15"></a><span class="line-modified">422                     checkerList.add(revChecker);</span>


423                 }
<a name="16" id="anc16"></a>
424 
<a name="17" id="anc17"></a><span class="line-modified">425                 // Each response in the list should be in parallel with</span>
<span class="line-modified">426                 // the certificate list.  If there is a zero-length response</span>
<span class="line-modified">427                 // treat it as being absent.  If the user has provided their</span>
<span class="line-modified">428                 // own PKIXRevocationChecker with pre-populated responses, do</span>
<span class="line-modified">429                 // not overwrite them with the ones from the handshake.</span>
<span class="line-modified">430                 Map&lt;X509Certificate, byte[]&gt; responseMap =</span>
<span class="line-modified">431                         revChecker.getOcspResponses();</span>
<span class="line-modified">432                 int limit = Integer.min(chain.length, responseList.size());</span>
<span class="line-modified">433                 for (int idx = 0; idx &lt; limit; idx++) {</span>
<span class="line-modified">434                     byte[] respBytes = responseList.get(idx);</span>
<span class="line-modified">435                     if (respBytes != null &amp;&amp; respBytes.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">436                             !responseMap.containsKey(chain[idx])) {</span>
<span class="line-modified">437                         responseMap.put(chain[idx], respBytes);</span>
<span class="line-removed">438                     }</span>
439                 }
<a name="18" id="anc18"></a>

440 
<a name="19" id="anc19"></a><span class="line-modified">441                 // Add the responses and push it all back into the</span>
<span class="line-modified">442                 // PKIXBuilderParameters</span>
<span class="line-modified">443                 revChecker.setOcspResponses(responseMap);</span>


444                 pkixParams.setCertPathCheckers(checkerList);
<a name="20" id="anc20"></a><span class="line-removed">445             } catch (NoSuchAlgorithmException exc) {</span>
<span class="line-removed">446                 // This should not occur, but if it does happen then</span>
<span class="line-removed">447                 // stapled OCSP responses won&#39;t be part of revocation checking.</span>
<span class="line-removed">448                 // Clients can still fall back to other means of revocation</span>
<span class="line-removed">449                 // checking.</span>
450             }
<a name="21" id="anc21"></a>




451         }
452     }
453 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
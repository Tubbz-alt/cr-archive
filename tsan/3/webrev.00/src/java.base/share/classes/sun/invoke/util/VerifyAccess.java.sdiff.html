<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/invoke/util/VerifyAccess.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../launcher/LauncherHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/invoke/util/VerifyAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71      *     a superclass of D, or D itself.
 72      *     &lt;p&gt;During verification, it was also required that, even if T is
 73      *     a superclass of D, the target reference of a protected instance
 74      *     field access or method invocation must be an instance of D or a
 75      *     subclass of D (4.10.1.8).&lt;/p&gt;&lt;/li&gt;
 76      * &lt;li&gt;R is either protected or has default access (that is, neither
 77      *     public nor protected nor private), and is declared by a class
 78      *     in the same run-time package as D.&lt;/li&gt;
 79      * &lt;li&gt;R is private and is declared in D by a class or interface
 80      *     belonging to the same nest as D.&lt;/li&gt;
 81      * &lt;/ul&gt;
 82      * If a referenced field or method is not accessible, access checking
 83      * throws an IllegalAccessError. If an exception is thrown while
 84      * attempting to determine the nest host of a class or interface,
 85      * access checking fails for the same reason.
 86      *
 87      * @param refc the class used in the symbolic reference to the proposed member
 88      * @param defc the class in which the proposed member is actually defined
 89      * @param mods modifier flags for the proposed member
 90      * @param lookupClass the class for which the access check is being made


 91      * @return true iff the accessing class can access such a member
 92      */
 93     public static boolean isMemberAccessible(Class&lt;?&gt; refc,  // symbolic ref class
 94                                              Class&lt;?&gt; defc,  // actual def class
 95                                              int      mods,  // actual member mods
 96                                              Class&lt;?&gt; lookupClass,

 97                                              int      allowedModes) {
 98         if (allowedModes == 0)  return false;
<span class="line-modified"> 99         assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
<span class="line-removed">100                (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
101         // The symbolic reference class (refc) must always be fully verified.
<span class="line-modified">102         if (!isClassAccessible(refc, lookupClass, allowedModes)) {</span>
103             return false;
104         }
105         // Usually refc and defc are the same, but verify defc also in case they differ.
106         if (defc == lookupClass  &amp;&amp;
107             (allowedModes &amp; PRIVATE) != 0)
108             return true;        // easy check; all self-access is OK with a private lookup
109 
110         switch (mods &amp; ALL_ACCESS_MODES) {
111         case PUBLIC:

112             return true;  // already checked above
113         case PROTECTED:
114             assert !defc.isInterface(); // protected members aren&#39;t allowed in interfaces
115             if ((allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0 &amp;&amp;
116                 isSamePackage(defc, lookupClass))
117                 return true;
118             if ((allowedModes &amp; PROTECTED) == 0)
119                 return false;
120             // Protected members are accessible by subclasses, which does not include interfaces.
121             // Interfaces are types, not classes. They should not have access to
122             // protected members in j.l.Object, even though it is their superclass.
123             if ((mods &amp; STATIC) != 0 &amp;&amp;
124                 !isRelatedClass(refc, lookupClass))
125                 return false;
126             if ((allowedModes &amp; PROTECTED) != 0 &amp;&amp;
127                 isSubClass(lookupClass, defc))
128                 return true;
129             return false;
130         case PACKAGE_ONLY:  // That is, zero.  Unmarked member is package-only access.
131             assert !defc.isInterface(); // package-private members aren&#39;t allowed in interfaces
</pre>
<hr />
<pre>
158     static int getClassModifiers(Class&lt;?&gt; c) {
159         // This would return the mask stored by javac for the source-level modifiers.
160         //   return c.getModifiers();
161         // But what we need for JVM access checks are the actual bits from the class header.
162         // ...But arrays and primitives are synthesized with their own odd flags:
163         if (c.isArray() || c.isPrimitive())
164             return c.getModifiers();
165         return Reflection.getClassAccessFlags(c);
166     }
167 
168     /**
169      * Evaluate the JVM linkage rules for access to the given class on behalf of caller.
170      * &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
171      * A class or interface C is accessible to a class or interface D
172      * if and only if any of the following conditions are true:&lt;ul&gt;
173      * &lt;li&gt;C is public and in the same module as D.
174      * &lt;li&gt;D is in a module that reads the module containing C, C is public and in a
175      * package that is exported to the module that contains D.
176      * &lt;li&gt;C and D are members of the same runtime package.
177      * &lt;/ul&gt;

178      * @param refc the symbolic reference class to which access is being checked (C)
179      * @param lookupClass the class performing the lookup (D)


180      */
<span class="line-modified">181     public static boolean isClassAccessible(Class&lt;?&gt; refc, Class&lt;?&gt; lookupClass,</span>


182                                             int allowedModes) {
183         if (allowedModes == 0)  return false;
<span class="line-modified">184         assert((allowedModes &amp; PUBLIC) != 0 &amp;&amp;</span>
<span class="line-modified">185                (allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>




186         int mods = getClassModifiers(refc);
187         if (isPublic(mods)) {
188 
189             Module lookupModule = lookupClass.getModule();
190             Module refModule = refc.getModule();
191 
192             // early VM startup case, java.base not defined
193             if (lookupModule == null) {
194                 assert refModule == null;
195                 return true;
196             }
197 
<span class="line-modified">198             // trivially allow</span>
<span class="line-modified">199             if ((allowedModes &amp; MODULE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-modified">200                 (lookupModule == refModule))</span>
<span class="line-modified">201                 return true;</span>
202 
<span class="line-modified">203             // check readability when UNCONDITIONAL not allowed</span>
<span class="line-modified">204             if (((allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0)</span>
<span class="line-modified">205                 || lookupModule.canRead(refModule)) {</span>
<span class="line-removed">206 </span>
<span class="line-removed">207                 // check that refc is in an exported package</span>
<span class="line-removed">208                 if ((allowedModes &amp; MODULE_ALLOWED) != 0) {</span>
<span class="line-removed">209                     if (refModule.isExported(refc.getPackageName(), lookupModule))</span>
<span class="line-removed">210                         return true;</span>
<span class="line-removed">211                 } else {</span>
<span class="line-removed">212                     // exported unconditionally</span>
<span class="line-removed">213                     if (refModule.isExported(refc.getPackageName()))</span>
<span class="line-removed">214                         return true;</span>
<span class="line-removed">215                 }</span>
<span class="line-removed">216 </span>
<span class="line-removed">217                 // not exported but allow access during VM initialization</span>
<span class="line-removed">218                 // because java.base does not have its exports setup</span>
<span class="line-removed">219                 if (!jdk.internal.misc.VM.isModuleSystemInited())</span>
220                     return true;



221             }
222 














223             // public class not accessible to lookupClass
224             return false;
225         }
<span class="line-modified">226         if ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-modified">227             isSamePackage(lookupClass, refc))</span>
<span class="line-modified">228             return true;</span>






















229         return false;
230     }
231 
232     /**
233      * Decide if the given method type, attributed to a member or symbolic
234      * reference of a given reference class, is really visible to that class.
235      * @param type the supposed type of a member or symbolic reference of refc
236      * @param refc the class attempting to make the reference
237      */
238     public static boolean isTypeVisible(Class&lt;?&gt; type, Class&lt;?&gt; refc) {
239         if (type == refc) {
240             return true;  // easy check
241         }
242         while (type.isArray())  type = type.getComponentType();
243         if (type.isPrimitive() || type == Object.class) {
244             return true;
245         }
246         ClassLoader typeLoader = type.getClassLoader();
247         ClassLoader refcLoader = refc.getClassLoader();
248         if (typeLoader == refcLoader) {
</pre>
</td>
<td>
<hr />
<pre>
 71      *     a superclass of D, or D itself.
 72      *     &lt;p&gt;During verification, it was also required that, even if T is
 73      *     a superclass of D, the target reference of a protected instance
 74      *     field access or method invocation must be an instance of D or a
 75      *     subclass of D (4.10.1.8).&lt;/p&gt;&lt;/li&gt;
 76      * &lt;li&gt;R is either protected or has default access (that is, neither
 77      *     public nor protected nor private), and is declared by a class
 78      *     in the same run-time package as D.&lt;/li&gt;
 79      * &lt;li&gt;R is private and is declared in D by a class or interface
 80      *     belonging to the same nest as D.&lt;/li&gt;
 81      * &lt;/ul&gt;
 82      * If a referenced field or method is not accessible, access checking
 83      * throws an IllegalAccessError. If an exception is thrown while
 84      * attempting to determine the nest host of a class or interface,
 85      * access checking fails for the same reason.
 86      *
 87      * @param refc the class used in the symbolic reference to the proposed member
 88      * @param defc the class in which the proposed member is actually defined
 89      * @param mods modifier flags for the proposed member
 90      * @param lookupClass the class for which the access check is being made
<span class="line-added"> 91      * @param prevLookupClass the class for which the access check is being made</span>
<span class="line-added"> 92      * @param allowedModes allowed modes</span>
 93      * @return true iff the accessing class can access such a member
 94      */
 95     public static boolean isMemberAccessible(Class&lt;?&gt; refc,  // symbolic ref class
 96                                              Class&lt;?&gt; defc,  // actual def class
 97                                              int      mods,  // actual member mods
 98                                              Class&lt;?&gt; lookupClass,
<span class="line-added"> 99                                              Class&lt;?&gt; prevLookupClass,</span>
100                                              int      allowedModes) {
101         if (allowedModes == 0)  return false;
<span class="line-modified">102         assert((allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>

103         // The symbolic reference class (refc) must always be fully verified.
<span class="line-modified">104         if (!isClassAccessible(refc, lookupClass, prevLookupClass, allowedModes)) {</span>
105             return false;
106         }
107         // Usually refc and defc are the same, but verify defc also in case they differ.
108         if (defc == lookupClass  &amp;&amp;
109             (allowedModes &amp; PRIVATE) != 0)
110             return true;        // easy check; all self-access is OK with a private lookup
111 
112         switch (mods &amp; ALL_ACCESS_MODES) {
113         case PUBLIC:
<span class="line-added">114             assert (allowedModes &amp; PUBLIC) != 0 || (allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0;</span>
115             return true;  // already checked above
116         case PROTECTED:
117             assert !defc.isInterface(); // protected members aren&#39;t allowed in interfaces
118             if ((allowedModes &amp; PROTECTED_OR_PACKAGE_ALLOWED) != 0 &amp;&amp;
119                 isSamePackage(defc, lookupClass))
120                 return true;
121             if ((allowedModes &amp; PROTECTED) == 0)
122                 return false;
123             // Protected members are accessible by subclasses, which does not include interfaces.
124             // Interfaces are types, not classes. They should not have access to
125             // protected members in j.l.Object, even though it is their superclass.
126             if ((mods &amp; STATIC) != 0 &amp;&amp;
127                 !isRelatedClass(refc, lookupClass))
128                 return false;
129             if ((allowedModes &amp; PROTECTED) != 0 &amp;&amp;
130                 isSubClass(lookupClass, defc))
131                 return true;
132             return false;
133         case PACKAGE_ONLY:  // That is, zero.  Unmarked member is package-only access.
134             assert !defc.isInterface(); // package-private members aren&#39;t allowed in interfaces
</pre>
<hr />
<pre>
161     static int getClassModifiers(Class&lt;?&gt; c) {
162         // This would return the mask stored by javac for the source-level modifiers.
163         //   return c.getModifiers();
164         // But what we need for JVM access checks are the actual bits from the class header.
165         // ...But arrays and primitives are synthesized with their own odd flags:
166         if (c.isArray() || c.isPrimitive())
167             return c.getModifiers();
168         return Reflection.getClassAccessFlags(c);
169     }
170 
171     /**
172      * Evaluate the JVM linkage rules for access to the given class on behalf of caller.
173      * &lt;h3&gt;JVM Specification, 5.4.4 &quot;Access Control&quot;&lt;/h3&gt;
174      * A class or interface C is accessible to a class or interface D
175      * if and only if any of the following conditions are true:&lt;ul&gt;
176      * &lt;li&gt;C is public and in the same module as D.
177      * &lt;li&gt;D is in a module that reads the module containing C, C is public and in a
178      * package that is exported to the module that contains D.
179      * &lt;li&gt;C and D are members of the same runtime package.
180      * &lt;/ul&gt;
<span class="line-added">181      *</span>
182      * @param refc the symbolic reference class to which access is being checked (C)
183      * @param lookupClass the class performing the lookup (D)
<span class="line-added">184      * @param prevLookupClass the class from which the lookup was teleported or null</span>
<span class="line-added">185      * @param allowedModes allowed modes</span>
186      */
<span class="line-modified">187     public static boolean isClassAccessible(Class&lt;?&gt; refc,</span>
<span class="line-added">188                                             Class&lt;?&gt; lookupClass,</span>
<span class="line-added">189                                             Class&lt;?&gt; prevLookupClass,</span>
190                                             int allowedModes) {
191         if (allowedModes == 0)  return false;
<span class="line-modified">192         assert((allowedModes &amp; ~(ALL_ACCESS_MODES|PACKAGE_ALLOWED|MODULE_ALLOWED|UNCONDITIONAL_ALLOWED)) == 0);</span>
<span class="line-modified">193 </span>
<span class="line-added">194         if ((allowedModes &amp; PACKAGE_ALLOWED) != 0 &amp;&amp;</span>
<span class="line-added">195             isSamePackage(lookupClass, refc))</span>
<span class="line-added">196             return true;</span>
<span class="line-added">197 </span>
198         int mods = getClassModifiers(refc);
199         if (isPublic(mods)) {
200 
201             Module lookupModule = lookupClass.getModule();
202             Module refModule = refc.getModule();
203 
204             // early VM startup case, java.base not defined
205             if (lookupModule == null) {
206                 assert refModule == null;
207                 return true;
208             }
209 
<span class="line-modified">210             // allow access to public types in all unconditionally exported packages</span>
<span class="line-modified">211             if ((allowedModes &amp; UNCONDITIONAL_ALLOWED) != 0) {</span>
<span class="line-modified">212                 return refModule.isExported(refc.getPackageName());</span>
<span class="line-modified">213             }</span>
214 
<span class="line-modified">215             if (lookupModule == refModule &amp;&amp; prevLookupClass == null) {</span>
<span class="line-modified">216                 // allow access to all public types in lookupModule</span>
<span class="line-modified">217                 if ((allowedModes &amp; MODULE_ALLOWED) != 0)</span>














218                     return true;
<span class="line-added">219 </span>
<span class="line-added">220                 assert (allowedModes &amp; PUBLIC) != 0;</span>
<span class="line-added">221                 return refModule.isExported(refc.getPackageName());</span>
222             }
223 
<span class="line-added">224             // cross-module access</span>
<span class="line-added">225             // 1. refc is in different module from lookupModule, or</span>
<span class="line-added">226             // 2. refc is in lookupModule and a different module from prevLookupModule</span>
<span class="line-added">227             Module prevLookupModule = prevLookupClass != null ? prevLookupClass.getModule()</span>
<span class="line-added">228                                                               : null;</span>
<span class="line-added">229             assert refModule != lookupModule || refModule != prevLookupModule;</span>
<span class="line-added">230             if (isModuleAccessible(refc, lookupModule, prevLookupModule))</span>
<span class="line-added">231                 return true;</span>
<span class="line-added">232 </span>
<span class="line-added">233             // not exported but allow access during VM initialization</span>
<span class="line-added">234             // because java.base does not have its exports setup</span>
<span class="line-added">235             if (!jdk.internal.misc.VM.isModuleSystemInited())</span>
<span class="line-added">236                 return true;</span>
<span class="line-added">237 </span>
238             // public class not accessible to lookupClass
239             return false;
240         }
<span class="line-modified">241 </span>
<span class="line-modified">242         return false;</span>
<span class="line-modified">243     }</span>
<span class="line-added">244 </span>
<span class="line-added">245     /*</span>
<span class="line-added">246      * Tests if a class or interface REFC is accessible to m1 and m2 where m2</span>
<span class="line-added">247      * may be null.</span>
<span class="line-added">248      *</span>
<span class="line-added">249      * A class or interface REFC in m is accessible to m1 and m2 if and only if</span>
<span class="line-added">250      * both m1 and m2 read m and m exports the package of REFC at least to</span>
<span class="line-added">251      * both m1 and m2.</span>
<span class="line-added">252      */</span>
<span class="line-added">253     public static boolean isModuleAccessible(Class&lt;?&gt; refc,  Module m1, Module m2) {</span>
<span class="line-added">254         Module refModule = refc.getModule();</span>
<span class="line-added">255         assert refModule != m1 || refModule != m2;</span>
<span class="line-added">256         int mods = getClassModifiers(refc);</span>
<span class="line-added">257         if (isPublic(mods)) {</span>
<span class="line-added">258             if (m1.canRead(refModule) &amp;&amp; (m2 == null || m2.canRead(refModule))) {</span>
<span class="line-added">259                 String pn = refc.getPackageName();</span>
<span class="line-added">260 </span>
<span class="line-added">261                 // refc is exported package to at least both m1 and m2</span>
<span class="line-added">262                 if (refModule.isExported(pn, m1) &amp;&amp; (m2 == null || refModule.isExported(pn, m2)))</span>
<span class="line-added">263                     return true;</span>
<span class="line-added">264             }</span>
<span class="line-added">265         }</span>
266         return false;
267     }
268 
269     /**
270      * Decide if the given method type, attributed to a member or symbolic
271      * reference of a given reference class, is really visible to that class.
272      * @param type the supposed type of a member or symbolic reference of refc
273      * @param refc the class attempting to make the reference
274      */
275     public static boolean isTypeVisible(Class&lt;?&gt; type, Class&lt;?&gt; refc) {
276         if (type == refc) {
277             return true;  // easy check
278         }
279         while (type.isArray())  type = type.getComponentType();
280         if (type.isPrimitive() || type == Object.class) {
281             return true;
282         }
283         ClassLoader typeLoader = type.getClassLoader();
284         ClassLoader refcLoader = refc.getClassLoader();
285         if (typeLoader == refcLoader) {
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../launcher/LauncherHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
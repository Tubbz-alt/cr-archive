<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketAdaptor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;

 34 import java.net.StandardSocketOptions;
 35 import java.nio.channels.AlreadyBoundException;
 36 import java.nio.channels.AsynchronousCloseException;
 37 import java.nio.channels.ClosedChannelException;

 38 import java.nio.channels.NotYetBoundException;
 39 import java.nio.channels.SelectionKey;
 40 import java.nio.channels.ServerSocketChannel;
 41 import java.nio.channels.SocketChannel;
 42 import java.nio.channels.spi.SelectorProvider;
 43 import java.util.Collections;
 44 import java.util.HashSet;
 45 import java.util.Objects;
 46 import java.util.Set;
 47 import java.util.concurrent.locks.ReentrantLock;
 48 
 49 import sun.net.NetHooks;
 50 import sun.net.ext.ExtendedSocketOptions;
 51 
 52 /**
 53  * An implementation of ServerSocketChannels
 54  */
 55 
 56 class ServerSocketChannelImpl
 57     extends ServerSocketChannel
 58     implements SelChImpl
 59 {
 60     // Used to make native close and configure calls
<span class="line-modified"> 61     private static NativeDispatcher nd;</span>
 62 
 63     // Our file descriptor
 64     private final FileDescriptor fd;
 65     private final int fdVal;
 66 
 67     // Lock held by thread currently blocked on this channel
 68     private final ReentrantLock acceptLock = new ReentrantLock();
 69 
 70     // Lock held by any thread that modifies the state fields declared below
 71     // DO NOT invoke a blocking I/O operation while holding this lock!
 72     private final Object stateLock = new Object();
 73 
 74     // -- The following fields are protected by stateLock
 75 
 76     // Channel state, increases monotonically
 77     private static final int ST_INUSE = 0;
 78     private static final int ST_CLOSING = 1;
<span class="line-modified"> 79     private static final int ST_KILLPENDING = 2;</span>
<span class="line-removed"> 80     private static final int ST_KILLED = 3;</span>
 81     private int state;
 82 
 83     // ID of native thread currently blocked in this channel, for signalling
 84     private long thread;
 85 
 86     // Binding
 87     private InetSocketAddress localAddress; // null =&gt; unbound
 88 
 89     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 90     private boolean isReuseAddress;
 91 
 92     // Our socket adaptor, if any
 93     private ServerSocket socket;
 94 
 95     // -- End of fields protected by stateLock
 96 
 97 
<span class="line-modified"> 98     ServerSocketChannelImpl(SelectorProvider sp) throws IOException {</span>
 99         super(sp);
<span class="line-modified">100         this.fd =  Net.serverSocket(true);</span>
101         this.fdVal = IOUtil.fdVal(fd);
102     }
103 
104     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
105         throws IOException
106     {
107         super(sp);
108         this.fd =  fd;
109         this.fdVal = IOUtil.fdVal(fd);
110         if (bound) {
111             synchronized (stateLock) {
112                 localAddress = Net.localAddress(fd);
113             }
114         }
115     }
116 
117     // @throws ClosedChannelException if channel is closed
118     private void ensureOpen() throws ClosedChannelException {
119         if (!isOpen())
120             throw new ClosedChannelException();
</pre>
<hr />
<pre>
129         }
130     }
131 
132     @Override
133     public SocketAddress getLocalAddress() throws IOException {
134         synchronized (stateLock) {
135             ensureOpen();
136             return (localAddress == null)
137                     ? null
138                     : Net.getRevealedLocalAddress(localAddress);
139         }
140     }
141 
142     @Override
143     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
144         throws IOException
145     {
146         Objects.requireNonNull(name);
147         if (!supportedOptions().contains(name))
148             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);



149         synchronized (stateLock) {
150             ensureOpen();
151 
152             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
153                 // SO_REUSEADDR emulated when using exclusive bind
154                 isReuseAddress = (Boolean)value;
155             } else {
156                 // no options that require special handling
157                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
158             }
159             return this;
160         }
161     }
162 
163     @Override
164     @SuppressWarnings(&quot;unchecked&quot;)
165     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
166         throws IOException
167     {
168         Objects.requireNonNull(name);
</pre>
<hr />
<pre>
233             ensureOpen();
234             if (localAddress == null)
235                 throw new NotYetBoundException();
236             if (blocking)
237                 thread = NativeThread.current();
238         }
239     }
240 
241     /**
242      * Marks the end of an I/O operation that may have blocked.
243      *
244      * @throws AsynchronousCloseException if the channel was closed due to this
245      * thread being interrupted on a blocking I/O operation.
246      */
247     private void end(boolean blocking, boolean completed)
248         throws AsynchronousCloseException
249     {
250         if (blocking) {
251             synchronized (stateLock) {
252                 thread = 0;
<span class="line-removed">253                 // notify any thread waiting in implCloseSelectableChannel</span>
254                 if (state == ST_CLOSING) {
<span class="line-modified">255                     stateLock.notifyAll();</span>
256                 }
257             }
258             end(completed);
259         }
260     }
261 
262     @Override
263     public SocketChannel accept() throws IOException {




264         acceptLock.lock();
265         try {
<span class="line-removed">266             int n = 0;</span>
<span class="line-removed">267             FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-removed">268             InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="line-removed">269 </span>
270             boolean blocking = isBlocking();
271             try {
272                 begin(blocking);
<span class="line-modified">273                 do {</span>
<span class="line-modified">274                     n = accept(this.fd, newfd, isaa);</span>
<span class="line-modified">275                 } while (n == IOStatus.INTERRUPTED &amp;&amp; isOpen());</span>




276             } finally {
277                 end(blocking, n &gt; 0);
278                 assert IOStatus.check(n);
279             }



280 
<span class="line-modified">281             if (n &lt; 1)</span>
<span class="line-modified">282                 return null;</span>




283 
<span class="line-modified">284             // newly accepted socket is initially in blocking mode</span>
<span class="line-modified">285             IOUtil.configureBlocking(newfd, true);</span>












286 
<span class="line-modified">287             InetSocketAddress isa = isaa[0];</span>
<span class="line-modified">288             SocketChannel sc = new SocketChannelImpl(provider(), newfd, isa);</span>



289 
<span class="line-modified">290             // check permitted to accept connections from the remote address</span>
<span class="line-modified">291             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-modified">292             if (sm != null) {</span>

293                 try {
<span class="line-modified">294                     sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-modified">295                 } catch (SecurityException x) {</span>
<span class="line-modified">296                     sc.close();</span>
<span class="line-modified">297                     throw x;</span>









298                 }


299             }
<span class="line-removed">300             return sc;</span>
<span class="line-removed">301 </span>
302         } finally {
303             acceptLock.unlock();
304         }






















305     }
306 
307     @Override
308     protected void implConfigureBlocking(boolean block) throws IOException {
309         acceptLock.lock();
310         try {
<span class="line-modified">311             synchronized (stateLock) {</span>
<span class="line-removed">312                 ensureOpen();</span>
<span class="line-removed">313                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-removed">314             }</span>
315         } finally {
316             acceptLock.unlock();
317         }
318     }
319 
320     /**
<span class="line-modified">321      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">322      *</span>
<span class="line-modified">323      * This method waits for outstanding I/O operations to complete. When in</span>
<span class="line-modified">324      * blocking mode, the socket is pre-closed and the threads in blocking I/O</span>
<span class="line-modified">325      * operations are signalled to ensure that the outstanding I/O operations</span>
<span class="line-modified">326      * complete quickly.</span>







327      *
<span class="line-modified">328      * The socket is closed by this method when it is not registered with a</span>
<span class="line-modified">329      * Selector. Note that a channel configured blocking may be registered with</span>
<span class="line-removed">330      * a Selector. This arises when a key is canceled and the channel configured</span>
<span class="line-removed">331      * to blocking mode before the key is flushed from the Selector.</span>
332      */
<span class="line-modified">333     @Override</span>
<span class="line-modified">334     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">335         assert !isOpen();</span>








336 
<span class="line-modified">337         boolean interrupted = false;</span>
<span class="line-modified">338         boolean blocking;</span>












339 
<span class="line-modified">340         // set state to ST_CLOSING</span>


















341         synchronized (stateLock) {
342             assert state &lt; ST_CLOSING;
343             state = ST_CLOSING;
<span class="line-modified">344             blocking = isBlocking();</span>
<span class="line-removed">345         }</span>
<span class="line-removed">346 </span>
<span class="line-removed">347         // wait for any outstanding accept to complete</span>
<span class="line-removed">348         if (blocking) {</span>
<span class="line-removed">349             synchronized (stateLock) {</span>
<span class="line-removed">350                 assert state == ST_CLOSING;</span>
351                 long th = thread;
352                 if (th != 0) {
353                     nd.preClose(fd);
354                     NativeThread.signal(th);
<span class="line-removed">355 </span>
<span class="line-removed">356                     // wait for accept operation to end</span>
<span class="line-removed">357                     while (thread != 0) {</span>
<span class="line-removed">358                         try {</span>
<span class="line-removed">359                             stateLock.wait();</span>
<span class="line-removed">360                         } catch (InterruptedException e) {</span>
<span class="line-removed">361                             interrupted = true;</span>
<span class="line-removed">362                         }</span>
<span class="line-removed">363                     }</span>
364                 }
365             }
<span class="line-removed">366         } else {</span>
<span class="line-removed">367             // non-blocking mode: wait for accept to complete</span>
<span class="line-removed">368             acceptLock.lock();</span>
<span class="line-removed">369             acceptLock.unlock();</span>
370         }

371 
<span class="line-modified">372         // set state to ST_KILLPENDING</span>













373         synchronized (stateLock) {
<span class="line-modified">374             assert state == ST_CLOSING;</span>
<span class="line-modified">375             state = ST_KILLPENDING;</span>

376         }

377 
<span class="line-modified">378         // close socket if not registered with Selector</span>
<span class="line-modified">379         if (!isRegistered())</span>
<span class="line-modified">380             kill();</span>
<span class="line-modified">381 </span>
<span class="line-modified">382         // restore interrupt status</span>
<span class="line-modified">383         if (interrupted)</span>
<span class="line-modified">384             Thread.currentThread().interrupt();</span>




385     }
386 
387     @Override
<span class="line-modified">388     public void kill() throws IOException {</span>
389         synchronized (stateLock) {
<span class="line-modified">390             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">391                 state = ST_KILLED;</span>
<span class="line-removed">392                 nd.close(fd);</span>
393             }
394         }
395     }
396 
397     /**
398      * Returns true if channel&#39;s socket is bound
399      */
400     boolean isBound() {
401         synchronized (stateLock) {
402             return localAddress != null;
403         }
404     }
405 
406     /**
407      * Returns the local address, or null if not bound
408      */
409     InetSocketAddress localAddress() {
410         synchronized (stateLock) {
411             return localAddress;
412         }
413     }
414 
<span class="line-removed">415     /**</span>
<span class="line-removed">416      * Poll this channel&#39;s socket for a new connection up to the given timeout.</span>
<span class="line-removed">417      * @return {@code true} if there is a connection to accept</span>
<span class="line-removed">418      */</span>
<span class="line-removed">419     boolean pollAccept(long timeout) throws IOException {</span>
<span class="line-removed">420         assert Thread.holdsLock(blockingLock()) &amp;&amp; isBlocking();</span>
<span class="line-removed">421         acceptLock.lock();</span>
<span class="line-removed">422         try {</span>
<span class="line-removed">423             boolean polled = false;</span>
<span class="line-removed">424             try {</span>
<span class="line-removed">425                 begin(true);</span>
<span class="line-removed">426                 int events = Net.poll(fd, Net.POLLIN, timeout);</span>
<span class="line-removed">427                 polled = (events != 0);</span>
<span class="line-removed">428             } finally {</span>
<span class="line-removed">429                 end(true, polled);</span>
<span class="line-removed">430             }</span>
<span class="line-removed">431             return polled;</span>
<span class="line-removed">432         } finally {</span>
<span class="line-removed">433             acceptLock.unlock();</span>
<span class="line-removed">434         }</span>
<span class="line-removed">435     }</span>
<span class="line-removed">436 </span>
437     /**
438      * Translates native poll revent set into a ready operation set
439      */
440     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
441         int intOps = ski.nioInterestOps();
442         int oldOps = ski.nioReadyOps();
443         int newOps = initialOps;
444 
445         if ((ops &amp; Net.POLLNVAL) != 0) {
446             // This should only happen if this channel is pre-closed while a
447             // selection operation is in progress
448             // ## Throw an error if this channel has not been pre-closed
449             return false;
450         }
451 
452         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
453             newOps = intOps;
454             ski.nioReadyOps(newOps);
455             return (newOps &amp; ~oldOps) != 0;
456         }
</pre>
<hr />
<pre>
491 
492     public String toString() {
493         StringBuilder sb = new StringBuilder();
494         sb.append(this.getClass().getName());
495         sb.append(&#39;[&#39;);
496         if (!isOpen()) {
497             sb.append(&quot;closed&quot;);
498         } else {
499             synchronized (stateLock) {
500                 InetSocketAddress addr = localAddress;
501                 if (addr == null) {
502                     sb.append(&quot;unbound&quot;);
503                 } else {
504                     sb.append(Net.getRevealedLocalAddressAsString(addr));
505                 }
506             }
507         }
508         sb.append(&#39;]&#39;);
509         return sb.toString();
510     }
<span class="line-removed">511 </span>
<span class="line-removed">512     /**</span>
<span class="line-removed">513      * Accept a connection on a socket.</span>
<span class="line-removed">514      *</span>
<span class="line-removed">515      * @implNote Wrap native call to allow instrumentation.</span>
<span class="line-removed">516      */</span>
<span class="line-removed">517     private int accept(FileDescriptor ssfd,</span>
<span class="line-removed">518                        FileDescriptor newfd,</span>
<span class="line-removed">519                        InetSocketAddress[] isaa)</span>
<span class="line-removed">520         throws IOException</span>
<span class="line-removed">521     {</span>
<span class="line-removed">522         return accept0(ssfd, newfd, isaa);</span>
<span class="line-removed">523     }</span>
<span class="line-removed">524 </span>
<span class="line-removed">525     // -- Native methods --</span>
<span class="line-removed">526 </span>
<span class="line-removed">527     // Accepts a new connection, setting the given file descriptor to refer to</span>
<span class="line-removed">528     // the new socket and setting isaa[0] to the socket&#39;s remote address.</span>
<span class="line-removed">529     // Returns 1 on success, or IOStatus.UNAVAILABLE (if non-blocking and no</span>
<span class="line-removed">530     // connections are pending) or IOStatus.INTERRUPTED.</span>
<span class="line-removed">531     //</span>
<span class="line-removed">532     private native int accept0(FileDescriptor ssfd,</span>
<span class="line-removed">533                                FileDescriptor newfd,</span>
<span class="line-removed">534                                InetSocketAddress[] isaa)</span>
<span class="line-removed">535         throws IOException;</span>
<span class="line-removed">536 </span>
<span class="line-removed">537     private static native void initIDs();</span>
<span class="line-removed">538 </span>
<span class="line-removed">539     static {</span>
<span class="line-removed">540         IOUtil.load();</span>
<span class="line-removed">541         initIDs();</span>
<span class="line-removed">542         nd = new SocketDispatcher();</span>
<span class="line-removed">543     }</span>
<span class="line-removed">544 </span>
545 }
</pre>
</td>
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
<span class="line-added"> 34 import java.net.SocketTimeoutException;</span>
 35 import java.net.StandardSocketOptions;
 36 import java.nio.channels.AlreadyBoundException;
 37 import java.nio.channels.AsynchronousCloseException;
 38 import java.nio.channels.ClosedChannelException;
<span class="line-added"> 39 import java.nio.channels.IllegalBlockingModeException;</span>
 40 import java.nio.channels.NotYetBoundException;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 import java.nio.channels.spi.SelectorProvider;
 45 import java.util.Collections;
 46 import java.util.HashSet;
 47 import java.util.Objects;
 48 import java.util.Set;
 49 import java.util.concurrent.locks.ReentrantLock;
 50 
 51 import sun.net.NetHooks;
 52 import sun.net.ext.ExtendedSocketOptions;
 53 
 54 /**
 55  * An implementation of ServerSocketChannels
 56  */
 57 
 58 class ServerSocketChannelImpl
 59     extends ServerSocketChannel
 60     implements SelChImpl
 61 {
 62     // Used to make native close and configure calls
<span class="line-modified"> 63     private static final NativeDispatcher nd = new SocketDispatcher();</span>
 64 
 65     // Our file descriptor
 66     private final FileDescriptor fd;
 67     private final int fdVal;
 68 
 69     // Lock held by thread currently blocked on this channel
 70     private final ReentrantLock acceptLock = new ReentrantLock();
 71 
 72     // Lock held by any thread that modifies the state fields declared below
 73     // DO NOT invoke a blocking I/O operation while holding this lock!
 74     private final Object stateLock = new Object();
 75 
 76     // -- The following fields are protected by stateLock
 77 
 78     // Channel state, increases monotonically
 79     private static final int ST_INUSE = 0;
 80     private static final int ST_CLOSING = 1;
<span class="line-modified"> 81     private static final int ST_CLOSED = 2;</span>

 82     private int state;
 83 
 84     // ID of native thread currently blocked in this channel, for signalling
 85     private long thread;
 86 
 87     // Binding
 88     private InetSocketAddress localAddress; // null =&gt; unbound
 89 
 90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 91     private boolean isReuseAddress;
 92 
 93     // Our socket adaptor, if any
 94     private ServerSocket socket;
 95 
 96     // -- End of fields protected by stateLock
 97 
 98 
<span class="line-modified"> 99     ServerSocketChannelImpl(SelectorProvider sp) {</span>
100         super(sp);
<span class="line-modified">101         this.fd = Net.serverSocket(true);</span>
102         this.fdVal = IOUtil.fdVal(fd);
103     }
104 
105     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
106         throws IOException
107     {
108         super(sp);
109         this.fd =  fd;
110         this.fdVal = IOUtil.fdVal(fd);
111         if (bound) {
112             synchronized (stateLock) {
113                 localAddress = Net.localAddress(fd);
114             }
115         }
116     }
117 
118     // @throws ClosedChannelException if channel is closed
119     private void ensureOpen() throws ClosedChannelException {
120         if (!isOpen())
121             throw new ClosedChannelException();
</pre>
<hr />
<pre>
130         }
131     }
132 
133     @Override
134     public SocketAddress getLocalAddress() throws IOException {
135         synchronized (stateLock) {
136             ensureOpen();
137             return (localAddress == null)
138                     ? null
139                     : Net.getRevealedLocalAddress(localAddress);
140         }
141     }
142 
143     @Override
144     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
145         throws IOException
146     {
147         Objects.requireNonNull(name);
148         if (!supportedOptions().contains(name))
149             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<span class="line-added">150         if (!name.type().isInstance(value))</span>
<span class="line-added">151             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">152 </span>
153         synchronized (stateLock) {
154             ensureOpen();
155 
156             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
157                 // SO_REUSEADDR emulated when using exclusive bind
158                 isReuseAddress = (Boolean)value;
159             } else {
160                 // no options that require special handling
161                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
162             }
163             return this;
164         }
165     }
166 
167     @Override
168     @SuppressWarnings(&quot;unchecked&quot;)
169     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
170         throws IOException
171     {
172         Objects.requireNonNull(name);
</pre>
<hr />
<pre>
237             ensureOpen();
238             if (localAddress == null)
239                 throw new NotYetBoundException();
240             if (blocking)
241                 thread = NativeThread.current();
242         }
243     }
244 
245     /**
246      * Marks the end of an I/O operation that may have blocked.
247      *
248      * @throws AsynchronousCloseException if the channel was closed due to this
249      * thread being interrupted on a blocking I/O operation.
250      */
251     private void end(boolean blocking, boolean completed)
252         throws AsynchronousCloseException
253     {
254         if (blocking) {
255             synchronized (stateLock) {
256                 thread = 0;

257                 if (state == ST_CLOSING) {
<span class="line-modified">258                     tryFinishClose();</span>
259                 }
260             }
261             end(completed);
262         }
263     }
264 
265     @Override
266     public SocketChannel accept() throws IOException {
<span class="line-added">267         int n = 0;</span>
<span class="line-added">268         FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-added">269         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="line-added">270 </span>
271         acceptLock.lock();
272         try {




273             boolean blocking = isBlocking();
274             try {
275                 begin(blocking);
<span class="line-modified">276                 n = Net.accept(this.fd, newfd, isaa);</span>
<span class="line-modified">277                 if (blocking) {</span>
<span class="line-modified">278                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">279                         park(Net.POLLIN);</span>
<span class="line-added">280                         n = Net.accept(this.fd, newfd, isaa);</span>
<span class="line-added">281                     }</span>
<span class="line-added">282                 }</span>
283             } finally {
284                 end(blocking, n &gt; 0);
285                 assert IOStatus.check(n);
286             }
<span class="line-added">287         } finally {</span>
<span class="line-added">288             acceptLock.unlock();</span>
<span class="line-added">289         }</span>
290 
<span class="line-modified">291         if (n &gt; 0) {</span>
<span class="line-modified">292             return finishAccept(newfd, isaa[0]);</span>
<span class="line-added">293         } else {</span>
<span class="line-added">294             return null;</span>
<span class="line-added">295         }</span>
<span class="line-added">296     }</span>
297 
<span class="line-modified">298     /**</span>
<span class="line-modified">299      * Accepts a new connection with a given timeout. This method requires the</span>
<span class="line-added">300      * channel to be configured in blocking mode.</span>
<span class="line-added">301      *</span>
<span class="line-added">302      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">303      *</span>
<span class="line-added">304      * @param nanos the timeout, in nanoseconds</span>
<span class="line-added">305      * @throws IllegalBlockingModeException if the channel is configured non-blocking</span>
<span class="line-added">306      * @throws SocketTimeoutException if the timeout expires</span>
<span class="line-added">307      */</span>
<span class="line-added">308     SocketChannel blockingAccept(long nanos) throws IOException {</span>
<span class="line-added">309         int n = 0;</span>
<span class="line-added">310         FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-added">311         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
312 
<span class="line-modified">313         acceptLock.lock();</span>
<span class="line-modified">314         try {</span>
<span class="line-added">315             // check that channel is configured blocking</span>
<span class="line-added">316             if (!isBlocking())</span>
<span class="line-added">317                 throw new IllegalBlockingModeException();</span>
318 
<span class="line-modified">319             try {</span>
<span class="line-modified">320                 begin(true);</span>
<span class="line-modified">321                 // change socket to non-blocking</span>
<span class="line-added">322                 lockedConfigureBlocking(false);</span>
323                 try {
<span class="line-modified">324                     long startNanos = System.nanoTime();</span>
<span class="line-modified">325                     n = Net.accept(fd, newfd, isaa);</span>
<span class="line-modified">326                     while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-modified">327                         long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">328                         if (remainingNanos &lt;= 0) {</span>
<span class="line-added">329                             throw new SocketTimeoutException(&quot;Accept timed out&quot;);</span>
<span class="line-added">330                         }</span>
<span class="line-added">331                         park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">332                         n = Net.accept(fd, newfd, isaa);</span>
<span class="line-added">333                     }</span>
<span class="line-added">334                 } finally {</span>
<span class="line-added">335                     // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">336                     tryLockedConfigureBlocking(true);</span>
337                 }
<span class="line-added">338             } finally {</span>
<span class="line-added">339                 end(true, n &gt; 0);</span>
340             }


341         } finally {
342             acceptLock.unlock();
343         }
<span class="line-added">344 </span>
<span class="line-added">345         assert n &gt; 0;</span>
<span class="line-added">346         return finishAccept(newfd, isaa[0]);</span>
<span class="line-added">347     }</span>
<span class="line-added">348 </span>
<span class="line-added">349     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)</span>
<span class="line-added">350         throws IOException</span>
<span class="line-added">351     {</span>
<span class="line-added">352         try {</span>
<span class="line-added">353             // newly accepted socket is initially in blocking mode</span>
<span class="line-added">354             IOUtil.configureBlocking(newfd, true);</span>
<span class="line-added">355 </span>
<span class="line-added">356             // check permitted to accept connections from the remote address</span>
<span class="line-added">357             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">358             if (sm != null) {</span>
<span class="line-added">359                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added">360             }</span>
<span class="line-added">361             return new SocketChannelImpl(provider(), newfd, isa);</span>
<span class="line-added">362         } catch (Exception e) {</span>
<span class="line-added">363             nd.close(newfd);</span>
<span class="line-added">364             throw e;</span>
<span class="line-added">365         }</span>
366     }
367 
368     @Override
369     protected void implConfigureBlocking(boolean block) throws IOException {
370         acceptLock.lock();
371         try {
<span class="line-modified">372             lockedConfigureBlocking(block);</span>



373         } finally {
374             acceptLock.unlock();
375         }
376     }
377 
378     /**
<span class="line-modified">379      * Adjust the blocking. acceptLock must already be held.</span>
<span class="line-modified">380      */</span>
<span class="line-modified">381     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-modified">382         assert acceptLock.isHeldByCurrentThread();</span>
<span class="line-modified">383         synchronized (stateLock) {</span>
<span class="line-modified">384             ensureOpen();</span>
<span class="line-added">385             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">386         }</span>
<span class="line-added">387     }</span>
<span class="line-added">388 </span>
<span class="line-added">389     /**</span>
<span class="line-added">390      * Adjusts the blocking mode if the channel is open. acceptLock must already</span>
<span class="line-added">391      * be held.</span>
392      *
<span class="line-modified">393      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-modified">394      *         the blocking mode was not adjusted because the channel is closed</span>


395      */
<span class="line-modified">396     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-modified">397         assert acceptLock.isHeldByCurrentThread();</span>
<span class="line-modified">398         synchronized (stateLock) {</span>
<span class="line-added">399             if (isOpen()) {</span>
<span class="line-added">400                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">401                 return true;</span>
<span class="line-added">402             } else {</span>
<span class="line-added">403                 return false;</span>
<span class="line-added">404             }</span>
<span class="line-added">405         }</span>
<span class="line-added">406     }</span>
407 
<span class="line-modified">408     /**</span>
<span class="line-modified">409      * Closes the socket if there are no accept in progress and the channel is</span>
<span class="line-added">410      * not registered with a Selector.</span>
<span class="line-added">411      */</span>
<span class="line-added">412     private boolean tryClose() throws IOException {</span>
<span class="line-added">413         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-added">414         if ((thread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">415             state = ST_CLOSED;</span>
<span class="line-added">416             nd.close(fd);</span>
<span class="line-added">417             return true;</span>
<span class="line-added">418         } else {</span>
<span class="line-added">419             return false;</span>
<span class="line-added">420         }</span>
<span class="line-added">421     }</span>
422 
<span class="line-modified">423     /**</span>
<span class="line-added">424      * Invokes tryClose to attempt to close the socket.</span>
<span class="line-added">425      *</span>
<span class="line-added">426      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">427      */</span>
<span class="line-added">428     private void tryFinishClose() {</span>
<span class="line-added">429         try {</span>
<span class="line-added">430             tryClose();</span>
<span class="line-added">431         } catch (IOException ignore) { }</span>
<span class="line-added">432     }</span>
<span class="line-added">433 </span>
<span class="line-added">434     /**</span>
<span class="line-added">435      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">436      *</span>
<span class="line-added">437      * If there is an accept in progress then the socket is pre-closed and the</span>
<span class="line-added">438      * accept thread is signalled, in which case the final close is deferred</span>
<span class="line-added">439      * until the accept aborts.</span>
<span class="line-added">440      */</span>
<span class="line-added">441     private void implCloseBlockingMode() throws IOException {</span>
442         synchronized (stateLock) {
443             assert state &lt; ST_CLOSING;
444             state = ST_CLOSING;
<span class="line-modified">445             if (!tryClose()) {</span>






446                 long th = thread;
447                 if (th != 0) {
448                     nd.preClose(fd);
449                     NativeThread.signal(th);









450                 }
451             }




452         }
<span class="line-added">453     }</span>
454 
<span class="line-modified">455     /**</span>
<span class="line-added">456      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">457      *</span>
<span class="line-added">458      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">459      * until the channel is flushed from all Selectors.</span>
<span class="line-added">460      */</span>
<span class="line-added">461     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="line-added">462         synchronized (stateLock) {</span>
<span class="line-added">463             assert state &lt; ST_CLOSING;</span>
<span class="line-added">464             state = ST_CLOSING;</span>
<span class="line-added">465         }</span>
<span class="line-added">466         // wait for any accept to complete before trying to close</span>
<span class="line-added">467         acceptLock.lock();</span>
<span class="line-added">468         acceptLock.unlock();</span>
469         synchronized (stateLock) {
<span class="line-modified">470             if (state == ST_CLOSING) {</span>
<span class="line-modified">471                 tryClose();</span>
<span class="line-added">472             }</span>
473         }
<span class="line-added">474     }</span>
475 
<span class="line-modified">476     /**</span>
<span class="line-modified">477      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">478      */</span>
<span class="line-modified">479     @Override</span>
<span class="line-modified">480     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">481         assert !isOpen();</span>
<span class="line-modified">482         if (isBlocking()) {</span>
<span class="line-added">483             implCloseBlockingMode();</span>
<span class="line-added">484         } else {</span>
<span class="line-added">485             implCloseNonBlockingMode();</span>
<span class="line-added">486         }</span>
487     }
488 
489     @Override
<span class="line-modified">490     public void kill() {</span>
491         synchronized (stateLock) {
<span class="line-modified">492             if (state == ST_CLOSING) {</span>
<span class="line-modified">493                 tryFinishClose();</span>

494             }
495         }
496     }
497 
498     /**
499      * Returns true if channel&#39;s socket is bound
500      */
501     boolean isBound() {
502         synchronized (stateLock) {
503             return localAddress != null;
504         }
505     }
506 
507     /**
508      * Returns the local address, or null if not bound
509      */
510     InetSocketAddress localAddress() {
511         synchronized (stateLock) {
512             return localAddress;
513         }
514     }
515 






















516     /**
517      * Translates native poll revent set into a ready operation set
518      */
519     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
520         int intOps = ski.nioInterestOps();
521         int oldOps = ski.nioReadyOps();
522         int newOps = initialOps;
523 
524         if ((ops &amp; Net.POLLNVAL) != 0) {
525             // This should only happen if this channel is pre-closed while a
526             // selection operation is in progress
527             // ## Throw an error if this channel has not been pre-closed
528             return false;
529         }
530 
531         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
532             newOps = intOps;
533             ski.nioReadyOps(newOps);
534             return (newOps &amp; ~oldOps) != 0;
535         }
</pre>
<hr />
<pre>
570 
571     public String toString() {
572         StringBuilder sb = new StringBuilder();
573         sb.append(this.getClass().getName());
574         sb.append(&#39;[&#39;);
575         if (!isOpen()) {
576             sb.append(&quot;closed&quot;);
577         } else {
578             synchronized (stateLock) {
579                 InetSocketAddress addr = localAddress;
580                 if (addr == null) {
581                     sb.append(&quot;unbound&quot;);
582                 } else {
583                     sb.append(Net.getRevealedLocalAddressAsString(addr));
584                 }
585             }
586         }
587         sb.append(&#39;]&#39;);
588         return sb.toString();
589     }


































590 }
</pre>
</td>
</tr>
</table>
<center><a href="ServerSocketAdaptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketAdaptor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSocketOutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.ByteArrayInputStream;
 29 import java.io.IOException;
 30 import java.io.OutputStream;
 31 import java.net.SocketException;
 32 import java.nio.ByteBuffer;
 33 import javax.net.ssl.SSLHandshakeException;
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLSocket}.
 37  */
 38 final class SSLSocketOutputRecord extends OutputRecord implements SSLRecord {
 39     private OutputStream deliverStream = null;
 40 
 41     SSLSocketOutputRecord(HandshakeHash handshakeHash) {
 42         this(handshakeHash, null);
 43     }
 44 
 45     SSLSocketOutputRecord(HandshakeHash handshakeHash,
 46             TransportContext tc) {
 47         super(handshakeHash, SSLCipher.SSLWriteCipher.nullTlsWriteCipher());
 48         this.tc = tc;
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
 54     void encodeAlert(byte level, byte description) throws IOException {
 55         recordLock.lock();
 56         try {
 57             if (isClosed()) {
 58                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
 59                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +
 60                         &quot;alert message: &quot; + Alert.nameOf(description));
 61                 }
 62                 return;
 63             }
 64 
 65             // use the buf of ByteArrayOutputStream
 66             int position = headerSize + writeCipher.getExplicitNonceSize();
 67             count = position;
 68 
 69             write(level);
 70             write(description);
 71             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
 72                 SSLLogger.fine(&quot;WRITE: &quot; + protocolVersion +
 73                         &quot; &quot; + ContentType.ALERT.name +
 74                         &quot;(&quot; + Alert.nameOf(description) + &quot;)&quot; +
 75                         &quot;, length = &quot; + (count - headerSize));
 76             }
 77 
 78             // Encrypt the fragment and wrap up a record.
 79             encrypt(writeCipher, ContentType.ALERT.id, headerSize);
 80 
 81             // deliver this message
 82             deliverStream.write(buf, 0, count);    // may throw IOException
 83             deliverStream.flush();                 // may throw IOException
 84 
 85             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
 86                 SSLLogger.fine(&quot;Raw write&quot;,
 87                         (new ByteArrayInputStream(buf, 0, count)));
 88             }
 89 
 90             // reset the internal buffer
 91             count = 0;
 92         } finally {
 93             recordLock.unlock();
 94         }
 95     }
 96 
 97     @Override
 98     void encodeHandshake(byte[] source,
 99             int offset, int length) throws IOException {
100         recordLock.lock();
101         try {
102             if (isClosed()) {
103                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
104                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +
105                             &quot;handshake message&quot;,
106                             ByteBuffer.wrap(source, offset, length));
107                 }
108                 return;
109             }
110 
111             if (firstMessage) {
112                 firstMessage = false;
113 
114                 if ((helloVersion == ProtocolVersion.SSL20Hello) &amp;&amp;
115                     (source[offset] == SSLHandshake.CLIENT_HELLO.id) &amp;&amp;
116                                             //  5: recode header size
117                     (source[offset + 4 + 2 + 32] == 0)) {
118                                             // V3 session ID is empty
119                                             //  4: handshake header size
120                                             //  2: client_version in ClientHello
121                                             // 32: random in ClientHello
122 
123                     ByteBuffer v2ClientHello = encodeV2ClientHello(
124                             source, (offset + 4), (length - 4));
125 
126                     // array offset is zero
127                     byte[] record = v2ClientHello.array();
128                     int limit = v2ClientHello.limit();
129                     handshakeHash.deliver(record, 2, (limit - 2));
130 
131                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
132                         SSLLogger.fine(
133                                 &quot;WRITE: SSLv2 ClientHello message&quot; +
134                                 &quot;, length = &quot; + limit);
135                     }
136 
137                     // deliver this message
138                     //
139                     // Version 2 ClientHello message should be plaintext.
140                     //
141                     // No max fragment length negotiation.
142                     deliverStream.write(record, 0, limit);
143                     deliverStream.flush();
144 
145                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
146                         SSLLogger.fine(&quot;Raw write&quot;,
147                                 (new ByteArrayInputStream(record, 0, limit)));
148                     }
149 
150                     return;
151                 }
152             }
153 
154             byte handshakeType = source[0];
155             if (handshakeHash.isHashable(handshakeType)) {
156                 handshakeHash.deliver(source, offset, length);
157             }
158 
159             int fragLimit = getFragLimit();
160             int position = headerSize + writeCipher.getExplicitNonceSize();
161             if (count == 0) {
162                 count = position;
163             }
164 
165             if ((count - position) &lt; (fragLimit - length)) {
166                 write(source, offset, length);
167                 return;
168             }
169 
170             for (int limit = (offset + length); offset &lt; limit;) {
171 
172                 int remains = (limit - offset) + (count - position);
173                 int fragLen = Math.min(fragLimit, remains);
174 
175                 // use the buf of ByteArrayOutputStream
176                 write(source, offset, fragLen);
177                 if (remains &lt; fragLimit) {
178                     return;
179                 }
180 
181                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
182                     SSLLogger.fine(
183                             &quot;WRITE: &quot; + protocolVersion +
184                             &quot; &quot; + ContentType.HANDSHAKE.name +
185                             &quot;, length = &quot; + (count - headerSize));
186                 }
187 
188                 // Encrypt the fragment and wrap up a record.
189                 encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
190 
191                 // deliver this message
192                 deliverStream.write(buf, 0, count);    // may throw IOException
193                 deliverStream.flush();                 // may throw IOException
194 
195                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
196                     SSLLogger.fine(&quot;Raw write&quot;,
197                             (new ByteArrayInputStream(buf, 0, count)));
198                 }
199 
200                 // reset the offset
201                 offset += fragLen;
202 
203                 // reset the internal buffer
204                 count = position;
205             }
206         } finally {
207             recordLock.unlock();
208         }
209     }
210 
211     @Override
212     void encodeChangeCipherSpec() throws IOException {
213         recordLock.lock();
214         try {
215             if (isClosed()) {
216                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
217                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +
218                         &quot;change_cipher_spec message&quot;);
219                 }
220                 return;
221             }
222 
223             // use the buf of ByteArrayOutputStream
224             int position = headerSize + writeCipher.getExplicitNonceSize();
225             count = position;
226 
227             write((byte)1);         // byte 1: change_cipher_spec(
228 
229             // Encrypt the fragment and wrap up a record.
230             encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);
231 
232             // deliver this message
233             deliverStream.write(buf, 0, count);        // may throw IOException
234             // deliverStream.flush();                  // flush in Finished
235 
236             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
237                 SSLLogger.fine(&quot;Raw write&quot;,
238                         (new ByteArrayInputStream(buf, 0, count)));
239             }
240 
241             // reset the internal buffer
242             count = 0;
243         } finally {
244             recordLock.unlock();
245         }
246     }
247 
248     @Override
249     public void flush() throws IOException {
250         recordLock.lock();
251         try {
252             int position = headerSize + writeCipher.getExplicitNonceSize();
253             if (count &lt;= position) {
254                 return;
255             }
256 
257             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
258                 SSLLogger.fine(
259                         &quot;WRITE: &quot; + protocolVersion +
260                         &quot; &quot; + ContentType.HANDSHAKE.name +
261                         &quot;, length = &quot; + (count - headerSize));
262             }
263 
264             // Encrypt the fragment and wrap up a record.
265             encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
266 
267             // deliver this message
268             deliverStream.write(buf, 0, count);    // may throw IOException
269             deliverStream.flush();                 // may throw IOException
270 
271             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
272                 SSLLogger.fine(&quot;Raw write&quot;,
273                         (new ByteArrayInputStream(buf, 0, count)));
274             }
275 
276             // reset the internal buffer
277             count = 0;      // DON&#39;T use position
278         } finally {
279             recordLock.unlock();
280         }
281     }
282 
283     @Override
284     void deliver(byte[] source, int offset, int length) throws IOException {
285         recordLock.lock();
286         try {
287             if (isClosed()) {
288                 throw new SocketException(
289                         &quot;Connection or outbound has been closed&quot;);
290             }
291 
292             if (writeCipher.authenticator.seqNumOverflow()) {
293                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
294                     SSLLogger.fine(
295                         &quot;sequence number extremely close to overflow &quot; +
296                         &quot;(2^64-1 packets). Closing connection.&quot;);
297                 }
298 
299                 throw new SSLHandshakeException(&quot;sequence number overflow&quot;);
300             }
301 
302             boolean isFirstRecordOfThePayload = true;
303             for (int limit = (offset + length); offset &lt; limit;) {
304                 int fragLen;
305                 if (packetSize &gt; 0) {
306                     fragLen = Math.min(maxRecordSize, packetSize);
307                     fragLen = writeCipher.calculateFragmentSize(
308                             fragLen, headerSize);
309 
310                     fragLen = Math.min(fragLen, Record.maxDataSize);
311                 } else {
312                     fragLen = Record.maxDataSize;
313                 }
314 
315                 // Calculate more impact, for example TLS 1.3 padding.
316                 fragLen = calculateFragmentSize(fragLen);
317 
318                 if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {
319                     fragLen = 1;
320                     isFirstRecordOfThePayload = false;
321                 } else {
322                     fragLen = Math.min(fragLen, (limit - offset));
323                 }
324 
325                 // use the buf of ByteArrayOutputStream
326                 int position = headerSize + writeCipher.getExplicitNonceSize();
327                 count = position;
328                 write(source, offset, fragLen);
329 
330                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
331                     SSLLogger.fine(
332                             &quot;WRITE: &quot; + protocolVersion +
333                             &quot; &quot; + ContentType.APPLICATION_DATA.name +
334                             &quot;, length = &quot; + (count - position));
335                 }
336 
337                 // Encrypt the fragment and wrap up a record.
338                 encrypt(writeCipher,
339                         ContentType.APPLICATION_DATA.id, headerSize);
340 
341                 // deliver this message
342                 deliverStream.write(buf, 0, count);    // may throw IOException
343                 deliverStream.flush();                 // may throw IOException
344 
345                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
346                     SSLLogger.fine(&quot;Raw write&quot;,
347                             (new ByteArrayInputStream(buf, 0, count)));
348                 }
349 
350                 // reset the internal buffer
351                 count = 0;
352 
353                 if (isFirstAppOutputRecord) {
354                     isFirstAppOutputRecord = false;
355                 }
356 
357                 offset += fragLen;
358             }
359         } finally {
360             recordLock.unlock();
361         }
362     }
363 
364     @Override
365     void setDeliverStream(OutputStream outputStream) {
366         recordLock.lock();
367         try {
368             this.deliverStream = outputStream;
369         } finally {
370             recordLock.unlock();
371         }
372     }
373 
374     /*
375      * Need to split the payload except the following cases:
376      *
377      * 1. protocol version is TLS 1.1 or later;
378      * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
379      * 3. the payload is the first application record of a freshly
380      *    negotiated TLS session.
381      * 4. the CBC protection is disabled;
382      *
383      * By default, we counter chosen plaintext issues on CBC mode
384      * ciphersuites in SSLv3/TLS1.0 by sending one byte of application
385      * data in the first record of every payload, and the rest in
386      * subsequent record(s). Note that the issues have been solved in
387      * TLS 1.1 or later.
388      *
389      * It is not necessary to split the very first application record of
390      * a freshly negotiated TLS session, as there is no previous
391      * application data to guess.  To improve compatibility, we will not
392      * split such records.
393      *
394      * This avoids issues in the outbound direction.  For a full fix,
395      * the peer must have similar protections.
396      */
397     private boolean needToSplitPayload() {
398         return (!protocolVersion.useTLS11PlusSpec()) &amp;&amp;
399                 writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;
400                 Record.enableCBCProtection;
401     }
402 
403     private int getFragLimit() {
404         int fragLimit;
405         if (packetSize &gt; 0) {
406             fragLimit = Math.min(maxRecordSize, packetSize);
407             fragLimit =
408                     writeCipher.calculateFragmentSize(fragLimit, headerSize);
409 
410             fragLimit = Math.min(fragLimit, Record.maxDataSize);
411         } else {
412             fragLimit = Record.maxDataSize;
413         }
414 
415         // Calculate more impact, for example TLS 1.3 padding.
416         fragLimit = calculateFragmentSize(fragLimit);
417 
418         return fragLimit;
419     }
420 }
    </pre>
  </body>
</html>
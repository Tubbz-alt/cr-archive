<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /**
  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.util.Date;
 31 
 32 /**
 33  * Represents a single DER-encoded value.  DER encoding rules are a subset
 34  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 35  * (&quot;Definite&quot; encoding) to encode any given value.
 36  *
 37  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 38  * class represents such tagged values as they have been read (or constructed),
 39  * and provides structured access to the encoded data.
 40  *
 41  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 42  * data encodings which are defined.  That subset is sufficient for parsing
 43  * most X.509 certificates, and working with selected additional formats
 44  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 45  *
 46  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 47  * and RFC 5280, section 8, we assume that this kind of string will contain
 48  * ISO-8859-1 characters only.
 49  *
 50  *
 51  * @author David Brownell
 52  * @author Amit Kapoor
 53  * @author Hemma Prafullchandra
 54  */
 55 public class DerValue {
 56     /** The tag class types */
 57     public static final byte TAG_UNIVERSAL = (byte)0x000;
 58     public static final byte TAG_APPLICATION = (byte)0x040;
 59     public static final byte TAG_CONTEXT = (byte)0x080;
 60     public static final byte TAG_PRIVATE = (byte)0x0c0;
 61 
 62     /** The DER tag of the value; one of the tag_ constants. */
 63     public byte                 tag;
 64 
 65     protected DerInputBuffer    buffer;
 66 
 67     /**
 68      * The DER-encoded data of the value, never null
 69      */
 70     public final DerInputStream data;
 71 
 72     private int                 length;
 73 
 74     /*
 75      * The type starts at the first byte of the encoding, and
 76      * is one of these tag_* values.  That may be all the type
 77      * data that is needed.
 78      */
 79 
 80     /*
 81      * These tags are the &quot;universal&quot; tags ... they mean the same
 82      * in all contexts.  (Mask with 0x1f -- five bits.)
 83      */
 84 
 85     /** Tag value indicating an ASN.1 &quot;BOOLEAN&quot; value. */
 86     public static final byte    tag_Boolean = 0x01;
 87 
 88     /** Tag value indicating an ASN.1 &quot;INTEGER&quot; value. */
 89     public static final byte    tag_Integer = 0x02;
 90 
 91     /** Tag value indicating an ASN.1 &quot;BIT STRING&quot; value. */
 92     public static final byte    tag_BitString = 0x03;
 93 
 94     /** Tag value indicating an ASN.1 &quot;OCTET STRING&quot; value. */
 95     public static final byte    tag_OctetString = 0x04;
 96 
 97     /** Tag value indicating an ASN.1 &quot;NULL&quot; value. */
 98     public static final byte    tag_Null = 0x05;
 99 
100     /** Tag value indicating an ASN.1 &quot;OBJECT IDENTIFIER&quot; value. */
101     public static final byte    tag_ObjectId = 0x06;
102 
103     /** Tag value including an ASN.1 &quot;ENUMERATED&quot; value */
104     public static final byte    tag_Enumerated = 0x0A;
105 
106     /** Tag value indicating an ASN.1 &quot;UTF8String&quot; value. */
107     public static final byte    tag_UTF8String = 0x0C;
108 
109     /** Tag value including a &quot;printable&quot; string */
110     public static final byte    tag_PrintableString = 0x13;
111 
112     /** Tag value including a &quot;teletype&quot; string */
113     public static final byte    tag_T61String = 0x14;
114 
115     /** Tag value including an ASCII string */
116     public static final byte    tag_IA5String = 0x16;
117 
118     /** Tag value indicating an ASN.1 &quot;UTCTime&quot; value. */
119     public static final byte    tag_UtcTime = 0x17;
120 
121     /** Tag value indicating an ASN.1 &quot;GeneralizedTime&quot; value. */
122     public static final byte    tag_GeneralizedTime = 0x18;
123 
124     /** Tag value indicating an ASN.1 &quot;GenerallString&quot; value. */
125     public static final byte    tag_GeneralString = 0x1B;
126 
127     /** Tag value indicating an ASN.1 &quot;UniversalString&quot; value. */
128     public static final byte    tag_UniversalString = 0x1C;
129 
130     /** Tag value indicating an ASN.1 &quot;BMPString&quot; value. */
131     public static final byte    tag_BMPString = 0x1E;
132 
133     // CONSTRUCTED seq/set
134 
135     /**
136      * Tag value indicating an ASN.1
137      * &quot;SEQUENCE&quot; (zero to N elements, order is significant).
138      */
139     public static final byte    tag_Sequence = 0x30;
140 
141     /**
142      * Tag value indicating an ASN.1
143      * &quot;SEQUENCE OF&quot; (one to N elements, order is significant).
144      */
145     public static final byte    tag_SequenceOf = 0x30;
146 
147     /**
148      * Tag value indicating an ASN.1
149      * &quot;SET&quot; (zero to N members, order does not matter).
150      */
151     public static final byte    tag_Set = 0x31;
152 
153     /**
154      * Tag value indicating an ASN.1
155      * &quot;SET OF&quot; (one to N members, order does not matter).
156      */
157     public static final byte    tag_SetOf = 0x31;
158 
159     /*
160      * These values are the high order bits for the other kinds of tags.
161      */
162 
163     /**
164      * Returns true if the tag class is UNIVERSAL.
165      */
166     public boolean isUniversal()      { return ((tag &amp; 0x0c0) == 0x000); }
167 
168     /**
169      * Returns true if the tag class is APPLICATION.
170      */
171     public boolean isApplication()    { return ((tag &amp; 0x0c0) == 0x040); }
172 
173     /**
174      * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.
175      * This is associated with the ASN.1 &quot;DEFINED BY&quot; syntax.
176      */
177     public boolean isContextSpecific() { return ((tag &amp; 0x0c0) == 0x080); }
178 
179     /**
180      * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.
181      */
182     public boolean isContextSpecific(byte cntxtTag) {
183         if (!isContextSpecific()) {
184             return false;
185         }
186         return ((tag &amp; 0x01f) == cntxtTag);
187     }
188 
189     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
190 
191     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
192     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
193 
194     /**
195      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
196      */
197     public boolean isConstructed(byte constructedTag) {
198         if (!isConstructed()) {
199             return false;
200         }
201         return ((tag &amp; 0x01f) == constructedTag);
202     }
203 
204     /**
205      * Creates a PrintableString or UTF8string DER value from a string
206      */
207     public DerValue(String value) throws IOException {
208         boolean isPrintableString = true;
209         for (int i = 0; i &lt; value.length(); i++) {
210             if (!isPrintableStringChar(value.charAt(i))) {
211                 isPrintableString = false;
212                 break;
213             }
214         }
215 
216         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
217     }
218 
219     /**
220      * Creates a string type DER value from a String object
221      * @param stringTag the tag for the DER value to create
222      * @param value the String object to use for the DER value
223      */
224     public DerValue(byte stringTag, String value) throws IOException {
225         data = init(stringTag, value);
226     }
227 
228     // Creates a DerValue from a tag and some DER-encoded data w/ additional
229     // arg to control whether DER checks are enforced.
230     DerValue(byte tag, byte[] data, boolean allowBER) {
231         this.tag = tag;
232         buffer = new DerInputBuffer(data.clone(), allowBER);
233         length = data.length;
234         this.data = new DerInputStream(buffer);
235         this.data.mark(Integer.MAX_VALUE);
236     }
237 
238     /**
239      * Creates a DerValue from a tag and some DER-encoded data.
240      *
241      * @param tag the DER type tag
242      * @param data the DER-encoded data
243      */
244     public DerValue(byte tag, byte[] data) {
245         this(tag, data, true);
246     }
247 
248     /*
249      * package private
250      */
251     DerValue(DerInputBuffer in) throws IOException {
252 
253         // XXX must also parse BER-encoded constructed
254         // values such as sequences, sets...
255         tag = (byte)in.read();
256         byte lenByte = (byte)in.read();
257         length = DerInputStream.getLength(lenByte, in);
258         if (length == -1) {  // indefinite length encoding found
259             DerInputBuffer inbuf = in.dup();
260             int readLen = inbuf.available();
261             int offset = 2;     // for tag and length bytes
262             byte[] indefData = new byte[readLen + offset];
263             indefData[0] = tag;
264             indefData[1] = lenByte;
265             DataInputStream dis = new DataInputStream(inbuf);
266             dis.readFully(indefData, offset, readLen);
267             dis.close();
268             DerIndefLenConverter derIn = new DerIndefLenConverter();
269             inbuf = new DerInputBuffer(derIn.convert(indefData), in.allowBER);
270             if (tag != inbuf.read())
271                 throw new IOException
272                         (&quot;Indefinite length encoding not supported&quot;);
273             length = DerInputStream.getDefiniteLength(inbuf);
274             buffer = inbuf.dup();
275             buffer.truncate(length);
276             data = new DerInputStream(buffer);
277             // indefinite form is encoded by sending a length field with a
278             // length of 0. - i.e. [1000|0000].
279             // the object is ended by sending two zero bytes.
280             in.skip(length + offset);
281         } else {
282 
283             buffer = in.dup();
284             buffer.truncate(length);
285             data = new DerInputStream(buffer);
286 
287             in.skip(length);
288         }
289     }
290 
291     // Get an ASN.1/DER encoded datum from a buffer w/ additional
292     // arg to control whether DER checks are enforced.
293     DerValue(byte[] buf, boolean allowBER) throws IOException {
294         data = init(true, new ByteArrayInputStream(buf), allowBER);
295     }
296 
297     /**
298      * Get an ASN.1/DER encoded datum from a buffer.  The
299      * entire buffer must hold exactly one datum, including
300      * its tag and length.
301      *
302      * @param buf buffer holding a single DER-encoded datum.
303      */
304     public DerValue(byte[] buf) throws IOException {
305         this(buf, true);
306     }
307 
308     // Get an ASN.1/DER encoded datum from part of a buffer w/ additional
309     // arg to control whether DER checks are enforced.
310     DerValue(byte[] buf, int offset, int len, boolean allowBER)
311         throws IOException {
312         data = init(true, new ByteArrayInputStream(buf, offset, len), allowBER);
313     }
314 
315     /**
316      * Get an ASN.1/DER encoded datum from part of a buffer.
317      * That part of the buffer must hold exactly one datum, including
318      * its tag and length.
319      *
320      * @param buf the buffer
321      * @param offset start point of the single DER-encoded dataum
322      * @param len how many bytes are in the encoded datum
323      */
324     public DerValue(byte[] buf, int offset, int len) throws IOException {
325         this(buf, offset, len, true);
326     }
327 
328     // Get an ASN1/DER encoded datum from an input stream w/ additional
329     // arg to control whether DER checks are enforced.
330     DerValue(InputStream in, boolean allowBER) throws IOException {
331         data = init(false, in, allowBER);
332     }
333 
334     /**
335      * Get an ASN1/DER encoded datum from an input stream.  The
336      * stream may have additional data following the encoded datum.
337      * In case of indefinite length encoded datum, the input stream
338      * must hold only one datum.
339      *
340      * @param in the input stream holding a single DER datum,
341      *  which may be followed by additional data
342      */
343     public DerValue(InputStream in) throws IOException {
344         this(in, true);
345     }
346 
347     private DerInputStream init(byte stringTag, String value)
348         throws IOException {
349         String enc = null;
350 
351         tag = stringTag;
352 
353         switch (stringTag) {
354         case tag_PrintableString:
355         case tag_IA5String:
356         case tag_GeneralString:
357             enc = &quot;ASCII&quot;;
358             break;
359         case tag_T61String:
360             enc = &quot;ISO-8859-1&quot;;
361             break;
362         case tag_BMPString:
363             enc = &quot;UnicodeBigUnmarked&quot;;
364             break;
365         case tag_UTF8String:
366             enc = &quot;UTF8&quot;;
367             break;
368             // TBD: Need encoder for UniversalString before it can
369             // be handled.
370         default:
371             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
372         }
373 
374         byte[] buf = value.getBytes(enc);
375         length = buf.length;
376         buffer = new DerInputBuffer(buf, true);
377         DerInputStream result = new DerInputStream(buffer);
378         result.mark(Integer.MAX_VALUE);
379         return result;
380     }
381 
382     /*
383      * helper routine
384      */
385     private DerInputStream init(boolean fullyBuffered, InputStream in,
386         boolean allowBER) throws IOException {
387 
388         tag = (byte)in.read();
389         byte lenByte = (byte)in.read();
390         length = DerInputStream.getLength(lenByte, in);
391         if (length == -1) { // indefinite length encoding found
392             int readLen = in.available();
393             int offset = 2;     // for tag and length bytes
394             byte[] indefData = new byte[readLen + offset];
395             indefData[0] = tag;
396             indefData[1] = lenByte;
397             DataInputStream dis = new DataInputStream(in);
398             dis.readFully(indefData, offset, readLen);
399             dis.close();
400             DerIndefLenConverter derIn = new DerIndefLenConverter();
401             in = new ByteArrayInputStream(derIn.convert(indefData));
402             if (tag != in.read())
403                 throw new IOException
404                         (&quot;Indefinite length encoding not supported&quot;);
405             length = DerInputStream.getDefiniteLength(in);
406         }
407 
408         if (fullyBuffered &amp;&amp; in.available() != length)
409             throw new IOException(&quot;extra data given to DerValue constructor&quot;);
410 
411         byte[] bytes = IOUtils.readFully(in, length, true);
412 
413         buffer = new DerInputBuffer(bytes, allowBER);
414         return new DerInputStream(buffer);
415     }
416 
417     /**
418      * Encode an ASN1/DER encoded datum onto a DER output stream.
419      */
420     public void encode(DerOutputStream out)
421     throws IOException {
422         out.write(tag);
423         out.putLength(length);
424         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
425         if (length &gt; 0) {
426             byte[] value = new byte[length];
427             // always synchronized on data
428             synchronized (data) {
429                 buffer.reset();
430                 if (buffer.read(value) != length) {
431                     throw new IOException(&quot;short DER value read (encode)&quot;);
432                 }
433                 out.write(value);
434             }
435         }
436     }
437 
438     public final DerInputStream getData() {
439         return data;
440     }
441 
442     public final byte getTag() {
443         return tag;
444     }
445 
446     /**
447      * Returns an ASN.1 BOOLEAN
448      *
449      * @return the boolean held in this DER value
450      */
451     public boolean getBoolean() throws IOException {
452         if (tag != tag_Boolean) {
453             throw new IOException(&quot;DerValue.getBoolean, not a BOOLEAN &quot; + tag);
454         }
455         if (length != 1) {
456             throw new IOException(&quot;DerValue.getBoolean, invalid length &quot;
457                                         + length);
458         }
459         if (buffer.read() != 0) {
460             return true;
461         }
462         return false;
463     }
464 
465     /**
466      * Returns an ASN.1 OBJECT IDENTIFIER.
467      *
468      * @return the OID held in this DER value
469      */
470     public ObjectIdentifier getOID() throws IOException {
471         if (tag != tag_ObjectId)
472             throw new IOException(&quot;DerValue.getOID, not an OID &quot; + tag);
473         return new ObjectIdentifier(buffer);
474     }
475 
476     private byte[] append(byte[] a, byte[] b) {
477         if (a == null)
478             return b;
479 
480         byte[] ret = new byte[a.length + b.length];
481         System.arraycopy(a, 0, ret, 0, a.length);
482         System.arraycopy(b, 0, ret, a.length, b.length);
483 
484         return ret;
485     }
486 
487     /**
488      * Returns an ASN.1 OCTET STRING
489      *
490      * @return the octet string held in this DER value
491      */
492     public byte[] getOctetString() throws IOException {
493 
494         if (tag != tag_OctetString &amp;&amp; !isConstructed(tag_OctetString)) {
495             throw new IOException(
496                 &quot;DerValue.getOctetString, not an Octet String: &quot; + tag);
497         }
498         // Note: do not attempt to call buffer.read(bytes) at all. There&#39;s a
499         // known bug that it returns -1 instead of 0.
500         if (length == 0) {
501             return new byte[0];
502         }
503 
504         // Only allocate the array if there are enough bytes available.
505         // This only works for ByteArrayInputStream.
506         // The assignment below ensures that buffer has the required type.
507         ByteArrayInputStream arrayInput = buffer;
508         if (arrayInput.available() &lt; length) {
509             throw new IOException(&quot;short read on DerValue buffer&quot;);
510         }
511         byte[] bytes = new byte[length];
512         arrayInput.read(bytes);
513 
514         if (isConstructed()) {
515             DerInputStream in = new DerInputStream(bytes, 0, bytes.length,
516                 buffer.allowBER);
517             bytes = null;
518             while (in.available() != 0) {
519                 bytes = append(bytes, in.getOctetString());
520             }
521         }
522         return bytes;
523     }
524 
525     /**
526      * Returns an ASN.1 INTEGER value as an integer.
527      *
528      * @return the integer held in this DER value.
529      */
530     public int getInteger() throws IOException {
531         if (tag != tag_Integer) {
532             throw new IOException(&quot;DerValue.getInteger, not an int &quot; + tag);
533         }
534         return buffer.getInteger(data.available());
535     }
536 
537     /**
538      * Returns an ASN.1 INTEGER value as a BigInteger.
539      *
540      * @return the integer held in this DER value as a BigInteger.
541      */
542     public BigInteger getBigInteger() throws IOException {
543         if (tag != tag_Integer)
544             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
545         return buffer.getBigInteger(data.available(), false);
546     }
547 
548     /**
549      * Returns an ASN.1 INTEGER value as a positive BigInteger.
550      * This is just to deal with implementations that incorrectly encode
551      * some values as negative.
552      *
553      * @return the integer held in this DER value as a BigInteger.
554      */
555     public BigInteger getPositiveBigInteger() throws IOException {
556         if (tag != tag_Integer)
557             throw new IOException(&quot;DerValue.getBigInteger, not an int &quot; + tag);
558         return buffer.getBigInteger(data.available(), true);
559     }
560 
561     /**
562      * Returns an ASN.1 ENUMERATED value.
563      *
564      * @return the integer held in this DER value.
565      */
566     public int getEnumerated() throws IOException {
567         if (tag != tag_Enumerated) {
568             throw new IOException(&quot;DerValue.getEnumerated, incorrect tag: &quot;
569                                   + tag);
570         }
571         return buffer.getInteger(data.available());
572     }
573 
574     /**
575      * Returns an ASN.1 BIT STRING value.  The bit string must be byte-aligned.
576      *
577      * @return the bit string held in this value
578      */
579     public byte[] getBitString() throws IOException {
580         if (tag != tag_BitString)
581             throw new IOException(
582                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
583 
584         return buffer.getBitString();
585     }
586 
587     /**
588      * Returns an ASN.1 BIT STRING value that need not be byte-aligned.
589      *
590      * @return a BitArray representing the bit string held in this value
591      */
592     public BitArray getUnalignedBitString() throws IOException {
593         if (tag != tag_BitString)
594             throw new IOException(
595                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
596 
597         return buffer.getUnalignedBitString();
598     }
599 
600     /**
601      * Returns the name component as a Java string, regardless of its
602      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
603      */
604     // TBD: Need encoder for UniversalString before it can be handled.
605     public String getAsString() throws IOException {
606         if (tag == tag_UTF8String)
607             return getUTF8String();
608         else if (tag == tag_PrintableString)
609             return getPrintableString();
610         else if (tag == tag_T61String)
611             return getT61String();
612         else if (tag == tag_IA5String)
613             return getIA5String();
614         /*
615           else if (tag == tag_UniversalString)
616           return getUniversalString();
617         */
618         else if (tag == tag_BMPString)
619             return getBMPString();
620         else if (tag == tag_GeneralString)
621             return getGeneralString();
622         else
623             return null;
624     }
625 
626     /**
627      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
628      * based on the parameter.  The bit string must be byte-aligned.
629      *
630      * @param tagImplicit if true, the tag is assumed implicit.
631      * @return the bit string held in this value
632      */
633     public byte[] getBitString(boolean tagImplicit) throws IOException {
634         if (!tagImplicit) {
635             if (tag != tag_BitString)
636                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
637                                        + tag);
638             }
639         return buffer.getBitString();
640     }
641 
642     /**
643      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
644      * based on the parameter.  The bit string need not be byte-aligned.
645      *
646      * @param tagImplicit if true, the tag is assumed implicit.
647      * @return the bit string held in this value
648      */
649     public BitArray getUnalignedBitString(boolean tagImplicit)
650     throws IOException {
651         if (!tagImplicit) {
652             if (tag != tag_BitString)
653                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
654                                        + tag);
655             }
656         return buffer.getUnalignedBitString();
657     }
658 
659     /**
660      * Helper routine to return all the bytes contained in the
661      * DerInputStream associated with this object.
662      */
663     public byte[] getDataBytes() throws IOException {
664         byte[] retVal = new byte[length];
665         synchronized (data) {
666             data.reset();
667             data.getBytes(retVal);
668         }
669         return retVal;
670     }
671 
672     /**
673      * Returns an ASN.1 STRING value
674      *
675      * @return the printable string held in this value
676      */
677     public String getPrintableString()
678     throws IOException {
679         if (tag != tag_PrintableString)
680             throw new IOException(
681                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
682 
683         return new String(getDataBytes(), &quot;ASCII&quot;);
684     }
685 
686     /**
687      * Returns an ASN.1 T61 (Teletype) STRING value
688      *
689      * @return the teletype string held in this value
690      */
691     public String getT61String() throws IOException {
692         if (tag != tag_T61String)
693             throw new IOException(
694                 &quot;DerValue.getT61String, not T61 &quot; + tag);
695 
696         return new String(getDataBytes(), &quot;ISO-8859-1&quot;);
697     }
698 
699     /**
700      * Returns an ASN.1 IA5 (ASCII) STRING value
701      *
702      * @return the ASCII string held in this value
703      */
704     public String getIA5String() throws IOException {
705         if (tag != tag_IA5String)
706             throw new IOException(
707                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
708 
709         return new String(getDataBytes(), &quot;ASCII&quot;);
710     }
711 
712     /**
713      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
714      *
715      * @return a string corresponding to the encoded BMPString held in
716      * this value
717      */
718     public String getBMPString() throws IOException {
719         if (tag != tag_BMPString)
720             throw new IOException(
721                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
722 
723         // BMPString is the same as Unicode in big endian, unmarked
724         // format.
725         return new String(getDataBytes(), &quot;UnicodeBigUnmarked&quot;);
726     }
727 
728     /**
729      * Returns the ASN.1 UTF-8 STRING value as a Java String.
730      *
731      * @return a string corresponding to the encoded UTF8String held in
732      * this value
733      */
734     public String getUTF8String() throws IOException {
735         if (tag != tag_UTF8String)
736             throw new IOException(
737                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
738 
739         return new String(getDataBytes(), &quot;UTF8&quot;);
740     }
741 
742     /**
743      * Returns the ASN.1 GENERAL STRING value as a Java String.
744      *
745      * @return a string corresponding to the encoded GeneralString held in
746      * this value
747      */
748     public String getGeneralString() throws IOException {
749         if (tag != tag_GeneralString)
750             throw new IOException(
751                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
752 
753         return new String(getDataBytes(), &quot;ASCII&quot;);
754     }
755 
756     /**
757      * Returns a Date if the DerValue is UtcTime.
758      *
759      * @return the Date held in this DER value
760      */
761     public Date getUTCTime() throws IOException {
762         if (tag != tag_UtcTime) {
763             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
764         }
765         return buffer.getUTCTime(data.available());
766     }
767 
768     /**
769      * Returns a Date if the DerValue is GeneralizedTime.
770      *
771      * @return the Date held in this DER value
772      */
773     public Date getGeneralizedTime() throws IOException {
774         if (tag != tag_GeneralizedTime) {
775             throw new IOException(
776                 &quot;DerValue.getGeneralizedTime, not a GeneralizedTime: &quot; + tag);
777         }
778         return buffer.getGeneralizedTime(data.available());
779     }
780 
781     /**
782      * Bitwise equality comparison.  DER encoded values have a single
783      * encoding, so that bitwise equality of the encoded values is an
784      * efficient way to establish equivalence of the unencoded values.
785      *
786      * @param o the object being compared with this one
787      */
788     @Override
789     public boolean equals(Object o) {
790         if (this == o) {
791             return true;
792         }
793         if (!(o instanceof DerValue)) {
794             return false;
795         }
796         DerValue other = (DerValue) o;
797         if (tag != other.tag) {
798             return false;
799         }
800         if (data == other.data) {
801             return true;
802         }
803 
804         // make sure the order of lock is always consistent to avoid a deadlock
805         return (System.identityHashCode(this.data)
806                 &gt; System.identityHashCode(other.data)) ?
807                 doEquals(this, other):
808                 doEquals(other, this);
809     }
810 
811     /**
812      * Helper for public method equals()
813      */
814     private static boolean doEquals(DerValue d1, DerValue d2) {
815         synchronized (d1.data) {
816             synchronized (d2.data) {
817                 d1.data.reset();
818                 d2.data.reset();
819                 return d1.buffer.equals(d2.buffer);
820             }
821         }
822     }
823 
824     /**
825      * Returns a printable representation of the value.
826      *
827      * @return printable representation of the value
828      */
829     @Override
830     public String toString() {
831         try {
832 
833             String str = getAsString();
834             if (str != null)
835                 return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
836             if (tag == tag_Null)
837                 return &quot;[DerValue, null]&quot;;
838             if (tag == tag_ObjectId)
839                 return &quot;OID.&quot; + getOID();
840 
841             // integers
842             else
843                 return &quot;[DerValue, tag = &quot; + tag
844                         + &quot;, length = &quot; + length + &quot;]&quot;;
845         } catch (IOException e) {
846             throw new IllegalArgumentException(&quot;misformatted DER value&quot;);
847         }
848     }
849 
850     /**
851      * Returns a DER-encoded value, such that if it&#39;s passed to the
852      * DerValue constructor, a value equivalent to &quot;this&quot; is returned.
853      *
854      * @return DER-encoded value, including tag and length.
855      */
856     public byte[] toByteArray() throws IOException {
857         DerOutputStream out = new DerOutputStream();
858 
859         encode(out);
860         data.reset();
861         return out.toByteArray();
862     }
863 
864     /**
865      * For &quot;set&quot; and &quot;sequence&quot; types, this function may be used
866      * to return a DER stream of the members of the set or sequence.
867      * This operation is not supported for primitive types such as
868      * integers or bit strings.
869      */
870     public DerInputStream toDerInputStream() throws IOException {
871         if (tag == tag_Sequence || tag == tag_Set)
872             return new DerInputStream(buffer);
873         throw new IOException(&quot;toDerInputStream rejects tag type &quot; + tag);
874     }
875 
876     /**
877      * Get the length of the encoded value.
878      */
879     public int length() {
880         return length;
881     }
882 
883     /**
884      * Determine if a character is one of the permissible characters for
885      * PrintableString:
886      * A-Z, a-z, 0-9, space, apostrophe (39), left and right parentheses,
887      * plus sign, comma, hyphen, period, slash, colon, equals sign,
888      * and question mark.
889      *
890      * Characters that are *not* allowed in PrintableString include
891      * exclamation point, quotation mark, number sign, dollar sign,
892      * percent sign, ampersand, asterisk, semicolon, less than sign,
893      * greater than sign, at sign, left and right square brackets,
894      * backslash, circumflex (94), underscore, back quote (96),
895      * left and right curly brackets, vertical line, tilde,
896      * and the control codes (0-31 and 127).
897      *
898      * This list is based on X.680 (the ASN.1 spec).
899      */
900     public static boolean isPrintableStringChar(char ch) {
901         if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
902             (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
903             return true;
904         } else {
905             switch (ch) {
906                 case &#39; &#39;:       /* space */
907                 case &#39;\&#39;&#39;:      /* apostrophe */
908                 case &#39;(&#39;:       /* left paren */
909                 case &#39;)&#39;:       /* right paren */
910                 case &#39;+&#39;:       /* plus */
911                 case &#39;,&#39;:       /* comma */
912                 case &#39;-&#39;:       /* hyphen */
913                 case &#39;.&#39;:       /* period */
914                 case &#39;/&#39;:       /* slash */
915                 case &#39;:&#39;:       /* colon */
916                 case &#39;=&#39;:       /* equals */
917                 case &#39;?&#39;:       /* question mark */
918                     return true;
919                 default:
920                     return false;
921             }
922         }
923     }
924 
925     /**
926      * Create the tag of the attribute.
927      *
928      * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,
929      *               APPLICATION or PRIVATE
930      * @param form if true, the value is constructed, otherwise it
931      * is primitive.
932      * @param val the tag value
933      */
934     public static byte createTag(byte tagClass, boolean form, byte val) {
935         byte tag = (byte)(tagClass | val);
936         if (form) {
937             tag |= (byte)0x20;
938         }
939         return (tag);
940     }
941 
942     /**
943      * Set the tag of the attribute. Commonly used to reset the
944      * tag value used for IMPLICIT encodings.
945      *
946      * @param tag the tag value
947      */
948     public void resetTag(byte tag) {
949         this.tag = tag;
950     }
951 
952     /**
953      * Returns a hashcode for this DerValue.
954      *
955      * @return a hashcode for this DerValue.
956      */
957     @Override
958     public int hashCode() {
959         return toString().hashCode();
960     }
961 }
    </pre>
  </body>
</html>
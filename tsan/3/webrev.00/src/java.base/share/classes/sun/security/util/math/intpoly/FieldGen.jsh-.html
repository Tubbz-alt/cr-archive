<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/util/math/intpoly/FieldGen.jsh</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 /*
 26  * This file is used to generated optimized finite field implementations.
 27  * Required settings are included in the file. To generate, use jshell:
 28  * jshell &lt; FieldGen.jsh
 29  */
 30 
 31 import java.io.*;
 32 import java.math.BigInteger;
 33 import java.nio.file.Files;
 34 import java.nio.file.Paths;
 35 import java.util.*;
 36 
 37 public class FieldGen {
 38 
 39     static FieldParams Curve25519 = new FieldParams(&quot;IntegerPolynomial25519&quot;, 26, 10, 1, 255,
 40     Arrays.asList(
 41     new Term(0, -19)
 42     ),
 43     Curve25519CrSequence(), simpleSmallCrSequence(10)
 44     );
 45 
 46     private static List&lt;CarryReduce&gt; Curve25519CrSequence() {
 47         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
 48 
 49         // reduce(7,2)
 50         result.add(new Reduce(17));
 51         result.add(new Reduce(18));
 52 
 53         // carry(8,2)
 54         result.add(new Carry(8));
 55         result.add(new Carry(9));
 56 
 57         // reduce(0,7)
 58         for (int i = 10; i &lt; 17; i++) {
 59             result.add(new Reduce(i));
 60         }
 61 
 62         // carry(0,9)
 63         result.addAll(fullCarry(10));
 64 
 65         return result;
 66     }
 67 
 68     static FieldParams Curve448 = new FieldParams(&quot;IntegerPolynomial448&quot;, 28, 16, 1, 448,
 69     Arrays.asList(
 70     new Term(224, -1),
 71     new Term(0, -1)
 72     ),
 73     Curve448CrSequence(), simpleSmallCrSequence(16)
 74     );
 75 
 76     private static List&lt;CarryReduce&gt; Curve448CrSequence() {
 77         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
 78 
 79         // reduce(8, 7)
 80         for (int i = 24; i &lt; 31; i++) {
 81             result.add(new Reduce(i));
 82         }
 83         // reduce(4, 4)
 84         for (int i = 20; i &lt; 24; i++) {
 85             result.add(new Reduce(i));
 86         }
 87 
 88         //carry(14, 2)
 89         result.add(new Carry(14));
 90         result.add(new Carry(15));
 91 
 92         // reduce(0, 4)
 93         for (int i = 16; i &lt; 20; i++) {
 94             result.add(new Reduce(i));
 95         }
 96 
 97         // carry(0, 15)
 98         result.addAll(fullCarry(16));
 99 
100         return result;
101     }
102 
103     static FieldParams P256 = new FieldParams(&quot;IntegerPolynomialP256&quot;, 26, 10, 2, 256,
104     Arrays.asList(
105     new Term(224, -1),
106     new Term(192, 1),
107     new Term(96, 1),
108     new Term(0, -1)
109     ),
110     P256CrSequence(), simpleSmallCrSequence(10)
111     );
112 
113     private static List&lt;CarryReduce&gt; P256CrSequence() {
114         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
115         result.addAll(fullReduce(10));
116         result.addAll(simpleSmallCrSequence(10));
117         return result;
118     }
119 
120     static FieldParams P384 = new FieldParams(&quot;IntegerPolynomialP384&quot;, 28, 14, 2, 384,
121     Arrays.asList(
122     new Term(128, -1),
123     new Term(96, -1),
124     new Term(32, 1),
125     new Term(0, -1)
126     ),
127     P384CrSequence(), simpleSmallCrSequence(14)
128     );
129 
130     private static List&lt;CarryReduce&gt; P384CrSequence() {
131         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
132         result.addAll(fullReduce(14));
133         result.addAll(simpleSmallCrSequence(14));
134         return result;
135     }
136 
137     static FieldParams P521 = new FieldParams(&quot;IntegerPolynomialP521&quot;, 28, 19, 2, 521,
138     Arrays.asList(new Term(0, -1)), P521CrSequence(), simpleSmallCrSequence(19)
139     );
140 
141     private static List&lt;CarryReduce&gt; P521CrSequence() {
142         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
143         result.addAll(fullReduce(19));
144         result.addAll(simpleSmallCrSequence(19));
145         return result;
146     }
147 
148     static FieldParams O256 = new FieldParams(&quot;P256OrderField&quot;, 26, 10, 1, 256,
149     new BigInteger(&quot;26959946660873538059280334323273029441504803697035324946844617595567&quot;),
150     orderFieldCrSequence(10), orderFieldSmallCrSequence(10)
151     );
152 
153     static FieldParams O384 = new FieldParams(&quot;P384OrderField&quot;, 28, 14, 1, 384,
154     new BigInteger(&quot;1388124618062372383947042015309946732620727252194336364173&quot;),
155     orderFieldCrSequence(14), orderFieldSmallCrSequence(14)
156     );
157 
158     static FieldParams O521 = new FieldParams(&quot;P521OrderField&quot;, 28, 19, 1, 521,
159     new BigInteger(&quot;657877501894328237357444332315020117536923257219387276263472201219398408051703&quot;),
160     o521crSequence(19), orderFieldSmallCrSequence(19)
161     );
162 
163     private static List&lt;CarryReduce&gt; o521crSequence(int numLimbs) {
164 
165         // split the full reduce in half, with a carry in between
166         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
167         result.addAll(fullCarry(2 * numLimbs));
168         for (int i = 2 * numLimbs - 1; i &gt;= numLimbs + numLimbs/2; i--) {
169             result.add(new Reduce(i));
170         }
171         // carry
172         for (int i = numLimbs; i &lt; numLimbs + numLimbs / 2 - 1; i++) {
173             result.add(new Carry(i));
174         }
175         // rest of reduce
176         for (int i = numLimbs + numLimbs/2 - 1; i &gt;= numLimbs; i--) {
177             result.add(new Reduce(i));
178         }
179         result.addAll(orderFieldSmallCrSequence(numLimbs));
180 
181         return result;
182     }
183 
184     private static List&lt;CarryReduce&gt; orderFieldCrSequence(int numLimbs) {
185         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
186         result.addAll(fullCarry(2 * numLimbs));
187         result.add(new Reduce(2 * numLimbs - 1));
188         result.addAll(fullReduce(numLimbs));
189         result.addAll(fullCarry(numLimbs + 1));
190         result.add(new Reduce(numLimbs));
191         result.addAll(fullCarry(numLimbs));
192 
193         return result;
194     }
195    private static List&lt;CarryReduce&gt; orderFieldSmallCrSequence(int numLimbs) {
196         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
197         result.addAll(fullCarry(numLimbs + 1));
198         result.add(new Reduce(numLimbs));
199         result.addAll(fullCarry(numLimbs));
200         return result;
201     }
202 
203     static final FieldParams[] ALL_FIELDS = {P256, P384, P521, O256, O384, O521};
204 
205     public static class Term {
206         private final int power;
207         private final int coefficient;
208 
209         public Term(int power, int coefficient) {
210             this.power = power;
211             this.coefficient = coefficient;
212         }
213 
214         public int getPower() {
215             return power;
216         }
217 
218         public int getCoefficient() {
219             return coefficient;
220         }
221 
222         public BigInteger getValue() {
223             return BigInteger.valueOf(2).pow(power).multiply(BigInteger.valueOf(coefficient));
224         }
225 
226     }
227 
228     static abstract class CarryReduce {
229         private final int index;
230 
231         protected CarryReduce(int index) {
232             this.index = index;
233         }
234 
235         public int getIndex() {
236             return index;
237         }
238 
239         public abstract void write(CodeBuffer out, FieldParams params, String prefix, Iterable&lt;CarryReduce&gt; remaining);
240     }
241 
242     static class Carry extends CarryReduce {
243         public Carry(int index) {
244             super(index);
245         }
246 
247         public void write(CodeBuffer out, FieldParams params, String prefix, Iterable&lt;CarryReduce&gt; remaining) {
248             carry(out, params, prefix, getIndex());
249         }
250     }
251 
252     static class Reduce extends CarryReduce {
253         public Reduce(int index) {
254             super(index);
255         }
256 
257         public void write(CodeBuffer out, FieldParams params, String prefix, Iterable&lt;CarryReduce&gt; remaining) {
258             reduce(out, params, prefix, getIndex(), remaining);
259         }
260     }
261 
262     static class FieldParams {
263         private final String className;
264         private final int bitsPerLimb;
265         private final int numLimbs;
266         private final int maxAdds;
267         private final int power;
268         private final Iterable&lt;Term&gt; terms;
269         private final List&lt;CarryReduce&gt; crSequence;
270         private final List&lt;CarryReduce&gt; smallCrSequence;
271 
272         public FieldParams(String className, int bitsPerLimb, int numLimbs, int maxAdds, int power,
273                            Iterable&lt;Term&gt; terms, List&lt;CarryReduce&gt; crSequence, List&lt;CarryReduce&gt; smallCrSequence) {
274             this.className = className;
275             this.bitsPerLimb = bitsPerLimb;
276             this.numLimbs = numLimbs;
277             this.maxAdds = maxAdds;
278             this.power = power;
279             this.terms = terms;
280             this.crSequence = crSequence;
281             this.smallCrSequence = smallCrSequence;
282         }
283 
284         public FieldParams(String className, int bitsPerLimb, int numLimbs, int maxAdds, int power,
285                            BigInteger term, List&lt;CarryReduce&gt; crSequence, List&lt;CarryReduce&gt; smallCrSequence) {
286             this.className = className;
287             this.bitsPerLimb = bitsPerLimb;
288             this.numLimbs = numLimbs;
289             this.maxAdds = maxAdds;
290             this.power = power;
291             this.crSequence = crSequence;
292             this.smallCrSequence = smallCrSequence;
293 
294             terms = buildTerms(term);
295         }
296 
297         private Iterable&lt;Term&gt; buildTerms(BigInteger sub) {
298             // split a large subtrahend into smaller terms that are aligned with limbs
299             List&lt;Term&gt; result = new ArrayList&lt;Term&gt;();
300             BigInteger mod = BigInteger.valueOf(1 &lt;&lt; bitsPerLimb);
301             int termIndex = 0;
302             while (!sub.equals(BigInteger.ZERO)) {
303                 int coef = sub.mod(mod).intValue();
304                 boolean plusOne = false;
305                 if (coef &gt; (1 &lt;&lt; (bitsPerLimb - 1))) {
306                     coef = coef - (1 &lt;&lt; bitsPerLimb);
307                     plusOne = true;
308                 }
309                 if (coef != 0) {
310                     int pow = termIndex * bitsPerLimb;
311                     result.add(new Term(pow, -coef));
312                 }
313                 sub = sub.shiftRight(bitsPerLimb);
314                 if (plusOne) {
315                    sub = sub.add(BigInteger.ONE);
316                 }
317                 ++termIndex;
318             }
319             return result;
320         }
321 
322         public String getClassName() {
323             return className;
324         }
325 
326         public int getBitsPerLimb() {
327             return bitsPerLimb;
328         }
329 
330         public int getNumLimbs() {
331             return numLimbs;
332         }
333 
334         public int getMaxAdds() {
335             return maxAdds;
336         }
337 
338         public int getPower() {
339             return power;
340         }
341 
342         public Iterable&lt;Term&gt; getTerms() {
343             return terms;
344         }
345 
346         public List&lt;CarryReduce&gt; getCrSequence() {
347             return crSequence;
348         }
349 
350         public List&lt;CarryReduce&gt; getSmallCrSequence() {
351             return smallCrSequence;
352         }
353     }
354 
355     static Collection&lt;Carry&gt; fullCarry(int numLimbs) {
356         List&lt;Carry&gt; result = new ArrayList&lt;Carry&gt;();
357         for (int i = 0; i &lt; numLimbs - 1; i++) {
358             result.add(new Carry(i));
359         }
360         return result;
361     }
362 
363     static Collection&lt;Reduce&gt; fullReduce(int numLimbs) {
364         List&lt;Reduce&gt; result = new ArrayList&lt;Reduce&gt;();
365         for (int i = numLimbs - 2; i &gt;= 0; i--) {
366             result.add(new Reduce(i + numLimbs));
367         }
368         return result;
369     }
370 
371     static List&lt;CarryReduce&gt; simpleCrSequence(int numLimbs) {
372         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
373         for(int i = 0; i &lt; 4; i++) {
374             result.addAll(fullCarry(2 * numLimbs - 1));
375             result.addAll(fullReduce(numLimbs));
376         }
377 
378         return result;
379     }
380 
381     static List&lt;CarryReduce&gt; simpleSmallCrSequence(int numLimbs) {
382         List&lt;CarryReduce&gt; result = new ArrayList&lt;CarryReduce&gt;();
383         // carry a few positions at the end
384         for (int i = numLimbs - 2; i &lt; numLimbs; i++) {
385             result.add(new Carry(i));
386         }
387         // this carries out a single value that must be reduced back in
388         result.add(new Reduce(numLimbs));
389         // finish with a full carry
390         result.addAll(fullCarry(numLimbs));
391         return result;
392     }
393 
394     private final String packageName;
395     private final String parentName;
396 
397     public FieldGen(String packageName, String parentName) {
398         this.packageName = packageName;
399         this.parentName = parentName;
400     }
401 
402     public static void main(String[] args) throws Exception {
403 
404         FieldGen gen = new FieldGen(&quot;sun.security.util.math.intpoly&quot;, &quot;IntegerPolynomial&quot;);
405         for(FieldParams p : ALL_FIELDS) {
406             gen.generateFile(p);
407         }
408     }
409 
410     private void generateFile(FieldParams params) throws IOException {
411         String text = generate(params);
412         String fileName = params.getClassName() + &quot;.java&quot;;
413         PrintWriter out = new PrintWriter(new FileWriter(fileName));
414         out.println(text);
415         out.close();
416     }
417 
418     static class CodeBuffer {
419 
420         private int nextTemporary = 0;
421         private Set&lt;String&gt; temporaries = new HashSet&lt;String&gt;();
422         private StringBuffer buffer = new StringBuffer();
423         private int indent = 0;
424         private Class lastCR;
425         private int lastCrCount = 0;
426         private int crMethodBreakCount = 0;
427         private int crNumLimbs = 0;
428 
429         public void incrIndent() {
430             indent++;
431         }
432 
433         public void decrIndent() {
434             indent--;
435         }
436 
437         public void newTempScope() {
438             nextTemporary = 0;
439             temporaries.clear();
440         }
441 
442         public void appendLine(String s) {
443             appendIndent();
444             buffer.append(s + &quot;\n&quot;);
445         }
446 
447         public void appendLine() {
448             buffer.append(&quot;\n&quot;);
449         }
450 
451         public String toString() {
452             return buffer.toString();
453         }
454 
455         public void startCrSequence(int numLimbs) {
456             this.crNumLimbs = numLimbs;
457             lastCrCount = 0;
458             crMethodBreakCount = 0;
459             lastCR = null;
460         }
461         /*
462          * Record a carry/reduce of the specified type. This method is used to
463          * break up large carry/reduce sequences into multiple methods to make
464          * JIT/optimization easier
465          */
466         public void record(Class type) {
467             if (type == lastCR) {
468                 lastCrCount++;
469             } else {
470 
471                 if (lastCrCount &gt;= 8) {
472                     insertCrMethodBreak();
473                 }
474 
475                 lastCR = type;
476                 lastCrCount = 0;
477             }
478         }
479 
480         private void insertCrMethodBreak() {
481 
482             appendLine();
483 
484             // call the new method
485             appendIndent();
486             append(&quot;carryReduce&quot; + crMethodBreakCount + &quot;(r&quot;);
487             for(int i = 0; i &lt; crNumLimbs; i++) {
488                 append(&quot;, c&quot; + i);
489             }
490             // temporaries are not live between operations, no need to send
491             append(&quot;);\n&quot;);
492 
493             decrIndent();
494             appendLine(&quot;}&quot;);
495 
496             // make the method
497             appendIndent();
498             append(&quot;void carryReduce&quot; + crMethodBreakCount + &quot;(long[] r&quot;);
499             for(int i = 0; i &lt; crNumLimbs; i++) {
500                 append (&quot;, long c&quot; + i);
501             }
502             append(&quot;) {\n&quot;);
503             incrIndent();
504             // declare temporaries
505             for(String temp : temporaries) {
506                 appendLine(&quot;long &quot; + temp + &quot;;&quot;);
507             }
508             append(&quot;\n&quot;);
509 
510             crMethodBreakCount++;
511         }
512 
513         public String getTemporary(String type, String value) {
514             Iterator&lt;String&gt; iter = temporaries.iterator();
515             if(iter.hasNext()) {
516                 String result = iter.next();
517                 iter.remove();
518                 appendLine(result + &quot; = &quot; + value + &quot;;&quot;);
519                 return result;
520             } else {
521                 String result = &quot;t&quot; + (nextTemporary++);
522                 appendLine(type + &quot; &quot; + result + &quot; = &quot; + value + &quot;;&quot;);
523                 return result;
524             }
525         }
526 
527         public void freeTemporary(String temp) {
528             temporaries.add(temp);
529         }
530 
531         public void appendIndent() {
532             for(int i = 0; i &lt; indent; i++) {
533                 buffer.append(&quot;    &quot;);
534             }
535         }
536 
537         public void append(String s) {
538             buffer.append(s);
539         }
540     }
541 
542     private String generate(FieldParams params) throws IOException {
543         CodeBuffer result = new CodeBuffer();
544         String header = readHeader();
545         result.appendLine(header);
546 
547         if (packageName != null) {
548             result.appendLine(&quot;package &quot; + packageName + &quot;;&quot;);
549             result.appendLine();
550         }
551         result.appendLine(&quot;import java.math.BigInteger;&quot;);
552 
553         result.appendLine(&quot;public class &quot; + params.getClassName() + &quot; extends &quot; + this.parentName + &quot; {&quot;);
554         result.incrIndent();
555 
556         result.appendLine(&quot;private static final int BITS_PER_LIMB = &quot; + params.getBitsPerLimb() + &quot;;&quot;);
557         result.appendLine(&quot;private static final int NUM_LIMBS = &quot; + params.getNumLimbs() + &quot;;&quot;);
558         result.appendLine(&quot;private static final int MAX_ADDS = &quot; + params.getMaxAdds() + &quot;;&quot;);
559         result.appendLine(&quot;public static final BigInteger MODULUS = evaluateModulus();&quot;);
560         result.appendLine(&quot;private static final long CARRY_ADD = 1 &lt;&lt; &quot; + (params.getBitsPerLimb() - 1) + &quot;;&quot;);
561         if (params.getBitsPerLimb() * params.getNumLimbs() != params.getPower()) {
562             result.appendLine(&quot;private static final int LIMB_MASK = -1 &gt;&gt;&gt; (64 - BITS_PER_LIMB);&quot;);
563         }
564         int termIndex = 0;
565 
566         result.appendLine(&quot;public &quot; + params.getClassName() + &quot;() {&quot;);
567         result.appendLine();
568         result.appendLine(&quot;    super(BITS_PER_LIMB, NUM_LIMBS, MAX_ADDS, MODULUS);&quot;);
569         result.appendLine();
570         result.appendLine(&quot;}&quot;);
571 
572         result.appendLine(&quot;private static BigInteger evaluateModulus() {&quot;);
573         result.incrIndent();
574         result.appendLine(&quot;BigInteger result = BigInteger.valueOf(2).pow(&quot; + params.getPower() + &quot;);&quot;);
575         for(Term t : params.getTerms()) {
576             boolean subtract = false;
577             int coefValue = t.getCoefficient();
578             if (coefValue &lt; 0) {
579                 coefValue = 0 - coefValue;
580                 subtract = true;
581             }
582             String coefExpr = &quot;BigInteger.valueOf(&quot; + coefValue + &quot;)&quot;;
583             String powExpr = &quot;BigInteger.valueOf(2).pow(&quot; + t.getPower() + &quot;)&quot;;
584             String termExpr = &quot;ERROR&quot;;
585             if (t.getPower() == 0) {
586                 termExpr = coefExpr;
587             } else if (coefValue == 1) {
588                 termExpr = powExpr;
589             } else {
590                 termExpr = powExpr + &quot;.multiply(&quot; + coefExpr + &quot;)&quot;;
591             }
592             if (subtract) {
593                 result.appendLine(&quot;result = result.subtract(&quot; + termExpr + &quot;);&quot;);
594             } else {
595                 result.appendLine(&quot;result = result.add(&quot; + termExpr + &quot;);&quot;);
596             }
597         }
598         result.appendLine(&quot;return result;&quot;);
599         result.decrIndent();
600         result.appendLine(&quot;}&quot;);
601 
602         result.appendLine(&quot;@Override&quot;);
603         result.appendLine(&quot;protected void finalCarryReduceLast(long[] limbs) {&quot;);
604         result.incrIndent();
605         int extraBits = params.getBitsPerLimb() * params.getNumLimbs() - params.getPower();
606         int highBits = params.getBitsPerLimb() - extraBits;
607         result.appendLine(&quot;long c = limbs[&quot; + (params.getNumLimbs() - 1) + &quot;] &gt;&gt; &quot; + highBits + &quot;;&quot;);
608         result.appendLine(&quot;limbs[&quot; + (params.getNumLimbs() - 1) + &quot;] -= c &lt;&lt; &quot; + highBits + &quot;;&quot;);
609         for (Term t : params.getTerms()) {
610             int reduceBits = params.getPower() + extraBits - t.getPower();
611             int negatedCoefficient = -1 * t.getCoefficient();
612             modReduceInBits(result, params, true, &quot;limbs&quot;, params.getNumLimbs(), reduceBits, negatedCoefficient, &quot;c&quot;);
613         }
614         result.decrIndent();
615         result.appendLine(&quot;}&quot;);
616 
617         // full carry/reduce sequence
618         result.appendIndent();
619         result.append(&quot;private void carryReduce(long[] r, &quot;);
620         for(int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
621             result.append (&quot;long c&quot; + i);
622             if (i &lt; 2 * params.getNumLimbs() - 2) {
623                 result.append(&quot;, &quot;);
624             }
625         }
626         result.append(&quot;) {\n&quot;);
627         result.newTempScope();
628         result.incrIndent();
629         result.appendLine(&quot;long c&quot; + (2 * params.getNumLimbs() - 1) + &quot; = 0;&quot;);
630         write(result, params.getCrSequence(), params, &quot;c&quot;, 2 * params.getNumLimbs());
631         result.appendLine();
632         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
633             result.appendLine(&quot;r[&quot; + i + &quot;] = c&quot; + i + &quot;;&quot;);
634         }
635         result.decrIndent();
636         result.appendLine(&quot;}&quot;);
637 
638         // small carry/reduce sequence
639         result.appendIndent();
640         result.append(&quot;private void carryReduce(long[] r, &quot;);
641         for(int i = 0; i &lt; params.getNumLimbs(); i++) {
642             result.append (&quot;long c&quot; + i);
643             if (i &lt; params.getNumLimbs() - 1) {
644                 result.append(&quot;, &quot;);
645             }
646         }
647         result.append(&quot;) {\n&quot;);
648         result.newTempScope();
649         result.incrIndent();
650         result.appendLine(&quot;long c&quot; + params.getNumLimbs() + &quot; = 0;&quot;);
651         write(result, params.getSmallCrSequence(), params, &quot;c&quot;, params.getNumLimbs() + 1);
652         result.appendLine();
653         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
654             result.appendLine(&quot;r[&quot; + i + &quot;] = c&quot; + i + &quot;;&quot;);
655         }
656         result.decrIndent();
657         result.appendLine(&quot;}&quot;);
658 
659         result.appendLine(&quot;@Override&quot;);
660         result.appendLine(&quot;protected void mult(long[] a, long[] b, long[] r) {&quot;);
661         result.incrIndent();
662         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
663             result.appendIndent();
664             result.append(&quot;long c&quot; + i + &quot; = &quot;);
665             int startJ = Math.max(i + 1 - params.getNumLimbs(), 0);
666             int endJ = Math.min(params.getNumLimbs(), i + 1);
667             for (int j = startJ; j &lt; endJ; j++) {
668                 int bIndex = i - j;
669                 result.append(&quot;(a[&quot; + j + &quot;] * b[&quot; + bIndex + &quot;])&quot;);
670                 if (j &lt; endJ - 1) {
671                     result.append(&quot; + &quot;);
672                 }
673             }
674             result.append(&quot;;\n&quot;);
675         }
676         result.appendLine();
677         result.appendIndent();
678         result.append(&quot;carryReduce(r, &quot;);
679         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
680             result.append(&quot;c&quot; + i);
681             if (i &lt; 2 * params.getNumLimbs() - 2) {
682                 result.append(&quot;, &quot;);
683             }
684         }
685         result.append(&quot;);\n&quot;);
686         result.decrIndent();
687         result.appendLine(&quot;}&quot;);
688 
689         result.appendLine(&quot;@Override&quot;);
690         result.appendLine(&quot;protected void reduce(long[] a) {&quot;);
691         result.incrIndent();
692         result.appendIndent();
693         result.append(&quot;carryReduce(a, &quot;);
694         for (int i = 0; i &lt; params.getNumLimbs(); i++) {
695             result.append(&quot;a[&quot; + i + &quot;]&quot;);
696             if (i &lt; params.getNumLimbs() - 1) {
697                 result.append(&quot;, &quot;);
698             }
699         }
700         result.append(&quot;);\n&quot;);
701         result.decrIndent();
702         result.appendLine(&quot;}&quot;);
703 
704         result.appendLine(&quot;@Override&quot;);
705         result.appendLine(&quot;protected void square(long[] a, long[] r) {&quot;);
706         result.incrIndent();
707         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
708             result.appendIndent();
709             result.append(&quot;long c&quot; + i + &quot; = &quot;);
710             int startJ = Math.max(i + 1 - params.getNumLimbs(), 0);
711             int endJ = Math.min(params.getNumLimbs(), i + 1);
712             int jDiff = endJ - startJ;
713             if (jDiff &gt; 1) {
714                 result.append(&quot;2 * (&quot;);
715             }
716             for (int j = 0; j &lt; jDiff / 2; j++) {
717                 int aIndex = j + startJ;
718                 int bIndex = i - aIndex;
719                 result.append(&quot;(a[&quot; + aIndex + &quot;] * a[&quot; + bIndex + &quot;])&quot;);
720                 if (j &lt; (jDiff / 2) - 1) {
721                     result.append(&quot; + &quot;);
722                 }
723             }
724             if (jDiff &gt; 1) {
725                 result.append(&quot;)&quot;);
726             }
727             if (jDiff % 2 == 1) {
728                 int aIndex = i / 2;
729                 if (jDiff &gt; 1) {
730                     result.append (&quot; + &quot;);
731                 }
732                 result.append(&quot;(a[&quot; + aIndex + &quot;] * a[&quot; + aIndex + &quot;])&quot;);
733             }
734             result.append(&quot;;\n&quot;);
735         }
736         result.appendLine();
737         result.appendIndent();
738         result.append(&quot;carryReduce(r, &quot;);
739         for (int i = 0; i &lt; 2 * params.getNumLimbs() - 1; i++) {
740             result.append(&quot;c&quot; + i);
741             if (i &lt; 2 * params.getNumLimbs() - 2) {
742                 result.append(&quot;, &quot;);
743             }
744         }
745         result.append(&quot;);\n&quot;);
746         result.decrIndent();
747         result.appendLine(&quot;}&quot;);
748 
749         result.decrIndent();
750         result.appendLine(&quot;}&quot;); // end class
751 
752         return result.toString();
753     }
754 
755     private static void write(CodeBuffer out, List&lt;CarryReduce&gt; sequence, FieldParams params, String prefix, int numLimbs) {
756 
757         out.startCrSequence(numLimbs);
758         for (int i = 0; i &lt; sequence.size(); i++) {
759             CarryReduce cr = sequence.get(i);
760             Iterator&lt;CarryReduce&gt; remainingIter = sequence.listIterator(i + 1);
761             List&lt;CarryReduce&gt; remaining = new ArrayList&lt;CarryReduce&gt;();
762             remainingIter.forEachRemaining(remaining::add);
763             cr.write(out, params, prefix, remaining);
764         }
765     }
766 
767     private static void reduce(CodeBuffer out, FieldParams params, String prefix, int index, Iterable&lt;CarryReduce&gt; remaining) {
768 
769         out.record(Reduce.class);
770 
771         out.appendLine(&quot;//reduce from position &quot; + index);
772         String reduceFrom = indexedExpr(false, prefix, index);
773         boolean referenced = false;
774         for (CarryReduce cr : remaining) {
775             if(cr.index == index) {
776                 referenced = true;
777             }
778         }
779         for (Term t : params.getTerms()) {
780             int reduceBits = params.getPower() - t.getPower();
781             int negatedCoefficient = -1 * t.getCoefficient();
782             modReduceInBits(out, params, false, prefix, index, reduceBits, negatedCoefficient, reduceFrom);
783         }
784         if (referenced) {
785             out.appendLine(reduceFrom + &quot; = 0;&quot;);
786         }
787     }
788 
789     private static void carry(CodeBuffer out, FieldParams params, String prefix, int index) {
790 
791         out.record(Carry.class);
792 
793         out.appendLine(&quot;//carry from position &quot; + index);
794         String carryFrom = prefix + index;
795         String carryTo = prefix + (index + 1);
796         String carry = &quot;(&quot; + carryFrom + &quot; + CARRY_ADD) &gt;&gt; &quot; + params.getBitsPerLimb();
797         String temp = out.getTemporary(&quot;long&quot;, carry);
798         out.appendLine(carryFrom + &quot; -= (&quot; + temp + &quot; &lt;&lt; &quot; + params.getBitsPerLimb() + &quot;);&quot;);
799         out.appendLine(carryTo + &quot; += &quot; + temp + &quot;;&quot;);
800         out.freeTemporary(temp);
801     }
802 
803     private static String indexedExpr(boolean isArray, String prefix, int index) {
804         String result = prefix + index;
805         if (isArray) {
806             result = prefix + &quot;[&quot; + index + &quot;]&quot;;
807         }
808         return result;
809     }
810 
811     private static void modReduceInBits(CodeBuffer result, FieldParams params, boolean isArray, String prefix, int index, int reduceBits, int coefficient, String c) {
812 
813         String x = coefficient + &quot; * &quot; + c;
814         String accOp = &quot;+=&quot;;
815         String temp = null;
816         if (coefficient == 1) {
817             x = c;
818         } else if (coefficient == -1) {
819             x = c;
820             accOp = &quot;-=&quot;;
821         } else {
822             temp = result.getTemporary(&quot;long&quot;, x);
823             x = temp;
824         }
825 
826         if (reduceBits % params.getBitsPerLimb() == 0) {
827             int pos = reduceBits / params.getBitsPerLimb();
828             result.appendLine(indexedExpr(isArray, prefix, (index - pos)) + &quot; &quot; + accOp + &quot; &quot; + x + &quot;;&quot;);
829         } else {
830             int secondPos = reduceBits / params.getBitsPerLimb();
831             int bitOffset = (secondPos + 1) * params.getBitsPerLimb() - reduceBits;
832             int rightBitOffset = params.getBitsPerLimb() - bitOffset;
833             result.appendLine(indexedExpr(isArray, prefix, (index - (secondPos + 1))) + &quot; &quot; + accOp + &quot; (&quot; + x + &quot; &lt;&lt; &quot; + bitOffset + &quot;) &amp; LIMB_MASK;&quot;);
834             result.appendLine(indexedExpr(isArray, prefix, (index - secondPos)) + &quot; &quot; + accOp + &quot; &quot; + x + &quot; &gt;&gt; &quot; + rightBitOffset + &quot;;&quot;);
835         }
836 
837         if (temp != null) {
838             result.freeTemporary(temp);
839         }
840     }
841 
842     private String readHeader() throws IOException {
843         BufferedReader reader = Files.newBufferedReader(Paths.get(&quot;header.txt&quot;));
844         StringBuffer result = new StringBuffer();
845         reader.lines().forEach(s -&gt; result.append(s + &quot;\n&quot;));
846         return result.toString();
847     }
848 }
849 
850 FieldGen.main(null);
851 
    </pre>
  </body>
</html>
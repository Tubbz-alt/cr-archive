<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/X509KeyManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.lang.ref.*;
 29 import java.net.Socket;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.KeyStore;
 32 import java.security.KeyStore.Builder;
 33 import java.security.KeyStore.Entry;
 34 import java.security.KeyStore.PrivateKeyEntry;
 35 import java.security.Principal;
 36 import java.security.PrivateKey;
 37 import java.security.cert.CertPathValidatorException;
 38 import java.security.cert.Certificate;
 39 import java.security.cert.CertificateException;
 40 import java.security.cert.X509Certificate;
 41 import java.util.*;
 42 import java.util.concurrent.atomic.AtomicLong;
 43 import javax.net.ssl.*;
 44 import sun.security.provider.certpath.AlgorithmChecker;
 45 import sun.security.validator.Validator;
 46 
 47 /**
 48  * The new X509 key manager implementation. The main differences to the
 49  * old SunX509 key manager are:
 50  *  . it is based around the KeyStore.Builder API. This allows it to use
 51  *    other forms of KeyStore protection or password input (e.g. a
 52  *    CallbackHandler) or to have keys within one KeyStore protected by
 53  *    different keys.
 54  *  . it can use multiple KeyStores at the same time.
 55  *  . it is explicitly designed to accommodate KeyStores that change over
 56  *    the lifetime of the process.
 57  *  . it makes an effort to choose the key that matches best, i.e. one that
 58  *    is not expired and has the appropriate certificate extensions.
 59  *
 60  * Note that this code is not explicitly performance optimzied yet.
 61  *
 62  * @author  Andreas Sterbenz
 63  */
 64 final class X509KeyManagerImpl extends X509ExtendedKeyManager
 65         implements X509KeyManager {
 66 
 67     // for unit testing only, set via privileged reflection
 68     private static Date verificationDate;
 69 
 70     // list of the builders
 71     private final List&lt;Builder&gt; builders;
 72 
 73     // counter to generate unique ids for the aliases
 74     private final AtomicLong uidCounter;
 75 
 76     // cached entries
 77     private final Map&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt; entryCacheMap;
 78 
 79     X509KeyManagerImpl(Builder builder) {
 80         this(Collections.singletonList(builder));
 81     }
 82 
 83     X509KeyManagerImpl(List&lt;Builder&gt; builders) {
 84         this.builders = builders;
 85         uidCounter = new AtomicLong();
 86         entryCacheMap = Collections.synchronizedMap
 87                         (new SizedMap&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt;());
 88     }
 89 
 90     // LinkedHashMap with a max size of 10
 91     // see LinkedHashMap JavaDocs
 92     private static class SizedMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; {
<a name="2" id="anc2"></a>
 93         private static final long serialVersionUID = -8211222668790986062L;
 94 
 95         @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
 96             return size() &gt; 10;
 97         }
 98     }
 99 
100     //
101     // public methods
102     //
103 
104     @Override
105     public X509Certificate[] getCertificateChain(String alias) {
106         PrivateKeyEntry entry = getEntry(alias);
107         return entry == null ? null :
108                 (X509Certificate[])entry.getCertificateChain();
109     }
110 
111     @Override
112     public PrivateKey getPrivateKey(String alias) {
113         PrivateKeyEntry entry = getEntry(alias);
114         return entry == null ? null : entry.getPrivateKey();
115     }
116 
117     @Override
118     public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
119             Socket socket) {
120         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
121                         getAlgorithmConstraints(socket));
122     }
123 
124     @Override
125     public String chooseEngineClientAlias(String[] keyTypes,
126             Principal[] issuers, SSLEngine engine) {
127         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
128                         getAlgorithmConstraints(engine));
129     }
130 
131     @Override
132     public String chooseServerAlias(String keyType,
133             Principal[] issuers, Socket socket) {
134         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
135             getAlgorithmConstraints(socket),
136             X509TrustManagerImpl.getRequestedServerNames(socket),
137             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
138                          // The certificate selection scheme for SNI HostName
139                          // is similar to HTTPS endpoint identification scheme
140                          // implemented in this provider.
141                          //
142                          // Using HTTPS endpoint identification scheme to guide
143                          // the selection of an appropriate authentication
144                          // certificate according to requested SNI extension.
145                          //
146                          // It is not a really HTTPS endpoint identification.
147     }
148 
149     @Override
150     public String chooseEngineServerAlias(String keyType,
151             Principal[] issuers, SSLEngine engine) {
152         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
153             getAlgorithmConstraints(engine),
154             X509TrustManagerImpl.getRequestedServerNames(engine),
155             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
156                          // The certificate selection scheme for SNI HostName
157                          // is similar to HTTPS endpoint identification scheme
158                          // implemented in this provider.
159                          //
160                          // Using HTTPS endpoint identification scheme to guide
161                          // the selection of an appropriate authentication
162                          // certificate according to requested SNI extension.
163                          //
164                          // It is not a really HTTPS endpoint identification.
165     }
166 
167     @Override
168     public String[] getClientAliases(String keyType, Principal[] issuers) {
169         return getAliases(keyType, issuers, CheckType.CLIENT, null);
170     }
171 
172     @Override
173     public String[] getServerAliases(String keyType, Principal[] issuers) {
174         return getAliases(keyType, issuers, CheckType.SERVER, null);
175     }
176 
177     //
178     // implementation private methods
179     //
180 
181     // Gets algorithm constraints of the socket.
182     private AlgorithmConstraints getAlgorithmConstraints(Socket socket) {
183         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
184                                         socket instanceof SSLSocket) {
185 
186             SSLSocket sslSocket = (SSLSocket)socket;
187             SSLSession session = sslSocket.getHandshakeSession();
188 
189             if (session != null) {
190                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
191                     String[] peerSupportedSignAlgs = null;
192 
193                     if (session instanceof ExtendedSSLSession) {
194                         ExtendedSSLSession extSession =
195                             (ExtendedSSLSession)session;
196                         peerSupportedSignAlgs =
197                             extSession.getPeerSupportedSignatureAlgorithms();
198                     }
199 
200                     return new SSLAlgorithmConstraints(
201                         sslSocket, peerSupportedSignAlgs, true);
202                 }
203             }
204 
205             return new SSLAlgorithmConstraints(sslSocket, true);
206         }
207 
208         return new SSLAlgorithmConstraints((SSLSocket)null, true);
209     }
210 
211     // Gets algorithm constraints of the engine.
212     private AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {
213         if (engine != null) {
214             SSLSession session = engine.getHandshakeSession();
215             if (session != null) {
216                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
217                     String[] peerSupportedSignAlgs = null;
218 
219                     if (session instanceof ExtendedSSLSession) {
220                         ExtendedSSLSession extSession =
221                             (ExtendedSSLSession)session;
222                         peerSupportedSignAlgs =
223                             extSession.getPeerSupportedSignatureAlgorithms();
224                     }
225 
226                     return new SSLAlgorithmConstraints(
227                         engine, peerSupportedSignAlgs, true);
228                 }
229             }
230         }
231 
232         return new SSLAlgorithmConstraints(engine, true);
233     }
234 
235     // we construct the alias we return to JSSE as seen in the code below
236     // a unique id is included to allow us to reliably cache entries
237     // between the calls to getCertificateChain() and getPrivateKey()
238     // even if tokens are inserted or removed
239     private String makeAlias(EntryStatus entry) {
240         return uidCounter.incrementAndGet() + &quot;.&quot; + entry.builderIndex + &quot;.&quot;
241                 + entry.alias;
242     }
243 
244     private PrivateKeyEntry getEntry(String alias) {
245         // if the alias is null, return immediately
246         if (alias == null) {
247             return null;
248         }
249 
250         // try to get the entry from cache
251         Reference&lt;PrivateKeyEntry&gt; ref = entryCacheMap.get(alias);
252         PrivateKeyEntry entry = (ref != null) ? ref.get() : null;
253         if (entry != null) {
254             return entry;
255         }
256 
257         // parse the alias
258         int firstDot = alias.indexOf(&#39;.&#39;);
259         int secondDot = alias.indexOf(&#39;.&#39;, firstDot + 1);
260         if ((firstDot == -1) || (secondDot == firstDot)) {
261             // invalid alias
262             return null;
263         }
264         try {
265             int builderIndex = Integer.parseInt
266                                 (alias.substring(firstDot + 1, secondDot));
267             String keyStoreAlias = alias.substring(secondDot + 1);
268             Builder builder = builders.get(builderIndex);
269             KeyStore ks = builder.getKeyStore();
270             Entry newEntry = ks.getEntry
271                     (keyStoreAlias, builder.getProtectionParameter(alias));
272             if (newEntry instanceof PrivateKeyEntry == false) {
273                 // unexpected type of entry
274                 return null;
275             }
276             entry = (PrivateKeyEntry)newEntry;
277             entryCacheMap.put(alias, new SoftReference&lt;PrivateKeyEntry&gt;(entry));
278             return entry;
279         } catch (Exception e) {
280             // ignore
281             return null;
282         }
283     }
284 
285     // Class to help verify that the public key algorithm (and optionally
286     // the signature algorithm) of a certificate matches what we need.
287     private static class KeyType {
288 
289         final String keyAlgorithm;
290 
291         // In TLS 1.2, the signature algorithm  has been obsoleted by the
292         // supported_signature_algorithms, and the certificate type no longer
293         // restricts the algorithm used to sign the certificate.
294         //
295         // However, because we don&#39;t support certificate type checking other
296         // than rsa_sign, dss_sign and ecdsa_sign, we don&#39;t have to check the
297         // protocol version here.
298         final String sigKeyAlgorithm;
299 
300         KeyType(String algorithm) {
301             int k = algorithm.indexOf(&#39;_&#39;);
302             if (k == -1) {
303                 keyAlgorithm = algorithm;
304                 sigKeyAlgorithm = null;
305             } else {
306                 keyAlgorithm = algorithm.substring(0, k);
307                 sigKeyAlgorithm = algorithm.substring(k + 1);
308             }
309         }
310 
311         boolean matches(Certificate[] chain) {
312             if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {
313                 return false;
314             }
315             if (sigKeyAlgorithm == null) {
316                 return true;
317             }
318             if (chain.length &gt; 1) {
319                 // if possible, check the public key in the issuer cert
320                 return sigKeyAlgorithm.equals(
321                         chain[1].getPublicKey().getAlgorithm());
322             } else {
323                 // Check the signature algorithm of the certificate itself.
324                 // Look for the &quot;withRSA&quot; in &quot;SHA1withRSA&quot;, etc.
325                 X509Certificate issuer = (X509Certificate)chain[0];
326                 String sigAlgName =
327                         issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);
328                 String pattern =
329                         &quot;WITH&quot; + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);
330                 return sigAlgName.contains(pattern);
331             }
332         }
333     }
334 
335     private static List&lt;KeyType&gt; getKeyTypes(String ... keyTypes) {
336         if ((keyTypes == null) ||
337                 (keyTypes.length == 0) || (keyTypes[0] == null)) {
338             return null;
339         }
340         List&lt;KeyType&gt; list = new ArrayList&lt;&gt;(keyTypes.length);
341         for (String keyType : keyTypes) {
342             list.add(new KeyType(keyType));
343         }
344         return list;
345     }
346 
347     /*
348      * Return the best alias that fits the given parameters.
349      * The algorithm we use is:
350      *   . scan through all the aliases in all builders in order
351      *   . as soon as we find a perfect match, return
352      *     (i.e. a match with a cert that has appropriate key usage,
353      *      qualified endpoint identity, and is not expired).
354      *   . if we do not find a perfect match, keep looping and remember
355      *     the imperfect matches
356      *   . at the end, sort the imperfect matches. we prefer expired certs
357      *     with appropriate key usage to certs with the wrong key usage.
358      *     return the first one of them.
359      */
360     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
361             CheckType checkType, AlgorithmConstraints constraints) {
362 
363         return chooseAlias(keyTypeList, issuers,
364                                     checkType, constraints, null, null);
365     }
366 
367     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
368             CheckType checkType, AlgorithmConstraints constraints,
369             List&lt;SNIServerName&gt; requestedServerNames, String idAlgorithm) {
370 
371         if (keyTypeList == null || keyTypeList.isEmpty()) {
372             return null;
373         }
374 
375         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
376         List&lt;EntryStatus&gt; allResults = null;
377         for (int i = 0, n = builders.size(); i &lt; n; i++) {
378             try {
379                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
380                             issuerSet, false, checkType, constraints,
381                             requestedServerNames, idAlgorithm);
382                 if (results != null) {
383                     // the results will either be a single perfect match
384                     // or 1 or more imperfect matches
385                     // if it&#39;s a perfect match, return immediately
386                     EntryStatus status = results.get(0);
387                     if (status.checkResult == CheckResult.OK) {
388                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
389                             SSLLogger.fine(&quot;KeyMgr: choosing key: &quot; + status);
390                         }
391                         return makeAlias(status);
392                     }
393                     if (allResults == null) {
394                         allResults = new ArrayList&lt;EntryStatus&gt;();
395                     }
396                     allResults.addAll(results);
397                 }
398             } catch (Exception e) {
399                 // ignore
400             }
401         }
402         if (allResults == null) {
403             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
404                 SSLLogger.fine(&quot;KeyMgr: no matching key found&quot;);
405             }
406             return null;
407         }
408         Collections.sort(allResults);
409         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
410             SSLLogger.fine(
411                     &quot;KeyMgr: no good matching key found, &quot;
412                     + &quot;returning best match out of&quot;, allResults);
413         }
414         return makeAlias(allResults.get(0));
415     }
416 
417     /*
418      * Return all aliases that (approximately) fit the parameters.
419      * These are perfect matches plus imperfect matches (expired certificates
420      * and certificates with the wrong extensions).
421      * The perfect matches will be first in the array.
422      */
423     public String[] getAliases(String keyType, Principal[] issuers,
424             CheckType checkType, AlgorithmConstraints constraints) {
425         if (keyType == null) {
426             return null;
427         }
428 
429         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
430         List&lt;KeyType&gt; keyTypeList = getKeyTypes(keyType);
431         List&lt;EntryStatus&gt; allResults = null;
432         for (int i = 0, n = builders.size(); i &lt; n; i++) {
433             try {
434                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
435                                     issuerSet, true, checkType, constraints,
436                                     null, null);
437                 if (results != null) {
438                     if (allResults == null) {
439                         allResults = new ArrayList&lt;&gt;();
440                     }
441                     allResults.addAll(results);
442                 }
443             } catch (Exception e) {
444                 // ignore
445             }
446         }
447         if (allResults == null || allResults.isEmpty()) {
448             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
449                 SSLLogger.fine(&quot;KeyMgr: no matching alias found&quot;);
450             }
451             return null;
452         }
453         Collections.sort(allResults);
454         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
455             SSLLogger.fine(&quot;KeyMgr: getting aliases&quot;, allResults);
456         }
457         return toAliases(allResults);
458     }
459 
460     // turn candidate entries into unique aliases we can return to JSSE
461     private String[] toAliases(List&lt;EntryStatus&gt; results) {
462         String[] s = new String[results.size()];
463         int i = 0;
464         for (EntryStatus result : results) {
465             s[i++] = makeAlias(result);
466         }
467         return s;
468     }
469 
470     // make a Set out of the array
471     private Set&lt;Principal&gt; getIssuerSet(Principal[] issuers) {
472         if ((issuers != null) &amp;&amp; (issuers.length != 0)) {
473             return new HashSet&lt;&gt;(Arrays.asList(issuers));
474         } else {
475             return null;
476         }
477     }
478 
479     // a candidate match
480     // identifies the entry by builder and alias
481     // and includes the result of the certificate check
482     private static class EntryStatus implements Comparable&lt;EntryStatus&gt; {
483 
484         final int builderIndex;
485         final int keyIndex;
486         final String alias;
487         final CheckResult checkResult;
488 
489         EntryStatus(int builderIndex, int keyIndex, String alias,
490                 Certificate[] chain, CheckResult checkResult) {
491             this.builderIndex = builderIndex;
492             this.keyIndex = keyIndex;
493             this.alias = alias;
494             this.checkResult = checkResult;
495         }
496 
497         @Override
498         public int compareTo(EntryStatus other) {
499             int result = this.checkResult.compareTo(other.checkResult);
500             return (result == 0) ? (this.keyIndex - other.keyIndex) : result;
501         }
502 
503         @Override
504         public String toString() {
505             String s = alias + &quot; (verified: &quot; + checkResult + &quot;)&quot;;
506             if (builderIndex == 0) {
507                 return s;
508             } else {
509                 return &quot;Builder #&quot; + builderIndex + &quot;, alias: &quot; + s;
510             }
511         }
512     }
513 
514     // enum for the type of certificate check we want to perform
515     // (client or server)
516     // also includes the check code itself
517     private static enum CheckType {
518 
519         // enum constant for &quot;no check&quot; (currently not used)
520         NONE(Collections.&lt;String&gt;emptySet()),
521 
522         // enum constant for &quot;tls client&quot; check
523         // valid EKU for TLS client: any, tls_client
524         CLIENT(new HashSet&lt;String&gt;(Arrays.asList(new String[] {
525             &quot;2.5.29.37.0&quot;, &quot;1.3.6.1.5.5.7.3.2&quot; }))),
526 
527         // enum constant for &quot;tls server&quot; check
528         // valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc
529         SERVER(new HashSet&lt;String&gt;(Arrays.asList(new String[] {
530             &quot;2.5.29.37.0&quot;, &quot;1.3.6.1.5.5.7.3.1&quot;, &quot;2.16.840.1.113730.4.1&quot;,
531             &quot;1.3.6.1.4.1.311.10.3.3&quot; })));
532 
533         // set of valid EKU values for this type
534         final Set&lt;String&gt; validEku;
535 
536         CheckType(Set&lt;String&gt; validEku) {
537             this.validEku = validEku;
538         }
539 
540         private static boolean getBit(boolean[] keyUsage, int bit) {
541             return (bit &lt; keyUsage.length) &amp;&amp; keyUsage[bit];
542         }
543 
544         // Check if this certificate is appropriate for this type of use
545         // first check extensions, if they match, check expiration.
546         //
547         // Note: we may want to move this code into the sun.security.validator
548         // package
549         CheckResult check(X509Certificate cert, Date date,
550                 List&lt;SNIServerName&gt; serverNames, String idAlgorithm) {
551 
552             if (this == NONE) {
553                 return CheckResult.OK;
554             }
555 
556             // check extensions
557             try {
558                 // check extended key usage
559                 List&lt;String&gt; certEku = cert.getExtendedKeyUsage();
560                 if ((certEku != null) &amp;&amp;
561                         Collections.disjoint(validEku, certEku)) {
562                     // if extension present and it does not contain any of
563                     // the valid EKU OIDs, return extension_mismatch
564                     return CheckResult.EXTENSION_MISMATCH;
565                 }
566 
567                 // check key usage
568                 boolean[] ku = cert.getKeyUsage();
569                 if (ku != null) {
570                     String algorithm = cert.getPublicKey().getAlgorithm();
571                     boolean supportsDigitalSignature = getBit(ku, 0);
572                     switch (algorithm) {
573                         case &quot;RSA&quot;:
574                             // require either signature bit
575                             // or if server also allow key encipherment bit
576                             if (!supportsDigitalSignature) {
577                                 if (this == CLIENT || getBit(ku, 2) == false) {
578                                     return CheckResult.EXTENSION_MISMATCH;
579                                 }
580                             }
581                             break;
582                         case &quot;RSASSA-PSS&quot;:
583                             if (!supportsDigitalSignature &amp;&amp; (this == SERVER)) {
584                                 return CheckResult.EXTENSION_MISMATCH;
585                             }
586                             break;
587                         case &quot;DSA&quot;:
588                             // require signature bit
589                             if (!supportsDigitalSignature) {
590                                 return CheckResult.EXTENSION_MISMATCH;
591                             }
592                             break;
593                         case &quot;DH&quot;:
594                             // require keyagreement bit
595                             if (getBit(ku, 4) == false) {
596                                 return CheckResult.EXTENSION_MISMATCH;
597                             }
598                             break;
599                         case &quot;EC&quot;:
600                             // require signature bit
601                             if (!supportsDigitalSignature) {
602                                 return CheckResult.EXTENSION_MISMATCH;
603                             }
604                             // For servers, also require key agreement.
605                             // This is not totally accurate as the keyAgreement
606                             // bit is only necessary for static ECDH key
607                             // exchange and not ephemeral ECDH. We leave it in
608                             // for now until there are signs that this check
609                             // causes problems for real world EC certificates.
610                             if ((this == SERVER) &amp;&amp; (getBit(ku, 4) == false)) {
611                                 return CheckResult.EXTENSION_MISMATCH;
612                             }
613                             break;
614                     }
615                 }
616             } catch (CertificateException e) {
617                 // extensions unparseable, return failure
618                 return CheckResult.EXTENSION_MISMATCH;
619             }
620 
621             try {
622                 cert.checkValidity(date);
623             } catch (CertificateException e) {
624                 return CheckResult.EXPIRED;
625             }
626 
627             if (serverNames != null &amp;&amp; !serverNames.isEmpty()) {
628                 for (SNIServerName serverName : serverNames) {
629                     if (serverName.getType() ==
630                                 StandardConstants.SNI_HOST_NAME) {
631                         if (!(serverName instanceof SNIHostName)) {
632                             try {
633                                 serverName =
634                                     new SNIHostName(serverName.getEncoded());
635                             } catch (IllegalArgumentException iae) {
636                                 // unlikely to happen, just in case ...
637                                 if (SSLLogger.isOn &amp;&amp;
638                                         SSLLogger.isOn(&quot;keymanager&quot;)) {
639                                     SSLLogger.fine(
640                                        &quot;Illegal server name: &quot; + serverName);
641                                 }
642 
643                                 return CheckResult.INSENSITIVE;
644                             }
645                         }
646                         String hostname =
647                                 ((SNIHostName)serverName).getAsciiName();
648 
649                         try {
650                             X509TrustManagerImpl.checkIdentity(hostname,
651                                                         cert, idAlgorithm);
652                         } catch (CertificateException e) {
653                             if (SSLLogger.isOn &amp;&amp;
654                                     SSLLogger.isOn(&quot;keymanager&quot;)) {
655                                 SSLLogger.fine(
656                                     &quot;Certificate identity does not match &quot; +
657                                     &quot;Server Name Inidication (SNI): &quot; +
658                                     hostname);
659                             }
660                             return CheckResult.INSENSITIVE;
661                         }
662 
663                         break;
664                     }
665                 }
666             }
667 
668             return CheckResult.OK;
669         }
670 
671         public String getValidator() {
672             if (this == CLIENT) {
673                 return Validator.VAR_TLS_CLIENT;
674             } else if (this == SERVER) {
675                 return Validator.VAR_TLS_SERVER;
676             }
677             return Validator.VAR_GENERIC;
678         }
679     }
680 
681     // enum for the result of the extension check
682     // NOTE: the order of the constants is important as they are used
683     // for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH
684     private static enum CheckResult {
685         OK,                     // ok or not checked
686         INSENSITIVE,            // server name indication insensitive
687         EXPIRED,                // extensions valid but cert expired
688         EXTENSION_MISMATCH,     // extensions invalid (expiration not checked)
689     }
690 
691     /*
692      * Return a List of all candidate matches in the specified builder
693      * that fit the parameters.
694      * We exclude entries in the KeyStore if they are not:
695      *  . private key entries
696      *  . the certificates are not X509 certificates
697      *  . the algorithm of the key in the EE cert doesn&#39;t match one of keyTypes
698      *  . none of the certs is issued by a Principal in issuerSet
699      * Using those entries would not be possible or they would almost
700      * certainly be rejected by the peer.
701      *
702      * In addition to those checks, we also check the extensions in the EE
703      * cert and its expiration. Even if there is a mismatch, we include
704      * such certificates because they technically work and might be accepted
705      * by the peer. This leads to more graceful failure and better error
706      * messages if the cert expires from one day to the next.
707      *
708      * The return values are:
709      *   . null, if there are no matching entries at all
710      *   . if &#39;findAll&#39; is &#39;false&#39; and there is a perfect match, a List
711      *     with a single element (early return)
712      *   . if &#39;findAll&#39; is &#39;false&#39; and there is NO perfect match, a List
713      *     with all the imperfect matches (expired, wrong extensions)
714      *   . if &#39;findAll&#39; is &#39;true&#39;, a List with all perfect and imperfect
715      *     matches
716      */
717     private List&lt;EntryStatus&gt; getAliases(int builderIndex,
718             List&lt;KeyType&gt; keyTypes, Set&lt;Principal&gt; issuerSet,
719             boolean findAll, CheckType checkType,
720             AlgorithmConstraints constraints,
721             List&lt;SNIServerName&gt; requestedServerNames,
722             String idAlgorithm) throws Exception {
723 
724         Builder builder = builders.get(builderIndex);
725         KeyStore ks = builder.getKeyStore();
726         List&lt;EntryStatus&gt; results = null;
727         Date date = verificationDate;
728         boolean preferred = false;
729         for (Enumeration&lt;String&gt; e = ks.aliases(); e.hasMoreElements(); ) {
730             String alias = e.nextElement();
731             // check if it is a key entry (private key or secret key)
732             if (!ks.isKeyEntry(alias)) {
733                 continue;
734             }
735 
736             Certificate[] chain = ks.getCertificateChain(alias);
737             if ((chain == null) || (chain.length == 0)) {
738                 // must be secret key entry, ignore
739                 continue;
740             }
741 
742             boolean incompatible = false;
743             for (Certificate cert : chain) {
744                 if (cert instanceof X509Certificate == false) {
745                     // not an X509Certificate, ignore this alias
746                     incompatible = true;
747                     break;
748                 }
749             }
750             if (incompatible) {
751                 continue;
752             }
753 
754             // check keytype
755             int keyIndex = -1;
756             int j = 0;
757             for (KeyType keyType : keyTypes) {
758                 if (keyType.matches(chain)) {
759                     keyIndex = j;
760                     break;
761                 }
762                 j++;
763             }
764             if (keyIndex == -1) {
765                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
766                     SSLLogger.fine(&quot;Ignore alias &quot; + alias
767                                 + &quot;: key algorithm does not match&quot;);
768                 }
769                 continue;
770             }
771             // check issuers
772             if (issuerSet != null) {
773                 boolean found = false;
774                 for (Certificate cert : chain) {
775                     X509Certificate xcert = (X509Certificate)cert;
776                     if (issuerSet.contains(xcert.getIssuerX500Principal())) {
777                         found = true;
778                         break;
779                     }
780                 }
781                 if (found == false) {
782                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
783                         SSLLogger.fine(
784                                 &quot;Ignore alias &quot; + alias
785                                 + &quot;: issuers do not match&quot;);
786                     }
787                     continue;
788                 }
789             }
790 
791             // check the algorithm constraints
792             if (constraints != null &amp;&amp;
793                     !conformsToAlgorithmConstraints(constraints, chain,
794                             checkType.getValidator())) {
795 
796                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
797                     SSLLogger.fine(&quot;Ignore alias &quot; + alias +
798                             &quot;: certificate list does not conform to &quot; +
799                             &quot;algorithm constraints&quot;);
800                 }
801                 continue;
802             }
803 
804             if (date == null) {
805                 date = new Date();
806             }
807             CheckResult checkResult =
808                     checkType.check((X509Certificate)chain[0], date,
809                                     requestedServerNames, idAlgorithm);
810             EntryStatus status =
811                     new EntryStatus(builderIndex, keyIndex,
812                                         alias, chain, checkResult);
813             if (!preferred &amp;&amp; checkResult == CheckResult.OK &amp;&amp; keyIndex == 0) {
814                 preferred = true;
815             }
816             if (preferred &amp;&amp; (findAll == false)) {
817                 // if we have a good match and do not need all matches,
818                 // return immediately
819                 return Collections.singletonList(status);
820             } else {
821                 if (results == null) {
822                     results = new ArrayList&lt;&gt;();
823                 }
824                 results.add(status);
825             }
826         }
827         return results;
828     }
829 
830     private static boolean conformsToAlgorithmConstraints(
831             AlgorithmConstraints constraints, Certificate[] chain,
832             String variant) {
833 
834         AlgorithmChecker checker =
835                 new AlgorithmChecker(constraints, null, variant);
836         try {
837             checker.init(false);
838         } catch (CertPathValidatorException cpve) {
839             // unlikely to happen
840             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
841                 SSLLogger.fine(
842                     &quot;Cannot initialize algorithm constraints checker&quot;, cpve);
843             }
844 
845             return false;
846         }
847 
848         // It is a forward checker, so we need to check from trust to target.
849         for (int i = chain.length - 1; i &gt;= 0; i--) {
850             Certificate cert = chain[i];
851             try {
852                 // We don&#39;t care about the unresolved critical extensions.
853                 checker.check(cert, Collections.&lt;String&gt;emptySet());
854             } catch (CertPathValidatorException cpve) {
855                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
856                     SSLLogger.fine(&quot;Certificate does not conform to &quot; +
857                             &quot;algorithm constraints&quot;, cert, cpve);
858                 }
859 
860                 return false;
861             }
862         }
863 
864         return true;
865     }
866 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
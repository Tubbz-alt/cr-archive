<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/OutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="NewSessionTicket.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/OutputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,11 @@</span>
  import java.io.ByteArrayOutputStream;
  import java.io.Closeable;
  import java.io.IOException;
  import java.io.OutputStream;
  import java.nio.ByteBuffer;
<span class="udiff-line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import sun.security.ssl.SSLCipher.SSLWriteCipher;
  
  /**
   * {@code OutputRecord} takes care of the management of SSL/(D)TLS
   * output records, including buffering, encryption, handshake
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,15 +62,17 @@</span>
  
      // packet size
      int                         packetSize;
  
      // fragment size
<span class="udiff-line-modified-removed">-     int                         fragmentSize;</span>
<span class="udiff-line-modified-added">+     private int                 fragmentSize;</span>
  
      // closed or not?
      volatile boolean            isClosed;
  
<span class="udiff-line-added">+     final ReentrantLock recordLock = new ReentrantLock();</span>
<span class="udiff-line-added">+ </span>
      /*
       * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
       * This is taken from the SSL V3 specification, Appendix E.
       */
      private static final int[] V3toV2CipherMap1 =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,32 +90,47 @@</span>
          this.handshakeHash = handshakeHash;
  
          // Please set packetSize and protocolVersion in the implementation.
      }
  
<span class="udiff-line-modified-removed">-     synchronized void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="udiff-line-modified-removed">-         this.protocolVersion = protocolVersion;</span>
<span class="udiff-line-modified-added">+     void setVersion(ProtocolVersion protocolVersion) {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.protocolVersion = protocolVersion;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /*
       * Updates helloVersion of this record.
       */
<span class="udiff-line-modified-removed">-     synchronized void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="udiff-line-modified-removed">-         this.helloVersion = helloVersion;</span>
<span class="udiff-line-modified-added">+     void setHelloVersion(ProtocolVersion helloVersion) {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.helloVersion = helloVersion;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /*
       * Return true iff the record is empty -- to avoid doing the work
       * of sending empty records over the network.
       */
      boolean isEmpty() {
          return false;
      }
  
<span class="udiff-line-modified-removed">-     synchronized boolean seqNumIsHuge() {</span>
<span class="udiff-line-modified-removed">-         return (writeCipher.authenticator != null) &amp;&amp;</span>
<span class="udiff-line-modified-added">+     boolean seqNumIsHuge() {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return (writeCipher.authenticator != null) &amp;&amp;</span>
                          writeCipher.authenticator.seqNumIsHuge();
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      // SSLEngine and SSLSocket
      abstract void encodeAlert(byte level, byte description) throws IOException;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146,72 +164,97 @@</span>
      void setDeliverStream(OutputStream outputStream) {
          throw new UnsupportedOperationException();
      }
  
      // Change write ciphers, may use change_cipher_spec record.
<span class="udiff-line-modified-removed">-     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
<span class="udiff-line-modified-added">+     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              boolean useChangeCipherSpec) throws IOException {
<span class="udiff-line-modified-removed">-         if (isClosed()) {</span>
<span class="udiff-line-modified-removed">-             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="udiff-line-modified-removed">-                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="udiff-line-modified-removed">-                     &quot;change_cipher_spec message&quot;);</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             if (isClosed()) {</span>
<span class="udiff-line-modified-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="udiff-line-added">+                         &quot;change_cipher_spec message&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return;</span>
              }
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         if (useChangeCipherSpec) {</span>
<span class="udiff-line-modified-removed">-             encodeChangeCipherSpec();</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /*</span>
<span class="udiff-line-removed">-          * Dispose of any intermediate state in the underlying cipher.</span>
<span class="udiff-line-removed">-          * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="udiff-line-removed">-          * and thus make finalization faster.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="udiff-line-removed">-          * not necessary to do the same with MAC&#39;s.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         writeCipher.dispose();</span>
<span class="udiff-line-modified-added">+             if (useChangeCipherSpec) {</span>
<span class="udiff-line-modified-added">+                 encodeChangeCipherSpec();</span>
<span class="udiff-line-modified-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         this.writeCipher = writeCipher;</span>
<span class="udiff-line-modified-removed">-         this.isFirstAppOutputRecord = true;</span>
<span class="udiff-line-modified-added">+             /*</span>
<span class="udiff-line-modified-added">+              * Dispose of any intermediate state in the underlying cipher.</span>
<span class="udiff-line-added">+              * For PKCS11 ciphers, this will release any attached sessions,</span>
<span class="udiff-line-added">+              * and thus make finalization faster.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * Since MAC&#39;s doFinal() is called for every SSL/TLS packet, it&#39;s</span>
<span class="udiff-line-added">+              * not necessary to do the same with MAC&#39;s.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             writeCipher.dispose();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             this.writeCipher = writeCipher;</span>
<span class="udiff-line-added">+             this.isFirstAppOutputRecord = true;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      // Change write ciphers using key_update handshake message.
<span class="udiff-line-modified-removed">-     synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
<span class="udiff-line-modified-added">+     void changeWriteCiphers(SSLWriteCipher writeCipher,</span>
              byte keyUpdateRequest) throws IOException {
<span class="udiff-line-modified-removed">-         if (isClosed()) {</span>
<span class="udiff-line-modified-removed">-             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="udiff-line-modified-removed">-                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="udiff-line-modified-removed">-                     &quot;key_update handshake message&quot;);</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             if (isClosed()) {</span>
<span class="udiff-line-modified-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="udiff-line-added">+                         &quot;key_update handshake message&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return;</span>
              }
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         // encode the handshake message, KeyUpdate</span>
<span class="udiff-line-modified-removed">-         byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="udiff-line-modified-removed">-         hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="udiff-line-modified-removed">-         encodeHandshake(hm, 0, hm.length);</span>
<span class="udiff-line-modified-removed">-         flush();</span>
<span class="udiff-line-modified-added">+             // encode the handshake message, KeyUpdate</span>
<span class="udiff-line-modified-added">+             byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();</span>
<span class="udiff-line-modified-added">+             hm[hm.length - 1] = keyUpdateRequest;</span>
<span class="udiff-line-modified-added">+             encodeHandshake(hm, 0, hm.length);</span>
<span class="udiff-line-modified-added">+             flush();</span>
  
<span class="udiff-line-modified-removed">-         // Dispose of any intermediate state in the underlying cipher.</span>
<span class="udiff-line-modified-removed">-         writeCipher.dispose();</span>
<span class="udiff-line-modified-added">+             // Dispose of any intermediate state in the underlying cipher.</span>
<span class="udiff-line-modified-added">+             writeCipher.dispose();</span>
  
<span class="udiff-line-modified-removed">-         this.writeCipher = writeCipher;</span>
<span class="udiff-line-modified-removed">-         this.isFirstAppOutputRecord = true;</span>
<span class="udiff-line-modified-added">+             this.writeCipher = writeCipher;</span>
<span class="udiff-line-modified-added">+             this.isFirstAppOutputRecord = true;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized void changePacketSize(int packetSize) {</span>
<span class="udiff-line-modified-removed">-         this.packetSize = packetSize;</span>
<span class="udiff-line-modified-added">+     void changePacketSize(int packetSize) {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.packetSize = packetSize;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized void changeFragmentSize(int fragmentSize) {</span>
<span class="udiff-line-modified-removed">-         this.fragmentSize = fragmentSize;</span>
<span class="udiff-line-modified-added">+     void changeFragmentSize(int fragmentSize) {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.fragmentSize = fragmentSize;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized int getMaxPacketSize() {</span>
<span class="udiff-line-modified-removed">-         return packetSize;</span>
<span class="udiff-line-modified-added">+     int getMaxPacketSize() {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return packetSize;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      // apply to DTLS SSLEngine
      void initHandshaker() {
          // blank
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,27 +269,50 @@</span>
      void launchRetransmission() {
          // blank
      }
  
      @Override
<span class="udiff-line-modified-removed">-     public synchronized void close() throws IOException {</span>
<span class="udiff-line-modified-removed">-         if (isClosed) {</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     public void close() throws IOException {</span>
<span class="udiff-line-modified-added">+         recordLock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             if (isClosed) {</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         isClosed = true;</span>
<span class="udiff-line-modified-removed">-         writeCipher.dispose();</span>
<span class="udiff-line-modified-added">+             isClosed = true;</span>
<span class="udiff-line-modified-added">+             writeCipher.dispose();</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             recordLock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      boolean isClosed() {
          return isClosed;
      }
  
      //
      // shared helpers
      //
  
<span class="udiff-line-added">+     private static final class T13PaddingHolder {</span>
<span class="udiff-line-added">+         private static final byte[] zeros = new byte[16];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int calculateFragmentSize(int fragmentLimit) {</span>
<span class="udiff-line-added">+         if (fragmentSize &gt; 0) {</span>
<span class="udiff-line-added">+             fragmentLimit = Math.min(fragmentLimit, fragmentSize);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (protocolVersion.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+             // No negative integer checking as the fragment capacity should</span>
<span class="udiff-line-added">+             // have been ensured.</span>
<span class="udiff-line-added">+             return fragmentLimit -  T13PaddingHolder.zeros.length - 1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return fragmentLimit;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Encrypt a fragment and wrap up a record.
      //
      // To be consistent with the spec of SSLEngine.wrap() methods, the
      // destination ByteBuffer&#39;s position is updated to reflect the amount
      // of data produced.  The limit remains the same.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -324,12 +390,16 @@</span>
              int headerOffset, int dstLim, int headerSize,
              ProtocolVersion protocolVersion) {
          if (!encCipher.isNullCipher()) {
              // inner plaintext, using zero length padding.
              int endOfPt = destination.limit();
<span class="udiff-line-modified-removed">-             destination.limit(endOfPt + 1);</span>
<span class="udiff-line-modified-removed">-             destination.put(endOfPt, contentType);</span>
<span class="udiff-line-modified-added">+             int startOfPt = destination.position();</span>
<span class="udiff-line-modified-added">+             destination.position(endOfPt);</span>
<span class="udiff-line-added">+             destination.limit(endOfPt + 1 + T13PaddingHolder.zeros.length);</span>
<span class="udiff-line-added">+             destination.put(contentType);</span>
<span class="udiff-line-added">+             destination.put(T13PaddingHolder.zeros);</span>
<span class="udiff-line-added">+             destination.position(startOfPt);</span>
          }
  
          // use the right TLSCiphertext.opaque_type and legacy_record_version
          ProtocolVersion pv = protocolVersion;
          if (!encCipher.isNullCipher()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,14 +463,10 @@</span>
          } else {
              return t10Encrypt(encCipher, contentType, headerSize);
          }
      }
  
<span class="udiff-line-removed">-     private static final class T13PaddingHolder {</span>
<span class="udiff-line-removed">-         private static final byte[] zeros = new byte[16];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      private long t13Encrypt(
              SSLWriteCipher encCipher, byte contentType, int headerSize) {
          if (!encCipher.isNullCipher()) {
              // inner plaintext
              write(contentType);
</pre>
<center><a href="NewSessionTicket.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PostHandshakeContext.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/sun/net/www/ParseUtil.java b/src/java.base/share/classes/sun/net/www/ParseUtil.java
--- a/src/java.base/share/classes/sun/net/www/ParseUtil.java
+++ b/src/java.base/share/classes/sun/net/www/ParseUtil.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,23 +24,24 @@
  */
 
 package sun.net.www;
 
 import java.io.File;
-import java.net.URL;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
-
-import sun.nio.cs.ThreadLocalCoders;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CoderResult;
 import java.nio.charset.CodingErrorAction;
 
+import sun.nio.cs.ThreadLocalCoders;
+import sun.nio.cs.UTF_8;
+
 /**
  * A class that contains useful routines common to sun.net.www
  * @author  Mike McCloskey
  */
 
@@ -144,11 +145,11 @@
         return new String(retCC, 0, retLen);
     }
 
     /**
      * Appends the URL escape sequence for the specified char to the
-     * specified StringBuffer.
+     * specified character array.
      */
     private static int escape(char[] cc, char c, int index) {
         cc[index++] = '%';
         cc[index++] = Character.forDigit((c >> 4) & 0xF, 16);
         cc[index++] = Character.forDigit(c & 0xF, 16);
@@ -174,11 +175,11 @@
             return s;
 
         StringBuilder sb = new StringBuilder(n);
         ByteBuffer bb = ByteBuffer.allocate(n);
         CharBuffer cb = CharBuffer.allocate(n);
-        CharsetDecoder dec = ThreadLocalCoders.decoderFor("UTF-8")
+        CharsetDecoder dec = ThreadLocalCoders.decoderFor(UTF_8.INSTANCE)
             .onMalformedInput(CodingErrorAction.REPORT)
             .onUnmappableCharacter(CodingErrorAction.REPORT);
 
         char c = s.charAt(0);
         for (int i = 0; i < n;) {
@@ -334,11 +335,11 @@
                             int port,
                             String path,
                             String query,
                             String fragment)
     {
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
         if (scheme != null) {
             sb.append(scheme);
             sb.append(':');
         }
         appendSchemeSpecificPart(sb, opaquePart,
@@ -346,11 +347,11 @@
                                  path, query);
         appendFragment(sb, fragment);
         return sb.toString();
     }
 
-    private static void appendSchemeSpecificPart(StringBuffer sb,
+    private static void appendSchemeSpecificPart(StringBuilder sb,
                                           String opaquePart,
                                           String authority,
                                           String userInfo,
                                           String host,
                                           int port,
@@ -387,11 +388,11 @@
                 sb.append(quote(query, L_URIC, H_URIC));
             }
         }
     }
 
-    private static void appendAuthority(StringBuffer sb,
+    private static void appendAuthority(StringBuilder sb,
                                  String authority,
                                  String userInfo,
                                  String host,
                                  int port)
     {
@@ -435,11 +436,11 @@
                             H_REG_NAME | H_SERVER));
             }
         }
     }
 
-    private static void appendFragment(StringBuffer sb, String fragment) {
+    private static void appendFragment(StringBuilder sb, String fragment) {
         if (fragment != null) {
             sb.append('#');
             sb.append(quote(fragment, L_URIC, H_URIC));
         }
     }
@@ -447,18 +448,18 @@
     // Quote any characters in s that are not permitted
     // by the given mask pair
     //
     private static String quote(String s, long lowMask, long highMask) {
         int n = s.length();
-        StringBuffer sb = null;
+        StringBuilder sb = null;
         boolean allowNonASCII = ((lowMask & L_ESCAPED) != 0);
         for (int i = 0; i < s.length(); i++) {
             char c = s.charAt(i);
             if (c < '\u0080') {
                 if (!match(c, lowMask, highMask) && !isEscaped(s, i)) {
                     if (sb == null) {
-                        sb = new StringBuffer();
+                        sb = new StringBuilder();
                         sb.append(s, 0, i);
                     }
                     appendEscape(sb, (byte)c);
                 } else {
                     if (sb != null)
@@ -466,11 +467,11 @@
                 }
             } else if (allowNonASCII
                        && (Character.isSpaceChar(c)
                            || Character.isISOControl(c))) {
                 if (sb == null) {
-                    sb = new StringBuffer();
+                    sb = new StringBuilder();
                     sb.append(s, 0, i);
                 }
                 appendEncoded(sb, c);
             } else {
                 if (sb != null)
@@ -491,14 +492,14 @@
         return s.charAt(pos) == '%'
                && match(s.charAt(pos + 1), L_HEX, H_HEX)
                && match(s.charAt(pos + 2), L_HEX, H_HEX);
     }
 
-    private static void appendEncoded(StringBuffer sb, char c) {
+    private static void appendEncoded(StringBuilder sb, char c) {
         ByteBuffer bb = null;
         try {
-            bb = ThreadLocalCoders.encoderFor("UTF-8")
+            bb = ThreadLocalCoders.encoderFor(UTF_8.INSTANCE)
                 .encode(CharBuffer.wrap("" + c));
         } catch (CharacterCodingException x) {
             assert false;
         }
         while (bb.hasRemaining()) {
@@ -513,11 +514,11 @@
     private static final char[] hexDigits = {
         '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
     };
 
-    private static void appendEscape(StringBuffer sb, byte b) {
+    private static void appendEscape(StringBuilder sb, byte b) {
         sb.append('%');
         sb.append(hexDigits[(b >> 4) & 0x0f]);
         sb.append(hexDigits[(b >> 0) & 0x0f]);
     }
 

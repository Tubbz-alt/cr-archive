<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DerOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DisabledAlgorithmConstraints.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;

 30 import java.util.Date;
 31 


 32 /**
 33  * Represents a single DER-encoded value.  DER encoding rules are a subset
 34  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 35  * (&quot;Definite&quot; encoding) to encode any given value.
 36  *
 37  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 38  * class represents such tagged values as they have been read (or constructed),
 39  * and provides structured access to the encoded data.
 40  *
 41  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 42  * data encodings which are defined.  That subset is sufficient for parsing
 43  * most X.509 certificates, and working with selected additional formats
 44  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 45  *
 46  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 47  * and RFC 5280, section 8, we assume that this kind of string will contain
 48  * ISO-8859-1 characters only.
 49  *
 50  *
 51  * @author David Brownell
</pre>
<hr />
<pre>
187     }
188 
189     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
190 
191     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
192     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
193 
194     /**
195      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
196      */
197     public boolean isConstructed(byte constructedTag) {
198         if (!isConstructed()) {
199             return false;
200         }
201         return ((tag &amp; 0x01f) == constructedTag);
202     }
203 
204     /**
205      * Creates a PrintableString or UTF8string DER value from a string
206      */
<span class="line-modified">207     public DerValue(String value) throws IOException {</span>
208         boolean isPrintableString = true;
209         for (int i = 0; i &lt; value.length(); i++) {
210             if (!isPrintableStringChar(value.charAt(i))) {
211                 isPrintableString = false;
212                 break;
213             }
214         }
215 
216         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
217     }
218 
219     /**
220      * Creates a string type DER value from a String object
221      * @param stringTag the tag for the DER value to create
222      * @param value the String object to use for the DER value
223      */
<span class="line-modified">224     public DerValue(byte stringTag, String value) throws IOException {</span>
225         data = init(stringTag, value);
226     }
227 
228     // Creates a DerValue from a tag and some DER-encoded data w/ additional
229     // arg to control whether DER checks are enforced.
230     DerValue(byte tag, byte[] data, boolean allowBER) {
231         this.tag = tag;
232         buffer = new DerInputBuffer(data.clone(), allowBER);
233         length = data.length;
234         this.data = new DerInputStream(buffer);
235         this.data.mark(Integer.MAX_VALUE);
236     }
237 
238     /**
239      * Creates a DerValue from a tag and some DER-encoded data.
240      *
241      * @param tag the DER type tag
242      * @param data the DER-encoded data
243      */
244     public DerValue(byte tag, byte[] data) {
245         this(tag, data, true);
246     }
247 
248     /*
249      * package private
250      */
251     DerValue(DerInputBuffer in) throws IOException {
252 
253         // XXX must also parse BER-encoded constructed
254         // values such as sequences, sets...
255         tag = (byte)in.read();
256         byte lenByte = (byte)in.read();
257         length = DerInputStream.getLength(lenByte, in);
258         if (length == -1) {  // indefinite length encoding found
259             DerInputBuffer inbuf = in.dup();
<span class="line-modified">260             int readLen = inbuf.available();</span>
<span class="line-modified">261             int offset = 2;     // for tag and length bytes</span>
<span class="line-modified">262             byte[] indefData = new byte[readLen + offset];</span>
<span class="line-removed">263             indefData[0] = tag;</span>
<span class="line-removed">264             indefData[1] = lenByte;</span>
<span class="line-removed">265             DataInputStream dis = new DataInputStream(inbuf);</span>
<span class="line-removed">266             dis.readFully(indefData, offset, readLen);</span>
<span class="line-removed">267             dis.close();</span>
<span class="line-removed">268             DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-removed">269             inbuf = new DerInputBuffer(derIn.convert(indefData), in.allowBER);</span>
270             if (tag != inbuf.read())
271                 throw new IOException
272                         (&quot;Indefinite length encoding not supported&quot;);
273             length = DerInputStream.getDefiniteLength(inbuf);
274             buffer = inbuf.dup();
275             buffer.truncate(length);
276             data = new DerInputStream(buffer);
277             // indefinite form is encoded by sending a length field with a
278             // length of 0. - i.e. [1000|0000].
279             // the object is ended by sending two zero bytes.
<span class="line-modified">280             in.skip(length + offset);</span>
281         } else {
282 
283             buffer = in.dup();
284             buffer.truncate(length);
285             data = new DerInputStream(buffer);
286 
287             in.skip(length);
288         }
289     }
290 
291     // Get an ASN.1/DER encoded datum from a buffer w/ additional
292     // arg to control whether DER checks are enforced.
293     DerValue(byte[] buf, boolean allowBER) throws IOException {
294         data = init(true, new ByteArrayInputStream(buf), allowBER);
295     }
296 
297     /**
298      * Get an ASN.1/DER encoded datum from a buffer.  The
299      * entire buffer must hold exactly one datum, including
300      * its tag and length.
</pre>
<hr />
<pre>
327 
328     // Get an ASN1/DER encoded datum from an input stream w/ additional
329     // arg to control whether DER checks are enforced.
330     DerValue(InputStream in, boolean allowBER) throws IOException {
331         data = init(false, in, allowBER);
332     }
333 
334     /**
335      * Get an ASN1/DER encoded datum from an input stream.  The
336      * stream may have additional data following the encoded datum.
337      * In case of indefinite length encoded datum, the input stream
338      * must hold only one datum.
339      *
340      * @param in the input stream holding a single DER datum,
341      *  which may be followed by additional data
342      */
343     public DerValue(InputStream in) throws IOException {
344         this(in, true);
345     }
346 
<span class="line-modified">347     private DerInputStream init(byte stringTag, String value)</span>
<span class="line-modified">348         throws IOException {</span>
<span class="line-removed">349         String enc = null;</span>
350 
351         tag = stringTag;
352 
353         switch (stringTag) {
354         case tag_PrintableString:
355         case tag_IA5String:
356         case tag_GeneralString:
<span class="line-modified">357             enc = &quot;ASCII&quot;;</span>
358             break;
359         case tag_T61String:
<span class="line-modified">360             enc = &quot;ISO-8859-1&quot;;</span>
361             break;
362         case tag_BMPString:
<span class="line-modified">363             enc = &quot;UnicodeBigUnmarked&quot;;</span>
364             break;
365         case tag_UTF8String:
<span class="line-modified">366             enc = &quot;UTF8&quot;;</span>
367             break;
368             // TBD: Need encoder for UniversalString before it can
369             // be handled.
370         default:
371             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
372         }
373 
<span class="line-modified">374         byte[] buf = value.getBytes(enc);</span>
375         length = buf.length;
376         buffer = new DerInputBuffer(buf, true);
377         DerInputStream result = new DerInputStream(buffer);
378         result.mark(Integer.MAX_VALUE);
379         return result;
380     }
381 
382     /*
383      * helper routine
384      */
385     private DerInputStream init(boolean fullyBuffered, InputStream in,
386         boolean allowBER) throws IOException {
387 
388         tag = (byte)in.read();
389         byte lenByte = (byte)in.read();
390         length = DerInputStream.getLength(lenByte, in);
391         if (length == -1) { // indefinite length encoding found
<span class="line-modified">392             int readLen = in.available();</span>
<span class="line-modified">393             int offset = 2;     // for tag and length bytes</span>
<span class="line-removed">394             byte[] indefData = new byte[readLen + offset];</span>
<span class="line-removed">395             indefData[0] = tag;</span>
<span class="line-removed">396             indefData[1] = lenByte;</span>
<span class="line-removed">397             DataInputStream dis = new DataInputStream(in);</span>
<span class="line-removed">398             dis.readFully(indefData, offset, readLen);</span>
<span class="line-removed">399             dis.close();</span>
<span class="line-removed">400             DerIndefLenConverter derIn = new DerIndefLenConverter();</span>
<span class="line-removed">401             in = new ByteArrayInputStream(derIn.convert(indefData));</span>
402             if (tag != in.read())
403                 throw new IOException
404                         (&quot;Indefinite length encoding not supported&quot;);
405             length = DerInputStream.getDefiniteLength(in);
406         }
407 
408         if (fullyBuffered &amp;&amp; in.available() != length)
409             throw new IOException(&quot;extra data given to DerValue constructor&quot;);
410 
<span class="line-modified">411         byte[] bytes = IOUtils.readFully(in, length, true);</span>
412 
413         buffer = new DerInputBuffer(bytes, allowBER);
414         return new DerInputStream(buffer);
415     }
416 
417     /**
418      * Encode an ASN1/DER encoded datum onto a DER output stream.
419      */
420     public void encode(DerOutputStream out)
421     throws IOException {
422         out.write(tag);
423         out.putLength(length);
424         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
425         if (length &gt; 0) {
426             byte[] value = new byte[length];
427             // always synchronized on data
428             synchronized (data) {
429                 buffer.reset();
430                 if (buffer.read(value) != length) {
431                     throw new IOException(&quot;short DER value read (encode)&quot;);
</pre>
<hr />
<pre>
663     public byte[] getDataBytes() throws IOException {
664         byte[] retVal = new byte[length];
665         synchronized (data) {
666             data.reset();
667             data.getBytes(retVal);
668         }
669         return retVal;
670     }
671 
672     /**
673      * Returns an ASN.1 STRING value
674      *
675      * @return the printable string held in this value
676      */
677     public String getPrintableString()
678     throws IOException {
679         if (tag != tag_PrintableString)
680             throw new IOException(
681                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
682 
<span class="line-modified">683         return new String(getDataBytes(), &quot;ASCII&quot;);</span>
684     }
685 
686     /**
687      * Returns an ASN.1 T61 (Teletype) STRING value
688      *
689      * @return the teletype string held in this value
690      */
691     public String getT61String() throws IOException {
692         if (tag != tag_T61String)
693             throw new IOException(
694                 &quot;DerValue.getT61String, not T61 &quot; + tag);
695 
<span class="line-modified">696         return new String(getDataBytes(), &quot;ISO-8859-1&quot;);</span>
697     }
698 
699     /**
700      * Returns an ASN.1 IA5 (ASCII) STRING value
701      *
702      * @return the ASCII string held in this value
703      */
704     public String getIA5String() throws IOException {
705         if (tag != tag_IA5String)
706             throw new IOException(
707                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
708 
<span class="line-modified">709         return new String(getDataBytes(), &quot;ASCII&quot;);</span>
710     }
711 
712     /**
713      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
714      *
715      * @return a string corresponding to the encoded BMPString held in
716      * this value
717      */
718     public String getBMPString() throws IOException {
719         if (tag != tag_BMPString)
720             throw new IOException(
721                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
722 
723         // BMPString is the same as Unicode in big endian, unmarked
724         // format.
<span class="line-modified">725         return new String(getDataBytes(), &quot;UnicodeBigUnmarked&quot;);</span>
726     }
727 
728     /**
729      * Returns the ASN.1 UTF-8 STRING value as a Java String.
730      *
731      * @return a string corresponding to the encoded UTF8String held in
732      * this value
733      */
734     public String getUTF8String() throws IOException {
735         if (tag != tag_UTF8String)
736             throw new IOException(
737                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
738 
<span class="line-modified">739         return new String(getDataBytes(), &quot;UTF8&quot;);</span>
740     }
741 
742     /**
743      * Returns the ASN.1 GENERAL STRING value as a Java String.
744      *
745      * @return a string corresponding to the encoded GeneralString held in
746      * this value
747      */
748     public String getGeneralString() throws IOException {
749         if (tag != tag_GeneralString)
750             throw new IOException(
751                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
752 
<span class="line-modified">753         return new String(getDataBytes(), &quot;ASCII&quot;);</span>
754     }
755 
756     /**
757      * Returns a Date if the DerValue is UtcTime.
758      *
759      * @return the Date held in this DER value
760      */
761     public Date getUTCTime() throws IOException {
762         if (tag != tag_UtcTime) {
763             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
764         }
765         return buffer.getUTCTime(data.available());
766     }
767 
768     /**
769      * Returns a Date if the DerValue is GeneralizedTime.
770      *
771      * @return the Date held in this DER value
772      */
773     public Date getGeneralizedTime() throws IOException {
</pre>
</td>
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
<span class="line-added"> 30 import java.nio.charset.Charset;</span>
 31 import java.util.Date;
 32 
<span class="line-added"> 33 import static java.nio.charset.StandardCharsets.*;</span>
<span class="line-added"> 34 </span>
 35 /**
 36  * Represents a single DER-encoded value.  DER encoding rules are a subset
 37  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 38  * (&quot;Definite&quot; encoding) to encode any given value.
 39  *
 40  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 41  * class represents such tagged values as they have been read (or constructed),
 42  * and provides structured access to the encoded data.
 43  *
 44  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 45  * data encodings which are defined.  That subset is sufficient for parsing
 46  * most X.509 certificates, and working with selected additional formats
 47  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 48  *
 49  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 50  * and RFC 5280, section 8, we assume that this kind of string will contain
 51  * ISO-8859-1 characters only.
 52  *
 53  *
 54  * @author David Brownell
</pre>
<hr />
<pre>
190     }
191 
192     boolean isPrivate()        { return ((tag &amp; 0x0c0) == 0x0c0); }
193 
194     /** Returns true iff the CONSTRUCTED bit is set in the type tag. */
195     public boolean isConstructed()    { return ((tag &amp; 0x020) == 0x020); }
196 
197     /**
198      * Returns true iff the CONSTRUCTED TAG matches the passed tag.
199      */
200     public boolean isConstructed(byte constructedTag) {
201         if (!isConstructed()) {
202             return false;
203         }
204         return ((tag &amp; 0x01f) == constructedTag);
205     }
206 
207     /**
208      * Creates a PrintableString or UTF8string DER value from a string
209      */
<span class="line-modified">210     public DerValue(String value) {</span>
211         boolean isPrintableString = true;
212         for (int i = 0; i &lt; value.length(); i++) {
213             if (!isPrintableStringChar(value.charAt(i))) {
214                 isPrintableString = false;
215                 break;
216             }
217         }
218 
219         data = init(isPrintableString ? tag_PrintableString : tag_UTF8String, value);
220     }
221 
222     /**
223      * Creates a string type DER value from a String object
224      * @param stringTag the tag for the DER value to create
225      * @param value the String object to use for the DER value
226      */
<span class="line-modified">227     public DerValue(byte stringTag, String value) {</span>
228         data = init(stringTag, value);
229     }
230 
231     // Creates a DerValue from a tag and some DER-encoded data w/ additional
232     // arg to control whether DER checks are enforced.
233     DerValue(byte tag, byte[] data, boolean allowBER) {
234         this.tag = tag;
235         buffer = new DerInputBuffer(data.clone(), allowBER);
236         length = data.length;
237         this.data = new DerInputStream(buffer);
238         this.data.mark(Integer.MAX_VALUE);
239     }
240 
241     /**
242      * Creates a DerValue from a tag and some DER-encoded data.
243      *
244      * @param tag the DER type tag
245      * @param data the DER-encoded data
246      */
247     public DerValue(byte tag, byte[] data) {
248         this(tag, data, true);
249     }
250 
251     /*
252      * package private
253      */
254     DerValue(DerInputBuffer in) throws IOException {
255 
256         // XXX must also parse BER-encoded constructed
257         // values such as sequences, sets...
258         tag = (byte)in.read();
259         byte lenByte = (byte)in.read();
260         length = DerInputStream.getLength(lenByte, in);
261         if (length == -1) {  // indefinite length encoding found
262             DerInputBuffer inbuf = in.dup();
<span class="line-modified">263             inbuf = new DerInputBuffer(</span>
<span class="line-modified">264                     DerIndefLenConverter.convertStream(inbuf, lenByte, tag),</span>
<span class="line-modified">265                     in.allowBER);</span>







266             if (tag != inbuf.read())
267                 throw new IOException
268                         (&quot;Indefinite length encoding not supported&quot;);
269             length = DerInputStream.getDefiniteLength(inbuf);
270             buffer = inbuf.dup();
271             buffer.truncate(length);
272             data = new DerInputStream(buffer);
273             // indefinite form is encoded by sending a length field with a
274             // length of 0. - i.e. [1000|0000].
275             // the object is ended by sending two zero bytes.
<span class="line-modified">276             in.skip(length + 2);</span>
277         } else {
278 
279             buffer = in.dup();
280             buffer.truncate(length);
281             data = new DerInputStream(buffer);
282 
283             in.skip(length);
284         }
285     }
286 
287     // Get an ASN.1/DER encoded datum from a buffer w/ additional
288     // arg to control whether DER checks are enforced.
289     DerValue(byte[] buf, boolean allowBER) throws IOException {
290         data = init(true, new ByteArrayInputStream(buf), allowBER);
291     }
292 
293     /**
294      * Get an ASN.1/DER encoded datum from a buffer.  The
295      * entire buffer must hold exactly one datum, including
296      * its tag and length.
</pre>
<hr />
<pre>
323 
324     // Get an ASN1/DER encoded datum from an input stream w/ additional
325     // arg to control whether DER checks are enforced.
326     DerValue(InputStream in, boolean allowBER) throws IOException {
327         data = init(false, in, allowBER);
328     }
329 
330     /**
331      * Get an ASN1/DER encoded datum from an input stream.  The
332      * stream may have additional data following the encoded datum.
333      * In case of indefinite length encoded datum, the input stream
334      * must hold only one datum.
335      *
336      * @param in the input stream holding a single DER datum,
337      *  which may be followed by additional data
338      */
339     public DerValue(InputStream in) throws IOException {
340         this(in, true);
341     }
342 
<span class="line-modified">343     private DerInputStream init(byte stringTag, String value) {</span>
<span class="line-modified">344         final Charset charset;</span>

345 
346         tag = stringTag;
347 
348         switch (stringTag) {
349         case tag_PrintableString:
350         case tag_IA5String:
351         case tag_GeneralString:
<span class="line-modified">352             charset = US_ASCII;</span>
353             break;
354         case tag_T61String:
<span class="line-modified">355             charset = ISO_8859_1;</span>
356             break;
357         case tag_BMPString:
<span class="line-modified">358             charset = UTF_16BE;</span>
359             break;
360         case tag_UTF8String:
<span class="line-modified">361             charset = UTF_8;</span>
362             break;
363             // TBD: Need encoder for UniversalString before it can
364             // be handled.
365         default:
366             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
367         }
368 
<span class="line-modified">369         byte[] buf = value.getBytes(charset);</span>
370         length = buf.length;
371         buffer = new DerInputBuffer(buf, true);
372         DerInputStream result = new DerInputStream(buffer);
373         result.mark(Integer.MAX_VALUE);
374         return result;
375     }
376 
377     /*
378      * helper routine
379      */
380     private DerInputStream init(boolean fullyBuffered, InputStream in,
381         boolean allowBER) throws IOException {
382 
383         tag = (byte)in.read();
384         byte lenByte = (byte)in.read();
385         length = DerInputStream.getLength(lenByte, in);
386         if (length == -1) { // indefinite length encoding found
<span class="line-modified">387             in = new ByteArrayInputStream(</span>
<span class="line-modified">388                     DerIndefLenConverter.convertStream(in, lenByte, tag));</span>








389             if (tag != in.read())
390                 throw new IOException
391                         (&quot;Indefinite length encoding not supported&quot;);
392             length = DerInputStream.getDefiniteLength(in);
393         }
394 
395         if (fullyBuffered &amp;&amp; in.available() != length)
396             throw new IOException(&quot;extra data given to DerValue constructor&quot;);
397 
<span class="line-modified">398         byte[] bytes = IOUtils.readExactlyNBytes(in, length);</span>
399 
400         buffer = new DerInputBuffer(bytes, allowBER);
401         return new DerInputStream(buffer);
402     }
403 
404     /**
405      * Encode an ASN1/DER encoded datum onto a DER output stream.
406      */
407     public void encode(DerOutputStream out)
408     throws IOException {
409         out.write(tag);
410         out.putLength(length);
411         // XXX yeech, excess copies ... DerInputBuffer.write(OutStream)
412         if (length &gt; 0) {
413             byte[] value = new byte[length];
414             // always synchronized on data
415             synchronized (data) {
416                 buffer.reset();
417                 if (buffer.read(value) != length) {
418                     throw new IOException(&quot;short DER value read (encode)&quot;);
</pre>
<hr />
<pre>
650     public byte[] getDataBytes() throws IOException {
651         byte[] retVal = new byte[length];
652         synchronized (data) {
653             data.reset();
654             data.getBytes(retVal);
655         }
656         return retVal;
657     }
658 
659     /**
660      * Returns an ASN.1 STRING value
661      *
662      * @return the printable string held in this value
663      */
664     public String getPrintableString()
665     throws IOException {
666         if (tag != tag_PrintableString)
667             throw new IOException(
668                 &quot;DerValue.getPrintableString, not a string &quot; + tag);
669 
<span class="line-modified">670         return new String(getDataBytes(), US_ASCII);</span>
671     }
672 
673     /**
674      * Returns an ASN.1 T61 (Teletype) STRING value
675      *
676      * @return the teletype string held in this value
677      */
678     public String getT61String() throws IOException {
679         if (tag != tag_T61String)
680             throw new IOException(
681                 &quot;DerValue.getT61String, not T61 &quot; + tag);
682 
<span class="line-modified">683         return new String(getDataBytes(), ISO_8859_1);</span>
684     }
685 
686     /**
687      * Returns an ASN.1 IA5 (ASCII) STRING value
688      *
689      * @return the ASCII string held in this value
690      */
691     public String getIA5String() throws IOException {
692         if (tag != tag_IA5String)
693             throw new IOException(
694                 &quot;DerValue.getIA5String, not IA5 &quot; + tag);
695 
<span class="line-modified">696         return new String(getDataBytes(), US_ASCII);</span>
697     }
698 
699     /**
700      * Returns the ASN.1 BMP (Unicode) STRING value as a Java string.
701      *
702      * @return a string corresponding to the encoded BMPString held in
703      * this value
704      */
705     public String getBMPString() throws IOException {
706         if (tag != tag_BMPString)
707             throw new IOException(
708                 &quot;DerValue.getBMPString, not BMP &quot; + tag);
709 
710         // BMPString is the same as Unicode in big endian, unmarked
711         // format.
<span class="line-modified">712         return new String(getDataBytes(), UTF_16BE);</span>
713     }
714 
715     /**
716      * Returns the ASN.1 UTF-8 STRING value as a Java String.
717      *
718      * @return a string corresponding to the encoded UTF8String held in
719      * this value
720      */
721     public String getUTF8String() throws IOException {
722         if (tag != tag_UTF8String)
723             throw new IOException(
724                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
725 
<span class="line-modified">726         return new String(getDataBytes(), UTF_8);</span>
727     }
728 
729     /**
730      * Returns the ASN.1 GENERAL STRING value as a Java String.
731      *
732      * @return a string corresponding to the encoded GeneralString held in
733      * this value
734      */
735     public String getGeneralString() throws IOException {
736         if (tag != tag_GeneralString)
737             throw new IOException(
738                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
739 
<span class="line-modified">740         return new String(getDataBytes(), US_ASCII);</span>
741     }
742 
743     /**
744      * Returns a Date if the DerValue is UtcTime.
745      *
746      * @return the Date held in this DER value
747      */
748     public Date getUTCTime() throws IOException {
749         if (tag != tag_UtcTime) {
750             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
751         }
752         return buffer.getUTCTime(data.available());
753     }
754 
755     /**
756      * Returns a Date if the DerValue is GeneralizedTime.
757      *
758      * @return the Date held in this DER value
759      */
760     public Date getGeneralizedTime() throws IOException {
</pre>
</td>
</tr>
</table>
<center><a href="DerOutputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DisabledAlgorithmConstraints.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
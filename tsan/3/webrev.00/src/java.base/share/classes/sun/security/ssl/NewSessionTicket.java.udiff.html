<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyShareExtension.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OutputRecord.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/NewSessionTicket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,45 +26,145 @@</span>
  
  import java.io.IOException;
  import java.math.BigInteger;
  import java.nio.ByteBuffer;
  import java.security.GeneralSecurityException;
<span class="udiff-line-removed">- import java.security.ProviderException;</span>
  import java.security.SecureRandom;
  import java.text.MessageFormat;
  import java.util.Locale;
<span class="udiff-line-removed">- import java.util.Optional;</span>
  import javax.crypto.SecretKey;
  import javax.net.ssl.SSLHandshakeException;
  import sun.security.ssl.PskKeyExchangeModesExtension.PskKeyExchangeModesSpec;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;</span>
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="udiff-line-added">+ import sun.security.util.HexDumpEncoder;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ import static sun.security.ssl.SSLHandshake.NEW_SESSION_TICKET;</span>
  
  /**
   * Pack of the NewSessionTicket handshake message.
   */
  final class NewSessionTicket {
<span class="udiff-line-modified-removed">-     private static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     static final int MAX_TICKET_LIFETIME = 604800;  // seconds, 7 days</span>
      static final SSLConsumer handshakeConsumer =
<span class="udiff-line-modified-removed">-         new NewSessionTicketConsumer();</span>
<span class="udiff-line-modified-added">+         new T13NewSessionTicketConsumer();</span>
<span class="udiff-line-added">+     static final SSLConsumer handshake12Consumer =</span>
<span class="udiff-line-added">+         new T12NewSessionTicketConsumer();</span>
      static final SSLProducer kickstartProducer =
          new NewSessionTicketKickstartProducer();
<span class="udiff-line-modified-removed">-     static final HandshakeProducer handshakeProducer =</span>
<span class="udiff-line-modified-removed">-         new NewSessionTicketProducer();</span>
<span class="udiff-line-modified-added">+     static final HandshakeProducer handshake12Producer =</span>
<span class="udiff-line-modified-added">+         new T12NewSessionTicketProducer();</span>
  
      /**
<span class="udiff-line-modified-removed">-      * The NewSessionTicketMessage handshake message.</span>
<span class="udiff-line-modified-added">+      * The NewSessionTicketMessage handshake messages.</span>
       */
<span class="udiff-line-modified-removed">-     static final class NewSessionTicketMessage extends HandshakeMessage {</span>
<span class="udiff-line-modified-removed">-         final int ticketLifetime;</span>
<span class="udiff-line-modified-removed">-         final int ticketAgeAdd;</span>
<span class="udiff-line-modified-removed">-         final byte[] ticketNonce;</span>
<span class="udiff-line-modified-removed">-         final byte[] ticket;</span>
<span class="udiff-line-modified-removed">-         final SSLExtensions extensions;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         NewSessionTicketMessage(HandshakeContext context,</span>
<span class="udiff-line-modified-added">+     abstract static class NewSessionTicketMessage extends HandshakeMessage {</span>
<span class="udiff-line-modified-added">+         int ticketLifetime;</span>
<span class="udiff-line-modified-added">+         byte[] ticket = new byte[0];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         NewSessionTicketMessage(HandshakeContext context) {</span>
<span class="udiff-line-modified-added">+             super(context);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public SSLHandshake handshakeType() {</span>
<span class="udiff-line-added">+             return NEW_SESSION_TICKET;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // For TLS 1.3 only</span>
<span class="udiff-line-added">+         int getTicketAgeAdd() throws IOException {</span>
<span class="udiff-line-added">+             throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="udiff-line-added">+                     &quot;TicketAgeAdd not part of RFC 5077.&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // For TLS 1.3 only</span>
<span class="udiff-line-added">+         byte[] getTicketNonce() throws IOException {</span>
<span class="udiff-line-added">+             throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="udiff-line-added">+                     &quot;TicketNonce not part of RFC 5077.&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         boolean isValid() {</span>
<span class="udiff-line-added">+             return (ticket.length &gt; 0);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * NewSessionTicket for TLS 1.2 and below (RFC 5077)</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static final class T12NewSessionTicketMessage extends NewSessionTicketMessage {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         T12NewSessionTicketMessage(HandshakeContext context,</span>
<span class="udiff-line-added">+                 int ticketLifetime, byte[] ticket) {</span>
<span class="udiff-line-added">+             super(context);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             this.ticketLifetime = ticketLifetime;</span>
<span class="udiff-line-added">+             this.ticket = ticket;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         T12NewSessionTicketMessage(HandshakeContext context,</span>
<span class="udiff-line-added">+                 ByteBuffer m) throws IOException {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // RFC5077 struct {</span>
<span class="udiff-line-added">+             //     uint32 ticket_lifetime;</span>
<span class="udiff-line-added">+             //     opaque ticket&lt;0..2^16-1&gt;;</span>
<span class="udiff-line-added">+             // } NewSessionTicket;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             super(context);</span>
<span class="udiff-line-added">+             if (m.remaining() &lt; 6) {</span>
<span class="udiff-line-added">+                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="udiff-line-added">+                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             this.ticketLifetime = Record.getInt32(m);</span>
<span class="udiff-line-added">+             this.ticket = Record.getBytes16(m);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public SSLHandshake handshakeType() {</span>
<span class="udiff-line-added">+             return NEW_SESSION_TICKET;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int messageLength() {</span>
<span class="udiff-line-added">+             return 4 + // ticketLifetime</span>
<span class="udiff-line-added">+                     2 + ticket.length;  // len of ticket + ticket</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void send(HandshakeOutStream hos) throws IOException {</span>
<span class="udiff-line-added">+             hos.putInt32(ticketLifetime);</span>
<span class="udiff-line-added">+             hos.putBytes16(ticket);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             MessageFormat messageFormat = new MessageFormat(</span>
<span class="udiff-line-added">+                     &quot;\&quot;NewSessionTicket\&quot;: &#39;{&#39;\n&quot; +</span>
<span class="udiff-line-added">+                             &quot;  \&quot;ticket_lifetime\&quot;      : \&quot;{0}\&quot;,\n&quot; +</span>
<span class="udiff-line-added">+                             &quot;  \&quot;ticket\&quot;               : &#39;{&#39;\n&quot; +</span>
<span class="udiff-line-added">+                             &quot;{1}\n&quot; +</span>
<span class="udiff-line-added">+                             &quot;  &#39;}&#39;&quot; +</span>
<span class="udiff-line-added">+                             &quot;&#39;}&#39;&quot;,</span>
<span class="udiff-line-added">+                 Locale.ENGLISH);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
<span class="udiff-line-added">+             Object[] messageFields = {</span>
<span class="udiff-line-added">+                     ticketLifetime,</span>
<span class="udiff-line-added">+                     Utilities.indent(hexEncoder.encode(ticket), &quot;    &quot;),</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             return messageFormat.format(messageFields);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * NewSessionTicket defined by the TLS 1.3</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static final class T13NewSessionTicketMessage extends NewSessionTicketMessage {</span>
<span class="udiff-line-added">+         int ticketAgeAdd;</span>
<span class="udiff-line-added">+         byte[] ticketNonce;</span>
<span class="udiff-line-added">+         SSLExtensions extensions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         T13NewSessionTicketMessage(HandshakeContext context,</span>
                  int ticketLifetime, SecureRandom generator,
                  byte[] ticketNonce, byte[] ticket) {
              super(context);
  
              this.ticketLifetime = ticketLifetime;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,66 +172,82 @@</span>
              this.ticketNonce = ticketNonce;
              this.ticket = ticket;
              this.extensions = new SSLExtensions(this);
          }
  
<span class="udiff-line-modified-removed">-         NewSessionTicketMessage(HandshakeContext context,</span>
<span class="udiff-line-modified-added">+         T13NewSessionTicketMessage(HandshakeContext context,</span>
                  ByteBuffer m) throws IOException {
              super(context);
  
              // struct {
              //     uint32 ticket_lifetime;
              //     uint32 ticket_age_add;
              //     opaque ticket_nonce&lt;0..255&gt;;
              //     opaque ticket&lt;1..2^16-1&gt;;
              //     Extension extensions&lt;0..2^16-2&gt;;
              // } NewSessionTicket;
<span class="udiff-line-added">+ </span>
              if (m.remaining() &lt; 14) {
                  throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="udiff-line-modified-removed">-                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>
<span class="udiff-line-modified-added">+                     &quot;Invalid NewSessionTicket message: insufficient data&quot;);</span>
              }
  
              this.ticketLifetime = Record.getInt32(m);
              this.ticketAgeAdd = Record.getInt32(m);
              this.ticketNonce = Record.getBytes8(m);
  
              if (m.remaining() &lt; 5) {
                  throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="udiff-line-modified-removed">-                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>
<span class="udiff-line-modified-added">+                     &quot;Invalid NewSessionTicket message: insufficient ticket&quot; +</span>
<span class="udiff-line-added">+                             &quot; data&quot;);</span>
              }
  
              this.ticket = Record.getBytes16(m);
              if (ticket.length == 0) {
<span class="udiff-line-modified-removed">-                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="udiff-line-modified-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(</span>
                      &quot;No ticket in the NewSessionTicket handshake message&quot;);
<span class="udiff-line-added">+                 }</span>
              }
  
              if (m.remaining() &lt; 2) {
                  throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="udiff-line-modified-removed">-                     &quot;Invalid NewSessionTicket message: no sufficient data&quot;);</span>
<span class="udiff-line-modified-added">+                     &quot;Invalid NewSessionTicket message: extra data&quot;);</span>
              }
  
              SSLExtension[] supportedExtensions =
                      context.sslConfig.getEnabledExtensions(
<span class="udiff-line-modified-removed">-                             SSLHandshake.NEW_SESSION_TICKET);</span>
<span class="udiff-line-modified-added">+                             NEW_SESSION_TICKET);</span>
              this.extensions = new SSLExtensions(this, m, supportedExtensions);
          }
  
          @Override
          public SSLHandshake handshakeType() {
<span class="udiff-line-modified-removed">-             return SSLHandshake.NEW_SESSION_TICKET;</span>
<span class="udiff-line-modified-added">+             return NEW_SESSION_TICKET;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         int getTicketAgeAdd() {</span>
<span class="udiff-line-added">+             return ticketAgeAdd;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         byte[] getTicketNonce() {</span>
<span class="udiff-line-added">+             return ticketNonce;</span>
          }
  
          @Override
          public int messageLength() {
<span class="udiff-line-added">+ </span>
              int extLen = extensions.length();
              if (extLen == 0) {
                  extLen = 2;     // empty extensions
              }
  
<span class="udiff-line-modified-removed">-             return 8 + ticketNonce.length + 1 +</span>
<span class="udiff-line-modified-removed">-                        ticket.length + 2 + extLen;</span>
<span class="udiff-line-modified-added">+             return 4 +// ticketLifetime</span>
<span class="udiff-line-modified-added">+                     4 + // ticketAgeAdd</span>
<span class="udiff-line-added">+                     1 + ticketNonce.length + // len of nonce + nonce</span>
<span class="udiff-line-added">+                     2 + ticket.length + // len of ticket + ticket</span>
<span class="udiff-line-added">+                     extLen;</span>
          }
  
          @Override
          public void send(HandshakeOutStream hos) throws IOException {
              hos.putInt32(ticketLifetime);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,22 +268,25 @@</span>
              MessageFormat messageFormat = new MessageFormat(
                  &quot;\&quot;NewSessionTicket\&quot;: &#39;{&#39;\n&quot; +
                  &quot;  \&quot;ticket_lifetime\&quot;      : \&quot;{0}\&quot;,\n&quot; +
                  &quot;  \&quot;ticket_age_add\&quot;       : \&quot;{1}\&quot;,\n&quot; +
                  &quot;  \&quot;ticket_nonce\&quot;         : \&quot;{2}\&quot;,\n&quot; +
<span class="udiff-line-modified-removed">-                 &quot;  \&quot;ticket\&quot;               : \&quot;{3}\&quot;,\n&quot; +</span>
<span class="udiff-line-modified-added">+                 &quot;  \&quot;ticket\&quot;               : &#39;{&#39;\n&quot; +</span>
<span class="udiff-line-added">+                 &quot;{3}\n&quot; +</span>
<span class="udiff-line-added">+                 &quot;  &#39;}&#39;&quot; +</span>
                  &quot;  \&quot;extensions\&quot;           : [\n&quot; +
                  &quot;{4}\n&quot; +
                  &quot;  ]\n&quot; +
                  &quot;&#39;}&#39;&quot;,
                  Locale.ENGLISH);
  
<span class="udiff-line-added">+             HexDumpEncoder hexEncoder = new HexDumpEncoder();</span>
              Object[] messageFields = {
                  ticketLifetime,
                  &quot;&lt;omitted&gt;&quot;,    //ticketAgeAdd should not be logged
                  Utilities.toHexString(ticketNonce),
<span class="udiff-line-modified-removed">-                 Utilities.toHexString(ticket),</span>
<span class="udiff-line-modified-added">+                 Utilities.indent(hexEncoder.encode(ticket), &quot;    &quot;),</span>
                  Utilities.indent(extensions.toString(), &quot;    &quot;)
              };
  
              return messageFormat.format(messageFields);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -194,197 +313,331 @@</span>
              // blank
          }
  
          @Override
          public byte[] produce(ConnectionContext context) throws IOException {
<span class="udiff-line-added">+             HandshakeContext hc = (HandshakeContext)context;</span>
<span class="udiff-line-added">+ </span>
              // The producing happens in server side only.
<span class="udiff-line-modified-removed">-             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>
<span class="udiff-line-modified-added">+             if (hc instanceof ServerHandshakeContext) {</span>
<span class="udiff-line-added">+                 // Is this session resumable?</span>
<span class="udiff-line-added">+                 if (!hc.handshakeSession.isRejoinable()) {</span>
<span class="udiff-line-added">+                     return null;</span>
<span class="udiff-line-added">+                 }</span>
  
<span class="udiff-line-modified-removed">-             // Is this session resumable?</span>
<span class="udiff-line-modified-removed">-             if (!shc.handshakeSession.isRejoinable()) {</span>
<span class="udiff-line-modified-removed">-                 return null;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-added">+                 // What&#39;s the requested PSK key exchange modes?</span>
<span class="udiff-line-modified-added">+                 //</span>
<span class="udiff-line-modified-added">+                 // Note that currently, the NewSessionTicket post-handshake is</span>
<span class="udiff-line-modified-added">+                 // produced and delivered only in the current handshake context</span>
<span class="udiff-line-added">+                 // if required.</span>
<span class="udiff-line-added">+                 PskKeyExchangeModesSpec pkemSpec =</span>
<span class="udiff-line-added">+                         (PskKeyExchangeModesSpec) hc.handshakeExtensions.get(</span>
<span class="udiff-line-added">+                                 SSLExtension.PSK_KEY_EXCHANGE_MODES);</span>
<span class="udiff-line-added">+                 if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="udiff-line-added">+                         PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="udiff-line-added">+                     // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>
<span class="udiff-line-added">+                     return null;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else { // PostHandshakeContext</span>
  
<span class="udiff-line-modified-removed">-             // What&#39;s the requested PSK key exchange modes?</span>
<span class="udiff-line-modified-removed">-             //</span>
<span class="udiff-line-modified-removed">-             // Note that currently, the NewSessionTicket post-handshake is</span>
<span class="udiff-line-modified-removed">-             // produced and delivered only in the current handshake context</span>
<span class="udiff-line-modified-removed">-             // if required.</span>
<span class="udiff-line-removed">-             PskKeyExchangeModesSpec pkemSpec =</span>
<span class="udiff-line-removed">-                     (PskKeyExchangeModesSpec)shc.handshakeExtensions.get(</span>
<span class="udiff-line-removed">-                             SSLExtension.PSK_KEY_EXCHANGE_MODES);</span>
<span class="udiff-line-removed">-             if (pkemSpec == null || !pkemSpec.contains(</span>
<span class="udiff-line-removed">-                 PskKeyExchangeModesExtension.PskKeyExchangeMode.PSK_DHE_KE)) {</span>
<span class="udiff-line-removed">-                 // Client doesn&#39;t support PSK with (EC)DHE key establishment.</span>
<span class="udiff-line-removed">-                 return null;</span>
<span class="udiff-line-modified-added">+                 // Check if we have sent a PSK already, then we know it is using a</span>
<span class="udiff-line-modified-added">+                 // allowable PSK exchange key mode</span>
<span class="udiff-line-modified-added">+                 if (!hc.handshakeSession.isPSKable()) {</span>
<span class="udiff-line-modified-added">+                     return null;</span>
<span class="udiff-line-modified-added">+                 }</span>
              }
  
              // get a new session ID
              SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
<span class="udiff-line-modified-removed">-                 shc.sslContext.engineGetServerSessionContext();</span>
<span class="udiff-line-modified-added">+                 hc.sslContext.engineGetServerSessionContext();</span>
              SessionId newId = new SessionId(true,
<span class="udiff-line-modified-removed">-                 shc.sslContext.getSecureRandom());</span>
<span class="udiff-line-modified-added">+                 hc.sslContext.getSecureRandom());</span>
  
<span class="udiff-line-modified-removed">-             Optional&lt;SecretKey&gt; resumptionMasterSecret =</span>
<span class="udiff-line-modified-removed">-                 shc.handshakeSession.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-removed">-             if (!resumptionMasterSecret.isPresent()) {</span>
<span class="udiff-line-modified-added">+             SecretKey resumptionMasterSecret =</span>
<span class="udiff-line-modified-added">+                 hc.handshakeSession.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-added">+             if (resumptionMasterSecret == null) {</span>
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
                          &quot;Session has no resumption secret. No ticket sent.&quot;);
                  }
                  return null;
              }
  
              // construct the PSK and handshake message
<span class="udiff-line-modified-removed">-             BigInteger nonce = shc.handshakeSession.incrTicketNonceCounter();</span>
<span class="udiff-line-modified-added">+             BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();</span>
              byte[] nonceArr = nonce.toByteArray();
              SecretKey psk = derivePreSharedKey(
<span class="udiff-line-modified-removed">-                     shc.negotiatedCipherSuite.hashAlg,</span>
<span class="udiff-line-modified-removed">-                     resumptionMasterSecret.get(), nonceArr);</span>
<span class="udiff-line-modified-added">+                     hc.negotiatedCipherSuite.hashAlg,</span>
<span class="udiff-line-modified-added">+                     resumptionMasterSecret, nonceArr);</span>
  
              int sessionTimeoutSeconds = sessionCache.getSessionTimeout();
              if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
                          &quot;Session timeout is too long. No ticket sent.&quot;);
                  }
                  return null;
              }
<span class="udiff-line-removed">-             NewSessionTicketMessage nstm = new NewSessionTicketMessage(shc,</span>
<span class="udiff-line-removed">-                 sessionTimeoutSeconds, shc.sslContext.getSecureRandom(),</span>
<span class="udiff-line-removed">-                 nonceArr, newId.getId());</span>
<span class="udiff-line-removed">-             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-removed">-                 SSLLogger.fine(</span>
<span class="udiff-line-removed">-                         &quot;Produced NewSessionTicket handshake message&quot;, nstm);</span>
<span class="udiff-line-removed">-             }</span>
  
<span class="udiff-line-modified-removed">-             // create and cache the new session</span>
<span class="udiff-line-modified-removed">-             // The new session must be a child of the existing session so</span>
<span class="udiff-line-removed">-             // they will be invalidated together, etc.</span>
<span class="udiff-line-modified-added">+             NewSessionTicketMessage nstm = null;</span>
<span class="udiff-line-modified-added">+ </span>
              SSLSessionImpl sessionCopy =
<span class="udiff-line-modified-removed">-                     new SSLSessionImpl(shc.handshakeSession, newId);</span>
<span class="udiff-line-removed">-             shc.handshakeSession.addChild(sessionCopy);</span>
<span class="udiff-line-modified-added">+                     new SSLSessionImpl(hc.handshakeSession, newId);</span>
              sessionCopy.setPreSharedKey(psk);
              sessionCopy.setPskIdentity(newId.getId());
<span class="udiff-line-modified-removed">-             sessionCopy.setTicketAgeAdd(nstm.ticketAgeAdd);</span>
<span class="udiff-line-modified-removed">-             sessionCache.put(sessionCopy);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             // If a stateless ticket is allowed, attempt to make one</span>
<span class="udiff-line-added">+             if (hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="udiff-line-added">+                 nstm = new T13NewSessionTicketMessage(hc,</span>
<span class="udiff-line-added">+                         sessionTimeoutSeconds,</span>
<span class="udiff-line-added">+                         hc.sslContext.getSecureRandom(),</span>
<span class="udiff-line-added">+                         nonceArr,</span>
<span class="udiff-line-added">+                         new SessionTicketSpec().encrypt(hc, sessionCopy));</span>
<span class="udiff-line-added">+                 // If ticket construction failed, switch to session cache</span>
<span class="udiff-line-added">+                 if (!nstm.isValid()) {</span>
<span class="udiff-line-added">+                     hc.statelessResumption = false;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                         SSLLogger.fine(</span>
<span class="udiff-line-added">+                                 &quot;Produced NewSessionTicket stateless &quot; +</span>
<span class="udiff-line-added">+                                         &quot;handshake message&quot;, nstm);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // If a session cache ticket is being used, make one</span>
<span class="udiff-line-added">+             if (!hc.handshakeSession.isStatelessable(hc)) {</span>
<span class="udiff-line-added">+                 nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,</span>
<span class="udiff-line-added">+                         hc.sslContext.getSecureRandom(), nonceArr,</span>
<span class="udiff-line-added">+                         newId.getId());</span>
<span class="udiff-line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(</span>
<span class="udiff-line-added">+                             &quot;Produced NewSessionTicket handshake message&quot;,</span>
<span class="udiff-line-added">+                             nstm);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // create and cache the new session</span>
<span class="udiff-line-added">+                 // The new session must be a child of the existing session so</span>
<span class="udiff-line-added">+                 // they will be invalidated together, etc.</span>
<span class="udiff-line-added">+                 hc.handshakeSession.addChild(sessionCopy);</span>
<span class="udiff-line-added">+                 sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());</span>
<span class="udiff-line-added">+                 sessionCache.put(sessionCopy);</span>
<span class="udiff-line-added">+             }</span>
  
              // Output the handshake message.
<span class="udiff-line-modified-removed">-             nstm.write(shc.handshakeOutput);</span>
<span class="udiff-line-modified-removed">-             shc.handshakeOutput.flush();</span>
<span class="udiff-line-modified-added">+             if (nstm != null) {</span>
<span class="udiff-line-modified-added">+                 // should never be null</span>
<span class="udiff-line-added">+                 nstm.write(hc.handshakeOutput);</span>
<span class="udiff-line-added">+                 hc.handshakeOutput.flush();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (hc instanceof PostHandshakeContext) {</span>
<span class="udiff-line-added">+                 ((PostHandshakeContext) hc).finish();</span>
<span class="udiff-line-added">+             }</span>
  
              // The message has been delivered.
              return null;
          }
      }
  
      /**
<span class="udiff-line-modified-removed">-      * The &quot;NewSessionTicket&quot; handshake message producer.</span>
<span class="udiff-line-modified-added">+      * The &quot;NewSessionTicket&quot; handshake message producer for RFC 5077</span>
       */
<span class="udiff-line-modified-removed">-     private static final class NewSessionTicketProducer</span>
<span class="udiff-line-modified-added">+     private static final class T12NewSessionTicketProducer</span>
              implements HandshakeProducer {
  
          // Prevent instantiation of this class.
<span class="udiff-line-modified-removed">-         private NewSessionTicketProducer() {</span>
<span class="udiff-line-modified-added">+         private T12NewSessionTicketProducer() {</span>
              // blank
          }
  
          @Override
          public byte[] produce(ConnectionContext context,
                  HandshakeMessage message) throws IOException {
  
<span class="udiff-line-modified-removed">-             // NSTM may be sent in response to handshake messages.</span>
<span class="udiff-line-removed">-             // For example: key update</span>
<span class="udiff-line-modified-added">+             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>
  
<span class="udiff-line-modified-removed">-             throw new ProviderException(</span>
<span class="udiff-line-modified-removed">-                 &quot;NewSessionTicket handshake producer not implemented&quot;);</span>
<span class="udiff-line-modified-added">+             // Is this session resumable?</span>
<span class="udiff-line-modified-added">+             if (!shc.handshakeSession.isRejoinable()) {</span>
<span class="udiff-line-added">+                 return null;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // get a new session ID</span>
<span class="udiff-line-added">+             SessionId newId = shc.handshakeSession.getSessionId();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-added">+                     shc.sslContext.engineGetServerSessionContext();</span>
<span class="udiff-line-added">+             int sessionTimeoutSeconds = sessionCache.getSessionTimeout();</span>
<span class="udiff-line-added">+             if (sessionTimeoutSeconds &gt; MAX_TICKET_LIFETIME) {</span>
<span class="udiff-line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(</span>
<span class="udiff-line-added">+                         &quot;Session timeout is too long. No ticket sent.&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return null;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             SSLSessionImpl sessionCopy =</span>
<span class="udiff-line-added">+                     new SSLSessionImpl(shc.handshakeSession, newId);</span>
<span class="udiff-line-added">+             sessionCopy.setPskIdentity(newId.getId());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(shc,</span>
<span class="udiff-line-added">+                     sessionTimeoutSeconds,</span>
<span class="udiff-line-added">+                     new SessionTicketSpec().encrypt(shc, sessionCopy));</span>
<span class="udiff-line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                 SSLLogger.fine(</span>
<span class="udiff-line-added">+                         &quot;Produced NewSessionTicket stateless handshake message&quot;, nstm);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // Output the handshake message.</span>
<span class="udiff-line-added">+             nstm.write(shc.handshakeOutput);</span>
<span class="udiff-line-added">+             shc.handshakeOutput.flush();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // The message has been delivered.</span>
<span class="udiff-line-added">+             return null;</span>
          }
      }
  
      private static final
<span class="udiff-line-modified-removed">-             class NewSessionTicketConsumer implements SSLConsumer {</span>
<span class="udiff-line-modified-added">+     class T13NewSessionTicketConsumer implements SSLConsumer {</span>
          // Prevent instantiation of this class.
<span class="udiff-line-modified-removed">-         private NewSessionTicketConsumer() {</span>
<span class="udiff-line-modified-added">+         private T13NewSessionTicketConsumer() {</span>
              // blank
          }
  
          @Override
          public void consume(ConnectionContext context,
<span class="udiff-line-modified-removed">-                             ByteBuffer message) throws IOException {</span>
<span class="udiff-line-modified-added">+                 ByteBuffer message) throws IOException {</span>
  
              // Note: Although the resumption master secret depends on the
              // client&#39;s second flight, servers which do not request client
              // authentication MAY compute the remainder of the transcript
              // independently and then send a NewSessionTicket immediately
              // upon sending its Finished rather than waiting for the client
              // Finished.
              //
<span class="udiff-line-modified-removed">-             // The consuming happens in client side only.  As the server</span>
<span class="udiff-line-modified-removed">-             // may send the NewSessionTicket before handshake complete, the</span>
<span class="udiff-line-modified-removed">-             // context may be a PostHandshakeContext or HandshakeContext</span>
<span class="udiff-line-removed">-             // instance.</span>
<span class="udiff-line-modified-added">+             // The consuming happens in client side only and is received after</span>
<span class="udiff-line-modified-added">+             // the server&#39;s Finished message with PostHandshakeContext.</span>
<span class="udiff-line-modified-added">+ </span>
              HandshakeContext hc = (HandshakeContext)context;
              NewSessionTicketMessage nstm =
<span class="udiff-line-modified-removed">-                     new NewSessionTicketMessage(hc, message);</span>
<span class="udiff-line-modified-added">+                     new T13NewSessionTicketMessage(hc, message);</span>
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                  &quot;Consuming NewSessionTicket message&quot;, nstm);
              }
  
<span class="udiff-line-added">+             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-added">+                     hc.sslContext.engineGetClientSessionContext();</span>
<span class="udiff-line-added">+ </span>
              // discard tickets with timeout 0
              if (nstm.ticketLifetime &lt;= 0 ||
                  nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
                      &quot;Discarding NewSessionTicket with lifetime &quot;
                          + nstm.ticketLifetime, nstm);
                  }
<span class="udiff-line-added">+                 sessionCache.remove(hc.handshakeSession.getSessionId());</span>
                  return;
              }
  
<span class="udiff-line-removed">-             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-removed">-                 hc.sslContext.engineGetClientSessionContext();</span>
<span class="udiff-line-removed">- </span>
              if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {
                  if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                      SSLLogger.fine(
                      &quot;Session cache lifetime is too long. Discarding ticket.&quot;);
                  }
                  return;
              }
  
              SSLSessionImpl sessionToSave = hc.conContext.conSession;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             Optional&lt;SecretKey&gt; resumptionMasterSecret =</span>
<span class="udiff-line-modified-removed">-                 sessionToSave.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-removed">-             if (!resumptionMasterSecret.isPresent()) {</span>
<span class="udiff-line-modified-removed">-                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-modified-removed">-                     SSLLogger.fine(</span>
<span class="udiff-line-modified-removed">-                     &quot;Session has no resumption master secret. Ignoring ticket.&quot;);</span>
<span class="udiff-line-modified-added">+             SecretKey psk = null;</span>
<span class="udiff-line-modified-added">+             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="udiff-line-modified-added">+                 SecretKey resumptionMasterSecret =</span>
<span class="udiff-line-modified-added">+                         sessionToSave.getResumptionMasterSecret();</span>
<span class="udiff-line-modified-added">+                 if (resumptionMasterSecret == null) {</span>
<span class="udiff-line-modified-added">+                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-modified-added">+                         SSLLogger.fine(</span>
<span class="udiff-line-added">+                                 &quot;Session has no resumption master secret.&quot; +</span>
<span class="udiff-line-added">+                                         &quot; Ignoring ticket.&quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     return;</span>
                  }
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             }</span>
  
<span class="udiff-line-modified-removed">-             // derive the PSK</span>
<span class="udiff-line-modified-removed">-             SecretKey psk = derivePreSharedKey(</span>
<span class="udiff-line-modified-removed">-                 sessionToSave.getSuite().hashAlg, resumptionMasterSecret.get(),</span>
<span class="udiff-line-modified-removed">-                 nstm.ticketNonce);</span>
<span class="udiff-line-modified-added">+                 // derive the PSK</span>
<span class="udiff-line-modified-added">+                 psk = derivePreSharedKey(</span>
<span class="udiff-line-modified-added">+                         sessionToSave.getSuite().hashAlg,</span>
<span class="udiff-line-modified-added">+                         resumptionMasterSecret, nstm.getTicketNonce());</span>
<span class="udiff-line-added">+             }</span>
  
              // create and cache the new session
              // The new session must be a child of the existing session so
              // they will be invalidated together, etc.
              SessionId newId =
<span class="udiff-line-modified-removed">-                 new SessionId(true, hc.sslContext.getSecureRandom());</span>
<span class="udiff-line-modified-added">+                     new SessionId(true, hc.sslContext.getSecureRandom());</span>
              SSLSessionImpl sessionCopy = new SSLSessionImpl(sessionToSave,
                      newId);
              sessionToSave.addChild(sessionCopy);
              sessionCopy.setPreSharedKey(psk);
<span class="udiff-line-modified-removed">-             sessionCopy.setTicketAgeAdd(nstm.ticketAgeAdd);</span>
<span class="udiff-line-modified-added">+             sessionCopy.setTicketAgeAdd(nstm.getTicketAgeAdd());</span>
              sessionCopy.setPskIdentity(nstm.ticket);
              sessionCache.put(sessionCopy);
  
              // clean handshake context
<span class="udiff-line-modified-removed">-             hc.conContext.finishPostHandshake();</span>
<span class="udiff-line-modified-added">+             if (hc.negotiatedProtocol.useTLS13PlusSpec()) {</span>
<span class="udiff-line-added">+                 hc.conContext.finishPostHandshake();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static final</span>
<span class="udiff-line-added">+     class T12NewSessionTicketConsumer implements SSLConsumer {</span>
<span class="udiff-line-added">+         // Prevent instantiation of this class.</span>
<span class="udiff-line-added">+         private T12NewSessionTicketConsumer() {</span>
<span class="udiff-line-added">+             // blank</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void consume(ConnectionContext context,</span>
<span class="udiff-line-added">+                 ByteBuffer message) throws IOException {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             HandshakeContext hc = (HandshakeContext)context;</span>
<span class="udiff-line-added">+             hc.handshakeConsumers.remove(NEW_SESSION_TICKET.id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             NewSessionTicketMessage nstm = new T12NewSessionTicketMessage(hc,</span>
<span class="udiff-line-added">+                     message);</span>
<span class="udiff-line-added">+             if (nstm.ticket.length == 0) {</span>
<span class="udiff-line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(&quot;NewSessionTicket ticket was empty&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // discard tickets with timeout 0</span>
<span class="udiff-line-added">+             if (nstm.ticketLifetime &lt;= 0 ||</span>
<span class="udiff-line-added">+                 nstm.ticketLifetime &gt; MAX_TICKET_LIFETIME) {</span>
<span class="udiff-line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(</span>
<span class="udiff-line-added">+                     &quot;Discarding NewSessionTicket with lifetime &quot;</span>
<span class="udiff-line-added">+                         + nstm.ticketLifetime, nstm);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)</span>
<span class="udiff-line-added">+                     hc.sslContext.engineGetClientSessionContext();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (sessionCache.getSessionTimeout() &gt; MAX_TICKET_LIFETIME) {</span>
<span class="udiff-line-added">+                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                     SSLLogger.fine(</span>
<span class="udiff-line-added">+                     &quot;Session cache lifetime is too long. Discarding ticket.&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             hc.handshakeSession.setPskIdentity(nstm.ticket);</span>
<span class="udiff-line-added">+             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="udiff-line-added">+                 SSLLogger.fine(&quot;Consuming NewSessionTicket\n&quot; +</span>
<span class="udiff-line-added">+                         nstm.toString());</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  }
  
</pre>
<center><a href="KeyShareExtension.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OutputRecord.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/nio/ch/ServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.net.InetSocketAddress;
 31 import java.net.ServerSocket;
 32 import java.net.SocketAddress;
 33 import java.net.SocketOption;
<a name="1" id="anc1"></a><span class="line-added"> 34 import java.net.SocketTimeoutException;</span>
 35 import java.net.StandardSocketOptions;
 36 import java.nio.channels.AlreadyBoundException;
 37 import java.nio.channels.AsynchronousCloseException;
 38 import java.nio.channels.ClosedChannelException;
<a name="2" id="anc2"></a><span class="line-added"> 39 import java.nio.channels.IllegalBlockingModeException;</span>
 40 import java.nio.channels.NotYetBoundException;
 41 import java.nio.channels.SelectionKey;
 42 import java.nio.channels.ServerSocketChannel;
 43 import java.nio.channels.SocketChannel;
 44 import java.nio.channels.spi.SelectorProvider;
 45 import java.util.Collections;
 46 import java.util.HashSet;
 47 import java.util.Objects;
 48 import java.util.Set;
 49 import java.util.concurrent.locks.ReentrantLock;
 50 
 51 import sun.net.NetHooks;
 52 import sun.net.ext.ExtendedSocketOptions;
 53 
 54 /**
 55  * An implementation of ServerSocketChannels
 56  */
 57 
 58 class ServerSocketChannelImpl
 59     extends ServerSocketChannel
 60     implements SelChImpl
 61 {
 62     // Used to make native close and configure calls
<a name="3" id="anc3"></a><span class="line-modified"> 63     private static final NativeDispatcher nd = new SocketDispatcher();</span>
 64 
 65     // Our file descriptor
 66     private final FileDescriptor fd;
 67     private final int fdVal;
 68 
 69     // Lock held by thread currently blocked on this channel
 70     private final ReentrantLock acceptLock = new ReentrantLock();
 71 
 72     // Lock held by any thread that modifies the state fields declared below
 73     // DO NOT invoke a blocking I/O operation while holding this lock!
 74     private final Object stateLock = new Object();
 75 
 76     // -- The following fields are protected by stateLock
 77 
 78     // Channel state, increases monotonically
 79     private static final int ST_INUSE = 0;
 80     private static final int ST_CLOSING = 1;
<a name="4" id="anc4"></a><span class="line-modified"> 81     private static final int ST_CLOSED = 2;</span>

 82     private int state;
 83 
 84     // ID of native thread currently blocked in this channel, for signalling
 85     private long thread;
 86 
 87     // Binding
 88     private InetSocketAddress localAddress; // null =&gt; unbound
 89 
 90     // set true when exclusive binding is on and SO_REUSEADDR is emulated
 91     private boolean isReuseAddress;
 92 
 93     // Our socket adaptor, if any
 94     private ServerSocket socket;
 95 
 96     // -- End of fields protected by stateLock
 97 
 98 
<a name="5" id="anc5"></a><span class="line-modified"> 99     ServerSocketChannelImpl(SelectorProvider sp) {</span>
100         super(sp);
<a name="6" id="anc6"></a><span class="line-modified">101         this.fd = Net.serverSocket(true);</span>
102         this.fdVal = IOUtil.fdVal(fd);
103     }
104 
105     ServerSocketChannelImpl(SelectorProvider sp, FileDescriptor fd, boolean bound)
106         throws IOException
107     {
108         super(sp);
109         this.fd =  fd;
110         this.fdVal = IOUtil.fdVal(fd);
111         if (bound) {
112             synchronized (stateLock) {
113                 localAddress = Net.localAddress(fd);
114             }
115         }
116     }
117 
118     // @throws ClosedChannelException if channel is closed
119     private void ensureOpen() throws ClosedChannelException {
120         if (!isOpen())
121             throw new ClosedChannelException();
122     }
123 
124     @Override
125     public ServerSocket socket() {
126         synchronized (stateLock) {
127             if (socket == null)
128                 socket = ServerSocketAdaptor.create(this);
129             return socket;
130         }
131     }
132 
133     @Override
134     public SocketAddress getLocalAddress() throws IOException {
135         synchronized (stateLock) {
136             ensureOpen();
137             return (localAddress == null)
138                     ? null
139                     : Net.getRevealedLocalAddress(localAddress);
140         }
141     }
142 
143     @Override
144     public &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value)
145         throws IOException
146     {
147         Objects.requireNonNull(name);
148         if (!supportedOptions().contains(name))
149             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
<a name="7" id="anc7"></a><span class="line-added">150         if (!name.type().isInstance(value))</span>
<span class="line-added">151             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">152 </span>
153         synchronized (stateLock) {
154             ensureOpen();
155 
156             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
157                 // SO_REUSEADDR emulated when using exclusive bind
158                 isReuseAddress = (Boolean)value;
159             } else {
160                 // no options that require special handling
161                 Net.setSocketOption(fd, Net.UNSPEC, name, value);
162             }
163             return this;
164         }
165     }
166 
167     @Override
168     @SuppressWarnings(&quot;unchecked&quot;)
169     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
170         throws IOException
171     {
172         Objects.requireNonNull(name);
173         if (!supportedOptions().contains(name))
174             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
175 
176         synchronized (stateLock) {
177             ensureOpen();
178             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; Net.useExclusiveBind()) {
179                 // SO_REUSEADDR emulated when using exclusive bind
180                 return (T)Boolean.valueOf(isReuseAddress);
181             }
182             // no options that require special handling
183             return (T) Net.getSocketOption(fd, Net.UNSPEC, name);
184         }
185     }
186 
187     private static class DefaultOptionsHolder {
188         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
189 
190         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
191             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
192             set.add(StandardSocketOptions.SO_RCVBUF);
193             set.add(StandardSocketOptions.SO_REUSEADDR);
194             if (Net.isReusePortAvailable()) {
195                 set.add(StandardSocketOptions.SO_REUSEPORT);
196             }
197             set.addAll(ExtendedSocketOptions.serverSocketOptions());
198             return Collections.unmodifiableSet(set);
199         }
200     }
201 
202     @Override
203     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
204         return DefaultOptionsHolder.defaultOptions;
205     }
206 
207     @Override
208     public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {
209         synchronized (stateLock) {
210             ensureOpen();
211             if (localAddress != null)
212                 throw new AlreadyBoundException();
213             InetSocketAddress isa = (local == null)
214                                     ? new InetSocketAddress(0)
215                                     : Net.checkAddress(local);
216             SecurityManager sm = System.getSecurityManager();
217             if (sm != null)
218                 sm.checkListen(isa.getPort());
219             NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());
220             Net.bind(fd, isa.getAddress(), isa.getPort());
221             Net.listen(fd, backlog &lt; 1 ? 50 : backlog);
222             localAddress = Net.localAddress(fd);
223         }
224         return this;
225     }
226 
227     /**
228      * Marks the beginning of an I/O operation that might block.
229      *
230      * @throws ClosedChannelException if the channel is closed
231      * @throws NotYetBoundException if the channel&#39;s socket has not been bound yet
232      */
233     private void begin(boolean blocking) throws ClosedChannelException {
234         if (blocking)
235             begin();  // set blocker to close channel if interrupted
236         synchronized (stateLock) {
237             ensureOpen();
238             if (localAddress == null)
239                 throw new NotYetBoundException();
240             if (blocking)
241                 thread = NativeThread.current();
242         }
243     }
244 
245     /**
246      * Marks the end of an I/O operation that may have blocked.
247      *
248      * @throws AsynchronousCloseException if the channel was closed due to this
249      * thread being interrupted on a blocking I/O operation.
250      */
251     private void end(boolean blocking, boolean completed)
252         throws AsynchronousCloseException
253     {
254         if (blocking) {
255             synchronized (stateLock) {
256                 thread = 0;
<a name="8" id="anc8"></a>
257                 if (state == ST_CLOSING) {
<a name="9" id="anc9"></a><span class="line-modified">258                     tryFinishClose();</span>
259                 }
260             }
261             end(completed);
262         }
263     }
264 
265     @Override
266     public SocketChannel accept() throws IOException {
<a name="10" id="anc10"></a><span class="line-added">267         int n = 0;</span>
<span class="line-added">268         FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-added">269         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
<span class="line-added">270 </span>
271         acceptLock.lock();
272         try {
<a name="11" id="anc11"></a>



273             boolean blocking = isBlocking();
274             try {
275                 begin(blocking);
<a name="12" id="anc12"></a><span class="line-modified">276                 n = Net.accept(this.fd, newfd, isaa);</span>
<span class="line-modified">277                 if (blocking) {</span>
<span class="line-modified">278                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">279                         park(Net.POLLIN);</span>
<span class="line-added">280                         n = Net.accept(this.fd, newfd, isaa);</span>
<span class="line-added">281                     }</span>
<span class="line-added">282                 }</span>
283             } finally {
284                 end(blocking, n &gt; 0);
285                 assert IOStatus.check(n);
286             }
<a name="13" id="anc13"></a><span class="line-added">287         } finally {</span>
<span class="line-added">288             acceptLock.unlock();</span>
<span class="line-added">289         }</span>
290 
<a name="14" id="anc14"></a><span class="line-modified">291         if (n &gt; 0) {</span>
<span class="line-modified">292             return finishAccept(newfd, isaa[0]);</span>
<span class="line-added">293         } else {</span>
<span class="line-added">294             return null;</span>
<span class="line-added">295         }</span>
<span class="line-added">296     }</span>
297 
<a name="15" id="anc15"></a><span class="line-modified">298     /**</span>
<span class="line-modified">299      * Accepts a new connection with a given timeout. This method requires the</span>
<span class="line-added">300      * channel to be configured in blocking mode.</span>
<span class="line-added">301      *</span>
<span class="line-added">302      * @apiNote This method is for use by the socket adaptor.</span>
<span class="line-added">303      *</span>
<span class="line-added">304      * @param nanos the timeout, in nanoseconds</span>
<span class="line-added">305      * @throws IllegalBlockingModeException if the channel is configured non-blocking</span>
<span class="line-added">306      * @throws SocketTimeoutException if the timeout expires</span>
<span class="line-added">307      */</span>
<span class="line-added">308     SocketChannel blockingAccept(long nanos) throws IOException {</span>
<span class="line-added">309         int n = 0;</span>
<span class="line-added">310         FileDescriptor newfd = new FileDescriptor();</span>
<span class="line-added">311         InetSocketAddress[] isaa = new InetSocketAddress[1];</span>
312 
<a name="16" id="anc16"></a><span class="line-modified">313         acceptLock.lock();</span>
<span class="line-modified">314         try {</span>
<span class="line-added">315             // check that channel is configured blocking</span>
<span class="line-added">316             if (!isBlocking())</span>
<span class="line-added">317                 throw new IllegalBlockingModeException();</span>
318 
<a name="17" id="anc17"></a><span class="line-modified">319             try {</span>
<span class="line-modified">320                 begin(true);</span>
<span class="line-modified">321                 // change socket to non-blocking</span>
<span class="line-added">322                 lockedConfigureBlocking(false);</span>
323                 try {
<a name="18" id="anc18"></a><span class="line-modified">324                     long startNanos = System.nanoTime();</span>
<span class="line-modified">325                     n = Net.accept(fd, newfd, isaa);</span>
<span class="line-modified">326                     while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {</span>
<span class="line-modified">327                         long remainingNanos = nanos - (System.nanoTime() - startNanos);</span>
<span class="line-added">328                         if (remainingNanos &lt;= 0) {</span>
<span class="line-added">329                             throw new SocketTimeoutException(&quot;Accept timed out&quot;);</span>
<span class="line-added">330                         }</span>
<span class="line-added">331                         park(Net.POLLIN, remainingNanos);</span>
<span class="line-added">332                         n = Net.accept(fd, newfd, isaa);</span>
<span class="line-added">333                     }</span>
<span class="line-added">334                 } finally {</span>
<span class="line-added">335                     // restore socket to blocking mode (if channel is open)</span>
<span class="line-added">336                     tryLockedConfigureBlocking(true);</span>
337                 }
<a name="19" id="anc19"></a><span class="line-added">338             } finally {</span>
<span class="line-added">339                 end(true, n &gt; 0);</span>
340             }
<a name="20" id="anc20"></a>

341         } finally {
342             acceptLock.unlock();
343         }
<a name="21" id="anc21"></a><span class="line-added">344 </span>
<span class="line-added">345         assert n &gt; 0;</span>
<span class="line-added">346         return finishAccept(newfd, isaa[0]);</span>
<span class="line-added">347     }</span>
<span class="line-added">348 </span>
<span class="line-added">349     private SocketChannel finishAccept(FileDescriptor newfd, InetSocketAddress isa)</span>
<span class="line-added">350         throws IOException</span>
<span class="line-added">351     {</span>
<span class="line-added">352         try {</span>
<span class="line-added">353             // newly accepted socket is initially in blocking mode</span>
<span class="line-added">354             IOUtil.configureBlocking(newfd, true);</span>
<span class="line-added">355 </span>
<span class="line-added">356             // check permitted to accept connections from the remote address</span>
<span class="line-added">357             SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">358             if (sm != null) {</span>
<span class="line-added">359                 sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());</span>
<span class="line-added">360             }</span>
<span class="line-added">361             return new SocketChannelImpl(provider(), newfd, isa);</span>
<span class="line-added">362         } catch (Exception e) {</span>
<span class="line-added">363             nd.close(newfd);</span>
<span class="line-added">364             throw e;</span>
<span class="line-added">365         }</span>
366     }
367 
368     @Override
369     protected void implConfigureBlocking(boolean block) throws IOException {
370         acceptLock.lock();
371         try {
<a name="22" id="anc22"></a><span class="line-modified">372             lockedConfigureBlocking(block);</span>



373         } finally {
374             acceptLock.unlock();
375         }
376     }
377 
378     /**
<a name="23" id="anc23"></a><span class="line-modified">379      * Adjust the blocking. acceptLock must already be held.</span>
<span class="line-modified">380      */</span>
<span class="line-modified">381     private void lockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-modified">382         assert acceptLock.isHeldByCurrentThread();</span>
<span class="line-modified">383         synchronized (stateLock) {</span>
<span class="line-modified">384             ensureOpen();</span>
<span class="line-added">385             IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">386         }</span>
<span class="line-added">387     }</span>
<span class="line-added">388 </span>
<span class="line-added">389     /**</span>
<span class="line-added">390      * Adjusts the blocking mode if the channel is open. acceptLock must already</span>
<span class="line-added">391      * be held.</span>
392      *
<a name="24" id="anc24"></a><span class="line-modified">393      * @return {@code true} if the blocking mode was adjusted, {@code false} if</span>
<span class="line-modified">394      *         the blocking mode was not adjusted because the channel is closed</span>


395      */
<a name="25" id="anc25"></a><span class="line-modified">396     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {</span>
<span class="line-modified">397         assert acceptLock.isHeldByCurrentThread();</span>
<span class="line-modified">398         synchronized (stateLock) {</span>
<span class="line-added">399             if (isOpen()) {</span>
<span class="line-added">400                 IOUtil.configureBlocking(fd, block);</span>
<span class="line-added">401                 return true;</span>
<span class="line-added">402             } else {</span>
<span class="line-added">403                 return false;</span>
<span class="line-added">404             }</span>
<span class="line-added">405         }</span>
<span class="line-added">406     }</span>
407 
<a name="26" id="anc26"></a><span class="line-modified">408     /**</span>
<span class="line-modified">409      * Closes the socket if there are no accept in progress and the channel is</span>
<span class="line-added">410      * not registered with a Selector.</span>
<span class="line-added">411      */</span>
<span class="line-added">412     private boolean tryClose() throws IOException {</span>
<span class="line-added">413         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-added">414         if ((thread == 0) &amp;&amp; !isRegistered()) {</span>
<span class="line-added">415             state = ST_CLOSED;</span>
<span class="line-added">416             nd.close(fd);</span>
<span class="line-added">417             return true;</span>
<span class="line-added">418         } else {</span>
<span class="line-added">419             return false;</span>
<span class="line-added">420         }</span>
<span class="line-added">421     }</span>
422 
<a name="27" id="anc27"></a><span class="line-modified">423     /**</span>
<span class="line-added">424      * Invokes tryClose to attempt to close the socket.</span>
<span class="line-added">425      *</span>
<span class="line-added">426      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">427      */</span>
<span class="line-added">428     private void tryFinishClose() {</span>
<span class="line-added">429         try {</span>
<span class="line-added">430             tryClose();</span>
<span class="line-added">431         } catch (IOException ignore) { }</span>
<span class="line-added">432     }</span>
<span class="line-added">433 </span>
<span class="line-added">434     /**</span>
<span class="line-added">435      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">436      *</span>
<span class="line-added">437      * If there is an accept in progress then the socket is pre-closed and the</span>
<span class="line-added">438      * accept thread is signalled, in which case the final close is deferred</span>
<span class="line-added">439      * until the accept aborts.</span>
<span class="line-added">440      */</span>
<span class="line-added">441     private void implCloseBlockingMode() throws IOException {</span>
442         synchronized (stateLock) {
443             assert state &lt; ST_CLOSING;
444             state = ST_CLOSING;
<a name="28" id="anc28"></a><span class="line-modified">445             if (!tryClose()) {</span>






446                 long th = thread;
447                 if (th != 0) {
448                     nd.preClose(fd);
449                     NativeThread.signal(th);
<a name="29" id="anc29"></a>








450                 }
451             }
<a name="30" id="anc30"></a>



452         }
<a name="31" id="anc31"></a><span class="line-added">453     }</span>
454 
<a name="32" id="anc32"></a><span class="line-modified">455     /**</span>
<span class="line-added">456      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">457      *</span>
<span class="line-added">458      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">459      * until the channel is flushed from all Selectors.</span>
<span class="line-added">460      */</span>
<span class="line-added">461     private void implCloseNonBlockingMode() throws IOException {</span>
<span class="line-added">462         synchronized (stateLock) {</span>
<span class="line-added">463             assert state &lt; ST_CLOSING;</span>
<span class="line-added">464             state = ST_CLOSING;</span>
<span class="line-added">465         }</span>
<span class="line-added">466         // wait for any accept to complete before trying to close</span>
<span class="line-added">467         acceptLock.lock();</span>
<span class="line-added">468         acceptLock.unlock();</span>
469         synchronized (stateLock) {
<a name="33" id="anc33"></a><span class="line-modified">470             if (state == ST_CLOSING) {</span>
<span class="line-modified">471                 tryClose();</span>
<span class="line-added">472             }</span>
473         }
<a name="34" id="anc34"></a><span class="line-added">474     }</span>
475 
<a name="35" id="anc35"></a><span class="line-modified">476     /**</span>
<span class="line-modified">477      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">478      */</span>
<span class="line-modified">479     @Override</span>
<span class="line-modified">480     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">481         assert !isOpen();</span>
<span class="line-modified">482         if (isBlocking()) {</span>
<span class="line-added">483             implCloseBlockingMode();</span>
<span class="line-added">484         } else {</span>
<span class="line-added">485             implCloseNonBlockingMode();</span>
<span class="line-added">486         }</span>
487     }
488 
489     @Override
<a name="36" id="anc36"></a><span class="line-modified">490     public void kill() {</span>
491         synchronized (stateLock) {
<a name="37" id="anc37"></a><span class="line-modified">492             if (state == ST_CLOSING) {</span>
<span class="line-modified">493                 tryFinishClose();</span>

494             }
495         }
496     }
497 
498     /**
499      * Returns true if channel&#39;s socket is bound
500      */
501     boolean isBound() {
502         synchronized (stateLock) {
503             return localAddress != null;
504         }
505     }
506 
507     /**
508      * Returns the local address, or null if not bound
509      */
510     InetSocketAddress localAddress() {
511         synchronized (stateLock) {
512             return localAddress;
513         }
514     }
515 
<a name="38" id="anc38"></a>





















516     /**
517      * Translates native poll revent set into a ready operation set
518      */
519     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
520         int intOps = ski.nioInterestOps();
521         int oldOps = ski.nioReadyOps();
522         int newOps = initialOps;
523 
524         if ((ops &amp; Net.POLLNVAL) != 0) {
525             // This should only happen if this channel is pre-closed while a
526             // selection operation is in progress
527             // ## Throw an error if this channel has not been pre-closed
528             return false;
529         }
530 
531         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
532             newOps = intOps;
533             ski.nioReadyOps(newOps);
534             return (newOps &amp; ~oldOps) != 0;
535         }
536 
537         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
538             ((intOps &amp; SelectionKey.OP_ACCEPT) != 0))
539                 newOps |= SelectionKey.OP_ACCEPT;
540 
541         ski.nioReadyOps(newOps);
542         return (newOps &amp; ~oldOps) != 0;
543     }
544 
545     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
546         return translateReadyOps(ops, ski.nioReadyOps(), ski);
547     }
548 
549     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
550         return translateReadyOps(ops, 0, ski);
551     }
552 
553     /**
554      * Translates an interest operation set into a native poll event set
555      */
556     public int translateInterestOps(int ops) {
557         int newOps = 0;
558         if ((ops &amp; SelectionKey.OP_ACCEPT) != 0)
559             newOps |= Net.POLLIN;
560         return newOps;
561     }
562 
563     public FileDescriptor getFD() {
564         return fd;
565     }
566 
567     public int getFDVal() {
568         return fdVal;
569     }
570 
571     public String toString() {
572         StringBuilder sb = new StringBuilder();
573         sb.append(this.getClass().getName());
574         sb.append(&#39;[&#39;);
575         if (!isOpen()) {
576             sb.append(&quot;closed&quot;);
577         } else {
578             synchronized (stateLock) {
579                 InetSocketAddress addr = localAddress;
580                 if (addr == null) {
581                     sb.append(&quot;unbound&quot;);
582                 } else {
583                     sb.append(Net.getRevealedLocalAddressAsString(addr));
584                 }
585             }
586         }
587         sb.append(&#39;]&#39;);
588         return sb.toString();
589     }
<a name="39" id="anc39"></a>

































590 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.text.MessageFormat;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;
 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();
 54     static final SSLStringizer chStringizer =
 55             new CHKeyShareStringizer();
 56 
 57     static final HandshakeProducer shNetworkProducer =
 58             new SHKeyShareProducer();
 59     static final ExtensionConsumer shOnLoadConsumer =
 60             new SHKeyShareConsumer();
 61     static final HandshakeAbsence shOnLoadAbsence =
 62             new SHKeyShareAbsence();
 63     static final SSLStringizer shStringizer =
 64             new SHKeyShareStringizer();
 65 
 66     static final HandshakeProducer hrrNetworkProducer =
 67             new HRRKeyShareProducer();
 68     static final ExtensionConsumer hrrOnLoadConsumer =
 69             new HRRKeyShareConsumer();
 70     static final HandshakeProducer hrrNetworkReproducer =
 71             new HRRKeyShareReproducer();
 72     static final SSLStringizer hrrStringizer =
 73             new HRRKeyShareStringizer();
 74 
 75     /**
 76      * The key share entry used in &quot;key_share&quot; extensions.
 77      */
 78     private static final class KeyShareEntry {
 79         final int namedGroupId;
 80         final byte[] keyExchange;
 81 
 82         private KeyShareEntry(int namedGroupId, byte[] keyExchange) {
 83             this.namedGroupId = namedGroupId;
 84             this.keyExchange = keyExchange;
 85         }
 86 
 87         private byte[] getEncoded() {
 88             byte[] buffer = new byte[keyExchange.length + 4];
 89                                             //  2: named group id
 90                                             // +2: key exchange length
 91             ByteBuffer m = ByteBuffer.wrap(buffer);
 92             try {
 93                 Record.putInt16(m, namedGroupId);
 94                 Record.putBytes16(m, keyExchange);
 95             } catch (IOException ioe) {
 96                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 97                     SSLLogger.warning(
 98                         &quot;Unlikely IOException&quot;, ioe);
 99                 }
100             }
101 
102             return buffer;
103         }
104 
105         private int getEncodedSize() {
106             return keyExchange.length + 4;  //  2: named group id
107                                             // +2: key exchange length
108         }
109 
110         @Override
111         public String toString() {
112             MessageFormat messageFormat = new MessageFormat(
113                 &quot;\n&#39;{&#39;\n&quot; +
114                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
115                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
116                 &quot;{1}\n&quot; +
117                 &quot;  &#39;}&#39;\n&quot; +
118                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
119 
120             HexDumpEncoder hexEncoder = new HexDumpEncoder();
121             Object[] messageFields = {
122                 NamedGroup.nameOf(namedGroupId),
123                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
124             };
125 
126             return messageFormat.format(messageFields);
127         }
128     }
129 
130     /**
131      * The &quot;key_share&quot; extension in a ClientHello handshake message.
132      */
133     static final class CHKeyShareSpec implements SSLExtensionSpec {
134         final List&lt;KeyShareEntry&gt; clientShares;
135 
136         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
137             this.clientShares = clientShares;
138         }
139 
140         private CHKeyShareSpec(ByteBuffer buffer) throws IOException {
141             // struct {
142             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
143             // } KeyShareClientHello;
144             if (buffer.remaining() &lt; 2) {
145                 throw new SSLProtocolException(
146                     &quot;Invalid key_share extension: &quot; +
147                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);
148             }
149 
150             int listLen = Record.getInt16(buffer);
151             if (listLen != buffer.remaining()) {
152                 throw new SSLProtocolException(
153                     &quot;Invalid key_share extension: &quot; +
154                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;);
155             }
156 
157             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
158             while (buffer.hasRemaining()) {
159                 int namedGroupId = Record.getInt16(buffer);
160                 byte[] keyExchange = Record.getBytes16(buffer);
161                 if (keyExchange.length == 0) {
162                     throw new SSLProtocolException(
163                         &quot;Invalid key_share extension: empty key_exchange&quot;);
164                 }
165 
166                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
167             }
168 
169             this.clientShares = Collections.unmodifiableList(keyShares);
170         }
171 
172         @Override
173         public String toString() {
174             MessageFormat messageFormat = new MessageFormat(
175                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
176 
177             StringBuilder builder = new StringBuilder(512);
178             for (KeyShareEntry entry : clientShares) {
179                 builder.append(entry.toString());
180             }
181 
182             Object[] messageFields = {
183                 Utilities.indent(builder.toString())
184             };
185 
186             return messageFormat.format(messageFields);
187         }
188     }
189 
190     private static final class CHKeyShareStringizer implements SSLStringizer {
191         @Override
192         public String toString(ByteBuffer buffer) {
193             try {
194                 return (new CHKeyShareSpec(buffer)).toString();
195             } catch (IOException ioe) {
196                 // For debug logging only, so please swallow exceptions.
197                 return ioe.getMessage();
198             }
199         }
200     }
201 
202     /**
203      * Network data producer of the extension in a ClientHello
204      * handshake message.
205      */
206     private static final
207             class CHKeyShareProducer implements HandshakeProducer {
208         // Prevent instantiation of this class.
209         private CHKeyShareProducer() {
210             // blank
211         }
212 
213         @Override
214         public byte[] produce(ConnectionContext context,
215                 HandshakeMessage message) throws IOException {
216             // The producing happens in client side only.
217             ClientHandshakeContext chc = (ClientHandshakeContext)context;
218 
219             // Is it a supported and enabled extension?
220             if (!chc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
221                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
222                     SSLLogger.fine(
223                         &quot;Ignore unavailable key_share extension&quot;);
224                 }
225                 return null;
226             }
227 
228             List&lt;NamedGroup&gt; namedGroups;
229             if (chc.serverSelectedNamedGroup != null) {
230                 // Response to HelloRetryRequest
231                 namedGroups = Arrays.asList(chc.serverSelectedNamedGroup);
232             } else {
233                 namedGroups = chc.clientRequestedNamedGroups;
234                 if (namedGroups == null || namedGroups.isEmpty()) {
235                     // No supported groups.
236                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
237                         SSLLogger.warning(
238                             &quot;Ignore key_share extension, no supported groups&quot;);
239                     }
240                     return null;
241                 }
242             }
243 
244             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
245             for (NamedGroup ng : namedGroups) {
246                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
247                 if (ke == null) {
248                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
249                         SSLLogger.warning(
250                             &quot;No key exchange for named group &quot; + ng.name);
251                     }
252                     continue;
253                 }
254 
255                 SSLPossession[] poses = ke.createPossessions(chc);
256                 for (SSLPossession pos : poses) {
257                     // update the context
258                     chc.handshakePossessions.add(pos);
259                     if (!(pos instanceof NamedGroupPossession)) {
260                         // May need more possesion types in the future.
261                         continue;
262                     }
263 
264                     keyShares.add(new KeyShareEntry(ng.id, pos.encode()));
265                 }
266 
267                 // One key share entry only.  Too much key share entries makes
268                 // the ClientHello handshake message really big.
269                 if (!keyShares.isEmpty()) {
270                     break;
271                 }
272             }
273 
274             int listLen = 0;
275             for (KeyShareEntry entry : keyShares) {
276                 listLen += entry.getEncodedSize();
277             }
278             byte[] extData = new byte[listLen + 2];     //  2: list length
279             ByteBuffer m = ByteBuffer.wrap(extData);
280             Record.putInt16(m, listLen);
281             for (KeyShareEntry entry : keyShares) {
282                 m.put(entry.getEncoded());
283             }
284 
285             // update the context
286             chc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE,
287                     new CHKeyShareSpec(keyShares));
288 
289             return extData;
290         }
291     }
292 
293     /**
294      * Network data consumer of the extension in a ClientHello
295      * handshake message.
296      */
297     private static final class CHKeyShareConsumer implements ExtensionConsumer {
298         // Prevent instantiation of this class.
299         private CHKeyShareConsumer() {
300             // blank
301         }
302 
303         @Override
304         public void consume(ConnectionContext context,
305             HandshakeMessage message, ByteBuffer buffer) throws IOException {
306             // The consuming happens in server side only.
307             ServerHandshakeContext shc = (ServerHandshakeContext)context;
308 
309             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
310                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
311                     SSLLogger.fine(
312                             &quot;The key_share extension has been loaded&quot;);
313                 }
314                 return;
315             }
316 
317             // Is it a supported and enabled extension?
318             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
319                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
320                     SSLLogger.fine(
321                             &quot;Ignore unavailable key_share extension&quot;);
322                 }
323                 return;     // ignore the extension
324             }
325 
326             // Parse the extension
327             CHKeyShareSpec spec;
328             try {
329                 spec = new CHKeyShareSpec(buffer);
330             } catch (IOException ioe) {
331                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
332             }
333 
334             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
335             for (KeyShareEntry entry : spec.clientShares) {
336                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
337                 if (ng == null || !SupportedGroups.isActivatable(
338                         shc.sslConfig.algorithmConstraints, ng)) {
339                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
340                         SSLLogger.fine(
341                                 &quot;Ignore unsupported named group: &quot; +
342                                 NamedGroup.nameOf(entry.namedGroupId));
343                     }
344                     continue;
345                 }
346 
347                 try {
348                     SSLCredentials kaCred =
349                         ng.decodeCredentials(entry.keyExchange,
350                         shc.algorithmConstraints,
351                         s -&gt; SSLLogger.warning(s));
352                     if (kaCred != null) {
353                         credentials.add(kaCred);
354                     }
355                 } catch (GeneralSecurityException ex) {
356                     SSLLogger.warning(
357                         &quot;Cannot decode named group: &quot; +
358                         NamedGroup.nameOf(entry.namedGroupId));
359                 }
360             }
361 
362             if (!credentials.isEmpty()) {
363                 shc.handshakeCredentials.addAll(credentials);
364             } else {
365                 // New handshake credentials are required from the client side.
366                 shc.handshakeProducers.put(
367                         SSLHandshake.HELLO_RETRY_REQUEST.id,
368                         SSLHandshake.HELLO_RETRY_REQUEST);
369             }
370 
371             // update the context
372             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
373         }
374     }
375 
376     /**
377      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
378      */
379     static final class SHKeyShareSpec implements SSLExtensionSpec {
380         final KeyShareEntry serverShare;
381 
382         SHKeyShareSpec(KeyShareEntry serverShare) {
383             this.serverShare = serverShare;
384         }
385 
386         private SHKeyShareSpec(ByteBuffer buffer) throws IOException {
387             // struct {
388             //      KeyShareEntry server_share;
389             // } KeyShareServerHello;
390             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
391                 throw new SSLProtocolException(
392                     &quot;Invalid key_share extension: &quot; +
393                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);
394             }
395 
396             int namedGroupId = Record.getInt16(buffer);
397             byte[] keyExchange = Record.getBytes16(buffer);
398 
399             if (buffer.hasRemaining()) {
400                 throw new SSLProtocolException(
401                     &quot;Invalid key_share extension: unknown extra data&quot;);
402             }
403 
404             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
405         }
406 
407         @Override
408         public String toString() {
409             MessageFormat messageFormat = new MessageFormat(
410                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
411                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
412                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
413                 &quot;{1}\n&quot; +
414                 &quot;  &#39;}&#39;\n&quot; +
415                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
416 
417             HexDumpEncoder hexEncoder = new HexDumpEncoder();
418             Object[] messageFields = {
419                 NamedGroup.nameOf(serverShare.namedGroupId),
420                 Utilities.indent(
421                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
422             };
423 
424             return messageFormat.format(messageFields);
425         }
426     }
427 
428     private static final class SHKeyShareStringizer implements SSLStringizer {
429         @Override
430         public String toString(ByteBuffer buffer) {
431             try {
432                 return (new SHKeyShareSpec(buffer)).toString();
433             } catch (IOException ioe) {
434                 // For debug logging only, so please swallow exceptions.
435                 return ioe.getMessage();
436             }
437         }
438     }
439 
440     /**
441      * Network data producer of the extension in a ServerHello
442      * handshake message.
443      */
444     private static final class SHKeyShareProducer implements HandshakeProducer {
445         // Prevent instantiation of this class.
446         private SHKeyShareProducer() {
447             // blank
448         }
449 
450         @Override
451         public byte[] produce(ConnectionContext context,
452                 HandshakeMessage message) throws IOException {
453             // The producing happens in client side only.
454             ServerHandshakeContext shc = (ServerHandshakeContext)context;
455 
456             // In response to key_share request only
457             CHKeyShareSpec kss =
458                     (CHKeyShareSpec)shc.handshakeExtensions.get(
459                             SSLExtension.CH_KEY_SHARE);
460             if (kss == null) {
461                 // Unlikely, no key_share extension requested.
462                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
463                     SSLLogger.warning(
464                             &quot;Ignore, no client key_share extension&quot;);
465                 }
466                 return null;
467             }
468 
469             // Is it a supported and enabled extension?
470             if (!shc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
471                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
472                     SSLLogger.warning(
473                             &quot;Ignore, no available server key_share extension&quot;);
474                 }
475                 return null;
476             }
477 
478             // use requested key share entries
479             if ((shc.handshakeCredentials == null) ||
480                     shc.handshakeCredentials.isEmpty()) {
481                 // Unlikely, HelloRetryRequest should be used ealier.
482                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
483                     SSLLogger.warning(
484                             &quot;No available client key share entries&quot;);
485                 }
486                 return null;
487             }
488 
489             KeyShareEntry keyShare = null;
490             for (SSLCredentials cd : shc.handshakeCredentials) {
491                 NamedGroup ng = null;
492                 if (cd instanceof NamedGroupCredentials) {
493                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;
494                     ng = creds.getNamedGroup();
495                 }
496 
497                 if (ng == null) {
498                     continue;
499                 }
500 
501                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
502                 if (ke == null) {
503                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
504                         SSLLogger.warning(
505                             &quot;No key exchange for named group &quot; + ng.name);
506                     }
507                     continue;
508                 }
509 
510                 SSLPossession[] poses = ke.createPossessions(shc);
511                 for (SSLPossession pos : poses) {
512                     if (!(pos instanceof NamedGroupPossession)) {
513                         // May need more possesion types in the future.
514                         continue;
515                     }
516 
517                     // update the context
518                     shc.handshakeKeyExchange = ke;
519                     shc.handshakePossessions.add(pos);
520                     keyShare = new KeyShareEntry(ng.id, pos.encode());
521                     break;
522                 }
523 
524                 if (keyShare != null) {
525                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
526                             ke.getHandshakeProducers(shc)) {
527                         shc.handshakeProducers.put(
528                                 me.getKey(), me.getValue());
529                     }
530 
531                     // We have got one! Don&#39;t forget to break.
532                     break;
533                 }
534             }
535 
536             if (keyShare == null) {
537                 // Unlikely, HelloRetryRequest should be used instead ealier.
538                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
539                     SSLLogger.warning(
540                             &quot;No available server key_share extension&quot;);
541                 }
542                 return null;
543             }
544 
545             byte[] extData = keyShare.getEncoded();
546 
547             // update the context
548             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
549             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
550 
551             return extData;
552         }
553     }
554 
555     /**
556      * Network data consumer of the extension in a ServerHello
557      * handshake message.
558      */
559     private static final class SHKeyShareConsumer implements ExtensionConsumer {
560         // Prevent instantiation of this class.
561         private SHKeyShareConsumer() {
562             // blank
563         }
564 
565         @Override
566         public void consume(ConnectionContext context,
567             HandshakeMessage message, ByteBuffer buffer) throws IOException {
568             // Happens in client side only.
569             ClientHandshakeContext chc = (ClientHandshakeContext)context;
570             if (chc.clientRequestedNamedGroups == null ||
571                     chc.clientRequestedNamedGroups.isEmpty()) {
572                 // No supported groups.
573                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
574                         &quot;Unexpected key_share extension in ServerHello&quot;);
575             }
576 
577             // Is it a supported and enabled extension?
578             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
579                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
580                         &quot;Unsupported key_share extension in ServerHello&quot;);
581             }
582 
583             // Parse the extension
584             SHKeyShareSpec spec;
585             try {
586                 spec = new SHKeyShareSpec(buffer);
587             } catch (IOException ioe) {
588                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
589             }
590 
591             KeyShareEntry keyShare = spec.serverShare;
592             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
593             if (ng == null || !SupportedGroups.isActivatable(
594                     chc.sslConfig.algorithmConstraints, ng)) {
595                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
596                         &quot;Unsupported named group: &quot; +
597                         NamedGroup.nameOf(keyShare.namedGroupId));
598             }
599 
600             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
601             if (ke == null) {
602                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
603                         &quot;No key exchange for named group &quot; + ng.name);
604             }
605 
606             SSLCredentials credentials = null;
607             try {
608                 SSLCredentials kaCred = ng.decodeCredentials(
609                     keyShare.keyExchange, chc.algorithmConstraints,
610                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
611                 if (kaCred != null) {
612                     credentials = kaCred;
613                 }
614             } catch (GeneralSecurityException ex) {
615                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
616                         &quot;Cannot decode named group: &quot; +
617                         NamedGroup.nameOf(keyShare.namedGroupId));
618             }
619 
620             if (credentials == null) {
621                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
622                         &quot;Unsupported named group: &quot; + ng.name);
623             }
624 
625             // update the context
626             chc.handshakeKeyExchange = ke;
627             chc.handshakeCredentials.add(credentials);
628             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
629         }
630     }
631 
632     /**
633      * The absence processing if the extension is not present in
634      * the ServerHello handshake message.
635      */
636     private static final class SHKeyShareAbsence implements HandshakeAbsence {
637         @Override
638         public void absent(ConnectionContext context,
639                 HandshakeMessage message) throws IOException {
640             // The producing happens in client side only.
641             ClientHandshakeContext chc = (ClientHandshakeContext)context;
642 
643             // Cannot use the previous requested key shares any more.
644             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
645                 SSLLogger.fine(
646                         &quot;No key_share extension in ServerHello, &quot; +
647                         &quot;cleanup the key shares if necessary&quot;);
648             }
649             chc.handshakePossessions.clear();
650         }
651     }
652 
653     /**
654      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
655      */
656     static final class HRRKeyShareSpec implements SSLExtensionSpec {
657         final int selectedGroup;
658 
659         HRRKeyShareSpec(NamedGroup serverGroup) {
660             this.selectedGroup = serverGroup.id;
661         }
662 
663         private HRRKeyShareSpec(ByteBuffer buffer) throws IOException {
664             // struct {
665             //     NamedGroup selected_group;
666             // } KeyShareHelloRetryRequest;
667             if (buffer.remaining() != 2) {
668                 throw new SSLProtocolException(
669                     &quot;Invalid key_share extension: &quot; +
670                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;);
671             }
672 
673             this.selectedGroup = Record.getInt16(buffer);
674         }
675 
676         @Override
677         public String toString() {
678             MessageFormat messageFormat = new MessageFormat(
679                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
680 
681             Object[] messageFields = {
682                     NamedGroup.nameOf(selectedGroup)
683                 };
684             return messageFormat.format(messageFields);
685         }
686     }
687 
688     private static final class HRRKeyShareStringizer implements SSLStringizer {
689         @Override
690         public String toString(ByteBuffer buffer) {
691             try {
692                 return (new HRRKeyShareSpec(buffer)).toString();
693             } catch (IOException ioe) {
694                 // For debug logging only, so please swallow exceptions.
695                 return ioe.getMessage();
696             }
697         }
698     }
699 
700     /**
701      * Network data producer of the extension in a HelloRetryRequest
702      * handshake message.
703      */
704     private static final
705             class HRRKeyShareProducer implements HandshakeProducer {
706         // Prevent instantiation of this class.
707         private HRRKeyShareProducer() {
708             // blank
709         }
710 
711         @Override
712         public byte[] produce(ConnectionContext context,
713                 HandshakeMessage message) throws IOException {
714             // The producing happens in server side only.
715             ServerHandshakeContext shc = (ServerHandshakeContext) context;
716 
717             // Is it a supported and enabled extension?
718             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
719                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
720                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
721             }
722 
723             if (shc.clientRequestedNamedGroups == null ||
724                     shc.clientRequestedNamedGroups.isEmpty()) {
725                 // No supported groups.
726                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
727                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
728             }
729 
730             NamedGroup selectedGroup = null;
731             for (NamedGroup ng : shc.clientRequestedNamedGroups) {
732                 if (SupportedGroups.isActivatable(
733                         shc.sslConfig.algorithmConstraints, ng)) {
734                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
735                         SSLLogger.fine(
736                                 &quot;HelloRetryRequest selected named group: &quot; +
737                                 ng.name);
738                     }
739 
740                     selectedGroup = ng;
741                     break;
742                 }
743             }
744 
745             if (selectedGroup == null) {
746                 throw shc.conContext.fatal(
747                         Alert.UNEXPECTED_MESSAGE, &quot;No common named group&quot;);
748             }
749 
750             byte[] extdata = new byte[] {
751                     (byte)((selectedGroup.id &gt;&gt; 8) &amp; 0xFF),
752                     (byte)(selectedGroup.id &amp; 0xFF)
753                 };
754 
755             // update the context
756             shc.serverSelectedNamedGroup = selectedGroup;
757             shc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE,
758                     new HRRKeyShareSpec(selectedGroup));
759 
760             return extdata;
761         }
762     }
763 
764     /**
765      * Network data producer of the extension for stateless
766      * HelloRetryRequest reconstruction.
767      */
768     private static final
769             class HRRKeyShareReproducer implements HandshakeProducer {
770         // Prevent instantiation of this class.
771         private HRRKeyShareReproducer() {
772             // blank
773         }
774 
775         @Override
776         public byte[] produce(ConnectionContext context,
777                 HandshakeMessage message) throws IOException {
778             // The producing happens in server side only.
779             ServerHandshakeContext shc = (ServerHandshakeContext) context;
780 
781             // Is it a supported and enabled extension?
782             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
783                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
784                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
785             }
786 
787             CHKeyShareSpec spec = (CHKeyShareSpec)shc.handshakeExtensions.get(
788                     SSLExtension.CH_KEY_SHARE);
789             if (spec != null &amp;&amp; spec.clientShares != null &amp;&amp;
790                     spec.clientShares.size() == 1) {
791                 int namedGroupId = spec.clientShares.get(0).namedGroupId;
792 
793                 byte[] extdata = new byte[] {
794                         (byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF),
795                         (byte)(namedGroupId &amp; 0xFF)
796                     };
797 
798                 return extdata;
799             }
800 
801             return null;
802         }
803     }
804 
805     /**
806      * Network data consumer of the extension in a HelloRetryRequest
807      * handshake message.
808      */
809     private static final
810             class HRRKeyShareConsumer implements ExtensionConsumer {
811         // Prevent instantiation of this class.
812         private HRRKeyShareConsumer() {
813             // blank
814         }
815 
816         @Override
817         public void consume(ConnectionContext context,
818             HandshakeMessage message, ByteBuffer buffer) throws IOException {
819             // The producing happens in client side only.
820             ClientHandshakeContext chc = (ClientHandshakeContext)context;
821 
822             // Is it a supported and enabled extension?
823             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
824                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
825                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
826             }
827 
828             if (chc.clientRequestedNamedGroups == null ||
829                     chc.clientRequestedNamedGroups.isEmpty()) {
830                 // No supported groups.
831                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             // Parse the extension
836             HRRKeyShareSpec spec;
837             try {
838                 spec = new HRRKeyShareSpec(buffer);
839             } catch (IOException ioe) {
840                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
841             }
842 
843             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
844             if (serverGroup == null) {
845                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
846                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
847                                 NamedGroup.nameOf(spec.selectedGroup));
848             }
849 
850             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
851                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
852                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
853                                 serverGroup.name);
854             }
855 
856             // update the context
857 
858             // When sending the new ClientHello, the client MUST replace the
859             // original &quot;key_share&quot; extension with one containing only a new
860             // KeyShareEntry for the group indicated in the selected_group
861             // field of the triggering HelloRetryRequest.
862             //
863             chc.serverSelectedNamedGroup = serverGroup;
864             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
865         }
866     }
867 }
    </pre>
  </body>
</html>
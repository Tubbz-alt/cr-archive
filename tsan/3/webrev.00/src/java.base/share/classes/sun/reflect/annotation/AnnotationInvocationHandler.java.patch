diff a/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java b/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java
--- a/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java
+++ b/src/java.base/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,12 +39,14 @@
  *
  * @author  Josh Bloch
  * @since   1.5
  */
 class AnnotationInvocationHandler implements InvocationHandler, Serializable {
+    @java.io.Serial
     private static final long serialVersionUID = 6182022883658399397L;
     private final Class<? extends Annotation> type;
+    @SuppressWarnings("serial") // Not statically typed as Serializable
     private final Map<String, Object> memberValues;
 
     AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
         Class<?>[] superInterfaces = type.getInterfaces();
         if (!type.isAnnotation() ||
@@ -143,18 +145,24 @@
         StringBuilder result = new StringBuilder(128);
         result.append('@');
         result.append(type.getName());
         result.append('(');
         boolean firstMember = true;
-        for (Map.Entry<String, Object> e : memberValues.entrySet()) {
+        Set<Map.Entry<String, Object>> entries = memberValues.entrySet();
+        boolean loneValue = entries.size() == 1;
+        for (Map.Entry<String, Object> e : entries) {
             if (firstMember)
                 firstMember = false;
             else
                 result.append(", ");
 
-            result.append(e.getKey());
-            result.append('=');
+            String key = e.getKey();
+            if (!loneValue || !"value".equals(key)) {
+                result.append(key);
+                result.append('=');
+            }
+            loneValue = false;
             result.append(memberValueToString(e.getValue()));
         }
         result.append(')');
         return result.toString();
     }
@@ -176,10 +184,12 @@
                 return  toSourceString((double) value);
             else if (type == Float.class)
                 return  toSourceString((float) value);
             else if (type == Long.class)
                 return  toSourceString((long) value);
+            else if (type == Byte.class)
+                return  toSourceString((byte) value);
             else
                 return value.toString();
         } else {
             Stream<String> stringStream;
             if (type == byte[].class)
@@ -219,18 +229,18 @@
      * Translates a Class value to a form suitable for use in the
      * string representation of an annotation.
      */
     private static String toSourceString(Class<?> clazz) {
         Class<?> finalComponent = clazz;
-        StringBuilder arrayBackets = new StringBuilder();
+        StringBuilder arrayBrackets = new StringBuilder();
 
         while(finalComponent.isArray()) {
             finalComponent = finalComponent.getComponentType();
-            arrayBackets.append("[]");
+            arrayBrackets.append("[]");
         }
 
-        return finalComponent.getName() + arrayBackets.toString() + ".class" ;
+        return finalComponent.getName() + arrayBrackets.toString() + ".class";
     }
 
     private static String toSourceString(float f) {
         if (Float.isFinite(f))
             return Float.toString(f) + "f" ;
@@ -254,42 +264,68 @@
     }
 
     private static String toSourceString(char c) {
         StringBuilder sb = new StringBuilder(4);
         sb.append('\'');
-        if (c == '\'')
-            sb.append("\\'");
-        else
-            sb.append(c);
-        return sb.append('\'')
-                .toString();
+        sb.append(quote(c));
+        return sb.append('\'') .toString();
+    }
+
+    /**
+     * Escapes a character if it has an escape sequence or is
+     * non-printable ASCII.  Leaves non-ASCII characters alone.
+     */
+    private static String quote(char ch) {
+        switch (ch) {
+        case '\b':  return "\\b";
+        case '\f':  return "\\f";
+        case '\n':  return "\\n";
+        case '\r':  return "\\r";
+        case '\t':  return "\\t";
+        case '\'':  return "\\'";
+        case '\"':  return "\\\"";
+        case '\\':  return "\\\\";
+        default:
+            return (isPrintableAscii(ch))
+                ? String.valueOf(ch)
+                : String.format("\\u%04x", (int) ch);
+        }
+    }
+
+    /**
+     * Is a character printable ASCII?
+     */
+    private static boolean isPrintableAscii(char ch) {
+        return ch >= ' ' && ch <= '~';
+    }
+
+    private static String toSourceString(byte b) {
+        return String.format("(byte)0x%02x", b);
     }
 
     private static String toSourceString(long ell) {
-        String str = String.valueOf(ell);
-        return (ell < Integer.MIN_VALUE || ell > Integer.MAX_VALUE)
-                ? (str + 'L') : str;
+        return String.valueOf(ell) + "L";
     }
 
     /**
      * Return a string suitable for use in the string representation
      * of an annotation.
      */
     private static String toSourceString(String s) {
         StringBuilder sb = new StringBuilder();
         sb.append('"');
-        // Escape embedded quote characters, if present, but don't do
-        // anything more heroic.
-        sb.append(s.replace("\"", "\\\""));
+        for (int i = 0; i < s.length(); i++) {
+            sb.append(quote(s.charAt(i)));
+        }
         sb.append('"');
         return sb.toString();
     }
 
     private static Stream<String> convert(byte[] values) {
         List<String> list = new ArrayList<>(values.length);
         for (byte b : values)
-            list.add(Byte.toString(b));
+            list.add(toSourceString(b));
         return list.stream();
     }
 
     private static Stream<String> convert(char[] values) {
         List<String> list = new ArrayList<>(values.length);
@@ -567,10 +603,11 @@
         if (type == boolean[].class)
             return Arrays.hashCode((boolean[]) value);
         return Arrays.hashCode((Object[]) value);
     }
 
+    @java.io.Serial
     private void readObject(java.io.ObjectInputStream s)
         throws java.io.IOException, ClassNotFoundException {
         ObjectInputStream.GetField fields = s.readFields();
 
         @SuppressWarnings("unchecked")

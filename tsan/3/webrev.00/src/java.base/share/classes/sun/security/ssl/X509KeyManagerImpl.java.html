<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/X509KeyManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.lang.ref.*;
 29 import java.net.Socket;
 30 import java.security.AlgorithmConstraints;
 31 import java.security.KeyStore;
 32 import java.security.KeyStore.Builder;
 33 import java.security.KeyStore.Entry;
 34 import java.security.KeyStore.PrivateKeyEntry;
 35 import java.security.Principal;
 36 import java.security.PrivateKey;
 37 import java.security.cert.CertPathValidatorException;
 38 import java.security.cert.Certificate;
 39 import java.security.cert.CertificateException;
 40 import java.security.cert.X509Certificate;
 41 import java.util.*;
 42 import java.util.concurrent.atomic.AtomicLong;
 43 import javax.net.ssl.*;
 44 import sun.security.provider.certpath.AlgorithmChecker;
 45 import sun.security.validator.Validator;
 46 
 47 /**
 48  * The new X509 key manager implementation. The main differences to the
 49  * old SunX509 key manager are:
 50  *  . it is based around the KeyStore.Builder API. This allows it to use
 51  *    other forms of KeyStore protection or password input (e.g. a
 52  *    CallbackHandler) or to have keys within one KeyStore protected by
 53  *    different keys.
 54  *  . it can use multiple KeyStores at the same time.
 55  *  . it is explicitly designed to accommodate KeyStores that change over
 56  *    the lifetime of the process.
 57  *  . it makes an effort to choose the key that matches best, i.e. one that
 58  *    is not expired and has the appropriate certificate extensions.
 59  *
 60  * Note that this code is not explicitly performance optimzied yet.
 61  *
 62  * @author  Andreas Sterbenz
 63  */
 64 final class X509KeyManagerImpl extends X509ExtendedKeyManager
 65         implements X509KeyManager {
 66 
 67     // for unit testing only, set via privileged reflection
 68     private static Date verificationDate;
 69 
 70     // list of the builders
 71     private final List&lt;Builder&gt; builders;
 72 
 73     // counter to generate unique ids for the aliases
 74     private final AtomicLong uidCounter;
 75 
 76     // cached entries
 77     private final Map&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt; entryCacheMap;
 78 
 79     X509KeyManagerImpl(Builder builder) {
 80         this(Collections.singletonList(builder));
 81     }
 82 
 83     X509KeyManagerImpl(List&lt;Builder&gt; builders) {
 84         this.builders = builders;
 85         uidCounter = new AtomicLong();
 86         entryCacheMap = Collections.synchronizedMap
 87                         (new SizedMap&lt;String,Reference&lt;PrivateKeyEntry&gt;&gt;());
 88     }
 89 
 90     // LinkedHashMap with a max size of 10
 91     // see LinkedHashMap JavaDocs
 92     private static class SizedMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; {
 93         @java.io.Serial
 94         private static final long serialVersionUID = -8211222668790986062L;
 95 
 96         @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
 97             return size() &gt; 10;
 98         }
 99     }
100 
101     //
102     // public methods
103     //
104 
105     @Override
106     public X509Certificate[] getCertificateChain(String alias) {
107         PrivateKeyEntry entry = getEntry(alias);
108         return entry == null ? null :
109                 (X509Certificate[])entry.getCertificateChain();
110     }
111 
112     @Override
113     public PrivateKey getPrivateKey(String alias) {
114         PrivateKeyEntry entry = getEntry(alias);
115         return entry == null ? null : entry.getPrivateKey();
116     }
117 
118     @Override
119     public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
120             Socket socket) {
121         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
122                         getAlgorithmConstraints(socket));
123     }
124 
125     @Override
126     public String chooseEngineClientAlias(String[] keyTypes,
127             Principal[] issuers, SSLEngine engine) {
128         return chooseAlias(getKeyTypes(keyTypes), issuers, CheckType.CLIENT,
129                         getAlgorithmConstraints(engine));
130     }
131 
132     @Override
133     public String chooseServerAlias(String keyType,
134             Principal[] issuers, Socket socket) {
135         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
136             getAlgorithmConstraints(socket),
137             X509TrustManagerImpl.getRequestedServerNames(socket),
138             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
139                          // The certificate selection scheme for SNI HostName
140                          // is similar to HTTPS endpoint identification scheme
141                          // implemented in this provider.
142                          //
143                          // Using HTTPS endpoint identification scheme to guide
144                          // the selection of an appropriate authentication
145                          // certificate according to requested SNI extension.
146                          //
147                          // It is not a really HTTPS endpoint identification.
148     }
149 
150     @Override
151     public String chooseEngineServerAlias(String keyType,
152             Principal[] issuers, SSLEngine engine) {
153         return chooseAlias(getKeyTypes(keyType), issuers, CheckType.SERVER,
154             getAlgorithmConstraints(engine),
155             X509TrustManagerImpl.getRequestedServerNames(engine),
156             &quot;HTTPS&quot;);    // The SNI HostName is a fully qualified domain name.
157                          // The certificate selection scheme for SNI HostName
158                          // is similar to HTTPS endpoint identification scheme
159                          // implemented in this provider.
160                          //
161                          // Using HTTPS endpoint identification scheme to guide
162                          // the selection of an appropriate authentication
163                          // certificate according to requested SNI extension.
164                          //
165                          // It is not a really HTTPS endpoint identification.
166     }
167 
168     @Override
169     public String[] getClientAliases(String keyType, Principal[] issuers) {
170         return getAliases(keyType, issuers, CheckType.CLIENT, null);
171     }
172 
173     @Override
174     public String[] getServerAliases(String keyType, Principal[] issuers) {
175         return getAliases(keyType, issuers, CheckType.SERVER, null);
176     }
177 
178     //
179     // implementation private methods
180     //
181 
182     // Gets algorithm constraints of the socket.
183     private AlgorithmConstraints getAlgorithmConstraints(Socket socket) {
184         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
185                                         socket instanceof SSLSocket) {
186 
187             SSLSocket sslSocket = (SSLSocket)socket;
188             SSLSession session = sslSocket.getHandshakeSession();
189 
190             if (session != null) {
191                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
192                     String[] peerSupportedSignAlgs = null;
193 
194                     if (session instanceof ExtendedSSLSession) {
195                         ExtendedSSLSession extSession =
196                             (ExtendedSSLSession)session;
197                         peerSupportedSignAlgs =
198                             extSession.getPeerSupportedSignatureAlgorithms();
199                     }
200 
201                     return new SSLAlgorithmConstraints(
202                         sslSocket, peerSupportedSignAlgs, true);
203                 }
204             }
205 
206             return new SSLAlgorithmConstraints(sslSocket, true);
207         }
208 
209         return new SSLAlgorithmConstraints((SSLSocket)null, true);
210     }
211 
212     // Gets algorithm constraints of the engine.
213     private AlgorithmConstraints getAlgorithmConstraints(SSLEngine engine) {
214         if (engine != null) {
215             SSLSession session = engine.getHandshakeSession();
216             if (session != null) {
217                 if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
218                     String[] peerSupportedSignAlgs = null;
219 
220                     if (session instanceof ExtendedSSLSession) {
221                         ExtendedSSLSession extSession =
222                             (ExtendedSSLSession)session;
223                         peerSupportedSignAlgs =
224                             extSession.getPeerSupportedSignatureAlgorithms();
225                     }
226 
227                     return new SSLAlgorithmConstraints(
228                         engine, peerSupportedSignAlgs, true);
229                 }
230             }
231         }
232 
233         return new SSLAlgorithmConstraints(engine, true);
234     }
235 
236     // we construct the alias we return to JSSE as seen in the code below
237     // a unique id is included to allow us to reliably cache entries
238     // between the calls to getCertificateChain() and getPrivateKey()
239     // even if tokens are inserted or removed
240     private String makeAlias(EntryStatus entry) {
241         return uidCounter.incrementAndGet() + &quot;.&quot; + entry.builderIndex + &quot;.&quot;
242                 + entry.alias;
243     }
244 
245     private PrivateKeyEntry getEntry(String alias) {
246         // if the alias is null, return immediately
247         if (alias == null) {
248             return null;
249         }
250 
251         // try to get the entry from cache
252         Reference&lt;PrivateKeyEntry&gt; ref = entryCacheMap.get(alias);
253         PrivateKeyEntry entry = (ref != null) ? ref.get() : null;
254         if (entry != null) {
255             return entry;
256         }
257 
258         // parse the alias
259         int firstDot = alias.indexOf(&#39;.&#39;);
260         int secondDot = alias.indexOf(&#39;.&#39;, firstDot + 1);
261         if ((firstDot == -1) || (secondDot == firstDot)) {
262             // invalid alias
263             return null;
264         }
265         try {
266             int builderIndex = Integer.parseInt
267                                 (alias.substring(firstDot + 1, secondDot));
268             String keyStoreAlias = alias.substring(secondDot + 1);
269             Builder builder = builders.get(builderIndex);
270             KeyStore ks = builder.getKeyStore();
271             Entry newEntry = ks.getEntry
272                     (keyStoreAlias, builder.getProtectionParameter(alias));
273             if (newEntry instanceof PrivateKeyEntry == false) {
274                 // unexpected type of entry
275                 return null;
276             }
277             entry = (PrivateKeyEntry)newEntry;
278             entryCacheMap.put(alias, new SoftReference&lt;PrivateKeyEntry&gt;(entry));
279             return entry;
280         } catch (Exception e) {
281             // ignore
282             return null;
283         }
284     }
285 
286     // Class to help verify that the public key algorithm (and optionally
287     // the signature algorithm) of a certificate matches what we need.
288     private static class KeyType {
289 
290         final String keyAlgorithm;
291 
292         // In TLS 1.2, the signature algorithm  has been obsoleted by the
293         // supported_signature_algorithms, and the certificate type no longer
294         // restricts the algorithm used to sign the certificate.
295         //
296         // However, because we don&#39;t support certificate type checking other
297         // than rsa_sign, dss_sign and ecdsa_sign, we don&#39;t have to check the
298         // protocol version here.
299         final String sigKeyAlgorithm;
300 
301         KeyType(String algorithm) {
302             int k = algorithm.indexOf(&#39;_&#39;);
303             if (k == -1) {
304                 keyAlgorithm = algorithm;
305                 sigKeyAlgorithm = null;
306             } else {
307                 keyAlgorithm = algorithm.substring(0, k);
308                 sigKeyAlgorithm = algorithm.substring(k + 1);
309             }
310         }
311 
312         boolean matches(Certificate[] chain) {
313             if (!chain[0].getPublicKey().getAlgorithm().equals(keyAlgorithm)) {
314                 return false;
315             }
316             if (sigKeyAlgorithm == null) {
317                 return true;
318             }
319             if (chain.length &gt; 1) {
320                 // if possible, check the public key in the issuer cert
321                 return sigKeyAlgorithm.equals(
322                         chain[1].getPublicKey().getAlgorithm());
323             } else {
324                 // Check the signature algorithm of the certificate itself.
325                 // Look for the &quot;withRSA&quot; in &quot;SHA1withRSA&quot;, etc.
326                 X509Certificate issuer = (X509Certificate)chain[0];
327                 String sigAlgName =
328                         issuer.getSigAlgName().toUpperCase(Locale.ENGLISH);
329                 String pattern =
330                         &quot;WITH&quot; + sigKeyAlgorithm.toUpperCase(Locale.ENGLISH);
331                 return sigAlgName.contains(pattern);
332             }
333         }
334     }
335 
336     private static List&lt;KeyType&gt; getKeyTypes(String ... keyTypes) {
337         if ((keyTypes == null) ||
338                 (keyTypes.length == 0) || (keyTypes[0] == null)) {
339             return null;
340         }
341         List&lt;KeyType&gt; list = new ArrayList&lt;&gt;(keyTypes.length);
342         for (String keyType : keyTypes) {
343             list.add(new KeyType(keyType));
344         }
345         return list;
346     }
347 
348     /*
349      * Return the best alias that fits the given parameters.
350      * The algorithm we use is:
351      *   . scan through all the aliases in all builders in order
352      *   . as soon as we find a perfect match, return
353      *     (i.e. a match with a cert that has appropriate key usage,
354      *      qualified endpoint identity, and is not expired).
355      *   . if we do not find a perfect match, keep looping and remember
356      *     the imperfect matches
357      *   . at the end, sort the imperfect matches. we prefer expired certs
358      *     with appropriate key usage to certs with the wrong key usage.
359      *     return the first one of them.
360      */
361     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
362             CheckType checkType, AlgorithmConstraints constraints) {
363 
364         return chooseAlias(keyTypeList, issuers,
365                                     checkType, constraints, null, null);
366     }
367 
368     private String chooseAlias(List&lt;KeyType&gt; keyTypeList, Principal[] issuers,
369             CheckType checkType, AlgorithmConstraints constraints,
370             List&lt;SNIServerName&gt; requestedServerNames, String idAlgorithm) {
371 
372         if (keyTypeList == null || keyTypeList.isEmpty()) {
373             return null;
374         }
375 
376         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
377         List&lt;EntryStatus&gt; allResults = null;
378         for (int i = 0, n = builders.size(); i &lt; n; i++) {
379             try {
380                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
381                             issuerSet, false, checkType, constraints,
382                             requestedServerNames, idAlgorithm);
383                 if (results != null) {
384                     // the results will either be a single perfect match
385                     // or 1 or more imperfect matches
386                     // if it&#39;s a perfect match, return immediately
387                     EntryStatus status = results.get(0);
388                     if (status.checkResult == CheckResult.OK) {
389                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
390                             SSLLogger.fine(&quot;KeyMgr: choosing key: &quot; + status);
391                         }
392                         return makeAlias(status);
393                     }
394                     if (allResults == null) {
395                         allResults = new ArrayList&lt;EntryStatus&gt;();
396                     }
397                     allResults.addAll(results);
398                 }
399             } catch (Exception e) {
400                 // ignore
401             }
402         }
403         if (allResults == null) {
404             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
405                 SSLLogger.fine(&quot;KeyMgr: no matching key found&quot;);
406             }
407             return null;
408         }
409         Collections.sort(allResults);
410         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
411             SSLLogger.fine(
412                     &quot;KeyMgr: no good matching key found, &quot;
413                     + &quot;returning best match out of&quot;, allResults);
414         }
415         return makeAlias(allResults.get(0));
416     }
417 
418     /*
419      * Return all aliases that (approximately) fit the parameters.
420      * These are perfect matches plus imperfect matches (expired certificates
421      * and certificates with the wrong extensions).
422      * The perfect matches will be first in the array.
423      */
424     public String[] getAliases(String keyType, Principal[] issuers,
425             CheckType checkType, AlgorithmConstraints constraints) {
426         if (keyType == null) {
427             return null;
428         }
429 
430         Set&lt;Principal&gt; issuerSet = getIssuerSet(issuers);
431         List&lt;KeyType&gt; keyTypeList = getKeyTypes(keyType);
432         List&lt;EntryStatus&gt; allResults = null;
433         for (int i = 0, n = builders.size(); i &lt; n; i++) {
434             try {
435                 List&lt;EntryStatus&gt; results = getAliases(i, keyTypeList,
436                                     issuerSet, true, checkType, constraints,
437                                     null, null);
438                 if (results != null) {
439                     if (allResults == null) {
440                         allResults = new ArrayList&lt;&gt;();
441                     }
442                     allResults.addAll(results);
443                 }
444             } catch (Exception e) {
445                 // ignore
446             }
447         }
448         if (allResults == null || allResults.isEmpty()) {
449             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
450                 SSLLogger.fine(&quot;KeyMgr: no matching alias found&quot;);
451             }
452             return null;
453         }
454         Collections.sort(allResults);
455         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
456             SSLLogger.fine(&quot;KeyMgr: getting aliases&quot;, allResults);
457         }
458         return toAliases(allResults);
459     }
460 
461     // turn candidate entries into unique aliases we can return to JSSE
462     private String[] toAliases(List&lt;EntryStatus&gt; results) {
463         String[] s = new String[results.size()];
464         int i = 0;
465         for (EntryStatus result : results) {
466             s[i++] = makeAlias(result);
467         }
468         return s;
469     }
470 
471     // make a Set out of the array
472     private Set&lt;Principal&gt; getIssuerSet(Principal[] issuers) {
473         if ((issuers != null) &amp;&amp; (issuers.length != 0)) {
474             return new HashSet&lt;&gt;(Arrays.asList(issuers));
475         } else {
476             return null;
477         }
478     }
479 
480     // a candidate match
481     // identifies the entry by builder and alias
482     // and includes the result of the certificate check
483     private static class EntryStatus implements Comparable&lt;EntryStatus&gt; {
484 
485         final int builderIndex;
486         final int keyIndex;
487         final String alias;
488         final CheckResult checkResult;
489 
490         EntryStatus(int builderIndex, int keyIndex, String alias,
491                 Certificate[] chain, CheckResult checkResult) {
492             this.builderIndex = builderIndex;
493             this.keyIndex = keyIndex;
494             this.alias = alias;
495             this.checkResult = checkResult;
496         }
497 
498         @Override
499         public int compareTo(EntryStatus other) {
500             int result = this.checkResult.compareTo(other.checkResult);
501             return (result == 0) ? (this.keyIndex - other.keyIndex) : result;
502         }
503 
504         @Override
505         public String toString() {
506             String s = alias + &quot; (verified: &quot; + checkResult + &quot;)&quot;;
507             if (builderIndex == 0) {
508                 return s;
509             } else {
510                 return &quot;Builder #&quot; + builderIndex + &quot;, alias: &quot; + s;
511             }
512         }
513     }
514 
515     // enum for the type of certificate check we want to perform
516     // (client or server)
517     // also includes the check code itself
518     private static enum CheckType {
519 
520         // enum constant for &quot;no check&quot; (currently not used)
521         NONE(Collections.&lt;String&gt;emptySet()),
522 
523         // enum constant for &quot;tls client&quot; check
524         // valid EKU for TLS client: any, tls_client
525         CLIENT(new HashSet&lt;String&gt;(Arrays.asList(new String[] {
526             &quot;2.5.29.37.0&quot;, &quot;1.3.6.1.5.5.7.3.2&quot; }))),
527 
528         // enum constant for &quot;tls server&quot; check
529         // valid EKU for TLS server: any, tls_server, ns_sgc, ms_sgc
530         SERVER(new HashSet&lt;String&gt;(Arrays.asList(new String[] {
531             &quot;2.5.29.37.0&quot;, &quot;1.3.6.1.5.5.7.3.1&quot;, &quot;2.16.840.1.113730.4.1&quot;,
532             &quot;1.3.6.1.4.1.311.10.3.3&quot; })));
533 
534         // set of valid EKU values for this type
535         final Set&lt;String&gt; validEku;
536 
537         CheckType(Set&lt;String&gt; validEku) {
538             this.validEku = validEku;
539         }
540 
541         private static boolean getBit(boolean[] keyUsage, int bit) {
542             return (bit &lt; keyUsage.length) &amp;&amp; keyUsage[bit];
543         }
544 
545         // Check if this certificate is appropriate for this type of use
546         // first check extensions, if they match, check expiration.
547         //
548         // Note: we may want to move this code into the sun.security.validator
549         // package
550         CheckResult check(X509Certificate cert, Date date,
551                 List&lt;SNIServerName&gt; serverNames, String idAlgorithm) {
552 
553             if (this == NONE) {
554                 return CheckResult.OK;
555             }
556 
557             // check extensions
558             try {
559                 // check extended key usage
560                 List&lt;String&gt; certEku = cert.getExtendedKeyUsage();
561                 if ((certEku != null) &amp;&amp;
562                         Collections.disjoint(validEku, certEku)) {
563                     // if extension present and it does not contain any of
564                     // the valid EKU OIDs, return extension_mismatch
565                     return CheckResult.EXTENSION_MISMATCH;
566                 }
567 
568                 // check key usage
569                 boolean[] ku = cert.getKeyUsage();
570                 if (ku != null) {
571                     String algorithm = cert.getPublicKey().getAlgorithm();
572                     boolean supportsDigitalSignature = getBit(ku, 0);
573                     switch (algorithm) {
574                         case &quot;RSA&quot;:
575                             // require either signature bit
576                             // or if server also allow key encipherment bit
577                             if (!supportsDigitalSignature) {
578                                 if (this == CLIENT || getBit(ku, 2) == false) {
579                                     return CheckResult.EXTENSION_MISMATCH;
580                                 }
581                             }
582                             break;
583                         case &quot;RSASSA-PSS&quot;:
584                             if (!supportsDigitalSignature &amp;&amp; (this == SERVER)) {
585                                 return CheckResult.EXTENSION_MISMATCH;
586                             }
587                             break;
588                         case &quot;DSA&quot;:
589                             // require signature bit
590                             if (!supportsDigitalSignature) {
591                                 return CheckResult.EXTENSION_MISMATCH;
592                             }
593                             break;
594                         case &quot;DH&quot;:
595                             // require keyagreement bit
596                             if (getBit(ku, 4) == false) {
597                                 return CheckResult.EXTENSION_MISMATCH;
598                             }
599                             break;
600                         case &quot;EC&quot;:
601                             // require signature bit
602                             if (!supportsDigitalSignature) {
603                                 return CheckResult.EXTENSION_MISMATCH;
604                             }
605                             // For servers, also require key agreement.
606                             // This is not totally accurate as the keyAgreement
607                             // bit is only necessary for static ECDH key
608                             // exchange and not ephemeral ECDH. We leave it in
609                             // for now until there are signs that this check
610                             // causes problems for real world EC certificates.
611                             if ((this == SERVER) &amp;&amp; (getBit(ku, 4) == false)) {
612                                 return CheckResult.EXTENSION_MISMATCH;
613                             }
614                             break;
615                     }
616                 }
617             } catch (CertificateException e) {
618                 // extensions unparseable, return failure
619                 return CheckResult.EXTENSION_MISMATCH;
620             }
621 
622             try {
623                 cert.checkValidity(date);
624             } catch (CertificateException e) {
625                 return CheckResult.EXPIRED;
626             }
627 
628             if (serverNames != null &amp;&amp; !serverNames.isEmpty()) {
629                 for (SNIServerName serverName : serverNames) {
630                     if (serverName.getType() ==
631                                 StandardConstants.SNI_HOST_NAME) {
632                         if (!(serverName instanceof SNIHostName)) {
633                             try {
634                                 serverName =
635                                     new SNIHostName(serverName.getEncoded());
636                             } catch (IllegalArgumentException iae) {
637                                 // unlikely to happen, just in case ...
638                                 if (SSLLogger.isOn &amp;&amp;
639                                         SSLLogger.isOn(&quot;keymanager&quot;)) {
640                                     SSLLogger.fine(
641                                        &quot;Illegal server name: &quot; + serverName);
642                                 }
643 
644                                 return CheckResult.INSENSITIVE;
645                             }
646                         }
647                         String hostname =
648                                 ((SNIHostName)serverName).getAsciiName();
649 
650                         try {
651                             X509TrustManagerImpl.checkIdentity(hostname,
652                                                         cert, idAlgorithm);
653                         } catch (CertificateException e) {
654                             if (SSLLogger.isOn &amp;&amp;
655                                     SSLLogger.isOn(&quot;keymanager&quot;)) {
656                                 SSLLogger.fine(
657                                     &quot;Certificate identity does not match &quot; +
658                                     &quot;Server Name Inidication (SNI): &quot; +
659                                     hostname);
660                             }
661                             return CheckResult.INSENSITIVE;
662                         }
663 
664                         break;
665                     }
666                 }
667             }
668 
669             return CheckResult.OK;
670         }
671 
672         public String getValidator() {
673             if (this == CLIENT) {
674                 return Validator.VAR_TLS_CLIENT;
675             } else if (this == SERVER) {
676                 return Validator.VAR_TLS_SERVER;
677             }
678             return Validator.VAR_GENERIC;
679         }
680     }
681 
682     // enum for the result of the extension check
683     // NOTE: the order of the constants is important as they are used
684     // for sorting, i.e. OK is best, followed by EXPIRED and EXTENSION_MISMATCH
685     private static enum CheckResult {
686         OK,                     // ok or not checked
687         INSENSITIVE,            // server name indication insensitive
688         EXPIRED,                // extensions valid but cert expired
689         EXTENSION_MISMATCH,     // extensions invalid (expiration not checked)
690     }
691 
692     /*
693      * Return a List of all candidate matches in the specified builder
694      * that fit the parameters.
695      * We exclude entries in the KeyStore if they are not:
696      *  . private key entries
697      *  . the certificates are not X509 certificates
698      *  . the algorithm of the key in the EE cert doesn&#39;t match one of keyTypes
699      *  . none of the certs is issued by a Principal in issuerSet
700      * Using those entries would not be possible or they would almost
701      * certainly be rejected by the peer.
702      *
703      * In addition to those checks, we also check the extensions in the EE
704      * cert and its expiration. Even if there is a mismatch, we include
705      * such certificates because they technically work and might be accepted
706      * by the peer. This leads to more graceful failure and better error
707      * messages if the cert expires from one day to the next.
708      *
709      * The return values are:
710      *   . null, if there are no matching entries at all
711      *   . if &#39;findAll&#39; is &#39;false&#39; and there is a perfect match, a List
712      *     with a single element (early return)
713      *   . if &#39;findAll&#39; is &#39;false&#39; and there is NO perfect match, a List
714      *     with all the imperfect matches (expired, wrong extensions)
715      *   . if &#39;findAll&#39; is &#39;true&#39;, a List with all perfect and imperfect
716      *     matches
717      */
718     private List&lt;EntryStatus&gt; getAliases(int builderIndex,
719             List&lt;KeyType&gt; keyTypes, Set&lt;Principal&gt; issuerSet,
720             boolean findAll, CheckType checkType,
721             AlgorithmConstraints constraints,
722             List&lt;SNIServerName&gt; requestedServerNames,
723             String idAlgorithm) throws Exception {
724 
725         Builder builder = builders.get(builderIndex);
726         KeyStore ks = builder.getKeyStore();
727         List&lt;EntryStatus&gt; results = null;
728         Date date = verificationDate;
729         boolean preferred = false;
730         for (Enumeration&lt;String&gt; e = ks.aliases(); e.hasMoreElements(); ) {
731             String alias = e.nextElement();
732             // check if it is a key entry (private key or secret key)
733             if (!ks.isKeyEntry(alias)) {
734                 continue;
735             }
736 
737             Certificate[] chain = ks.getCertificateChain(alias);
738             if ((chain == null) || (chain.length == 0)) {
739                 // must be secret key entry, ignore
740                 continue;
741             }
742 
743             boolean incompatible = false;
744             for (Certificate cert : chain) {
745                 if (cert instanceof X509Certificate == false) {
746                     // not an X509Certificate, ignore this alias
747                     incompatible = true;
748                     break;
749                 }
750             }
751             if (incompatible) {
752                 continue;
753             }
754 
755             // check keytype
756             int keyIndex = -1;
757             int j = 0;
758             for (KeyType keyType : keyTypes) {
759                 if (keyType.matches(chain)) {
760                     keyIndex = j;
761                     break;
762                 }
763                 j++;
764             }
765             if (keyIndex == -1) {
766                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
767                     SSLLogger.fine(&quot;Ignore alias &quot; + alias
768                                 + &quot;: key algorithm does not match&quot;);
769                 }
770                 continue;
771             }
772             // check issuers
773             if (issuerSet != null) {
774                 boolean found = false;
775                 for (Certificate cert : chain) {
776                     X509Certificate xcert = (X509Certificate)cert;
777                     if (issuerSet.contains(xcert.getIssuerX500Principal())) {
778                         found = true;
779                         break;
780                     }
781                 }
782                 if (found == false) {
783                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
784                         SSLLogger.fine(
785                                 &quot;Ignore alias &quot; + alias
786                                 + &quot;: issuers do not match&quot;);
787                     }
788                     continue;
789                 }
790             }
791 
792             // check the algorithm constraints
793             if (constraints != null &amp;&amp;
794                     !conformsToAlgorithmConstraints(constraints, chain,
795                             checkType.getValidator())) {
796 
797                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
798                     SSLLogger.fine(&quot;Ignore alias &quot; + alias +
799                             &quot;: certificate list does not conform to &quot; +
800                             &quot;algorithm constraints&quot;);
801                 }
802                 continue;
803             }
804 
805             if (date == null) {
806                 date = new Date();
807             }
808             CheckResult checkResult =
809                     checkType.check((X509Certificate)chain[0], date,
810                                     requestedServerNames, idAlgorithm);
811             EntryStatus status =
812                     new EntryStatus(builderIndex, keyIndex,
813                                         alias, chain, checkResult);
814             if (!preferred &amp;&amp; checkResult == CheckResult.OK &amp;&amp; keyIndex == 0) {
815                 preferred = true;
816             }
817             if (preferred &amp;&amp; (findAll == false)) {
818                 // if we have a good match and do not need all matches,
819                 // return immediately
820                 return Collections.singletonList(status);
821             } else {
822                 if (results == null) {
823                     results = new ArrayList&lt;&gt;();
824                 }
825                 results.add(status);
826             }
827         }
828         return results;
829     }
830 
831     private static boolean conformsToAlgorithmConstraints(
832             AlgorithmConstraints constraints, Certificate[] chain,
833             String variant) {
834 
835         AlgorithmChecker checker =
836                 new AlgorithmChecker(constraints, null, variant);
837         try {
838             checker.init(false);
839         } catch (CertPathValidatorException cpve) {
840             // unlikely to happen
841             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
842                 SSLLogger.fine(
843                     &quot;Cannot initialize algorithm constraints checker&quot;, cpve);
844             }
845 
846             return false;
847         }
848 
849         // It is a forward checker, so we need to check from trust to target.
850         for (int i = chain.length - 1; i &gt;= 0; i--) {
851             Certificate cert = chain[i];
852             try {
853                 // We don&#39;t care about the unresolved critical extensions.
854                 checker.check(cert, Collections.&lt;String&gt;emptySet());
855             } catch (CertPathValidatorException cpve) {
856                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;keymanager&quot;)) {
857                     SSLLogger.fine(&quot;Certificate does not conform to &quot; +
858                             &quot;algorithm constraints&quot;, cert, cpve);
859                 }
860 
861                 return false;
862             }
863         }
864 
865         return true;
866     }
867 }
    </pre>
  </body>
</html>
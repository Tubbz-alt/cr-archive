<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLHandshake.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.util.AbstractMap.SimpleImmutableEntry;
 31 import java.util.Map;
 32 import javax.net.ssl.SSLException;
 33 
 34 enum SSLHandshake implements SSLConsumer, HandshakeProducer {
 35     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 36     HELLO_REQUEST ((byte)0x00, &quot;hello_request&quot;,
 37         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 38             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 39                 HelloRequest.handshakeConsumer,
 40                 ProtocolVersion.PROTOCOLS_TO_12
 41             )
 42         }),
 43         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 44             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 45                 HelloRequest.handshakeProducer,
 46                 ProtocolVersion.PROTOCOLS_TO_12
 47             )
 48         })),
 49 
 50     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 51     CLIENT_HELLO ((byte)0x01, &quot;client_hello&quot;,
 52         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 53             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 54                 ClientHello.handshakeConsumer,
 55                 ProtocolVersion.PROTOCOLS_TO_13
 56             )
 57         }),
 58         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 59             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 60                 ClientHello.handshakeProducer,
 61                 ProtocolVersion.PROTOCOLS_TO_13
 62             )
 63         })),
 64 
 65     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 66     SERVER_HELLO ((byte)0x02, &quot;server_hello&quot;,
 67         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 68             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 69                 ServerHello.handshakeConsumer,
 70                 ProtocolVersion.PROTOCOLS_TO_13
 71             )
 72         }),
 73         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 74             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 75                 ServerHello.t12HandshakeProducer,
 76                 ProtocolVersion.PROTOCOLS_TO_12
 77             ),
 78             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 79                 ServerHello.t13HandshakeProducer,
 80                 ProtocolVersion.PROTOCOLS_OF_13
 81             )
 82         })),
 83 
 84     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 85     HELLO_RETRY_REQUEST ((byte)0x02, &quot;hello_retry_request&quot;,
 86         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 87             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
 88                 ServerHello.handshakeConsumer,      // Use ServerHello consumer
 89                 ProtocolVersion.PROTOCOLS_TO_13
 90             )
 91         }),
 92         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
 93             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
 94                 ServerHello.hrrHandshakeProducer,
 95                 ProtocolVersion.PROTOCOLS_OF_13
 96             )
 97         })),
 98 
 99     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
100     HELLO_VERIFY_REQUEST        ((byte)0x03, &quot;hello_verify_request&quot;,
101         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
102             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
103                 HelloVerifyRequest.handshakeConsumer,
104                 ProtocolVersion.PROTOCOLS_TO_12
105             )
106         }),
107         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
108             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
109                 HelloVerifyRequest.handshakeProducer,
110                 ProtocolVersion.PROTOCOLS_TO_12
111             )
112         })),
113 
114     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
115     NEW_SESSION_TICKET          ((byte)0x04, &quot;new_session_ticket&quot;,
116         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
117             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
118                  NewSessionTicket.handshake12Consumer,
119                  ProtocolVersion.PROTOCOLS_TO_12
120             ),
121             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
122                  NewSessionTicket.handshakeConsumer,
123                  ProtocolVersion.PROTOCOLS_OF_13
124             )
125         }),
126         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
127             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
128                  NewSessionTicket.handshake12Producer,
129                  ProtocolVersion.PROTOCOLS_TO_12
130             )
131         })),
132     END_OF_EARLY_DATA           ((byte)0x05, &quot;end_of_early_data&quot;),
133 
134     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
135     ENCRYPTED_EXTENSIONS        ((byte)0x08, &quot;encrypted_extensions&quot;,
136         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
137             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
138                 EncryptedExtensions.handshakeConsumer,
139                 ProtocolVersion.PROTOCOLS_OF_13
140             )
141         }),
142         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
143             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
144                 EncryptedExtensions.handshakeProducer,
145                 ProtocolVersion.PROTOCOLS_OF_13
146             )
147         })),
148 
149     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
150     CERTIFICATE                 ((byte)0x0B, &quot;certificate&quot;,
151         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
152             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
153                 CertificateMessage.t12HandshakeConsumer,
154                 ProtocolVersion.PROTOCOLS_TO_12
155             ),
156             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
157                 CertificateMessage.t13HandshakeConsumer,
158                 ProtocolVersion.PROTOCOLS_OF_13
159             )
160         }),
161         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
162             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
163                 CertificateMessage.t12HandshakeProducer,
164                 ProtocolVersion.PROTOCOLS_TO_12
165             ),
166             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
167                 CertificateMessage.t13HandshakeProducer,
168                 ProtocolVersion.PROTOCOLS_OF_13
169             )
170         })),
171 
172     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
173     SERVER_KEY_EXCHANGE         ((byte)0x0C, &quot;server_key_exchange&quot;,
174         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
175             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
176                 ServerKeyExchange.handshakeConsumer,
177                 ProtocolVersion.PROTOCOLS_TO_12
178             )
179         }),
180         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
181             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
182                 ServerKeyExchange.handshakeProducer,
183                 ProtocolVersion.PROTOCOLS_TO_12
184             )
185         })),
186 
187     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
188     CERTIFICATE_REQUEST         ((byte)0x0D, &quot;certificate_request&quot;,
189         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
190             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
191                 CertificateRequest.t10HandshakeConsumer,
192                 ProtocolVersion.PROTOCOLS_TO_11
193             ),
194             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
195                 CertificateRequest.t12HandshakeConsumer,
196                 ProtocolVersion.PROTOCOLS_OF_12
197             ),
198             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
199                 CertificateRequest.t13HandshakeConsumer,
200                 ProtocolVersion.PROTOCOLS_OF_13
201             )
202         }),
203         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
204             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
205                 CertificateRequest.t10HandshakeProducer,
206                 ProtocolVersion.PROTOCOLS_TO_11
207             ),
208             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
209                 CertificateRequest.t12HandshakeProducer,
210                 ProtocolVersion.PROTOCOLS_OF_12
211             ),
212             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
213                 CertificateRequest.t13HandshakeProducer,
214                 ProtocolVersion.PROTOCOLS_OF_13
215             )
216         })),
217 
218     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
219     SERVER_HELLO_DONE           ((byte)0x0E, &quot;server_hello_done&quot;,
220         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
221             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
222                 ServerHelloDone.handshakeConsumer,
223                 ProtocolVersion.PROTOCOLS_TO_12
224             )
225         }),
226         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
227             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
228                 ServerHelloDone.handshakeProducer,
229                 ProtocolVersion.PROTOCOLS_TO_12
230             )
231         })),
232 
233     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
234     CERTIFICATE_VERIFY          ((byte)0x0F, &quot;certificate_verify&quot;,
235         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
236             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
237                 CertificateVerify.s30HandshakeConsumer,
238                 ProtocolVersion.PROTOCOLS_OF_30
239             ),
240             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
241                 CertificateVerify.t10HandshakeConsumer,
242                 ProtocolVersion.PROTOCOLS_10_11
243             ),
244             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
245                 CertificateVerify.t12HandshakeConsumer,
246                 ProtocolVersion.PROTOCOLS_OF_12
247             ),
248             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
249                 CertificateVerify.t13HandshakeConsumer,
250                 ProtocolVersion.PROTOCOLS_OF_13
251             )
252         }),
253         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
254             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
255                 CertificateVerify.s30HandshakeProducer,
256                 ProtocolVersion.PROTOCOLS_OF_30
257             ),
258             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
259                 CertificateVerify.t10HandshakeProducer,
260                 ProtocolVersion.PROTOCOLS_10_11
261             ),
262             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
263                 CertificateVerify.t12HandshakeProducer,
264                 ProtocolVersion.PROTOCOLS_OF_12
265             ),
266             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
267                 CertificateVerify.t13HandshakeProducer,
268                 ProtocolVersion.PROTOCOLS_OF_13
269             )
270         })),
271 
272     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
273     CLIENT_KEY_EXCHANGE         ((byte)0x10, &quot;client_key_exchange&quot;,
274         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
275             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
276                 ClientKeyExchange.handshakeConsumer,
277                 ProtocolVersion.PROTOCOLS_TO_12
278             )
279         }),
280         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
281             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
282                 ClientKeyExchange.handshakeProducer,
283                 ProtocolVersion.PROTOCOLS_TO_12
284             )
285         })),
286 
287     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
288     FINISHED                    ((byte)0x14, &quot;finished&quot;,
289         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
290             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
291                 Finished.t12HandshakeConsumer,
292                 ProtocolVersion.PROTOCOLS_TO_12
293             ),
294             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
295                 Finished.t13HandshakeConsumer,
296                 ProtocolVersion.PROTOCOLS_OF_13
297             )
298         }),
299         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
300             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
301                 Finished.t12HandshakeProducer,
302                 ProtocolVersion.PROTOCOLS_TO_12
303             ),
304             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
305                 Finished.t13HandshakeProducer,
306                 ProtocolVersion.PROTOCOLS_OF_13
307             )
308         })),
309 
310     CERTIFICATE_URL             ((byte)0x15, &quot;certificate_url&quot;),
311 
312     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
313     CERTIFICATE_STATUS          ((byte)0x16, &quot;certificate_status&quot;,
314         (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
315             new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
316                 CertificateStatus.handshakeConsumer,
317                 ProtocolVersion.PROTOCOLS_TO_12
318             )
319         }),
320         (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
321             new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
322                 CertificateStatus.handshakeProducer,
323                 ProtocolVersion.PROTOCOLS_TO_12
324             )
325         }),
326         (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(new Map.Entry[] {
327             new SimpleImmutableEntry&lt;HandshakeAbsence, ProtocolVersion[]&gt;(
328                 CertificateStatus.handshakeAbsence,
329                 ProtocolVersion.PROTOCOLS_TO_12
330             )
331         })),
332 
333     SUPPLEMENTAL_DATA           ((byte)0x17, &quot;supplemental_data&quot;),
334 
335     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
336     KEY_UPDATE                  ((byte)0x18, &quot;key_update&quot;,
337             (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
338                     new SimpleImmutableEntry&lt;SSLConsumer, ProtocolVersion[]&gt;(
339                             KeyUpdate.handshakeConsumer,
340                             ProtocolVersion.PROTOCOLS_OF_13
341                     )
342             }),
343             (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(new Map.Entry[] {
344                     new SimpleImmutableEntry&lt;HandshakeProducer, ProtocolVersion[]&gt;(
345                             KeyUpdate.handshakeProducer,
346                             ProtocolVersion.PROTOCOLS_OF_13
347                     )
348             })),
349     MESSAGE_HASH                ((byte)0xFE, &quot;message_hash&quot;),
350     NOT_APPLICABLE              ((byte)0xFF, &quot;not_applicable&quot;);
351 
352     final byte id;
353     final String name;
354     final Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers;
355     final Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers;
356     final Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[] handshakeAbsences;
357 
358     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
359     SSLHandshake(byte id, String name) {
360         this(id, name,
361                 (Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[])(
362                         new Map.Entry[0]),
363                 (Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[])(
364                         new Map.Entry[0]),
365                 (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(
366                         new Map.Entry[0]));
367     }
368 
369     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
370     SSLHandshake(byte id, String name,
371         Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers,
372         Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers) {
373 
374         this(id, name, handshakeConsumers, handshakeProducers,
375                 (Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[])(
376                         new Map.Entry[0]));
377     }
378 
379     SSLHandshake(byte id, String name,
380         Map.Entry&lt;SSLConsumer, ProtocolVersion[]&gt;[] handshakeConsumers,
381         Map.Entry&lt;HandshakeProducer, ProtocolVersion[]&gt;[] handshakeProducers,
382         Map.Entry&lt;HandshakeAbsence, ProtocolVersion[]&gt;[] handshakeAbsence) {
383 
384         this.id = id;
385         this.name = name;
386         this.handshakeConsumers = handshakeConsumers;
387         this.handshakeProducers = handshakeProducers;
388         this.handshakeAbsences = handshakeAbsence;
389     }
390 
391     @Override
392     public void consume(ConnectionContext context,
393             ByteBuffer message) throws IOException {
394         SSLConsumer hc = getHandshakeConsumer(context);
395         if (hc != null) {
396             hc.consume(context, message);
397         } else {
398             throw new UnsupportedOperationException(
399                     &quot;Unsupported handshake consumer: &quot; + this.name);
400         }
401     }
402 
403     private SSLConsumer getHandshakeConsumer(ConnectionContext context) {
404         if (handshakeConsumers.length == 0) {
405             return null;
406         }
407 
408         // The consuming happens in handshake context only.
409         HandshakeContext hc = (HandshakeContext)context;
410         ProtocolVersion protocolVersion;
411         if ((hc.negotiatedProtocol == null) ||
412                 (hc.negotiatedProtocol == ProtocolVersion.NONE)) {
413             if (hc.conContext.isNegotiated &amp;&amp;
414                     hc.conContext.protocolVersion != ProtocolVersion.NONE) {
415                 protocolVersion = hc.conContext.protocolVersion;
416             } else {
417                 protocolVersion = hc.maximumActiveProtocol;
418             }
419         } else {
420             protocolVersion = hc.negotiatedProtocol;
421         }
422 
423         for (Map.Entry&lt;SSLConsumer,
424                 ProtocolVersion[]&gt; phe : handshakeConsumers) {
425             for (ProtocolVersion pv : phe.getValue()) {
426                 if (protocolVersion == pv) {
427                     return phe.getKey();
428                 }
429             }
430         }
431 
432         return null;
433     }
434 
435     @Override
436     public byte[] produce(ConnectionContext context,
437             HandshakeMessage message) throws IOException {
438         HandshakeProducer hp = getHandshakeProducer(context);
439         if (hp != null) {
440             return hp.produce(context, message);
441         } else {
442             throw new UnsupportedOperationException(
443                     &quot;Unsupported handshake producer: &quot; + this.name);
444         }
445     }
446 
447     private HandshakeProducer getHandshakeProducer(
448             ConnectionContext context) {
449         if (handshakeConsumers.length == 0) {
450             return null;
451         }
452 
453         // The consuming happens in handshake context only.
454         HandshakeContext hc = (HandshakeContext)context;
455         ProtocolVersion protocolVersion;
456         if ((hc.negotiatedProtocol == null) ||
457                 (hc.negotiatedProtocol == ProtocolVersion.NONE)) {
458             if (hc.conContext.isNegotiated &amp;&amp;
459                     hc.conContext.protocolVersion != ProtocolVersion.NONE) {
460                 protocolVersion = hc.conContext.protocolVersion;
461             } else {
462                 protocolVersion = hc.maximumActiveProtocol;
463             }
464         } else {
465             protocolVersion = hc.negotiatedProtocol;
466         }
467 
468         for (Map.Entry&lt;HandshakeProducer,
469                 ProtocolVersion[]&gt; phe : handshakeProducers) {
470             for (ProtocolVersion pv : phe.getValue()) {
471                 if (protocolVersion == pv) {
472                     return phe.getKey();
473                 }
474             }
475         }
476 
477         return null;
478     }
479 
480     @Override
481     public String toString() {
482         return name;
483     }
484 
485     static String nameOf(byte id) {
486         // If two handshake message share the same handshake type, returns
487         // the first handshake message name.
488         //
489         // It is not a big issue at present as only ServerHello and
490         // HellRetryRequest share a handshake type.
491         for (SSLHandshake hs : SSLHandshake.values()) {
492             if (hs.id == id) {
493                 return hs.name;
494             }
495         }
496 
497         return &quot;UNKNOWN-HANDSHAKE-MESSAGE(&quot; + id + &quot;)&quot;;
498     }
499 
500     static boolean isKnown(byte id) {
501         for (SSLHandshake hs : SSLHandshake.values()) {
502             if (hs.id == id &amp;&amp; id != NOT_APPLICABLE.id) {
503                 return true;
504             }
505         }
506 
507         return false;
508     }
509 
510     static final void kickstart(HandshakeContext context) throws IOException {
511         if (context instanceof ClientHandshakeContext) {
512             // For initial handshaking, including session resumption,
513             // ClientHello message is used as the kickstart message.
514             //
515             // (D)TLS 1.2 and older protocols support renegotiation on existing
516             // connections.  A ClientHello messages is used to kickstart the
517             // renegotiation.
518             //
519             // (D)TLS 1.3 forbids renegotiation.  The post-handshake KeyUpdate
520             // message is used to update the sending cryptographic keys.
521             if (context.conContext.isNegotiated &amp;&amp;
522                     context.conContext.protocolVersion.useTLS13PlusSpec()) {
523                 // Use KeyUpdate message for renegotiation.
524                 KeyUpdate.kickstartProducer.produce(context);
525             } else {
526                 // Using ClientHello message for the initial handshaking
527                 // (including session resumption) or renegotiation.
528                 // SSLHandshake.CLIENT_HELLO.produce(context);
529                 ClientHello.kickstartProducer.produce(context);
530             }
531         } else {
532             // The server side can delivering kickstart message after the
533             // connection has established.
534             //
535             // (D)TLS 1.2 and older protocols use HelloRequest to begin a
536             // negotiation process anew.
537             //
538             // While (D)TLS 1.3 uses the post-handshake KeyUpdate message
539             // to update the sending cryptographic keys.
540             if (context.conContext.protocolVersion.useTLS13PlusSpec()) {
541                 // Use KeyUpdate message for renegotiation.
542                 KeyUpdate.kickstartProducer.produce(context);
543             } else {
544                 // SSLHandshake.HELLO_REQUEST.produce(context);
545                 HelloRequest.kickstartProducer.produce(context);
546             }
547         }
548     }
549 
550     /**
551      * A (transparent) specification of handshake message.
552      */
553     static abstract class HandshakeMessage {
554         final HandshakeContext      handshakeContext;
555 
556         HandshakeMessage(HandshakeContext handshakeContext) {
557             this.handshakeContext = handshakeContext;
558         }
559 
560         abstract SSLHandshake handshakeType();
561         abstract int messageLength();
562         abstract void send(HandshakeOutStream hos) throws IOException;
563 
564         void write(HandshakeOutStream hos) throws IOException {
565             int len = messageLength();
566             if (len &gt;= Record.OVERFLOW_OF_INT24) {
567                 throw new SSLException(&quot;Handshake message is overflow&quot;
568                         + &quot;, type = &quot; + handshakeType() + &quot;, len = &quot; + len);
569             }
570             hos.write(handshakeType().id);
571             hos.putInt24(len);
572             send(hos);
573             hos.complete();
574         }
575     }
576 }
    </pre>
  </body>
</html>
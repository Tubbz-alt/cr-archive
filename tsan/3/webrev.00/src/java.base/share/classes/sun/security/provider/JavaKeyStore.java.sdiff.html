<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/provider/JavaKeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DomainKeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/provider/JavaKeyStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.*;
 29 import java.security.*;
 30 import java.security.cert.Certificate;
 31 import java.security.cert.CertificateFactory;
 32 import java.security.cert.CertificateException;
 33 import java.util.*;
 34 


 35 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 36 import sun.security.pkcs12.PKCS12KeyStore;
 37 import sun.security.util.Debug;
 38 import sun.security.util.IOUtils;
 39 import sun.security.util.KeyStoreDelegator;
 40 
 41 /**
 42  * This class provides the keystore implementation referred to as &quot;JKS&quot;.
 43  *
 44  * @author Jan Luehe
 45  * @author David Brownell
 46  *
 47  *
 48  * @see KeyProtector
 49  * @see java.security.KeyStoreSpi
 50  * @see KeyTool
 51  *
 52  * @since 1.2
 53  */
 54 
</pre>
<hr />
<pre>
678             int count = dis.readInt();
679 
680             for (int i = 0; i &lt; count; i++) {
681                 int tag;
682                 String alias;
683 
684                 tag = dis.readInt();
685 
686                 if (tag == 1) { // private key entry
687                     privateKeyCount++;
688                     KeyEntry entry = new KeyEntry();
689 
690                     // Read the alias
691                     alias = dis.readUTF();
692 
693                     // Read the (entry creation) date
694                     entry.date = new Date(dis.readLong());
695 
696                     // Read the private key
697                     entry.protectedPrivKey =
<span class="line-modified">698                             IOUtils.readFully(dis, dis.readInt(), true);</span>
699 
700                     // Read the certificate chain
701                     int numOfCerts = dis.readInt();
702                     if (numOfCerts &gt; 0) {
703                         List&lt;Certificate&gt; certs = new ArrayList&lt;&gt;(
704                                 numOfCerts &gt; 10 ? 10 : numOfCerts);
705                         for (int j = 0; j &lt; numOfCerts; j++) {
706                             if (xVersion == 2) {
707                                 // read the certificate type, and instantiate a
708                                 // certificate factory of that type (reuse
709                                 // existing factory if possible)
710                                 String certType = dis.readUTF();
711                                 if (cfs.containsKey(certType)) {
712                                     // reuse certificate factory
713                                     cf = cfs.get(certType);
714                                 } else {
715                                     // create new certificate factory
716                                     cf = CertificateFactory.getInstance(certType);
717                                     // store the certificate factory so we can
718                                     // reuse it later
719                                     cfs.put(certType, cf);
720                                 }
721                             }
722                             // instantiate the certificate
<span class="line-modified">723                             encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
724                             bais = new ByteArrayInputStream(encoded);
725                             certs.add(cf.generateCertificate(bais));
726                             bais.close();
727                         }
728                         // We can be sure now that numOfCerts of certs are read
729                         entry.chain = certs.toArray(new Certificate[numOfCerts]);
730                     }
731 
732                     // Add the entry to the list
733                     entries.put(alias, entry);
734 
735                 } else if (tag == 2) { // trusted certificate entry
736                     trustedKeyCount++;
737                     TrustedCertEntry entry = new TrustedCertEntry();
738 
739                     // Read the alias
740                     alias = dis.readUTF();
741 
742                     // Read the (entry creation) date
743                     entry.date = new Date(dis.readLong());
744 
745                     // Read the trusted certificate
746                     if (xVersion == 2) {
747                         // read the certificate type, and instantiate a
748                         // certificate factory of that type (reuse
749                         // existing factory if possible)
750                         String certType = dis.readUTF();
751                         if (cfs.containsKey(certType)) {
752                             // reuse certificate factory
753                             cf = cfs.get(certType);
754                         } else {
755                             // create new certificate factory
756                             cf = CertificateFactory.getInstance(certType);
757                             // store the certificate factory so we can
758                             // reuse it later
759                             cfs.put(certType, cf);
760                         }
761                     }
<span class="line-modified">762                     encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
763                     bais = new ByteArrayInputStream(encoded);
764                     entry.cert = cf.generateCertificate(bais);
765                     bais.close();
766 
767                     // Add the entry to the list
768                     entries.put(alias, entry);
769 
770                 } else {
771                     throw new IOException(&quot;Unrecognized keystore entry: &quot; +
772                             tag);
773                 }
774             }
775 
776             if (debug != null) {
777                 debug.println(&quot;JavaKeyStore load: private key count: &quot; +
778                     privateKeyCount + &quot;. trusted key count: &quot; + trustedKeyCount);
779             }
780 
781             /*
782              * If a password has been provided, we check the keyed digest
783              * at the end. If this check fails, the store has been tampered
784              * with
785              */
786             if (password != null) {
787                 byte[] computed = md.digest();
<span class="line-modified">788                 byte[] actual = new byte[computed.length];</span>
<span class="line-modified">789                 dis.readFully(actual);</span>
<span class="line-modified">790                 for (int i = 0; i &lt; computed.length; i++) {</span>
<span class="line-removed">791                     if (computed[i] != actual[i]) {</span>
<span class="line-removed">792                         Throwable t = new UnrecoverableKeyException</span>
793                             (&quot;Password verification failed&quot;);
<span class="line-modified">794                         throw (IOException)new IOException</span>
795                             (&quot;Keystore was tampered with, or &quot;
<span class="line-modified">796                             + &quot;password was incorrect&quot;).initCause(t);</span>
<span class="line-removed">797                     }</span>
798                 }
799             }
800         }
801     }
802 
803     /**
804      * To guard against tampering with the keystore, we append a keyed
805      * hash with a bit of whitener.
806      */
807     private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">808         throws NoSuchAlgorithmException, UnsupportedEncodingException</span>
809     {
810 
811         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
812         byte[] passwdBytes = convertToBytes(password);
813         md.update(passwdBytes);
814         Arrays.fill(passwdBytes, (byte) 0x00);
<span class="line-modified">815         md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));</span>
816         return md;
817     }
818 
819     /**
820      * Helper method to convert char[] to byte[]
821      */
822 
823     private byte[] convertToBytes(char[] password) {
824         int i, j;
825         byte[] passwdBytes = new byte[password.length * 2];
826         for (i=0, j=0; i&lt;password.length; i++) {
827             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
828             passwdBytes[j++] = (byte)password[i];
829         }
830         return passwdBytes;
831     }
832 
833     /**
834      * Probe the first few bytes of the keystore data stream for a valid
835      * JKS keystore encoding.
</pre>
</td>
<td>
<hr />
<pre>
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.*;
 29 import java.security.*;
 30 import java.security.cert.Certificate;
 31 import java.security.cert.CertificateFactory;
 32 import java.security.cert.CertificateException;
 33 import java.util.*;
 34 
<span class="line-added"> 35 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 36 </span>
 37 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 38 import sun.security.pkcs12.PKCS12KeyStore;
 39 import sun.security.util.Debug;
 40 import sun.security.util.IOUtils;
 41 import sun.security.util.KeyStoreDelegator;
 42 
 43 /**
 44  * This class provides the keystore implementation referred to as &quot;JKS&quot;.
 45  *
 46  * @author Jan Luehe
 47  * @author David Brownell
 48  *
 49  *
 50  * @see KeyProtector
 51  * @see java.security.KeyStoreSpi
 52  * @see KeyTool
 53  *
 54  * @since 1.2
 55  */
 56 
</pre>
<hr />
<pre>
680             int count = dis.readInt();
681 
682             for (int i = 0; i &lt; count; i++) {
683                 int tag;
684                 String alias;
685 
686                 tag = dis.readInt();
687 
688                 if (tag == 1) { // private key entry
689                     privateKeyCount++;
690                     KeyEntry entry = new KeyEntry();
691 
692                     // Read the alias
693                     alias = dis.readUTF();
694 
695                     // Read the (entry creation) date
696                     entry.date = new Date(dis.readLong());
697 
698                     // Read the private key
699                     entry.protectedPrivKey =
<span class="line-modified">700                             IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
701 
702                     // Read the certificate chain
703                     int numOfCerts = dis.readInt();
704                     if (numOfCerts &gt; 0) {
705                         List&lt;Certificate&gt; certs = new ArrayList&lt;&gt;(
706                                 numOfCerts &gt; 10 ? 10 : numOfCerts);
707                         for (int j = 0; j &lt; numOfCerts; j++) {
708                             if (xVersion == 2) {
709                                 // read the certificate type, and instantiate a
710                                 // certificate factory of that type (reuse
711                                 // existing factory if possible)
712                                 String certType = dis.readUTF();
713                                 if (cfs.containsKey(certType)) {
714                                     // reuse certificate factory
715                                     cf = cfs.get(certType);
716                                 } else {
717                                     // create new certificate factory
718                                     cf = CertificateFactory.getInstance(certType);
719                                     // store the certificate factory so we can
720                                     // reuse it later
721                                     cfs.put(certType, cf);
722                                 }
723                             }
724                             // instantiate the certificate
<span class="line-modified">725                             encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
726                             bais = new ByteArrayInputStream(encoded);
727                             certs.add(cf.generateCertificate(bais));
728                             bais.close();
729                         }
730                         // We can be sure now that numOfCerts of certs are read
731                         entry.chain = certs.toArray(new Certificate[numOfCerts]);
732                     }
733 
734                     // Add the entry to the list
735                     entries.put(alias, entry);
736 
737                 } else if (tag == 2) { // trusted certificate entry
738                     trustedKeyCount++;
739                     TrustedCertEntry entry = new TrustedCertEntry();
740 
741                     // Read the alias
742                     alias = dis.readUTF();
743 
744                     // Read the (entry creation) date
745                     entry.date = new Date(dis.readLong());
746 
747                     // Read the trusted certificate
748                     if (xVersion == 2) {
749                         // read the certificate type, and instantiate a
750                         // certificate factory of that type (reuse
751                         // existing factory if possible)
752                         String certType = dis.readUTF();
753                         if (cfs.containsKey(certType)) {
754                             // reuse certificate factory
755                             cf = cfs.get(certType);
756                         } else {
757                             // create new certificate factory
758                             cf = CertificateFactory.getInstance(certType);
759                             // store the certificate factory so we can
760                             // reuse it later
761                             cfs.put(certType, cf);
762                         }
763                     }
<span class="line-modified">764                     encoded = IOUtils.readExactlyNBytes(dis, dis.readInt());</span>
765                     bais = new ByteArrayInputStream(encoded);
766                     entry.cert = cf.generateCertificate(bais);
767                     bais.close();
768 
769                     // Add the entry to the list
770                     entries.put(alias, entry);
771 
772                 } else {
773                     throw new IOException(&quot;Unrecognized keystore entry: &quot; +
774                             tag);
775                 }
776             }
777 
778             if (debug != null) {
779                 debug.println(&quot;JavaKeyStore load: private key count: &quot; +
780                     privateKeyCount + &quot;. trusted key count: &quot; + trustedKeyCount);
781             }
782 
783             /*
784              * If a password has been provided, we check the keyed digest
785              * at the end. If this check fails, the store has been tampered
786              * with
787              */
788             if (password != null) {
789                 byte[] computed = md.digest();
<span class="line-modified">790                 byte[] actual = IOUtils.readExactlyNBytes(dis, computed.length);</span>
<span class="line-modified">791                 if (!MessageDigest.isEqual(computed, actual)) {</span>
<span class="line-modified">792                     Throwable t = new UnrecoverableKeyException</span>


793                             (&quot;Password verification failed&quot;);
<span class="line-modified">794                     throw (IOException) new IOException</span>
795                             (&quot;Keystore was tampered with, or &quot;
<span class="line-modified">796                                     + &quot;password was incorrect&quot;).initCause(t);</span>

797                 }
798             }
799         }
800     }
801 
802     /**
803      * To guard against tampering with the keystore, we append a keyed
804      * hash with a bit of whitener.
805      */
806     private MessageDigest getPreKeyedHash(char[] password)
<span class="line-modified">807         throws NoSuchAlgorithmException</span>
808     {
809 
810         MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
811         byte[] passwdBytes = convertToBytes(password);
812         md.update(passwdBytes);
813         Arrays.fill(passwdBytes, (byte) 0x00);
<span class="line-modified">814         md.update(&quot;Mighty Aphrodite&quot;.getBytes(UTF_8));</span>
815         return md;
816     }
817 
818     /**
819      * Helper method to convert char[] to byte[]
820      */
821 
822     private byte[] convertToBytes(char[] password) {
823         int i, j;
824         byte[] passwdBytes = new byte[password.length * 2];
825         for (i=0, j=0; i&lt;password.length; i++) {
826             passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);
827             passwdBytes[j++] = (byte)password[i];
828         }
829         return passwdBytes;
830     }
831 
832     /**
833      * Probe the first few bytes of the keystore data stream for a valid
834      * JKS keystore encoding.
</pre>
</td>
</tr>
</table>
<center><a href="DomainKeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="KeyProtector.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
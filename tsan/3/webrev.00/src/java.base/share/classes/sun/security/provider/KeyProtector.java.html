<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.IOException;
 29 import java.security.Key;
 30 import java.security.KeyStoreException;
 31 import java.security.MessageDigest;
 32 import java.security.NoSuchAlgorithmException;
 33 import java.security.SecureRandom;
 34 import java.security.UnrecoverableKeyException;
 35 import java.util.*;
 36 
 37 import sun.security.pkcs.PKCS8Key;
 38 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 39 import sun.security.x509.AlgorithmId;
 40 import sun.security.util.ObjectIdentifier;
 41 import sun.security.util.DerValue;
 42 
 43 /**
 44  * This is an implementation of a Sun proprietary, exportable algorithm
 45  * intended for use when protecting (or recovering the cleartext version of)
 46  * sensitive keys.
 47  * This algorithm is not intended as a general purpose cipher.
 48  *
 49  * This is how the algorithm works for key protection:
 50  *
 51  * p - user password
 52  * s - random salt
 53  * X - xor key
 54  * P - to-be-protected key
 55  * Y - protected key
 56  * R - what gets stored in the keystore
 57  *
 58  * Step 1:
 59  * Take the user&#39;s password, append a random salt (of fixed size) to it,
 60  * and hash it: d1 = digest(p, s)
 61  * Store d1 in X.
 62  *
 63  * Step 2:
 64  * Take the user&#39;s password, append the digest result from the previous step,
 65  * and hash it: dn = digest(p, dn-1).
 66  * Store dn in X (append it to the previously stored digests).
 67  * Repeat this step until the length of X matches the length of the private key
 68  * P.
 69  *
 70  * Step 3:
 71  * XOR X and P, and store the result in Y: Y = X XOR P.
 72  *
 73  * Step 4:
 74  * Store s, Y, and digest(p, P) in the result buffer R:
 75  * R = s + Y + digest(p, P), where &quot;+&quot; denotes concatenation.
 76  * (NOTE: digest(p, P) is stored in the result buffer, so that when the key is
 77  * recovered, we can check if the recovered key indeed matches the original
 78  * key.) R is stored in the keystore.
 79  *
 80  * The protected key is recovered as follows:
 81  *
 82  * Step1 and Step2 are the same as above, except that the salt is not randomly
 83  * generated, but taken from the result R of step 4 (the first length(s)
 84  * bytes).
 85  *
 86  * Step 3 (XOR operation) yields the plaintext key.
 87  *
 88  * Then concatenate the password with the recovered key, and compare with the
 89  * last length(digest(p, P)) bytes of R. If they match, the recovered key is
 90  * indeed the same key as the original key.
 91  *
 92  * @author Jan Luehe
 93  *
 94  *
 95  * @see java.security.KeyStore
 96  * @see JavaKeyStore
 97  * @see KeyTool
 98  *
 99  * @since 1.2
100  */
101 
102 final class KeyProtector {
103 
104     private static final int SALT_LEN = 20; // the salt length
105     private static final String DIGEST_ALG = &quot;SHA&quot;;
106     private static final int DIGEST_LEN = 20;
107 
108     // defined by JavaSoft
109     private static final String KEY_PROTECTOR_OID = &quot;1.3.6.1.4.1.42.2.17.1.1&quot;;
110 
111     // The password used for protecting/recovering keys passed through this
112     // key protector. We store it as a byte array, so that we can digest it.
113     private byte[] passwdBytes;
114 
115     private MessageDigest md;
116 
117 
118     /**
119      * Creates an instance of this class, and initializes it with the given
120      * password.
121      */
122     public KeyProtector(byte[] passwordBytes)
123         throws NoSuchAlgorithmException
124     {
125         if (passwordBytes == null) {
126            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
127         }
128         md = MessageDigest.getInstance(DIGEST_ALG);
129         this.passwdBytes = passwordBytes;
130     }
131 
132     /*
133      * Protects the given plaintext key, using the password provided at
134      * construction time.
135      */
136     public byte[] protect(Key key) throws KeyStoreException
137     {
138         int i;
139         int numRounds;
140         byte[] digest;
141         int xorOffset; // offset in xorKey where next digest will be stored
142         int encrKeyOffset = 0;
143 
144         if (key == null) {
145             throw new IllegalArgumentException(&quot;plaintext key can&#39;t be null&quot;);
146         }
147 
148         if (!&quot;PKCS#8&quot;.equalsIgnoreCase(key.getFormat())) {
149             throw new KeyStoreException(
150                 &quot;Cannot get key bytes, not PKCS#8 encoded&quot;);
151         }
152 
153         byte[] plainKey = key.getEncoded();
154         if (plainKey == null) {
155             throw new KeyStoreException(
156                 &quot;Cannot get key bytes, encoding not supported&quot;);
157         }
158 
159         // Determine the number of digest rounds
160         numRounds = plainKey.length / DIGEST_LEN;
161         if ((plainKey.length % DIGEST_LEN) != 0)
162             numRounds++;
163 
164         // Create a random salt
165         byte[] salt = new byte[SALT_LEN];
166         SecureRandom random = new SecureRandom();
167         random.nextBytes(salt);
168 
169         // Set up the byte array which will be XORed with &quot;plainKey&quot;
170         byte[] xorKey = new byte[plainKey.length];
171 
172         // Compute the digests, and store them in &quot;xorKey&quot;
173         for (i = 0, xorOffset = 0, digest = salt;
174              i &lt; numRounds;
175              i++, xorOffset += DIGEST_LEN) {
176             md.update(passwdBytes);
177             md.update(digest);
178             digest = md.digest();
179             md.reset();
180             // Copy the digest into &quot;xorKey&quot;
181             if (i &lt; numRounds - 1) {
182                 System.arraycopy(digest, 0, xorKey, xorOffset,
183                                  digest.length);
184             } else {
185                 System.arraycopy(digest, 0, xorKey, xorOffset,
186                                  xorKey.length - xorOffset);
187             }
188         }
189 
190         // XOR &quot;plainKey&quot; with &quot;xorKey&quot;, and store the result in &quot;tmpKey&quot;
191         byte[] tmpKey = new byte[plainKey.length];
192         for (i = 0; i &lt; tmpKey.length; i++) {
193             tmpKey[i] = (byte)(plainKey[i] ^ xorKey[i]);
194         }
195 
196         // Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;
197         byte[] encrKey = new byte[salt.length + tmpKey.length + DIGEST_LEN];
198         System.arraycopy(salt, 0, encrKey, encrKeyOffset, salt.length);
199         encrKeyOffset += salt.length;
200         System.arraycopy(tmpKey, 0, encrKey, encrKeyOffset, tmpKey.length);
201         encrKeyOffset += tmpKey.length;
202 
203         // Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;
204         md.update(passwdBytes);
205         Arrays.fill(passwdBytes, (byte)0x00);
206         passwdBytes = null;
207         md.update(plainKey);
208         digest = md.digest();
209         md.reset();
210         System.arraycopy(digest, 0, encrKey, encrKeyOffset, digest.length);
211 
212         // wrap the protected private key in a PKCS#8-style
213         // EncryptedPrivateKeyInfo, and returns its encoding
214         AlgorithmId encrAlg;
215         try {
216             encrAlg = new AlgorithmId(new ObjectIdentifier(KEY_PROTECTOR_OID));
217             return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
218         } catch (IOException ioe) {
219             throw new KeyStoreException(ioe.getMessage());
220         }
221     }
222 
223     /*
224      * Recovers the plaintext version of the given key (in protected format),
225      * using the password provided at construction time.
226      */
227     public Key recover(EncryptedPrivateKeyInfo encrInfo)
228         throws UnrecoverableKeyException
229     {
230         int i;
231         byte[] digest;
232         int numRounds;
233         int xorOffset; // offset in xorKey where next digest will be stored
234         int encrKeyLen; // the length of the encrpyted key
235 
236         // do we support the algorithm?
237         AlgorithmId encrAlg = encrInfo.getAlgorithm();
238         if (!(encrAlg.getOID().toString().equals(KEY_PROTECTOR_OID))) {
239             throw new UnrecoverableKeyException(&quot;Unsupported key protection &quot;
240                                                 + &quot;algorithm&quot;);
241         }
242 
243         byte[] protectedKey = encrInfo.getEncryptedData();
244 
245         /*
246          * Get the salt associated with this key (the first SALT_LEN bytes of
247          * &lt;code&gt;protectedKey&lt;/code&gt;)
248          */
249         byte[] salt = new byte[SALT_LEN];
250         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
251 
252         // Determine the number of digest rounds
253         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
254         numRounds = encrKeyLen / DIGEST_LEN;
255         if ((encrKeyLen % DIGEST_LEN) != 0) numRounds++;
256 
257         // Get the encrypted key portion and store it in &quot;encrKey&quot;
258         byte[] encrKey = new byte[encrKeyLen];
259         System.arraycopy(protectedKey, SALT_LEN, encrKey, 0, encrKeyLen);
260 
261         // Set up the byte array which will be XORed with &quot;encrKey&quot;
262         byte[] xorKey = new byte[encrKey.length];
263 
264         // Compute the digests, and store them in &quot;xorKey&quot;
265         for (i = 0, xorOffset = 0, digest = salt;
266              i &lt; numRounds;
267              i++, xorOffset += DIGEST_LEN) {
268             md.update(passwdBytes);
269             md.update(digest);
270             digest = md.digest();
271             md.reset();
272             // Copy the digest into &quot;xorKey&quot;
273             if (i &lt; numRounds - 1) {
274                 System.arraycopy(digest, 0, xorKey, xorOffset,
275                                  digest.length);
276             } else {
277                 System.arraycopy(digest, 0, xorKey, xorOffset,
278                                  xorKey.length - xorOffset);
279             }
280         }
281 
282         // XOR &quot;encrKey&quot; with &quot;xorKey&quot;, and store the result in &quot;plainKey&quot;
283         byte[] plainKey = new byte[encrKey.length];
284         for (i = 0; i &lt; plainKey.length; i++) {
285             plainKey[i] = (byte)(encrKey[i] ^ xorKey[i]);
286         }
287 
288         /*
289          * Check the integrity of the recovered key by concatenating it with
290          * the password, digesting the concatenation, and comparing the
291          * result of the digest operation with the digest provided at the end
292          * of &lt;code&gt;protectedKey&lt;/code&gt;. If the two digest values are
293          * different, throw an exception.
294          */
295         md.update(passwdBytes);
296         Arrays.fill(passwdBytes, (byte)0x00);
297         passwdBytes = null;
298         md.update(plainKey);
299         digest = md.digest();
300         md.reset();
301         for (i = 0; i &lt; digest.length; i++) {
302             if (digest[i] != protectedKey[SALT_LEN + encrKeyLen + i]) {
303                 throw new UnrecoverableKeyException(&quot;Cannot recover key&quot;);
304             }
305         }
306 
307         // The parseKey() method of PKCS8Key parses the key
308         // algorithm and instantiates the appropriate key factory,
309         // which in turn parses the key material.
310         try {
311             return PKCS8Key.parseKey(new DerValue(plainKey));
312         } catch (IOException ioe) {
313             throw new UnrecoverableKeyException(ioe.getMessage());
314         }
315     }
316 }
    </pre>
  </body>
</html>
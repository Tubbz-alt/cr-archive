diff a/src/java.base/share/classes/sun/security/ssl/X509Authentication.java b/src/java.base/share/classes/sun/security/ssl/X509Authentication.java
--- a/src/java.base/share/classes/sun/security/ssl/X509Authentication.java
+++ b/src/java.base/share/classes/sun/security/ssl/X509Authentication.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,18 +26,21 @@
 package sun.security.ssl;
 
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.security.cert.X509Certificate;
+import java.security.interfaces.ECKey;
 import java.security.interfaces.ECPublicKey;
+import java.security.interfaces.XECKey;
+import java.security.spec.AlgorithmParameterSpec;
 import java.security.spec.ECParameterSpec;
+import java.security.spec.NamedParameterSpec;
 import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.Map;
 import javax.net.ssl.SSLEngine;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.X509ExtendedKeyManager;
-import sun.security.ssl.SupportedGroupsExtension.NamedGroup;
 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 
 enum X509Authentication implements SSLAuthentication {
     // Require rsaEncryption public key
     RSA         ("RSA",         new X509PossessionGenerator(
@@ -64,11 +67,11 @@
                                     new String[] {"EC"}));
 
     final String keyType;
     final SSLPossessionGenerator possessionGenerator;
 
-    X509Authentication(String keyType,
+    private X509Authentication(String keyType,
             SSLPossessionGenerator possessionGenerator) {
         this.keyType = keyType;
         this.possessionGenerator = possessionGenerator;
     }
 
@@ -125,10 +128,59 @@
         X509Possession(PrivateKey popPrivateKey,
                 X509Certificate[] popCerts) {
             this.popCerts = popCerts;
             this.popPrivateKey = popPrivateKey;
         }
+
+        ECParameterSpec getECParameterSpec() {
+            if (popPrivateKey == null ||
+                    !"EC".equals(popPrivateKey.getAlgorithm())) {
+                return null;
+            }
+
+            if (popPrivateKey instanceof ECKey) {
+                return ((ECKey)popPrivateKey).getParams();
+            } else if (popCerts != null && popCerts.length != 0) {
+                // The private key not extractable, get the parameters from
+                // the X.509 certificate.
+                PublicKey publicKey = popCerts[0].getPublicKey();
+                if (publicKey instanceof ECKey) {
+                    return ((ECKey)publicKey).getParams();
+                }
+            }
+
+            return null;
+        }
+
+        // Similar to above, but for XEC.
+        NamedParameterSpec getXECParameterSpec() {
+            if (popPrivateKey == null ||
+                    !"XEC".equals(popPrivateKey.getAlgorithm())) {
+                return null;
+            }
+
+            if (popPrivateKey instanceof XECKey) {
+                AlgorithmParameterSpec params =
+                        ((XECKey)popPrivateKey).getParams();
+                if (params instanceof NamedParameterSpec){
+                    return (NamedParameterSpec)params;
+                }
+            } else if (popCerts != null && popCerts.length != 0) {
+                // The private key not extractable, get the parameters from
+                // the X.509 certificate.
+                PublicKey publicKey = popCerts[0].getPublicKey();
+                if (publicKey instanceof XECKey) {
+                    AlgorithmParameterSpec params =
+                            ((XECKey)publicKey).getParams();
+                    if (params instanceof NamedParameterSpec){
+                        return (NamedParameterSpec)params;
+                    }
+                }
+            }
+
+            return null;
+        }
     }
 
     static final class X509Credentials implements SSLCredentials {
         final X509Certificate[]   popCerts;
         final PublicKey           popPublicKey;
@@ -272,25 +324,28 @@
                             keyType + " algorithm");
                 }
                 return null;
             }
 
-            // For ECC certs, check whether we support the EC domain
-            // parameters.  If the client sent a SupportedEllipticCurves
-            // ClientHello extension, check against that too.
-            if (keyType.equals("EC")) {
+            // For TLS 1.2 and prior versions, the public key of a EC cert
+            // MUST use a curve and point format supported by the client.
+            // But for TLS 1.3, signature algorithms are negotiated
+            // independently via the "signature_algorithms" extension.
+            if (!shc.negotiatedProtocol.useTLS13PlusSpec() &&
+                    keyType.equals("EC")) {
                 if (!(serverPublicKey instanceof ECPublicKey)) {
                     if (SSLLogger.isOn && SSLLogger.isOn("ssl")) {
                         SSLLogger.warning(serverAlias +
                             " public key is not an instance of ECPublicKey");
                     }
                     return null;
                 }
 
                 // For ECC certs, check whether we support the EC domain
-                // parameters. If the client sent a SupportedEllipticCurves
-                // ClientHello extension, check against that too.
+                // parameters.  If the client sent a supported_groups
+                // ClientHello extension, check against that too for
+                // TLS 1.2 and prior versions.
                 ECParameterSpec params =
                         ((ECPublicKey)serverPublicKey).getParams();
                 NamedGroup namedGroup = NamedGroup.valueOf(params);
                 if ((namedGroup == null) ||
                         (!SupportedGroups.isSupported(namedGroup)) ||

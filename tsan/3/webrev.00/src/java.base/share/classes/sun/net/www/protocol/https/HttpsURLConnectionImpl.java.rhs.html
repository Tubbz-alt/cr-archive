<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/net/www/protocol/https/HttpsURLConnectionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.www.protocol.https;
 27 
 28 import java.net.URL;
 29 import java.net.Proxy;
 30 import java.net.ProtocolException;
 31 import java.net.MalformedURLException;
 32 import java.io.*;
 33 import java.net.Authenticator;
 34 import javax.net.ssl.*;
 35 import java.security.Permission;
 36 import java.security.Principal;
 37 import java.util.Map;
 38 import java.util.List;
 39 import java.util.Optional;
<a name="1" id="anc1"></a><span class="line-added"> 40 import sun.net.util.IPAddressUtil;</span>
 41 import sun.net.www.http.HttpClient;
 42 
 43 /**
 44  * A class to represent an HTTP connection to a remote object.
 45  *
 46  * Ideally, this class should subclass and inherit the http handler
 47  * implementation, but it can&#39;t do so because that class have the
 48  * wrong Java Type.  Thus it uses the delegate (aka, the
 49  * Adapter/Wrapper design pattern) to reuse code from the http
 50  * handler.
 51  *
 52  * Since it would use a delegate to access
 53  * sun.net.www.protocol.http.HttpURLConnection functionalities, it
 54  * needs to implement all public methods in it&#39;s super class and all
 55  * the way to Object.
 56  *
 57  */
 58 public class HttpsURLConnectionImpl
 59         extends javax.net.ssl.HttpsURLConnection {
 60 
<a name="2" id="anc2"></a><span class="line-modified"> 61     private final DelegateHttpsURLConnection delegate;</span>

 62 
 63     HttpsURLConnectionImpl(URL u, Handler handler) throws IOException {
 64         this(u, null, handler);
 65     }
 66 
 67     static URL checkURL(URL u) throws IOException {
 68         if (u != null) {
 69             if (u.toExternalForm().indexOf(&#39;\n&#39;) &gt; -1) {
 70                 throw new MalformedURLException(&quot;Illegal character in URL&quot;);
 71             }
 72         }
<a name="3" id="anc3"></a><span class="line-added"> 73         String s = IPAddressUtil.checkAuthority(u);</span>
<span class="line-added"> 74         if (s != null) {</span>
<span class="line-added"> 75             throw new MalformedURLException(s);</span>
<span class="line-added"> 76         }</span>
 77         return u;
 78     }
 79 
 80     HttpsURLConnectionImpl(URL u, Proxy p, Handler handler) throws IOException {
 81         super(checkURL(u));
 82         delegate = new DelegateHttpsURLConnection(url, p, handler, this);
 83     }
 84 
<a name="4" id="anc4"></a>






 85     /**
 86      * Create a new HttpClient object, bypassing the cache of
 87      * HTTP client objects/connections.
 88      *
 89      * @param url       the URL being accessed
 90      */
 91     protected void setNewClient(URL url) throws IOException {
 92         delegate.setNewClient(url, false);
 93     }
 94 
 95     /**
 96      * Obtain a HttpClient object. Use the cached copy if specified.
 97      *
 98      * @param url       the URL being accessed
 99      * @param useCache  whether the cached connection should be used
100      *                  if present
101      */
102     protected void setNewClient(URL url, boolean useCache)
103             throws IOException {
104         delegate.setNewClient(url, useCache);
105     }
106 
107     /**
108      * Create a new HttpClient object, set up so that it uses
109      * per-instance proxying to the given HTTP proxy.  This
110      * bypasses the cache of HTTP client objects/connections.
111      *
112      * @param url       the URL being accessed
113      * @param proxyHost the proxy host to use
114      * @param proxyPort the proxy port to use
115      */
116     protected void setProxiedClient(URL url, String proxyHost, int proxyPort)
117             throws IOException {
118         delegate.setProxiedClient(url, proxyHost, proxyPort);
119     }
120 
121     /**
122      * Obtain a HttpClient object, set up so that it uses per-instance
123      * proxying to the given HTTP proxy. Use the cached copy of HTTP
124      * client objects/connections if specified.
125      *
126      * @param url       the URL being accessed
127      * @param proxyHost the proxy host to use
128      * @param proxyPort the proxy port to use
129      * @param useCache  whether the cached connection should be used
130      *                  if present
131      */
132     protected void setProxiedClient(URL url, String proxyHost, int proxyPort,
133             boolean useCache) throws IOException {
134         delegate.setProxiedClient(url, proxyHost, proxyPort, useCache);
135     }
136 
137     /**
138      * Implements the HTTP protocol handler&#39;s &quot;connect&quot; method,
139      * establishing an SSL connection to the server as necessary.
140      */
141     public void connect() throws IOException {
142         delegate.connect();
143     }
144 
145     /**
146      * Used by subclass to access &quot;connected&quot; variable.  Since we are
147      * delegating the actual implementation to &quot;delegate&quot;, we need to
148      * delegate the access of &quot;connected&quot; as well.
149      */
150     protected boolean isConnected() {
151         return delegate.isConnected();
152     }
153 
154     /**
155      * Used by subclass to access &quot;connected&quot; variable.  Since we are
156      * delegating the actual implementation to &quot;delegate&quot;, we need to
157      * delegate the access of &quot;connected&quot; as well.
158      */
159     protected void setConnected(boolean conn) {
160         delegate.setConnected(conn);
161     }
162 
163     /**
164      * Returns the cipher suite in use on this connection.
165      */
166     public String getCipherSuite() {
167         return delegate.getCipherSuite();
168     }
169 
170     /**
171      * Returns the certificate chain the client sent to the
172      * server, or null if the client did not authenticate.
173      */
174     public java.security.cert.Certificate []
175         getLocalCertificates() {
176         return delegate.getLocalCertificates();
177     }
178 
179     /**
180      * Returns the server&#39;s certificate chain, or throws
181      * SSLPeerUnverified Exception if
182      * the server did not authenticate.
183      */
184     public java.security.cert.Certificate []
185         getServerCertificates() throws SSLPeerUnverifiedException {
186         return delegate.getServerCertificates();
187     }
188 
189     /**
190      * Returns the principal with which the server authenticated itself,
191      * or throw a SSLPeerUnverifiedException if the server did not authenticate.
192      */
193     public Principal getPeerPrincipal()
194             throws SSLPeerUnverifiedException
195     {
196         return delegate.getPeerPrincipal();
197     }
198 
199     /**
200      * Returns the principal the client sent to the
201      * server, or null if the client did not authenticate.
202      */
203     public Principal getLocalPrincipal()
204     {
205         return delegate.getLocalPrincipal();
206     }
207 
208     /*
209      * Allowable input/output sequences:
210      * [interpreted as POST/PUT]
211      * - get output, [write output,] get input, [read input]
212      * - get output, [write output]
213      * [interpreted as GET]
214      * - get input, [read input]
215      * Disallowed:
216      * - get input, [read input,] get output, [write output]
217      */
218 
<a name="5" id="anc5"></a><span class="line-modified">219     public OutputStream getOutputStream() throws IOException {</span>
220         return delegate.getOutputStream();
221     }
222 
<a name="6" id="anc6"></a><span class="line-modified">223     public InputStream getInputStream() throws IOException {</span>
224         return delegate.getInputStream();
225     }
226 
227     public InputStream getErrorStream() {
228         return delegate.getErrorStream();
229     }
230 
231     /**
232      * Disconnect from the server.
233      */
234     public void disconnect() {
235         delegate.disconnect();
236     }
237 
238     public boolean usingProxy() {
239         return delegate.usingProxy();
240     }
241 
242     /**
243      * Returns an unmodifiable Map of the header fields.
244      * The Map keys are Strings that represent the
245      * response-header field names. Each Map value is an
246      * unmodifiable List of Strings that represents
247      * the corresponding field values.
248      *
249      * @return a Map of header fields
250      * @since 1.4
251      */
252     public Map&lt;String,List&lt;String&gt;&gt; getHeaderFields() {
253         return delegate.getHeaderFields();
254     }
255 
256     /**
257      * Gets a header field by name. Returns null if not known.
258      * @param name the name of the header field
259      */
260     public String getHeaderField(String name) {
261         return delegate.getHeaderField(name);
262     }
263 
264     /**
265      * Gets a header field by index. Returns null if not known.
266      * @param n the index of the header field
267      */
268     public String getHeaderField(int n) {
269         return delegate.getHeaderField(n);
270     }
271 
272     /**
273      * Gets a header field by index. Returns null if not known.
274      * @param n the index of the header field
275      */
276     public String getHeaderFieldKey(int n) {
277         return delegate.getHeaderFieldKey(n);
278     }
279 
280     /**
281      * Sets request property. If a property with the key already
282      * exists, overwrite its value with the new value.
283      * @param value the value to be set
284      */
285     public void setRequestProperty(String key, String value) {
286         delegate.setRequestProperty(key, value);
287     }
288 
289     /**
290      * Adds a general request property specified by a
291      * key-value pair.  This method will not overwrite
292      * existing values associated with the same key.
293      *
294      * @param   key     the keyword by which the request is known
295      *                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).
296      * @param   value  the value associated with it.
<a name="7" id="anc7"></a><span class="line-modified">297      * @see #getRequestProperty(java.lang.String)</span>
298      * @since 1.4
299      */
300     public void addRequestProperty(String key, String value) {
301         delegate.addRequestProperty(key, value);
302     }
303 
304     /**
305      * Overwrite super class method
306      */
307     public int getResponseCode() throws IOException {
308         return delegate.getResponseCode();
309     }
310 
311     public String getRequestProperty(String key) {
312         return delegate.getRequestProperty(key);
313     }
314 
315     /**
316      * Returns an unmodifiable Map of general request
317      * properties for this connection. The Map keys
318      * are Strings that represent the request-header
319      * field names. Each Map value is a unmodifiable List
320      * of Strings that represents the corresponding
321      * field values.
322      *
323      * @return  a Map of the general request properties for this connection.
324      * @throws IllegalStateException if already connected
325      * @since 1.4
326      */
327     public Map&lt;String,List&lt;String&gt;&gt; getRequestProperties() {
328         return delegate.getRequestProperties();
329     }
330 
331     /*
332      * We support JDK 1.2.x so we can&#39;t count on these from JDK 1.3.
333      * We override and supply our own version.
334      */
335     public void setInstanceFollowRedirects(boolean shouldFollow) {
336         delegate.setInstanceFollowRedirects(shouldFollow);
337     }
338 
339     public boolean getInstanceFollowRedirects() {
340         return delegate.getInstanceFollowRedirects();
341     }
342 
343     public void setRequestMethod(String method) throws ProtocolException {
344         delegate.setRequestMethod(method);
345     }
346 
347     public String getRequestMethod() {
348         return delegate.getRequestMethod();
349     }
350 
351     public String getResponseMessage() throws IOException {
352         return delegate.getResponseMessage();
353     }
354 
355     public long getHeaderFieldDate(String name, long Default) {
356         return delegate.getHeaderFieldDate(name, Default);
357     }
358 
359     public Permission getPermission() throws IOException {
360         return delegate.getPermission();
361     }
362 
363     public URL getURL() {
364         return delegate.getURL();
365     }
366 
367     public int getContentLength() {
368         return delegate.getContentLength();
369     }
370 
371     public long getContentLengthLong() {
372         return delegate.getContentLengthLong();
373     }
374 
375     public String getContentType() {
376         return delegate.getContentType();
377     }
378 
379     public String getContentEncoding() {
380         return delegate.getContentEncoding();
381     }
382 
383     public long getExpiration() {
384         return delegate.getExpiration();
385     }
386 
387     public long getDate() {
388         return delegate.getDate();
389     }
390 
391     public long getLastModified() {
392         return delegate.getLastModified();
393     }
394 
395     public int getHeaderFieldInt(String name, int Default) {
396         return delegate.getHeaderFieldInt(name, Default);
397     }
398 
399     public long getHeaderFieldLong(String name, long Default) {
400         return delegate.getHeaderFieldLong(name, Default);
401     }
402 
403     public Object getContent() throws IOException {
404         return delegate.getContent();
405     }
406 
407     @SuppressWarnings(&quot;rawtypes&quot;)
408     public Object getContent(Class[] classes) throws IOException {
409         return delegate.getContent(classes);
410     }
411 
412     public String toString() {
413         return delegate.toString();
414     }
415 
416     public void setDoInput(boolean doinput) {
417         delegate.setDoInput(doinput);
418     }
419 
420     public boolean getDoInput() {
421         return delegate.getDoInput();
422     }
423 
424     public void setDoOutput(boolean dooutput) {
425         delegate.setDoOutput(dooutput);
426     }
427 
428     public boolean getDoOutput() {
429         return delegate.getDoOutput();
430     }
431 
432     public void setAllowUserInteraction(boolean allowuserinteraction) {
433         delegate.setAllowUserInteraction(allowuserinteraction);
434     }
435 
436     public boolean getAllowUserInteraction() {
437         return delegate.getAllowUserInteraction();
438     }
439 
440     public void setUseCaches(boolean usecaches) {
441         delegate.setUseCaches(usecaches);
442     }
443 
444     public boolean getUseCaches() {
445         return delegate.getUseCaches();
446     }
447 
448     public void setIfModifiedSince(long ifmodifiedsince) {
449         delegate.setIfModifiedSince(ifmodifiedsince);
450     }
451 
452     public long getIfModifiedSince() {
453         return delegate.getIfModifiedSince();
454     }
455 
456     public boolean getDefaultUseCaches() {
457         return delegate.getDefaultUseCaches();
458     }
459 
460     public void setDefaultUseCaches(boolean defaultusecaches) {
461         delegate.setDefaultUseCaches(defaultusecaches);
462     }
463 
<a name="8" id="anc8"></a>









464     public boolean equals(Object obj) {
465         return this == obj || ((obj instanceof HttpsURLConnectionImpl) &amp;&amp;
466             delegate.equals(((HttpsURLConnectionImpl)obj).delegate));
467     }
468 
469     public int hashCode() {
470         return delegate.hashCode();
471     }
472 
473     public void setConnectTimeout(int timeout) {
474         delegate.setConnectTimeout(timeout);
475     }
476 
477     public int getConnectTimeout() {
478         return delegate.getConnectTimeout();
479     }
480 
481     public void setReadTimeout(int timeout) {
482         delegate.setReadTimeout(timeout);
483     }
484 
485     public int getReadTimeout() {
486         return delegate.getReadTimeout();
487     }
488 
489     public void setFixedLengthStreamingMode (int contentLength) {
490         delegate.setFixedLengthStreamingMode(contentLength);
491     }
492 
493     public void setFixedLengthStreamingMode(long contentLength) {
494         delegate.setFixedLengthStreamingMode(contentLength);
495     }
496 
497     public void setChunkedStreamingMode (int chunklen) {
498         delegate.setChunkedStreamingMode(chunklen);
499     }
500 
501     @Override
502     public void setAuthenticator(Authenticator auth) {
503         delegate.setAuthenticator(auth);
504     }
505 
506     @Override
507     public Optional&lt;SSLSession&gt; getSSLSession() {
508         return Optional.ofNullable(delegate.getSSLSession());
509     }
510 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
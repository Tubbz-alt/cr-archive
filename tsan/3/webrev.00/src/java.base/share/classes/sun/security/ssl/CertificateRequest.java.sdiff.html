<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertificateMessage.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateStatus.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
313     /**
314      * The &quot;CertificateRequest&quot; handshake message consumer for SSL 3.0 and
315      * TLS 1.0/1.1.
316      */
317     private static final
318             class T10CertificateRequestConsumer implements SSLConsumer {
319         // Prevent instantiation of this class.
320         private T10CertificateRequestConsumer() {
321             // blank
322         }
323 
324         @Override
325         public void consume(ConnectionContext context,
326                 ByteBuffer message) throws IOException {
327             // The consuming happens in client side only.
328             ClientHandshakeContext chc = (ClientHandshakeContext)context;
329 
330             // clean up this consumer
331             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
332 









333             T10CertificateRequestMessage crm =
334                     new T10CertificateRequestMessage(chc, message);
335             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
336                 SSLLogger.fine(
337                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
338             }
339 
340             //
341             // validate
342             //
343             // blank
344 
345             //
346             // update
347             //
348 
349             // An empty client Certificate handshake message may be allow.
350             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
351                     SSLHandshake.CERTIFICATE);
352 
</pre>
<hr />
<pre>
630 
631     /**
632      * The &quot;CertificateRequest&quot; handshake message consumer for TLS 1.2.
633      */
634     private static final
635             class T12CertificateRequestConsumer implements SSLConsumer {
636         // Prevent instantiation of this class.
637         private T12CertificateRequestConsumer() {
638             // blank
639         }
640 
641         @Override
642         public void consume(ConnectionContext context,
643                 ByteBuffer message) throws IOException {
644             // The consuming happens in client side only.
645             ClientHandshakeContext chc = (ClientHandshakeContext)context;
646 
647             // clean up this consumer
648             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
649 









650             T12CertificateRequestMessage crm =
651                     new T12CertificateRequestMessage(chc, message);
652             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
653                 SSLLogger.fine(
654                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
655             }
656 
657             //
658             // validate
659             //
660             // blank
661 
662             //
663             // update
664             //
665 
666             // An empty client Certificate handshake message may be allow.
667             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
668                     SSLHandshake.CERTIFICATE);
669 
</pre>
<hr />
<pre>
701                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
702                     SSLLogger.warning(&quot;No signature and hash algorithms &quot; +
703                             &quot;in CertificateRequest&quot;);
704                 }
705                 return null;
706             }
707 
708             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
709             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
710                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
711                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
712                         SSLLogger.warning(
713                             &quot;Unsupported authentication scheme: &quot; + ss.name);
714                     }
715                     continue;
716                 }
717 
718                 // Don&#39;t select a signature scheme unless we will be able to
719                 // produce a CertificateVerify message later
720                 if (SignatureScheme.getPreferableAlgorithm(

721                         hc.peerRequestedSignatureSchemes,
722                         ss, hc.negotiatedProtocol) == null) {
723 
724                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
725                         SSLLogger.warning(
726                             &quot;Unable to produce CertificateVerify for &quot; +
727                             &quot;signature scheme: &quot; + ss.name);
728                     }
729                     checkedKeyTypes.add(ss.keyAlgorithm);
730                     continue;
731                 }
732 
733                 SSLAuthentication ka = X509Authentication.valueOf(ss);
734                 if (ka == null) {
735                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
736                         SSLLogger.warning(
737                             &quot;Unsupported authentication scheme: &quot; + ss.name);
738                     }
739                     checkedKeyTypes.add(ss.keyAlgorithm);
740                     continue;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
313     /**
314      * The &quot;CertificateRequest&quot; handshake message consumer for SSL 3.0 and
315      * TLS 1.0/1.1.
316      */
317     private static final
318             class T10CertificateRequestConsumer implements SSLConsumer {
319         // Prevent instantiation of this class.
320         private T10CertificateRequestConsumer() {
321             // blank
322         }
323 
324         @Override
325         public void consume(ConnectionContext context,
326                 ByteBuffer message) throws IOException {
327             // The consuming happens in client side only.
328             ClientHandshakeContext chc = (ClientHandshakeContext)context;
329 
330             // clean up this consumer
331             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
332 
<span class="line-added">333             SSLConsumer certStatCons = chc.handshakeConsumers.remove(</span>
<span class="line-added">334                     SSLHandshake.CERTIFICATE_STATUS.id);</span>
<span class="line-added">335             if (certStatCons != null) {</span>
<span class="line-added">336                 // Stapling was active but no certificate status message</span>
<span class="line-added">337                 // was sent.  We need to run the absence handler which will</span>
<span class="line-added">338                 // check the certificate chain.</span>
<span class="line-added">339                 CertificateStatus.handshakeAbsence.absent(context, null);</span>
<span class="line-added">340             }</span>
<span class="line-added">341 </span>
342             T10CertificateRequestMessage crm =
343                     new T10CertificateRequestMessage(chc, message);
344             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
345                 SSLLogger.fine(
346                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
347             }
348 
349             //
350             // validate
351             //
352             // blank
353 
354             //
355             // update
356             //
357 
358             // An empty client Certificate handshake message may be allow.
359             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
360                     SSLHandshake.CERTIFICATE);
361 
</pre>
<hr />
<pre>
639 
640     /**
641      * The &quot;CertificateRequest&quot; handshake message consumer for TLS 1.2.
642      */
643     private static final
644             class T12CertificateRequestConsumer implements SSLConsumer {
645         // Prevent instantiation of this class.
646         private T12CertificateRequestConsumer() {
647             // blank
648         }
649 
650         @Override
651         public void consume(ConnectionContext context,
652                 ByteBuffer message) throws IOException {
653             // The consuming happens in client side only.
654             ClientHandshakeContext chc = (ClientHandshakeContext)context;
655 
656             // clean up this consumer
657             chc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE_REQUEST.id);
658 
<span class="line-added">659             SSLConsumer certStatCons = chc.handshakeConsumers.remove(</span>
<span class="line-added">660                     SSLHandshake.CERTIFICATE_STATUS.id);</span>
<span class="line-added">661             if (certStatCons != null) {</span>
<span class="line-added">662                 // Stapling was active but no certificate status message</span>
<span class="line-added">663                 // was sent.  We need to run the absence handler which will</span>
<span class="line-added">664                 // check the certificate chain.</span>
<span class="line-added">665                 CertificateStatus.handshakeAbsence.absent(context, null);</span>
<span class="line-added">666             }</span>
<span class="line-added">667 </span>
668             T12CertificateRequestMessage crm =
669                     new T12CertificateRequestMessage(chc, message);
670             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
671                 SSLLogger.fine(
672                         &quot;Consuming CertificateRequest handshake message&quot;, crm);
673             }
674 
675             //
676             // validate
677             //
678             // blank
679 
680             //
681             // update
682             //
683 
684             // An empty client Certificate handshake message may be allow.
685             chc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
686                     SSLHandshake.CERTIFICATE);
687 
</pre>
<hr />
<pre>
719                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
720                     SSLLogger.warning(&quot;No signature and hash algorithms &quot; +
721                             &quot;in CertificateRequest&quot;);
722                 }
723                 return null;
724             }
725 
726             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
727             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
728                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
729                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
730                         SSLLogger.warning(
731                             &quot;Unsupported authentication scheme: &quot; + ss.name);
732                     }
733                     continue;
734                 }
735 
736                 // Don&#39;t select a signature scheme unless we will be able to
737                 // produce a CertificateVerify message later
738                 if (SignatureScheme.getPreferableAlgorithm(
<span class="line-added">739                         hc.algorithmConstraints,</span>
740                         hc.peerRequestedSignatureSchemes,
741                         ss, hc.negotiatedProtocol) == null) {
742 
743                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
744                         SSLLogger.warning(
745                             &quot;Unable to produce CertificateVerify for &quot; +
746                             &quot;signature scheme: &quot; + ss.name);
747                     }
748                     checkedKeyTypes.add(ss.keyAlgorithm);
749                     continue;
750                 }
751 
752                 SSLAuthentication ka = X509Authentication.valueOf(ss);
753                 if (ka == null) {
754                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
755                         SSLLogger.warning(
756                             &quot;Unsupported authentication scheme: &quot; + ss.name);
757                     }
758                     checkedKeyTypes.add(ss.keyAlgorithm);
759                     continue;
</pre>
</td>
</tr>
</table>
<center><a href="CertificateMessage.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateStatus.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
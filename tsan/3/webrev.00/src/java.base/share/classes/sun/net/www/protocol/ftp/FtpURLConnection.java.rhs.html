<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/net/www/protocol/ftp/FtpURLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * FTP stream opener.
 28  */
 29 
 30 package sun.net.www.protocol.ftp;
 31 
 32 import java.io.IOException;
 33 import java.io.InputStream;
 34 import java.io.OutputStream;
 35 import java.io.BufferedInputStream;
 36 import java.io.FilterInputStream;
 37 import java.io.FilterOutputStream;
 38 import java.io.FileNotFoundException;
<a name="2" id="anc2"></a><span class="line-added"> 39 import java.net.MalformedURLException;</span>
 40 import java.net.URL;
 41 import java.net.SocketPermission;
 42 import java.net.UnknownHostException;
 43 import java.net.InetSocketAddress;
 44 import java.net.URI;
 45 import java.net.Proxy;
 46 import java.net.ProxySelector;
<a name="3" id="anc3"></a><span class="line-added"> 47 import java.util.List;</span>
 48 import java.util.StringTokenizer;
 49 import java.util.Iterator;
 50 import java.security.Permission;
 51 import java.util.Properties;
 52 import sun.net.NetworkClient;
<a name="4" id="anc4"></a><span class="line-added"> 53 import sun.net.util.IPAddressUtil;</span>
 54 import sun.net.www.MessageHeader;
 55 import sun.net.www.MeteredStream;
 56 import sun.net.www.URLConnection;
 57 import sun.net.www.protocol.http.HttpURLConnection;
 58 import sun.net.ftp.FtpClient;
 59 import sun.net.ftp.FtpProtocolException;
 60 import sun.net.ProgressSource;
 61 import sun.net.ProgressMonitor;
 62 import sun.net.www.ParseUtil;
 63 import sun.security.action.GetPropertyAction;
 64 
 65 
 66 /**
 67  * This class Opens an FTP input (or output) stream given a URL.
 68  * It works as a one shot FTP transfer :
 69  * &lt;UL&gt;
 70  * &lt;LI&gt;Login&lt;/LI&gt;
 71  * &lt;LI&gt;Get (or Put) the file&lt;/LI&gt;
 72  * &lt;LI&gt;Disconnect&lt;/LI&gt;
 73  * &lt;/UL&gt;
 74  * You should not have to use it directly in most cases because all will be handled
 75  * in a abstract layer. Here is an example of how to use the class:
 76  * &lt;pre&gt;{@code
 77  * URL url = new URL(&quot;ftp://ftp.sun.com/pub/test.txt&quot;);
 78  * UrlConnection con = url.openConnection();
 79  * InputStream is = con.getInputStream();
 80  * ...
 81  * is.close();
 82  * }&lt;/pre&gt;
 83  *
 84  * @see sun.net.ftp.FtpClient
 85  */
 86 public class FtpURLConnection extends URLConnection {
 87 
 88     // In case we have to use proxies, we use HttpURLConnection
 89     HttpURLConnection http = null;
 90     private Proxy instProxy;
 91 
 92     InputStream is = null;
 93     OutputStream os = null;
 94 
 95     FtpClient ftp = null;
 96     Permission permission;
 97 
 98     String password;
 99     String user;
100 
101     String host;
102     String pathname;
103     String filename;
104     String fullpath;
105     int port;
106     static final int NONE = 0;
107     static final int ASCII = 1;
108     static final int BIN = 2;
109     static final int DIR = 3;
110     int type = NONE;
111     /* Redefine timeouts from java.net.URLConnection as we need -1 to mean
112      * not set. This is to ensure backward compatibility.
113      */
114     private int connectTimeout = NetworkClient.DEFAULT_CONNECT_TIMEOUT;;
115     private int readTimeout = NetworkClient.DEFAULT_READ_TIMEOUT;;
116 
117     /**
118      * For FTP URLs we need to have a special InputStream because we
119      * need to close 2 sockets after we&#39;re done with it :
120      *  - The Data socket (for the file).
121      *   - The command socket (FtpClient).
122      * Since that&#39;s the only class that needs to see that, it is an inner class.
123      */
124     protected class FtpInputStream extends FilterInputStream {
125         FtpClient ftp;
126         FtpInputStream(FtpClient cl, InputStream fd) {
127             super(new BufferedInputStream(fd));
128             ftp = cl;
129         }
130 
131         @Override
132         public void close() throws IOException {
133             super.close();
134             if (ftp != null) {
135                 ftp.close();
136             }
137         }
138     }
139 
140     /**
141      * For FTP URLs we need to have a special OutputStream because we
142      * need to close 2 sockets after we&#39;re done with it :
143      *  - The Data socket (for the file).
144      *   - The command socket (FtpClient).
145      * Since that&#39;s the only class that needs to see that, it is an inner class.
146      */
147     protected class FtpOutputStream extends FilterOutputStream {
148         FtpClient ftp;
149         FtpOutputStream(FtpClient cl, OutputStream fd) {
150             super(fd);
151             ftp = cl;
152         }
153 
154         @Override
155         public void close() throws IOException {
156             super.close();
157             if (ftp != null) {
158                 ftp.close();
159             }
160         }
161     }
162 
<a name="5" id="anc5"></a><span class="line-added">163     static URL checkURL(URL u) throws IllegalArgumentException {</span>
<span class="line-added">164         if (u != null) {</span>
<span class="line-added">165             if (u.toExternalForm().indexOf(&#39;\n&#39;) &gt; -1) {</span>
<span class="line-added">166                 Exception mfue = new MalformedURLException(&quot;Illegal character in URL&quot;);</span>
<span class="line-added">167                 throw new IllegalArgumentException(mfue.getMessage(), mfue);</span>
<span class="line-added">168             }</span>
<span class="line-added">169         }</span>
<span class="line-added">170         String s = IPAddressUtil.checkAuthority(u);</span>
<span class="line-added">171         if (s != null) {</span>
<span class="line-added">172             Exception mfue = new MalformedURLException(s);</span>
<span class="line-added">173             throw new IllegalArgumentException(mfue.getMessage(), mfue);</span>
<span class="line-added">174         }</span>
<span class="line-added">175         return u;</span>
<span class="line-added">176     }</span>
<span class="line-added">177 </span>
178     /**
179      * Creates an FtpURLConnection from a URL.
180      *
181      * @param   url     The {@code URL} to retrieve or store.
182      */
183     public FtpURLConnection(URL url) {
184         this(url, null);
185     }
186 
187     /**
188      * Same as FtpURLconnection(URL) with a per connection proxy specified
189      */
190     FtpURLConnection(URL url, Proxy p) {
<a name="6" id="anc6"></a><span class="line-modified">191         super(checkURL(url));</span>
192         instProxy = p;
193         host = url.getHost();
194         port = url.getPort();
195         String userInfo = url.getUserInfo();
196 
197         if (userInfo != null) { // get the user and password
198             int delimiter = userInfo.indexOf(&#39;:&#39;);
199             if (delimiter == -1) {
200                 user = ParseUtil.decode(userInfo);
201                 password = null;
202             } else {
203                 user = ParseUtil.decode(userInfo.substring(0, delimiter++));
204                 password = ParseUtil.decode(userInfo.substring(delimiter));
205             }
206         }
207     }
208 
209     private void setTimeouts() {
210         if (ftp != null) {
211             if (connectTimeout &gt;= 0) {
212                 ftp.setConnectTimeout(connectTimeout);
213             }
214             if (readTimeout &gt;= 0) {
215                 ftp.setReadTimeout(readTimeout);
216             }
217         }
218     }
219 
220     /**
221      * Connects to the FTP server and logs in.
222      *
223      * @throws  FtpLoginException if the login is unsuccessful
224      * @throws  FtpProtocolException if an error occurs
225      * @throws  UnknownHostException if trying to connect to an unknown host
226      */
227 
228     public synchronized void connect() throws IOException {
229         if (connected) {
230             return;
231         }
232 
233         Proxy p = null;
234         if (instProxy == null) { // no per connection proxy specified
235             /**
236              * Do we have to use a proxy?
237              */
238             ProxySelector sel = java.security.AccessController.doPrivileged(
239                     new java.security.PrivilegedAction&lt;ProxySelector&gt;() {
240                         public ProxySelector run() {
241                             return ProxySelector.getDefault();
242                         }
243                     });
244             if (sel != null) {
245                 URI uri = sun.net.www.ParseUtil.toURI(url);
<a name="7" id="anc7"></a><span class="line-modified">246                 final List&lt;Proxy&gt; proxies;</span>
<span class="line-added">247                 try {</span>
<span class="line-added">248                     proxies = sel.select(uri);</span>
<span class="line-added">249                 } catch (IllegalArgumentException iae) {</span>
<span class="line-added">250                     throw new IOException(&quot;Failed to select a proxy&quot;, iae);</span>
<span class="line-added">251                 }</span>
<span class="line-added">252                 final Iterator&lt;Proxy&gt; it = proxies.iterator();</span>
253                 while (it.hasNext()) {
254                     p = it.next();
255                     if (p == null || p == Proxy.NO_PROXY ||
256                         p.type() == Proxy.Type.SOCKS) {
257                         break;
258                     }
259                     if (p.type() != Proxy.Type.HTTP ||
260                             !(p.address() instanceof InetSocketAddress)) {
261                         sel.connectFailed(uri, p.address(), new IOException(&quot;Wrong proxy type&quot;));
262                         continue;
263                     }
264                     // OK, we have an http proxy
265                     InetSocketAddress paddr = (InetSocketAddress) p.address();
266                     try {
267                         http = new HttpURLConnection(url, p);
268                         http.setDoInput(getDoInput());
269                         http.setDoOutput(getDoOutput());
270                         if (connectTimeout &gt;= 0) {
271                             http.setConnectTimeout(connectTimeout);
272                         }
273                         if (readTimeout &gt;= 0) {
274                             http.setReadTimeout(readTimeout);
275                         }
276                         http.connect();
277                         connected = true;
278                         return;
279                     } catch (IOException ioe) {
280                         sel.connectFailed(uri, paddr, ioe);
281                         http = null;
282                     }
283                 }
284             }
285         } else { // per connection proxy specified
286             p = instProxy;
287             if (p.type() == Proxy.Type.HTTP) {
288                 http = new HttpURLConnection(url, instProxy);
289                 http.setDoInput(getDoInput());
290                 http.setDoOutput(getDoOutput());
291                 if (connectTimeout &gt;= 0) {
292                     http.setConnectTimeout(connectTimeout);
293                 }
294                 if (readTimeout &gt;= 0) {
295                     http.setReadTimeout(readTimeout);
296                 }
297                 http.connect();
298                 connected = true;
299                 return;
300             }
301         }
302 
303         if (user == null) {
304             user = &quot;anonymous&quot;;
305             Properties props = GetPropertyAction.privilegedGetProperties();
306             String vers = props.getProperty(&quot;java.version&quot;);
307             password = props.getProperty(&quot;ftp.protocol.user&quot;,
308                     &quot;Java&quot; + vers + &quot;@&quot;);
309         }
310         try {
311             ftp = FtpClient.create();
312             if (p != null) {
313                 ftp.setProxy(p);
314             }
315             setTimeouts();
316             if (port != -1) {
317                 ftp.connect(new InetSocketAddress(host, port));
318             } else {
319                 ftp.connect(new InetSocketAddress(host, FtpClient.defaultPort()));
320             }
321         } catch (UnknownHostException e) {
322             // Maybe do something smart here, like use a proxy like iftp.
323             // Just keep throwing for now.
324             throw e;
325         } catch (FtpProtocolException fe) {
326             if (ftp != null) {
327                 try {
328                     ftp.close();
329                 } catch (IOException ioe) {
330                     fe.addSuppressed(ioe);
331                 }
332             }
333             throw new IOException(fe);
334         }
335         try {
336             ftp.login(user, password == null ? null : password.toCharArray());
337         } catch (sun.net.ftp.FtpProtocolException e) {
338             ftp.close();
339             // Backward compatibility
340             throw new sun.net.ftp.FtpLoginException(&quot;Invalid username/password&quot;);
341         }
342         connected = true;
343     }
344 
345 
346     /*
347      * Decodes the path as per the RFC-1738 specifications.
348      */
349     private void decodePath(String path) {
350         int i = path.indexOf(&quot;;type=&quot;);
351         if (i &gt;= 0) {
352             String s1 = path.substring(i + 6, path.length());
353             if (&quot;i&quot;.equalsIgnoreCase(s1)) {
354                 type = BIN;
355             }
356             if (&quot;a&quot;.equalsIgnoreCase(s1)) {
357                 type = ASCII;
358             }
359             if (&quot;d&quot;.equalsIgnoreCase(s1)) {
360                 type = DIR;
361             }
362             path = path.substring(0, i);
363         }
364         if (path != null &amp;&amp; path.length() &gt; 1 &amp;&amp;
365                 path.charAt(0) == &#39;/&#39;) {
366             path = path.substring(1);
367         }
368         if (path == null || path.isEmpty()) {
369             path = &quot;./&quot;;
370         }
371         if (!path.endsWith(&quot;/&quot;)) {
372             i = path.lastIndexOf(&#39;/&#39;);
373             if (i &gt; 0) {
374                 filename = path.substring(i + 1, path.length());
375                 filename = ParseUtil.decode(filename);
376                 pathname = path.substring(0, i);
377             } else {
378                 filename = ParseUtil.decode(path);
379                 pathname = null;
380             }
381         } else {
382             pathname = path.substring(0, path.length() - 1);
383             filename = null;
384         }
385         if (pathname != null) {
386             fullpath = pathname + &quot;/&quot; + (filename != null ? filename : &quot;&quot;);
387         } else {
388             fullpath = filename;
389         }
390     }
391 
392     /*
393      * As part of RFC-1738 it is specified that the path should be
394      * interpreted as a series of FTP CWD commands.
395      * This is because, &#39;/&#39; is not necessarly the directory delimiter
396      * on every systems.
397      */
398     private void cd(String path) throws FtpProtocolException, IOException {
399         if (path == null || path.isEmpty()) {
400             return;
401         }
402         if (path.indexOf(&#39;/&#39;) == -1) {
403             ftp.changeDirectory(ParseUtil.decode(path));
404             return;
405         }
406 
407         StringTokenizer token = new StringTokenizer(path, &quot;/&quot;);
408         while (token.hasMoreTokens()) {
409             ftp.changeDirectory(ParseUtil.decode(token.nextToken()));
410         }
411     }
412 
413     /**
414      * Get the InputStream to retreive the remote file. It will issue the
415      * &quot;get&quot; (or &quot;dir&quot;) command to the ftp server.
416      *
417      * @return  the {@code InputStream} to the connection.
418      *
419      * @throws  IOException if already opened for output
420      * @throws  FtpProtocolException if errors occur during the transfert.
421      */
422     @Override
423     public InputStream getInputStream() throws IOException {
424         if (!connected) {
425             connect();
426         }
427 
428         if (http != null) {
429             return http.getInputStream();
430         }
431 
432         if (os != null) {
433             throw new IOException(&quot;Already opened for output&quot;);
434         }
435 
436         if (is != null) {
437             return is;
438         }
439 
440         MessageHeader msgh = new MessageHeader();
441 
442         boolean isAdir = false;
443         try {
444             decodePath(url.getPath());
445             if (filename == null || type == DIR) {
446                 ftp.setAsciiType();
447                 cd(pathname);
448                 if (filename == null) {
449                     is = new FtpInputStream(ftp, ftp.list(null));
450                 } else {
451                     is = new FtpInputStream(ftp, ftp.nameList(filename));
452                 }
453             } else {
454                 if (type == ASCII) {
455                     ftp.setAsciiType();
456                 } else {
457                     ftp.setBinaryType();
458                 }
459                 cd(pathname);
460                 is = new FtpInputStream(ftp, ftp.getFileStream(filename));
461             }
462 
463             /* Try to get the size of the file in bytes.  If that is
464             successful, then create a MeteredStream. */
465             try {
466                 long l = ftp.getLastTransferSize();
467                 msgh.add(&quot;content-length&quot;, Long.toString(l));
468                 if (l &gt; 0) {
469 
470                     // Wrap input stream with MeteredStream to ensure read() will always return -1
471                     // at expected length.
472 
473                     // Check if URL should be metered
474                     boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, &quot;GET&quot;);
475                     ProgressSource pi = null;
476 
477                     if (meteredInput) {
478                         pi = new ProgressSource(url, &quot;GET&quot;, l);
479                         pi.beginTracking();
480                     }
481 
482                     is = new MeteredStream(is, pi, l);
483                 }
484             } catch (Exception e) {
485                 e.printStackTrace();
486             /* do nothing, since all we were doing was trying to
487             get the size in bytes of the file */
488             }
489 
490             if (isAdir) {
491                 msgh.add(&quot;content-type&quot;, &quot;text/plain&quot;);
492                 msgh.add(&quot;access-type&quot;, &quot;directory&quot;);
493             } else {
494                 msgh.add(&quot;access-type&quot;, &quot;file&quot;);
495                 String ftype = guessContentTypeFromName(fullpath);
496                 if (ftype == null &amp;&amp; is.markSupported()) {
497                     ftype = guessContentTypeFromStream(is);
498                 }
499                 if (ftype != null) {
500                     msgh.add(&quot;content-type&quot;, ftype);
501                 }
502             }
503         } catch (FileNotFoundException e) {
504             try {
505                 cd(fullpath);
506                 /* if that worked, then make a directory listing
507                 and build an html stream with all the files in
508                 the directory */
509                 ftp.setAsciiType();
510 
511                 is = new FtpInputStream(ftp, ftp.list(null));
512                 msgh.add(&quot;content-type&quot;, &quot;text/plain&quot;);
513                 msgh.add(&quot;access-type&quot;, &quot;directory&quot;);
514             } catch (IOException ex) {
515                 FileNotFoundException fnfe = new FileNotFoundException(fullpath);
516                 if (ftp != null) {
517                     try {
518                         ftp.close();
519                     } catch (IOException ioe) {
520                         fnfe.addSuppressed(ioe);
521                     }
522                 }
523                 throw fnfe;
524             } catch (FtpProtocolException ex2) {
525                 FileNotFoundException fnfe = new FileNotFoundException(fullpath);
526                 if (ftp != null) {
527                     try {
528                         ftp.close();
529                     } catch (IOException ioe) {
530                         fnfe.addSuppressed(ioe);
531                     }
532                 }
533                 throw fnfe;
534             }
535         } catch (FtpProtocolException ftpe) {
536             if (ftp != null) {
537                 try {
538                     ftp.close();
539                 } catch (IOException ioe) {
540                     ftpe.addSuppressed(ioe);
541                 }
542             }
543             throw new IOException(ftpe);
544         }
545         setProperties(msgh);
546         return is;
547     }
548 
549     /**
550      * Get the OutputStream to store the remote file. It will issue the
551      * &quot;put&quot; command to the ftp server.
552      *
553      * @return  the {@code OutputStream} to the connection.
554      *
555      * @throws  IOException if already opened for input or the URL
556      *          points to a directory
557      * @throws  FtpProtocolException if errors occur during the transfert.
558      */
559     @Override
560     public OutputStream getOutputStream() throws IOException {
561         if (!connected) {
562             connect();
563         }
564 
565         if (http != null) {
566             OutputStream out = http.getOutputStream();
567             // getInputStream() is neccessary to force a writeRequests()
568             // on the http client.
569             http.getInputStream();
570             return out;
571         }
572 
573         if (is != null) {
574             throw new IOException(&quot;Already opened for input&quot;);
575         }
576 
577         if (os != null) {
578             return os;
579         }
580 
581         decodePath(url.getPath());
582         if (filename == null || filename.isEmpty()) {
583             throw new IOException(&quot;illegal filename for a PUT&quot;);
584         }
585         try {
586             if (pathname != null) {
587                 cd(pathname);
588             }
589             if (type == ASCII) {
590                 ftp.setAsciiType();
591             } else {
592                 ftp.setBinaryType();
593             }
594             os = new FtpOutputStream(ftp, ftp.putFileStream(filename, false));
595         } catch (FtpProtocolException e) {
596             throw new IOException(e);
597         }
598         return os;
599     }
600 
601     String guessContentTypeFromFilename(String fname) {
602         return guessContentTypeFromName(fname);
603     }
604 
605     /**
606      * Gets the {@code Permission} associated with the host and port.
607      *
608      * @return  The {@code Permission} object.
609      */
610     @Override
611     public Permission getPermission() {
612         if (permission == null) {
613             int urlport = url.getPort();
614             urlport = urlport &lt; 0 ? FtpClient.defaultPort() : urlport;
615             String urlhost = this.host + &quot;:&quot; + urlport;
616             permission = new SocketPermission(urlhost, &quot;connect&quot;);
617         }
618         return permission;
619     }
620 
621     /**
622      * Sets the general request property. If a property with the key already
623      * exists, overwrite its value with the new value.
624      *
625      * @param   key     the keyword by which the request is known
626      *                  (e.g., &quot;{@code accept}&quot;).
627      * @param   value   the value associated with it.
628      * @throws IllegalStateException if already connected
629      * @see #getRequestProperty(java.lang.String)
630      */
631     @Override
632     public void setRequestProperty(String key, String value) {
633         super.setRequestProperty(key, value);
634         if (&quot;type&quot;.equals(key)) {
635             if (&quot;i&quot;.equalsIgnoreCase(value)) {
636                 type = BIN;
637             } else if (&quot;a&quot;.equalsIgnoreCase(value)) {
638                 type = ASCII;
639             } else if (&quot;d&quot;.equalsIgnoreCase(value)) {
640                 type = DIR;
641             } else {
642                 throw new IllegalArgumentException(
643                         &quot;Value of &#39;&quot; + key +
644                         &quot;&#39; request property was &#39;&quot; + value +
645                         &quot;&#39; when it must be either &#39;i&#39;, &#39;a&#39; or &#39;d&#39;&quot;);
646             }
647         }
648     }
649 
650     /**
651      * Returns the value of the named general request property for this
652      * connection.
653      *
654      * @param key the keyword by which the request is known (e.g., &quot;accept&quot;).
655      * @return  the value of the named general request property for this
656      *           connection.
657      * @throws IllegalStateException if already connected
658      * @see #setRequestProperty(java.lang.String, java.lang.String)
659      */
660     @Override
661     public String getRequestProperty(String key) {
662         String value = super.getRequestProperty(key);
663 
664         if (value == null) {
665             if (&quot;type&quot;.equals(key)) {
666                 value = (type == ASCII ? &quot;a&quot; : type == DIR ? &quot;d&quot; : &quot;i&quot;);
667             }
668         }
669 
670         return value;
671     }
672 
673     @Override
674     public void setConnectTimeout(int timeout) {
675         if (timeout &lt; 0) {
676             throw new IllegalArgumentException(&quot;timeouts can&#39;t be negative&quot;);
677         }
678         connectTimeout = timeout;
679     }
680 
681     @Override
682     public int getConnectTimeout() {
683         return (connectTimeout &lt; 0 ? 0 : connectTimeout);
684     }
685 
686     @Override
687     public void setReadTimeout(int timeout) {
688         if (timeout &lt; 0) {
689             throw new IllegalArgumentException(&quot;timeouts can&#39;t be negative&quot;);
690         }
691         readTimeout = timeout;
692     }
693 
694     @Override
695     public int getReadTimeout() {
696         return readTimeout &lt; 0 ? 0 : readTimeout;
697     }
698 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
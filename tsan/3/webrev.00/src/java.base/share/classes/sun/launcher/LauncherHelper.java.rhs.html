<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/launcher/LauncherHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.launcher;
  27 
  28 /*
  29  *
  30  *  &lt;p&gt;&lt;b&gt;This is NOT part of any API supported by Sun Microsystems.
  31  *  If you write code that depends on this, you do so at your own
  32  *  risk.  This code and its internal interfaces are subject to change
  33  *  or deletion without notice.&lt;/b&gt;
  34  *
  35  */
  36 
  37 /**
  38  * A utility package for the java(1), javaw(1) launchers.
  39  * The following are helper methods that the native launcher uses
  40  * to perform checks etc. using JNI, see src/share/bin/java.c
  41  */
  42 import java.io.File;
  43 import java.io.IOException;
  44 import java.io.PrintStream;
  45 import java.io.UnsupportedEncodingException;
  46 import java.lang.module.Configuration;
  47 import java.lang.module.ModuleDescriptor;
<a name="2" id="anc2"></a>
  48 import java.lang.module.ModuleDescriptor.Exports;
  49 import java.lang.module.ModuleDescriptor.Opens;
  50 import java.lang.module.ModuleDescriptor.Provides;
<a name="3" id="anc3"></a><span class="line-added">  51 import java.lang.module.ModuleDescriptor.Requires;</span>
  52 import java.lang.module.ModuleFinder;
  53 import java.lang.module.ModuleReference;
  54 import java.lang.module.ResolvedModule;
  55 import java.lang.reflect.InvocationTargetException;
  56 import java.lang.reflect.Method;
  57 import java.lang.reflect.Modifier;
  58 import java.math.BigDecimal;
  59 import java.math.RoundingMode;
  60 import java.net.URI;
  61 import java.nio.charset.Charset;
  62 import java.nio.file.DirectoryStream;
  63 import java.nio.file.Files;
  64 import java.nio.file.Path;
<a name="4" id="anc4"></a>
  65 import java.text.MessageFormat;
<a name="5" id="anc5"></a><span class="line-added">  66 import java.text.Normalizer;</span>
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.Comparator;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Locale;
  73 import java.util.Locale.Category;
  74 import java.util.Optional;
  75 import java.util.Properties;
  76 import java.util.ResourceBundle;
  77 import java.util.Set;
  78 import java.util.TreeSet;
  79 import java.util.jar.Attributes;
  80 import java.util.jar.JarFile;
  81 import java.util.jar.Manifest;
  82 import java.util.stream.Collectors;
  83 import java.util.stream.Stream;
  84 
  85 import jdk.internal.misc.VM;
  86 import jdk.internal.module.ModuleBootstrap;
  87 import jdk.internal.module.Modules;
  88 import jdk.internal.platform.Container;
  89 import jdk.internal.platform.Metrics;
  90 
  91 
  92 public final class LauncherHelper {
  93 
  94     // No instantiation
  95     private LauncherHelper() {}
  96 
  97     // used to identify JavaFX applications
  98     private static final String JAVAFX_APPLICATION_MARKER =
  99             &quot;JavaFX-Application-Class&quot;;
 100     private static final String JAVAFX_APPLICATION_CLASS_NAME =
 101             &quot;javafx.application.Application&quot;;
 102     private static final String JAVAFX_FXHELPER_CLASS_NAME_SUFFIX =
 103             &quot;sun.launcher.LauncherHelper$FXHelper&quot;;
 104     private static final String LAUNCHER_AGENT_CLASS = &quot;Launcher-Agent-Class&quot;;
 105     private static final String MAIN_CLASS = &quot;Main-Class&quot;;
 106     private static final String ADD_EXPORTS = &quot;Add-Exports&quot;;
 107     private static final String ADD_OPENS = &quot;Add-Opens&quot;;
 108 
 109     private static StringBuilder outBuf = new StringBuilder();
 110 
 111     private static final String INDENT = &quot;    &quot;;
 112     private static final String VM_SETTINGS     = &quot;VM settings:&quot;;
 113     private static final String PROP_SETTINGS   = &quot;Property settings:&quot;;
 114     private static final String LOCALE_SETTINGS = &quot;Locale settings:&quot;;
 115 
 116     // sync with java.c and jdk.internal.misc.VM
 117     private static final String diagprop = &quot;sun.java.launcher.diag&quot;;
 118     static final boolean trace = VM.getSavedProperty(diagprop) != null;
 119 
 120     private static final String defaultBundleName =
 121             &quot;sun.launcher.resources.launcher&quot;;
<a name="6" id="anc6"></a><span class="line-added"> 122 </span>
 123     private static class ResourceBundleHolder {
 124         private static final ResourceBundle RB =
 125                 ResourceBundle.getBundle(defaultBundleName);
 126     }
 127     private static PrintStream ostream;
 128     private static Class&lt;?&gt; appClass; // application class, for GUI/reporting purposes
 129 
 130     /*
 131      * A method called by the launcher to print out the standard settings,
 132      * by default -XshowSettings is equivalent to -XshowSettings:all,
 133      * Specific information may be gotten by using suboptions with possible
 134      * values vm, properties and locale.
 135      *
 136      * printToStderr: choose between stdout and stderr
 137      *
 138      * optionFlag: specifies which options to print default is all other
 139      *    possible values are vm, properties, locale.
 140      *
 141      * initialHeapSize: in bytes, as set by the launcher, a zero-value indicates
 142      *    this code should determine this value, using a suitable method or
 143      *    the line could be omitted.
 144      *
 145      * maxHeapSize: in bytes, as set by the launcher, a zero-value indicates
 146      *    this code should determine this value, using a suitable method.
 147      *
 148      * stackSize: in bytes, as set by the launcher, a zero-value indicates
 149      *    this code determine this value, using a suitable method or omit the
 150      *    line entirely.
 151      */
 152     @SuppressWarnings(&quot;fallthrough&quot;)
 153     static void showSettings(boolean printToStderr, String optionFlag,
 154             long initialHeapSize, long maxHeapSize, long stackSize) {
 155 
 156         initOutput(printToStderr);
 157         String opts[] = optionFlag.split(&quot;:&quot;);
 158         String optStr = (opts.length &gt; 1 &amp;&amp; opts[1] != null)
 159                 ? opts[1].trim()
 160                 : &quot;all&quot;;
 161         switch (optStr) {
 162             case &quot;vm&quot;:
 163                 printVmSettings(initialHeapSize, maxHeapSize, stackSize);
 164                 break;
 165             case &quot;properties&quot;:
 166                 printProperties();
 167                 break;
 168             case &quot;locale&quot;:
 169                 printLocale();
 170                 break;
 171             case &quot;system&quot;:
 172                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {
 173                     printSystemMetrics();
 174                     break;
 175                 }
 176             default:
 177                 printVmSettings(initialHeapSize, maxHeapSize, stackSize);
 178                 printProperties();
 179                 printLocale();
 180                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {
 181                     printSystemMetrics();
 182                 }
 183                 break;
 184         }
 185     }
 186 
 187     /*
 188      * prints the main vm settings subopt/section
 189      */
 190     private static void printVmSettings(
 191             long initialHeapSize, long maxHeapSize,
 192             long stackSize) {
 193 
 194         ostream.println(VM_SETTINGS);
 195         if (stackSize != 0L) {
 196             ostream.println(INDENT + &quot;Stack Size: &quot; +
 197                     SizePrefix.scaleValue(stackSize));
 198         }
 199         if (initialHeapSize != 0L) {
 200              ostream.println(INDENT + &quot;Min. Heap Size: &quot; +
 201                     SizePrefix.scaleValue(initialHeapSize));
 202         }
 203         if (maxHeapSize != 0L) {
 204             ostream.println(INDENT + &quot;Max. Heap Size: &quot; +
 205                     SizePrefix.scaleValue(maxHeapSize));
 206         } else {
 207             ostream.println(INDENT + &quot;Max. Heap Size (Estimated): &quot;
 208                     + SizePrefix.scaleValue(Runtime.getRuntime().maxMemory()));
 209         }
 210         ostream.println(INDENT + &quot;Using VM: &quot;
 211                 + System.getProperty(&quot;java.vm.name&quot;));
 212         ostream.println();
 213     }
 214 
 215     /*
 216      * prints the properties subopt/section
 217      */
 218     private static void printProperties() {
 219         Properties p = System.getProperties();
 220         ostream.println(PROP_SETTINGS);
 221         List&lt;String&gt; sortedPropertyKeys = new ArrayList&lt;&gt;();
 222         sortedPropertyKeys.addAll(p.stringPropertyNames());
 223         Collections.sort(sortedPropertyKeys);
 224         for (String x : sortedPropertyKeys) {
 225             printPropertyValue(x, p.getProperty(x));
 226         }
 227         ostream.println();
 228     }
 229 
 230     private static boolean isPath(String key) {
 231         return key.endsWith(&quot;.dirs&quot;) || key.endsWith(&quot;.path&quot;);
 232     }
 233 
 234     private static void printPropertyValue(String key, String value) {
 235         ostream.print(INDENT + key + &quot; = &quot;);
 236         if (key.equals(&quot;line.separator&quot;)) {
 237             for (byte b : value.getBytes()) {
 238                 switch (b) {
 239                     case 0xd:
 240                         ostream.print(&quot;\\r &quot;);
 241                         break;
 242                     case 0xa:
 243                         ostream.print(&quot;\\n &quot;);
 244                         break;
 245                     default:
 246                         // print any bizzare line separators in hex, but really
 247                         // shouldn&#39;t happen.
 248                         ostream.printf(&quot;0x%02X&quot;, b &amp; 0xff);
 249                         break;
 250                 }
 251             }
 252             ostream.println();
 253             return;
 254         }
 255         if (!isPath(key)) {
 256             ostream.println(value);
 257             return;
 258         }
 259         String[] values = value.split(System.getProperty(&quot;path.separator&quot;));
 260         boolean first = true;
 261         for (String s : values) {
 262             if (first) { // first line treated specially
 263                 ostream.println(s);
 264                 first = false;
 265             } else { // following lines prefix with indents
 266                 ostream.println(INDENT + INDENT + s);
 267             }
 268         }
 269     }
 270 
 271     /*
 272      * prints the locale subopt/section
 273      */
 274     private static void printLocale() {
 275         Locale locale = Locale.getDefault();
 276         ostream.println(LOCALE_SETTINGS);
 277         ostream.println(INDENT + &quot;default locale = &quot; +
 278                 locale.getDisplayName());
 279         ostream.println(INDENT + &quot;default display locale = &quot; +
 280                 Locale.getDefault(Category.DISPLAY).getDisplayName());
 281         ostream.println(INDENT + &quot;default format locale = &quot; +
 282                 Locale.getDefault(Category.FORMAT).getDisplayName());
 283         printLocales();
 284         ostream.println();
 285     }
 286 
 287     private static void printLocales() {
 288         Locale[] tlocales = Locale.getAvailableLocales();
 289         final int len = tlocales == null ? 0 : tlocales.length;
 290         if (len &lt; 1 ) {
 291             return;
 292         }
 293         // Locale does not implement Comparable so we convert it to String
 294         // and sort it for pretty printing.
 295         Set&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();
 296         for (Locale l : tlocales) {
 297             sortedSet.add(l.toString());
 298         }
 299 
 300         ostream.print(INDENT + &quot;available locales = &quot;);
 301         Iterator&lt;String&gt; iter = sortedSet.iterator();
 302         final int last = len - 1;
 303         for (int i = 0 ; iter.hasNext() ; i++) {
 304             String s = iter.next();
 305             ostream.print(s);
 306             if (i != last) {
 307                 ostream.print(&quot;, &quot;);
 308             }
 309             // print columns of 8
 310             if ((i + 1) % 8 == 0) {
 311                 ostream.println();
 312                 ostream.print(INDENT + INDENT);
 313             }
 314         }
 315     }
 316 
 317     public static void printSystemMetrics() {
 318         Metrics c = Container.metrics();
 319 
 320         ostream.println(&quot;Operating System Metrics:&quot;);
 321 
 322         if (c == null) {
 323             ostream.println(INDENT + &quot;No metrics available for this platform&quot;);
 324             return;
 325         }
 326 
<a name="7" id="anc7"></a><span class="line-added"> 327         final long longRetvalNotSupported = -2;</span>
<span class="line-added"> 328 </span>
 329         ostream.println(INDENT + &quot;Provider: &quot; + c.getProvider());
 330         ostream.println(INDENT + &quot;Effective CPU Count: &quot; + c.getEffectiveCpuCount());
<a name="8" id="anc8"></a><span class="line-modified"> 331         ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + &quot;CPU Period: &quot;, longRetvalNotSupported));</span>
<span class="line-modified"> 332         ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + &quot;CPU Quota: &quot;, longRetvalNotSupported));</span>
<span class="line-modified"> 333         ostream.println(formatCpuVal(c.getCpuShares(), INDENT + &quot;CPU Shares: &quot;, longRetvalNotSupported));</span>


 334 
 335         int cpus[] = c.getCpuSetCpus();
<a name="9" id="anc9"></a><span class="line-modified"> 336         if (cpus != null) {</span>
<span class="line-modified"> 337             ostream.println(INDENT + &quot;List of Processors, &quot;</span>
<span class="line-added"> 338                     + cpus.length + &quot; total: &quot;);</span>
 339 
<a name="10" id="anc10"></a><span class="line-modified"> 340             ostream.print(INDENT);</span>
<span class="line-modified"> 341             for (int i = 0; i &lt; cpus.length; i++) {</span>
<span class="line-modified"> 342                 ostream.print(cpus[i] + &quot; &quot;);</span>
<span class="line-modified"> 343             }</span>
<span class="line-modified"> 344             if (cpus.length &gt; 0) {</span>
<span class="line-modified"> 345                 ostream.println(&quot;&quot;);</span>
<span class="line-added"> 346             }</span>
<span class="line-added"> 347         } else {</span>
<span class="line-added"> 348             ostream.println(INDENT + &quot;List of Processors: N/A&quot;);</span>
 349         }
 350 
 351         cpus = c.getEffectiveCpuSetCpus();
<a name="11" id="anc11"></a><span class="line-modified"> 352         if (cpus != null) {</span>
<span class="line-modified"> 353             ostream.println(INDENT + &quot;List of Effective Processors, &quot;</span>
<span class="line-added"> 354                     + cpus.length + &quot; total: &quot;);</span>
 355 
<a name="12" id="anc12"></a><span class="line-modified"> 356             ostream.print(INDENT);</span>
<span class="line-modified"> 357             for (int i = 0; i &lt; cpus.length; i++) {</span>
<span class="line-modified"> 358                 ostream.print(cpus[i] + &quot; &quot;);</span>
<span class="line-modified"> 359             }</span>
<span class="line-modified"> 360             if (cpus.length &gt; 0) {</span>
<span class="line-modified"> 361                 ostream.println(&quot;&quot;);</span>
<span class="line-added"> 362             }</span>
<span class="line-added"> 363         } else {</span>
<span class="line-added"> 364             ostream.println(INDENT + &quot;List of Effective Processors: N/A&quot;);</span>
 365         }
 366 
 367         int mems[] = c.getCpuSetMems();
<a name="13" id="anc13"></a><span class="line-modified"> 368         if (mems != null) {</span>
<span class="line-modified"> 369             ostream.println(INDENT + &quot;List of Memory Nodes, &quot;</span>
<span class="line-added"> 370                     + mems.length + &quot; total: &quot;);</span>
 371 
<a name="14" id="anc14"></a><span class="line-modified"> 372             ostream.print(INDENT);</span>
<span class="line-modified"> 373             for (int i = 0; i &lt; mems.length; i++) {</span>
<span class="line-modified"> 374                 ostream.print(mems[i] + &quot; &quot;);</span>
<span class="line-modified"> 375             }</span>
<span class="line-modified"> 376             if (mems.length &gt; 0) {</span>
<span class="line-modified"> 377                 ostream.println(&quot;&quot;);</span>
<span class="line-added"> 378             }</span>
<span class="line-added"> 379         } else {</span>
<span class="line-added"> 380             ostream.println(INDENT + &quot;List of Memory Nodes: N/A&quot;);</span>
 381         }
 382 
 383         mems = c.getEffectiveCpuSetMems();
<a name="15" id="anc15"></a><span class="line-modified"> 384         if (mems != null) {</span>
<span class="line-modified"> 385             ostream.println(INDENT + &quot;List of Available Memory Nodes, &quot;</span>
<span class="line-added"> 386                     + mems.length + &quot; total: &quot;);</span>
 387 
<a name="16" id="anc16"></a><span class="line-modified"> 388             ostream.print(INDENT);</span>
<span class="line-modified"> 389             for (int i = 0; i &lt; mems.length; i++) {</span>
<span class="line-modified"> 390                 ostream.print(mems[i] + &quot; &quot;);</span>
<span class="line-modified"> 391             }</span>
<span class="line-modified"> 392             if (mems.length &gt; 0) {</span>
<span class="line-modified"> 393                 ostream.println(&quot;&quot;);</span>
<span class="line-added"> 394             }</span>
<span class="line-added"> 395         } else {</span>
<span class="line-added"> 396             ostream.println(INDENT + &quot;List of Available Memory Nodes: N/A&quot;);</span>
 397         }
 398 
<a name="17" id="anc17"></a>


 399         long limit = c.getMemoryLimit();
<a name="18" id="anc18"></a><span class="line-modified"> 400         ostream.println(formatLimitString(limit, INDENT + &quot;Memory Limit: &quot;, longRetvalNotSupported));</span>

 401 
 402         limit = c.getMemorySoftLimit();
<a name="19" id="anc19"></a><span class="line-modified"> 403         ostream.println(formatLimitString(limit, INDENT + &quot;Memory Soft Limit: &quot;, longRetvalNotSupported));</span>

 404 
 405         limit = c.getMemoryAndSwapLimit();
<a name="20" id="anc20"></a><span class="line-modified"> 406         ostream.println(formatLimitString(limit, INDENT + &quot;Memory &amp; Swap Limit: &quot;, longRetvalNotSupported));</span>





 407 
<a name="21" id="anc21"></a><span class="line-modified"> 408         ostream.println(&quot;&quot;);</span>
<span class="line-modified"> 409     }</span>

 410 
<a name="22" id="anc22"></a><span class="line-modified"> 411     private static String formatLimitString(long limit, String prefix, long unavailable) {</span>
<span class="line-modified"> 412         if (limit &gt;= 0) {</span>
<span class="line-added"> 413             return prefix + SizePrefix.scaleValue(limit);</span>
<span class="line-added"> 414         } else if (limit == unavailable) {</span>
<span class="line-added"> 415             return prefix + &quot;N/A&quot;;</span>
<span class="line-added"> 416         } else {</span>
<span class="line-added"> 417             return prefix + &quot;Unlimited&quot;;</span>
<span class="line-added"> 418         }</span>
<span class="line-added"> 419     }</span>
 420 
<a name="23" id="anc23"></a><span class="line-modified"> 421     private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {</span>
<span class="line-added"> 422         if (cpuVal &gt;= 0) {</span>
<span class="line-added"> 423             return prefix + cpuVal + &quot;us&quot;;</span>
<span class="line-added"> 424         } else if (cpuVal == unavailable) {</span>
<span class="line-added"> 425             return prefix + &quot;N/A&quot;;</span>
<span class="line-added"> 426         } else {</span>
<span class="line-added"> 427             return prefix + cpuVal;</span>
<span class="line-added"> 428         }</span>
 429     }
 430 
 431     private enum SizePrefix {
 432 
 433         KILO(1024, &quot;K&quot;),
 434         MEGA(1024 * 1024, &quot;M&quot;),
 435         GIGA(1024 * 1024 * 1024, &quot;G&quot;),
 436         TERA(1024L * 1024L * 1024L * 1024L, &quot;T&quot;);
 437         long size;
 438         String abbrev;
 439 
 440         SizePrefix(long size, String abbrev) {
 441             this.size = size;
 442             this.abbrev = abbrev;
 443         }
 444 
 445         private static String scale(long v, SizePrefix prefix) {
 446             return BigDecimal.valueOf(v).divide(BigDecimal.valueOf(prefix.size),
 447                     2, RoundingMode.HALF_EVEN).toPlainString() + prefix.abbrev;
 448         }
 449         /*
 450          * scale the incoming values to a human readable form, represented as
 451          * K, M, G and T, see java.c parse_size for the scaled values and
 452          * suffixes. The lowest possible scaled value is Kilo.
 453          */
 454         static String scaleValue(long v) {
 455             if (v &lt; MEGA.size) {
 456                 return scale(v, KILO);
 457             } else if (v &lt; GIGA.size) {
 458                 return scale(v, MEGA);
 459             } else if (v &lt; TERA.size) {
 460                 return scale(v, GIGA);
 461             } else {
 462                 return scale(v, TERA);
 463             }
 464         }
 465     }
 466 
 467     /**
 468      * A private helper method to get a localized message and also
 469      * apply any arguments that we might pass.
 470      */
 471     private static String getLocalizedMessage(String key, Object... args) {
 472         String msg = ResourceBundleHolder.RB.getString(key);
 473         return (args != null) ? MessageFormat.format(msg, args) : msg;
 474     }
 475 
 476     /**
 477      * The java -help message is split into 3 parts, an invariant, followed
 478      * by a set of platform dependent variant messages, finally an invariant
 479      * set of lines.
 480      * This method initializes the help message for the first time, and also
 481      * assembles the invariant header part of the message.
 482      */
 483     static void initHelpMessage(String progname) {
 484         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.header&quot;,
 485                 (progname == null) ? &quot;java&quot; : progname ));
 486     }
 487 
 488     /**
 489      * Appends the vm selection messages to the header, already created.
 490      * initHelpSystem must already be called.
 491      */
 492     static void appendVmSelectMessage(String vm1, String vm2) {
 493         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.vmselect&quot;,
 494                 vm1, vm2));
 495     }
 496 
 497     /**
 498      * Appends the vm synoym message to the header, already created.
 499      * initHelpSystem must be called before using this method.
 500      */
 501     static void appendVmSynonymMessage(String vm1, String vm2) {
 502         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.hotspot&quot;,
 503                 vm1, vm2));
 504     }
 505 
 506     /**
 507      * Appends the last invariant part to the previously created messages,
 508      * and finishes up the printing to the desired output stream.
 509      * initHelpSystem must be called before using this method.
 510      */
 511     static void printHelpMessage(boolean printToStderr) {
 512         initOutput(printToStderr);
 513         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.footer&quot;,
 514                 File.pathSeparator));
 515         ostream.println(outBuf.toString());
 516     }
 517 
 518     /**
 519      * Prints the Xusage text to the desired output stream.
 520      */
 521     static void printXUsageMessage(boolean printToStderr) {
 522         initOutput(printToStderr);
 523         ostream.println(getLocalizedMessage(&quot;java.launcher.X.usage&quot;,
 524                 File.pathSeparator));
 525         if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {
 526             ostream.println(getLocalizedMessage(&quot;java.launcher.X.macosx.usage&quot;,
 527                         File.pathSeparator));
 528         }
 529     }
 530 
 531     static void initOutput(boolean printToStderr) {
 532         ostream =  (printToStderr) ? System.err : System.out;
 533     }
 534 
 535     static void initOutput(PrintStream ps) {
 536         ostream = ps;
 537     }
 538 
 539     static String getMainClassFromJar(String jarname) {
 540         String mainValue;
 541         try (JarFile jarFile = new JarFile(jarname)) {
 542             Manifest manifest = jarFile.getManifest();
 543             if (manifest == null) {
 544                 abort(null, &quot;java.launcher.jar.error2&quot;, jarname);
 545             }
 546             Attributes mainAttrs = manifest.getMainAttributes();
 547             if (mainAttrs == null) {
 548                 abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
 549             }
 550 
 551             // Main-Class
 552             mainValue = mainAttrs.getValue(MAIN_CLASS);
 553             if (mainValue == null) {
 554                 abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
 555             }
 556 
 557             // Launcher-Agent-Class (only check for this when Main-Class present)
 558             String agentClass = mainAttrs.getValue(LAUNCHER_AGENT_CLASS);
 559             if (agentClass != null) {
 560                 ModuleLayer.boot().findModule(&quot;java.instrument&quot;).ifPresent(m -&gt; {
 561                     try {
 562                         String cn = &quot;sun.instrument.InstrumentationImpl&quot;;
 563                         Class&lt;?&gt; clazz = Class.forName(cn, false, null);
 564                         Method loadAgent = clazz.getMethod(&quot;loadAgent&quot;, String.class);
 565                         loadAgent.invoke(null, jarname);
 566                     } catch (Throwable e) {
 567                         if (e instanceof InvocationTargetException) e = e.getCause();
 568                         abort(e, &quot;java.launcher.jar.error4&quot;, jarname);
 569                     }
 570                 });
 571             }
 572 
 573             // Add-Exports and Add-Opens
 574             String exports = mainAttrs.getValue(ADD_EXPORTS);
 575             if (exports != null) {
 576                 addExportsOrOpens(exports, false);
 577             }
 578             String opens = mainAttrs.getValue(ADD_OPENS);
 579             if (opens != null) {
 580                 addExportsOrOpens(opens, true);
 581             }
 582 
 583             /*
 584              * Hand off to FXHelper if it detects a JavaFX application
 585              * This must be done after ensuring a Main-Class entry
 586              * exists to enforce compliance with the jar specification
 587              */
 588             if (mainAttrs.containsKey(
 589                     new Attributes.Name(JAVAFX_APPLICATION_MARKER))) {
 590                 FXHelper.setFXLaunchParameters(jarname, LM_JAR);
 591                 return FXHelper.class.getName();
 592             }
 593 
 594             return mainValue.trim();
 595         } catch (IOException ioe) {
 596             abort(ioe, &quot;java.launcher.jar.error1&quot;, jarname);
 597         }
 598         return null;
 599     }
 600 
 601     /**
 602      * Process the Add-Exports or Add-Opens value. The value is
 603      * {@code &lt;module&gt;/&lt;package&gt; ( &lt;module&gt;/&lt;package&gt;)*}.
 604      */
 605     static void addExportsOrOpens(String value, boolean open) {
 606         for (String moduleAndPackage : value.split(&quot; &quot;)) {
 607             String[] s = moduleAndPackage.trim().split(&quot;/&quot;);
 608             if (s.length == 2) {
 609                 String mn = s[0];
 610                 String pn = s[1];
 611                 ModuleLayer.boot()
 612                     .findModule(mn)
 613                     .filter(m -&gt; m.getDescriptor().packages().contains(pn))
 614                     .ifPresent(m -&gt; {
 615                         if (open) {
 616                             Modules.addOpensToAllUnnamed(m, pn);
 617                         } else {
 618                             Modules.addExportsToAllUnnamed(m, pn);
 619                         }
 620                     });
 621             }
 622         }
 623     }
 624 
 625     // From src/share/bin/java.c:
 626     //   enum LaunchMode { LM_UNKNOWN = 0, LM_CLASS, LM_JAR, LM_MODULE, LM_SOURCE }
 627 
 628     private static final int LM_UNKNOWN = 0;
 629     private static final int LM_CLASS   = 1;
 630     private static final int LM_JAR     = 2;
 631     private static final int LM_MODULE  = 3;
 632     private static final int LM_SOURCE  = 4;
 633 
 634     static void abort(Throwable t, String msgKey, Object... args) {
 635         if (msgKey != null) {
 636             ostream.println(getLocalizedMessage(msgKey, args));
 637         }
 638         if (trace) {
 639             if (t != null) {
 640                 t.printStackTrace();
 641             } else {
 642                 Thread.dumpStack();
 643             }
 644         }
 645         System.exit(1);
 646     }
 647 
 648     /**
 649      * This method:
 650      * 1. Loads the main class from the module or class path
 651      * 2. Checks the public static void main method.
 652      * 3. If the main class extends FX Application then call on FXHelper to
 653      * perform the launch.
 654      *
 655      * @param printToStderr if set, all output will be routed to stderr
 656      * @param mode LaunchMode as determined by the arguments passed on the
 657      *             command line
 658      * @param what the module name[/class], JAR file, or the main class
 659      *             depending on the mode
 660      *
 661      * @return the application&#39;s main class
 662      */
 663     @SuppressWarnings(&quot;fallthrough&quot;)
 664     public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr,
 665                                             int mode,
 666                                             String what) {
 667         initOutput(printToStderr);
 668 
 669         Class&lt;?&gt; mainClass = null;
 670         switch (mode) {
 671             case LM_MODULE: case LM_SOURCE:
 672                 mainClass = loadModuleMainClass(what);
 673                 break;
 674             default:
 675                 mainClass = loadMainClass(mode, what);
 676                 break;
 677         }
 678 
 679         // record the real main class for UI purposes
 680         // neither method above can return null, they will abort()
 681         appClass = mainClass;
 682 
 683         /*
 684          * Check if FXHelper can launch it using the FX launcher. In an FX app,
 685          * the main class may or may not have a main method, so do this before
 686          * validating the main class.
 687          */
 688         if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainClass.getName()) ||
 689             doesExtendFXApplication(mainClass)) {
 690             // Will abort() if there are problems with FX runtime
 691             FXHelper.setFXLaunchParameters(what, mode);
 692             mainClass = FXHelper.class;
 693         }
 694 
 695         validateMainClass(mainClass);
 696         return mainClass;
 697     }
 698 
 699     /**
 700      * Returns the main class for a module. The query is either a module name
 701      * or module-name/main-class. For the former then the module&#39;s main class
 702      * is obtained from the module descriptor (MainClass attribute).
 703      */
 704     private static Class&lt;?&gt; loadModuleMainClass(String what) {
 705         int i = what.indexOf(&#39;/&#39;);
 706         String mainModule;
 707         String mainClass;
 708         if (i == -1) {
 709             mainModule = what;
 710             mainClass = null;
 711         } else {
 712             mainModule = what.substring(0, i);
 713             mainClass = what.substring(i+1);
 714         }
 715 
 716         // main module is in the boot layer
 717         ModuleLayer layer = ModuleLayer.boot();
 718         Optional&lt;Module&gt; om = layer.findModule(mainModule);
 719         if (!om.isPresent()) {
 720             // should not happen
 721             throw new InternalError(&quot;Module &quot; + mainModule + &quot; not in boot Layer&quot;);
 722         }
 723         Module m = om.get();
 724 
 725         // get main class
 726         if (mainClass == null) {
 727             Optional&lt;String&gt; omc = m.getDescriptor().mainClass();
 728             if (!omc.isPresent()) {
 729                 abort(null, &quot;java.launcher.module.error1&quot;, mainModule);
 730             }
 731             mainClass = omc.get();
 732         }
 733 
 734         // load the class from the module
 735         Class&lt;?&gt; c = null;
 736         try {
 737             c = Class.forName(m, mainClass);
 738             if (c == null &amp;&amp; System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
 739                     &amp;&amp; Normalizer.isNormalized(mainClass, Normalizer.Form.NFD)) {
 740 
 741                 String cn = Normalizer.normalize(mainClass, Normalizer.Form.NFC);
 742                 c = Class.forName(m, cn);
 743             }
 744         } catch (LinkageError le) {
 745             abort(null, &quot;java.launcher.module.error3&quot;, mainClass, m.getName(),
 746                     le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
 747         }
 748         if (c == null) {
 749             abort(null, &quot;java.launcher.module.error2&quot;, mainClass, mainModule);
 750         }
 751 
 752         System.setProperty(&quot;jdk.module.main.class&quot;, c.getName());
 753         return c;
 754     }
 755 
 756     /**
 757      * Loads the main class from the class path (LM_CLASS or LM_JAR).
 758      */
 759     private static Class&lt;?&gt; loadMainClass(int mode, String what) {
 760         // get the class name
 761         String cn;
 762         switch (mode) {
 763             case LM_CLASS:
 764                 cn = what;
 765                 break;
 766             case LM_JAR:
 767                 cn = getMainClassFromJar(what);
 768                 break;
 769             default:
 770                 // should never happen
 771                 throw new InternalError(&quot;&quot; + mode + &quot;: Unknown launch mode&quot;);
 772         }
 773 
 774         // load the main class
 775         cn = cn.replace(&#39;/&#39;, &#39;.&#39;);
 776         Class&lt;?&gt; mainClass = null;
 777         ClassLoader scl = ClassLoader.getSystemClassLoader();
 778         try {
 779             try {
 780                 mainClass = Class.forName(cn, false, scl);
 781             } catch (NoClassDefFoundError | ClassNotFoundException cnfe) {
 782                 if (System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
 783                         &amp;&amp; Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {
 784                     try {
 785                         // On Mac OS X since all names with diacritical marks are
 786                         // given as decomposed it is possible that main class name
 787                         // comes incorrectly from the command line and we have
 788                         // to re-compose it
 789                         String ncn = Normalizer.normalize(cn, Normalizer.Form.NFC);
 790                         mainClass = Class.forName(ncn, false, scl);
 791                     } catch (NoClassDefFoundError | ClassNotFoundException cnfe1) {
 792                         abort(cnfe1, &quot;java.launcher.cls.error1&quot;, cn,
 793                                 cnfe1.getClass().getCanonicalName(), cnfe1.getMessage());
 794                     }
 795                 } else {
 796                     abort(cnfe, &quot;java.launcher.cls.error1&quot;, cn,
 797                             cnfe.getClass().getCanonicalName(), cnfe.getMessage());
 798                 }
 799             }
 800         } catch (LinkageError le) {
 801             abort(le, &quot;java.launcher.cls.error6&quot;, cn,
 802                     le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
 803         }
 804         return mainClass;
 805     }
 806 
 807     /*
 808      * Accessor method called by the launcher after getting the main class via
 809      * checkAndLoadMain(). The &quot;application class&quot; is the class that is finally
 810      * executed to start the application and in this case is used to report
 811      * the correct application name, typically for UI purposes.
 812      */
 813     public static Class&lt;?&gt; getApplicationClass() {
 814         return appClass;
 815     }
 816 
 817     /*
 818      * Check if the given class is a JavaFX Application class. This is done
 819      * in a way that does not cause the Application class to load or throw
 820      * ClassNotFoundException if the JavaFX runtime is not available.
 821      */
 822     private static boolean doesExtendFXApplication(Class&lt;?&gt; mainClass) {
 823         for (Class&lt;?&gt; sc = mainClass.getSuperclass(); sc != null;
 824                 sc = sc.getSuperclass()) {
 825             if (sc.getName().equals(JAVAFX_APPLICATION_CLASS_NAME)) {
 826                 return true;
 827             }
 828         }
 829         return false;
 830     }
 831 
 832     // Check the existence and signature of main and abort if incorrect
 833     static void validateMainClass(Class&lt;?&gt; mainClass) {
 834         Method mainMethod = null;
 835         try {
 836             mainMethod = mainClass.getMethod(&quot;main&quot;, String[].class);
 837         } catch (NoSuchMethodException nsme) {
 838             // invalid main or not FX application, abort with an error
 839             abort(null, &quot;java.launcher.cls.error4&quot;, mainClass.getName(),
 840                   JAVAFX_APPLICATION_CLASS_NAME);
 841         } catch (Throwable e) {
 842             if (mainClass.getModule().isNamed()) {
 843                 abort(e, &quot;java.launcher.module.error5&quot;,
<a name="24" id="anc24"></a><span class="line-modified"> 844                       mainClass.getName(), mainClass.getModule().getName(),</span>
 845                       e.getClass().getName(), e.getLocalizedMessage());
 846             } else {
 847                 abort(e, &quot;java.launcher.cls.error7&quot;, mainClass.getName(),
 848                       e.getClass().getName(), e.getLocalizedMessage());
 849             }
 850         }
 851 
 852         /*
 853          * getMethod (above) will choose the correct method, based
 854          * on its name and parameter type, however, we still have to
 855          * ensure that the method is static and returns a void.
 856          */
 857         int mod = mainMethod.getModifiers();
 858         if (!Modifier.isStatic(mod)) {
 859             abort(null, &quot;java.launcher.cls.error2&quot;, &quot;static&quot;,
 860                   mainMethod.getDeclaringClass().getName());
 861         }
 862         if (mainMethod.getReturnType() != java.lang.Void.TYPE) {
 863             abort(null, &quot;java.launcher.cls.error3&quot;,
 864                   mainMethod.getDeclaringClass().getName());
 865         }
 866     }
 867 
 868     private static final String encprop = &quot;sun.jnu.encoding&quot;;
 869     private static String encoding = null;
 870     private static boolean isCharsetSupported = false;
 871 
 872     /*
 873      * converts a c or a byte array to a platform specific string,
 874      * previously implemented as a native method in the launcher.
 875      */
 876     static String makePlatformString(boolean printToStderr, byte[] inArray) {
 877         initOutput(printToStderr);
 878         if (encoding == null) {
 879             encoding = System.getProperty(encprop);
 880             isCharsetSupported = Charset.isSupported(encoding);
 881         }
 882         try {
 883             String out = isCharsetSupported
 884                     ? new String(inArray, encoding)
 885                     : new String(inArray);
 886             return out;
 887         } catch (UnsupportedEncodingException uee) {
 888             abort(uee, null);
 889         }
 890         return null; // keep the compiler happy
 891     }
 892 
 893     static String[] expandArgs(String[] argArray) {
 894         List&lt;StdArg&gt; aList = new ArrayList&lt;&gt;();
 895         for (String x : argArray) {
 896             aList.add(new StdArg(x));
 897         }
 898         return expandArgs(aList);
 899     }
 900 
 901     static String[] expandArgs(List&lt;StdArg&gt; argList) {
 902         ArrayList&lt;String&gt; out = new ArrayList&lt;&gt;();
 903         if (trace) {
 904             System.err.println(&quot;Incoming arguments:&quot;);
 905         }
 906         for (StdArg a : argList) {
 907             if (trace) {
 908                 System.err.println(a);
 909             }
 910             if (a.needsExpansion) {
 911                 File x = new File(a.arg);
 912                 File parent = x.getParentFile();
 913                 String glob = x.getName();
 914                 if (parent == null) {
 915                     parent = new File(&quot;.&quot;);
 916                 }
 917                 try (DirectoryStream&lt;Path&gt; dstream =
 918                         Files.newDirectoryStream(parent.toPath(), glob)) {
 919                     int entries = 0;
 920                     for (Path p : dstream) {
 921                         out.add(p.normalize().toString());
 922                         entries++;
 923                     }
 924                     if (entries == 0) {
 925                         out.add(a.arg);
 926                     }
 927                 } catch (Exception e) {
 928                     out.add(a.arg);
 929                     if (trace) {
 930                         System.err.println(&quot;Warning: passing argument as-is &quot; + a);
 931                         System.err.print(e);
 932                     }
 933                 }
 934             } else {
 935                 out.add(a.arg);
 936             }
 937         }
 938         String[] oarray = new String[out.size()];
 939         out.toArray(oarray);
 940 
 941         if (trace) {
 942             System.err.println(&quot;Expanded arguments:&quot;);
 943             for (String x : oarray) {
 944                 System.err.println(x);
 945             }
 946         }
 947         return oarray;
 948     }
 949 
 950     /* duplicate of the native StdArg struct */
 951     private static class StdArg {
 952         final String arg;
 953         final boolean needsExpansion;
 954         StdArg(String arg, boolean expand) {
 955             this.arg = arg;
 956             this.needsExpansion = expand;
 957         }
 958         // protocol: first char indicates whether expansion is required
 959         // &#39;T&#39; = true ; needs expansion
 960         // &#39;F&#39; = false; needs no expansion
 961         StdArg(String in) {
 962             this.arg = in.substring(1);
 963             needsExpansion = in.charAt(0) == &#39;T&#39;;
 964         }
 965         public String toString() {
 966             return &quot;StdArg{&quot; + &quot;arg=&quot; + arg + &quot;, needsExpansion=&quot; + needsExpansion + &#39;}&#39;;
 967         }
 968     }
 969 
 970     static final class FXHelper {
 971 
 972         private static final String JAVAFX_GRAPHICS_MODULE_NAME =
 973                 &quot;javafx.graphics&quot;;
 974 
 975         private static final String JAVAFX_LAUNCHER_CLASS_NAME =
 976                 &quot;com.sun.javafx.application.LauncherImpl&quot;;
 977 
 978         /*
 979          * The launch method used to invoke the JavaFX launcher. These must
 980          * match the strings used in the launchApplication method.
 981          *
 982          * Command line                 JavaFX-App-Class  Launch mode  FX Launch mode
 983          * java -cp fxapp.jar FXClass   N/A               LM_CLASS     &quot;LM_CLASS&quot;
 984          * java -cp somedir FXClass     N/A               LM_CLASS     &quot;LM_CLASS&quot;
 985          * java -jar fxapp.jar          Present           LM_JAR       &quot;LM_JAR&quot;
 986          * java -jar fxapp.jar          Not Present       LM_JAR       &quot;LM_JAR&quot;
 987          * java -m module/class [1]     N/A               LM_MODULE    &quot;LM_MODULE&quot;
 988          * java -m module               N/A               LM_MODULE    &quot;LM_MODULE&quot;
 989          *
 990          * [1] - JavaFX-Application-Class is ignored when modular args are used, even
 991          * if present in a modular jar
 992          */
 993         private static final String JAVAFX_LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;
 994         private static final String JAVAFX_LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;
 995         private static final String JAVAFX_LAUNCH_MODE_MODULE = &quot;LM_MODULE&quot;;
 996 
 997         /*
 998          * FX application launcher and launch method, so we can launch
 999          * applications with no main method.
1000          */
1001         private static String fxLaunchName = null;
1002         private static String fxLaunchMode = null;
1003 
1004         private static Class&lt;?&gt; fxLauncherClass    = null;
1005         private static Method   fxLauncherMethod   = null;
1006 
1007         /*
1008          * Set the launch params according to what was passed to LauncherHelper
1009          * so we can use the same launch mode for FX. Abort if there is any
1010          * issue with loading the FX runtime or with the launcher method.
1011          */
1012         private static void setFXLaunchParameters(String what, int mode) {
1013 
1014             // find the module with the FX launcher
1015             Optional&lt;Module&gt; om = ModuleLayer.boot().findModule(JAVAFX_GRAPHICS_MODULE_NAME);
1016             if (!om.isPresent()) {
1017                 abort(null, &quot;java.launcher.cls.error5&quot;);
1018             }
1019 
1020             // load the FX launcher class
1021             fxLauncherClass = Class.forName(om.get(), JAVAFX_LAUNCHER_CLASS_NAME);
1022             if (fxLauncherClass == null) {
1023                 abort(null, &quot;java.launcher.cls.error5&quot;);
1024             }
1025 
1026             try {
1027                 /*
1028                  * signature must be:
1029                  * public static void launchApplication(String launchName,
1030                  *     String launchMode, String[] args);
1031                  */
1032                 fxLauncherMethod = fxLauncherClass.getMethod(&quot;launchApplication&quot;,
1033                         String.class, String.class, String[].class);
1034 
1035                 // verify launcher signature as we do when validating the main method
1036                 int mod = fxLauncherMethod.getModifiers();
1037                 if (!Modifier.isStatic(mod)) {
1038                     abort(null, &quot;java.launcher.javafx.error1&quot;);
1039                 }
1040                 if (fxLauncherMethod.getReturnType() != java.lang.Void.TYPE) {
1041                     abort(null, &quot;java.launcher.javafx.error1&quot;);
1042                 }
1043             } catch (NoSuchMethodException ex) {
1044                 abort(ex, &quot;java.launcher.cls.error5&quot;, ex);
1045             }
1046 
1047             fxLaunchName = what;
1048             switch (mode) {
1049                 case LM_CLASS:
1050                     fxLaunchMode = JAVAFX_LAUNCH_MODE_CLASS;
1051                     break;
1052                 case LM_JAR:
1053                     fxLaunchMode = JAVAFX_LAUNCH_MODE_JAR;
1054                     break;
1055                 case LM_MODULE:
1056                     fxLaunchMode = JAVAFX_LAUNCH_MODE_MODULE;
1057                     break;
1058                 default:
1059                     // should not have gotten this far...
1060                     throw new InternalError(mode + &quot;: Unknown launch mode&quot;);
1061             }
1062         }
1063 
1064         public static void main(String... args) throws Exception {
1065             if (fxLauncherMethod == null
1066                     || fxLaunchMode == null
1067                     || fxLaunchName == null) {
1068                 throw new RuntimeException(&quot;Invalid JavaFX launch parameters&quot;);
1069             }
1070             // launch appClass via fxLauncherMethod
1071             fxLauncherMethod.invoke(null,
1072                     new Object[] {fxLaunchName, fxLaunchMode, args});
1073         }
1074     }
1075 
1076     /**
1077      * Called by the launcher to list the observable modules.
1078      */
1079     static void listModules() {
1080         initOutput(System.out);
1081 
1082         ModuleBootstrap.limitedFinder().findAll().stream()
1083             .sorted(new JrtFirstComparator())
1084             .forEach(LauncherHelper::showModule);
1085     }
1086 
1087     /**
1088      * Called by the launcher to show the resolved modules
1089      */
1090     static void showResolvedModules() {
1091         initOutput(System.out);
1092 
1093         ModuleLayer bootLayer = ModuleLayer.boot();
1094         Configuration cf = bootLayer.configuration();
1095 
1096         cf.modules().stream()
1097             .map(ResolvedModule::reference)
1098             .sorted(new JrtFirstComparator())
1099             .forEach(LauncherHelper::showModule);
1100     }
1101 
1102     /**
1103      * Called by the launcher to describe a module
1104      */
1105     static void describeModule(String moduleName) {
1106         initOutput(System.out);
1107 
1108         ModuleFinder finder = ModuleBootstrap.limitedFinder();
1109         ModuleReference mref = finder.find(moduleName).orElse(null);
1110         if (mref == null) {
1111             abort(null, &quot;java.launcher.module.error4&quot;, moduleName);
1112         }
1113         ModuleDescriptor md = mref.descriptor();
1114 
1115         // one-line summary
1116         showModule(mref);
1117 
1118         // unqualified exports (sorted by package)
1119         md.exports().stream()
1120             .filter(e -&gt; !e.isQualified())
1121             .sorted(Comparator.comparing(Exports::source))
1122             .map(e -&gt; Stream.concat(Stream.of(e.source()),
1123                                     toStringStream(e.modifiers()))
1124                     .collect(Collectors.joining(&quot; &quot;)))
1125             .forEach(sourceAndMods -&gt; ostream.format(&quot;exports %s%n&quot;, sourceAndMods));
1126 
1127         // dependences
1128         for (Requires r : md.requires()) {
1129             String nameAndMods = Stream.concat(Stream.of(r.name()),
1130                                                toStringStream(r.modifiers()))
1131                     .collect(Collectors.joining(&quot; &quot;));
1132             ostream.format(&quot;requires %s&quot;, nameAndMods);
1133             finder.find(r.name())
1134                 .map(ModuleReference::descriptor)
1135                 .filter(ModuleDescriptor::isAutomatic)
1136                 .ifPresent(any -&gt; ostream.print(&quot; automatic&quot;));
1137             ostream.println();
1138         }
1139 
1140         // service use and provides
1141         for (String s : md.uses()) {
1142             ostream.format(&quot;uses %s%n&quot;, s);
1143         }
1144         for (Provides ps : md.provides()) {
1145             String names = ps.providers().stream().collect(Collectors.joining(&quot; &quot;));
1146             ostream.format(&quot;provides %s with %s%n&quot;, ps.service(), names);
1147 
1148         }
1149 
1150         // qualified exports
1151         for (Exports e : md.exports()) {
1152             if (e.isQualified()) {
1153                 String who = e.targets().stream().collect(Collectors.joining(&quot; &quot;));
1154                 ostream.format(&quot;qualified exports %s to %s%n&quot;, e.source(), who);
1155             }
1156         }
1157 
1158         // open packages
1159         for (Opens opens: md.opens()) {
1160             if (opens.isQualified())
1161                 ostream.print(&quot;qualified &quot;);
1162             String sourceAndMods = Stream.concat(Stream.of(opens.source()),
1163                                                  toStringStream(opens.modifiers()))
1164                     .collect(Collectors.joining(&quot; &quot;));
1165             ostream.format(&quot;opens %s&quot;, sourceAndMods);
1166             if (opens.isQualified()) {
1167                 String who = opens.targets().stream().collect(Collectors.joining(&quot; &quot;));
1168                 ostream.format(&quot; to %s&quot;, who);
1169             }
1170             ostream.println();
1171         }
1172 
1173         // non-exported/non-open packages
1174         Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
1175         md.exports().stream().map(Exports::source).forEach(concealed::remove);
1176         md.opens().stream().map(Opens::source).forEach(concealed::remove);
1177         concealed.forEach(p -&gt; ostream.format(&quot;contains %s%n&quot;, p));
1178     }
1179 
1180     /**
1181      * Prints a single line with the module name, version and modifiers
1182      */
1183     private static void showModule(ModuleReference mref) {
1184         ModuleDescriptor md = mref.descriptor();
1185         ostream.print(md.toNameAndVersion());
1186         mref.location()
1187                 .filter(uri -&gt; !isJrt(uri))
1188                 .ifPresent(uri -&gt; ostream.format(&quot; %s&quot;, uri));
1189         if (md.isOpen())
1190             ostream.print(&quot; open&quot;);
1191         if (md.isAutomatic())
1192             ostream.print(&quot; automatic&quot;);
1193         ostream.println();
1194     }
1195 
1196     /**
1197      * A ModuleReference comparator that considers modules in the run-time
1198      * image to be less than modules than not in the run-time image.
1199      */
1200     private static class JrtFirstComparator implements Comparator&lt;ModuleReference&gt; {
1201         private final Comparator&lt;ModuleReference&gt; real;
1202 
1203         JrtFirstComparator() {
1204             this.real = Comparator.comparing(ModuleReference::descriptor);
1205         }
1206 
1207         @Override
1208         public int compare(ModuleReference a, ModuleReference b) {
1209             if (isJrt(a)) {
1210                 return isJrt(b) ? real.compare(a, b) : -1;
1211             } else {
1212                 return isJrt(b) ? 1 : real.compare(a, b);
1213             }
1214         }
1215     }
1216 
1217     private static &lt;T&gt; Stream&lt;String&gt; toStringStream(Set&lt;T&gt; s) {
1218         return s.stream().map(e -&gt; e.toString().toLowerCase());
1219     }
1220 
1221     private static boolean isJrt(ModuleReference mref) {
1222         return isJrt(mref.location().orElse(null));
1223     }
1224 
1225     private static boolean isJrt(URI uri) {
1226         return (uri != null &amp;&amp; uri.getScheme().equalsIgnoreCase(&quot;jrt&quot;));
1227     }
1228 
1229 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
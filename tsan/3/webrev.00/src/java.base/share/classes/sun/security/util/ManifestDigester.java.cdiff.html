<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/util/ManifestDigester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LegacyAlgorithmConstraints.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/ManifestDigester.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,14 ***</span>
   * questions.
   */
  
  package sun.security.util;
  
<span class="line-modified">! import java.security.*;</span>
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.io.ByteArrayOutputStream;
  import java.util.List;
  
  import static java.nio.charset.StandardCharsets.UTF_8;
  
  /**
<span class="line-new-header">--- 23,16 ---</span>
   * questions.
   */
  
  package sun.security.util;
  
<span class="line-modified">! import java.security.MessageDigest;</span>
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.io.ByteArrayOutputStream;
<span class="line-added">+ import java.io.OutputStream;</span>
<span class="line-added">+ import java.io.IOException;</span>
  import java.util.List;
  
  import static java.nio.charset.StandardCharsets.UTF_8;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,17 ***</span>
   * Please note that multiple sections might have the same name, and they
   * all belong to a single Entry.
   */
  public class ManifestDigester {
  
      public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
  
      /** the raw bytes of the manifest */
<span class="line-modified">!     private byte[] rawBytes;</span>
  
<span class="line-modified">!     /** the entries grouped by names */</span>
<span class="line-modified">!     private HashMap&lt;String, Entry&gt; entries; // key is a UTF-8 string</span>
  
      /** state returned by findSection */
      static class Position {
          int endOfFirstLine; // not including newline character
  
<span class="line-new-header">--- 40,31 ---</span>
   * Please note that multiple sections might have the same name, and they
   * all belong to a single Entry.
   */
  public class ManifestDigester {
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * The part &quot;{@code Manifest-Main-Attributes}&quot; of the main attributes</span>
<span class="line-added">+      * digest header name in a signature file as described in the jar</span>
<span class="line-added">+      * specification:</span>
<span class="line-added">+      * &lt;blockquote&gt;{@code x-Digest-Manifest-Main-Attributes}</span>
<span class="line-added">+      * (where x is the standard name of a {@link MessageDigest} algorithm):</span>
<span class="line-added">+      * The value of this attribute is the digest value of the main attributes</span>
<span class="line-added">+      * of the manifest.&lt;/blockquote&gt;</span>
<span class="line-added">+      * @see &lt;a href=&quot;{@docRoot}/../specs/jar/jar.html#signature-file&quot;&gt;</span>
<span class="line-added">+      * JAR File Specification, section Signature File&lt;/a&gt;</span>
<span class="line-added">+      * @see #getMainAttsEntry</span>
<span class="line-added">+      */</span>
      public static final String MF_MAIN_ATTRS = &quot;Manifest-Main-Attributes&quot;;
  
      /** the raw bytes of the manifest */
<span class="line-modified">!     private final byte[] rawBytes;</span>
  
<span class="line-modified">!     private final Entry mainAttsEntry;</span>
<span class="line-modified">! </span>
<span class="line-added">+     /** individual sections by their names */</span>
<span class="line-added">+     private final HashMap&lt;String, Entry&gt; entries = new HashMap&lt;&gt;();</span>
  
      /** state returned by findSection */
      static class Position {
          int endOfFirstLine; // not including newline character
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,33 ***</span>
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      private boolean findSection(int offset, Position pos)
      {
          int i = offset, len = rawBytes.length;
<span class="line-modified">!         int last = offset;</span>
          int next;
          boolean allBlank = true;
  
<span class="line-modified">!         pos.endOfFirstLine = -1;</span>
  
          while (i &lt; len) {
              byte b = rawBytes[i];
              switch(b) {
              case &#39;\r&#39;:
<span class="line-modified">!                 if (pos.endOfFirstLine == -1)</span>
                      pos.endOfFirstLine = i-1;
<span class="line-modified">!                 if ((i &lt; len) &amp;&amp;  (rawBytes[i+1] == &#39;\n&#39;))</span>
                      i++;
                  /* fall through */
              case &#39;\n&#39;:
<span class="line-modified">!                 if (pos.endOfFirstLine == -1)</span>
                      pos.endOfFirstLine = i-1;
                  if (allBlank || (i == len-1)) {
<span class="line-modified">!                     if (i == len-1)</span>
<span class="line-removed">-                         pos.endOfSection = i;</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         pos.endOfSection = last;</span>
                      pos.startOfNext = i+1;
                      return true;
                  }
                  else {
                      // start of a new line
<span class="line-new-header">--- 86,35 ---</span>
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      private boolean findSection(int offset, Position pos)
      {
          int i = offset, len = rawBytes.length;
<span class="line-modified">!         int last = offset - 1;</span>
          int next;
          boolean allBlank = true;
  
<span class="line-modified">!         /* denotes that a position is not yet assigned.</span>
<span class="line-added">+          * As a primitive type int it cannot be null</span>
<span class="line-added">+          * and -1 would be confused with (i - 1) when i == 0 */</span>
<span class="line-added">+         final int UNASSIGNED = Integer.MIN_VALUE;</span>
<span class="line-added">+ </span>
<span class="line-added">+         pos.endOfFirstLine = UNASSIGNED;</span>
  
          while (i &lt; len) {
              byte b = rawBytes[i];
              switch(b) {
              case &#39;\r&#39;:
<span class="line-modified">!                 if (pos.endOfFirstLine == UNASSIGNED)</span>
                      pos.endOfFirstLine = i-1;
<span class="line-modified">!                 if (i &lt; len - 1 &amp;&amp; rawBytes[i + 1] == &#39;\n&#39;)</span>
                      i++;
                  /* fall through */
              case &#39;\n&#39;:
<span class="line-modified">!                 if (pos.endOfFirstLine == UNASSIGNED)</span>
                      pos.endOfFirstLine = i-1;
                  if (allBlank || (i == len-1)) {
<span class="line-modified">!                     pos.endOfSection = allBlank ? last : i;</span>
                      pos.startOfNext = i+1;
                      return true;
                  }
                  else {
                      // start of a new line
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,35 ***</span>
      }
  
      public ManifestDigester(byte[] bytes)
      {
          rawBytes = bytes;
<span class="line-removed">-         entries = new HashMap&lt;&gt;();</span>
  
          Position pos = new Position();
  
<span class="line-modified">!         if (!findSection(0, pos))</span>
              return; // XXX: exception?
  
          // create an entry for main attributes
<span class="line-modified">!         entries.put(MF_MAIN_ATTRS, new Entry().addSection(</span>
<span class="line-modified">!                 new Section(0, pos.endOfSection + 1, pos.startOfNext, rawBytes)));</span>
  
          int start = pos.startOfNext;
          while(findSection(start, pos)) {
              int len = pos.endOfFirstLine-start+1;
              int sectionLen = pos.endOfSection-start+1;
              int sectionLenWithBlank = pos.startOfNext-start;
  
<span class="line-modified">!             if (len &gt; 6) {</span>
                  if (isNameAttr(bytes, start)) {
                      ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
                      nameBuf.write(bytes, start+6, len-6);
  
                      int i = start + len;
                      if ((i-start) &lt; sectionLen) {
<span class="line-modified">!                         if (bytes[i] == &#39;\r&#39;) {</span>
                              i += 2;
                          } else {
                              i += 1;
                          }
                      }
<span class="line-new-header">--- 132,38 ---</span>
      }
  
      public ManifestDigester(byte[] bytes)
      {
          rawBytes = bytes;
  
          Position pos = new Position();
  
<span class="line-modified">!         if (!findSection(0, pos)) {</span>
<span class="line-added">+             mainAttsEntry = null;</span>
              return; // XXX: exception?
<span class="line-added">+         }</span>
  
          // create an entry for main attributes
<span class="line-modified">!         mainAttsEntry = new Entry().addSection(new Section(</span>
<span class="line-modified">!                 0, pos.endOfSection + 1, pos.startOfNext, rawBytes));</span>
  
          int start = pos.startOfNext;
          while(findSection(start, pos)) {
              int len = pos.endOfFirstLine-start+1;
              int sectionLen = pos.endOfSection-start+1;
              int sectionLenWithBlank = pos.startOfNext-start;
  
<span class="line-modified">!             if (len &gt;= 6) { // 6 == &quot;Name: &quot;.length()</span>
                  if (isNameAttr(bytes, start)) {
                      ByteArrayOutputStream nameBuf = new ByteArrayOutputStream();
                      nameBuf.write(bytes, start+6, len-6);
  
                      int i = start + len;
                      if ((i-start) &lt; sectionLen) {
<span class="line-modified">!                         if (bytes[i] == &#39;\r&#39;</span>
<span class="line-added">+                                 &amp;&amp; i + 1 - start &lt; sectionLen</span>
<span class="line-added">+                                 &amp;&amp; bytes[i + 1] == &#39;\n&#39;) {</span>
                              i += 2;
                          } else {
                              i += 1;
                          }
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,26 ***</span>
                      while ((i-start) &lt; sectionLen) {
                          if (bytes[i++] == &#39; &#39;) {
                              // name is wrapped
                              int wrapStart = i;
                              while (((i-start) &lt; sectionLen)
<span class="line-modified">!                                     &amp;&amp; (bytes[i++] != &#39;\n&#39;));</span>
<span class="line-modified">!                             if (bytes[i-1] != &#39;\n&#39;)</span>
<span class="line-modified">!                                 return; // XXX: exception?</span>
<span class="line-modified">!                             int wrapLen;</span>
<span class="line-modified">!                             if (bytes[i-2] == &#39;\r&#39;)</span>
<span class="line-modified">!                                 wrapLen = i-wrapStart-2;</span>
<span class="line-modified">!                             else</span>
<span class="line-modified">!                                 wrapLen = i-wrapStart-1;</span>
  
                              nameBuf.write(bytes, wrapStart, wrapLen);
                          } else {
                              break;
                          }
                      }
  
<span class="line-modified">!                     entries.computeIfAbsent(new String(nameBuf.toByteArray(), UTF_8),</span>
                                              dummy -&gt; new Entry())
                              .addSection(new Section(start, sectionLen,
                                      sectionLenWithBlank, rawBytes));
                  }
              }
<span class="line-new-header">--- 171,28 ---</span>
                      while ((i-start) &lt; sectionLen) {
                          if (bytes[i++] == &#39; &#39;) {
                              // name is wrapped
                              int wrapStart = i;
                              while (((i-start) &lt; sectionLen)
<span class="line-modified">!                                     &amp;&amp; (bytes[i] != &#39;\r&#39;)</span>
<span class="line-modified">!                                     &amp;&amp; (bytes[i] != &#39;\n&#39;)) i++;</span>
<span class="line-modified">!                             int wrapLen = i - wrapStart;</span>
<span class="line-modified">!                             if (i - start &lt; sectionLen) {</span>
<span class="line-modified">!                                 i++;</span>
<span class="line-modified">!                                 if (bytes[i - 1] == &#39;\r&#39;</span>
<span class="line-modified">!                                     &amp;&amp; i - start &lt; sectionLen</span>
<span class="line-modified">!                                     &amp;&amp; bytes[i] == &#39;\n&#39;)</span>
<span class="line-added">+                                         i++;</span>
<span class="line-added">+                             }</span>
  
                              nameBuf.write(bytes, wrapStart, wrapLen);
                          } else {
                              break;
                          }
                      }
  
<span class="line-modified">!                     entries.computeIfAbsent(nameBuf.toString(UTF_8),</span>
                                              dummy -&gt; new Entry())
                              .addSection(new Section(start, sectionLen,
                                      sectionLenWithBlank, rawBytes));
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,10 ***</span>
<span class="line-new-header">--- 223,30 ---</span>
          {
              sections.add(sec);
              return this;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Check if the sections (particularly the last one of usually only one)</span>
<span class="line-added">+          * are properly delimited with a trailing blank line so that another</span>
<span class="line-added">+          * section can be correctly appended and return {@code true} or return</span>
<span class="line-added">+          * {@code false} to indicate that reproduction is not advised and should</span>
<span class="line-added">+          * be carried out with a clean &quot;normalized&quot; newly-written manifest.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @see #reproduceRaw</span>
<span class="line-added">+          */</span>
<span class="line-added">+         public boolean isProperlyDelimited() {</span>
<span class="line-added">+             return sections.stream().allMatch(</span>
<span class="line-added">+                     Section::isProperlySectionDelimited);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public void reproduceRaw(OutputStream out) throws IOException {</span>
<span class="line-added">+             for (Section sec : sections) {</span>
<span class="line-added">+                 out.write(sec.rawBytes, sec.offset, sec.lengthWithBlankLine);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          public byte[] digest(MessageDigest md)
          {
              md.reset();
              for (Section sec : sections) {
                  if (oldStyle) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,10 ***</span>
<span class="line-new-header">--- 283,19 ---</span>
              this.length = length;
              this.lengthWithBlankLine = lengthWithBlankLine;
              this.rawBytes = rawBytes;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Returns {@code true} if the raw section is terminated with a blank</span>
<span class="line-added">+          * line so that another section can possibly be appended resulting in a</span>
<span class="line-added">+          * valid manifest and {@code false} otherwise.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private boolean isProperlySectionDelimited() {</span>
<span class="line-added">+             return lengthWithBlankLine &gt; length;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private static void doOldStyle(MessageDigest md,
                                  byte[] bytes,
                                  int offset,
                                  int length)
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,14 ***</span>
              }
              md.update(bytes, start, i-start);
          }
      }
  
      public Entry get(String name, boolean oldStyle) {
<span class="line-modified">!         Entry e = entries.get(name);</span>
<span class="line-modified">!         if (e != null)</span>
              e.oldStyle = oldStyle;
          return e;
      }
  
      public byte[] manifestDigest(MessageDigest md) {
          md.reset();
<span class="line-new-header">--- 318,37 ---</span>
              }
              md.update(bytes, start, i-start);
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public Entry getMainAttsEntry() {</span>
<span class="line-added">+         return mainAttsEntry;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @see #MF_MAIN_ATTRS</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public Entry getMainAttsEntry(boolean oldStyle) {</span>
<span class="line-added">+         mainAttsEntry.oldStyle = oldStyle;</span>
<span class="line-added">+         return mainAttsEntry;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Entry get(String name) {</span>
<span class="line-added">+         return entries.get(name);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public Entry get(String name, boolean oldStyle) {
<span class="line-modified">!         Entry e = get(name);</span>
<span class="line-modified">!         if (e == null &amp;&amp; MF_MAIN_ATTRS.equals(name)) {</span>
<span class="line-added">+             e = getMainAttsEntry();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (e != null) {</span>
              e.oldStyle = oldStyle;
<span class="line-added">+         }</span>
          return e;
      }
  
      public byte[] manifestDigest(MessageDigest md) {
          md.reset();
</pre>
<center><a href="LegacyAlgorithmConstraints.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ObjectIdentifier.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
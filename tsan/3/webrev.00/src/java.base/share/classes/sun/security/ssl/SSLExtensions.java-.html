<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SSLExtensions.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.text.MessageFormat;
 31 import java.util.*;
 32 
 33 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 34 import sun.security.util.HexDumpEncoder;
 35 
 36 /**
 37  * SSL/(D)TLS extensions in a handshake message.
 38  */
 39 final class SSLExtensions {
 40     private final HandshakeMessage handshakeMessage;
 41     private Map&lt;SSLExtension, byte[]&gt; extMap = new LinkedHashMap&lt;&gt;();
 42     private int encodedLength;
 43 
 44     // Extension map for debug logging
 45     private final Map&lt;Integer, byte[]&gt; logMap =
 46             SSLLogger.isOn ? new LinkedHashMap&lt;&gt;() : null;
 47 
 48     SSLExtensions(HandshakeMessage handshakeMessage) {
 49         this.handshakeMessage = handshakeMessage;
 50         this.encodedLength = 2;         // 2: the length of the extensions.
 51     }
 52 
 53     SSLExtensions(HandshakeMessage hm,
 54             ByteBuffer m, SSLExtension[] extensions) throws IOException {
 55         this.handshakeMessage = hm;
 56 
 57         int len = Record.getInt16(m);
 58         encodedLength = len + 2;        // 2: the length of the extensions.
 59         while (len &gt; 0) {
 60             int extId = Record.getInt16(m);
 61             int extLen = Record.getInt16(m);
 62             if (extLen &gt; m.remaining()) {
 63                 throw hm.handshakeContext.conContext.fatal(
 64                         Alert.ILLEGAL_PARAMETER,
 65                         &quot;Error parsing extension (&quot; + extId +
 66                         &quot;): no sufficient data&quot;);
 67             }
 68 
 69             boolean isSupported = true;
 70             SSLHandshake handshakeType = hm.handshakeType();
 71             if (SSLExtension.isConsumable(extId) &amp;&amp;
 72                     SSLExtension.valueOf(handshakeType, extId) == null) {
 73                 if (extId == SSLExtension.CH_SUPPORTED_GROUPS.id &amp;&amp;
 74                         handshakeType == SSLHandshake.SERVER_HELLO) {
 75                     // Note: It does not comply to the specification.  However,
 76                     // there are servers that send the supported_groups
 77                     // extension in ServerHello handshake message.
 78                     //
 79                     // TLS 1.3 should not send this extension.   We may want to
 80                     // limit the workaround for TLS 1.2 and prior version only.
 81                     // However, the implementation of the limit is complicated
 82                     // and inefficient, and may not worthy the maintenance.
 83                     isSupported = false;
 84                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 85                         SSLLogger.warning(
 86                                 &quot;Received buggy supported_groups extension &quot; +
 87                                 &quot;in the ServerHello handshake message&quot;);
 88                     }
 89                 } else {
 90                     throw hm.handshakeContext.conContext.fatal(
 91                         Alert.UNSUPPORTED_EXTENSION,
 92                         &quot;extension (&quot; + extId +
 93                         &quot;) should not be presented in &quot; + handshakeType.name);
 94                 }
 95             }
 96 
 97             if (isSupported) {
 98                 isSupported = false;
 99                 for (SSLExtension extension : extensions) {
100                     if ((extension.id != extId) ||
101                             (extension.onLoadConsumer == null)) {
102                         continue;
103                     }
104 
105                     if (extension.handshakeType != handshakeType) {
106                         throw hm.handshakeContext.conContext.fatal(
107                                 Alert.UNSUPPORTED_EXTENSION,
108                                 &quot;extension (&quot; + extId + &quot;) should not be &quot; +
109                                 &quot;presented in &quot; + handshakeType.name);
110                     }
111 
112                     byte[] extData = new byte[extLen];
113                     m.get(extData);
114                     extMap.put(extension, extData);
115                     if (logMap != null) {
116                         logMap.put(extId, extData);
117                     }
118 
119                     isSupported = true;
120                     break;
121                 }
122             }
123 
124             if (!isSupported) {
125                 if (logMap != null) {
126                     // cache the extension for debug logging
127                     byte[] extData = new byte[extLen];
128                     m.get(extData);
129                     logMap.put(extId, extData);
130 
131                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
132                         SSLLogger.fine(
133                                 &quot;Ignore unknown or unsupported extension&quot;,
134                                 toString(extId, extData));
135                     }
136                 } else {
137                     // ignore the extension
138                     int pos = m.position() + extLen;
139                     m.position(pos);
140                 }
141             }
142 
143             len -= extLen + 4;
144         }
145     }
146 
147     byte[] get(SSLExtension ext) {
148         return extMap.get(ext);
149     }
150 
151     /**
152      * Consume the specified extensions.
153      */
154     void consumeOnLoad(HandshakeContext context,
155             SSLExtension[] extensions) throws IOException {
156         for (SSLExtension extension : extensions) {
157             if (context.negotiatedProtocol != null &amp;&amp;
158                     !extension.isAvailable(context.negotiatedProtocol)) {
159                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
160                     SSLLogger.fine(
161                         &quot;Ignore unsupported extension: &quot; + extension.name);
162                 }
163                 continue;
164             }
165 
166             if (!extMap.containsKey(extension)) {
167                 if (extension.onLoadAbsence != null) {
168                     extension.absentOnLoad(context, handshakeMessage);
169                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
170                     SSLLogger.fine(
171                         &quot;Ignore unavailable extension: &quot; + extension.name);
172                 }
173                 continue;
174             }
175 
176 
177             if (extension.onLoadConsumer == null) {
178                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
179                     SSLLogger.warning(
180                         &quot;Ignore unsupported extension: &quot; + extension.name);
181                 }
182                 continue;
183             }
184 
185             ByteBuffer m = ByteBuffer.wrap(extMap.get(extension));
186             extension.consumeOnLoad(context, handshakeMessage, m);
187 
188             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
189                 SSLLogger.fine(&quot;Consumed extension: &quot; + extension.name);
190             }
191         }
192     }
193 
194     /**
195      * Consider impact of the specified extensions.
196      */
197     void consumeOnTrade(HandshakeContext context,
198             SSLExtension[] extensions) throws IOException {
199         for (SSLExtension extension : extensions) {
200             if (!extMap.containsKey(extension)) {
201                 if (extension.onTradeAbsence != null) {
202                     extension.absentOnTrade(context, handshakeMessage);
203                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
204                     SSLLogger.fine(
205                         &quot;Ignore unavailable extension: &quot; + extension.name);
206                 }
207                 continue;
208             }
209 
210             if (extension.onTradeConsumer == null) {
211                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
212                     SSLLogger.warning(
213                             &quot;Ignore impact of unsupported extension: &quot; +
214                             extension.name);
215                 }
216                 continue;
217             }
218 
219             extension.consumeOnTrade(context, handshakeMessage);
220             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
221                 SSLLogger.fine(&quot;Populated with extension: &quot; + extension.name);
222             }
223         }
224     }
225 
226     /**
227      * Produce extension values for the specified extensions.
228      */
229     void produce(HandshakeContext context,
230             SSLExtension[] extensions) throws IOException {
231         for (SSLExtension extension : extensions) {
232             if (extMap.containsKey(extension)) {
233                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
234                     SSLLogger.fine(
235                             &quot;Ignore, duplicated extension: &quot; +
236                             extension.name);
237                 }
238                 continue;
239             }
240 
241             if (extension.networkProducer == null) {
242                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
243                     SSLLogger.warning(
244                             &quot;Ignore, no extension producer defined: &quot; +
245                             extension.name);
246                 }
247                 continue;
248             }
249 
250             byte[] encoded = extension.produce(context, handshakeMessage);
251             if (encoded != null) {
252                 extMap.put(extension, encoded);
253                 encodedLength += encoded.length + 4; // extension_type (2)
254                                                      // extension_data length(2)
255             } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
256                 // The extension is not available in the context.
257                 SSLLogger.fine(
258                         &quot;Ignore, context unavailable extension: &quot; +
259                         extension.name);
260             }
261         }
262     }
263 
264     /**
265      * Produce extension values for the specified extensions, replacing if
266      * there is an existing extension value for a specified extension.
267      */
268     void reproduce(HandshakeContext context,
269             SSLExtension[] extensions) throws IOException {
270         for (SSLExtension extension : extensions) {
271             if (extension.networkProducer == null) {
272                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
273                     SSLLogger.warning(
274                             &quot;Ignore, no extension producer defined: &quot; +
275                             extension.name);
276                 }
277                 continue;
278             }
279 
280             byte[] encoded = extension.produce(context, handshakeMessage);
281             if (encoded != null) {
282                 if (extMap.containsKey(extension)) {
283                     byte[] old = extMap.replace(extension, encoded);
284                     if (old != null) {
285                         encodedLength -= old.length + 4;
286                     }
287                     encodedLength += encoded.length + 4;
288                 } else {
289                     extMap.put(extension, encoded);
290                     encodedLength += encoded.length + 4;
291                                                     // extension_type (2)
292                                                     // extension_data length(2)
293                 }
294             } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
295                 // The extension is not available in the context.
296                 SSLLogger.fine(
297                         &quot;Ignore, context unavailable extension: &quot; +
298                         extension.name);
299             }
300         }
301     }
302 
303     // Note that TLS 1.3 may use empty extensions.  Please consider it while
304     // using this method.
305     int length() {
306         if (extMap.isEmpty()) {
307             return 0;
308         } else {
309             return encodedLength;
310         }
311     }
312 
313     // Note that TLS 1.3 may use empty extensions.  Please consider it while
314     // using this method.
315     void send(HandshakeOutStream hos) throws IOException {
316         int extsLen = length();
317         if (extsLen == 0) {
318             return;
319         }
320         hos.putInt16(extsLen - 2);
321         // extensions must be sent in the order they appear in the enum
322         for (SSLExtension ext : SSLExtension.values()) {
323             byte[] extData = extMap.get(ext);
324             if (extData != null) {
325                 hos.putInt16(ext.id);
326                 hos.putBytes16(extData);
327             }
328         }
329     }
330 
331     @Override
332     public String toString() {
333         if (extMap.isEmpty() &amp;&amp; (logMap == null || logMap.isEmpty())) {
334             return &quot;&lt;no extension&gt;&quot;;
335         } else {
336             StringBuilder builder = new StringBuilder(512);
337             if (logMap != null &amp;&amp; !logMap.isEmpty()) {
338                 for (Map.Entry&lt;Integer, byte[]&gt; en : logMap.entrySet()) {
339                     SSLExtension ext = SSLExtension.valueOf(
340                             handshakeMessage.handshakeType(), en.getKey());
341                     if (builder.length() != 0) {
342                         builder.append(&quot;,\n&quot;);
343                     }
344                     if (ext != null) {
345                         builder.append(
346                                 ext.toString(ByteBuffer.wrap(en.getValue())));
347                     } else {
348                         builder.append(toString(en.getKey(), en.getValue()));
349                     }
350                 }
351 
352                 return builder.toString();
353             } else {
354                 for (Map.Entry&lt;SSLExtension, byte[]&gt; en : extMap.entrySet()) {
355                     if (builder.length() != 0) {
356                         builder.append(&quot;,\n&quot;);
357                     }
358                     builder.append(
359                         en.getKey().toString(ByteBuffer.wrap(en.getValue())));
360                 }
361 
362                 return builder.toString();
363             }
364         }
365     }
366 
367     private static String toString(int extId, byte[] extData) {
368         MessageFormat messageFormat = new MessageFormat(
369             &quot;\&quot;unknown extension ({0})\&quot;: &#39;{&#39;\n&quot; +
370             &quot;{1}\n&quot; +
371             &quot;&#39;}&#39;&quot;,
372             Locale.ENGLISH);
373 
374         HexDumpEncoder hexEncoder = new HexDumpEncoder();
375         String encoded = hexEncoder.encodeBuffer(extData);
376 
377         Object[] messageFields = {
378             extId,
379             Utilities.indent(encoded)
380         };
381 
382         return messageFormat.format(messageFields);
383     }
384 }
    </pre>
  </body>
</html>
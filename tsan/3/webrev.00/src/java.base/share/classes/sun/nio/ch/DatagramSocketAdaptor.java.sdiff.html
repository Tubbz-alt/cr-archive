<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/DatagramSocketAdaptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;






 29 import java.net.DatagramPacket;
 30 import java.net.DatagramSocket;
<span class="line-removed"> 31 import java.net.DatagramSocketImpl;</span>
 32 import java.net.InetAddress;
 33 import java.net.InetSocketAddress;
 34 import java.net.NetworkInterface;

 35 import java.net.SocketAddress;
 36 import java.net.SocketException;
 37 import java.net.SocketOption;
<span class="line-removed"> 38 import java.net.SocketTimeoutException;</span>
 39 import java.net.StandardSocketOptions;
 40 import java.nio.ByteBuffer;

 41 import java.nio.channels.ClosedChannelException;
 42 import java.nio.channels.DatagramChannel;
<span class="line-modified"> 43 import java.nio.channels.IllegalBlockingModeException;</span>



 44 import java.util.Objects;


 45 

 46 
<span class="line-modified"> 47 // Make a datagram-socket channel look like a datagram socket.</span>
<span class="line-modified"> 48 //</span>
<span class="line-modified"> 49 // The methods in this class are defined in exactly the same order as in</span>
<span class="line-modified"> 50 // java.net.DatagramSocket so as to simplify tracking future changes to that</span>
<span class="line-modified"> 51 // class.</span>
<span class="line-modified"> 52 //</span>
<span class="line-modified"> 53 </span>

 54 public class DatagramSocketAdaptor
<span class="line-modified"> 55     extends DatagramSocket</span>
 56 {
 57     // The channel being adapted
 58     private final DatagramChannelImpl dc;
 59 
 60     // Timeout &quot;option&quot; value for receives
 61     private volatile int timeout;
 62 
<span class="line-removed"> 63     // ## super will create a useless impl</span>
 64     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
<span class="line-modified"> 65         // Invoke the DatagramSocketAdaptor(SocketAddress) constructor,</span>
<span class="line-removed"> 66         // passing a dummy DatagramSocketImpl object to avoid any native</span>
<span class="line-removed"> 67         // resource allocation in super class and invoking our bind method</span>
<span class="line-removed"> 68         // before the dc field is initialized.</span>
<span class="line-removed"> 69         super(dummyDatagramSocket);</span>
 70         this.dc = dc;
 71     }
 72 
<span class="line-modified"> 73     public static DatagramSocket create(DatagramChannelImpl dc) {</span>
 74         try {
 75             return new DatagramSocketAdaptor(dc);
<span class="line-modified"> 76         } catch (IOException x) {</span>
<span class="line-modified"> 77             throw new Error(x);</span>
 78         }
 79     }
 80 
<span class="line-modified"> 81     private void connectInternal(SocketAddress remote)</span>
<span class="line-removed"> 82         throws SocketException</span>
<span class="line-removed"> 83     {</span>
<span class="line-removed"> 84         InetSocketAddress isa = Net.asInetSocketAddress(remote);</span>
<span class="line-removed"> 85         int port = isa.getPort();</span>
<span class="line-removed"> 86         if (port &lt; 0 || port &gt; 0xFFFF)</span>
<span class="line-removed"> 87             throw new IllegalArgumentException(&quot;connect: &quot; + port);</span>
<span class="line-removed"> 88         if (remote == null)</span>
<span class="line-removed"> 89             throw new IllegalArgumentException(&quot;connect: null address&quot;);</span>
 90         try {
<span class="line-modified"> 91             dc.connect(remote);</span>
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 

 99     public void bind(SocketAddress local) throws SocketException {





100         try {
<span class="line-removed">101             if (local == null)</span>
<span class="line-removed">102                 local = new InetSocketAddress(0);</span>
103             dc.bind(local);
104         } catch (Exception x) {
105             Net.translateToSocketException(x);
106         }
107     }
108 

109     public void connect(InetAddress address, int port) {


110         try {
111             connectInternal(new InetSocketAddress(address, port));
112         } catch (SocketException x) {
<span class="line-modified">113             // Yes, j.n.DatagramSocket really does this</span>
114         }
115     }
116 

117     public void connect(SocketAddress remote) throws SocketException {
<span class="line-modified">118         Objects.requireNonNull(remote, &quot;Address can&#39;t be null&quot;);</span>
<span class="line-modified">119         connectInternal(remote);</span>

120     }
121 

122     public void disconnect() {
123         try {
124             dc.disconnect();
125         } catch (IOException x) {
<span class="line-modified">126             throw new Error(x);</span>
127         }
128     }
129 

130     public boolean isBound() {
131         return dc.localAddress() != null;
132     }
133 

134     public boolean isConnected() {
135         return dc.remoteAddress() != null;
136     }
137 

138     public InetAddress getInetAddress() {
139         InetSocketAddress remote = dc.remoteAddress();
140         return (remote != null) ? remote.getAddress() : null;
141     }
142 

143     public int getPort() {
144         InetSocketAddress remote = dc.remoteAddress();
145         return (remote != null) ? remote.getPort() : -1;
146     }
147 
<span class="line-modified">148     public void send(DatagramPacket p) throws IOException {</span>
<span class="line-modified">149         synchronized (dc.blockingLock()) {</span>
<span class="line-modified">150             if (!dc.isBlocking())</span>
<span class="line-removed">151                 throw new IllegalBlockingModeException();</span>
<span class="line-removed">152             try {</span>
<span class="line-removed">153                 synchronized (p) {</span>
<span class="line-removed">154                     ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="line-removed">155                                                     p.getOffset(),</span>
<span class="line-removed">156                                                     p.getLength());</span>
<span class="line-removed">157                     if (dc.isConnected()) {</span>
<span class="line-removed">158                         if (p.getAddress() == null) {</span>
<span class="line-removed">159                             // Legacy DatagramSocket will send in this case</span>
<span class="line-removed">160                             // and set address and port of the packet</span>
<span class="line-removed">161                             InetSocketAddress isa = dc.remoteAddress();</span>
<span class="line-removed">162                             p.setPort(isa.getPort());</span>
<span class="line-removed">163                             p.setAddress(isa.getAddress());</span>
<span class="line-removed">164                             dc.write(bb);</span>
<span class="line-removed">165                         } else {</span>
<span class="line-removed">166                             // Target address may not match connected address</span>
<span class="line-removed">167                             dc.send(bb, p.getSocketAddress());</span>
<span class="line-removed">168                         }</span>
<span class="line-removed">169                     } else {</span>
<span class="line-removed">170                         // Not connected so address must be valid or throw</span>
<span class="line-removed">171                         dc.send(bb, p.getSocketAddress());</span>
<span class="line-removed">172                     }</span>
<span class="line-removed">173                 }</span>
<span class="line-removed">174             } catch (IOException x) {</span>
<span class="line-removed">175                 Net.translateException(x);</span>
<span class="line-removed">176             }</span>
<span class="line-removed">177         }</span>
178     }
179 
<span class="line-modified">180     private SocketAddress receive(ByteBuffer bb) throws IOException {</span>
<span class="line-modified">181         assert Thread.holdsLock(dc.blockingLock()) &amp;&amp; dc.isBlocking();</span>








182 
<span class="line-modified">183         long to = this.timeout;</span>
<span class="line-modified">184         if (to == 0) {</span>
<span class="line-modified">185             return dc.receive(bb);</span>
<span class="line-modified">186         } else {</span>
<span class="line-modified">187             for (;;) {</span>
<span class="line-modified">188                 if (!dc.isOpen())</span>
<span class="line-modified">189                     throw new ClosedChannelException();</span>
<span class="line-modified">190                 long st = System.currentTimeMillis();</span>
<span class="line-modified">191                 if (dc.pollRead(to)) {</span>
<span class="line-modified">192                     return dc.receive(bb);</span>
















193                 }
<span class="line-modified">194                 to -= System.currentTimeMillis() - st;</span>
<span class="line-modified">195                 if (to &lt;= 0)</span>
<span class="line-modified">196                     throw new SocketTimeoutException();</span>











197             }
198         }
199     }
200 

201     public void receive(DatagramPacket p) throws IOException {
<span class="line-modified">202         synchronized (dc.blockingLock()) {</span>
<span class="line-modified">203             if (!dc.isBlocking())</span>
<span class="line-modified">204                 throw new IllegalBlockingModeException();</span>
<span class="line-modified">205             try {</span>
<span class="line-modified">206                 synchronized (p) {</span>
<span class="line-modified">207                     ByteBuffer bb = ByteBuffer.wrap(p.getData(),</span>
<span class="line-modified">208                                                     p.getOffset(),</span>
<span class="line-modified">209                                                     p.getLength());</span>
<span class="line-modified">210                     SocketAddress sender = receive(bb);</span>
<span class="line-modified">211                     p.setSocketAddress(sender);</span>
<span class="line-modified">212                     p.setLength(bb.position() - p.getOffset());</span>
<span class="line-modified">213                 }</span>
<span class="line-modified">214             } catch (IOException x) {</span>
<span class="line-modified">215                 Net.translateException(x);</span>

216             }






217         }
218     }
219 

220     public InetAddress getLocalAddress() {
221         if (isClosed())
222             return null;
223         InetSocketAddress local = dc.localAddress();
224         if (local == null)
225             local = new InetSocketAddress(0);
226         InetAddress result = local.getAddress();
227         SecurityManager sm = System.getSecurityManager();
228         if (sm != null) {
229             try {
230                 sm.checkConnect(result.getHostAddress(), -1);
231             } catch (SecurityException x) {
232                 return new InetSocketAddress(0).getAddress();
233             }
234         }
235         return result;
236     }
237 

238     public int getLocalPort() {
239         if (isClosed())
240             return -1;
<span class="line-modified">241         try {</span>
<span class="line-modified">242             InetSocketAddress local = dc.localAddress();</span>
<span class="line-modified">243             if (local != null) {</span>
<span class="line-removed">244                 return local.getPort();</span>
<span class="line-removed">245             }</span>
<span class="line-removed">246         } catch (Exception x) {</span>
247         }
248         return 0;
249     }
250 

251     public void setSoTimeout(int timeout) throws SocketException {




252         this.timeout = timeout;
253     }
254 

255     public int getSoTimeout() throws SocketException {


256         return timeout;
257     }
258 
259     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
260         throws SocketException
261     {
262         try {
263             dc.setOption(name, value);
264         } catch (IOException x) {
265             Net.translateToSocketException(x);
266         }
267     }
268 
269     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
270         throws SocketException
271     {
272         try {
273             dc.setOption(name, value);
274         } catch (IOException x) {
275             Net.translateToSocketException(x);
</pre>
<hr />
<pre>
277     }
278 
279     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
280         try {
281             return dc.getOption(name).booleanValue();
282         } catch (IOException x) {
283             Net.translateToSocketException(x);
284             return false;       // keep compiler happy
285         }
286     }
287 
288     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
289         try {
290             return dc.getOption(name).intValue();
291         } catch (IOException x) {
292             Net.translateToSocketException(x);
293             return -1;          // keep compiler happy
294         }
295     }
296 

297     public void setSendBufferSize(int size) throws SocketException {
298         if (size &lt;= 0)
299             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
300         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
301     }
302 

303     public int getSendBufferSize() throws SocketException {
304         return getIntOption(StandardSocketOptions.SO_SNDBUF);
305     }
306 

307     public void setReceiveBufferSize(int size) throws SocketException {
308         if (size &lt;= 0)
309             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
310         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
311     }
312 

313     public int getReceiveBufferSize() throws SocketException {
314         return getIntOption(StandardSocketOptions.SO_RCVBUF);
315     }
316 

317     public void setReuseAddress(boolean on) throws SocketException {
318         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
319     }
320 

321     public boolean getReuseAddress() throws SocketException {
322         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
<span class="line-removed">323 </span>
324     }
325 

326     public void setBroadcast(boolean on) throws SocketException {
327         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
328     }
329 

330     public boolean getBroadcast() throws SocketException {
331         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
332     }
333 

334     public void setTrafficClass(int tc) throws SocketException {
335         setIntOption(StandardSocketOptions.IP_TOS, tc);
336     }
337 

338     public int getTrafficClass() throws SocketException {
339         return getIntOption(StandardSocketOptions.IP_TOS);
340     }
341 

342     public void close() {
343         try {
344             dc.close();
345         } catch (IOException x) {
346             throw new Error(x);
347         }
348     }
349 

350     public boolean isClosed() {
351         return !dc.isOpen();
352     }
353 

354     public DatagramChannel getChannel() {
355         return dc;
356     }
357 
<span class="line-modified">358    /*</span>
<span class="line-modified">359     * A dummy implementation of DatagramSocketImpl that can be passed to the</span>
<span class="line-modified">360     * DatagramSocket constructor so that no native resources are allocated in</span>
<span class="line-modified">361     * super class.</span>
<span class="line-modified">362     */</span>
<span class="line-removed">363    private static final DatagramSocketImpl dummyDatagramSocket</span>
<span class="line-removed">364        = new DatagramSocketImpl()</span>
<span class="line-removed">365    {</span>
<span class="line-removed">366        protected void create() throws SocketException {}</span>
367 
<span class="line-modified">368        protected void bind(int lport, InetAddress laddr) throws SocketException {}</span>



369 
<span class="line-modified">370        protected void send(DatagramPacket p) throws IOException {}</span>



371 
<span class="line-modified">372        protected int peek(InetAddress i) throws IOException { return 0; }</span>
373 
<span class="line-modified">374        protected int peekData(DatagramPacket p) throws IOException { return 0; }</span>

375 
<span class="line-modified">376        protected void receive(DatagramPacket p) throws IOException {}</span>



377 
<span class="line-modified">378        @Deprecated</span>
<span class="line-modified">379        protected void setTTL(byte ttl) throws IOException {}</span>



380 
<span class="line-modified">381        @Deprecated</span>
<span class="line-modified">382        protected byte getTTL() throws IOException { return 0; }</span>







383 
<span class="line-modified">384        protected void setTimeToLive(int ttl) throws IOException {}</span>




385 
<span class="line-modified">386        protected int getTimeToLive() throws IOException { return 0;}</span>








387 
<span class="line-modified">388        protected void join(InetAddress inetaddr) throws IOException {}</span>










389 
<span class="line-modified">390        protected void leave(InetAddress inetaddr) throws IOException {}</span>










391 
<span class="line-modified">392        protected void joinGroup(SocketAddress mcastaddr,</span>
<span class="line-modified">393                                  NetworkInterface netIf) throws IOException {}</span>

































































































































394 
<span class="line-modified">395        protected void leaveGroup(SocketAddress mcastaddr,</span>
<span class="line-modified">396                                  NetworkInterface netIf) throws IOException {}</span>























































































397 
<span class="line-modified">398        protected void close() {}</span>








399 
<span class="line-modified">400        public Object getOption(int optID) throws SocketException { return null;}</span>


















401 
<span class="line-modified">402        public void setOption(int optID, Object value) throws SocketException {}</span>
<span class="line-modified">403    };</span>
<span class="line-modified">404 }</span>




















</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
<span class="line-added"> 29 import java.io.UncheckedIOException;</span>
<span class="line-added"> 30 import java.lang.invoke.MethodHandle;</span>
<span class="line-added"> 31 import java.lang.invoke.MethodHandles;</span>
<span class="line-added"> 32 import java.lang.invoke.MethodHandles.Lookup;</span>
<span class="line-added"> 33 import java.lang.invoke.MethodType;</span>
<span class="line-added"> 34 import java.lang.invoke.VarHandle;</span>
 35 import java.net.DatagramPacket;
 36 import java.net.DatagramSocket;

 37 import java.net.InetAddress;
 38 import java.net.InetSocketAddress;
 39 import java.net.NetworkInterface;
<span class="line-added"> 40 import java.net.MulticastSocket;</span>
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketOption;

 44 import java.net.StandardSocketOptions;
 45 import java.nio.ByteBuffer;
<span class="line-added"> 46 import java.nio.channels.AlreadyConnectedException;</span>
 47 import java.nio.channels.ClosedChannelException;
 48 import java.nio.channels.DatagramChannel;
<span class="line-modified"> 49 import java.nio.channels.MembershipKey;</span>
<span class="line-added"> 50 import java.security.AccessController;</span>
<span class="line-added"> 51 import java.security.PrivilegedAction;</span>
<span class="line-added"> 52 import java.security.PrivilegedExceptionAction;</span>
 53 import java.util.Objects;
<span class="line-added"> 54 import java.util.Set;</span>
<span class="line-added"> 55 import java.util.concurrent.locks.ReentrantLock;</span>
 56 
<span class="line-added"> 57 import static java.util.concurrent.TimeUnit.MILLISECONDS;</span>
 58 
<span class="line-modified"> 59 /**</span>
<span class="line-modified"> 60  * A multicast datagram socket based on a datagram channel.</span>
<span class="line-modified"> 61  *</span>
<span class="line-modified"> 62  * This class overrides every public method defined by java.net.DatagramSocket</span>
<span class="line-modified"> 63  * and java.net.MulticastSocket. The methods in this class are defined in exactly</span>
<span class="line-modified"> 64  * the same order as in java.net.DatagramSocket and java.net.MulticastSocket so</span>
<span class="line-modified"> 65  * as to simplify tracking changes.</span>
<span class="line-added"> 66  */</span>
 67 public class DatagramSocketAdaptor
<span class="line-modified"> 68     extends MulticastSocket</span>
 69 {
 70     // The channel being adapted
 71     private final DatagramChannelImpl dc;
 72 
 73     // Timeout &quot;option&quot; value for receives
 74     private volatile int timeout;
 75 

 76     private DatagramSocketAdaptor(DatagramChannelImpl dc) throws IOException {
<span class="line-modified"> 77         super(/*SocketAddress*/null);</span>




 78         this.dc = dc;
 79     }
 80 
<span class="line-modified"> 81     static DatagramSocket create(DatagramChannelImpl dc) {</span>
 82         try {
 83             return new DatagramSocketAdaptor(dc);
<span class="line-modified"> 84         } catch (IOException e) {</span>
<span class="line-modified"> 85             throw new Error(e);</span>
 86         }
 87     }
 88 
<span class="line-modified"> 89     private void connectInternal(SocketAddress remote) throws SocketException {</span>








 90         try {
<span class="line-modified"> 91             dc.connect(remote, false); // skips check for already connected</span>
 92         } catch (ClosedChannelException e) {
 93             // ignore
 94         } catch (Exception x) {
 95             Net.translateToSocketException(x);
 96         }
 97     }
 98 
<span class="line-added"> 99     @Override</span>
100     public void bind(SocketAddress local) throws SocketException {
<span class="line-added">101         if (local != null) {</span>
<span class="line-added">102             local = Net.asInetSocketAddress(local);</span>
<span class="line-added">103         } else {</span>
<span class="line-added">104             local = new InetSocketAddress(0);</span>
<span class="line-added">105         }</span>
106         try {


107             dc.bind(local);
108         } catch (Exception x) {
109             Net.translateToSocketException(x);
110         }
111     }
112 
<span class="line-added">113     @Override</span>
114     public void connect(InetAddress address, int port) {
<span class="line-added">115         if (address == null)</span>
<span class="line-added">116             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
117         try {
118             connectInternal(new InetSocketAddress(address, port));
119         } catch (SocketException x) {
<span class="line-modified">120             throw new UncheckedIOException(x);</span>
121         }
122     }
123 
<span class="line-added">124     @Override</span>
125     public void connect(SocketAddress remote) throws SocketException {
<span class="line-modified">126         if (remote == null)</span>
<span class="line-modified">127             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);</span>
<span class="line-added">128         connectInternal(Net.asInetSocketAddress(remote));</span>
129     }
130 
<span class="line-added">131     @Override</span>
132     public void disconnect() {
133         try {
134             dc.disconnect();
135         } catch (IOException x) {
<span class="line-modified">136             throw new UncheckedIOException(x);</span>
137         }
138     }
139 
<span class="line-added">140     @Override</span>
141     public boolean isBound() {
142         return dc.localAddress() != null;
143     }
144 
<span class="line-added">145     @Override</span>
146     public boolean isConnected() {
147         return dc.remoteAddress() != null;
148     }
149 
<span class="line-added">150     @Override</span>
151     public InetAddress getInetAddress() {
152         InetSocketAddress remote = dc.remoteAddress();
153         return (remote != null) ? remote.getAddress() : null;
154     }
155 
<span class="line-added">156     @Override</span>
157     public int getPort() {
158         InetSocketAddress remote = dc.remoteAddress();
159         return (remote != null) ? remote.getPort() : -1;
160     }
161 
<span class="line-modified">162     @Override</span>
<span class="line-modified">163     public SocketAddress getRemoteSocketAddress() {</span>
<span class="line-modified">164         return dc.remoteAddress();</span>



























165     }
166 
<span class="line-modified">167     @Override</span>
<span class="line-modified">168     public SocketAddress getLocalSocketAddress() {</span>
<span class="line-added">169         try {</span>
<span class="line-added">170             return dc.getLocalAddress();</span>
<span class="line-added">171         } catch (ClosedChannelException e) {</span>
<span class="line-added">172             return null;</span>
<span class="line-added">173         } catch (Exception x) {</span>
<span class="line-added">174             throw new Error(x);</span>
<span class="line-added">175         }</span>
<span class="line-added">176     }</span>
177 
<span class="line-modified">178     @Override</span>
<span class="line-modified">179     public void send(DatagramPacket p) throws IOException {</span>
<span class="line-modified">180         ByteBuffer bb = null;</span>
<span class="line-modified">181         try {</span>
<span class="line-modified">182             InetSocketAddress target;</span>
<span class="line-modified">183             synchronized (p) {</span>
<span class="line-modified">184                 // copy bytes to temporary direct buffer</span>
<span class="line-modified">185                 int len = p.getLength();</span>
<span class="line-modified">186                 bb = Util.getTemporaryDirectBuffer(len);</span>
<span class="line-modified">187                 bb.put(p.getData(), p.getOffset(), len);</span>
<span class="line-added">188                 bb.flip();</span>
<span class="line-added">189 </span>
<span class="line-added">190                 // target address</span>
<span class="line-added">191                 if (p.getAddress() == null) {</span>
<span class="line-added">192                     InetSocketAddress remote = dc.remoteAddress();</span>
<span class="line-added">193                     if (remote == null) {</span>
<span class="line-added">194                         // not specified by DatagramSocket</span>
<span class="line-added">195                         throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">196                     }</span>
<span class="line-added">197                     // set address/port to maintain compatibility with DatagramSocket</span>
<span class="line-added">198                     p.setAddress(remote.getAddress());</span>
<span class="line-added">199                     p.setPort(remote.getPort());</span>
<span class="line-added">200                     target = remote;</span>
<span class="line-added">201                 } else {</span>
<span class="line-added">202                     // throws IllegalArgumentException if port not set</span>
<span class="line-added">203                     target = (InetSocketAddress) p.getSocketAddress();</span>
204                 }
<span class="line-modified">205             }</span>
<span class="line-modified">206             // send datagram</span>
<span class="line-modified">207             try {</span>
<span class="line-added">208                 dc.blockingSend(bb, target);</span>
<span class="line-added">209             } catch (AlreadyConnectedException e) {</span>
<span class="line-added">210                 throw new IllegalArgumentException(&quot;Connected and packet address differ&quot;);</span>
<span class="line-added">211             } catch (ClosedChannelException e) {</span>
<span class="line-added">212                 var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">213                 exc.initCause(e);</span>
<span class="line-added">214                 throw exc;</span>
<span class="line-added">215             }</span>
<span class="line-added">216         } finally {</span>
<span class="line-added">217             if (bb != null) {</span>
<span class="line-added">218                 Util.offerFirstTemporaryDirectBuffer(bb);</span>
219             }
220         }
221     }
222 
<span class="line-added">223     @Override</span>
224     public void receive(DatagramPacket p) throws IOException {
<span class="line-modified">225         // get temporary direct buffer with a capacity of p.bufLength</span>
<span class="line-modified">226         int bufLength = DatagramPackets.getBufLength(p);</span>
<span class="line-modified">227         ByteBuffer bb = Util.getTemporaryDirectBuffer(bufLength);</span>
<span class="line-modified">228         try {</span>
<span class="line-modified">229             long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-modified">230             SocketAddress sender = dc.blockingReceive(bb, nanos);</span>
<span class="line-modified">231             bb.flip();</span>
<span class="line-modified">232             synchronized (p) {</span>
<span class="line-modified">233                 // copy bytes to the DatagramPacket and set length</span>
<span class="line-modified">234                 int len = Math.min(bb.limit(), DatagramPackets.getBufLength(p));</span>
<span class="line-modified">235                 bb.get(p.getData(), p.getOffset(), len);</span>
<span class="line-modified">236                 DatagramPackets.setLength(p, len);</span>
<span class="line-modified">237 </span>
<span class="line-modified">238                 // sender address</span>
<span class="line-added">239                 p.setSocketAddress(sender);</span>
240             }
<span class="line-added">241         } catch (ClosedChannelException e) {</span>
<span class="line-added">242             var exc = new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">243             exc.initCause(e);</span>
<span class="line-added">244             throw exc;</span>
<span class="line-added">245         } finally {</span>
<span class="line-added">246             Util.offerFirstTemporaryDirectBuffer(bb);</span>
247         }
248     }
249 
<span class="line-added">250     @Override</span>
251     public InetAddress getLocalAddress() {
252         if (isClosed())
253             return null;
254         InetSocketAddress local = dc.localAddress();
255         if (local == null)
256             local = new InetSocketAddress(0);
257         InetAddress result = local.getAddress();
258         SecurityManager sm = System.getSecurityManager();
259         if (sm != null) {
260             try {
261                 sm.checkConnect(result.getHostAddress(), -1);
262             } catch (SecurityException x) {
263                 return new InetSocketAddress(0).getAddress();
264             }
265         }
266         return result;
267     }
268 
<span class="line-added">269     @Override</span>
270     public int getLocalPort() {
271         if (isClosed())
272             return -1;
<span class="line-modified">273         InetSocketAddress local = dc.localAddress();</span>
<span class="line-modified">274         if (local != null) {</span>
<span class="line-modified">275             return local.getPort();</span>



276         }
277         return 0;
278     }
279 
<span class="line-added">280     @Override</span>
281     public void setSoTimeout(int timeout) throws SocketException {
<span class="line-added">282         if (isClosed())</span>
<span class="line-added">283             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">284         if (timeout &lt; 0)</span>
<span class="line-added">285             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
286         this.timeout = timeout;
287     }
288 
<span class="line-added">289     @Override</span>
290     public int getSoTimeout() throws SocketException {
<span class="line-added">291         if (isClosed())</span>
<span class="line-added">292             throw new SocketException(&quot;Socket is closed&quot;);</span>
293         return timeout;
294     }
295 
296     private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
297         throws SocketException
298     {
299         try {
300             dc.setOption(name, value);
301         } catch (IOException x) {
302             Net.translateToSocketException(x);
303         }
304     }
305 
306     private void setIntOption(SocketOption&lt;Integer&gt; name, int value)
307         throws SocketException
308     {
309         try {
310             dc.setOption(name, value);
311         } catch (IOException x) {
312             Net.translateToSocketException(x);
</pre>
<hr />
<pre>
314     }
315 
316     private boolean getBooleanOption(SocketOption&lt;Boolean&gt; name) throws SocketException {
317         try {
318             return dc.getOption(name).booleanValue();
319         } catch (IOException x) {
320             Net.translateToSocketException(x);
321             return false;       // keep compiler happy
322         }
323     }
324 
325     private int getIntOption(SocketOption&lt;Integer&gt; name) throws SocketException {
326         try {
327             return dc.getOption(name).intValue();
328         } catch (IOException x) {
329             Net.translateToSocketException(x);
330             return -1;          // keep compiler happy
331         }
332     }
333 
<span class="line-added">334     @Override</span>
335     public void setSendBufferSize(int size) throws SocketException {
336         if (size &lt;= 0)
337             throw new IllegalArgumentException(&quot;Invalid send size&quot;);
338         setIntOption(StandardSocketOptions.SO_SNDBUF, size);
339     }
340 
<span class="line-added">341     @Override</span>
342     public int getSendBufferSize() throws SocketException {
343         return getIntOption(StandardSocketOptions.SO_SNDBUF);
344     }
345 
<span class="line-added">346     @Override</span>
347     public void setReceiveBufferSize(int size) throws SocketException {
348         if (size &lt;= 0)
349             throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
350         setIntOption(StandardSocketOptions.SO_RCVBUF, size);
351     }
352 
<span class="line-added">353     @Override</span>
354     public int getReceiveBufferSize() throws SocketException {
355         return getIntOption(StandardSocketOptions.SO_RCVBUF);
356     }
357 
<span class="line-added">358     @Override</span>
359     public void setReuseAddress(boolean on) throws SocketException {
360         setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
361     }
362 
<span class="line-added">363     @Override</span>
364     public boolean getReuseAddress() throws SocketException {
365         return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);

366     }
367 
<span class="line-added">368     @Override</span>
369     public void setBroadcast(boolean on) throws SocketException {
370         setBooleanOption(StandardSocketOptions.SO_BROADCAST, on);
371     }
372 
<span class="line-added">373     @Override</span>
374     public boolean getBroadcast() throws SocketException {
375         return getBooleanOption(StandardSocketOptions.SO_BROADCAST);
376     }
377 
<span class="line-added">378     @Override</span>
379     public void setTrafficClass(int tc) throws SocketException {
380         setIntOption(StandardSocketOptions.IP_TOS, tc);
381     }
382 
<span class="line-added">383     @Override</span>
384     public int getTrafficClass() throws SocketException {
385         return getIntOption(StandardSocketOptions.IP_TOS);
386     }
387 
<span class="line-added">388     @Override</span>
389     public void close() {
390         try {
391             dc.close();
392         } catch (IOException x) {
393             throw new Error(x);
394         }
395     }
396 
<span class="line-added">397     @Override</span>
398     public boolean isClosed() {
399         return !dc.isOpen();
400     }
401 
<span class="line-added">402     @Override</span>
403     public DatagramChannel getChannel() {
404         return dc;
405     }
406 
<span class="line-modified">407     @Override</span>
<span class="line-modified">408     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-modified">409         dc.setOption(name, value);</span>
<span class="line-modified">410         return this;</span>
<span class="line-modified">411     }</span>




412 
<span class="line-modified">413     @Override</span>
<span class="line-added">414     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">415         return dc.getOption(name);</span>
<span class="line-added">416     }</span>
417 
<span class="line-modified">418     @Override</span>
<span class="line-added">419     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">420         return dc.supportedOptions();</span>
<span class="line-added">421     }</span>
422 
<span class="line-modified">423     // -- java.net.MulticastSocket --</span>
424 
<span class="line-modified">425     // used to coordinate changing TTL with the deprecated send method</span>
<span class="line-added">426     private final ReentrantLock sendLock = new ReentrantLock();</span>
427 
<span class="line-modified">428     // cached outgoing interface (for use by setInterface/getInterface)</span>
<span class="line-added">429     private final Object outgoingInterfaceLock = new Object();</span>
<span class="line-added">430     private NetworkInterface outgoingNetworkInterface;</span>
<span class="line-added">431     private InetAddress outgoingInetAddress;</span>
432 
<span class="line-modified">433     @Override</span>
<span class="line-modified">434     @Deprecated</span>
<span class="line-added">435     public void setTTL(byte ttl) throws IOException {</span>
<span class="line-added">436         setTimeToLive(Byte.toUnsignedInt(ttl));</span>
<span class="line-added">437     }</span>
438 
<span class="line-modified">439     @Override</span>
<span class="line-modified">440     public void setTimeToLive(int ttl) throws IOException {</span>
<span class="line-added">441         sendLock.lock();</span>
<span class="line-added">442         try {</span>
<span class="line-added">443             setIntOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);</span>
<span class="line-added">444         } finally {</span>
<span class="line-added">445             sendLock.unlock();</span>
<span class="line-added">446         }</span>
<span class="line-added">447     }</span>
448 
<span class="line-modified">449     @Override</span>
<span class="line-added">450     @Deprecated</span>
<span class="line-added">451     public byte getTTL() throws IOException {</span>
<span class="line-added">452         return (byte) getTimeToLive();</span>
<span class="line-added">453     }</span>
454 
<span class="line-modified">455     @Override</span>
<span class="line-added">456     public int getTimeToLive() throws IOException {</span>
<span class="line-added">457         sendLock.lock();</span>
<span class="line-added">458         try {</span>
<span class="line-added">459             return getIntOption(StandardSocketOptions.IP_MULTICAST_TTL);</span>
<span class="line-added">460         } finally {</span>
<span class="line-added">461             sendLock.unlock();</span>
<span class="line-added">462         }</span>
<span class="line-added">463     }</span>
464 
<span class="line-modified">465     @Override</span>
<span class="line-added">466     @Deprecated</span>
<span class="line-added">467     public void joinGroup(InetAddress group) throws IOException {</span>
<span class="line-added">468         Objects.requireNonNull(group);</span>
<span class="line-added">469         try {</span>
<span class="line-added">470             joinGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">471         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">472             // 1-arg joinGroup does not specify IllegalArgumentException</span>
<span class="line-added">473             throw (SocketException) new SocketException(&quot;joinGroup failed&quot;).initCause(iae);</span>
<span class="line-added">474         }</span>
<span class="line-added">475     }</span>
476 
<span class="line-modified">477     @Override</span>
<span class="line-added">478     @Deprecated</span>
<span class="line-added">479     public void leaveGroup(InetAddress group) throws IOException {</span>
<span class="line-added">480         Objects.requireNonNull(group);</span>
<span class="line-added">481         try {</span>
<span class="line-added">482             leaveGroup(new InetSocketAddress(group, 0), null);</span>
<span class="line-added">483         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">484             // 1-arg leaveGroup does not specify IllegalArgumentException</span>
<span class="line-added">485             throw (SocketException) new SocketException(&quot;leaveGroup failed&quot;).initCause(iae);</span>
<span class="line-added">486         }</span>
<span class="line-added">487     }</span>
488 
<span class="line-modified">489     /**</span>
<span class="line-modified">490      * Checks a SocketAddress to ensure that it is a multicast address.</span>
<span class="line-added">491      *</span>
<span class="line-added">492      * @return the multicast group</span>
<span class="line-added">493      * @throws IllegalArgumentException if group is null, an unsupported address</span>
<span class="line-added">494      *         type, or an unresolved address</span>
<span class="line-added">495      * @throws SocketException if group is not a multicast address</span>
<span class="line-added">496      */</span>
<span class="line-added">497     private static InetAddress checkGroup(SocketAddress mcastaddr) throws SocketException {</span>
<span class="line-added">498         if (mcastaddr == null || !(mcastaddr instanceof InetSocketAddress))</span>
<span class="line-added">499             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);</span>
<span class="line-added">500         InetAddress group = ((InetSocketAddress) mcastaddr).getAddress();</span>
<span class="line-added">501         if (group == null)</span>
<span class="line-added">502             throw new IllegalArgumentException(&quot;Unresolved address&quot;);</span>
<span class="line-added">503         if (!group.isMulticastAddress())</span>
<span class="line-added">504             throw new SocketException(&quot;Not a multicast address&quot;);</span>
<span class="line-added">505         return group;</span>
<span class="line-added">506     }</span>
<span class="line-added">507 </span>
<span class="line-added">508     @Override</span>
<span class="line-added">509     public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">510         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">511         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">512         if (isClosed())</span>
<span class="line-added">513             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">514         synchronized (this) {</span>
<span class="line-added">515             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">516             if (key != null) {</span>
<span class="line-added">517                 // already a member but need to check permission anyway</span>
<span class="line-added">518                 SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">519                 if (sm != null)</span>
<span class="line-added">520                     sm.checkMulticast(group);</span>
<span class="line-added">521                 throw new SocketException(&quot;Already a member of group&quot;);</span>
<span class="line-added">522             }</span>
<span class="line-added">523             dc.join(group, ni);  // checks permission</span>
<span class="line-added">524         }</span>
<span class="line-added">525     }</span>
<span class="line-added">526 </span>
<span class="line-added">527     @Override</span>
<span class="line-added">528     public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {</span>
<span class="line-added">529         InetAddress group = checkGroup(mcastaddr);</span>
<span class="line-added">530         NetworkInterface ni = (netIf != null) ? netIf : defaultNetworkInterface();</span>
<span class="line-added">531         if (isClosed())</span>
<span class="line-added">532             throw new SocketException(&quot;Socket is closed&quot;);</span>
<span class="line-added">533         SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">534         if (sm != null)</span>
<span class="line-added">535             sm.checkMulticast(group);</span>
<span class="line-added">536         synchronized (this) {</span>
<span class="line-added">537             MembershipKey key = dc.findMembership(group, ni);</span>
<span class="line-added">538             if (key == null)</span>
<span class="line-added">539                 throw new SocketException(&quot;Not a member of group&quot;);</span>
<span class="line-added">540             key.drop();</span>
<span class="line-added">541         }</span>
<span class="line-added">542     }</span>
<span class="line-added">543 </span>
<span class="line-added">544     @Override</span>
<span class="line-added">545     @Deprecated</span>
<span class="line-added">546     public void setInterface(InetAddress inf) throws SocketException {</span>
<span class="line-added">547         if (inf == null)</span>
<span class="line-added">548             throw new SocketException(&quot;Invalid value &#39;null&#39;&quot;);</span>
<span class="line-added">549         NetworkInterface ni = NetworkInterface.getByInetAddress(inf);</span>
<span class="line-added">550         if (ni == null) {</span>
<span class="line-added">551             String address = inf.getHostAddress();</span>
<span class="line-added">552             throw new SocketException(&quot;No network interface with address &quot; + address);</span>
<span class="line-added">553         }</span>
<span class="line-added">554         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">555             // set interface and update cached values</span>
<span class="line-added">556             setNetworkInterface(ni);</span>
<span class="line-added">557             outgoingNetworkInterface = ni;</span>
<span class="line-added">558             outgoingInetAddress = inf;</span>
<span class="line-added">559         }</span>
<span class="line-added">560     }</span>
<span class="line-added">561 </span>
<span class="line-added">562     @Override</span>
<span class="line-added">563     @Deprecated</span>
<span class="line-added">564     public InetAddress getInterface() throws SocketException {</span>
<span class="line-added">565         synchronized (outgoingInterfaceLock) {</span>
<span class="line-added">566             NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">567             if (ni != null) {</span>
<span class="line-added">568                 if (ni.equals(outgoingNetworkInterface)) {</span>
<span class="line-added">569                     return outgoingInetAddress;</span>
<span class="line-added">570                 } else {</span>
<span class="line-added">571                     // network interface has changed so update cached values</span>
<span class="line-added">572                     PrivilegedAction&lt;InetAddress&gt; pa;</span>
<span class="line-added">573                     pa = () -&gt; ni.inetAddresses().findFirst().orElse(null);</span>
<span class="line-added">574                     InetAddress ia = AccessController.doPrivileged(pa);</span>
<span class="line-added">575                     if (ia == null)</span>
<span class="line-added">576                         throw new SocketException(&quot;Network interface has no IP address&quot;);</span>
<span class="line-added">577                     outgoingNetworkInterface = ni;</span>
<span class="line-added">578                     outgoingInetAddress = ia;</span>
<span class="line-added">579                     return ia;</span>
<span class="line-added">580                 }</span>
<span class="line-added">581             }</span>
<span class="line-added">582         }</span>
<span class="line-added">583 </span>
<span class="line-added">584         // no interface set</span>
<span class="line-added">585         return anyInetAddress();</span>
<span class="line-added">586     }</span>
<span class="line-added">587 </span>
<span class="line-added">588     @Override</span>
<span class="line-added">589     public void setNetworkInterface(NetworkInterface netIf) throws SocketException {</span>
<span class="line-added">590         try {</span>
<span class="line-added">591             setOption(StandardSocketOptions.IP_MULTICAST_IF, netIf);</span>
<span class="line-added">592         } catch (IOException e) {</span>
<span class="line-added">593             Net.translateToSocketException(e);</span>
<span class="line-added">594         }</span>
<span class="line-added">595     }</span>
<span class="line-added">596 </span>
<span class="line-added">597     @Override</span>
<span class="line-added">598     public NetworkInterface getNetworkInterface() throws SocketException {</span>
<span class="line-added">599         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">600         if (ni == null) {</span>
<span class="line-added">601             // return NetworkInterface with index == 0 as placeholder</span>
<span class="line-added">602             ni = anyNetworkInterface();</span>
<span class="line-added">603         }</span>
<span class="line-added">604         return ni;</span>
<span class="line-added">605     }</span>
<span class="line-added">606 </span>
<span class="line-added">607     @Override</span>
<span class="line-added">608     @Deprecated</span>
<span class="line-added">609     public void setLoopbackMode(boolean disable) throws SocketException {</span>
<span class="line-added">610         boolean enable = !disable;</span>
<span class="line-added">611         setBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP, enable);</span>
<span class="line-added">612     }</span>
<span class="line-added">613 </span>
<span class="line-added">614     @Override</span>
<span class="line-added">615     @Deprecated</span>
<span class="line-added">616     public boolean getLoopbackMode() throws SocketException {</span>
<span class="line-added">617         boolean enabled = getBooleanOption(StandardSocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">618         return !enabled;</span>
<span class="line-added">619     }</span>
620 
<span class="line-modified">621     @Override</span>
<span class="line-modified">622     @Deprecated</span>
<span class="line-added">623     public void send(DatagramPacket p, byte ttl) throws IOException {</span>
<span class="line-added">624         sendLock.lock();</span>
<span class="line-added">625         try {</span>
<span class="line-added">626             int oldValue = getTimeToLive();</span>
<span class="line-added">627             try {</span>
<span class="line-added">628                 setTTL(ttl);</span>
<span class="line-added">629                 send(p);</span>
<span class="line-added">630             } finally {</span>
<span class="line-added">631                 setTimeToLive(oldValue);</span>
<span class="line-added">632             }</span>
<span class="line-added">633         } finally {</span>
<span class="line-added">634             sendLock.unlock();</span>
<span class="line-added">635         }</span>
<span class="line-added">636     }</span>
<span class="line-added">637 </span>
<span class="line-added">638     /**</span>
<span class="line-added">639      * Returns the outgoing NetworkInterface or null if not set.</span>
<span class="line-added">640      */</span>
<span class="line-added">641     private NetworkInterface outgoingNetworkInterface() throws SocketException {</span>
<span class="line-added">642         try {</span>
<span class="line-added">643             return getOption(StandardSocketOptions.IP_MULTICAST_IF);</span>
<span class="line-added">644         } catch (IOException e) {</span>
<span class="line-added">645             Net.translateToSocketException(e);</span>
<span class="line-added">646             return null; // keep compiler happy</span>
<span class="line-added">647         }</span>
<span class="line-added">648     }</span>
<span class="line-added">649 </span>
<span class="line-added">650     /**</span>
<span class="line-added">651      * Returns the default NetworkInterface to use when joining or leaving a</span>
<span class="line-added">652      * multicast group and a network interface is not specified.</span>
<span class="line-added">653      * This method will return the outgoing NetworkInterface if set, otherwise</span>
<span class="line-added">654      * the result of NetworkInterface.getDefault(), otherwise a NetworkInterface</span>
<span class="line-added">655      * with index == 0 as a placeholder for &quot;any network interface&quot;.</span>
<span class="line-added">656      */</span>
<span class="line-added">657     private NetworkInterface defaultNetworkInterface() throws SocketException {</span>
<span class="line-added">658         NetworkInterface ni = outgoingNetworkInterface();</span>
<span class="line-added">659         if (ni == null)</span>
<span class="line-added">660             ni = NetworkInterfaces.getDefault();   // macOS</span>
<span class="line-added">661         if (ni == null)</span>
<span class="line-added">662             ni = anyNetworkInterface();</span>
<span class="line-added">663         return ni;</span>
<span class="line-added">664     }</span>
<span class="line-added">665 </span>
<span class="line-added">666     /**</span>
<span class="line-added">667      * Returns the placeholder for &quot;any network interface&quot;, its index is 0.</span>
<span class="line-added">668      */</span>
<span class="line-added">669     private NetworkInterface anyNetworkInterface() {</span>
<span class="line-added">670         InetAddress[] addrs = new InetAddress[1];</span>
<span class="line-added">671         addrs[0] = anyInetAddress();</span>
<span class="line-added">672         return NetworkInterfaces.newNetworkInterface(addrs[0].getHostName(), 0, addrs);</span>
<span class="line-added">673     }</span>
<span class="line-added">674 </span>
<span class="line-added">675     /**</span>
<span class="line-added">676      * Returns the InetAddress representing anyLocalAddress.</span>
<span class="line-added">677      */</span>
<span class="line-added">678     private InetAddress anyInetAddress() {</span>
<span class="line-added">679         return new InetSocketAddress(0).getAddress();</span>
<span class="line-added">680     }</span>
<span class="line-added">681 </span>
<span class="line-added">682     /**</span>
<span class="line-added">683      * Defines static methods to get/set DatagramPacket fields and workaround</span>
<span class="line-added">684      * DatagramPacket deficiencies.</span>
<span class="line-added">685      */</span>
<span class="line-added">686     private static class DatagramPackets {</span>
<span class="line-added">687         private static final VarHandle LENGTH;</span>
<span class="line-added">688         private static final VarHandle BUF_LENGTH;</span>
<span class="line-added">689         static {</span>
<span class="line-added">690             try {</span>
<span class="line-added">691                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">692                     MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());</span>
<span class="line-added">693                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">694                 LENGTH = l.findVarHandle(DatagramPacket.class, &quot;length&quot;, int.class);</span>
<span class="line-added">695                 BUF_LENGTH = l.findVarHandle(DatagramPacket.class, &quot;bufLength&quot;, int.class);</span>
<span class="line-added">696             } catch (Exception e) {</span>
<span class="line-added">697                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">698             }</span>
<span class="line-added">699         }</span>
<span class="line-added">700 </span>
<span class="line-added">701         /**</span>
<span class="line-added">702          * Sets the DatagramPacket.length field. DatagramPacket.setLength cannot be</span>
<span class="line-added">703          * used at this time because it sets both the length and bufLength fields.</span>
<span class="line-added">704          */</span>
<span class="line-added">705         static void setLength(DatagramPacket p, int value) {</span>
<span class="line-added">706             synchronized (p) {</span>
<span class="line-added">707                 LENGTH.set(p, value);</span>
<span class="line-added">708             }</span>
<span class="line-added">709         }</span>
710 
<span class="line-modified">711         /**</span>
<span class="line-added">712          * Returns the value of the DatagramPacket.bufLength field.</span>
<span class="line-added">713          */</span>
<span class="line-added">714         static int getBufLength(DatagramPacket p) {</span>
<span class="line-added">715             synchronized (p) {</span>
<span class="line-added">716                 return (int) BUF_LENGTH.get(p);</span>
<span class="line-added">717             }</span>
<span class="line-added">718         }</span>
<span class="line-added">719     }</span>
720 
<span class="line-modified">721     /**</span>
<span class="line-added">722      * Defines static methods to invoke non-public NetworkInterface methods.</span>
<span class="line-added">723      */</span>
<span class="line-added">724     private static class NetworkInterfaces {</span>
<span class="line-added">725         static final MethodHandle GET_DEFAULT;</span>
<span class="line-added">726         static final MethodHandle CONSTRUCTOR;</span>
<span class="line-added">727         static {</span>
<span class="line-added">728             try {</span>
<span class="line-added">729                 PrivilegedExceptionAction&lt;Lookup&gt; pa = () -&gt;</span>
<span class="line-added">730                     MethodHandles.privateLookupIn(NetworkInterface.class, MethodHandles.lookup());</span>
<span class="line-added">731                 MethodHandles.Lookup l = AccessController.doPrivileged(pa);</span>
<span class="line-added">732                 MethodType methodType = MethodType.methodType(NetworkInterface.class);</span>
<span class="line-added">733                 GET_DEFAULT = l.findStatic(NetworkInterface.class, &quot;getDefault&quot;, methodType);</span>
<span class="line-added">734                 methodType = MethodType.methodType(void.class, String.class, int.class, InetAddress[].class);</span>
<span class="line-added">735                 CONSTRUCTOR = l.findConstructor(NetworkInterface.class, methodType);</span>
<span class="line-added">736             } catch (Exception e) {</span>
<span class="line-added">737                 throw new ExceptionInInitializerError(e);</span>
<span class="line-added">738             }</span>
<span class="line-added">739         }</span>
740 
<span class="line-modified">741         /**</span>
<span class="line-modified">742          * Returns the default network interface or null.</span>
<span class="line-modified">743          */</span>
<span class="line-added">744         static NetworkInterface getDefault() {</span>
<span class="line-added">745             try {</span>
<span class="line-added">746                 return (NetworkInterface) GET_DEFAULT.invokeExact();</span>
<span class="line-added">747             } catch (Throwable e) {</span>
<span class="line-added">748                 throw new InternalError(e);</span>
<span class="line-added">749             }</span>
<span class="line-added">750         }</span>
<span class="line-added">751 </span>
<span class="line-added">752         /**</span>
<span class="line-added">753          * Creates a NetworkInterface with the given name index and addresses.</span>
<span class="line-added">754          */</span>
<span class="line-added">755         static NetworkInterface newNetworkInterface(String name, int index, InetAddress[] addrs) {</span>
<span class="line-added">756             try {</span>
<span class="line-added">757                 return (NetworkInterface) CONSTRUCTOR.invoke(name, index, addrs);</span>
<span class="line-added">758             } catch (Throwable e) {</span>
<span class="line-added">759                 throw new InternalError(e);</span>
<span class="line-added">760             }</span>
<span class="line-added">761         }</span>
<span class="line-added">762     }</span>
<span class="line-added">763 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="DatagramChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
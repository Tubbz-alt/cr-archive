<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerSocketChannelImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SocketAdaptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,22 ***</span>
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.Socket;
  import java.net.SocketAddress;
  import java.net.SocketException;
<span class="line-removed">- import java.net.SocketImpl;</span>
  import java.net.SocketOption;
<span class="line-removed">- import java.net.SocketTimeoutException;</span>
  import java.net.StandardSocketOptions;
<span class="line-removed">- import java.nio.ByteBuffer;</span>
<span class="line-removed">- import java.nio.channels.Channels;</span>
<span class="line-removed">- import java.nio.channels.ClosedChannelException;</span>
<span class="line-removed">- import java.nio.channels.IllegalBlockingModeException;</span>
  import java.nio.channels.SocketChannel;
  import java.security.AccessController;
  import java.security.PrivilegedExceptionAction;
<span class="line-modified">! import static java.util.concurrent.TimeUnit.*;</span>
  
  // Make a socket channel look like a socket.
  //
  // The methods in this class are defined in exactly the same order as in
  // java.net.Socket so as to simplify tracking future changes to that class.
<span class="line-new-header">--- 31,19 ---</span>
  import java.net.InetAddress;
  import java.net.InetSocketAddress;
  import java.net.Socket;
  import java.net.SocketAddress;
  import java.net.SocketException;
  import java.net.SocketOption;
  import java.net.StandardSocketOptions;
  import java.nio.channels.SocketChannel;
  import java.security.AccessController;
<span class="line-added">+ import java.security.PrivilegedActionException;</span>
  import java.security.PrivilegedExceptionAction;
<span class="line-modified">! import java.util.Set;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import static java.util.concurrent.TimeUnit.MILLISECONDS;</span>
  
  // Make a socket channel look like a socket.
  //
  // The methods in this class are defined in exactly the same order as in
  // java.net.Socket so as to simplify tracking future changes to that class.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,209 ***</span>
  
      // Timeout &quot;option&quot; value for reads
      private volatile int timeout;
  
      private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
<span class="line-modified">!         super((SocketImpl) null);</span>
          this.sc = sc;
      }
  
<span class="line-modified">!     public static Socket create(SocketChannelImpl sc) {</span>
          try {
<span class="line-modified">!             return new SocketAdaptor(sc);</span>
<span class="line-modified">!         } catch (SocketException e) {</span>
<span class="line-modified">!             throw new InternalError(&quot;Should not reach here&quot;);</span>
          }
      }
  
<span class="line-modified">!     public SocketChannel getChannel() {</span>
<span class="line-removed">-         return sc;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Override this method just to protect against changes in the superclass</span>
<span class="line-removed">-     //</span>
      public void connect(SocketAddress remote) throws IOException {
          connect(remote, 0);
      }
  
      public void connect(SocketAddress remote, int timeout) throws IOException {
          if (remote == null)
              throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
          if (timeout &lt; 0)
              throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!         synchronized (sc.blockingLock()) {</span>
<span class="line-modified">!             if (!sc.isBlocking())</span>
<span class="line-modified">!                 throw new IllegalBlockingModeException();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             try {</span>
<span class="line-removed">-                 // no timeout</span>
<span class="line-removed">-                 if (timeout == 0) {</span>
<span class="line-removed">-                     sc.connect(remote);</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // timed connect</span>
<span class="line-removed">-                 sc.configureBlocking(false);</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     if (sc.connect(remote))</span>
<span class="line-removed">-                         return;</span>
<span class="line-removed">-                 } finally {</span>
<span class="line-removed">-                     try {</span>
<span class="line-removed">-                         sc.configureBlocking(true);</span>
<span class="line-removed">-                     } catch (ClosedChannelException e) { }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 long timeoutNanos = NANOSECONDS.convert(timeout, MILLISECONDS);</span>
<span class="line-removed">-                 long to = timeout;</span>
<span class="line-removed">-                 for (;;) {</span>
<span class="line-removed">-                     long startTime = System.nanoTime();</span>
<span class="line-removed">-                     if (sc.pollConnected(to)) {</span>
<span class="line-removed">-                         boolean connected = sc.finishConnect();</span>
<span class="line-removed">-                         assert connected;</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">-                     if (timeoutNanos &lt;= 0) {</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             sc.close();</span>
<span class="line-removed">-                         } catch (IOException x) { }</span>
<span class="line-removed">-                         throw new SocketTimeoutException();</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             } catch (Exception x) {</span>
<span class="line-removed">-                 Net.translateException(x, true);</span>
              }
          }
<span class="line-removed">- </span>
      }
  
      public void bind(SocketAddress local) throws IOException {
          try {
              sc.bind(local);
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
      public InetAddress getInetAddress() {
          InetSocketAddress remote = sc.remoteAddress();
          if (remote == null) {
              return null;
          } else {
              return remote.getAddress();
          }
      }
  
      public InetAddress getLocalAddress() {
          if (sc.isOpen()) {
              InetSocketAddress local = sc.localAddress();
              if (local != null) {
                  return Net.getRevealedLocalAddress(local).getAddress();
              }
          }
          return new InetSocketAddress(0).getAddress();
      }
  
      public int getPort() {
          InetSocketAddress remote = sc.remoteAddress();
          if (remote == null) {
              return 0;
          } else {
              return remote.getPort();
          }
      }
  
      public int getLocalPort() {
          InetSocketAddress local = sc.localAddress();
          if (local == null) {
              return -1;
          } else {
              return local.getPort();
          }
      }
  
<span class="line-modified">!     private class SocketInputStream</span>
<span class="line-modified">!         extends ChannelInputStream</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         private SocketInputStream() {</span>
<span class="line-removed">-             super(sc);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         protected int read(ByteBuffer bb)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             synchronized (sc.blockingLock()) {</span>
<span class="line-modified">!                 if (!sc.isBlocking())</span>
<span class="line-modified">!                     throw new IllegalBlockingModeException();</span>
<span class="line-modified">! </span>
<span class="line-removed">-                 // no timeout</span>
<span class="line-removed">-                 long to = SocketAdaptor.this.timeout;</span>
<span class="line-removed">-                 if (to == 0)</span>
<span class="line-removed">-                     return sc.read(bb);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // timed read</span>
<span class="line-removed">-                 long timeoutNanos = NANOSECONDS.convert(to, MILLISECONDS);</span>
<span class="line-removed">-                 for (;;) {</span>
<span class="line-removed">-                     long startTime = System.nanoTime();</span>
<span class="line-removed">-                     if (sc.pollRead(to)) {</span>
<span class="line-removed">-                         return sc.read(bb);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     timeoutNanos -= System.nanoTime() - startTime;</span>
<span class="line-removed">-                     if (timeoutNanos &lt;= 0)</span>
<span class="line-removed">-                         throw new SocketTimeoutException();</span>
<span class="line-removed">-                     to = MILLISECONDS.convert(timeoutNanos, NANOSECONDS);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
      }
  
<span class="line-modified">!     private InputStream socketInputStream = null;</span>
  
      public InputStream getInputStream() throws IOException {
          if (!sc.isOpen())
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!sc.isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (!sc.isInputOpen())
              throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!         if (socketInputStream == null) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 socketInputStream = AccessController.doPrivileged(</span>
<span class="line-modified">!                     new PrivilegedExceptionAction&lt;InputStream&gt;() {</span>
<span class="line-modified">!                         public InputStream run() throws IOException {</span>
<span class="line-modified">!                             return new SocketInputStream();</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     });</span>
<span class="line-removed">-             } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-removed">-                 throw (IOException)e.getException();</span>
              }
<span class="line-modified">!         }</span>
<span class="line-modified">!         return socketInputStream;</span>
      }
  
      public OutputStream getOutputStream() throws IOException {
          if (!sc.isOpen())
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!sc.isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (!sc.isOutputOpen())
              throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!         OutputStream os = null;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             os = AccessController.doPrivileged(</span>
<span class="line-modified">!                 new PrivilegedExceptionAction&lt;OutputStream&gt;() {</span>
<span class="line-modified">!                     public OutputStream run() throws IOException {</span>
<span class="line-modified">!                         return Channels.newOutputStream(sc);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 });</span>
<span class="line-modified">!         } catch (java.security.PrivilegedActionException e) {</span>
<span class="line-modified">!             throw (IOException)e.getException();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return os;</span>
      }
  
      private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
          throws SocketException
      {
<span class="line-new-header">--- 57,175 ---</span>
  
      // Timeout &quot;option&quot; value for reads
      private volatile int timeout;
  
      private SocketAdaptor(SocketChannelImpl sc) throws SocketException {
<span class="line-modified">!         super(DummySocketImpl.create());</span>
          this.sc = sc;
      }
  
<span class="line-modified">!     static Socket create(SocketChannelImpl sc) {</span>
<span class="line-added">+         PrivilegedExceptionAction&lt;Socket&gt; pa = () -&gt; new SocketAdaptor(sc);</span>
          try {
<span class="line-modified">!             return AccessController.doPrivileged(pa);</span>
<span class="line-modified">!         } catch (PrivilegedActionException pae) {</span>
<span class="line-modified">!             throw new InternalError(&quot;Should not reach here&quot;, pae);</span>
          }
      }
  
<span class="line-modified">!     @Override</span>
      public void connect(SocketAddress remote) throws IOException {
          connect(remote, 0);
      }
  
<span class="line-added">+     @Override</span>
      public void connect(SocketAddress remote, int timeout) throws IOException {
          if (remote == null)
              throw new IllegalArgumentException(&quot;connect: The address can&#39;t be null&quot;);
          if (timeout &lt; 0)
              throw new IllegalArgumentException(&quot;connect: timeout can&#39;t be negative&quot;);
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (timeout &gt; 0) {</span>
<span class="line-modified">!                 long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-modified">!                 sc.blockingConnect(remote, nanos);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 sc.blockingConnect(remote, Long.MAX_VALUE);</span>
              }
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             Net.translateException(e, true);</span>
          }
      }
  
<span class="line-added">+     @Override</span>
      public void bind(SocketAddress local) throws IOException {
          try {
              sc.bind(local);
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public InetAddress getInetAddress() {
          InetSocketAddress remote = sc.remoteAddress();
          if (remote == null) {
              return null;
          } else {
              return remote.getAddress();
          }
      }
  
<span class="line-added">+     @Override</span>
      public InetAddress getLocalAddress() {
          if (sc.isOpen()) {
              InetSocketAddress local = sc.localAddress();
              if (local != null) {
                  return Net.getRevealedLocalAddress(local).getAddress();
              }
          }
          return new InetSocketAddress(0).getAddress();
      }
  
<span class="line-added">+     @Override</span>
      public int getPort() {
          InetSocketAddress remote = sc.remoteAddress();
          if (remote == null) {
              return 0;
          } else {
              return remote.getPort();
          }
      }
  
<span class="line-added">+     @Override</span>
      public int getLocalPort() {
          InetSocketAddress local = sc.localAddress();
          if (local == null) {
              return -1;
          } else {
              return local.getPort();
          }
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public SocketAddress getRemoteSocketAddress() {</span>
<span class="line-modified">!         return sc.remoteAddress();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public SocketAddress getLocalSocketAddress() {</span>
<span class="line-modified">!         InetSocketAddress local = sc.localAddress();</span>
<span class="line-modified">!         if (local != null) {</span>
<span class="line-modified">!             return Net.getRevealedLocalAddress(local);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return null;</span>
          }
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     public SocketChannel getChannel() {</span>
<span class="line-added">+         return sc;</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     @Override</span>
      public InputStream getInputStream() throws IOException {
          if (!sc.isOpen())
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!sc.isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (!sc.isInputOpen())
              throw new SocketException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">!         return new InputStream() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public int read() throws IOException {</span>
<span class="line-modified">!                 byte[] a = new byte[1];</span>
<span class="line-modified">!                 int n = read(a, 0, 1);</span>
<span class="line-modified">!                 return (n &gt; 0) ? (a[0] &amp; 0xff) : -1;</span>
              }
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public int read(byte[] b, int off, int len) throws IOException {</span>
<span class="line-added">+                 int timeout = SocketAdaptor.this.timeout;</span>
<span class="line-added">+                 if (timeout &gt; 0) {</span>
<span class="line-added">+                     long nanos = MILLISECONDS.toNanos(timeout);</span>
<span class="line-added">+                     return sc.blockingRead(b, off, len, nanos);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return sc.blockingRead(b, off, len, 0);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public int available() throws IOException {</span>
<span class="line-added">+                 return sc.available();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public void close() throws IOException {</span>
<span class="line-added">+                 sc.close();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
      }
  
<span class="line-added">+     @Override</span>
      public OutputStream getOutputStream() throws IOException {
          if (!sc.isOpen())
              throw new SocketException(&quot;Socket is closed&quot;);
          if (!sc.isConnected())
              throw new SocketException(&quot;Socket is not connected&quot;);
          if (!sc.isOutputOpen())
              throw new SocketException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">!         return new OutputStream() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void write(int b) throws IOException {</span>
<span class="line-modified">!                 byte[] a = new byte[]{(byte) b};</span>
<span class="line-modified">!                 write(a, 0, 1);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void write(byte[] b, int off, int len) throws IOException {</span>
<span class="line-modified">!                 sc.blockingWriteFully(b, off, len);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void close() throws IOException {</span>
<span class="line-added">+                 sc.close();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
      }
  
      private void setBooleanOption(SocketOption&lt;Boolean&gt; name, boolean value)
          throws SocketException
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,141 ***</span>
              Net.translateToSocketException(x);
              return -1;          // keep compiler happy
          }
      }
  
      public void setTcpNoDelay(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
      }
  
      public boolean getTcpNoDelay() throws SocketException {
          return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
      }
  
      public void setSoLinger(boolean on, int linger) throws SocketException {
          if (!on)
              linger = -1;
          setIntOption(StandardSocketOptions.SO_LINGER, linger);
      }
  
      public int getSoLinger() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_LINGER);
      }
  
      public void sendUrgentData(int data) throws IOException {
          int n = sc.sendOutOfBandData((byte) data);
          if (n == 0)
              throw new IOException(&quot;Socket buffer full&quot;);
      }
  
      public void setOOBInline(boolean on) throws SocketException {
          setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
      }
  
      public boolean getOOBInline() throws SocketException {
          return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
      }
  
      public void setSoTimeout(int timeout) throws SocketException {
          if (timeout &lt; 0)
<span class="line-modified">!             throw new IllegalArgumentException(&quot;timeout can&#39;t be negative&quot;);</span>
          this.timeout = timeout;
      }
  
      public int getSoTimeout() throws SocketException {
          return timeout;
      }
  
      public void setSendBufferSize(int size) throws SocketException {
          // size 0 valid for SocketChannel, invalid for Socket
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid send size&quot;);
          setIntOption(StandardSocketOptions.SO_SNDBUF, size);
      }
  
      public int getSendBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_SNDBUF);
      }
  
      public void setReceiveBufferSize(int size) throws SocketException {
          // size 0 valid for SocketChannel, invalid for Socket
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
          setIntOption(StandardSocketOptions.SO_RCVBUF, size);
      }
  
      public int getReceiveBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_RCVBUF);
      }
  
      public void setKeepAlive(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
      }
  
      public boolean getKeepAlive() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
      }
  
      public void setTrafficClass(int tc) throws SocketException {
          setIntOption(StandardSocketOptions.IP_TOS, tc);
      }
  
      public int getTrafficClass() throws SocketException {
          return getIntOption(StandardSocketOptions.IP_TOS);
      }
  
      public void setReuseAddress(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
      }
  
      public boolean getReuseAddress() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
      }
  
      public void close() throws IOException {
          sc.close();
      }
  
      public void shutdownInput() throws IOException {
          try {
              sc.shutdownInput();
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
      public void shutdownOutput() throws IOException {
          try {
              sc.shutdownOutput();
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
      public String toString() {
          if (sc.isConnected())
              return &quot;Socket[addr=&quot; + getInetAddress() +
                  &quot;,port=&quot; + getPort() +
                  &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
          return &quot;Socket[unconnected]&quot;;
      }
  
      public boolean isConnected() {
          return sc.isConnected();
      }
  
      public boolean isBound() {
          return sc.localAddress() != null;
      }
  
      public boolean isClosed() {
          return !sc.isOpen();
      }
  
      public boolean isInputShutdown() {
          return !sc.isInputOpen();
      }
  
      public boolean isOutputShutdown() {
          return !sc.isOutputOpen();
      }
  }
<span class="line-new-header">--- 262,189 ---</span>
              Net.translateToSocketException(x);
              return -1;          // keep compiler happy
          }
      }
  
<span class="line-added">+     @Override</span>
      public void setTcpNoDelay(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.TCP_NODELAY, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getTcpNoDelay() throws SocketException {
          return getBooleanOption(StandardSocketOptions.TCP_NODELAY);
      }
  
<span class="line-added">+     @Override</span>
      public void setSoLinger(boolean on, int linger) throws SocketException {
          if (!on)
              linger = -1;
          setIntOption(StandardSocketOptions.SO_LINGER, linger);
      }
  
<span class="line-added">+     @Override</span>
      public int getSoLinger() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_LINGER);
      }
  
<span class="line-added">+     @Override</span>
      public void sendUrgentData(int data) throws IOException {
          int n = sc.sendOutOfBandData((byte) data);
          if (n == 0)
              throw new IOException(&quot;Socket buffer full&quot;);
      }
  
<span class="line-added">+     @Override</span>
      public void setOOBInline(boolean on) throws SocketException {
          setBooleanOption(ExtendedSocketOption.SO_OOBINLINE, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getOOBInline() throws SocketException {
          return getBooleanOption(ExtendedSocketOption.SO_OOBINLINE);
      }
  
<span class="line-added">+     @Override</span>
      public void setSoTimeout(int timeout) throws SocketException {
<span class="line-added">+         if (!sc.isOpen())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          if (timeout &lt; 0)
<span class="line-modified">!             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
          this.timeout = timeout;
      }
  
<span class="line-added">+     @Override</span>
      public int getSoTimeout() throws SocketException {
<span class="line-added">+         if (!sc.isOpen())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          return timeout;
      }
  
<span class="line-added">+     @Override</span>
      public void setSendBufferSize(int size) throws SocketException {
          // size 0 valid for SocketChannel, invalid for Socket
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid send size&quot;);
          setIntOption(StandardSocketOptions.SO_SNDBUF, size);
      }
  
<span class="line-added">+     @Override</span>
      public int getSendBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_SNDBUF);
      }
  
<span class="line-added">+     @Override</span>
      public void setReceiveBufferSize(int size) throws SocketException {
          // size 0 valid for SocketChannel, invalid for Socket
          if (size &lt;= 0)
              throw new IllegalArgumentException(&quot;Invalid receive size&quot;);
          setIntOption(StandardSocketOptions.SO_RCVBUF, size);
      }
  
<span class="line-added">+     @Override</span>
      public int getReceiveBufferSize() throws SocketException {
          return getIntOption(StandardSocketOptions.SO_RCVBUF);
      }
  
<span class="line-added">+     @Override</span>
      public void setKeepAlive(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_KEEPALIVE, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getKeepAlive() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_KEEPALIVE);
      }
  
<span class="line-added">+     @Override</span>
      public void setTrafficClass(int tc) throws SocketException {
          setIntOption(StandardSocketOptions.IP_TOS, tc);
      }
  
<span class="line-added">+     @Override</span>
      public int getTrafficClass() throws SocketException {
          return getIntOption(StandardSocketOptions.IP_TOS);
      }
  
<span class="line-added">+     @Override</span>
      public void setReuseAddress(boolean on) throws SocketException {
          setBooleanOption(StandardSocketOptions.SO_REUSEADDR, on);
      }
  
<span class="line-added">+     @Override</span>
      public boolean getReuseAddress() throws SocketException {
          return getBooleanOption(StandardSocketOptions.SO_REUSEADDR);
      }
  
<span class="line-added">+     @Override</span>
      public void close() throws IOException {
          sc.close();
      }
  
<span class="line-added">+     @Override</span>
      public void shutdownInput() throws IOException {
          try {
              sc.shutdownInput();
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public void shutdownOutput() throws IOException {
          try {
              sc.shutdownOutput();
          } catch (Exception x) {
              Net.translateException(x);
          }
      }
  
<span class="line-added">+     @Override</span>
      public String toString() {
          if (sc.isConnected())
              return &quot;Socket[addr=&quot; + getInetAddress() +
                  &quot;,port=&quot; + getPort() +
                  &quot;,localport=&quot; + getLocalPort() + &quot;]&quot;;
          return &quot;Socket[unconnected]&quot;;
      }
  
<span class="line-added">+     @Override</span>
      public boolean isConnected() {
          return sc.isConnected();
      }
  
<span class="line-added">+     @Override</span>
      public boolean isBound() {
          return sc.localAddress() != null;
      }
  
<span class="line-added">+     @Override</span>
      public boolean isClosed() {
          return !sc.isOpen();
      }
  
<span class="line-added">+     @Override</span>
      public boolean isInputShutdown() {
          return !sc.isInputOpen();
      }
  
<span class="line-added">+     @Override</span>
      public boolean isOutputShutdown() {
          return !sc.isOutputOpen();
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public &lt;T&gt; Socket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">+         sc.setOption(name, value);</span>
<span class="line-added">+         return this;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">+         return sc.getOption(name);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">+         return sc.supportedOptions();</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="ServerSocketChannelImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
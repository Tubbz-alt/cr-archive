<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/validator/PKIXValidator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../util/SignatureUtil.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ValidatorException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/validator/PKIXValidator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  import java.security.*;
  import java.security.cert.*;
  
  import javax.security.auth.x500.X500Principal;
  import sun.security.action.GetBooleanAction;
<span class="line-added">+ import sun.security.action.GetPropertyAction;</span>
  import sun.security.provider.certpath.AlgorithmChecker;
  import sun.security.provider.certpath.PKIXExtendedParameters;
  
  /**
   * Validator implementation built on the PKIX CertPath API. This
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,10 ***</span>
<span class="line-new-header">--- 59,22 ---</span>
       * supports CRL distribution points as we do not manually setup CertStores.
       */
      private static final boolean checkTLSRevocation = GetBooleanAction
              .privilegedGetProperty(&quot;com.sun.net.ssl.checkRevocation&quot;);
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * System property that if set (or set to &quot;true&quot;), allows trust anchor</span>
<span class="line-added">+      * certificates to be used if they do not have the proper CA extensions.</span>
<span class="line-added">+      * Set to false if prop is not set, or set to any other value.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static final boolean ALLOW_NON_CA_ANCHOR = allowNonCaAnchor();</span>
<span class="line-added">+     private static boolean allowNonCaAnchor() {</span>
<span class="line-added">+         String prop = GetPropertyAction</span>
<span class="line-added">+             .privilegedGetProperty(&quot;jdk.security.allowNonCaAnchor&quot;);</span>
<span class="line-added">+         return prop != null &amp;&amp; (prop.isEmpty() || prop.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private final Set&lt;X509Certificate&gt; trustedCerts;
      private final PKIXBuilderParameters parameterTemplate;
      private int certPathLength = -1;
  
      // needed only for the validator
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,10 ***</span>
<span class="line-new-header">--- 154,11 ---</span>
          }
  
          return subjectMap;
      }
  
<span class="line-added">+     @Override</span>
      public Collection&lt;X509Certificate&gt; getTrustedCertificates() {
          return trustedCerts;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,10 ***</span>
<span class="line-new-header">--- 206,11 ---</span>
          if ((chain == null) || (chain.length == 0)) {
              throw new CertificateException
                  (&quot;null or zero-length certificate chain&quot;);
          }
  
<span class="line-added">+ </span>
          // Use PKIXExtendedParameters for timestamp and variant additions
          PKIXBuilderParameters pkixParameters = null;
          try {
              pkixParameters = new PKIXExtendedParameters(
                      (PKIXBuilderParameters) parameterTemplate.clone(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,32 ***</span>
          // trust anchor
          X500Principal prevIssuer = null;
          for (int i = 0; i &lt; chain.length; i++) {
              X509Certificate cert = chain[i];
              X500Principal dn = cert.getSubjectX500Principal();
<span class="line-removed">-             if (i != 0 &amp;&amp; !dn.equals(prevIssuer)) {</span>
<span class="line-removed">-                 // chain is not ordered correctly, call builder instead</span>
<span class="line-removed">-                 return doBuild(chain, otherCerts, pkixParameters);</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Check if chain[i] is already trusted. It may be inside</span>
<span class="line-modified">!             // trustedCerts, or has the same dn and public key as a cert</span>
<span class="line-removed">-             // inside trustedCerts. The latter happens when a CA has</span>
<span class="line-removed">-             // updated its cert with a stronger signature algorithm in JRE</span>
<span class="line-removed">-             // but the weak one is still in circulation.</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (trustedCerts.contains(cert) ||          // trusted cert</span>
<span class="line-removed">-                     (trustedSubjects.containsKey(dn) &amp;&amp; // replacing ...</span>
<span class="line-removed">-                      trustedSubjects.get(dn).contains(  // ... weak cert</span>
<span class="line-removed">-                         cert.getPublicKey()))) {</span>
<span class="line-removed">-                 if (i == 0) {</span>
                      return new X509Certificate[] {chain[0]};
                  }
<span class="line-modified">!                 // Remove and call validator on partial chain [0 .. i-1]</span>
<span class="line-modified">!                 X509Certificate[] newChain = new X509Certificate[i];</span>
<span class="line-modified">!                 System.arraycopy(chain, 0, newChain, 0, i);</span>
<span class="line-modified">!                 return doValidate(newChain, pkixParameters);</span>
              }
              prevIssuer = cert.getIssuerX500Principal();
          }
  
          // apparently issued by trust anchor?
<span class="line-new-header">--- 236,34 ---</span>
          // trust anchor
          X500Principal prevIssuer = null;
          for (int i = 0; i &lt; chain.length; i++) {
              X509Certificate cert = chain[i];
              X500Principal dn = cert.getSubjectX500Principal();
  
<span class="line-modified">!             if (i == 0) {</span>
<span class="line-modified">!                 if (trustedCerts.contains(cert)) {</span>
                      return new X509Certificate[] {chain[0]};
                  }
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (!dn.equals(prevIssuer)) {</span>
<span class="line-modified">!                     // chain is not ordered correctly, call builder instead</span>
<span class="line-modified">!                     return doBuild(chain, otherCerts, pkixParameters);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // Check if chain[i] is already trusted. It may be inside</span>
<span class="line-added">+                 // trustedCerts, or has the same dn and public key as a cert</span>
<span class="line-added">+                 // inside trustedCerts. The latter happens when a CA has</span>
<span class="line-added">+                 // updated its cert with a stronger signature algorithm in JRE</span>
<span class="line-added">+                 // but the weak one is still in circulation.</span>
<span class="line-added">+                 if (trustedCerts.contains(cert) ||          // trusted cert</span>
<span class="line-added">+                         (trustedSubjects.containsKey(dn) &amp;&amp; // replacing ...</span>
<span class="line-added">+                          trustedSubjects.get(dn).contains(  // ... weak cert</span>
<span class="line-added">+                             cert.getPublicKey()))) {</span>
<span class="line-added">+                     // Remove and call validator on partial chain [0 .. i-1]</span>
<span class="line-added">+                     X509Certificate[] newChain = new X509Certificate[i];</span>
<span class="line-added">+                     System.arraycopy(chain, 0, newChain, 0, i);</span>
<span class="line-added">+                     return doValidate(newChain, pkixParameters);</span>
<span class="line-added">+                 }</span>
              }
              prevIssuer = cert.getIssuerX500Principal();
          }
  
          // apparently issued by trust anchor?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,19 ***</span>
          return true; // only check if PLUGIN is set
      }
  
      private static X509Certificate[] toArray(CertPath path, TrustAnchor anchor)
              throws CertificateException {
<span class="line-removed">-         List&lt;? extends java.security.cert.Certificate&gt; list =</span>
<span class="line-removed">-                                                 path.getCertificates();</span>
<span class="line-removed">-         X509Certificate[] chain = new X509Certificate[list.size() + 1];</span>
<span class="line-removed">-         list.toArray(chain);</span>
          X509Certificate trustedCert = anchor.getTrustedCert();
          if (trustedCert == null) {
              throw new ValidatorException
                  (&quot;TrustAnchor must be specified as certificate&quot;);
          }
          chain[chain.length - 1] = trustedCert;
          return chain;
      }
  
      /**
<span class="line-new-header">--- 322,22 ---</span>
          return true; // only check if PLUGIN is set
      }
  
      private static X509Certificate[] toArray(CertPath path, TrustAnchor anchor)
              throws CertificateException {
          X509Certificate trustedCert = anchor.getTrustedCert();
          if (trustedCert == null) {
              throw new ValidatorException
                  (&quot;TrustAnchor must be specified as certificate&quot;);
          }
<span class="line-added">+ </span>
<span class="line-added">+         verifyTrustAnchor(trustedCert);</span>
<span class="line-added">+ </span>
<span class="line-added">+         List&lt;? extends java.security.cert.Certificate&gt; list =</span>
<span class="line-added">+                                                 path.getCertificates();</span>
<span class="line-added">+         X509Certificate[] chain = new X509Certificate[list.size() + 1];</span>
<span class="line-added">+         list.toArray(chain);</span>
          chain[chain.length - 1] = trustedCert;
          return chain;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,10 ***</span>
<span class="line-new-header">--- 368,45 ---</span>
              throw new ValidatorException
                  (&quot;PKIX path validation failed: &quot; + e.toString(), e);
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Verify that a trust anchor certificate is a CA certificate.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static void verifyTrustAnchor(X509Certificate trustedCert)</span>
<span class="line-added">+         throws ValidatorException {</span>
<span class="line-added">+ </span>
<span class="line-added">+         // skip check if jdk.security.allowNonCAAnchor system property is set</span>
<span class="line-added">+         if (ALLOW_NON_CA_ANCHOR) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // allow v1 trust anchor certificates</span>
<span class="line-added">+         if (trustedCert.getVersion() &lt; 3) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // check that the BasicConstraints cA field is not set to false</span>
<span class="line-added">+         if (trustedCert.getBasicConstraints() == -1) {</span>
<span class="line-added">+             throw new ValidatorException</span>
<span class="line-added">+                 (&quot;TrustAnchor with subject \&quot;&quot; +</span>
<span class="line-added">+                  trustedCert.getSubjectX500Principal() +</span>
<span class="line-added">+                  &quot;\&quot; is not a CA certificate&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // check that the KeyUsage extension, if included, asserts the</span>
<span class="line-added">+         // keyCertSign bit</span>
<span class="line-added">+         boolean[] keyUsageBits = trustedCert.getKeyUsage();</span>
<span class="line-added">+         if (keyUsageBits != null &amp;&amp; !keyUsageBits[5]) {</span>
<span class="line-added">+             throw new ValidatorException</span>
<span class="line-added">+                 (&quot;TrustAnchor with subject \&quot;&quot; +</span>
<span class="line-added">+                  trustedCert.getSubjectX500Principal() +</span>
<span class="line-added">+                  &quot;\&quot; does not have keyCertSign bit set in KeyUsage extension&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private X509Certificate[] doBuild(X509Certificate[] chain,
          Collection&lt;X509Certificate&gt; otherCerts,
          PKIXBuilderParameters params) throws CertificateException {
  
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,57 ***</span>
       * in the List must match the order of the certificates in the
       * chain parameter.
       */
      private static void addResponses(PKIXBuilderParameters pkixParams,
              X509Certificate[] chain, List&lt;byte[]&gt; responseList) {
<span class="line-modified">! </span>
<span class="line-modified">!         if (pkixParams.isRevocationEnabled()) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 // Make a modifiable copy of the CertPathChecker list</span>
<span class="line-modified">!                 PKIXRevocationChecker revChecker = null;</span>
<span class="line-modified">!                 List&lt;PKIXCertPathChecker&gt; checkerList =</span>
<span class="line-modified">!                         new ArrayList&lt;&gt;(pkixParams.getCertPathCheckers());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // Find the first PKIXRevocationChecker in the list</span>
<span class="line-modified">!                 for (PKIXCertPathChecker checker : checkerList) {</span>
<span class="line-modified">!                     if (checker instanceof PKIXRevocationChecker) {</span>
<span class="line-modified">!                         revChecker = (PKIXRevocationChecker)checker;</span>
<span class="line-modified">!                         break;</span>
<span class="line-removed">-                     }</span>
                  }
  
<span class="line-modified">!                 // If we still haven&#39;t found one, make one</span>
<span class="line-modified">!                 if (revChecker == null) {</span>
                      revChecker = (PKIXRevocationChecker)CertPathValidator.
                              getInstance(&quot;PKIX&quot;).getRevocationChecker();
<span class="line-modified">!                     checkerList.add(revChecker);</span>
                  }
  
<span class="line-modified">!                 // Each response in the list should be in parallel with</span>
<span class="line-modified">!                 // the certificate list.  If there is a zero-length response</span>
<span class="line-modified">!                 // treat it as being absent.  If the user has provided their</span>
<span class="line-modified">!                 // own PKIXRevocationChecker with pre-populated responses, do</span>
<span class="line-modified">!                 // not overwrite them with the ones from the handshake.</span>
<span class="line-modified">!                 Map&lt;X509Certificate, byte[]&gt; responseMap =</span>
<span class="line-modified">!                         revChecker.getOcspResponses();</span>
<span class="line-modified">!                 int limit = Integer.min(chain.length, responseList.size());</span>
<span class="line-modified">!                 for (int idx = 0; idx &lt; limit; idx++) {</span>
<span class="line-modified">!                     byte[] respBytes = responseList.get(idx);</span>
<span class="line-modified">!                     if (respBytes != null &amp;&amp; respBytes.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">!                             !responseMap.containsKey(chain[idx])) {</span>
<span class="line-modified">!                         responseMap.put(chain[idx], respBytes);</span>
<span class="line-removed">-                     }</span>
                  }
  
<span class="line-modified">!                 // Add the responses and push it all back into the</span>
<span class="line-modified">!                 // PKIXBuilderParameters</span>
<span class="line-modified">!                 revChecker.setOcspResponses(responseMap);</span>
                  pkixParams.setCertPathCheckers(checkerList);
<span class="line-removed">-             } catch (NoSuchAlgorithmException exc) {</span>
<span class="line-removed">-                 // This should not occur, but if it does happen then</span>
<span class="line-removed">-                 // stapled OCSP responses won&#39;t be part of revocation checking.</span>
<span class="line-removed">-                 // Clients can still fall back to other means of revocation</span>
<span class="line-removed">-                 // checking.</span>
              }
          }
      }
  }
<span class="line-new-header">--- 452,69 ---</span>
       * in the List must match the order of the certificates in the
       * chain parameter.
       */
      private static void addResponses(PKIXBuilderParameters pkixParams,
              X509Certificate[] chain, List&lt;byte[]&gt; responseList) {
<span class="line-modified">!         try {</span>
<span class="line-modified">!             boolean createdRevChk = false;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Obtain the current CertPathChecker list</span>
<span class="line-modified">!             PKIXRevocationChecker revChecker = null;</span>
<span class="line-modified">!             List&lt;PKIXCertPathChecker&gt; checkerList =</span>
<span class="line-modified">!                     pkixParams.getCertPathCheckers();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Find the first PKIXRevocationChecker in the list</span>
<span class="line-modified">!             for (PKIXCertPathChecker checker : checkerList) {</span>
<span class="line-modified">!                 if (checker instanceof PKIXRevocationChecker) {</span>
<span class="line-modified">!                     revChecker = (PKIXRevocationChecker)checker;</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // If we still haven&#39;t found one, make one, unless revocation</span>
<span class="line-modified">!             // is disabled - then there&#39;s no point adding OCSP responses.</span>
<span class="line-added">+             // If a PKIXRevocationChecker was added externally, then we</span>
<span class="line-added">+             // must add the responses since revocation checking is performed</span>
<span class="line-added">+             // independent of the revocation flag (per the</span>
<span class="line-added">+             // PKIXRevocationChecker spec).</span>
<span class="line-added">+             if (revChecker == null) {</span>
<span class="line-added">+                 if (pkixParams.isRevocationEnabled()) {</span>
                      revChecker = (PKIXRevocationChecker)CertPathValidator.
                              getInstance(&quot;PKIX&quot;).getRevocationChecker();
<span class="line-modified">!                     createdRevChk = true;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     return;</span>
                  }
<span class="line-added">+             }</span>
  
<span class="line-modified">!             // Each response in the list should be in parallel with</span>
<span class="line-modified">!             // the certificate list.  If there is a zero-length response</span>
<span class="line-modified">!             // treat it as being absent.  If the user has provided their</span>
<span class="line-modified">!             // own PKIXRevocationChecker with pre-populated responses, do</span>
<span class="line-modified">!             // not overwrite them with the ones from the handshake.</span>
<span class="line-modified">!             Map&lt;X509Certificate, byte[]&gt; responseMap =</span>
<span class="line-modified">!                     revChecker.getOcspResponses();</span>
<span class="line-modified">!             int limit = Integer.min(chain.length, responseList.size());</span>
<span class="line-modified">!             for (int idx = 0; idx &lt; limit; idx++) {</span>
<span class="line-modified">!                 byte[] respBytes = responseList.get(idx);</span>
<span class="line-modified">!                 if (respBytes != null &amp;&amp; respBytes.length &gt; 0 &amp;&amp;</span>
<span class="line-modified">!                         !responseMap.containsKey(chain[idx])) {</span>
<span class="line-modified">!                     responseMap.put(chain[idx], respBytes);</span>
                  }
<span class="line-added">+             }</span>
<span class="line-added">+             revChecker.setOcspResponses(responseMap);</span>
  
<span class="line-modified">!             // Add the responses and push it all back into the</span>
<span class="line-modified">!             // PKIXBuilderParameters</span>
<span class="line-modified">!             if (createdRevChk) {</span>
<span class="line-added">+                 pkixParams.addCertPathChecker(revChecker);</span>
<span class="line-added">+             } else {</span>
                  pkixParams.setCertPathCheckers(checkerList);
              }
<span class="line-added">+         } catch (NoSuchAlgorithmException exc) {</span>
<span class="line-added">+             // This should not occur, but if it does happen then</span>
<span class="line-added">+             // stapled OCSP responses won&#39;t be part of revocation checking.</span>
<span class="line-added">+             // Clients can still fall back to other means of revocation</span>
<span class="line-added">+             // checking.</span>
          }
      }
  }
</pre>
<center><a href="../util/SignatureUtil.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ValidatorException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
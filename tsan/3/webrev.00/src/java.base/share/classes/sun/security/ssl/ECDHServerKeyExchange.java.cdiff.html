<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ECDHKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECPointFormatsExtension.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ECDHServerKeyExchange.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,36 ***</span>
  
  package sun.security.ssl;
  
  import java.io.IOException;
  import java.nio.ByteBuffer;
<span class="line-modified">! import java.security.CryptoPrimitive;</span>
  import java.security.InvalidAlgorithmParameterException;
  import java.security.InvalidKeyException;
  import java.security.Key;
<span class="line-removed">- import java.security.KeyFactory;</span>
  import java.security.NoSuchAlgorithmException;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.Signature;
  import java.security.SignatureException;
<span class="line-removed">- import java.security.interfaces.ECPublicKey;</span>
<span class="line-removed">- import java.security.spec.ECParameterSpec;</span>
<span class="line-removed">- import java.security.spec.ECPoint;</span>
<span class="line-removed">- import java.security.spec.ECPublicKeySpec;</span>
<span class="line-removed">- import java.security.spec.InvalidKeySpecException;</span>
  import java.text.MessageFormat;
<span class="line-removed">- import java.util.EnumSet;</span>
  import java.util.Locale;
<span class="line-modified">! import sun.security.ssl.ECDHKeyExchange.ECDHECredentials;</span>
<span class="line-removed">- import sun.security.ssl.ECDHKeyExchange.ECDHEPossession;</span>
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
<span class="line-removed">- import sun.security.ssl.SupportedGroupsExtension.NamedGroup;</span>
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
<span class="line-removed">- import sun.security.util.ECUtil;</span>
  import sun.security.util.HexDumpEncoder;
  
  /**
   * Pack of the ServerKeyExchange handshake message.
   */
<span class="line-new-header">--- 25,26 ---</span>
  
  package sun.security.ssl;
  
  import java.io.IOException;
  import java.nio.ByteBuffer;
<span class="line-modified">! import java.security.GeneralSecurityException;</span>
  import java.security.InvalidAlgorithmParameterException;
  import java.security.InvalidKeyException;
  import java.security.Key;
  import java.security.NoSuchAlgorithmException;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.Signature;
  import java.security.SignatureException;
  import java.text.MessageFormat;
  import java.util.Locale;
<span class="line-modified">! import java.util.Map;</span>
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
  import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
  import sun.security.ssl.X509Authentication.X509Credentials;
  import sun.security.ssl.X509Authentication.X509Possession;
  import sun.security.util.HexDumpEncoder;
  
  /**
   * Pack of the ServerKeyExchange handshake message.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,58 ***</span>
          private final byte[] publicPoint;
  
          // signature bytes, or null if anonymous
          private final byte[] paramsSignature;
  
<span class="line-removed">-         // public key object encapsulated in this message</span>
<span class="line-removed">-         private final ECPublicKey publicKey;</span>
<span class="line-removed">- </span>
          private final boolean useExplicitSigAlgorithm;
  
          // the signature algorithm used by this ServerKeyExchange message
          private final SignatureScheme signatureScheme;
  
          ECDHServerKeyExchangeMessage(
                  HandshakeContext handshakeContext) throws IOException {
              super(handshakeContext);
  
              // This happens in server side only.
              ServerHandshakeContext shc =
                      (ServerHandshakeContext)handshakeContext;
  
<span class="line-modified">!             ECDHEPossession ecdhePossession = null;</span>
              X509Possession x509Possession = null;
              for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">!                 if (possession instanceof ECDHEPossession) {</span>
<span class="line-modified">!                     ecdhePossession = (ECDHEPossession)possession;</span>
                      if (x509Possession != null) {
                          break;
                      }
                  } else if (possession instanceof X509Possession) {
                      x509Possession = (X509Possession)possession;
<span class="line-modified">!                     if (ecdhePossession != null) {</span>
                          break;
                      }
                  }
              }
  
<span class="line-modified">!             if (ecdhePossession == null) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;No ECDHE credentials negotiated for server key exchange&quot;);
              }
  
<span class="line-modified">!             publicKey = ecdhePossession.publicKey;</span>
<span class="line-modified">!             ECParameterSpec params = publicKey.getParams();</span>
<span class="line-modified">!             ECPoint point = publicKey.getW();</span>
<span class="line-modified">!             publicPoint = ECUtil.encodePoint(point, params.getCurve());</span>
  
<span class="line-modified">!             this.namedGroup = NamedGroup.valueOf(params);</span>
<span class="line-modified">!             if ((namedGroup == null) || (namedGroup.oid == null) ) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Unnamed EC parameter spec: &quot; + params);</span>
              }
  
              if (x509Possession == null) {
                  // anonymous, no authentication, no signature
                  paramsSignature = null;
<span class="line-new-header">--- 68,63 ---</span>
          private final byte[] publicPoint;
  
          // signature bytes, or null if anonymous
          private final byte[] paramsSignature;
  
          private final boolean useExplicitSigAlgorithm;
  
          // the signature algorithm used by this ServerKeyExchange message
          private final SignatureScheme signatureScheme;
  
<span class="line-added">+         // the parsed credential object</span>
<span class="line-added">+         private SSLCredentials sslCredentials;</span>
<span class="line-added">+ </span>
          ECDHServerKeyExchangeMessage(
                  HandshakeContext handshakeContext) throws IOException {
              super(handshakeContext);
  
              // This happens in server side only.
              ServerHandshakeContext shc =
                      (ServerHandshakeContext)handshakeContext;
  
<span class="line-modified">!             // Find the Possessions needed</span>
<span class="line-added">+             NamedGroupPossession namedGroupPossession = null;</span>
              X509Possession x509Possession = null;
              for (SSLPossession possession : shc.handshakePossessions) {
<span class="line-modified">!                 if (possession instanceof NamedGroupPossession) {</span>
<span class="line-modified">!                     namedGroupPossession = (NamedGroupPossession)possession;</span>
                      if (x509Possession != null) {
                          break;
                      }
                  } else if (possession instanceof X509Possession) {
                      x509Possession = (X509Possession)possession;
<span class="line-modified">!                     if (namedGroupPossession != null) {</span>
                          break;
                      }
                  }
              }
  
<span class="line-modified">!             if (namedGroupPossession == null) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;No ECDHE credentials negotiated for server key exchange&quot;);
              }
  
<span class="line-modified">!             // Find the NamedGroup used for the ephemeral keys.</span>
<span class="line-modified">!             namedGroup = namedGroupPossession.getNamedGroup();</span>
<span class="line-modified">!             if ((namedGroup == null) || (!namedGroup.isAvailable)) {</span>
<span class="line-modified">!                 // unlikely</span>
<span class="line-added">+                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">+                     &quot;Missing or improper named group: &quot; + namedGroup);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             publicPoint = namedGroup.encodePossessionPublicKey(</span>
<span class="line-modified">!                     namedGroupPossession);</span>
<span class="line-added">+             if (publicPoint == null) {</span>
                  // unlikely
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Missing public point for named group: &quot; + namedGroup);</span>
              }
  
              if (x509Possession == null) {
                  // anonymous, no authentication, no signature
                  paramsSignature = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,30 ***</span>
              } else {
                  useExplicitSigAlgorithm =
                          shc.negotiatedProtocol.useTLS12PlusSpec();
                  Signature signer = null;
                  if (useExplicitSigAlgorithm) {
<span class="line-modified">!                     signatureScheme = SignatureScheme.getPreferableAlgorithm(</span>
<span class="line-modified">!                             shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">!                             x509Possession.popPrivateKey,</span>
<span class="line-modified">!                             shc.negotiatedProtocol);</span>
<span class="line-modified">!                     if (signatureScheme == null) {</span>
                          // Unlikely, the credentials generator should have
                          // selected the preferable signature algorithm properly.
                          throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">!                                 &quot;No preferred signature algorithm for &quot; +</span>
                                  x509Possession.popPrivateKey.getAlgorithm() +
                                  &quot;  key&quot;);
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     try {</span>
<span class="line-modified">!                         signer = signatureScheme.getSignature(</span>
<span class="line-removed">-                                 x509Possession.popPrivateKey);</span>
<span class="line-removed">-                     } catch (NoSuchAlgorithmException | InvalidKeyException |</span>
<span class="line-removed">-                             InvalidAlgorithmParameterException nsae) {</span>
<span class="line-removed">-                         throw shc.conContext.fatal(Alert.INTERNAL_ERROR,</span>
<span class="line-removed">-                             &quot;Unsupported signature algorithm: &quot; +</span>
<span class="line-removed">-                             signatureScheme.name, nsae);</span>
                      }
                  } else {
                      signatureScheme = null;
                      try {
                          signer = getSignature(
<span class="line-new-header">--- 133,26 ---</span>
              } else {
                  useExplicitSigAlgorithm =
                          shc.negotiatedProtocol.useTLS12PlusSpec();
                  Signature signer = null;
                  if (useExplicitSigAlgorithm) {
<span class="line-modified">!                     Map.Entry&lt;SignatureScheme, Signature&gt; schemeAndSigner =</span>
<span class="line-modified">!                             SignatureScheme.getSignerOfPreferableAlgorithm(</span>
<span class="line-modified">!                                 shc.algorithmConstraints,</span>
<span class="line-modified">!                                 shc.peerRequestedSignatureSchemes,</span>
<span class="line-modified">!                                 x509Possession,</span>
<span class="line-added">+                                 shc.negotiatedProtocol);</span>
<span class="line-added">+                     if (schemeAndSigner == null) {</span>
                          // Unlikely, the credentials generator should have
                          // selected the preferable signature algorithm properly.
                          throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
<span class="line-modified">!                                 &quot;No supported signature algorithm for &quot; +</span>
                                  x509Possession.popPrivateKey.getAlgorithm() +
                                  &quot;  key&quot;);
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         signatureScheme = schemeAndSigner.getKey();</span>
<span class="line-modified">!                         signer = schemeAndSigner.getValue();</span>
                      }
                  } else {
                      signatureScheme = null;
                      try {
                          signer = getSignature(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,43 ***</span>
              if (!SupportedGroups.isSupported(namedGroup)) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;Unsupported named group: &quot; + namedGroup);
              }
  
<span class="line-removed">-             if (namedGroup.oid == null) {</span>
<span class="line-removed">-                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">-                     &quot;Unknown named EC curve: &quot; + namedGroup);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             ECParameterSpec parameters =</span>
<span class="line-removed">-                     ECUtil.getECParameterSpec(null, namedGroup.oid);</span>
<span class="line-removed">-             if (parameters == null) {</span>
<span class="line-removed">-                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">-                     &quot;No supported EC parameter: &quot; + namedGroup);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              publicPoint = Record.getBytes8(m);
              if (publicPoint.length == 0) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Insufficient ECPoint data: &quot; + namedGroup);</span>
              }
  
<span class="line-removed">-             ECPublicKey ecPublicKey = null;</span>
              try {
<span class="line-modified">!                 ECPoint point =</span>
<span class="line-modified">!                         ECUtil.decodePoint(publicPoint, parameters.getCurve());</span>
<span class="line-modified">!                 KeyFactory factory = KeyFactory.getInstance(&quot;EC&quot;);</span>
<span class="line-modified">!                 ecPublicKey = (ECPublicKey)factory.generatePublic(</span>
<span class="line-modified">!                     new ECPublicKeySpec(point, parameters));</span>
<span class="line-modified">!             } catch (NoSuchAlgorithmException |</span>
<span class="line-modified">!                     InvalidKeySpecException | IOException ex) {</span>
<span class="line-modified">!                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-removed">-                     &quot;Invalid ECPoint: &quot; + namedGroup, ex);</span>
              }
  
<span class="line-removed">-             publicKey = ecPublicKey;</span>
<span class="line-removed">- </span>
              X509Credentials x509Credentials = null;
              for (SSLCredentials cd : chc.handshakeCredentials) {
                  if (cd instanceof X509Credentials) {
                      x509Credentials = (X509Credentials)cd;
                      break;
<span class="line-new-header">--- 205,27 ---</span>
              if (!SupportedGroups.isSupported(namedGroup)) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                      &quot;Unsupported named group: &quot; + namedGroup);
              }
  
              publicPoint = Record.getBytes8(m);
              if (publicPoint.length == 0) {
                  throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-modified">!                     &quot;Insufficient Point data: &quot; + namedGroup);</span>
              }
  
              try {
<span class="line-modified">!                 sslCredentials = namedGroup.decodeCredentials(</span>
<span class="line-modified">!                     publicPoint, handshakeContext.algorithmConstraints,</span>
<span class="line-modified">!                      s -&gt; chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-modified">!                      &quot;ServerKeyExchange &quot; + namedGroup + &quot;: &quot; + (s)));</span>
<span class="line-modified">!             } catch (GeneralSecurityException ex) {</span>
<span class="line-modified">!                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
<span class="line-modified">!                         &quot;Cannot decode named group: &quot; +</span>
<span class="line-modified">!                         NamedGroup.nameOf(namedGroupId));</span>
              }
  
              X509Credentials x509Credentials = null;
              for (SSLCredentials cd : chc.handshakeCredentials) {
                  if (cd instanceof X509Credentials) {
                      x509Credentials = (X509Credentials)cd;
                      break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,11 ***</span>
              // read and verify the signature
              paramsSignature = Record.getBytes16(m);
              Signature signer;
              if (useExplicitSigAlgorithm) {
                  try {
<span class="line-modified">!                     signer = signatureScheme.getSignature(</span>
                              x509Credentials.popPublicKey);
                  } catch (NoSuchAlgorithmException | InvalidKeyException |
                          InvalidAlgorithmParameterException nsae) {
                      throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Unsupported signature algorithm: &quot; +
<span class="line-new-header">--- 269,11 ---</span>
              // read and verify the signature
              paramsSignature = Record.getBytes16(m);
              Signature signer;
              if (useExplicitSigAlgorithm) {
                  try {
<span class="line-modified">!                     signer = signatureScheme.getVerifier(</span>
                              x509Credentials.popPublicKey);
                  } catch (NoSuchAlgorithmException | InvalidKeyException |
                          InvalidAlgorithmParameterException nsae) {
                      throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
                          &quot;Unsupported signature algorithm: &quot; +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,34 ***</span>
          public void consume(ConnectionContext context,
                  ByteBuffer message) throws IOException {
              // The consuming happens in client side only.
              ClientHandshakeContext chc = (ClientHandshakeContext)context;
  
              ECDHServerKeyExchangeMessage skem =
                      new ECDHServerKeyExchangeMessage(chc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
              }
  
<span class="line-removed">-             //</span>
<span class="line-removed">-             // validate</span>
<span class="line-removed">-             //</span>
<span class="line-removed">-             // check constraints of EC PublicKey</span>
<span class="line-removed">-             if (!chc.algorithmConstraints.permits(</span>
<span class="line-removed">-                     EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
<span class="line-removed">-                     skem.publicKey)) {</span>
<span class="line-removed">-                 throw chc.conContext.fatal(Alert.INSUFFICIENT_SECURITY,</span>
<span class="line-removed">-                         &quot;ECDH ServerKeyExchange does not comply &quot; +</span>
<span class="line-removed">-                         &quot;to algorithm constraints&quot;);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              //
              // update
              //
<span class="line-modified">!             chc.handshakeCredentials.add(</span>
<span class="line-removed">-                     new ECDHECredentials(skem.publicKey, skem.namedGroup));</span>
  
              //
              // produce
              //
              // Need no new handshake message producers here.
<span class="line-new-header">--- 502,22 ---</span>
          public void consume(ConnectionContext context,
                  ByteBuffer message) throws IOException {
              // The consuming happens in client side only.
              ClientHandshakeContext chc = (ClientHandshakeContext)context;
  
<span class="line-added">+             // AlgorithmConstraints are checked during decoding</span>
              ECDHServerKeyExchangeMessage skem =
                      new ECDHServerKeyExchangeMessage(chc, message);
              if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
                  SSLLogger.fine(
                      &quot;Consuming ECDH ServerKeyExchange handshake message&quot;, skem);
              }
  
              //
              // update
              //
<span class="line-modified">!             chc.handshakeCredentials.add(skem.sslCredentials);</span>
  
              //
              // produce
              //
              // Need no new handshake message producers here.
</pre>
<center><a href="ECDHKeyExchange.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ECPointFormatsExtension.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/X509TrustManagerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X509KeyManagerImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/X509TrustManagerImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  
  import java.net.Socket;
  import java.security.*;
  import java.security.cert.*;
  import java.util.*;
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import javax.net.ssl.*;
  import sun.security.util.AnchorCertificates;
  import sun.security.util.HostnameChecker;
  import sun.security.validator.*;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,10 ***</span>
<span class="line-new-header">--- 62,12 ---</span>
  
      // note that we need separate validator for client and server due to
      // the different extension checks. They are initialized lazily on demand.
      private volatile Validator clientValidator, serverValidator;
  
<span class="line-added">+     private final ReentrantLock validatorLock = new ReentrantLock();</span>
<span class="line-added">+ </span>
      X509TrustManagerImpl(String validatorType,
              Collection&lt;X509Certificate&gt; trustedCerts) {
  
          this.validatorType = validatorType;
          this.pkixParams = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,11 ***</span>
              SSLEngine engine) throws CertificateException {
          checkTrusted(chain, authType, engine, false);
      }
  
      private Validator checkTrustedInit(X509Certificate[] chain,
<span class="line-modified">!                                         String authType, boolean isClient) {</span>
          if (chain == null || chain.length == 0) {
              throw new IllegalArgumentException(
                  &quot;null or zero-length certificate chain&quot;);
          }
  
<span class="line-new-header">--- 143,11 ---</span>
              SSLEngine engine) throws CertificateException {
          checkTrusted(chain, authType, engine, false);
      }
  
      private Validator checkTrustedInit(X509Certificate[] chain,
<span class="line-modified">!             String authType, boolean checkClientTrusted) {</span>
          if (chain == null || chain.length == 0) {
              throw new IllegalArgumentException(
                  &quot;null or zero-length certificate chain&quot;);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,42 ***</span>
              throw new IllegalArgumentException(
                  &quot;null or zero-length authentication type&quot;);
          }
  
          Validator v = null;
<span class="line-modified">!         if (isClient) {</span>
              v = clientValidator;
              if (v == null) {
<span class="line-modified">!                 synchronized (this) {</span>
                      v = clientValidator;
                      if (v == null) {
                          v = getValidator(Validator.VAR_TLS_CLIENT);
                          clientValidator = v;
                      }
                  }
              }
          } else {
              // assume double checked locking with a volatile flag works
              // (guaranteed under the new Tiger memory model)
              v = serverValidator;
              if (v == null) {
<span class="line-modified">!                 synchronized (this) {</span>
                      v = serverValidator;
                      if (v == null) {
                          v = getValidator(Validator.VAR_TLS_SERVER);
                          serverValidator = v;
                      }
                  }
              }
          }
  
          return v;
      }
  
<span class="line-modified">!     private void checkTrusted(X509Certificate[] chain, String authType,</span>
<span class="line-modified">!                 Socket socket, boolean isClient) throws CertificateException {</span>
<span class="line-modified">!         Validator v = checkTrustedInit(chain, authType, isClient);</span>
  
          X509Certificate[] trustedChain = null;
          if ((socket != null) &amp;&amp; socket.isConnected() &amp;&amp;
                                          (socket instanceof SSLSocket)) {
  
<span class="line-new-header">--- 155,49 ---</span>
              throw new IllegalArgumentException(
                  &quot;null or zero-length authentication type&quot;);
          }
  
          Validator v = null;
<span class="line-modified">!         if (checkClientTrusted) {</span>
              v = clientValidator;
              if (v == null) {
<span class="line-modified">!                 validatorLock.lock();</span>
<span class="line-added">+                 try {</span>
                      v = clientValidator;
                      if (v == null) {
                          v = getValidator(Validator.VAR_TLS_CLIENT);
                          clientValidator = v;
                      }
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     validatorLock.unlock();</span>
                  }
              }
          } else {
              // assume double checked locking with a volatile flag works
              // (guaranteed under the new Tiger memory model)
              v = serverValidator;
              if (v == null) {
<span class="line-modified">!                 validatorLock.lock();</span>
<span class="line-added">+                 try {</span>
                      v = serverValidator;
                      if (v == null) {
                          v = getValidator(Validator.VAR_TLS_SERVER);
                          serverValidator = v;
                      }
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     validatorLock.unlock();</span>
                  }
              }
          }
  
          return v;
      }
  
<span class="line-modified">!     private void checkTrusted(X509Certificate[] chain,</span>
<span class="line-modified">!             String authType, Socket socket,</span>
<span class="line-modified">!             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-added">+         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);</span>
  
          X509Certificate[] trustedChain = null;
          if ((socket != null) &amp;&amp; socket.isConnected() &amp;&amp;
                                          (socket instanceof SSLSocket)) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,43 ***</span>
                  constraints = new SSLAlgorithmConstraints(sslSocket, false);
              }
  
              // Grab any stapled OCSP responses for use in validation
              List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">!             if (!isClient &amp;&amp; isExtSession) {</span>
                  responseList =
                          ((ExtendedSSLSession)session).getStatusResponses();
              }
              trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">!                     constraints, isClient ? null : authType);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // check if EE certificate chains to a public root CA (as</span>
<span class="line-removed">-             // pre-installed in cacerts)</span>
<span class="line-removed">-             boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-removed">-                     trustedChain[trustedChain.length-1]);</span>
  
              // check endpoint identity
              String identityAlg = sslSocket.getSSLParameters().
                      getEndpointIdentificationAlgorithm();
              if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">!                 checkIdentity(session, trustedChain[0], identityAlg, isClient,</span>
<span class="line-modified">!                         getRequestedServerNames(socket), chainsToPublicCA);</span>
              }
          } else {
              trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">!                     null, isClient ? null : authType);</span>
          }
  
          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
              SSLLogger.fine(&quot;Found trusted certificate&quot;,
                      trustedChain[trustedChain.length - 1]);
          }
      }
  
<span class="line-modified">!     private void checkTrusted(X509Certificate[] chain, String authType,</span>
<span class="line-modified">!             SSLEngine engine, boolean isClient) throws CertificateException {</span>
<span class="line-modified">!         Validator v = checkTrustedInit(chain, authType, isClient);</span>
  
          X509Certificate[] trustedChain = null;
          if (engine != null) {
              SSLSession session = engine.getHandshakeSession();
              if (session == null) {
<span class="line-new-header">--- 222,39 ---</span>
                  constraints = new SSLAlgorithmConstraints(sslSocket, false);
              }
  
              // Grab any stapled OCSP responses for use in validation
              List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">!             if (!checkClientTrusted &amp;&amp; isExtSession) {</span>
                  responseList =
                          ((ExtendedSSLSession)session).getStatusResponses();
              }
              trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">!                     constraints, checkClientTrusted ? null : authType);</span>
  
              // check endpoint identity
              String identityAlg = sslSocket.getSSLParameters().
                      getEndpointIdentificationAlgorithm();
              if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">!                 checkIdentity(session,</span>
<span class="line-modified">!                         trustedChain, identityAlg, checkClientTrusted);</span>
              }
          } else {
              trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">!                     null, checkClientTrusted ? null : authType);</span>
          }
  
          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
              SSLLogger.fine(&quot;Found trusted certificate&quot;,
                      trustedChain[trustedChain.length - 1]);
          }
      }
  
<span class="line-modified">!     private void checkTrusted(X509Certificate[] chain,</span>
<span class="line-modified">!             String authType, SSLEngine engine,</span>
<span class="line-modified">!             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-added">+         Validator v = checkTrustedInit(chain, authType, checkClientTrusted);</span>
  
          X509Certificate[] trustedChain = null;
          if (engine != null) {
              SSLSession session = engine.getHandshakeSession();
              if (session == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,32 ***</span>
                  constraints = new SSLAlgorithmConstraints(engine, false);
              }
  
              // Grab any stapled OCSP responses for use in validation
              List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">!             if (!isClient &amp;&amp; isExtSession) {</span>
                  responseList =
                          ((ExtendedSSLSession)session).getStatusResponses();
              }
              trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">!                     constraints, isClient ? null : authType);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // check if EE certificate chains to a public root CA (as</span>
<span class="line-removed">-             // pre-installed in cacerts)</span>
<span class="line-removed">-             boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-removed">-                     trustedChain[trustedChain.length-1]);</span>
  
              // check endpoint identity
              String identityAlg = engine.getSSLParameters().
                      getEndpointIdentificationAlgorithm();
              if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">!                 checkIdentity(session, trustedChain[0], identityAlg, isClient,</span>
<span class="line-modified">!                         getRequestedServerNames(engine), chainsToPublicCA);</span>
              }
          } else {
              trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">!                     null, isClient ? null : authType);</span>
          }
  
          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
              SSLLogger.fine(&quot;Found trusted certificate&quot;,
                      trustedChain[trustedChain.length - 1]);
<span class="line-new-header">--- 276,27 ---</span>
                  constraints = new SSLAlgorithmConstraints(engine, false);
              }
  
              // Grab any stapled OCSP responses for use in validation
              List&lt;byte[]&gt; responseList = Collections.emptyList();
<span class="line-modified">!             if (!checkClientTrusted &amp;&amp; isExtSession) {</span>
                  responseList =
                          ((ExtendedSSLSession)session).getStatusResponses();
              }
              trustedChain = v.validate(chain, null, responseList,
<span class="line-modified">!                     constraints, checkClientTrusted ? null : authType);</span>
  
              // check endpoint identity
              String identityAlg = engine.getSSLParameters().
                      getEndpointIdentificationAlgorithm();
              if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">!                 checkIdentity(session, trustedChain,</span>
<span class="line-modified">!                         identityAlg, checkClientTrusted);</span>
              }
          } else {
              trustedChain = v.validate(chain, null, Collections.emptyList(),
<span class="line-modified">!                     null, checkClientTrusted ? null : authType);</span>
          }
  
          if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,trustmanager&quot;)) {
              SSLLogger.fine(&quot;Found trusted certificate&quot;,
                      trustedChain[trustedChain.length - 1]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,32 ***</span>
  
      // Also used by X509KeyManagerImpl
      static List&lt;SNIServerName&gt; getRequestedServerNames(Socket socket) {
          if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
                                          socket instanceof SSLSocket) {
<span class="line-modified">! </span>
<span class="line-modified">!             SSLSocket sslSocket = (SSLSocket)socket;</span>
<span class="line-removed">-             SSLSession session = sslSocket.getHandshakeSession();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-removed">-                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;</span>
<span class="line-removed">-                 return extSession.getRequestedServerNames();</span>
<span class="line-removed">-             }</span>
          }
  
          return Collections.&lt;SNIServerName&gt;emptyList();
      }
  
      // Also used by X509KeyManagerImpl
      static List&lt;SNIServerName&gt; getRequestedServerNames(SSLEngine engine) {
          if (engine != null) {
<span class="line-modified">!             SSLSession session = engine.getHandshakeSession();</span>
  
<span class="line-modified">!             if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-modified">!                 ExtendedSSLSession extSession = (ExtendedSSLSession)session;</span>
<span class="line-modified">!                 return extSession.getRequestedServerNames();</span>
<span class="line-modified">!             }</span>
          }
  
          return Collections.&lt;SNIServerName&gt;emptyList();
      }
  
<span class="line-new-header">--- 350,30 ---</span>
  
      // Also used by X509KeyManagerImpl
      static List&lt;SNIServerName&gt; getRequestedServerNames(Socket socket) {
          if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
                                          socket instanceof SSLSocket) {
<span class="line-modified">!             return getRequestedServerNames(</span>
<span class="line-modified">!                     ((SSLSocket)socket).getHandshakeSession());</span>
          }
  
          return Collections.&lt;SNIServerName&gt;emptyList();
      }
  
      // Also used by X509KeyManagerImpl
      static List&lt;SNIServerName&gt; getRequestedServerNames(SSLEngine engine) {
          if (engine != null) {
<span class="line-modified">!             return getRequestedServerNames(engine.getHandshakeSession());</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         return Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static List&lt;SNIServerName&gt; getRequestedServerNames(</span>
<span class="line-added">+             SSLSession session) {</span>
<span class="line-added">+         if (session != null &amp;&amp; (session instanceof ExtendedSSLSession)) {</span>
<span class="line-added">+             return ((ExtendedSSLSession)session).getRequestedServerNames();</span>
          }
  
          return Collections.&lt;SNIServerName&gt;emptyList();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,37 ***</span>
       * is not always a reliable fully qualified domain name. The HostName in
       * server_name extension is more reliable than peer host. So we prefer
       * the identity checking aginst the server_name extension if present, and
       * may failove to peer host checking.
       */
<span class="line-modified">!     private static void checkIdentity(SSLSession session,</span>
<span class="line-modified">!             X509Certificate cert,</span>
              String algorithm,
<span class="line-modified">!             boolean isClient,</span>
<span class="line-modified">!             List&lt;SNIServerName&gt; sniNames,</span>
<span class="line-modified">!             boolean chainsToPublicCA) throws CertificateException {</span>
  
          boolean identifiable = false;
          String peerHost = session.getPeerHost();
<span class="line-modified">!         if (isClient) {</span>
<span class="line-modified">!             String hostname = getHostNameInSNI(sniNames);</span>
<span class="line-modified">!             if (hostname != null) {</span>
                  try {
<span class="line-modified">!                     checkIdentity(hostname, cert, algorithm, chainsToPublicCA);</span>
                      identifiable = true;
                  } catch (CertificateException ce) {
<span class="line-modified">!                     if (hostname.equalsIgnoreCase(peerHost)) {</span>
                          throw ce;
                      }
  
                      // otherwisw, failover to check peer host
                  }
              }
          }
  
          if (!identifiable) {
<span class="line-modified">!             checkIdentity(peerHost, cert, algorithm, chainsToPublicCA);</span>
          }
      }
  
      /*
       * Identify the peer by its certificate and hostname.
<span class="line-new-header">--- 390,43 ---</span>
       * is not always a reliable fully qualified domain name. The HostName in
       * server_name extension is more reliable than peer host. So we prefer
       * the identity checking aginst the server_name extension if present, and
       * may failove to peer host checking.
       */
<span class="line-modified">!     static void checkIdentity(SSLSession session,</span>
<span class="line-modified">!             X509Certificate[] trustedChain,</span>
              String algorithm,
<span class="line-modified">!             boolean checkClientTrusted) throws CertificateException {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // check if EE certificate chains to a public root CA (as</span>
<span class="line-added">+         // pre-installed in cacerts)</span>
<span class="line-added">+         boolean chainsToPublicCA = AnchorCertificates.contains(</span>
<span class="line-added">+                 trustedChain[trustedChain.length - 1]);</span>
  
          boolean identifiable = false;
          String peerHost = session.getPeerHost();
<span class="line-modified">!         if (!checkClientTrusted) {</span>
<span class="line-modified">!             List&lt;SNIServerName&gt; sniNames = getRequestedServerNames(session);</span>
<span class="line-modified">!             String sniHostName = getHostNameInSNI(sniNames);</span>
<span class="line-added">+             if (sniHostName != null) {</span>
                  try {
<span class="line-modified">!                     checkIdentity(sniHostName,</span>
<span class="line-added">+                             trustedChain[0], algorithm, chainsToPublicCA);</span>
                      identifiable = true;
                  } catch (CertificateException ce) {
<span class="line-modified">!                     if (sniHostName.equalsIgnoreCase(peerHost)) {</span>
                          throw ce;
                      }
  
                      // otherwisw, failover to check peer host
                  }
              }
          }
  
          if (!identifiable) {
<span class="line-modified">!             checkIdentity(peerHost,</span>
<span class="line-added">+                     trustedChain[0], algorithm, chainsToPublicCA);</span>
          }
      }
  
      /*
       * Identify the peer by its certificate and hostname.
</pre>
<center><a href="X509KeyManagerImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../timestamp/TSResponse.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
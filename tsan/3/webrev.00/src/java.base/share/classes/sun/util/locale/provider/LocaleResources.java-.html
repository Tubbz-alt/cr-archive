<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/util/locale/provider/LocaleResources.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 29  *
 30  * The original version of this source code and documentation
 31  * is copyrighted and owned by Taligent, Inc., a wholly-owned
 32  * subsidiary of IBM. These materials are provided under terms
 33  * of a License Agreement between Taligent and Sun. This technology
 34  * is protected by multiple US and International patents.
 35  *
 36  * This notice and attribution to Taligent may not be removed.
 37  * Taligent is a registered trademark of Taligent, Inc.
 38  *
 39  */
 40 
 41 package sun.util.locale.provider;
 42 
 43 import java.lang.ref.ReferenceQueue;
 44 import java.lang.ref.SoftReference;
 45 import java.text.MessageFormat;
 46 import java.text.NumberFormat;
 47 import java.util.Calendar;
 48 import java.util.HashSet;
 49 import java.util.LinkedHashSet;
 50 import java.util.Locale;
 51 import java.util.Map;
 52 import java.util.Objects;
 53 import java.util.ResourceBundle;
 54 import java.util.Set;
 55 import java.util.TimeZone;
 56 import java.util.concurrent.ConcurrentHashMap;
 57 import java.util.concurrent.ConcurrentMap;
 58 import sun.security.action.GetPropertyAction;
 59 import sun.util.resources.LocaleData;
 60 import sun.util.resources.OpenListResourceBundle;
 61 import sun.util.resources.ParallelListResourceBundle;
 62 import sun.util.resources.TimeZoneNamesBundle;
 63 
 64 /**
 65  * Central accessor to locale-dependent resources for JRE/CLDR provider adapters.
 66  *
 67  * @author Masayoshi Okutsu
 68  * @author Naoto Sato
 69  */
 70 public class LocaleResources {
 71 
 72     private final Locale locale;
 73     private final LocaleData localeData;
 74     private final LocaleProviderAdapter.Type type;
 75 
 76     // Resource cache
 77     private final ConcurrentMap&lt;String, ResourceReference&gt; cache = new ConcurrentHashMap&lt;&gt;();
 78     private final ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 79 
 80     // cache key prefixes
 81     private static final String BREAK_ITERATOR_INFO = &quot;BII.&quot;;
 82     private static final String CALENDAR_DATA = &quot;CALD.&quot;;
 83     private static final String COLLATION_DATA_CACHEKEY = &quot;COLD&quot;;
 84     private static final String DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY = &quot;DFSD&quot;;
 85     private static final String CURRENCY_NAMES = &quot;CN.&quot;;
 86     private static final String LOCALE_NAMES = &quot;LN.&quot;;
 87     private static final String TIME_ZONE_NAMES = &quot;TZN.&quot;;
 88     private static final String ZONE_IDS_CACHEKEY = &quot;ZID&quot;;
 89     private static final String CALENDAR_NAMES = &quot;CALN.&quot;;
 90     private static final String NUMBER_PATTERNS_CACHEKEY = &quot;NP&quot;;
 91     private static final String COMPACT_NUMBER_PATTERNS_CACHEKEY = &quot;CNP&quot;;
 92     private static final String DATE_TIME_PATTERN = &quot;DTP.&quot;;
 93 
 94     // TimeZoneNamesBundle exemplar city prefix
 95     private static final String TZNB_EXCITY_PREFIX = &quot;timezone.excity.&quot;;
 96 
 97     // null singleton cache value
 98     private static final Object NULLOBJECT = new Object();
 99 
100     LocaleResources(ResourceBundleBasedAdapter adapter, Locale locale) {
101         this.locale = locale;
102         this.localeData = adapter.getLocaleData();
103         type = ((LocaleProviderAdapter)adapter).getAdapterType();
104     }
105 
106     private void removeEmptyReferences() {
107         Object ref;
108         while ((ref = referenceQueue.poll()) != null) {
109             cache.remove(((ResourceReference)ref).getCacheKey());
110         }
111     }
112 
113     Object getBreakIteratorInfo(String key) {
114         Object biInfo;
115         String cacheKey = BREAK_ITERATOR_INFO + key;
116 
117         removeEmptyReferences();
118         ResourceReference data = cache.get(cacheKey);
119         if (data == null || ((biInfo = data.get()) == null)) {
120            biInfo = localeData.getBreakIteratorInfo(locale).getObject(key);
121            cache.put(cacheKey, new ResourceReference(cacheKey, biInfo, referenceQueue));
122         }
123 
124        return biInfo;
125     }
126 
127     @SuppressWarnings(&quot;unchecked&quot;)
128     byte[] getBreakIteratorResources(String key) {
129         return (byte[]) localeData.getBreakIteratorResources(locale).getObject(key);
130     }
131 
132     public String getCalendarData(String key) {
133         String caldata = &quot;&quot;;
134         String cacheKey = CALENDAR_DATA  + key;
135 
136         removeEmptyReferences();
137 
138         ResourceReference data = cache.get(cacheKey);
139         if (data == null || ((caldata = (String) data.get()) == null)) {
140             ResourceBundle rb = localeData.getCalendarData(locale);
141             if (rb.containsKey(key)) {
142                 caldata = rb.getString(key);
143             }
144 
145             cache.put(cacheKey,
146                       new ResourceReference(cacheKey, caldata, referenceQueue));
147         }
148 
149         return caldata;
150     }
151 
152     public String getCollationData() {
153         String key = &quot;Rule&quot;;
154         String coldata = &quot;&quot;;
155 
156         removeEmptyReferences();
157         ResourceReference data = cache.get(COLLATION_DATA_CACHEKEY);
158         if (data == null || ((coldata = (String) data.get()) == null)) {
159             ResourceBundle rb = localeData.getCollationData(locale);
160             if (rb.containsKey(key)) {
161                 coldata = rb.getString(key);
162             }
163             cache.put(COLLATION_DATA_CACHEKEY,
164                       new ResourceReference(COLLATION_DATA_CACHEKEY, (Object) coldata, referenceQueue));
165         }
166 
167         return coldata;
168     }
169 
170     public Object[] getDecimalFormatSymbolsData() {
171         Object[] dfsdata;
172 
173         removeEmptyReferences();
174         ResourceReference data = cache.get(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY);
175         if (data == null || ((dfsdata = (Object[]) data.get()) == null)) {
176             // Note that only dfsdata[0] is prepared here in this method. Other
177             // elements are provided by the caller, yet they are cached here.
178             ResourceBundle rb = localeData.getNumberFormatData(locale);
179             dfsdata = new Object[3];
180 
181             // NumberElements look up. First, try the Unicode extension
182             String numElemKey;
183             String numberType = locale.getUnicodeLocaleType(&quot;nu&quot;);
184             if (numberType != null) {
185                 numElemKey = numberType + &quot;.NumberElements&quot;;
186                 if (rb.containsKey(numElemKey)) {
187                     dfsdata[0] = rb.getStringArray(numElemKey);
188                 }
189             }
190 
191             // Next, try DefaultNumberingSystem value
192             if (dfsdata[0] == null &amp;&amp; rb.containsKey(&quot;DefaultNumberingSystem&quot;)) {
193                 numElemKey = rb.getString(&quot;DefaultNumberingSystem&quot;) + &quot;.NumberElements&quot;;
194                 if (rb.containsKey(numElemKey)) {
195                     dfsdata[0] = rb.getStringArray(numElemKey);
196                 }
197             }
198 
199             // Last resort. No need to check the availability.
200             // Just let it throw MissingResourceException when needed.
201             if (dfsdata[0] == null) {
202                 dfsdata[0] = rb.getStringArray(&quot;NumberElements&quot;);
203             }
204 
205             cache.put(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY,
206                       new ResourceReference(DECIMAL_FORMAT_SYMBOLS_DATA_CACHEKEY, (Object) dfsdata, referenceQueue));
207         }
208 
209         return dfsdata;
210     }
211 
212     public String getCurrencyName(String key) {
213         Object currencyName = null;
214         String cacheKey = CURRENCY_NAMES + key;
215 
216         removeEmptyReferences();
217         ResourceReference data = cache.get(cacheKey);
218 
219         if (data != null &amp;&amp; ((currencyName = data.get()) != null)) {
220             if (currencyName.equals(NULLOBJECT)) {
221                 currencyName = null;
222             }
223 
224             return (String) currencyName;
225         }
226 
227         OpenListResourceBundle olrb = localeData.getCurrencyNames(locale);
228 
229         if (olrb.containsKey(key)) {
230             currencyName = olrb.getObject(key);
231             cache.put(cacheKey,
232                       new ResourceReference(cacheKey, currencyName, referenceQueue));
233         }
234 
235         return (String) currencyName;
236     }
237 
238     public String getLocaleName(String key) {
239         Object localeName = null;
240         String cacheKey = LOCALE_NAMES + key;
241 
242         removeEmptyReferences();
243         ResourceReference data = cache.get(cacheKey);
244 
245         if (data != null &amp;&amp; ((localeName = data.get()) != null)) {
246             if (localeName.equals(NULLOBJECT)) {
247                 localeName = null;
248             }
249 
250             return (String) localeName;
251         }
252 
253         OpenListResourceBundle olrb = localeData.getLocaleNames(locale);
254 
255         if (olrb.containsKey(key)) {
256             localeName = olrb.getObject(key);
257             cache.put(cacheKey,
258                       new ResourceReference(cacheKey, localeName, referenceQueue));
259         }
260 
261         return (String) localeName;
262     }
263 
264     public Object getTimeZoneNames(String key) {
265         Object val = null;
266         String cacheKey = TIME_ZONE_NAMES + key;
267 
268         removeEmptyReferences();
269         ResourceReference data = cache.get(cacheKey);
270 
271         if (Objects.isNull(data) || Objects.isNull(val = data.get())) {
272             TimeZoneNamesBundle tznb = localeData.getTimeZoneNames(locale);
273             if (key.startsWith(TZNB_EXCITY_PREFIX)) {
274                 if (tznb.containsKey(key)) {
275                     val = tznb.getString(key);
276                     assert val instanceof String;
277                     trace(&quot;tznb: %s key: %s, val: %s\n&quot;, tznb, key, val);
278                 }
279             } else {
280                 String[] names = null;
281                 if (tznb.containsKey(key)) {
282                     names = tznb.getStringArray(key);
283                 } else {
284                     var tz = TimeZoneNameUtility.canonicalTZID(key).orElse(key);
285                     if (tznb.containsKey(tz)) {
286                         names = tznb.getStringArray(tz);
287                     }
288                 }
289 
290                 if (names != null) {
291                     names[0] = key;
292                     trace(&quot;tznb: %s key: %s, names: %s, %s, %s, %s, %s, %s, %s\n&quot;, tznb, key,
293                         names[0], names[1], names[2], names[3], names[4], names[5], names[6]);
294                     val = names;
295                 }
296             }
297             if (val != null) {
298                 cache.put(cacheKey,
299                           new ResourceReference(cacheKey, val, referenceQueue));
300             }
301         }
302 
303         return val;
304     }
305 
306     @SuppressWarnings(&quot;unchecked&quot;)
307     Set&lt;String&gt; getZoneIDs() {
308         Set&lt;String&gt; zoneIDs = null;
309 
310         removeEmptyReferences();
311         ResourceReference data = cache.get(ZONE_IDS_CACHEKEY);
312         if (data == null || ((zoneIDs = (Set&lt;String&gt;) data.get()) == null)) {
313             TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
314             zoneIDs = rb.keySet();
315             cache.put(ZONE_IDS_CACHEKEY,
316                       new ResourceReference(ZONE_IDS_CACHEKEY, (Object) zoneIDs, referenceQueue));
317         }
318 
319         return zoneIDs;
320     }
321 
322     // zoneStrings are cached separately in TimeZoneNameUtility.
323     String[][] getZoneStrings() {
324         TimeZoneNamesBundle rb = localeData.getTimeZoneNames(locale);
325         Set&lt;String&gt; keyset = getZoneIDs();
326         // Use a LinkedHashSet to preseve the order
327         Set&lt;String[]&gt; value = new LinkedHashSet&lt;&gt;();
328         Set&lt;String&gt; tzIds = new HashSet&lt;&gt;(Set.of(TimeZone.getAvailableIDs()));
329         for (String key : keyset) {
330             if (!key.startsWith(TZNB_EXCITY_PREFIX)) {
331                 value.add(rb.getStringArray(key));
332                 tzIds.remove(key);
333             }
334         }
335 
336         if (type == LocaleProviderAdapter.Type.CLDR) {
337             // Note: TimeZoneNamesBundle creates a String[] on each getStringArray call.
338 
339             // Add timezones which are not present in this keyset,
340             // so that their fallback names will be generated at runtime.
341             tzIds.stream().filter(i -&gt; (!i.startsWith(&quot;Etc/GMT&quot;)
342                     &amp;&amp; !i.startsWith(&quot;GMT&quot;)
343                     &amp;&amp; !i.startsWith(&quot;SystemV&quot;)))
344                     .forEach(tzid -&gt; {
345                         String[] val = new String[7];
346                         if (keyset.contains(tzid)) {
347                             val = rb.getStringArray(tzid);
348                         } else {
349                             var canonID = TimeZoneNameUtility.canonicalTZID(tzid)
350                                             .orElse(tzid);
351                             if (keyset.contains(canonID)) {
352                                 val = rb.getStringArray(canonID);
353                             }
354                         }
355                         val[0] = tzid;
356                         value.add(val);
357                     });
358         }
359         return value.toArray(new String[0][]);
360     }
361 
362     String[] getCalendarNames(String key) {
363         String[] names = null;
364         String cacheKey = CALENDAR_NAMES + key;
365 
366         removeEmptyReferences();
367         ResourceReference data = cache.get(cacheKey);
368 
369         if (data == null || ((names = (String[]) data.get()) == null)) {
370             ResourceBundle rb = localeData.getDateFormatData(locale);
371             if (rb.containsKey(key)) {
372                 names = rb.getStringArray(key);
373                 cache.put(cacheKey,
374                           new ResourceReference(cacheKey, (Object) names, referenceQueue));
375             }
376         }
377 
378         return names;
379     }
380 
381     String[] getJavaTimeNames(String key) {
382         String[] names = null;
383         String cacheKey = CALENDAR_NAMES + key;
384 
385         removeEmptyReferences();
386         ResourceReference data = cache.get(cacheKey);
387 
388         if (data == null || ((names = (String[]) data.get()) == null)) {
389             ResourceBundle rb = getJavaTimeFormatData();
390             if (rb.containsKey(key)) {
391                 names = rb.getStringArray(key);
392                 cache.put(cacheKey,
393                           new ResourceReference(cacheKey, (Object) names, referenceQueue));
394             }
395         }
396 
397         return names;
398     }
399 
400     public String getDateTimePattern(int timeStyle, int dateStyle, Calendar cal) {
401         if (cal == null) {
402             cal = Calendar.getInstance(locale);
403         }
404         return getDateTimePattern(null, timeStyle, dateStyle, cal.getCalendarType());
405     }
406 
407     /**
408      * Returns a date-time format pattern
409      * @param timeStyle style of time; one of FULL, LONG, MEDIUM, SHORT in DateFormat,
410      *                  or -1 if not required
411      * @param dateStyle style of time; one of FULL, LONG, MEDIUM, SHORT in DateFormat,
412      *                  or -1 if not required
413      * @param calType   the calendar type for the pattern
414      * @return the pattern string
415      */
416     public String getJavaTimeDateTimePattern(int timeStyle, int dateStyle, String calType) {
417         calType = CalendarDataUtility.normalizeCalendarType(calType);
418         String pattern;
419         pattern = getDateTimePattern(&quot;java.time.&quot;, timeStyle, dateStyle, calType);
420         if (pattern == null) {
421             pattern = getDateTimePattern(null, timeStyle, dateStyle, calType);
422         }
423         return pattern;
424     }
425 
426     private String getDateTimePattern(String prefix, int timeStyle, int dateStyle, String calType) {
427         String pattern;
428         String timePattern = null;
429         String datePattern = null;
430 
431         if (timeStyle &gt;= 0) {
432             if (prefix != null) {
433                 timePattern = getDateTimePattern(prefix, &quot;TimePatterns&quot;, timeStyle, calType);
434             }
435             if (timePattern == null) {
436                 timePattern = getDateTimePattern(null, &quot;TimePatterns&quot;, timeStyle, calType);
437             }
438         }
439         if (dateStyle &gt;= 0) {
440             if (prefix != null) {
441                 datePattern = getDateTimePattern(prefix, &quot;DatePatterns&quot;, dateStyle, calType);
442             }
443             if (datePattern == null) {
444                 datePattern = getDateTimePattern(null, &quot;DatePatterns&quot;, dateStyle, calType);
445             }
446         }
447         if (timeStyle &gt;= 0) {
448             if (dateStyle &gt;= 0) {
449                 String dateTimePattern = null;
450                 int dateTimeStyle = Math.max(dateStyle, timeStyle);
451                 if (prefix != null) {
452                     dateTimePattern = getDateTimePattern(prefix, &quot;DateTimePatterns&quot;, dateTimeStyle, calType);
453                 }
454                 if (dateTimePattern == null) {
455                     dateTimePattern = getDateTimePattern(null, &quot;DateTimePatterns&quot;, dateTimeStyle, calType);
456                 }
457                 switch (dateTimePattern) {
458                 case &quot;{1} {0}&quot;:
459                     pattern = datePattern + &quot; &quot; + timePattern;
460                     break;
461                 case &quot;{0} {1}&quot;:
462                     pattern = timePattern + &quot; &quot; + datePattern;
463                     break;
464                 default:
465                     pattern = MessageFormat.format(dateTimePattern.replaceAll(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;), timePattern, datePattern);
466                     break;
467                 }
468             } else {
469                 pattern = timePattern;
470             }
471         } else if (dateStyle &gt;= 0) {
472             pattern = datePattern;
473         } else {
474             throw new IllegalArgumentException(&quot;No date or time style specified&quot;);
475         }
476         return pattern;
477     }
478 
479     public String[] getNumberPatterns() {
480         String[] numberPatterns = null;
481 
482         removeEmptyReferences();
483         ResourceReference data = cache.get(NUMBER_PATTERNS_CACHEKEY);
484 
485         if (data == null || ((numberPatterns = (String[]) data.get()) == null)) {
486             ResourceBundle resource = localeData.getNumberFormatData(locale);
487             numberPatterns = resource.getStringArray(&quot;NumberPatterns&quot;);
488             cache.put(NUMBER_PATTERNS_CACHEKEY,
489                       new ResourceReference(NUMBER_PATTERNS_CACHEKEY, (Object) numberPatterns, referenceQueue));
490         }
491 
492         return numberPatterns;
493     }
494 
495     /**
496      * Returns the compact number format patterns.
497      * @param formatStyle the style for formatting a number
498      * @return an array of compact number patterns
499      */
500     @SuppressWarnings(&quot;unchecked&quot;)
501     public String[] getCNPatterns(NumberFormat.Style formatStyle) {
502 
503         Objects.requireNonNull(formatStyle);
504         String[] compactNumberPatterns = null;
505         removeEmptyReferences();
506         String width = (formatStyle == NumberFormat.Style.LONG) ? &quot;long&quot; : &quot;short&quot;;
507         String cacheKey = width + &quot;.&quot; + COMPACT_NUMBER_PATTERNS_CACHEKEY;
508         ResourceReference data = cache.get(cacheKey);
509         if (data == null || ((compactNumberPatterns
510                 = (String[]) data.get()) == null)) {
511             ResourceBundle resource = localeData.getNumberFormatData(locale);
512             compactNumberPatterns = (String[]) resource
513                     .getObject(width + &quot;.CompactNumberPatterns&quot;);
514             cache.put(cacheKey, new ResourceReference(cacheKey,
515                     (Object) compactNumberPatterns, referenceQueue));
516         }
517         return compactNumberPatterns;
518     }
519 
520 
521     /**
522      * Returns the FormatData resource bundle of this LocaleResources.
523      * The FormatData should be used only for accessing extra
524      * resources required by JSR 310.
525      */
526     public ResourceBundle getJavaTimeFormatData() {
527         ResourceBundle rb = localeData.getDateFormatData(locale);
528         if (rb instanceof ParallelListResourceBundle) {
529             localeData.setSupplementary((ParallelListResourceBundle) rb);
530         }
531         return rb;
532     }
533 
534     private String getDateTimePattern(String prefix, String key, int styleIndex, String calendarType) {
535         StringBuilder sb = new StringBuilder();
536         if (prefix != null) {
537             sb.append(prefix);
538         }
539         if (!&quot;gregory&quot;.equals(calendarType)) {
540             sb.append(calendarType).append(&#39;.&#39;);
541         }
542         sb.append(key);
543         String resourceKey = sb.toString();
544         String cacheKey = sb.insert(0, DATE_TIME_PATTERN).toString();
545 
546         removeEmptyReferences();
547         ResourceReference data = cache.get(cacheKey);
548         Object value = NULLOBJECT;
549 
550         if (data == null || ((value = data.get()) == null)) {
551             ResourceBundle r = (prefix != null) ? getJavaTimeFormatData() : localeData.getDateFormatData(locale);
552             if (r.containsKey(resourceKey)) {
553                 value = r.getStringArray(resourceKey);
554             } else {
555                 assert !resourceKey.equals(key);
556                 if (r.containsKey(key)) {
557                     value = r.getStringArray(key);
558                 }
559             }
560             cache.put(cacheKey,
561                       new ResourceReference(cacheKey, value, referenceQueue));
562         }
563         if (value == NULLOBJECT) {
564             assert prefix != null;
565             return null;
566         }
567 
568         // for DateTimePatterns. CLDR has multiple styles, while JRE has one.
569         String[] styles = (String[])value;
570         return (styles.length &gt; 1 ? styles[styleIndex] : styles[0]);
571     }
572 
573     private static class ResourceReference extends SoftReference&lt;Object&gt; {
574         private final String cacheKey;
575 
576         ResourceReference(String cacheKey, Object o, ReferenceQueue&lt;Object&gt; q) {
577             super(o, q);
578             this.cacheKey = cacheKey;
579         }
580 
581         String getCacheKey() {
582             return cacheKey;
583         }
584     }
585 
586     private static final boolean TRACE_ON = Boolean.valueOf(
587         GetPropertyAction.privilegedGetProperty(&quot;locale.resources.debug&quot;, &quot;false&quot;));
588 
589     public static void trace(String format, Object... params) {
590         if (TRACE_ON) {
591             System.out.format(format, params);
592         }
593     }
594 }
    </pre>
  </body>
</html>
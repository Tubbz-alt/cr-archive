<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/nio/ch/SelectorImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectionKeyImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SelectorProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/nio/ch/SelectorImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.ClosedSelectorException;
 30 import java.nio.channels.IllegalSelectorException;
 31 import java.nio.channels.SelectableChannel;
 32 import java.nio.channels.SelectionKey;
 33 import java.nio.channels.spi.AbstractSelectableChannel;
 34 import java.nio.channels.spi.AbstractSelector;
 35 import java.nio.channels.spi.SelectorProvider;

 36 import java.util.Collections;

 37 import java.util.HashSet;
 38 import java.util.Iterator;
 39 import java.util.Objects;
 40 import java.util.Set;
 41 import java.util.concurrent.ConcurrentHashMap;
 42 import java.util.function.Consumer;
 43 
 44 
 45 /**
 46  * Base Selector implementation class.
 47  */
 48 
<span class="line-modified"> 49 abstract class SelectorImpl</span>
 50     extends AbstractSelector
 51 {
 52     // The set of keys registered with this Selector
 53     private final Set&lt;SelectionKey&gt; keys;
 54 
 55     // The set of keys with data ready for an operation
 56     private final Set&lt;SelectionKey&gt; selectedKeys;
 57 
 58     // Public views of the key sets
 59     private final Set&lt;SelectionKey&gt; publicKeys;             // Immutable
 60     private final Set&lt;SelectionKey&gt; publicSelectedKeys;     // Removal allowed, but not addition
 61 



 62     // used to check for reentrancy
 63     private boolean inSelect;
 64 
 65     protected SelectorImpl(SelectorProvider sp) {
 66         super(sp);
 67         keys = ConcurrentHashMap.newKeySet();
 68         selectedKeys = new HashSet&lt;&gt;();
 69         publicKeys = Collections.unmodifiableSet(keys);
 70         publicSelectedKeys = Util.ungrowableSet(selectedKeys);
 71     }
 72 
 73     private void ensureOpen() {
 74         if (!isOpen())
 75             throw new ClosedSelectorException();
 76     }
 77 
 78     @Override
 79     public final Set&lt;SelectionKey&gt; keys() {
 80         ensureOpen();
 81         return publicKeys;
</pre>
<hr />
<pre>
186                     deregister(ski);
187                     SelectableChannel selch = ski.channel();
188                     if (!selch.isOpen() &amp;&amp; !selch.isRegistered())
189                         ((SelChImpl)selch).kill();
190                     selectedKeys.remove(ski);
191                     i.remove();
192                 }
193                 assert selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();
194             }
195         }
196     }
197 
198     @Override
199     protected final SelectionKey register(AbstractSelectableChannel ch,
200                                           int ops,
201                                           Object attachment)
202     {
203         if (!(ch instanceof SelChImpl))
204             throw new IllegalSelectorException();
205         SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
<span class="line-modified">206         k.attach(attachment);</span>

207 
208         // register (if needed) before adding to key set
209         implRegister(k);
210 
211         // add to the selector&#39;s key set, removing it immediately if the selector
212         // is closed. The key is not in the channel&#39;s key set at this point but
213         // it may be observed by a thread iterating over the selector&#39;s key set.
214         keys.add(k);
215         try {
216             k.interestOps(ops);
217         } catch (ClosedSelectorException e) {
218             assert ch.keyFor(this) == null;
219             keys.remove(k);
220             k.cancel();
221             throw e;
222         }
223         return k;
224     }
225 
226     /**
227      * Register the key in the selector.
228      *
229      * The default implementation checks if the selector is open. It should
230      * be overridden by selector implementations as needed.
231      */
232     protected void implRegister(SelectionKeyImpl ski) {
233         ensureOpen();
234     }
235 
236     /**
237      * Removes the key from the selector
238      */
239     protected abstract void implDereg(SelectionKeyImpl ski) throws IOException;
240 
241     /**
<span class="line-modified">242      * Invoked by selection operations to process the cancelled-key set</span>









243      */
244     protected final void processDeregisterQueue() throws IOException {
245         assert Thread.holdsLock(this);
246         assert Thread.holdsLock(publicSelectedKeys);
247 
<span class="line-modified">248         Set&lt;SelectionKey&gt; cks = cancelledKeys();</span>
<span class="line-modified">249         synchronized (cks) {</span>
<span class="line-modified">250             if (!cks.isEmpty()) {</span>
<span class="line-modified">251                 Iterator&lt;SelectionKey&gt; i = cks.iterator();</span>
<span class="line-modified">252                 while (i.hasNext()) {</span>
<span class="line-removed">253                     SelectionKeyImpl ski = (SelectionKeyImpl)i.next();</span>
<span class="line-removed">254                     i.remove();</span>
<span class="line-removed">255 </span>
<span class="line-removed">256                     // remove the key from the selector</span>
<span class="line-removed">257                     implDereg(ski);</span>
258 
<span class="line-modified">259                     selectedKeys.remove(ski);</span>
<span class="line-modified">260                     keys.remove(ski);</span>
261 
<span class="line-modified">262                     // remove from channel&#39;s key set</span>
<span class="line-modified">263                     deregister(ski);</span>
264 
<span class="line-modified">265                     SelectableChannel ch = ski.channel();</span>
<span class="line-modified">266                     if (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span>
<span class="line-modified">267                         ((SelChImpl)ch).kill();</span>
<span class="line-removed">268                 }</span>
269             }
270         }
271     }
272 
273     /**
274      * Invoked by selection operations to handle ready events. If an action
275      * is specified then it is invoked to handle the key, otherwise the key
276      * is added to the selected-key set (or updated when it is already in the
277      * set).
278      */
279     protected final int processReadyEvents(int rOps,
280                                            SelectionKeyImpl ski,
281                                            Consumer&lt;SelectionKey&gt; action) {
282         if (action != null) {
283             ski.translateAndSetReadyOps(rOps);
284             if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) {
285                 action.accept(ski);
286                 ensureOpen();
287                 return 1;
288             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.ClosedSelectorException;
 30 import java.nio.channels.IllegalSelectorException;
 31 import java.nio.channels.SelectableChannel;
 32 import java.nio.channels.SelectionKey;
 33 import java.nio.channels.spi.AbstractSelectableChannel;
 34 import java.nio.channels.spi.AbstractSelector;
 35 import java.nio.channels.spi.SelectorProvider;
<span class="line-added"> 36 import java.util.ArrayDeque;</span>
 37 import java.util.Collections;
<span class="line-added"> 38 import java.util.Deque;</span>
 39 import java.util.HashSet;
 40 import java.util.Iterator;
 41 import java.util.Objects;
 42 import java.util.Set;
 43 import java.util.concurrent.ConcurrentHashMap;
 44 import java.util.function.Consumer;
 45 
 46 
 47 /**
 48  * Base Selector implementation class.
 49  */
 50 
<span class="line-modified"> 51 public abstract class SelectorImpl</span>
 52     extends AbstractSelector
 53 {
 54     // The set of keys registered with this Selector
 55     private final Set&lt;SelectionKey&gt; keys;
 56 
 57     // The set of keys with data ready for an operation
 58     private final Set&lt;SelectionKey&gt; selectedKeys;
 59 
 60     // Public views of the key sets
 61     private final Set&lt;SelectionKey&gt; publicKeys;             // Immutable
 62     private final Set&lt;SelectionKey&gt; publicSelectedKeys;     // Removal allowed, but not addition
 63 
<span class="line-added"> 64     // pending cancelled keys for deregistration</span>
<span class="line-added"> 65     private final Deque&lt;SelectionKeyImpl&gt; cancelledKeys = new ArrayDeque&lt;&gt;();</span>
<span class="line-added"> 66 </span>
 67     // used to check for reentrancy
 68     private boolean inSelect;
 69 
 70     protected SelectorImpl(SelectorProvider sp) {
 71         super(sp);
 72         keys = ConcurrentHashMap.newKeySet();
 73         selectedKeys = new HashSet&lt;&gt;();
 74         publicKeys = Collections.unmodifiableSet(keys);
 75         publicSelectedKeys = Util.ungrowableSet(selectedKeys);
 76     }
 77 
 78     private void ensureOpen() {
 79         if (!isOpen())
 80             throw new ClosedSelectorException();
 81     }
 82 
 83     @Override
 84     public final Set&lt;SelectionKey&gt; keys() {
 85         ensureOpen();
 86         return publicKeys;
</pre>
<hr />
<pre>
191                     deregister(ski);
192                     SelectableChannel selch = ski.channel();
193                     if (!selch.isOpen() &amp;&amp; !selch.isRegistered())
194                         ((SelChImpl)selch).kill();
195                     selectedKeys.remove(ski);
196                     i.remove();
197                 }
198                 assert selectedKeys.isEmpty() &amp;&amp; keys.isEmpty();
199             }
200         }
201     }
202 
203     @Override
204     protected final SelectionKey register(AbstractSelectableChannel ch,
205                                           int ops,
206                                           Object attachment)
207     {
208         if (!(ch instanceof SelChImpl))
209             throw new IllegalSelectorException();
210         SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
<span class="line-modified">211         if (attachment != null)</span>
<span class="line-added">212             k.attach(attachment);</span>
213 
214         // register (if needed) before adding to key set
215         implRegister(k);
216 
217         // add to the selector&#39;s key set, removing it immediately if the selector
218         // is closed. The key is not in the channel&#39;s key set at this point but
219         // it may be observed by a thread iterating over the selector&#39;s key set.
220         keys.add(k);
221         try {
222             k.interestOps(ops);
223         } catch (ClosedSelectorException e) {
224             assert ch.keyFor(this) == null;
225             keys.remove(k);
226             k.cancel();
227             throw e;
228         }
229         return k;
230     }
231 
232     /**
233      * Register the key in the selector.
234      *
235      * The default implementation checks if the selector is open. It should
236      * be overridden by selector implementations as needed.
237      */
238     protected void implRegister(SelectionKeyImpl ski) {
239         ensureOpen();
240     }
241 
242     /**
243      * Removes the key from the selector
244      */
245     protected abstract void implDereg(SelectionKeyImpl ski) throws IOException;
246 
247     /**
<span class="line-modified">248      * Queue a cancelled key for the next selection operation</span>
<span class="line-added">249      */</span>
<span class="line-added">250     public void cancel(SelectionKeyImpl ski) {</span>
<span class="line-added">251         synchronized (cancelledKeys) {</span>
<span class="line-added">252             cancelledKeys.addLast(ski);</span>
<span class="line-added">253         }</span>
<span class="line-added">254     }</span>
<span class="line-added">255 </span>
<span class="line-added">256     /**</span>
<span class="line-added">257      * Invoked by selection operations to process the cancelled keys</span>
258      */
259     protected final void processDeregisterQueue() throws IOException {
260         assert Thread.holdsLock(this);
261         assert Thread.holdsLock(publicSelectedKeys);
262 
<span class="line-modified">263         synchronized (cancelledKeys) {</span>
<span class="line-modified">264             SelectionKeyImpl ski;</span>
<span class="line-modified">265             while ((ski = cancelledKeys.pollFirst()) != null) {</span>
<span class="line-modified">266                 // remove the key from the selector</span>
<span class="line-modified">267                 implDereg(ski);</span>





268 
<span class="line-modified">269                 selectedKeys.remove(ski);</span>
<span class="line-modified">270                 keys.remove(ski);</span>
271 
<span class="line-modified">272                 // remove from channel&#39;s key set</span>
<span class="line-modified">273                 deregister(ski);</span>
274 
<span class="line-modified">275                 SelectableChannel ch = ski.channel();</span>
<span class="line-modified">276                 if (!ch.isOpen() &amp;&amp; !ch.isRegistered())</span>
<span class="line-modified">277                     ((SelChImpl)ch).kill();</span>

278             }
279         }
280     }
281 
282     /**
283      * Invoked by selection operations to handle ready events. If an action
284      * is specified then it is invoked to handle the key, otherwise the key
285      * is added to the selected-key set (or updated when it is already in the
286      * set).
287      */
288     protected final int processReadyEvents(int rOps,
289                                            SelectionKeyImpl ski,
290                                            Consumer&lt;SelectionKey&gt; action) {
291         if (action != null) {
292             ski.translateAndSetReadyOps(rOps);
293             if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) {
294                 action.accept(ski);
295                 ensureOpen();
296                 return 1;
297             }
</pre>
</td>
</tr>
</table>
<center><a href="SelectionKeyImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SelectorProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/X509Authentication.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.security.PrivateKey;
 29 import java.security.PublicKey;
 30 import java.security.cert.X509Certificate;
 31 import java.security.interfaces.ECPublicKey;
 32 import java.security.spec.ECParameterSpec;
 33 import java.util.AbstractMap.SimpleImmutableEntry;
 34 import java.util.Map;
 35 import javax.net.ssl.SSLEngine;
 36 import javax.net.ssl.SSLSocket;
 37 import javax.net.ssl.X509ExtendedKeyManager;
 38 import sun.security.ssl.SupportedGroupsExtension.NamedGroup;
 39 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 40 
 41 enum X509Authentication implements SSLAuthentication {
 42     // Require rsaEncryption public key
 43     RSA         (&quot;RSA&quot;,         new X509PossessionGenerator(
 44                                     new String[]{&quot;RSA&quot;})),
 45 
 46     // Require RSASSA-PSS public key
 47     RSASSA_PSS  (&quot;RSASSA-PSS&quot;,  new X509PossessionGenerator(
 48                                     new String[] {&quot;RSASSA-PSS&quot;})),
 49 
 50     // Require rsaEncryption or RSASSA-PSS public key
 51     //
 52     // Note that this is a specifical scheme for TLS 1.2. (EC)DHE_RSA cipher
 53     // suites of TLS 1.2 can use either rsaEncryption or RSASSA-PSS public
 54     // key for authentication and handshake.
 55     RSA_OR_PSS  (&quot;RSA_OR_PSS&quot;,  new X509PossessionGenerator(
 56                                     new String[] {&quot;RSA&quot;, &quot;RSASSA-PSS&quot;})),
 57 
 58     // Require DSA public key
 59     DSA         (&quot;DSA&quot;,         new X509PossessionGenerator(
 60                                     new String[] {&quot;DSA&quot;})),
 61 
 62     // Require EC public key
 63     EC          (&quot;EC&quot;,          new X509PossessionGenerator(
 64                                     new String[] {&quot;EC&quot;}));
 65 
 66     final String keyType;
 67     final SSLPossessionGenerator possessionGenerator;
 68 
 69     X509Authentication(String keyType,
 70             SSLPossessionGenerator possessionGenerator) {
 71         this.keyType = keyType;
 72         this.possessionGenerator = possessionGenerator;
 73     }
 74 
 75     static X509Authentication valueOf(SignatureScheme signatureScheme) {
 76         for (X509Authentication au : X509Authentication.values()) {
 77             if (au.keyType.equals(signatureScheme.keyAlgorithm)) {
 78                 return au;
 79             }
 80         }
 81 
 82         return null;
 83     }
 84 
 85     @Override
 86     public SSLPossession createPossession(HandshakeContext handshakeContext) {
 87         return possessionGenerator.createPossession(handshakeContext);
 88     }
 89 
 90     @Override
 91     public SSLHandshake[] getRelatedHandshakers(
 92             HandshakeContext handshakeContext) {
 93         if (!handshakeContext.negotiatedProtocol.useTLS13PlusSpec()) {
 94             return new SSLHandshake[] {
 95                     SSLHandshake.CERTIFICATE,
 96                     SSLHandshake.CERTIFICATE_REQUEST
 97                 };
 98         }   // Otherwise, TLS 1.3 does not use this method.
 99 
100         return new SSLHandshake[0];
101     }
102 
103     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
104     @Override
105     public Map.Entry&lt;Byte, HandshakeProducer&gt;[] getHandshakeProducers(
106             HandshakeContext handshakeContext) {
107         if (!handshakeContext.negotiatedProtocol.useTLS13PlusSpec()) {
108             return (Map.Entry&lt;Byte, HandshakeProducer&gt;[])(new Map.Entry[] {
109                     new SimpleImmutableEntry&lt;Byte, HandshakeProducer&gt;(
110                         SSLHandshake.CERTIFICATE.id,
111                         SSLHandshake.CERTIFICATE
112                     )
113                 });
114         }   // Otherwise, TLS 1.3 does not use this method.
115 
116         return (Map.Entry&lt;Byte, HandshakeProducer&gt;[])(new Map.Entry[0]);
117     }
118 
119     static final class X509Possession implements SSLPossession {
120         // Proof of possession of the private key corresponding to the public
121         // key for which a certificate is being provided for authentication.
122         final X509Certificate[]   popCerts;
123         final PrivateKey          popPrivateKey;
124 
125         X509Possession(PrivateKey popPrivateKey,
126                 X509Certificate[] popCerts) {
127             this.popCerts = popCerts;
128             this.popPrivateKey = popPrivateKey;
129         }
130     }
131 
132     static final class X509Credentials implements SSLCredentials {
133         final X509Certificate[]   popCerts;
134         final PublicKey           popPublicKey;
135 
136         X509Credentials(PublicKey popPublicKey, X509Certificate[] popCerts) {
137             this.popCerts = popCerts;
138             this.popPublicKey = popPublicKey;
139         }
140     }
141 
142     private static final
143             class X509PossessionGenerator implements SSLPossessionGenerator {
144         private final String[] keyTypes;
145 
146         private X509PossessionGenerator(String[] keyTypes) {
147             this.keyTypes = keyTypes;
148         }
149 
150         @Override
151         public SSLPossession createPossession(HandshakeContext context) {
152             if (context.sslConfig.isClientMode) {
153                 for (String keyType : keyTypes) {
154                     SSLPossession poss = createClientPossession(
155                             (ClientHandshakeContext)context, keyType);
156                     if (poss != null) {
157                         return poss;
158                     }
159                 }
160             } else {
161                 for (String keyType : keyTypes) {
162                     SSLPossession poss = createServerPossession(
163                             (ServerHandshakeContext)context, keyType);
164                     if (poss != null) {
165                         return poss;
166                     }
167                 }
168             }
169 
170             return null;
171         }
172 
173         // Used by TLS 1.2 and TLS 1.3.
174         private SSLPossession createClientPossession(
175                 ClientHandshakeContext chc, String keyType) {
176             X509ExtendedKeyManager km = chc.sslContext.getX509KeyManager();
177             String clientAlias = null;
178             if (chc.conContext.transport instanceof SSLSocketImpl) {
179                 clientAlias = km.chooseClientAlias(
180                         new String[] { keyType },
181                         chc.peerSupportedAuthorities,
182                         (SSLSocket)chc.conContext.transport);
183             } else if (chc.conContext.transport instanceof SSLEngineImpl) {
184                 clientAlias = km.chooseEngineClientAlias(
185                         new String[] { keyType },
186                         chc.peerSupportedAuthorities,
187                         (SSLEngine)chc.conContext.transport);
188             }
189 
190             if (clientAlias == null) {
191                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
192                     SSLLogger.finest(&quot;No X.509 cert selected for &quot; + keyType);
193                 }
194                 return null;
195             }
196 
197             PrivateKey clientPrivateKey = km.getPrivateKey(clientAlias);
198             if (clientPrivateKey == null) {
199                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
200                     SSLLogger.finest(
201                             clientAlias + &quot; is not a private key entry&quot;);
202                 }
203                 return null;
204             }
205 
206             X509Certificate[] clientCerts = km.getCertificateChain(clientAlias);
207             if ((clientCerts == null) || (clientCerts.length == 0)) {
208                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
209                     SSLLogger.finest(clientAlias +
210                         &quot; is a private key entry with no cert chain stored&quot;);
211                 }
212                 return null;
213             }
214 
215             PublicKey clientPublicKey = clientCerts[0].getPublicKey();
216             if ((!clientPrivateKey.getAlgorithm().equals(keyType))
217                     || (!clientPublicKey.getAlgorithm().equals(keyType))) {
218                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
219                     SSLLogger.fine(
220                             clientAlias + &quot; private or public key is not of &quot; +
221                             keyType + &quot; algorithm&quot;);
222                 }
223                 return null;
224             }
225 
226             return new X509Possession(clientPrivateKey, clientCerts);
227         }
228 
229         private SSLPossession createServerPossession(
230                 ServerHandshakeContext shc, String keyType) {
231             X509ExtendedKeyManager km = shc.sslContext.getX509KeyManager();
232             String serverAlias = null;
233             if (shc.conContext.transport instanceof SSLSocketImpl) {
234                 serverAlias = km.chooseServerAlias(keyType,
235                         null, (SSLSocket)shc.conContext.transport);
236             } else if (shc.conContext.transport instanceof SSLEngineImpl) {
237                 serverAlias = km.chooseEngineServerAlias(keyType,
238                         null, (SSLEngine)shc.conContext.transport);
239             }
240 
241             if (serverAlias == null) {
242                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
243                     SSLLogger.finest(&quot;No X.509 cert selected for &quot; + keyType);
244                 }
245                 return null;
246             }
247 
248             PrivateKey serverPrivateKey = km.getPrivateKey(serverAlias);
249             if (serverPrivateKey == null) {
250                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
251                     SSLLogger.finest(
252                             serverAlias + &quot; is not a private key entry&quot;);
253                 }
254                 return null;
255             }
256 
257             X509Certificate[] serverCerts = km.getCertificateChain(serverAlias);
258             if ((serverCerts == null) || (serverCerts.length == 0)) {
259                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
260                     SSLLogger.finest(
261                             serverAlias + &quot; is not a certificate entry&quot;);
262                 }
263                 return null;
264             }
265 
266             PublicKey serverPublicKey = serverCerts[0].getPublicKey();
267             if ((!serverPrivateKey.getAlgorithm().equals(keyType))
268                     || (!serverPublicKey.getAlgorithm().equals(keyType))) {
269                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
270                     SSLLogger.fine(
271                             serverAlias + &quot; private or public key is not of &quot; +
272                             keyType + &quot; algorithm&quot;);
273                 }
274                 return null;
275             }
276 
277             // For ECC certs, check whether we support the EC domain
278             // parameters.  If the client sent a SupportedEllipticCurves
279             // ClientHello extension, check against that too.
280             if (keyType.equals(&quot;EC&quot;)) {
281                 if (!(serverPublicKey instanceof ECPublicKey)) {
282                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
283                         SSLLogger.warning(serverAlias +
284                             &quot; public key is not an instance of ECPublicKey&quot;);
285                     }
286                     return null;
287                 }
288 
289                 // For ECC certs, check whether we support the EC domain
290                 // parameters. If the client sent a SupportedEllipticCurves
291                 // ClientHello extension, check against that too.
292                 ECParameterSpec params =
293                         ((ECPublicKey)serverPublicKey).getParams();
294                 NamedGroup namedGroup = NamedGroup.valueOf(params);
295                 if ((namedGroup == null) ||
296                         (!SupportedGroups.isSupported(namedGroup)) ||
297                         ((shc.clientRequestedNamedGroups != null) &amp;&amp;
298                         !shc.clientRequestedNamedGroups.contains(namedGroup))) {
299 
300                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
301                         SSLLogger.warning(
302                             &quot;Unsupported named group (&quot; + namedGroup +
303                             &quot;) used in the &quot; + serverAlias + &quot; certificate&quot;);
304                     }
305 
306                     return null;
307                 }
308             }
309 
310             return new X509Possession(serverPrivateKey, serverCerts);
311         }
312     }
313 }
    </pre>
  </body>
</html>
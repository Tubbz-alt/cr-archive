<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/CertificateMessage.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.ByteArrayInputStream;
  29 import java.io.IOException;
  30 import java.nio.ByteBuffer;
  31 import java.security.PublicKey;
  32 import java.security.cert.CertPathValidatorException;
  33 import java.security.cert.CertPathValidatorException.BasicReason;
  34 import java.security.cert.CertPathValidatorException.Reason;
  35 import java.security.cert.CertificateEncodingException;
  36 import java.security.cert.CertificateException;
  37 import java.security.cert.CertificateFactory;
  38 import java.security.cert.CertificateParsingException;
  39 import java.security.cert.X509Certificate;
  40 import java.text.MessageFormat;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collection;
  44 import java.util.Collections;
  45 import java.util.HashSet;
  46 import java.util.LinkedList;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import javax.net.ssl.SSLEngine;
  50 import javax.net.ssl.SSLException;
  51 import javax.net.ssl.SSLProtocolException;
  52 import javax.net.ssl.SSLSocket;
  53 import javax.net.ssl.X509ExtendedTrustManager;
  54 import javax.net.ssl.X509TrustManager;
  55 import javax.security.auth.x500.X500Principal;
  56 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  57 import sun.security.ssl.ClientHello.ClientHelloMessage;
  58 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  59 import sun.security.ssl.X509Authentication.X509Credentials;
  60 import sun.security.ssl.X509Authentication.X509Possession;
  61 
  62 /**
  63  * Pack of the CertificateMessage handshake message.
  64  */
  65 final class CertificateMessage {
  66     static final SSLConsumer t12HandshakeConsumer =
  67         new T12CertificateConsumer();
  68     static final HandshakeProducer t12HandshakeProducer =
  69         new T12CertificateProducer();
  70 
  71     static final SSLConsumer t13HandshakeConsumer =
  72         new T13CertificateConsumer();
  73     static final HandshakeProducer t13HandshakeProducer =
  74         new T13CertificateProducer();
  75 
  76     /**
  77      * The Certificate handshake message for TLS 1.2 and previous
  78      * SSL/TLS protocol versions.
  79      *
  80      * In server mode, the certificate handshake message is sent whenever the
  81      * agreed-upon key exchange method uses certificates for authentication.
  82      * In client mode, this message is only sent if the server requests a
  83      * certificate for client authentication.
  84      *
  85      *       opaque ASN.1Cert&lt;1..2^24-1&gt;;
  86      *
  87      * SSL 3.0:
  88      *       struct {
  89      *           ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
  90      *       } Certificate;
  91      * Note: For SSL 3.0 client authentication, if no suitable certificate
  92      * is available, the client should send a no_certificate alert instead.
  93      * This alert is only a warning; however, the server may respond with
  94      * a fatal handshake failure alert if client authentication is required.
  95      *
  96      * TLS 1.0/1.1/1.2:
  97      *       struct {
  98      *           ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
  99      *       } Certificate;
 100      */
 101     static final class T12CertificateMessage extends HandshakeMessage {
 102         final List&lt;byte[]&gt; encodedCertChain;
 103 
 104         T12CertificateMessage(HandshakeContext handshakeContext,
 105                 X509Certificate[] certChain) throws SSLException {
 106             super(handshakeContext);
 107 
 108             List&lt;byte[]&gt; encodedCerts = new ArrayList&lt;&gt;(certChain.length);
 109             for (X509Certificate cert : certChain) {
 110                 try {
 111                     encodedCerts.add(cert.getEncoded());
 112                 } catch (CertificateEncodingException cee) {
 113                     // unlikely
 114                     throw handshakeContext.conContext.fatal(
 115                             Alert.INTERNAL_ERROR,
 116                             &quot;Could not encode certificate (&quot; +
 117                             cert.getSubjectX500Principal() + &quot;)&quot;, cee);
 118                 }
 119             }
 120 
 121             this.encodedCertChain = encodedCerts;
 122         }
 123 
 124         T12CertificateMessage(HandshakeContext handshakeContext,
 125                 ByteBuffer m) throws IOException {
 126             super(handshakeContext);
 127 
 128             int listLen = Record.getInt24(m);
 129             if (listLen &gt; m.remaining()) {
 130                 throw handshakeContext.conContext.fatal(
 131                     Alert.ILLEGAL_PARAMETER,
 132                     &quot;Error parsing certificate message:no sufficient data&quot;);
 133             }
 134             if (listLen &gt; 0) {
 135                 List&lt;byte[]&gt; encodedCerts = new LinkedList&lt;&gt;();
 136                 while (listLen &gt; 0) {
 137                     byte[] encodedCert = Record.getBytes24(m);
 138                     listLen -= (3 + encodedCert.length);
 139                     encodedCerts.add(encodedCert);
 140                 }
 141                 this.encodedCertChain = encodedCerts;
 142             } else {
 143                 this.encodedCertChain = Collections.emptyList();
 144             }
 145         }
 146 
 147         @Override
 148         public SSLHandshake handshakeType() {
 149             return SSLHandshake.CERTIFICATE;
 150         }
 151 
 152         @Override
 153         public int messageLength() {
 154             int msgLen = 3;
 155             for (byte[] encodedCert : encodedCertChain) {
 156                 msgLen += (encodedCert.length + 3);
 157             }
 158 
 159             return msgLen;
 160         }
 161 
 162         @Override
 163         public void send(HandshakeOutStream hos) throws IOException {
 164             int listLen = 0;
 165             for (byte[] encodedCert : encodedCertChain) {
 166                 listLen += (encodedCert.length + 3);
 167             }
 168 
 169             hos.putInt24(listLen);
 170             for (byte[] encodedCert : encodedCertChain) {
 171                 hos.putBytes24(encodedCert);
 172             }
 173         }
 174 
 175         @Override
 176         public String toString() {
 177             if (encodedCertChain.isEmpty()) {
 178                 return &quot;\&quot;Certificates\&quot;: &lt;empty list&gt;&quot;;
 179             }
 180 
 181             Object[] x509Certs = new Object[encodedCertChain.size()];
 182             try {
 183                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 184                 int i = 0;
 185                 for (byte[] encodedCert : encodedCertChain) {
 186                     Object obj;
 187                     try {
 188                         obj = (X509Certificate)cf.generateCertificate(
 189                                     new ByteArrayInputStream(encodedCert));
 190                     } catch (CertificateException ce) {
 191                         obj = encodedCert;
 192                     }
 193                     x509Certs[i++] = obj;
 194                 }
 195             } catch (CertificateException ce) {
 196                 // no X.509 certificate factory service
 197                 int i = 0;
 198                 for (byte[] encodedCert : encodedCertChain) {
 199                     x509Certs[i++] = encodedCert;
 200                 }
 201             }
 202 
 203             MessageFormat messageFormat = new MessageFormat(
 204                     &quot;\&quot;Certificates\&quot;: [\n&quot; +
 205                     &quot;{0}\n&quot; +
 206                     &quot;]&quot;,
 207                     Locale.ENGLISH);
 208             Object[] messageFields = {
 209                 SSLLogger.toString(x509Certs)
 210             };
 211 
 212             return messageFormat.format(messageFields);
 213         }
 214     }
 215 
 216     /**
 217      * The &quot;Certificate&quot; handshake message producer for TLS 1.2 and
 218      * previous SSL/TLS protocol versions.
 219      */
 220     private static final
 221             class T12CertificateProducer implements HandshakeProducer {
 222         // Prevent instantiation of this class.
 223         private T12CertificateProducer() {
 224             // blank
 225         }
 226 
 227         @Override
 228         public byte[] produce(ConnectionContext context,
 229                 HandshakeMessage message) throws IOException {
 230             // The producing happens in handshake context only.
 231             HandshakeContext hc = (HandshakeContext)context;
 232             if (hc.sslConfig.isClientMode) {
 233                 return onProduceCertificate(
 234                         (ClientHandshakeContext)context, message);
 235             } else {
 236                 return onProduceCertificate(
 237                         (ServerHandshakeContext)context, message);
 238             }
 239         }
 240 
 241         private byte[] onProduceCertificate(ServerHandshakeContext shc,
 242                 SSLHandshake.HandshakeMessage message) throws IOException {
 243             X509Possession x509Possession = null;
 244             for (SSLPossession possession : shc.handshakePossessions) {
 245                 if (possession instanceof X509Possession) {
 246                     x509Possession = (X509Possession)possession;
 247                     break;
 248                 }
 249             }
 250 
 251             if (x509Possession == null) {       // unlikely
 252                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 253                     &quot;No expected X.509 certificate for server authentication&quot;);
 254             }
 255 
 256             shc.handshakeSession.setLocalPrivateKey(
 257                     x509Possession.popPrivateKey);
 258             shc.handshakeSession.setLocalCertificates(x509Possession.popCerts);
 259             T12CertificateMessage cm =
 260                     new T12CertificateMessage(shc, x509Possession.popCerts);
 261             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 262                 SSLLogger.fine(
 263                     &quot;Produced server Certificate handshake message&quot;, cm);
 264             }
 265 
 266             // Output the handshake message.
 267             cm.write(shc.handshakeOutput);
 268             shc.handshakeOutput.flush();
 269 
 270             // The handshake message has been delivered.
 271             return null;
 272         }
 273 
 274         private byte[] onProduceCertificate(ClientHandshakeContext chc,
 275                 SSLHandshake.HandshakeMessage message) throws IOException {
 276             X509Possession x509Possession = null;
 277             for (SSLPossession possession : chc.handshakePossessions) {
 278                 if (possession instanceof X509Possession) {
 279                     x509Possession = (X509Possession)possession;
 280                     break;
 281                 }
 282             }
 283 
 284             // Report to the server if no appropriate cert was found.  For
 285             // SSL 3.0, send a no_certificate alert;  TLS 1.0/1.1/1.2 uses
 286             // an empty cert chain instead.
 287             if (x509Possession == null) {
 288                 if (chc.negotiatedProtocol.useTLS10PlusSpec()) {
 289                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 290                         SSLLogger.fine(
 291                             &quot;No X.509 certificate for client authentication, &quot; +
 292                             &quot;use empty Certificate message instead&quot;);
 293                     }
 294 
 295                     x509Possession =
 296                             new X509Possession(null, new X509Certificate[0]);
 297                 } else {
 298                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 299                         SSLLogger.fine(
 300                             &quot;No X.509 certificate for client authentication, &quot; +
 301                             &quot;send a no_certificate alert&quot;);
 302                     }
 303 
 304                     chc.conContext.warning(Alert.NO_CERTIFICATE);
 305                     return null;
 306                 }
 307             }
 308 
 309             chc.handshakeSession.setLocalPrivateKey(
 310                     x509Possession.popPrivateKey);
 311             if (x509Possession.popCerts != null &amp;&amp;
 312                     x509Possession.popCerts.length != 0) {
 313                 chc.handshakeSession.setLocalCertificates(
 314                         x509Possession.popCerts);
 315             } else {
 316                 chc.handshakeSession.setLocalCertificates(null);
 317             }
 318             T12CertificateMessage cm =
 319                     new T12CertificateMessage(chc, x509Possession.popCerts);
 320             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 321                 SSLLogger.fine(
 322                     &quot;Produced client Certificate handshake message&quot;, cm);
 323             }
 324 
 325             // Output the handshake message.
 326             cm.write(chc.handshakeOutput);
 327             chc.handshakeOutput.flush();
 328 
 329             // The handshake message has been delivered.
 330             return null;
 331         }
 332     }
 333 
 334     /**
 335      * The &quot;Certificate&quot; handshake message consumer for TLS 1.2 and
 336      * previous SSL/TLS protocol versions.
 337      */
 338     static final
 339             class T12CertificateConsumer implements SSLConsumer {
 340         // Prevent instantiation of this class.
 341         private T12CertificateConsumer() {
 342             // blank
 343         }
 344 
 345         @Override
 346         public void consume(ConnectionContext context,
 347                 ByteBuffer message) throws IOException {
 348             // The consuming happens in handshake context only.
 349             HandshakeContext hc = (HandshakeContext)context;
 350 
 351             // clean up this consumer
 352             hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);
 353 
 354             T12CertificateMessage cm = new T12CertificateMessage(hc, message);
 355             if (hc.sslConfig.isClientMode) {
 356                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 357                     SSLLogger.fine(
 358                         &quot;Consuming server Certificate handshake message&quot;, cm);
 359                 }
 360                 onCertificate((ClientHandshakeContext)context, cm);
 361             } else {
 362                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 363                     SSLLogger.fine(
 364                         &quot;Consuming client Certificate handshake message&quot;, cm);
 365                 }
 366                 onCertificate((ServerHandshakeContext)context, cm);
 367             }
 368         }
 369 
 370         private void onCertificate(ServerHandshakeContext shc,
 371                 T12CertificateMessage certificateMessage )throws IOException {
 372             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 373             if (encodedCerts == null || encodedCerts.isEmpty()) {
 374                 // For empty Certificate messages, we should not expect
 375                 // a CertificateVerify message to follow
 376                 shc.handshakeConsumers.remove(
 377                         SSLHandshake.CERTIFICATE_VERIFY.id);
 378                 if (shc.sslConfig.clientAuthType !=
 379                         ClientAuthType.CLIENT_AUTH_REQUESTED) {
 380                     // unexpected or require client authentication
 381                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 382                         &quot;Empty server certificate chain&quot;);
 383                 } else {
 384                     return;
 385                 }
 386             }
 387 
 388             X509Certificate[] x509Certs =
 389                     new X509Certificate[encodedCerts.size()];
 390             try {
 391                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 392                 int i = 0;
 393                 for (byte[] encodedCert : encodedCerts) {
 394                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 395                                     new ByteArrayInputStream(encodedCert));
 396                 }
 397             } catch (CertificateException ce) {
 398                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
 399                     &quot;Failed to parse server certificates&quot;, ce);
 400             }
 401 
 402             checkClientCerts(shc, x509Certs);
 403 
 404             //
 405             // update
 406             //
 407             shc.handshakeCredentials.add(
 408                 new X509Credentials(x509Certs[0].getPublicKey(), x509Certs));
 409             shc.handshakeSession.setPeerCertificates(x509Certs);
 410         }
 411 
 412         private void onCertificate(ClientHandshakeContext chc,
 413                 T12CertificateMessage certificateMessage) throws IOException {
 414             List&lt;byte[]&gt; encodedCerts = certificateMessage.encodedCertChain;
 415             if (encodedCerts == null || encodedCerts.isEmpty()) {
 416                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 417                     &quot;Empty server certificate chain&quot;);
 418             }
 419 
 420             X509Certificate[] x509Certs =
 421                     new X509Certificate[encodedCerts.size()];
 422             try {
 423                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 424                 int i = 0;
 425                 for (byte[] encodedCert : encodedCerts) {
 426                     x509Certs[i++] = (X509Certificate)cf.generateCertificate(
 427                                     new ByteArrayInputStream(encodedCert));
 428                 }
 429             } catch (CertificateException ce) {
 430                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 431                     &quot;Failed to parse server certificates&quot;, ce);
 432             }
 433 
 434             // Allow server certificate change in client side during
 435             // renegotiation after a session-resumption abbreviated
 436             // initial handshake?
 437             //
 438             // DO NOT need to check allowUnsafeServerCertChange here. We only
 439             // reserve server certificates when allowUnsafeServerCertChange is
 440             // false.
 441             if (chc.reservedServerCerts != null &amp;&amp;
 442                     !chc.handshakeSession.useExtendedMasterSecret) {
 443                 // It is not necessary to check the certificate update if
 444                 // endpoint identification is enabled.
 445                 String identityAlg = chc.sslConfig.identificationProtocol;
 446                 if ((identityAlg == null || identityAlg.isEmpty()) &amp;&amp;
 447                         !isIdentityEquivalent(x509Certs[0],
 448                                 chc.reservedServerCerts[0])) {
 449                     throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
 450                             &quot;server certificate change is restricted &quot; +
 451                             &quot;during renegotiation&quot;);
 452                 }
 453             }
 454 
 455             // ask the trust manager to verify the chain
 456             if (chc.staplingActive) {
 457                 // Defer the certificate check until after we&#39;ve received the
 458                 // CertificateStatus message.  If that message doesn&#39;t come in
 459                 // immediately following this message we will execute the
 460                 // check from CertificateStatus&#39; absent handler.
 461                 chc.deferredCerts = x509Certs;
 462             } else {
 463                 // We&#39;re not doing stapling, so perform the check right now
 464                 checkServerCerts(chc, x509Certs);
 465             }
 466 
 467             //
 468             // update
 469             //
 470             chc.handshakeCredentials.add(
 471                 new X509Credentials(x509Certs[0].getPublicKey(), x509Certs));
 472             chc.handshakeSession.setPeerCertificates(x509Certs);
 473         }
 474 
 475         /*
 476          * Whether the certificates can represent the same identity?
 477          *
 478          * The certificates can be used to represent the same identity:
 479          *     1. If the subject alternative names of IP address are present
 480          *        in both certificates, they should be identical; otherwise,
 481          *     2. if the subject alternative names of DNS name are present in
 482          *        both certificates, they should be identical; otherwise,
 483          *     3. if the subject fields are present in both certificates, the
 484          *        certificate subjects and issuers should be identical.
 485          */
 486         private static boolean isIdentityEquivalent(X509Certificate thisCert,
 487                 X509Certificate prevCert) {
 488             if (thisCert.equals(prevCert)) {
 489                 return true;
 490             }
 491 
 492             // check subject alternative names
 493             Collection&lt;List&lt;?&gt;&gt; thisSubjectAltNames = null;
 494             try {
 495                 thisSubjectAltNames = thisCert.getSubjectAlternativeNames();
 496             } catch (CertificateParsingException cpe) {
 497                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 498                     SSLLogger.fine(
 499                         &quot;Attempt to obtain subjectAltNames extension failed!&quot;);
 500                 }
 501             }
 502 
 503             Collection&lt;List&lt;?&gt;&gt; prevSubjectAltNames = null;
 504             try {
 505                 prevSubjectAltNames = prevCert.getSubjectAlternativeNames();
 506             } catch (CertificateParsingException cpe) {
 507                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
 508                     SSLLogger.fine(
 509                         &quot;Attempt to obtain subjectAltNames extension failed!&quot;);
 510                 }
 511             }
 512 
 513             if (thisSubjectAltNames != null &amp;&amp; prevSubjectAltNames != null) {
 514                 // check the iPAddress field in subjectAltName extension
 515                 //
 516                 // 7: subject alternative name of type IP.
 517                 Collection&lt;String&gt; thisSubAltIPAddrs =
 518                             getSubjectAltNames(thisSubjectAltNames, 7);
 519                 Collection&lt;String&gt; prevSubAltIPAddrs =
 520                             getSubjectAltNames(prevSubjectAltNames, 7);
 521                 if (thisSubAltIPAddrs != null &amp;&amp; prevSubAltIPAddrs != null &amp;&amp;
 522                     isEquivalent(thisSubAltIPAddrs, prevSubAltIPAddrs)) {
 523                     return true;
 524                 }
 525 
 526                 // check the dNSName field in subjectAltName extension
 527                 // 2: subject alternative name of type IP.
 528                 Collection&lt;String&gt; thisSubAltDnsNames =
 529                             getSubjectAltNames(thisSubjectAltNames, 2);
 530                 Collection&lt;String&gt; prevSubAltDnsNames =
 531                             getSubjectAltNames(prevSubjectAltNames, 2);
 532                 if (thisSubAltDnsNames != null &amp;&amp; prevSubAltDnsNames != null &amp;&amp;
 533                     isEquivalent(thisSubAltDnsNames, prevSubAltDnsNames)) {
 534                     return true;
 535                 }
 536             }
 537 
 538             // check the certificate subject and issuer
 539             X500Principal thisSubject = thisCert.getSubjectX500Principal();
 540             X500Principal prevSubject = prevCert.getSubjectX500Principal();
 541             X500Principal thisIssuer = thisCert.getIssuerX500Principal();
 542             X500Principal prevIssuer = prevCert.getIssuerX500Principal();
 543 
 544             return (!thisSubject.getName().isEmpty() &amp;&amp;
 545                     !prevSubject.getName().isEmpty() &amp;&amp;
 546                     thisSubject.equals(prevSubject) &amp;&amp;
 547                     thisIssuer.equals(prevIssuer));
 548         }
 549 
 550         /*
 551          * Returns the subject alternative name of the specified type in the
 552          * subjectAltNames extension of a certificate.
 553          *
 554          * Note that only those subjectAltName types that use String data
 555          * should be passed into this function.
 556          */
 557         private static Collection&lt;String&gt; getSubjectAltNames(
 558                 Collection&lt;List&lt;?&gt;&gt; subjectAltNames, int type) {
 559             HashSet&lt;String&gt; subAltDnsNames = null;
 560             for (List&lt;?&gt; subjectAltName : subjectAltNames) {
 561                 int subjectAltNameType = (Integer)subjectAltName.get(0);
 562                 if (subjectAltNameType == type) {
 563                     String subAltDnsName = (String)subjectAltName.get(1);
 564                     if ((subAltDnsName != null) &amp;&amp; !subAltDnsName.isEmpty()) {
 565                         if (subAltDnsNames == null) {
 566                             subAltDnsNames =
 567                                     new HashSet&lt;&gt;(subjectAltNames.size());
 568                         }
 569                         subAltDnsNames.add(subAltDnsName);
 570                     }
 571                 }
 572             }
 573 
 574             return subAltDnsNames;
 575         }
 576 
 577         private static boolean isEquivalent(Collection&lt;String&gt; thisSubAltNames,
 578                 Collection&lt;String&gt; prevSubAltNames) {
 579             for (String thisSubAltName : thisSubAltNames) {
 580                 for (String prevSubAltName : prevSubAltNames) {
 581                     // Only allow the exactly match.  No wildcard character
 582                     // checking.
 583                     if (thisSubAltName.equalsIgnoreCase(prevSubAltName)) {
 584                         return true;
 585                     }
 586                 }
 587             }
 588 
 589             return false;
 590         }
 591 
 592         /**
 593          * Perform client-side checking of server certificates.
 594          *
 595          * @param certs an array of {@code X509Certificate} objects presented
 596          *      by the server in the ServerCertificate message.
 597          *
 598          * @throws IOException if a failure occurs during validation or
 599          *      the trust manager associated with the {@code SSLContext} is not
 600          *      an {@code X509ExtendedTrustManager}.
 601          */
 602         static void checkServerCerts(ClientHandshakeContext chc,
 603                 X509Certificate[] certs) throws IOException {
 604 
 605             X509TrustManager tm = chc.sslContext.getX509TrustManager();
 606 
 607             // find out the key exchange algorithm used
 608             // use &quot;RSA&quot; for non-ephemeral &quot;RSA_EXPORT&quot;
 609             String keyExchangeString;
 610             if (chc.negotiatedCipherSuite.keyExchange ==
 611                     CipherSuite.KeyExchange.K_RSA_EXPORT ||
 612                     chc.negotiatedCipherSuite.keyExchange ==
 613                             CipherSuite.KeyExchange.K_DHE_RSA_EXPORT) {
 614                 keyExchangeString = CipherSuite.KeyExchange.K_RSA.name;
 615             } else {
 616                 keyExchangeString = chc.negotiatedCipherSuite.keyExchange.name;
 617             }
 618 
 619             try {
 620                 if (tm instanceof X509ExtendedTrustManager) {
 621                     if (chc.conContext.transport instanceof SSLEngine) {
 622                         SSLEngine engine = (SSLEngine)chc.conContext.transport;
 623                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
 624                             certs.clone(),
 625                             keyExchangeString,
 626                             engine);
 627                     } else {
 628                         SSLSocket socket = (SSLSocket)chc.conContext.transport;
 629                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
 630                             certs.clone(),
 631                             keyExchangeString,
 632                             socket);
 633                     }
 634                 } else {
 635                     // Unlikely to happen, because we have wrapped the old
 636                     // X509TrustManager with the new X509ExtendedTrustManager.
 637                     throw new CertificateException(
 638                             &quot;Improper X509TrustManager implementation&quot;);
 639                 }
 640 
 641                 // Once the server certificate chain has been validated, set
 642                 // the certificate chain in the TLS session.
 643                 chc.handshakeSession.setPeerCertificates(certs);
 644             } catch (CertificateException ce) {
 645                 throw chc.conContext.fatal(getCertificateAlert(chc, ce), ce);
 646             }
 647         }
 648 
 649         private static void checkClientCerts(ServerHandshakeContext shc,
 650                 X509Certificate[] certs) throws IOException {
 651             X509TrustManager tm = shc.sslContext.getX509TrustManager();
 652 
 653             // find out the types of client authentication used
 654             PublicKey key = certs[0].getPublicKey();
 655             String keyAlgorithm = key.getAlgorithm();
 656             String authType;
 657             switch (keyAlgorithm) {
 658                 case &quot;RSA&quot;:
 659                 case &quot;DSA&quot;:
 660                 case &quot;EC&quot;:
 661                 case &quot;RSASSA-PSS&quot;:
 662                     authType = keyAlgorithm;
 663                     break;
 664                 default:
 665                     // unknown public key type
 666                     authType = &quot;UNKNOWN&quot;;
 667             }
 668 
 669             try {
 670                 if (tm instanceof X509ExtendedTrustManager) {
 671                     if (shc.conContext.transport instanceof SSLEngine) {
 672                         SSLEngine engine = (SSLEngine)shc.conContext.transport;
 673                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
 674                             certs.clone(),
 675                             authType,
 676                             engine);
 677                     } else {
 678                         SSLSocket socket = (SSLSocket)shc.conContext.transport;
 679                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
 680                             certs.clone(),
 681                             authType,
 682                             socket);
 683                     }
 684                 } else {
 685                     // Unlikely to happen, because we have wrapped the old
 686                     // X509TrustManager with the new X509ExtendedTrustManager.
 687                     throw new CertificateException(
 688                             &quot;Improper X509TrustManager implementation&quot;);
 689                 }
 690             } catch (CertificateException ce) {
 691                 throw shc.conContext.fatal(Alert.CERTIFICATE_UNKNOWN, ce);
 692             }
 693         }
 694 
 695         /**
 696          * When a failure happens during certificate checking from an
 697          * {@link X509TrustManager}, determine what TLS alert description
 698          * to use.
 699          *
 700          * @param cexc The exception thrown by the {@link X509TrustManager}
 701          *
 702          * @return A byte value corresponding to a TLS alert description number.
 703          */
 704         private static Alert getCertificateAlert(
 705                 ClientHandshakeContext chc, CertificateException cexc) {
 706             // The specific reason for the failure will determine how to
 707             // set the alert description value
 708             Alert alert = Alert.CERTIFICATE_UNKNOWN;
 709 
 710             Throwable baseCause = cexc.getCause();
 711             if (baseCause instanceof CertPathValidatorException) {
 712                 CertPathValidatorException cpve =
 713                         (CertPathValidatorException)baseCause;
 714                 Reason reason = cpve.getReason();
 715                 if (reason == BasicReason.REVOKED) {
 716                     alert = chc.staplingActive ?
 717                             Alert.BAD_CERT_STATUS_RESPONSE :
 718                             Alert.CERTIFICATE_REVOKED;
 719                 } else if (
 720                         reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {
 721                     alert = chc.staplingActive ?
 722                             Alert.BAD_CERT_STATUS_RESPONSE :
 723                             Alert.CERTIFICATE_UNKNOWN;
 724                 } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {
 725                     alert = Alert.UNSUPPORTED_CERTIFICATE;
 726                 } else if (reason == BasicReason.EXPIRED) {
 727                     alert = Alert.CERTIFICATE_EXPIRED;
 728                 } else if (reason == BasicReason.INVALID_SIGNATURE ||
 729                         reason == BasicReason.NOT_YET_VALID) {
 730                     alert = Alert.BAD_CERTIFICATE;
 731                 }
 732             }
 733 
 734             return alert;
 735         }
 736 
 737     }
 738 
 739     /**
 740      * The certificate entry used in Certificate handshake message for TLS 1.3.
 741      */
 742     static final class CertificateEntry {
 743         final byte[] encoded;       // encoded cert or public key
 744         private final SSLExtensions extensions;
 745 
 746         CertificateEntry(byte[] encoded, SSLExtensions extensions) {
 747             this.encoded = encoded;
 748             this.extensions = extensions;
 749         }
 750 
 751         private int getEncodedSize() {
 752             int extLen = extensions.length();
 753             if (extLen == 0) {
 754                 extLen = 2;     // empty extensions
 755             }
 756             return 3 + encoded.length + extLen;
 757         }
 758 
 759         @Override
 760         public String toString() {
 761             MessageFormat messageFormat = new MessageFormat(
 762                 &quot;\n&#39;{&#39;\n&quot; +
 763                 &quot;{0}\n&quot; +                       // X.509 certificate
 764                 &quot;  \&quot;extensions\&quot;: &#39;{&#39;\n&quot; +
 765                 &quot;{1}\n&quot; +
 766                 &quot;  &#39;}&#39;\n&quot; +
 767                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
 768 
 769             Object x509Certs;
 770             try {
 771                 // Don&#39;t support certificate type extension (RawPublicKey) yet.
 772                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 773                 x509Certs =
 774                     cf.generateCertificate(new ByteArrayInputStream(encoded));
 775             } catch (CertificateException ce) {
 776                 // no X.509 certificate factory service
 777                 x509Certs = encoded;
 778             }
 779 
 780             Object[] messageFields = {
 781                 SSLLogger.toString(x509Certs),
 782                 Utilities.indent(extensions.toString(), &quot;    &quot;)
 783             };
 784 
 785             return messageFormat.format(messageFields);
 786         }
 787     }
 788 
 789     /**
 790      * The Certificate handshake message for TLS 1.3.
 791      */
 792     static final class T13CertificateMessage extends HandshakeMessage {
 793         private final byte[] requestContext;
 794         private final List&lt;CertificateEntry&gt; certEntries;
 795 
 796         T13CertificateMessage(HandshakeContext context,
 797                 byte[] requestContext, X509Certificate[] certificates)
 798                 throws SSLException, CertificateException  {
 799             super(context);
 800 
 801             this.requestContext = requestContext.clone();
 802             this.certEntries = new LinkedList&lt;&gt;();
 803             for (X509Certificate cert : certificates) {
 804                 byte[] encoded = cert.getEncoded();
 805                 SSLExtensions extensions = new SSLExtensions(this);
 806                 certEntries.add(new CertificateEntry(encoded, extensions));
 807             }
 808         }
 809 
 810         T13CertificateMessage(HandshakeContext handshakeContext,
 811                 byte[] requestContext, List&lt;CertificateEntry&gt; certificates) {
 812             super(handshakeContext);
 813 
 814             this.requestContext = requestContext.clone();
 815             this.certEntries = certificates;
 816         }
 817 
 818         T13CertificateMessage(HandshakeContext handshakeContext,
 819                 ByteBuffer m) throws IOException {
 820             super(handshakeContext);
 821 
 822             // struct {
 823             //      opaque certificate_request_context&lt;0..2^8-1&gt;;
 824             //      CertificateEntry certificate_list&lt;0..2^24-1&gt;;
 825             //  } Certificate;
 826             if (m.remaining() &lt; 4) {
 827                 throw new SSLProtocolException(
 828                         &quot;Invalid Certificate message: &quot; +
 829                         &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);
 830             }
 831             this.requestContext = Record.getBytes8(m);
 832 
 833             if (m.remaining() &lt; 3) {
 834                 throw new SSLProtocolException(
 835                         &quot;Invalid Certificate message: &quot; +
 836                         &quot;insufficient certificate entries data (length=&quot; +
 837                         m.remaining() + &quot;)&quot;);
 838             }
 839 
 840             int listLen = Record.getInt24(m);
 841             if (listLen != m.remaining()) {
 842                 throw new SSLProtocolException(
 843                     &quot;Invalid Certificate message: &quot; +
 844                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;);
 845             }
 846 
 847             SSLExtension[] enabledExtensions =
 848                 handshakeContext.sslConfig.getEnabledExtensions(
 849                         SSLHandshake.CERTIFICATE);
 850             List&lt;CertificateEntry&gt; certList = new LinkedList&lt;&gt;();
 851             while (m.hasRemaining()) {
 852                 // Note: support only X509 CertificateType right now.
 853                 byte[] encodedCert = Record.getBytes24(m);
 854                 if (encodedCert.length == 0) {
 855                     throw new SSLProtocolException(
 856                         &quot;Invalid Certificate message: empty cert_data&quot;);
 857                 }
 858 
 859                 SSLExtensions extensions =
 860                         new SSLExtensions(this, m, enabledExtensions);
 861                 certList.add(new CertificateEntry(encodedCert, extensions));
 862             }
 863 
 864             this.certEntries = Collections.unmodifiableList(certList);
 865         }
 866 
 867         @Override
 868         public SSLHandshake handshakeType() {
 869             return SSLHandshake.CERTIFICATE;
 870         }
 871 
 872         @Override
 873         public int messageLength() {
 874             int msgLen = 4 + requestContext.length;
 875             for (CertificateEntry entry : certEntries) {
 876                 msgLen += entry.getEncodedSize();
 877             }
 878 
 879             return msgLen;
 880         }
 881 
 882         @Override
 883         public void send(HandshakeOutStream hos) throws IOException {
 884             int entryListLen = 0;
 885             for (CertificateEntry entry : certEntries) {
 886                 entryListLen += entry.getEncodedSize();
 887             }
 888 
 889             hos.putBytes8(requestContext);
 890             hos.putInt24(entryListLen);
 891             for (CertificateEntry entry : certEntries) {
 892                 hos.putBytes24(entry.encoded);
 893                 // Is it an empty extensions?
 894                 if (entry.extensions.length() == 0) {
 895                     hos.putInt16(0);
 896                 } else {
 897                     entry.extensions.send(hos);
 898                 }
 899             }
 900         }
 901 
 902         @Override
 903         public String toString() {
 904             MessageFormat messageFormat = new MessageFormat(
 905                 &quot;\&quot;Certificate\&quot;: &#39;{&#39;\n&quot; +
 906                 &quot;  \&quot;certificate_request_context\&quot;: \&quot;{0}\&quot;,\n&quot; +
 907                 &quot;  \&quot;certificate_list\&quot;: [{1}\n]\n&quot; +
 908                 &quot;&#39;}&#39;&quot;,
 909                 Locale.ENGLISH);
 910 
 911             StringBuilder builder = new StringBuilder(512);
 912             for (CertificateEntry entry : certEntries) {
 913                 builder.append(entry.toString());
 914             }
 915 
 916             Object[] messageFields = {
 917                 Utilities.toHexString(requestContext),
 918                 Utilities.indent(builder.toString())
 919             };
 920 
 921             return messageFormat.format(messageFields);
 922         }
 923     }
 924 
 925     /**
 926      * The &quot;Certificate&quot; handshake message producer for TLS 1.3.
 927      */
 928     private static final
 929             class T13CertificateProducer implements HandshakeProducer {
 930         // Prevent instantiation of this class.
 931         private T13CertificateProducer() {
 932             // blank
 933         }
 934 
 935         @Override
 936         public byte[] produce(ConnectionContext context,
 937                 HandshakeMessage message) throws IOException {
 938             // The producing happens in handshake context only.
 939             HandshakeContext hc = (HandshakeContext)context;
 940             if (hc.sslConfig.isClientMode) {
 941                 return onProduceCertificate(
 942                         (ClientHandshakeContext)context, message);
 943             } else {
 944                 return onProduceCertificate(
 945                         (ServerHandshakeContext)context, message);
 946             }
 947         }
 948 
 949         private byte[] onProduceCertificate(ServerHandshakeContext shc,
 950                 HandshakeMessage message) throws IOException {
 951             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 952 
 953             SSLPossession pos = choosePossession(shc, clientHello);
 954             if (pos == null) {
 955                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 956                         &quot;No available authentication scheme&quot;);
 957             }
 958 
 959             if (!(pos instanceof X509Possession)) {
 960                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 961                         &quot;No X.509 certificate for server authentication&quot;);
 962             }
 963 
 964             X509Possession x509Possession = (X509Possession)pos;
 965             X509Certificate[] localCerts = x509Possession.popCerts;
 966             if (localCerts == null || localCerts.length == 0) {
 967                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 968                         &quot;No X.509 certificate for server authentication&quot;);
 969             }
 970 
 971             // update the context
 972             shc.handshakePossessions.add(x509Possession);
 973             shc.handshakeSession.setLocalPrivateKey(
 974                     x509Possession.popPrivateKey);
 975             shc.handshakeSession.setLocalCertificates(localCerts);
 976             T13CertificateMessage cm;
 977             try {
 978                 cm = new T13CertificateMessage(shc, (new byte[0]), localCerts);
 979             } catch (SSLException | CertificateException ce) {
 980                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 981                         &quot;Failed to produce server Certificate message&quot;, ce);
 982             }
 983 
 984             // Check the OCSP stapling extensions and attempt
 985             // to get responses.  If the resulting stapleParams is non
 986             // null, it implies that stapling is enabled on the server side.
 987             shc.stapleParams = StatusResponseManager.processStapling(shc);
 988             shc.staplingActive = (shc.stapleParams != null);
 989 
 990             // Process extensions for each CertificateEntry.
 991             // Since there can be multiple CertificateEntries within a
 992             // single CT message, we will pin a specific CertificateEntry
 993             // into the ServerHandshakeContext so individual extension
 994             // producers know which X509Certificate it is processing in
 995             // each call.
 996             SSLExtension[] enabledCTExts = shc.sslConfig.getEnabledExtensions(
 997                     SSLHandshake.CERTIFICATE,
 998                     Arrays.asList(ProtocolVersion.PROTOCOLS_OF_13));
 999             for (CertificateEntry certEnt : cm.certEntries) {
1000                 shc.currentCertEntry = certEnt;
1001                 certEnt.extensions.produce(shc, enabledCTExts);
1002             }
1003 
1004             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1005                 SSLLogger.fine(&quot;Produced server Certificate message&quot;, cm);
1006             }
1007 
1008             // Output the handshake message.
1009             cm.write(shc.handshakeOutput);
1010             shc.handshakeOutput.flush();
1011 
1012             // The handshake message has been delivered.
1013             return null;
1014         }
1015 
1016         private static SSLPossession choosePossession(
1017                 HandshakeContext hc,
1018                 ClientHelloMessage clientHello) throws IOException {
1019             if (hc.peerRequestedCertSignSchemes == null ||
1020                     hc.peerRequestedCertSignSchemes.isEmpty()) {
1021                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1022                     SSLLogger.warning(
1023                             &quot;No signature_algorithms(_cert) in ClientHello&quot;);
1024                 }
1025                 return null;
1026             }
1027 
1028             Collection&lt;String&gt; checkedKeyTypes = new HashSet&lt;&gt;();
1029             for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {
1030                 if (checkedKeyTypes.contains(ss.keyAlgorithm)) {
1031                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1032                         SSLLogger.warning(
1033                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1034                     }
1035                     continue;
1036                 }
1037 
1038                 // Don&#39;t select a signature scheme unless we will be able to
1039                 // produce a CertificateVerify message later
1040                 if (SignatureScheme.getPreferableAlgorithm(
1041                         hc.algorithmConstraints,
1042                         hc.peerRequestedSignatureSchemes,
1043                         ss, hc.negotiatedProtocol) == null) {
1044 
1045                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1046                         SSLLogger.warning(
1047                             &quot;Unable to produce CertificateVerify for &quot; +
1048                             &quot;signature scheme: &quot; + ss.name);
1049                     }
1050                     checkedKeyTypes.add(ss.keyAlgorithm);
1051                     continue;
1052                 }
1053 
1054                 SSLAuthentication ka = X509Authentication.valueOf(ss);
1055                 if (ka == null) {
1056                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1057                         SSLLogger.warning(
1058                             &quot;Unsupported authentication scheme: &quot; + ss.name);
1059                     }
1060                     checkedKeyTypes.add(ss.keyAlgorithm);
1061                     continue;
1062                 }
1063 
1064                 SSLPossession pos = ka.createPossession(hc);
1065                 if (pos == null) {
1066                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1067                         SSLLogger.warning(
1068                             &quot;Unavailable authentication scheme: &quot; + ss.name);
1069                     }
1070                     continue;
1071                 }
1072 
1073                 return pos;
1074             }
1075 
1076             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1077                 SSLLogger.warning(&quot;No available authentication scheme&quot;);
1078             }
1079             return null;
1080         }
1081 
1082         private byte[] onProduceCertificate(ClientHandshakeContext chc,
1083                 HandshakeMessage message) throws IOException {
1084             ClientHelloMessage clientHello = (ClientHelloMessage)message;
1085             SSLPossession pos = choosePossession(chc, clientHello);
1086             X509Certificate[] localCerts;
1087             if (pos == null) {
1088                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1089                     SSLLogger.fine(&quot;No available client authentication scheme&quot;);
1090                 }
1091                 localCerts = new X509Certificate[0];
1092             } else {
1093                 chc.handshakePossessions.add(pos);
1094                 if (!(pos instanceof X509Possession)) {
1095                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1096                         SSLLogger.fine(
1097                             &quot;No X.509 certificate for client authentication&quot;);
1098                     }
1099                     localCerts = new X509Certificate[0];
1100                 } else {
1101                     X509Possession x509Possession = (X509Possession)pos;
1102                     localCerts = x509Possession.popCerts;
1103                     chc.handshakeSession.setLocalPrivateKey(
1104                             x509Possession.popPrivateKey);
1105                 }
1106             }
1107 
1108             if (localCerts != null &amp;&amp; localCerts.length != 0) {
1109                 chc.handshakeSession.setLocalCertificates(localCerts);
1110             } else {
1111                 chc.handshakeSession.setLocalCertificates(null);
1112             }
1113 
1114             T13CertificateMessage cm;
1115             try {
1116                 cm = new T13CertificateMessage(
1117                         chc, chc.certRequestContext, localCerts);
1118             } catch (SSLException | CertificateException ce) {
1119                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1120                         &quot;Failed to produce client Certificate message&quot;, ce);
1121             }
1122             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1123                 SSLLogger.fine(&quot;Produced client Certificate message&quot;, cm);
1124             }
1125 
1126             // Output the handshake message.
1127             cm.write(chc.handshakeOutput);
1128             chc.handshakeOutput.flush();
1129 
1130             // The handshake message has been delivered.
1131             return null;
1132         }
1133     }
1134 
1135     /**
1136      * The &quot;Certificate&quot; handshake message consumer for TLS 1.3.
1137      */
1138     private static final class T13CertificateConsumer implements SSLConsumer {
1139         // Prevent instantiation of this class.
1140         private T13CertificateConsumer() {
1141             // blank
1142         }
1143 
1144         @Override
1145         public void consume(ConnectionContext context,
1146                 ByteBuffer message) throws IOException {
1147             // The consuming happens in handshake context only.
1148             HandshakeContext hc = (HandshakeContext)context;
1149 
1150             // clean up this consumer
1151             hc.handshakeConsumers.remove(SSLHandshake.CERTIFICATE.id);
1152             T13CertificateMessage cm = new T13CertificateMessage(hc, message);
1153             if (hc.sslConfig.isClientMode) {
1154                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1155                     SSLLogger.fine(
1156                         &quot;Consuming server Certificate handshake message&quot;, cm);
1157                 }
1158                 onConsumeCertificate((ClientHandshakeContext)context, cm);
1159             } else {
1160                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1161                     SSLLogger.fine(
1162                         &quot;Consuming client Certificate handshake message&quot;, cm);
1163                 }
1164                 onConsumeCertificate((ServerHandshakeContext)context, cm);
1165             }
1166         }
1167 
1168         private void onConsumeCertificate(ServerHandshakeContext shc,
1169                 T13CertificateMessage certificateMessage )throws IOException {
1170             if (certificateMessage.certEntries == null ||
1171                     certificateMessage.certEntries.isEmpty()) {
1172                 // For empty Certificate messages, we should not expect
1173                 // a CertificateVerify message to follow
1174                 shc.handshakeConsumers.remove(
1175                         SSLHandshake.CERTIFICATE_VERIFY.id);
1176                 if (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED) {
1177                     throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1178                         &quot;Empty client certificate chain&quot;);
1179                 } else {
1180                     // optional client authentication
1181                     return;
1182                 }
1183             }
1184 
1185             // check client certificate entries
1186             X509Certificate[] cliCerts =
1187                     checkClientCerts(shc, certificateMessage.certEntries);
1188 
1189             //
1190             // update
1191             //
1192             shc.handshakeCredentials.add(
1193                 new X509Credentials(cliCerts[0].getPublicKey(), cliCerts));
1194             shc.handshakeSession.setPeerCertificates(cliCerts);
1195         }
1196 
1197         private void onConsumeCertificate(ClientHandshakeContext chc,
1198                 T13CertificateMessage certificateMessage )throws IOException {
1199             if (certificateMessage.certEntries == null ||
1200                     certificateMessage.certEntries.isEmpty()) {
1201                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
1202                     &quot;Empty server certificate chain&quot;);
1203             }
1204 
1205             // Each CertificateEntry will have its own set of extensions
1206             // which must be consumed.
1207             SSLExtension[] enabledExtensions =
1208                 chc.sslConfig.getEnabledExtensions(SSLHandshake.CERTIFICATE);
1209             for (CertificateEntry certEnt : certificateMessage.certEntries) {
1210                 certEnt.extensions.consumeOnLoad(chc, enabledExtensions);
1211             }
1212 
1213             // check server certificate entries
1214             X509Certificate[] srvCerts =
1215                     checkServerCerts(chc, certificateMessage.certEntries);
1216 
1217             //
1218             // update
1219             //
1220             chc.handshakeCredentials.add(
1221                 new X509Credentials(srvCerts[0].getPublicKey(), srvCerts));
1222             chc.handshakeSession.setPeerCertificates(srvCerts);
1223         }
1224 
1225         private static X509Certificate[] checkClientCerts(
1226                 ServerHandshakeContext shc,
1227                 List&lt;CertificateEntry&gt; certEntries) throws IOException {
1228             X509Certificate[] certs =
1229                     new X509Certificate[certEntries.size()];
1230             try {
1231                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1232                 int i = 0;
1233                 for (CertificateEntry entry : certEntries) {
1234                     certs[i++] = (X509Certificate)cf.generateCertificate(
1235                                     new ByteArrayInputStream(entry.encoded));
1236                 }
1237             } catch (CertificateException ce) {
1238                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1239                     &quot;Failed to parse server certificates&quot;, ce);
1240             }
1241 
1242             // find out the types of client authentication used
1243             String keyAlgorithm = certs[0].getPublicKey().getAlgorithm();
1244             String authType;
1245             switch (keyAlgorithm) {
1246                 case &quot;RSA&quot;:
1247                 case &quot;DSA&quot;:
1248                 case &quot;EC&quot;:
1249                 case &quot;RSASSA-PSS&quot;:
1250                     authType = keyAlgorithm;
1251                     break;
1252                 default:
1253                     // unknown public key type
1254                     authType = &quot;UNKNOWN&quot;;
1255             }
1256 
1257             try {
1258                 X509TrustManager tm = shc.sslContext.getX509TrustManager();
1259                 if (tm instanceof X509ExtendedTrustManager) {
1260                     if (shc.conContext.transport instanceof SSLEngine) {
1261                         SSLEngine engine = (SSLEngine)shc.conContext.transport;
1262                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
1263                             certs.clone(),
1264                             authType,
1265                             engine);
1266                     } else {
1267                         SSLSocket socket = (SSLSocket)shc.conContext.transport;
1268                         ((X509ExtendedTrustManager)tm).checkClientTrusted(
1269                             certs.clone(),
1270                             authType,
1271                             socket);
1272                     }
1273                 } else {
1274                     // Unlikely to happen, because we have wrapped the old
1275                     // X509TrustManager with the new X509ExtendedTrustManager.
1276                     throw new CertificateException(
1277                             &quot;Improper X509TrustManager implementation&quot;);
1278                 }
1279 
1280                 // Once the client certificate chain has been validated, set
1281                 // the certificate chain in the TLS session.
1282                 shc.handshakeSession.setPeerCertificates(certs);
1283             } catch (CertificateException ce) {
1284                 throw shc.conContext.fatal(Alert.CERTIFICATE_UNKNOWN, ce);
1285             }
1286 
1287             return certs;
1288         }
1289 
1290         private static X509Certificate[] checkServerCerts(
1291                 ClientHandshakeContext chc,
1292                 List&lt;CertificateEntry&gt; certEntries) throws IOException {
1293             X509Certificate[] certs =
1294                     new X509Certificate[certEntries.size()];
1295             try {
1296                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1297                 int i = 0;
1298                 for (CertificateEntry entry : certEntries) {
1299                     certs[i++] = (X509Certificate)cf.generateCertificate(
1300                                     new ByteArrayInputStream(entry.encoded));
1301                 }
1302             } catch (CertificateException ce) {
1303                 throw chc.conContext.fatal(Alert.BAD_CERTIFICATE,
1304                     &quot;Failed to parse server certificates&quot;, ce);
1305             }
1306 
1307             // find out the types of server authentication used
1308             //
1309             // Note that the &quot;UNKNOWN&quot; authentication type is sufficient to
1310             // check the required digitalSignature KeyUsage for TLS 1.3.
1311             String authType = &quot;UNKNOWN&quot;;
1312 
1313             try {
1314                 X509TrustManager tm = chc.sslContext.getX509TrustManager();
1315                 if (tm instanceof X509ExtendedTrustManager) {
1316                     if (chc.conContext.transport instanceof SSLEngine) {
1317                         SSLEngine engine = (SSLEngine)chc.conContext.transport;
1318                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
1319                             certs.clone(),
1320                             authType,
1321                             engine);
1322                     } else {
1323                         SSLSocket socket = (SSLSocket)chc.conContext.transport;
1324                         ((X509ExtendedTrustManager)tm).checkServerTrusted(
1325                             certs.clone(),
1326                             authType,
1327                             socket);
1328                     }
1329                 } else {
1330                     // Unlikely to happen, because we have wrapped the old
1331                     // X509TrustManager with the new X509ExtendedTrustManager.
1332                     throw new CertificateException(
1333                             &quot;Improper X509TrustManager implementation&quot;);
1334                 }
1335 
1336                 // Once the server certificate chain has been validated, set
1337                 // the certificate chain in the TLS session.
1338                 chc.handshakeSession.setPeerCertificates(certs);
1339             } catch (CertificateException ce) {
1340                 throw chc.conContext.fatal(getCertificateAlert(chc, ce), ce);
1341             }
1342 
1343             return certs;
1344         }
1345 
1346         /**
1347          * When a failure happens during certificate checking from an
1348          * {@link X509TrustManager}, determine what TLS alert description
1349          * to use.
1350          *
1351          * @param cexc The exception thrown by the {@link X509TrustManager}
1352          *
1353          * @return A byte value corresponding to a TLS alert description number.
1354          */
1355         private static Alert getCertificateAlert(
1356                 ClientHandshakeContext chc, CertificateException cexc) {
1357             // The specific reason for the failure will determine how to
1358             // set the alert description value
1359             Alert alert = Alert.CERTIFICATE_UNKNOWN;
1360 
1361             Throwable baseCause = cexc.getCause();
1362             if (baseCause instanceof CertPathValidatorException) {
1363                 CertPathValidatorException cpve =
1364                         (CertPathValidatorException)baseCause;
1365                 Reason reason = cpve.getReason();
1366                 if (reason == BasicReason.REVOKED) {
1367                     alert = chc.staplingActive ?
1368                             Alert.BAD_CERT_STATUS_RESPONSE :
1369                             Alert.CERTIFICATE_REVOKED;
1370                 } else if (
1371                         reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {
1372                     alert = chc.staplingActive ?
1373                             Alert.BAD_CERT_STATUS_RESPONSE :
1374                             Alert.CERTIFICATE_UNKNOWN;
1375                 }
1376             }
1377 
1378             return alert;
1379         }
1380     }
1381 }
    </pre>
  </body>
</html>
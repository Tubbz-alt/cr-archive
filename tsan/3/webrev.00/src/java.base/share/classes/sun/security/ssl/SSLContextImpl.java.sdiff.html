<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLContextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLContextImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
<span class="line-modified">  28 import java.io.*;</span>
  29 import java.net.Socket;
  30 import java.security.*;
  31 import java.security.cert.*;
  32 import java.util.*;

  33 import javax.net.ssl.*;
  34 import sun.security.action.GetPropertyAction;
  35 import sun.security.provider.certpath.AlgorithmChecker;
  36 import sun.security.validator.Validator;
  37 
  38 /**
  39  * Implementation of an SSLContext.
  40  *
  41  * Implementation note: Instances of this class and the child classes are
  42  * immutable, except that the context initialization (SSLContext.init()) may
  43  * reset the key, trust managers and source of secure random.
  44  */
  45 
  46 public abstract class SSLContextImpl extends SSLContextSpi {
  47 
  48     private final EphemeralKeyManager ephemeralKeyManager;
  49     private final SSLSessionContextImpl clientCache;
  50     private final SSLSessionContextImpl serverCache;
  51 
  52     private boolean isInitialized;
  53 
  54     private X509ExtendedKeyManager keyManager;
  55     private X509TrustManager trustManager;
  56     private SecureRandom secureRandom;
  57 
  58     // DTLS cookie exchange manager
  59     private volatile HelloCookieManager.Builder helloCookieManagerBuilder;
  60 
  61     private final boolean clientEnableStapling = Utilities.getBooleanProperty(
  62             &quot;jdk.tls.client.enableStatusRequestExtension&quot;, true);
  63     private final boolean serverEnableStapling = Utilities.getBooleanProperty(
  64             &quot;jdk.tls.server.enableStatusRequestExtension&quot;, false);
  65     private static final Collection&lt;CipherSuite&gt; clientCustomizedCipherSuites =
  66             getCustomizedCipherSuites(&quot;jdk.tls.client.cipherSuites&quot;);
  67     private static final Collection&lt;CipherSuite&gt; serverCustomizedCipherSuites =
  68             getCustomizedCipherSuites(&quot;jdk.tls.server.cipherSuites&quot;);
  69 
  70     private volatile StatusResponseManager statusResponseManager;
  71 





  72     SSLContextImpl() {
  73         ephemeralKeyManager = new EphemeralKeyManager();
<span class="line-modified">  74         clientCache = new SSLSessionContextImpl();</span>
<span class="line-modified">  75         serverCache = new SSLSessionContextImpl();</span>
  76     }
  77 
  78     @Override
  79     protected void engineInit(KeyManager[] km, TrustManager[] tm,
  80                                 SecureRandom sr) throws KeyManagementException {
  81         isInitialized = false;
  82         keyManager = chooseKeyManager(km);
  83 
  84         if (tm == null) {
  85             try {
  86                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
  87                         TrustManagerFactory.getDefaultAlgorithm());
  88                 tmf.init((KeyStore)null);
  89                 tm = tmf.getTrustManagers();
  90             } catch (Exception e) {
  91                 // eat
  92             }
  93         }
  94         trustManager = chooseTrustManager(tm);
  95 
</pre>
<hr />
<pre>
 213 
 214     SecureRandom getSecureRandom() {
 215         return secureRandom;
 216     }
 217 
 218     X509ExtendedKeyManager getX509KeyManager() {
 219         return keyManager;
 220     }
 221 
 222     X509TrustManager getX509TrustManager() {
 223         return trustManager;
 224     }
 225 
 226     EphemeralKeyManager getEphemeralKeyManager() {
 227         return ephemeralKeyManager;
 228     }
 229 
 230     // Used for DTLS in server mode only.
 231     HelloCookieManager getHelloCookieManager(ProtocolVersion protocolVersion) {
 232         if (helloCookieManagerBuilder == null) {
<span class="line-modified"> 233             synchronized (this) {</span>

 234                 if (helloCookieManagerBuilder == null) {
 235                     helloCookieManagerBuilder =
 236                             new HelloCookieManager.Builder(secureRandom);
 237                 }


 238             }
 239         }
 240 
 241         return helloCookieManagerBuilder.valueOf(protocolVersion);
 242     }
 243 
 244     StatusResponseManager getStatusResponseManager() {
 245         if (serverEnableStapling &amp;&amp; statusResponseManager == null) {
<span class="line-modified"> 246             synchronized (this) {</span>

 247                 if (statusResponseManager == null) {
 248                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 249                         SSLLogger.finest(
 250                                 &quot;Initializing StatusResponseManager&quot;);
 251                     }
 252                     statusResponseManager = new StatusResponseManager();
 253                 }


 254             }
 255         }
 256 
 257         return statusResponseManager;
 258     }
 259 
 260     // Get supported protocols.
 261     abstract List&lt;ProtocolVersion&gt; getSupportedProtocolVersions();
 262 
 263     // Get default protocols for server mode.
 264     abstract List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions();
 265 
 266     // Get default protocols for client mode.
 267     abstract List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions();
 268 
 269     // Get supported CipherSuite list.
 270     abstract List&lt;CipherSuite&gt; getSupportedCipherSuites();
 271 
 272     // Get default CipherSuite list for server mode.
 273     abstract List&lt;CipherSuite&gt; getServerDefaultCipherSuites();
</pre>
<hr />
<pre>
 344                         clientCustomizedCipherSuites, protocols);
 345             }
 346         } else {
 347             if (!serverCustomizedCipherSuites.isEmpty()) {
 348                 return getApplicableCipherSuites(
 349                         serverCustomizedCipherSuites, protocols);
 350             }
 351         }
 352 
 353         return getApplicableCipherSuites(
 354                 CipherSuite.defaultCipherSuites(), protocols);
 355     }
 356 
 357     /*
 358      * Return the list of available CipherSuites which are applicable to
 359      * the specified protocols.
 360      */
 361     private static List&lt;CipherSuite&gt; getApplicableCipherSuites(
 362             Collection&lt;CipherSuite&gt; allowedCipherSuites,
 363             List&lt;ProtocolVersion&gt; protocols) {
<span class="line-modified"> 364         TreeSet&lt;CipherSuite&gt; suites = new TreeSet&lt;&gt;();</span>
 365         if (protocols != null &amp;&amp; (!protocols.isEmpty())) {
 366             for (CipherSuite suite : allowedCipherSuites) {
 367                 if (!suite.isAvailable()) {
 368                     continue;
 369                 }
 370 
 371                 boolean isSupported = false;
 372                 for (ProtocolVersion protocol : protocols) {
<span class="line-modified"> 373                     if (!suite.supports(protocol)) {</span>

 374                         continue;
 375                     }
 376 
 377                     if (SSLAlgorithmConstraints.DEFAULT.permits(
 378                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 379                             suite.name, null)) {
 380                         suites.add(suite);
 381                         isSupported = true;
 382                     } else if (SSLLogger.isOn &amp;&amp;
 383                             SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 384                         SSLLogger.fine(
 385                                 &quot;Ignore disabled cipher suite: &quot; + suite.name);
 386                     }
 387 
 388                     break;
 389                 }
 390 
 391                 if (!isSupported &amp;&amp; SSLLogger.isOn &amp;&amp;
 392                         SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 393                     SSLLogger.finest(
</pre>
<hr />
<pre>
 520         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 521 
 522         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
 523         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 524 
 525         static {
 526             supportedProtocols = Arrays.asList(
 527                 ProtocolVersion.TLS13,
 528                 ProtocolVersion.TLS12,
 529                 ProtocolVersion.TLS11,
 530                 ProtocolVersion.TLS10,
 531                 ProtocolVersion.SSL30,
 532                 ProtocolVersion.SSL20Hello
 533             );
 534 
 535             serverDefaultProtocols = getAvailableProtocols(
 536                     new ProtocolVersion[] {
 537                 ProtocolVersion.TLS13,
 538                 ProtocolVersion.TLS12,
 539                 ProtocolVersion.TLS11,
<span class="line-modified"> 540                 ProtocolVersion.TLS10,</span>
<span class="line-removed"> 541                 ProtocolVersion.SSL30,</span>
<span class="line-removed"> 542                 ProtocolVersion.SSL20Hello</span>
 543             });
 544 
 545             supportedCipherSuites = getApplicableSupportedCipherSuites(
 546                     supportedProtocols);
 547             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
 548                     serverDefaultProtocols, false);
 549         }
 550 
 551         @Override
 552         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
 553             return supportedProtocols;
 554         }
 555 
 556         @Override
 557         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
 558             return supportedCipherSuites;
 559         }
 560 
 561         @Override
 562         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
</pre>
<hr />
<pre>
 565 
 566         @Override
 567         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 568             return serverDefaultCipherSuites;
 569         }
 570 
 571         @Override
 572         SSLEngine createSSLEngineImpl() {
 573             return new SSLEngineImpl(this);
 574         }
 575 
 576         @Override
 577         SSLEngine createSSLEngineImpl(String host, int port) {
 578             return new SSLEngineImpl(this, host, port);
 579         }
 580 
 581         @Override
 582         boolean isDTLS() {
 583             return false;
 584         }
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586         static ProtocolVersion[] getSupportedProtocols() {</span>
<span class="line-removed"> 587             return new ProtocolVersion[]{</span>
<span class="line-removed"> 588                     ProtocolVersion.TLS13,</span>
<span class="line-removed"> 589                     ProtocolVersion.TLS12,</span>
<span class="line-removed"> 590                     ProtocolVersion.TLS11,</span>
<span class="line-removed"> 591                     ProtocolVersion.TLS10,</span>
<span class="line-removed"> 592                     ProtocolVersion.SSL30,</span>
<span class="line-removed"> 593                     ProtocolVersion.SSL20Hello</span>
<span class="line-removed"> 594             };</span>
<span class="line-removed"> 595         }</span>
 596     }
 597 
 598     /*
 599      * The SSLContext implementation for SSLv3 and TLS10 algorithm
 600      *
 601      * @see SSLContext
 602      */
 603     public static final class TLS10Context extends AbstractTLSContext {
 604         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 605         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 606 
 607         static {
 608             clientDefaultProtocols = getAvailableProtocols(
 609                     new ProtocolVersion[] {
<span class="line-modified"> 610                 ProtocolVersion.TLS10,</span>
<span class="line-removed"> 611                 ProtocolVersion.SSL30</span>
 612             });
 613 
 614             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 615                     clientDefaultProtocols, true);
 616         }
 617 
 618         @Override
 619         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 620             return clientDefaultProtocols;
 621         }
 622 
 623         @Override
 624         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 625             return clientDefaultCipherSuites;
 626         }
 627     }
 628 
 629     /*
 630      * The SSLContext implementation for TLS11 algorithm
 631      *
 632      * @see SSLContext
 633      */
 634     public static final class TLS11Context extends AbstractTLSContext {
 635         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 636         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 637 
 638         static {
 639             clientDefaultProtocols = getAvailableProtocols(
 640                     new ProtocolVersion[] {
 641                 ProtocolVersion.TLS11,
<span class="line-modified"> 642                 ProtocolVersion.TLS10,</span>
<span class="line-removed"> 643                 ProtocolVersion.SSL30</span>
 644             });
 645 
 646             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 647                     clientDefaultProtocols, true);
 648 
 649         }
 650 
 651         @Override
 652         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 653             return clientDefaultProtocols;
 654         }
 655 
 656         @Override
 657         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 658             return clientDefaultCipherSuites;
 659         }
 660     }
 661 
 662     /*
 663      * The SSLContext implementation for TLS12 algorithm
 664      *
 665      * @see SSLContext
 666      */
 667     public static final class TLS12Context extends AbstractTLSContext {
 668         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 669         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 670 
 671         static {
 672             clientDefaultProtocols = getAvailableProtocols(
 673                     new ProtocolVersion[] {
 674                 ProtocolVersion.TLS12,
 675                 ProtocolVersion.TLS11,
<span class="line-modified"> 676                 ProtocolVersion.TLS10,</span>
<span class="line-removed"> 677                 ProtocolVersion.SSL30</span>
 678             });
 679 
 680             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 681                     clientDefaultProtocols, true);
 682         }
 683 
 684         @Override
 685         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 686             return clientDefaultProtocols;
 687         }
 688 
 689         @Override
 690         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 691             return clientDefaultCipherSuites;
 692         }
 693     }
 694 
 695     /*
 696      * The SSLContext implementation for TLS1.3 algorithm
 697      *
 698      * @see SSLContext
 699      */
 700     public static final class TLS13Context extends AbstractTLSContext {
 701         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 702         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 703 
 704         static {
 705             clientDefaultProtocols = getAvailableProtocols(
 706                     new ProtocolVersion[] {
 707                 ProtocolVersion.TLS13,
 708                 ProtocolVersion.TLS12,
 709                 ProtocolVersion.TLS11,
<span class="line-modified"> 710                 ProtocolVersion.TLS10,</span>
<span class="line-removed"> 711                 ProtocolVersion.SSL30</span>
 712             });
 713 
 714             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 715                     clientDefaultProtocols, true);
 716         }
 717 
 718         @Override
 719         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 720             return clientDefaultProtocols;
 721         }
 722 
 723         @Override
 724         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 725             return clientDefaultCipherSuites;
 726         }
 727     }
 728 
 729     /*
 730      * The interface for the customized SSL/(D)TLS SSLContext.
 731      *
</pre>
<hr />
<pre>
 828                 // unlikely to be used
 829                 clientDefaultProtocols = null;
 830                 serverDefaultProtocols = null;
 831                 clientDefaultCipherSuites = null;
 832                 serverDefaultCipherSuites = null;
 833             }
 834         }
 835 
 836         private static List&lt;ProtocolVersion&gt; customizedProtocols(
 837                 boolean client, List&lt;ProtocolVersion&gt; customized) {
 838             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
 839             for (ProtocolVersion pv : customized) {
 840                 if (!pv.isDTLS) {
 841                     refactored.add(pv);
 842                 }
 843             }
 844 
 845             // Use the default enabled protocols if no customization
 846             ProtocolVersion[] candidates;
 847             if (refactored.isEmpty()) {
<span class="line-modified"> 848                 if (client) {</span>
<span class="line-modified"> 849                     candidates = getProtocols();</span>
<span class="line-modified"> 850                 } else {</span>
<span class="line-modified"> 851                     candidates = getSupportedProtocols();</span>
<span class="line-modified"> 852                 }</span>


 853             } else {
 854                 // Use the customized TLS protocols.
 855                 candidates =
 856                     refactored.toArray(new ProtocolVersion[refactored.size()]);
 857             }
 858 
 859             return getAvailableProtocols(candidates);
 860         }
 861 
<span class="line-removed"> 862         static ProtocolVersion[] getProtocols() {</span>
<span class="line-removed"> 863             return new ProtocolVersion[]{</span>
<span class="line-removed"> 864                     ProtocolVersion.TLS13,</span>
<span class="line-removed"> 865                     ProtocolVersion.TLS12,</span>
<span class="line-removed"> 866                     ProtocolVersion.TLS11,</span>
<span class="line-removed"> 867                     ProtocolVersion.TLS10,</span>
<span class="line-removed"> 868                     ProtocolVersion.SSL30</span>
<span class="line-removed"> 869             };</span>
<span class="line-removed"> 870         }</span>
<span class="line-removed"> 871 </span>
 872         protected CustomizedTLSContext() {
 873             if (reservedException != null) {
 874                 throw reservedException;
 875             }
 876         }
 877 
 878         @Override
 879         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 880             return clientDefaultProtocols;
 881         }
 882 
 883         @Override
 884         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 885             return serverDefaultProtocols;
 886         }
 887 
 888         @Override
 889         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 890             return clientDefaultCipherSuites;
 891         }
 892 
 893         @Override
 894         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 895             return serverDefaultCipherSuites;
 896         }
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898 </span>
 899     }
 900 
 901     /*
 902      * The SSLContext implementation for default &quot;TLS&quot; algorithm
 903      *
 904      * @see SSLContext
 905      */
 906     public static final class TLSContext extends CustomizedTLSContext {
 907         // use the default constructor and methods
 908     }
 909 
 910     // lazy initialization holder class idiom for static default parameters
 911     //
 912     // See Effective Java Second Edition: Item 71.
 913     private static final class DefaultManagersHolder {
 914         private static final String NONE = &quot;NONE&quot;;
 915         private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 916 
 917         private static final TrustManager[] trustManagers;
 918         private static final KeyManager[] keyManagers;
</pre>
<hr />
<pre>
1154         }
1155     }
1156 
1157     /*
1158      * The base abstract SSLContext implementation for the Datagram Transport
1159      * Layer Security (DTLS) protocols.
1160      *
1161      * This abstract class encapsulates supported and the default server DTLS
1162      * parameters.
1163      *
1164      * @see SSLContext
1165      */
1166     private abstract static class AbstractDTLSContext extends SSLContextImpl {
1167         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
1168         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1169 
1170         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
1171         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1172 
1173         static {
<span class="line-removed">1174             // Both DTLSv1.0 and DTLSv1.2 can be used in FIPS mode.</span>
1175             supportedProtocols = Arrays.asList(
1176                 ProtocolVersion.DTLS12,
1177                 ProtocolVersion.DTLS10
1178             );
1179 
1180             // available protocols for server mode
1181             serverDefaultProtocols = getAvailableProtocols(
1182                     new ProtocolVersion[] {
1183                 ProtocolVersion.DTLS12,
1184                 ProtocolVersion.DTLS10
1185             });
1186 
1187             supportedCipherSuites = getApplicableSupportedCipherSuites(
1188                     supportedProtocols);
1189             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
1190                     serverDefaultProtocols, false);
1191         }
1192 
1193         @Override
1194         protected SSLParameters engineGetDefaultSSLParameters() {
</pre>
<hr />
<pre>
1451     public void checkServerTrusted(X509Certificate[] chain, String authType,
1452             Socket socket) throws CertificateException {
1453         tm.checkServerTrusted(chain, authType);
1454         checkAdditionalTrust(chain, authType, socket, false);
1455     }
1456 
1457     @Override
1458     public void checkClientTrusted(X509Certificate[] chain, String authType,
1459             SSLEngine engine) throws CertificateException {
1460         tm.checkClientTrusted(chain, authType);
1461         checkAdditionalTrust(chain, authType, engine, true);
1462     }
1463 
1464     @Override
1465     public void checkServerTrusted(X509Certificate[] chain, String authType,
1466             SSLEngine engine) throws CertificateException {
1467         tm.checkServerTrusted(chain, authType);
1468         checkAdditionalTrust(chain, authType, engine, false);
1469     }
1470 
<span class="line-modified">1471     private void checkAdditionalTrust(X509Certificate[] chain, String authType,</span>
<span class="line-modified">1472                 Socket socket, boolean isClient) throws CertificateException {</span>

1473         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
1474                                     socket instanceof SSLSocket) {
1475 
1476             SSLSocket sslSocket = (SSLSocket)socket;
1477             SSLSession session = sslSocket.getHandshakeSession();
1478             if (session == null) {
1479                 throw new CertificateException(&quot;No handshake session&quot;);
1480             }
1481 
1482             // check endpoint identity
1483             String identityAlg = sslSocket.getSSLParameters().
1484                                         getEndpointIdentificationAlgorithm();
1485             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">1486                 String hostname = session.getPeerHost();</span>
<span class="line-modified">1487                 X509TrustManagerImpl.checkIdentity(</span>
<span class="line-removed">1488                                     hostname, chain[0], identityAlg);</span>
1489             }
1490 
1491             // try the best to check the algorithm constraints
1492             AlgorithmConstraints constraints;
1493             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1494                 if (session instanceof ExtendedSSLSession) {
1495                     ExtendedSSLSession extSession =
1496                                     (ExtendedSSLSession)session;
1497                     String[] peerSupportedSignAlgs =
1498                             extSession.getLocalSupportedSignatureAlgorithms();
1499 
1500                     constraints = new SSLAlgorithmConstraints(
1501                                     sslSocket, peerSupportedSignAlgs, true);
1502                 } else {
1503                     constraints =
1504                             new SSLAlgorithmConstraints(sslSocket, true);
1505                 }
1506             } else {
1507                 constraints = new SSLAlgorithmConstraints(sslSocket, true);
1508             }
1509 
<span class="line-modified">1510             checkAlgorithmConstraints(chain, constraints, isClient);</span>
1511         }
1512     }
1513 
<span class="line-modified">1514     private void checkAdditionalTrust(X509Certificate[] chain, String authType,</span>
<span class="line-modified">1515             SSLEngine engine, boolean isClient) throws CertificateException {</span>

1516         if (engine != null) {
1517             SSLSession session = engine.getHandshakeSession();
1518             if (session == null) {
1519                 throw new CertificateException(&quot;No handshake session&quot;);
1520             }
1521 
1522             // check endpoint identity
1523             String identityAlg = engine.getSSLParameters().
1524                                         getEndpointIdentificationAlgorithm();
1525             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">1526                 String hostname = session.getPeerHost();</span>
<span class="line-modified">1527                 X509TrustManagerImpl.checkIdentity(</span>
<span class="line-removed">1528                                     hostname, chain[0], identityAlg);</span>
1529             }
1530 
1531             // try the best to check the algorithm constraints
1532             AlgorithmConstraints constraints;
1533             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1534                 if (session instanceof ExtendedSSLSession) {
1535                     ExtendedSSLSession extSession =
1536                                     (ExtendedSSLSession)session;
1537                     String[] peerSupportedSignAlgs =
1538                             extSession.getLocalSupportedSignatureAlgorithms();
1539 
1540                     constraints = new SSLAlgorithmConstraints(
1541                                     engine, peerSupportedSignAlgs, true);
1542                 } else {
1543                     constraints =
1544                             new SSLAlgorithmConstraints(engine, true);
1545                 }
1546             } else {
1547                 constraints = new SSLAlgorithmConstraints(engine, true);
1548             }
1549 
<span class="line-modified">1550             checkAlgorithmConstraints(chain, constraints, isClient);</span>
1551         }
1552     }
1553 
1554     private void checkAlgorithmConstraints(X509Certificate[] chain,
1555             AlgorithmConstraints constraints,
<span class="line-modified">1556             boolean isClient) throws CertificateException {</span>
1557         try {
1558             // Does the certificate chain end with a trusted certificate?
1559             int checkedLength = chain.length - 1;
1560 
1561             Collection&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
1562             X509Certificate[] certs = tm.getAcceptedIssuers();
1563             if ((certs != null) &amp;&amp; (certs.length &gt; 0)){
1564                 Collections.addAll(trustedCerts, certs);
1565             }
1566 
1567             if (trustedCerts.contains(chain[checkedLength])) {
1568                     checkedLength--;
1569             }
1570 
1571             // A forward checker, need to check from trust to target
1572             if (checkedLength &gt;= 0) {
1573                 AlgorithmChecker checker =
1574                     new AlgorithmChecker(constraints, null,
<span class="line-modified">1575                             (isClient ? Validator.VAR_TLS_CLIENT :</span>
1576                                         Validator.VAR_TLS_SERVER));
1577                 checker.init(false);
1578                 for (int i = checkedLength; i &gt;= 0; i--) {
1579                     X509Certificate cert = chain[i];
1580                     // We don&#39;t care about the unresolved critical extensions.
1581                     checker.check(cert, Collections.&lt;String&gt;emptySet());
1582                 }
1583             }
1584         } catch (CertPathValidatorException cpve) {
1585             throw new CertificateException(
1586                 &quot;Certificates do not conform to algorithm constraints&quot;, cpve);
1587         }
1588     }
1589 }
1590 
1591 // Dummy X509TrustManager implementation, rejects all peer certificates.
1592 // Used if the application did not specify a proper X509TrustManager.
1593 final class DummyX509TrustManager extends X509ExtendedTrustManager
1594             implements X509TrustManager {
1595 
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
<span class="line-modified">  28 import java.io.FileInputStream;</span>
  29 import java.net.Socket;
  30 import java.security.*;
  31 import java.security.cert.*;
  32 import java.util.*;
<span class="line-added">  33 import java.util.concurrent.locks.ReentrantLock;</span>
  34 import javax.net.ssl.*;
  35 import sun.security.action.GetPropertyAction;
  36 import sun.security.provider.certpath.AlgorithmChecker;
  37 import sun.security.validator.Validator;
  38 
  39 /**
  40  * Implementation of an SSLContext.
  41  *
  42  * Implementation note: Instances of this class and the child classes are
  43  * immutable, except that the context initialization (SSLContext.init()) may
  44  * reset the key, trust managers and source of secure random.
  45  */
  46 
  47 public abstract class SSLContextImpl extends SSLContextSpi {
  48 
  49     private final EphemeralKeyManager ephemeralKeyManager;
  50     private final SSLSessionContextImpl clientCache;
  51     private final SSLSessionContextImpl serverCache;
  52 
  53     private boolean isInitialized;
  54 
  55     private X509ExtendedKeyManager keyManager;
  56     private X509TrustManager trustManager;
  57     private SecureRandom secureRandom;
  58 
  59     // DTLS cookie exchange manager
  60     private volatile HelloCookieManager.Builder helloCookieManagerBuilder;
  61 
  62     private final boolean clientEnableStapling = Utilities.getBooleanProperty(
  63             &quot;jdk.tls.client.enableStatusRequestExtension&quot;, true);
  64     private final boolean serverEnableStapling = Utilities.getBooleanProperty(
  65             &quot;jdk.tls.server.enableStatusRequestExtension&quot;, false);
  66     private static final Collection&lt;CipherSuite&gt; clientCustomizedCipherSuites =
  67             getCustomizedCipherSuites(&quot;jdk.tls.client.cipherSuites&quot;);
  68     private static final Collection&lt;CipherSuite&gt; serverCustomizedCipherSuites =
  69             getCustomizedCipherSuites(&quot;jdk.tls.server.cipherSuites&quot;);
  70 
  71     private volatile StatusResponseManager statusResponseManager;
  72 
<span class="line-added">  73     private final ReentrantLock contextLock = new ReentrantLock();</span>
<span class="line-added">  74     final HashMap&lt;Integer,</span>
<span class="line-added">  75             SessionTicketExtension.StatelessKey&gt; keyHashMap = new HashMap&lt;&gt;();</span>
<span class="line-added">  76 </span>
<span class="line-added">  77 </span>
  78     SSLContextImpl() {
  79         ephemeralKeyManager = new EphemeralKeyManager();
<span class="line-modified">  80         clientCache = new SSLSessionContextImpl(false);</span>
<span class="line-modified">  81         serverCache = new SSLSessionContextImpl(true);</span>
  82     }
  83 
  84     @Override
  85     protected void engineInit(KeyManager[] km, TrustManager[] tm,
  86                                 SecureRandom sr) throws KeyManagementException {
  87         isInitialized = false;
  88         keyManager = chooseKeyManager(km);
  89 
  90         if (tm == null) {
  91             try {
  92                 TrustManagerFactory tmf = TrustManagerFactory.getInstance(
  93                         TrustManagerFactory.getDefaultAlgorithm());
  94                 tmf.init((KeyStore)null);
  95                 tm = tmf.getTrustManagers();
  96             } catch (Exception e) {
  97                 // eat
  98             }
  99         }
 100         trustManager = chooseTrustManager(tm);
 101 
</pre>
<hr />
<pre>
 219 
 220     SecureRandom getSecureRandom() {
 221         return secureRandom;
 222     }
 223 
 224     X509ExtendedKeyManager getX509KeyManager() {
 225         return keyManager;
 226     }
 227 
 228     X509TrustManager getX509TrustManager() {
 229         return trustManager;
 230     }
 231 
 232     EphemeralKeyManager getEphemeralKeyManager() {
 233         return ephemeralKeyManager;
 234     }
 235 
 236     // Used for DTLS in server mode only.
 237     HelloCookieManager getHelloCookieManager(ProtocolVersion protocolVersion) {
 238         if (helloCookieManagerBuilder == null) {
<span class="line-modified"> 239             contextLock.lock();</span>
<span class="line-added"> 240             try {</span>
 241                 if (helloCookieManagerBuilder == null) {
 242                     helloCookieManagerBuilder =
 243                             new HelloCookieManager.Builder(secureRandom);
 244                 }
<span class="line-added"> 245             } finally {</span>
<span class="line-added"> 246                 contextLock.unlock();</span>
 247             }
 248         }
 249 
 250         return helloCookieManagerBuilder.valueOf(protocolVersion);
 251     }
 252 
 253     StatusResponseManager getStatusResponseManager() {
 254         if (serverEnableStapling &amp;&amp; statusResponseManager == null) {
<span class="line-modified"> 255             contextLock.lock();</span>
<span class="line-added"> 256             try {</span>
 257                 if (statusResponseManager == null) {
 258                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,sslctx&quot;)) {
 259                         SSLLogger.finest(
 260                                 &quot;Initializing StatusResponseManager&quot;);
 261                     }
 262                     statusResponseManager = new StatusResponseManager();
 263                 }
<span class="line-added"> 264             } finally {</span>
<span class="line-added"> 265                 contextLock.unlock();</span>
 266             }
 267         }
 268 
 269         return statusResponseManager;
 270     }
 271 
 272     // Get supported protocols.
 273     abstract List&lt;ProtocolVersion&gt; getSupportedProtocolVersions();
 274 
 275     // Get default protocols for server mode.
 276     abstract List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions();
 277 
 278     // Get default protocols for client mode.
 279     abstract List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions();
 280 
 281     // Get supported CipherSuite list.
 282     abstract List&lt;CipherSuite&gt; getSupportedCipherSuites();
 283 
 284     // Get default CipherSuite list for server mode.
 285     abstract List&lt;CipherSuite&gt; getServerDefaultCipherSuites();
</pre>
<hr />
<pre>
 356                         clientCustomizedCipherSuites, protocols);
 357             }
 358         } else {
 359             if (!serverCustomizedCipherSuites.isEmpty()) {
 360                 return getApplicableCipherSuites(
 361                         serverCustomizedCipherSuites, protocols);
 362             }
 363         }
 364 
 365         return getApplicableCipherSuites(
 366                 CipherSuite.defaultCipherSuites(), protocols);
 367     }
 368 
 369     /*
 370      * Return the list of available CipherSuites which are applicable to
 371      * the specified protocols.
 372      */
 373     private static List&lt;CipherSuite&gt; getApplicableCipherSuites(
 374             Collection&lt;CipherSuite&gt; allowedCipherSuites,
 375             List&lt;ProtocolVersion&gt; protocols) {
<span class="line-modified"> 376         LinkedHashSet&lt;CipherSuite&gt; suites = new LinkedHashSet&lt;&gt;();</span>
 377         if (protocols != null &amp;&amp; (!protocols.isEmpty())) {
 378             for (CipherSuite suite : allowedCipherSuites) {
 379                 if (!suite.isAvailable()) {
 380                     continue;
 381                 }
 382 
 383                 boolean isSupported = false;
 384                 for (ProtocolVersion protocol : protocols) {
<span class="line-modified"> 385                     if (!suite.supports(protocol) ||</span>
<span class="line-added"> 386                             !suite.bulkCipher.isAvailable()) {</span>
 387                         continue;
 388                     }
 389 
 390                     if (SSLAlgorithmConstraints.DEFAULT.permits(
 391                             EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 392                             suite.name, null)) {
 393                         suites.add(suite);
 394                         isSupported = true;
 395                     } else if (SSLLogger.isOn &amp;&amp;
 396                             SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 397                         SSLLogger.fine(
 398                                 &quot;Ignore disabled cipher suite: &quot; + suite.name);
 399                     }
 400 
 401                     break;
 402                 }
 403 
 404                 if (!isSupported &amp;&amp; SSLLogger.isOn &amp;&amp;
 405                         SSLLogger.isOn(&quot;ssl,sslctx,verbose&quot;)) {
 406                     SSLLogger.finest(
</pre>
<hr />
<pre>
 533         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
 534 
 535         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
 536         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
 537 
 538         static {
 539             supportedProtocols = Arrays.asList(
 540                 ProtocolVersion.TLS13,
 541                 ProtocolVersion.TLS12,
 542                 ProtocolVersion.TLS11,
 543                 ProtocolVersion.TLS10,
 544                 ProtocolVersion.SSL30,
 545                 ProtocolVersion.SSL20Hello
 546             );
 547 
 548             serverDefaultProtocols = getAvailableProtocols(
 549                     new ProtocolVersion[] {
 550                 ProtocolVersion.TLS13,
 551                 ProtocolVersion.TLS12,
 552                 ProtocolVersion.TLS11,
<span class="line-modified"> 553                 ProtocolVersion.TLS10</span>


 554             });
 555 
 556             supportedCipherSuites = getApplicableSupportedCipherSuites(
 557                     supportedProtocols);
 558             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
 559                     serverDefaultProtocols, false);
 560         }
 561 
 562         @Override
 563         List&lt;ProtocolVersion&gt; getSupportedProtocolVersions() {
 564             return supportedProtocols;
 565         }
 566 
 567         @Override
 568         List&lt;CipherSuite&gt; getSupportedCipherSuites() {
 569             return supportedCipherSuites;
 570         }
 571 
 572         @Override
 573         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
</pre>
<hr />
<pre>
 576 
 577         @Override
 578         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 579             return serverDefaultCipherSuites;
 580         }
 581 
 582         @Override
 583         SSLEngine createSSLEngineImpl() {
 584             return new SSLEngineImpl(this);
 585         }
 586 
 587         @Override
 588         SSLEngine createSSLEngineImpl(String host, int port) {
 589             return new SSLEngineImpl(this, host, port);
 590         }
 591 
 592         @Override
 593         boolean isDTLS() {
 594             return false;
 595         }











 596     }
 597 
 598     /*
 599      * The SSLContext implementation for SSLv3 and TLS10 algorithm
 600      *
 601      * @see SSLContext
 602      */
 603     public static final class TLS10Context extends AbstractTLSContext {
 604         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 605         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 606 
 607         static {
 608             clientDefaultProtocols = getAvailableProtocols(
 609                     new ProtocolVersion[] {
<span class="line-modified"> 610                 ProtocolVersion.TLS10</span>

 611             });
 612 
 613             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 614                     clientDefaultProtocols, true);
 615         }
 616 
 617         @Override
 618         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 619             return clientDefaultProtocols;
 620         }
 621 
 622         @Override
 623         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 624             return clientDefaultCipherSuites;
 625         }
 626     }
 627 
 628     /*
 629      * The SSLContext implementation for TLS11 algorithm
 630      *
 631      * @see SSLContext
 632      */
 633     public static final class TLS11Context extends AbstractTLSContext {
 634         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 635         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 636 
 637         static {
 638             clientDefaultProtocols = getAvailableProtocols(
 639                     new ProtocolVersion[] {
 640                 ProtocolVersion.TLS11,
<span class="line-modified"> 641                 ProtocolVersion.TLS10</span>

 642             });
 643 
 644             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 645                     clientDefaultProtocols, true);
 646 
 647         }
 648 
 649         @Override
 650         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 651             return clientDefaultProtocols;
 652         }
 653 
 654         @Override
 655         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 656             return clientDefaultCipherSuites;
 657         }
 658     }
 659 
 660     /*
 661      * The SSLContext implementation for TLS12 algorithm
 662      *
 663      * @see SSLContext
 664      */
 665     public static final class TLS12Context extends AbstractTLSContext {
 666         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 667         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 668 
 669         static {
 670             clientDefaultProtocols = getAvailableProtocols(
 671                     new ProtocolVersion[] {
 672                 ProtocolVersion.TLS12,
 673                 ProtocolVersion.TLS11,
<span class="line-modified"> 674                 ProtocolVersion.TLS10</span>

 675             });
 676 
 677             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 678                     clientDefaultProtocols, true);
 679         }
 680 
 681         @Override
 682         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 683             return clientDefaultProtocols;
 684         }
 685 
 686         @Override
 687         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 688             return clientDefaultCipherSuites;
 689         }
 690     }
 691 
 692     /*
 693      * The SSLContext implementation for TLS1.3 algorithm
 694      *
 695      * @see SSLContext
 696      */
 697     public static final class TLS13Context extends AbstractTLSContext {
 698         private static final List&lt;ProtocolVersion&gt; clientDefaultProtocols;
 699         private static final List&lt;CipherSuite&gt; clientDefaultCipherSuites;
 700 
 701         static {
 702             clientDefaultProtocols = getAvailableProtocols(
 703                     new ProtocolVersion[] {
 704                 ProtocolVersion.TLS13,
 705                 ProtocolVersion.TLS12,
 706                 ProtocolVersion.TLS11,
<span class="line-modified"> 707                 ProtocolVersion.TLS10</span>

 708             });
 709 
 710             clientDefaultCipherSuites = getApplicableEnabledCipherSuites(
 711                     clientDefaultProtocols, true);
 712         }
 713 
 714         @Override
 715         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 716             return clientDefaultProtocols;
 717         }
 718 
 719         @Override
 720         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 721             return clientDefaultCipherSuites;
 722         }
 723     }
 724 
 725     /*
 726      * The interface for the customized SSL/(D)TLS SSLContext.
 727      *
</pre>
<hr />
<pre>
 824                 // unlikely to be used
 825                 clientDefaultProtocols = null;
 826                 serverDefaultProtocols = null;
 827                 clientDefaultCipherSuites = null;
 828                 serverDefaultCipherSuites = null;
 829             }
 830         }
 831 
 832         private static List&lt;ProtocolVersion&gt; customizedProtocols(
 833                 boolean client, List&lt;ProtocolVersion&gt; customized) {
 834             List&lt;ProtocolVersion&gt; refactored = new ArrayList&lt;&gt;();
 835             for (ProtocolVersion pv : customized) {
 836                 if (!pv.isDTLS) {
 837                     refactored.add(pv);
 838                 }
 839             }
 840 
 841             // Use the default enabled protocols if no customization
 842             ProtocolVersion[] candidates;
 843             if (refactored.isEmpty()) {
<span class="line-modified"> 844                 // Client and server use the same default protocols.</span>
<span class="line-modified"> 845                 candidates = new ProtocolVersion[] {</span>
<span class="line-modified"> 846                         ProtocolVersion.TLS13,</span>
<span class="line-modified"> 847                         ProtocolVersion.TLS12,</span>
<span class="line-modified"> 848                         ProtocolVersion.TLS11,</span>
<span class="line-added"> 849                         ProtocolVersion.TLS10</span>
<span class="line-added"> 850                     };</span>
 851             } else {
 852                 // Use the customized TLS protocols.
 853                 candidates =
 854                     refactored.toArray(new ProtocolVersion[refactored.size()]);
 855             }
 856 
 857             return getAvailableProtocols(candidates);
 858         }
 859 










 860         protected CustomizedTLSContext() {
 861             if (reservedException != null) {
 862                 throw reservedException;
 863             }
 864         }
 865 
 866         @Override
 867         List&lt;ProtocolVersion&gt; getClientDefaultProtocolVersions() {
 868             return clientDefaultProtocols;
 869         }
 870 
 871         @Override
 872         List&lt;ProtocolVersion&gt; getServerDefaultProtocolVersions() {
 873             return serverDefaultProtocols;
 874         }
 875 
 876         @Override
 877         List&lt;CipherSuite&gt; getClientDefaultCipherSuites() {
 878             return clientDefaultCipherSuites;
 879         }
 880 
 881         @Override
 882         List&lt;CipherSuite&gt; getServerDefaultCipherSuites() {
 883             return serverDefaultCipherSuites;
 884         }


 885     }
 886 
 887     /*
 888      * The SSLContext implementation for default &quot;TLS&quot; algorithm
 889      *
 890      * @see SSLContext
 891      */
 892     public static final class TLSContext extends CustomizedTLSContext {
 893         // use the default constructor and methods
 894     }
 895 
 896     // lazy initialization holder class idiom for static default parameters
 897     //
 898     // See Effective Java Second Edition: Item 71.
 899     private static final class DefaultManagersHolder {
 900         private static final String NONE = &quot;NONE&quot;;
 901         private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 902 
 903         private static final TrustManager[] trustManagers;
 904         private static final KeyManager[] keyManagers;
</pre>
<hr />
<pre>
1140         }
1141     }
1142 
1143     /*
1144      * The base abstract SSLContext implementation for the Datagram Transport
1145      * Layer Security (DTLS) protocols.
1146      *
1147      * This abstract class encapsulates supported and the default server DTLS
1148      * parameters.
1149      *
1150      * @see SSLContext
1151      */
1152     private abstract static class AbstractDTLSContext extends SSLContextImpl {
1153         private static final List&lt;ProtocolVersion&gt; supportedProtocols;
1154         private static final List&lt;ProtocolVersion&gt; serverDefaultProtocols;
1155 
1156         private static final List&lt;CipherSuite&gt; supportedCipherSuites;
1157         private static final List&lt;CipherSuite&gt; serverDefaultCipherSuites;
1158 
1159         static {

1160             supportedProtocols = Arrays.asList(
1161                 ProtocolVersion.DTLS12,
1162                 ProtocolVersion.DTLS10
1163             );
1164 
1165             // available protocols for server mode
1166             serverDefaultProtocols = getAvailableProtocols(
1167                     new ProtocolVersion[] {
1168                 ProtocolVersion.DTLS12,
1169                 ProtocolVersion.DTLS10
1170             });
1171 
1172             supportedCipherSuites = getApplicableSupportedCipherSuites(
1173                     supportedProtocols);
1174             serverDefaultCipherSuites = getApplicableEnabledCipherSuites(
1175                     serverDefaultProtocols, false);
1176         }
1177 
1178         @Override
1179         protected SSLParameters engineGetDefaultSSLParameters() {
</pre>
<hr />
<pre>
1436     public void checkServerTrusted(X509Certificate[] chain, String authType,
1437             Socket socket) throws CertificateException {
1438         tm.checkServerTrusted(chain, authType);
1439         checkAdditionalTrust(chain, authType, socket, false);
1440     }
1441 
1442     @Override
1443     public void checkClientTrusted(X509Certificate[] chain, String authType,
1444             SSLEngine engine) throws CertificateException {
1445         tm.checkClientTrusted(chain, authType);
1446         checkAdditionalTrust(chain, authType, engine, true);
1447     }
1448 
1449     @Override
1450     public void checkServerTrusted(X509Certificate[] chain, String authType,
1451             SSLEngine engine) throws CertificateException {
1452         tm.checkServerTrusted(chain, authType);
1453         checkAdditionalTrust(chain, authType, engine, false);
1454     }
1455 
<span class="line-modified">1456     private void checkAdditionalTrust(X509Certificate[] chain,</span>
<span class="line-modified">1457             String authType, Socket socket,</span>
<span class="line-added">1458             boolean checkClientTrusted) throws CertificateException {</span>
1459         if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;
1460                                     socket instanceof SSLSocket) {
1461 
1462             SSLSocket sslSocket = (SSLSocket)socket;
1463             SSLSession session = sslSocket.getHandshakeSession();
1464             if (session == null) {
1465                 throw new CertificateException(&quot;No handshake session&quot;);
1466             }
1467 
1468             // check endpoint identity
1469             String identityAlg = sslSocket.getSSLParameters().
1470                                         getEndpointIdentificationAlgorithm();
1471             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">1472                 X509TrustManagerImpl.checkIdentity(session, chain,</span>
<span class="line-modified">1473                                     identityAlg, checkClientTrusted);</span>

1474             }
1475 
1476             // try the best to check the algorithm constraints
1477             AlgorithmConstraints constraints;
1478             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1479                 if (session instanceof ExtendedSSLSession) {
1480                     ExtendedSSLSession extSession =
1481                                     (ExtendedSSLSession)session;
1482                     String[] peerSupportedSignAlgs =
1483                             extSession.getLocalSupportedSignatureAlgorithms();
1484 
1485                     constraints = new SSLAlgorithmConstraints(
1486                                     sslSocket, peerSupportedSignAlgs, true);
1487                 } else {
1488                     constraints =
1489                             new SSLAlgorithmConstraints(sslSocket, true);
1490                 }
1491             } else {
1492                 constraints = new SSLAlgorithmConstraints(sslSocket, true);
1493             }
1494 
<span class="line-modified">1495             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);</span>
1496         }
1497     }
1498 
<span class="line-modified">1499     private void checkAdditionalTrust(X509Certificate[] chain,</span>
<span class="line-modified">1500             String authType, SSLEngine engine,</span>
<span class="line-added">1501             boolean checkClientTrusted) throws CertificateException {</span>
1502         if (engine != null) {
1503             SSLSession session = engine.getHandshakeSession();
1504             if (session == null) {
1505                 throw new CertificateException(&quot;No handshake session&quot;);
1506             }
1507 
1508             // check endpoint identity
1509             String identityAlg = engine.getSSLParameters().
1510                                         getEndpointIdentificationAlgorithm();
1511             if (identityAlg != null &amp;&amp; !identityAlg.isEmpty()) {
<span class="line-modified">1512                 X509TrustManagerImpl.checkIdentity(session, chain,</span>
<span class="line-modified">1513                                     identityAlg, checkClientTrusted);</span>

1514             }
1515 
1516             // try the best to check the algorithm constraints
1517             AlgorithmConstraints constraints;
1518             if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {
1519                 if (session instanceof ExtendedSSLSession) {
1520                     ExtendedSSLSession extSession =
1521                                     (ExtendedSSLSession)session;
1522                     String[] peerSupportedSignAlgs =
1523                             extSession.getLocalSupportedSignatureAlgorithms();
1524 
1525                     constraints = new SSLAlgorithmConstraints(
1526                                     engine, peerSupportedSignAlgs, true);
1527                 } else {
1528                     constraints =
1529                             new SSLAlgorithmConstraints(engine, true);
1530                 }
1531             } else {
1532                 constraints = new SSLAlgorithmConstraints(engine, true);
1533             }
1534 
<span class="line-modified">1535             checkAlgorithmConstraints(chain, constraints, checkClientTrusted);</span>
1536         }
1537     }
1538 
1539     private void checkAlgorithmConstraints(X509Certificate[] chain,
1540             AlgorithmConstraints constraints,
<span class="line-modified">1541             boolean checkClientTrusted) throws CertificateException {</span>
1542         try {
1543             // Does the certificate chain end with a trusted certificate?
1544             int checkedLength = chain.length - 1;
1545 
1546             Collection&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
1547             X509Certificate[] certs = tm.getAcceptedIssuers();
1548             if ((certs != null) &amp;&amp; (certs.length &gt; 0)){
1549                 Collections.addAll(trustedCerts, certs);
1550             }
1551 
1552             if (trustedCerts.contains(chain[checkedLength])) {
1553                     checkedLength--;
1554             }
1555 
1556             // A forward checker, need to check from trust to target
1557             if (checkedLength &gt;= 0) {
1558                 AlgorithmChecker checker =
1559                     new AlgorithmChecker(constraints, null,
<span class="line-modified">1560                             (checkClientTrusted ? Validator.VAR_TLS_CLIENT :</span>
1561                                         Validator.VAR_TLS_SERVER));
1562                 checker.init(false);
1563                 for (int i = checkedLength; i &gt;= 0; i--) {
1564                     X509Certificate cert = chain[i];
1565                     // We don&#39;t care about the unresolved critical extensions.
1566                     checker.check(cert, Collections.&lt;String&gt;emptySet());
1567                 }
1568             }
1569         } catch (CertPathValidatorException cpve) {
1570             throw new CertificateException(
1571                 &quot;Certificates do not conform to algorithm constraints&quot;, cpve);
1572         }
1573     }
1574 }
1575 
1576 // Dummy X509TrustManager implementation, rejects all peer certificates.
1577 // Used if the application did not specify a proper X509TrustManager.
1578 final class DummyX509TrustManager extends X509ExtendedTrustManager
1579             implements X509TrustManager {
1580 
</pre>
</td>
</tr>
</table>
<center><a href="SSLConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLEngineImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
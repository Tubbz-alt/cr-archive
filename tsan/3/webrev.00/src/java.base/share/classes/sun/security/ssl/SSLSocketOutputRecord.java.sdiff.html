<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSocketOutputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSocketInputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLTransport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSocketOutputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLSocket}.
 37  */
 38 final class SSLSocketOutputRecord extends OutputRecord implements SSLRecord {
 39     private OutputStream deliverStream = null;
 40 
 41     SSLSocketOutputRecord(HandshakeHash handshakeHash) {
 42         this(handshakeHash, null);
 43     }
 44 
 45     SSLSocketOutputRecord(HandshakeHash handshakeHash,
 46             TransportContext tc) {
 47         super(handshakeHash, SSLCipher.SSLWriteCipher.nullTlsWriteCipher());
 48         this.tc = tc;
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<span class="line-modified"> 54     synchronized void encodeAlert(</span>
<span class="line-modified"> 55             byte level, byte description) throws IOException {</span>
<span class="line-modified"> 56         if (isClosed()) {</span>
<span class="line-modified"> 57             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 58                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified"> 59                     &quot;alert message: &quot; + Alert.nameOf(description));</span>



 60             }
<span class="line-removed"> 61             return;</span>
<span class="line-removed"> 62         }</span>
 63 
<span class="line-modified"> 64         // use the buf of ByteArrayOutputStream</span>
<span class="line-modified"> 65         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified"> 66         count = position;</span>
<span class="line-modified"> 67 </span>
<span class="line-modified"> 68         write(level);</span>
<span class="line-modified"> 69         write(description);</span>
<span class="line-modified"> 70         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified"> 71             SSLLogger.fine(&quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified"> 72                     &quot; &quot; + ContentType.ALERT.name +</span>
<span class="line-modified"> 73                     &quot;(&quot; + Alert.nameOf(description) + &quot;)&quot; +</span>
<span class="line-modified"> 74                     &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-modified"> 75         }</span>
 76 
<span class="line-modified"> 77         // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified"> 78         encrypt(writeCipher, ContentType.ALERT.id, headerSize);</span>
 79 
<span class="line-modified"> 80         // deliver this message</span>
<span class="line-modified"> 81         deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified"> 82         deliverStream.flush();                 // may throw IOException</span>
 83 
<span class="line-modified"> 84         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified"> 85             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified"> 86                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-modified"> 87         }</span>
 88 
<span class="line-modified"> 89         // reset the internal buffer</span>
<span class="line-modified"> 90         count = 0;</span>



 91     }
 92 
 93     @Override
<span class="line-modified"> 94     synchronized void encodeHandshake(byte[] source,</span>
 95             int offset, int length) throws IOException {
<span class="line-modified"> 96         if (isClosed()) {</span>
<span class="line-modified"> 97             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 98                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified"> 99                         &quot;handshake message&quot;,</span>
<span class="line-modified">100                         ByteBuffer.wrap(source, offset, length));</span>




101             }
<span class="line-removed">102             return;</span>
<span class="line-removed">103         }</span>
104 
<span class="line-modified">105         if (firstMessage) {</span>
<span class="line-modified">106             firstMessage = false;</span>
107 
<span class="line-modified">108             if ((helloVersion == ProtocolVersion.SSL20Hello) &amp;&amp;</span>
<span class="line-modified">109                 (source[offset] == SSLHandshake.CLIENT_HELLO.id) &amp;&amp;</span>
110                                             //  5: recode header size
<span class="line-modified">111                 (source[offset + 4 + 2 + 32] == 0)) {</span>
112                                             // V3 session ID is empty
113                                             //  4: handshake header size
114                                             //  2: client_version in ClientHello
115                                             // 32: random in ClientHello
116 
<span class="line-modified">117                 ByteBuffer v2ClientHello = encodeV2ClientHello(</span>
<span class="line-modified">118                         source, (offset + 4), (length - 4));</span>

















































119 
<span class="line-modified">120                 byte[] record = v2ClientHello.array();  // array offset is zero</span>
<span class="line-modified">121                 int limit = v2ClientHello.limit();</span>
<span class="line-modified">122                 handshakeHash.deliver(record, 2, (limit - 2));</span>


123 
124                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
125                     SSLLogger.fine(
<span class="line-modified">126                             &quot;WRITE: SSLv2 ClientHello message&quot; +</span>
<span class="line-modified">127                             &quot;, length = &quot; + limit);</span>

128                 }
129 



130                 // deliver this message
<span class="line-modified">131                 //</span>
<span class="line-modified">132                 // Version 2 ClientHello message should be plaintext.</span>
<span class="line-removed">133                 //</span>
<span class="line-removed">134                 // No max fragment length negotiation.</span>
<span class="line-removed">135                 deliverStream.write(record, 0, limit);</span>
<span class="line-removed">136                 deliverStream.flush();</span>
137 
138                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
139                     SSLLogger.fine(&quot;Raw write&quot;,
<span class="line-modified">140                             (new ByteArrayInputStream(record, 0, limit)));</span>
141                 }
142 
<span class="line-modified">143                 return;</span>




144             }


145         }

146 
<span class="line-modified">147         byte handshakeType = source[0];</span>
<span class="line-modified">148         if (handshakeHash.isHashable(handshakeType)) {</span>
<span class="line-modified">149             handshakeHash.deliver(source, offset, length);</span>
<span class="line-modified">150         }</span>







151 
<span class="line-modified">152         int fragLimit = getFragLimit();</span>
<span class="line-modified">153         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">154         if (count == 0) {</span>
155             count = position;
<span class="line-removed">156         }</span>
157 
<span class="line-modified">158         if ((count - position) &lt; (fragLimit - length)) {</span>
<span class="line-removed">159             write(source, offset, length);</span>
<span class="line-removed">160             return;</span>
<span class="line-removed">161         }</span>
162 
<span class="line-modified">163         for (int limit = (offset + length); offset &lt; limit;) {</span>

164 
<span class="line-modified">165             int remains = (limit - offset) + (count - position);</span>
<span class="line-modified">166             int fragLen = Math.min(fragLimit, remains);</span>

167 
<span class="line-modified">168             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">169             write(source, offset, fragLen);</span>
<span class="line-modified">170             if (remains &lt; fragLimit) {</span>















171                 return;
172             }
173 
174             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
175                 SSLLogger.fine(
176                         &quot;WRITE: &quot; + protocolVersion +
177                         &quot; &quot; + ContentType.HANDSHAKE.name +
178                         &quot;, length = &quot; + (count - headerSize));
179             }
180 
181             // Encrypt the fragment and wrap up a record.
182             encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
183 
184             // deliver this message
185             deliverStream.write(buf, 0, count);    // may throw IOException
186             deliverStream.flush();                 // may throw IOException
187 
188             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
189                 SSLLogger.fine(&quot;Raw write&quot;,
190                         (new ByteArrayInputStream(buf, 0, count)));
191             }
192 
<span class="line-removed">193             // reset the offset</span>
<span class="line-removed">194             offset += fragLen;</span>
<span class="line-removed">195 </span>
196             // reset the internal buffer
<span class="line-modified">197             count = position;</span>


198         }
199     }
200 
201     @Override
<span class="line-modified">202     synchronized void encodeChangeCipherSpec() throws IOException {</span>
<span class="line-modified">203         if (isClosed()) {</span>
<span class="line-modified">204             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">205                 SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-modified">206                     &quot;change_cipher_spec message&quot;);</span>

207             }
<span class="line-removed">208             return;</span>
<span class="line-removed">209         }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211         // use the buf of ByteArrayOutputStream</span>
<span class="line-removed">212         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">213         count = position;</span>
<span class="line-removed">214 </span>
<span class="line-removed">215         write((byte)1);         // byte 1: change_cipher_spec(</span>
<span class="line-removed">216 </span>
<span class="line-removed">217         // Encrypt the fragment and wrap up a record.</span>
<span class="line-removed">218         encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);</span>
<span class="line-removed">219 </span>
<span class="line-removed">220         // deliver this message</span>
<span class="line-removed">221         deliverStream.write(buf, 0, count);        // may throw IOException</span>
<span class="line-removed">222         // deliverStream.flush();                  // flush in Finished</span>
<span class="line-removed">223 </span>
<span class="line-removed">224         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-removed">225             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">226                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229         // reset the internal buffer</span>
<span class="line-removed">230         count = 0;</span>
<span class="line-removed">231     }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233     @Override</span>
<span class="line-removed">234     public synchronized void flush() throws IOException {</span>
<span class="line-removed">235         int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-removed">236         if (count &lt;= position) {</span>
<span class="line-removed">237             return;</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239 </span>
<span class="line-removed">240         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-removed">241             SSLLogger.fine(</span>
<span class="line-removed">242                     &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-removed">243                     &quot; &quot; + ContentType.HANDSHAKE.name +</span>
<span class="line-removed">244                     &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-removed">245         }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247         // Encrypt the fragment and wrap up a record.</span>
<span class="line-removed">248         encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         // deliver this message</span>
<span class="line-removed">251         deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-removed">252         deliverStream.flush();                 // may throw IOException</span>
<span class="line-removed">253 </span>
<span class="line-removed">254         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-removed">255             SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">256                     (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258 </span>
<span class="line-removed">259         // reset the internal buffer</span>
<span class="line-removed">260         count = 0;      // DON&#39;T use position</span>
<span class="line-removed">261     }</span>
262 
<span class="line-modified">263     @Override</span>
<span class="line-modified">264     synchronized void deliver(</span>
<span class="line-modified">265             byte[] source, int offset, int length) throws IOException {</span>
<span class="line-modified">266         if (isClosed()) {</span>
<span class="line-modified">267             throw new SocketException(&quot;Connection or outbound has been closed&quot;);</span>
<span class="line-modified">268         }</span>
269 
<span class="line-modified">270         if (writeCipher.authenticator.seqNumOverflow()) {</span>
<span class="line-removed">271             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-removed">272                 SSLLogger.fine(</span>
<span class="line-removed">273                     &quot;sequence number extremely close to overflow &quot; +</span>
<span class="line-removed">274                     &quot;(2^64-1 packets). Closing connection.&quot;);</span>
275             }
276 
<span class="line-modified">277             throw new SSLHandshakeException(&quot;sequence number overflow&quot;);</span>
<span class="line-modified">278         }</span>










279 
<span class="line-modified">280         boolean isFirstRecordOfThePayload = true;</span>
<span class="line-modified">281         for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-removed">282             int fragLen;</span>
<span class="line-removed">283             if (packetSize &gt; 0) {</span>
<span class="line-removed">284                 fragLen = Math.min(maxRecordSize, packetSize);</span>
<span class="line-removed">285                 fragLen =</span>
<span class="line-removed">286                         writeCipher.calculateFragmentSize(fragLen, headerSize);</span>
<span class="line-removed">287 </span>
<span class="line-removed">288                 fragLen = Math.min(fragLen, Record.maxDataSize);</span>
<span class="line-removed">289             } else {</span>
<span class="line-removed">290                 fragLen = Record.maxDataSize;</span>
<span class="line-removed">291             }</span>
292 
<span class="line-modified">293             if (fragmentSize &gt; 0) {</span>
<span class="line-modified">294                 fragLen = Math.min(fragLen, fragmentSize);</span>
<span class="line-modified">295             }</span>



296 
<span class="line-modified">297             if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {</span>
<span class="line-modified">298                 fragLen = 1;</span>
<span class="line-modified">299                 isFirstRecordOfThePayload = false;</span>
<span class="line-modified">300             } else {</span>
<span class="line-removed">301                 fragLen = Math.min(fragLen, (limit - offset));</span>
<span class="line-removed">302             }</span>
303 
<span class="line-modified">304             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">305             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified">306             count = position;</span>
<span class="line-modified">307             write(source, offset, fragLen);</span>


308 
<span class="line-modified">309             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified">310                 SSLLogger.fine(</span>
<span class="line-modified">311                         &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-removed">312                         &quot; &quot; + ContentType.APPLICATION_DATA.name +</span>
<span class="line-removed">313                         &quot;, length = &quot; + (count - position));</span>
<span class="line-removed">314             }</span>
315 
<span class="line-modified">316             // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified">317             encrypt(writeCipher, ContentType.APPLICATION_DATA.id, headerSize);</span>

318 
<span class="line-modified">319             // deliver this message</span>
<span class="line-modified">320             deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified">321             deliverStream.flush();                 // may throw IOException</span>

322 
<span class="line-modified">323             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">324                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-removed">325                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-removed">326             }</span>
327 
<span class="line-modified">328             // reset the internal buffer</span>
<span class="line-modified">329             count = 0;</span>

330 
<span class="line-modified">331             if (isFirstAppOutputRecord) {</span>
<span class="line-removed">332                 isFirstAppOutputRecord = false;</span>
333             }
<span class="line-modified">334 </span>
<span class="line-modified">335             offset += fragLen;</span>
336         }
337     }
338 
339     @Override
<span class="line-modified">340     synchronized void setDeliverStream(OutputStream outputStream) {</span>
<span class="line-modified">341         this.deliverStream = outputStream;</span>





342     }
343 
344     /*
345      * Need to split the payload except the following cases:
346      *
347      * 1. protocol version is TLS 1.1 or later;
348      * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
349      * 3. the payload is the first application record of a freshly
350      *    negotiated TLS session.
351      * 4. the CBC protection is disabled;
352      *
353      * By default, we counter chosen plaintext issues on CBC mode
354      * ciphersuites in SSLv3/TLS1.0 by sending one byte of application
355      * data in the first record of every payload, and the rest in
356      * subsequent record(s). Note that the issues have been solved in
357      * TLS 1.1 or later.
358      *
359      * It is not necessary to split the very first application record of
360      * a freshly negotiated TLS session, as there is no previous
361      * application data to guess.  To improve compatibility, we will not
</pre>
<hr />
<pre>
365      * the peer must have similar protections.
366      */
367     private boolean needToSplitPayload() {
368         return (!protocolVersion.useTLS11PlusSpec()) &amp;&amp;
369                 writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;
370                 Record.enableCBCProtection;
371     }
372 
373     private int getFragLimit() {
374         int fragLimit;
375         if (packetSize &gt; 0) {
376             fragLimit = Math.min(maxRecordSize, packetSize);
377             fragLimit =
378                     writeCipher.calculateFragmentSize(fragLimit, headerSize);
379 
380             fragLimit = Math.min(fragLimit, Record.maxDataSize);
381         } else {
382             fragLimit = Record.maxDataSize;
383         }
384 
<span class="line-modified">385         if (fragmentSize &gt; 0) {</span>
<span class="line-modified">386             fragLimit = Math.min(fragLimit, fragmentSize);</span>
<span class="line-removed">387         }</span>
388 
389         return fragLimit;
390     }
391 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 
 35 /**
 36  * {@code OutputRecord} implementation for {@code SSLSocket}.
 37  */
 38 final class SSLSocketOutputRecord extends OutputRecord implements SSLRecord {
 39     private OutputStream deliverStream = null;
 40 
 41     SSLSocketOutputRecord(HandshakeHash handshakeHash) {
 42         this(handshakeHash, null);
 43     }
 44 
 45     SSLSocketOutputRecord(HandshakeHash handshakeHash,
 46             TransportContext tc) {
 47         super(handshakeHash, SSLCipher.SSLWriteCipher.nullTlsWriteCipher());
 48         this.tc = tc;
 49         this.packetSize = SSLRecord.maxRecordSize;
 50         this.protocolVersion = ProtocolVersion.NONE;
 51     }
 52 
 53     @Override
<span class="line-modified"> 54     void encodeAlert(byte level, byte description) throws IOException {</span>
<span class="line-modified"> 55         recordLock.lock();</span>
<span class="line-modified"> 56         try {</span>
<span class="line-modified"> 57             if (isClosed()) {</span>
<span class="line-modified"> 58                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified"> 59                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added"> 60                         &quot;alert message: &quot; + Alert.nameOf(description));</span>
<span class="line-added"> 61                 }</span>
<span class="line-added"> 62                 return;</span>
 63             }


 64 
<span class="line-modified"> 65             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified"> 66             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified"> 67             count = position;</span>
<span class="line-modified"> 68 </span>
<span class="line-modified"> 69             write(level);</span>
<span class="line-modified"> 70             write(description);</span>
<span class="line-modified"> 71             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified"> 72                 SSLLogger.fine(&quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified"> 73                         &quot; &quot; + ContentType.ALERT.name +</span>
<span class="line-modified"> 74                         &quot;(&quot; + Alert.nameOf(description) + &quot;)&quot; +</span>
<span class="line-modified"> 75                         &quot;, length = &quot; + (count - headerSize));</span>
<span class="line-modified"> 76             }</span>
 77 
<span class="line-modified"> 78             // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified"> 79             encrypt(writeCipher, ContentType.ALERT.id, headerSize);</span>
 80 
<span class="line-modified"> 81             // deliver this message</span>
<span class="line-modified"> 82             deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified"> 83             deliverStream.flush();                 // may throw IOException</span>
 84 
<span class="line-modified"> 85             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified"> 86                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified"> 87                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-modified"> 88             }</span>
 89 
<span class="line-modified"> 90             // reset the internal buffer</span>
<span class="line-modified"> 91             count = 0;</span>
<span class="line-added"> 92         } finally {</span>
<span class="line-added"> 93             recordLock.unlock();</span>
<span class="line-added"> 94         }</span>
 95     }
 96 
 97     @Override
<span class="line-modified"> 98     void encodeHandshake(byte[] source,</span>
 99             int offset, int length) throws IOException {
<span class="line-modified">100         recordLock.lock();</span>
<span class="line-modified">101         try {</span>
<span class="line-modified">102             if (isClosed()) {</span>
<span class="line-modified">103                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">104                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">105                             &quot;handshake message&quot;,</span>
<span class="line-added">106                             ByteBuffer.wrap(source, offset, length));</span>
<span class="line-added">107                 }</span>
<span class="line-added">108                 return;</span>
109             }


110 
<span class="line-modified">111             if (firstMessage) {</span>
<span class="line-modified">112                 firstMessage = false;</span>
113 
<span class="line-modified">114                 if ((helloVersion == ProtocolVersion.SSL20Hello) &amp;&amp;</span>
<span class="line-modified">115                     (source[offset] == SSLHandshake.CLIENT_HELLO.id) &amp;&amp;</span>
116                                             //  5: recode header size
<span class="line-modified">117                     (source[offset + 4 + 2 + 32] == 0)) {</span>
118                                             // V3 session ID is empty
119                                             //  4: handshake header size
120                                             //  2: client_version in ClientHello
121                                             // 32: random in ClientHello
122 
<span class="line-modified">123                     ByteBuffer v2ClientHello = encodeV2ClientHello(</span>
<span class="line-modified">124                             source, (offset + 4), (length - 4));</span>
<span class="line-added">125 </span>
<span class="line-added">126                     // array offset is zero</span>
<span class="line-added">127                     byte[] record = v2ClientHello.array();</span>
<span class="line-added">128                     int limit = v2ClientHello.limit();</span>
<span class="line-added">129                     handshakeHash.deliver(record, 2, (limit - 2));</span>
<span class="line-added">130 </span>
<span class="line-added">131                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-added">132                         SSLLogger.fine(</span>
<span class="line-added">133                                 &quot;WRITE: SSLv2 ClientHello message&quot; +</span>
<span class="line-added">134                                 &quot;, length = &quot; + limit);</span>
<span class="line-added">135                     }</span>
<span class="line-added">136 </span>
<span class="line-added">137                     // deliver this message</span>
<span class="line-added">138                     //</span>
<span class="line-added">139                     // Version 2 ClientHello message should be plaintext.</span>
<span class="line-added">140                     //</span>
<span class="line-added">141                     // No max fragment length negotiation.</span>
<span class="line-added">142                     deliverStream.write(record, 0, limit);</span>
<span class="line-added">143                     deliverStream.flush();</span>
<span class="line-added">144 </span>
<span class="line-added">145                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-added">146                         SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-added">147                                 (new ByteArrayInputStream(record, 0, limit)));</span>
<span class="line-added">148                     }</span>
<span class="line-added">149 </span>
<span class="line-added">150                     return;</span>
<span class="line-added">151                 }</span>
<span class="line-added">152             }</span>
<span class="line-added">153 </span>
<span class="line-added">154             byte handshakeType = source[0];</span>
<span class="line-added">155             if (handshakeHash.isHashable(handshakeType)) {</span>
<span class="line-added">156                 handshakeHash.deliver(source, offset, length);</span>
<span class="line-added">157             }</span>
<span class="line-added">158 </span>
<span class="line-added">159             int fragLimit = getFragLimit();</span>
<span class="line-added">160             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-added">161             if (count == 0) {</span>
<span class="line-added">162                 count = position;</span>
<span class="line-added">163             }</span>
<span class="line-added">164 </span>
<span class="line-added">165             if ((count - position) &lt; (fragLimit - length)) {</span>
<span class="line-added">166                 write(source, offset, length);</span>
<span class="line-added">167                 return;</span>
<span class="line-added">168             }</span>
<span class="line-added">169 </span>
<span class="line-added">170             for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-added">171 </span>
<span class="line-added">172                 int remains = (limit - offset) + (count - position);</span>
<span class="line-added">173                 int fragLen = Math.min(fragLimit, remains);</span>
174 
<span class="line-modified">175                 // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">176                 write(source, offset, fragLen);</span>
<span class="line-modified">177                 if (remains &lt; fragLimit) {</span>
<span class="line-added">178                     return;</span>
<span class="line-added">179                 }</span>
180 
181                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
182                     SSLLogger.fine(
<span class="line-modified">183                             &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified">184                             &quot; &quot; + ContentType.HANDSHAKE.name +</span>
<span class="line-added">185                             &quot;, length = &quot; + (count - headerSize));</span>
186                 }
187 
<span class="line-added">188                 // Encrypt the fragment and wrap up a record.</span>
<span class="line-added">189                 encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);</span>
<span class="line-added">190 </span>
191                 // deliver this message
<span class="line-modified">192                 deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-modified">193                 deliverStream.flush();                 // may throw IOException</span>




194 
195                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
196                     SSLLogger.fine(&quot;Raw write&quot;,
<span class="line-modified">197                             (new ByteArrayInputStream(buf, 0, count)));</span>
198                 }
199 
<span class="line-modified">200                 // reset the offset</span>
<span class="line-added">201                 offset += fragLen;</span>
<span class="line-added">202 </span>
<span class="line-added">203                 // reset the internal buffer</span>
<span class="line-added">204                 count = position;</span>
205             }
<span class="line-added">206         } finally {</span>
<span class="line-added">207             recordLock.unlock();</span>
208         }
<span class="line-added">209     }</span>
210 
<span class="line-modified">211     @Override</span>
<span class="line-modified">212     void encodeChangeCipherSpec() throws IOException {</span>
<span class="line-modified">213         recordLock.lock();</span>
<span class="line-modified">214         try {</span>
<span class="line-added">215             if (isClosed()) {</span>
<span class="line-added">216                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-added">217                     SSLLogger.warning(&quot;outbound has closed, ignore outbound &quot; +</span>
<span class="line-added">218                         &quot;change_cipher_spec message&quot;);</span>
<span class="line-added">219                 }</span>
<span class="line-added">220                 return;</span>
<span class="line-added">221             }</span>
222 
<span class="line-modified">223             // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">224             int position = headerSize + writeCipher.getExplicitNonceSize();</span>

225             count = position;

226 
<span class="line-modified">227             write((byte)1);         // byte 1: change_cipher_spec(</span>



228 
<span class="line-modified">229             // Encrypt the fragment and wrap up a record.</span>
<span class="line-added">230             encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);</span>
231 
<span class="line-modified">232             // deliver this message</span>
<span class="line-modified">233             deliverStream.write(buf, 0, count);        // may throw IOException</span>
<span class="line-added">234             // deliverStream.flush();                  // flush in Finished</span>
235 
<span class="line-modified">236             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">237                 SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified">238                         (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-added">239             }</span>
<span class="line-added">240 </span>
<span class="line-added">241             // reset the internal buffer</span>
<span class="line-added">242             count = 0;</span>
<span class="line-added">243         } finally {</span>
<span class="line-added">244             recordLock.unlock();</span>
<span class="line-added">245         }</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     @Override</span>
<span class="line-added">249     public void flush() throws IOException {</span>
<span class="line-added">250         recordLock.lock();</span>
<span class="line-added">251         try {</span>
<span class="line-added">252             int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-added">253             if (count &lt;= position) {</span>
254                 return;
255             }
256 
257             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
258                 SSLLogger.fine(
259                         &quot;WRITE: &quot; + protocolVersion +
260                         &quot; &quot; + ContentType.HANDSHAKE.name +
261                         &quot;, length = &quot; + (count - headerSize));
262             }
263 
264             // Encrypt the fragment and wrap up a record.
265             encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);
266 
267             // deliver this message
268             deliverStream.write(buf, 0, count);    // may throw IOException
269             deliverStream.flush();                 // may throw IOException
270 
271             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
272                 SSLLogger.fine(&quot;Raw write&quot;,
273                         (new ByteArrayInputStream(buf, 0, count)));
274             }
275 



276             // reset the internal buffer
<span class="line-modified">277             count = 0;      // DON&#39;T use position</span>
<span class="line-added">278         } finally {</span>
<span class="line-added">279             recordLock.unlock();</span>
280         }
281     }
282 
283     @Override
<span class="line-modified">284     void deliver(byte[] source, int offset, int length) throws IOException {</span>
<span class="line-modified">285         recordLock.lock();</span>
<span class="line-modified">286         try {</span>
<span class="line-modified">287             if (isClosed()) {</span>
<span class="line-modified">288                 throw new SocketException(</span>
<span class="line-added">289                         &quot;Connection or outbound has been closed&quot;);</span>
290             }






















































291 
<span class="line-modified">292             if (writeCipher.authenticator.seqNumOverflow()) {</span>
<span class="line-modified">293                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {</span>
<span class="line-modified">294                     SSLLogger.fine(</span>
<span class="line-modified">295                         &quot;sequence number extremely close to overflow &quot; +</span>
<span class="line-modified">296                         &quot;(2^64-1 packets). Closing connection.&quot;);</span>
<span class="line-modified">297                 }</span>
298 
<span class="line-modified">299                 throw new SSLHandshakeException(&quot;sequence number overflow&quot;);</span>




300             }
301 
<span class="line-modified">302             boolean isFirstRecordOfThePayload = true;</span>
<span class="line-modified">303             for (int limit = (offset + length); offset &lt; limit;) {</span>
<span class="line-added">304                 int fragLen;</span>
<span class="line-added">305                 if (packetSize &gt; 0) {</span>
<span class="line-added">306                     fragLen = Math.min(maxRecordSize, packetSize);</span>
<span class="line-added">307                     fragLen = writeCipher.calculateFragmentSize(</span>
<span class="line-added">308                             fragLen, headerSize);</span>
<span class="line-added">309 </span>
<span class="line-added">310                     fragLen = Math.min(fragLen, Record.maxDataSize);</span>
<span class="line-added">311                 } else {</span>
<span class="line-added">312                     fragLen = Record.maxDataSize;</span>
<span class="line-added">313                 }</span>
314 
<span class="line-modified">315                 // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">316                 fragLen = calculateFragmentSize(fragLen);</span>










317 
<span class="line-modified">318                 if (isFirstRecordOfThePayload &amp;&amp; needToSplitPayload()) {</span>
<span class="line-modified">319                     fragLen = 1;</span>
<span class="line-modified">320                     isFirstRecordOfThePayload = false;</span>
<span class="line-added">321                 } else {</span>
<span class="line-added">322                     fragLen = Math.min(fragLen, (limit - offset));</span>
<span class="line-added">323                 }</span>
324 
<span class="line-modified">325                 // use the buf of ByteArrayOutputStream</span>
<span class="line-modified">326                 int position = headerSize + writeCipher.getExplicitNonceSize();</span>
<span class="line-modified">327                 count = position;</span>
<span class="line-modified">328                 write(source, offset, fragLen);</span>


329 
<span class="line-modified">330                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {</span>
<span class="line-modified">331                     SSLLogger.fine(</span>
<span class="line-modified">332                             &quot;WRITE: &quot; + protocolVersion +</span>
<span class="line-modified">333                             &quot; &quot; + ContentType.APPLICATION_DATA.name +</span>
<span class="line-added">334                             &quot;, length = &quot; + (count - position));</span>
<span class="line-added">335                 }</span>
336 
<span class="line-modified">337                 // Encrypt the fragment and wrap up a record.</span>
<span class="line-modified">338                 encrypt(writeCipher,</span>
<span class="line-modified">339                         ContentType.APPLICATION_DATA.id, headerSize);</span>



340 
<span class="line-modified">341                 // deliver this message</span>
<span class="line-modified">342                 deliverStream.write(buf, 0, count);    // may throw IOException</span>
<span class="line-added">343                 deliverStream.flush();                 // may throw IOException</span>
344 
<span class="line-modified">345                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-modified">346                     SSLLogger.fine(&quot;Raw write&quot;,</span>
<span class="line-modified">347                             (new ByteArrayInputStream(buf, 0, count)));</span>
<span class="line-added">348                 }</span>
349 
<span class="line-modified">350                 // reset the internal buffer</span>
<span class="line-modified">351                 count = 0;</span>


352 
<span class="line-modified">353                 if (isFirstAppOutputRecord) {</span>
<span class="line-modified">354                     isFirstAppOutputRecord = false;</span>
<span class="line-added">355                 }</span>
356 
<span class="line-modified">357                 offset += fragLen;</span>

358             }
<span class="line-modified">359         } finally {</span>
<span class="line-modified">360             recordLock.unlock();</span>
361         }
362     }
363 
364     @Override
<span class="line-modified">365     void setDeliverStream(OutputStream outputStream) {</span>
<span class="line-modified">366         recordLock.lock();</span>
<span class="line-added">367         try {</span>
<span class="line-added">368             this.deliverStream = outputStream;</span>
<span class="line-added">369         } finally {</span>
<span class="line-added">370             recordLock.unlock();</span>
<span class="line-added">371         }</span>
372     }
373 
374     /*
375      * Need to split the payload except the following cases:
376      *
377      * 1. protocol version is TLS 1.1 or later;
378      * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
379      * 3. the payload is the first application record of a freshly
380      *    negotiated TLS session.
381      * 4. the CBC protection is disabled;
382      *
383      * By default, we counter chosen plaintext issues on CBC mode
384      * ciphersuites in SSLv3/TLS1.0 by sending one byte of application
385      * data in the first record of every payload, and the rest in
386      * subsequent record(s). Note that the issues have been solved in
387      * TLS 1.1 or later.
388      *
389      * It is not necessary to split the very first application record of
390      * a freshly negotiated TLS session, as there is no previous
391      * application data to guess.  To improve compatibility, we will not
</pre>
<hr />
<pre>
395      * the peer must have similar protections.
396      */
397     private boolean needToSplitPayload() {
398         return (!protocolVersion.useTLS11PlusSpec()) &amp;&amp;
399                 writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;
400                 Record.enableCBCProtection;
401     }
402 
403     private int getFragLimit() {
404         int fragLimit;
405         if (packetSize &gt; 0) {
406             fragLimit = Math.min(maxRecordSize, packetSize);
407             fragLimit =
408                     writeCipher.calculateFragmentSize(fragLimit, headerSize);
409 
410             fragLimit = Math.min(fragLimit, Record.maxDataSize);
411         } else {
412             fragLimit = Record.maxDataSize;
413         }
414 
<span class="line-modified">415         // Calculate more impact, for example TLS 1.3 padding.</span>
<span class="line-modified">416         fragLimit = calculateFragmentSize(fragLimit);</span>

417 
418         return fragLimit;
419     }
420 }
</pre>
</td>
</tr>
</table>
<center><a href="SSLSocketInputRecord.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLTransport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
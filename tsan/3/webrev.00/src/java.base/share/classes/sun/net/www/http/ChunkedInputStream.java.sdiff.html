<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/net/www/http/ChunkedInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ParseUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ChunkedOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/net/www/http/ChunkedInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.net.www.http;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.net.*;
 31 import sun.net.www.*;

 32 
 33 /**
 34  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; provides a stream for reading a body of
 35  * a http message that can be sent as a series of chunks, each with its own
 36  * size indicator. Optionally the last chunk can be followed by trailers
 37  * containing entity-header fields.
 38  * &lt;p&gt;
 39  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; is also &lt;code&gt;Hurryable&lt;/code&gt; so it
 40  * can be hurried to the end of the stream if the bytes are available on
 41  * the underlying stream.
 42  */
 43 public
 44 class ChunkedInputStream extends InputStream implements Hurryable {
 45 
 46     /**
 47      * The underlying stream
 48      */
 49     private InputStream in;
 50 
 51     /**
</pre>
<hr />
<pre>
290                      * insufficient bytes in the raw buffer to parse a chunk header.
291                      */
292                     pos = rawPos;
293                     while (pos &lt; rawCount) {
294                         if (rawData[pos] == &#39;\n&#39;) {
295                             break;
296                         }
297                         pos++;
298                         if ((pos - rawPos) &gt;= MAX_CHUNK_HEADER_SIZE) {
299                             error = true;
300                             throw new IOException(&quot;Chunk header too long&quot;);
301                         }
302                     }
303                     if (pos &gt;= rawCount) {
304                         return;
305                     }
306 
307                     /*
308                      * Extract the chunk size from the header (ignoring extensions).
309                      */
<span class="line-modified">310                     String header = new String(rawData, rawPos, pos-rawPos+1, &quot;US-ASCII&quot;);</span>

311                     for (i=0; i &lt; header.length(); i++) {
312                         if (Character.digit(header.charAt(i), 16) == -1)
313                             break;
314                     }
315                     try {
316                         chunkSize = Integer.parseInt(header, 0, i, 16);
317                     } catch (NumberFormatException e) {
318                         error = true;
319                         throw new IOException(&quot;Bogus chunk size&quot;);
320                     }
321 
322                     /*
323                      * Chunk has been parsed so move rawPos to first byte of chunk
324                      * data.
325                      */
326                     rawPos = pos + 1;
327                     chunkRead = 0;
328 
329                     /*
330                      * A chunk size of 0 means EOF.
</pre>
<hr />
<pre>
444                     if (rawData[pos-1] != &#39;\r&#39;) {
445                         error = true;
446                         throw new IOException(&quot;LF should be proceeded by CR&quot;);
447                     }
448 
449                     /*
450                      * Stream done so close underlying stream.
451                      */
452                     if (pos == (rawPos + 1)) {
453 
454                         state = STATE_DONE;
455                         closeUnderlying();
456 
457                         return;
458                     }
459 
460                     /*
461                      * Extract any tailers and append them to the message
462                      * headers.
463                      */
<span class="line-modified">464                     String trailer = new String(rawData, rawPos, pos-rawPos, &quot;US-ASCII&quot;);</span>

465                     i = trailer.indexOf(&#39;:&#39;);
466                     if (i == -1) {
467                         throw new IOException(&quot;Malformed tailer - format should be key:value&quot;);
468                     }
469                     String key = (trailer.substring(0, i)).trim();
470                     String value = (trailer.substring(i+1, trailer.length())).trim();
471 
472                     responses.add(key, value);
473 
474                     /*
475                      * Move onto the next trailer.
476                      */
477                     rawPos = pos+1;
478                     break;
479 
480             } /* switch */
481         }
482     }
483 
484 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.net.www.http;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.net.*;
 31 import sun.net.www.*;
<span class="line-added"> 32 import sun.nio.cs.US_ASCII;</span>
 33 
 34 /**
 35  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; provides a stream for reading a body of
 36  * a http message that can be sent as a series of chunks, each with its own
 37  * size indicator. Optionally the last chunk can be followed by trailers
 38  * containing entity-header fields.
 39  * &lt;p&gt;
 40  * A &lt;code&gt;ChunkedInputStream&lt;/code&gt; is also &lt;code&gt;Hurryable&lt;/code&gt; so it
 41  * can be hurried to the end of the stream if the bytes are available on
 42  * the underlying stream.
 43  */
 44 public
 45 class ChunkedInputStream extends InputStream implements Hurryable {
 46 
 47     /**
 48      * The underlying stream
 49      */
 50     private InputStream in;
 51 
 52     /**
</pre>
<hr />
<pre>
291                      * insufficient bytes in the raw buffer to parse a chunk header.
292                      */
293                     pos = rawPos;
294                     while (pos &lt; rawCount) {
295                         if (rawData[pos] == &#39;\n&#39;) {
296                             break;
297                         }
298                         pos++;
299                         if ((pos - rawPos) &gt;= MAX_CHUNK_HEADER_SIZE) {
300                             error = true;
301                             throw new IOException(&quot;Chunk header too long&quot;);
302                         }
303                     }
304                     if (pos &gt;= rawCount) {
305                         return;
306                     }
307 
308                     /*
309                      * Extract the chunk size from the header (ignoring extensions).
310                      */
<span class="line-modified">311                     String header = new String(rawData, rawPos, pos-rawPos+1,</span>
<span class="line-added">312                             US_ASCII.INSTANCE);</span>
313                     for (i=0; i &lt; header.length(); i++) {
314                         if (Character.digit(header.charAt(i), 16) == -1)
315                             break;
316                     }
317                     try {
318                         chunkSize = Integer.parseInt(header, 0, i, 16);
319                     } catch (NumberFormatException e) {
320                         error = true;
321                         throw new IOException(&quot;Bogus chunk size&quot;);
322                     }
323 
324                     /*
325                      * Chunk has been parsed so move rawPos to first byte of chunk
326                      * data.
327                      */
328                     rawPos = pos + 1;
329                     chunkRead = 0;
330 
331                     /*
332                      * A chunk size of 0 means EOF.
</pre>
<hr />
<pre>
446                     if (rawData[pos-1] != &#39;\r&#39;) {
447                         error = true;
448                         throw new IOException(&quot;LF should be proceeded by CR&quot;);
449                     }
450 
451                     /*
452                      * Stream done so close underlying stream.
453                      */
454                     if (pos == (rawPos + 1)) {
455 
456                         state = STATE_DONE;
457                         closeUnderlying();
458 
459                         return;
460                     }
461 
462                     /*
463                      * Extract any tailers and append them to the message
464                      * headers.
465                      */
<span class="line-modified">466                     String trailer = new String(rawData, rawPos, pos-rawPos,</span>
<span class="line-added">467                             US_ASCII.INSTANCE);</span>
468                     i = trailer.indexOf(&#39;:&#39;);
469                     if (i == -1) {
470                         throw new IOException(&quot;Malformed tailer - format should be key:value&quot;);
471                     }
472                     String key = (trailer.substring(0, i)).trim();
473                     String value = (trailer.substring(i+1, trailer.length())).trim();
474 
475                     responses.add(key, value);
476 
477                     /*
478                      * Move onto the next trailer.
479                      */
480                     rawPos = pos+1;
481                     break;
482 
483             } /* switch */
484         }
485     }
486 
487 
</pre>
</td>
</tr>
</table>
<center><a href="../ParseUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ChunkedOutputStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
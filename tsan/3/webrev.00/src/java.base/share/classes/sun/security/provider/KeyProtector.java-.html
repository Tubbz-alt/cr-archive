<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/provider/KeyProtector.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.provider;
 27 
 28 import java.io.IOException;
 29 import java.io.UnsupportedEncodingException;
 30 import java.security.Key;
 31 import java.security.KeyStoreException;
 32 import java.security.MessageDigest;
 33 import java.security.NoSuchAlgorithmException;
 34 import java.security.SecureRandom;
 35 import java.security.UnrecoverableKeyException;
 36 import java.util.*;
 37 
 38 import sun.security.pkcs.PKCS8Key;
 39 import sun.security.pkcs.EncryptedPrivateKeyInfo;
 40 import sun.security.x509.AlgorithmId;
 41 import sun.security.util.ObjectIdentifier;
 42 import sun.security.util.DerValue;
 43 
 44 /**
 45  * This is an implementation of a Sun proprietary, exportable algorithm
 46  * intended for use when protecting (or recovering the cleartext version of)
 47  * sensitive keys.
 48  * This algorithm is not intended as a general purpose cipher.
 49  *
 50  * This is how the algorithm works for key protection:
 51  *
 52  * p - user password
 53  * s - random salt
 54  * X - xor key
 55  * P - to-be-protected key
 56  * Y - protected key
 57  * R - what gets stored in the keystore
 58  *
 59  * Step 1:
 60  * Take the user&#39;s password, append a random salt (of fixed size) to it,
 61  * and hash it: d1 = digest(p, s)
 62  * Store d1 in X.
 63  *
 64  * Step 2:
 65  * Take the user&#39;s password, append the digest result from the previous step,
 66  * and hash it: dn = digest(p, dn-1).
 67  * Store dn in X (append it to the previously stored digests).
 68  * Repeat this step until the length of X matches the length of the private key
 69  * P.
 70  *
 71  * Step 3:
 72  * XOR X and P, and store the result in Y: Y = X XOR P.
 73  *
 74  * Step 4:
 75  * Store s, Y, and digest(p, P) in the result buffer R:
 76  * R = s + Y + digest(p, P), where &quot;+&quot; denotes concatenation.
 77  * (NOTE: digest(p, P) is stored in the result buffer, so that when the key is
 78  * recovered, we can check if the recovered key indeed matches the original
 79  * key.) R is stored in the keystore.
 80  *
 81  * The protected key is recovered as follows:
 82  *
 83  * Step1 and Step2 are the same as above, except that the salt is not randomly
 84  * generated, but taken from the result R of step 4 (the first length(s)
 85  * bytes).
 86  *
 87  * Step 3 (XOR operation) yields the plaintext key.
 88  *
 89  * Then concatenate the password with the recovered key, and compare with the
 90  * last length(digest(p, P)) bytes of R. If they match, the recovered key is
 91  * indeed the same key as the original key.
 92  *
 93  * @author Jan Luehe
 94  *
 95  *
 96  * @see java.security.KeyStore
 97  * @see JavaKeyStore
 98  * @see KeyTool
 99  *
100  * @since 1.2
101  */
102 
103 final class KeyProtector {
104 
105     private static final int SALT_LEN = 20; // the salt length
106     private static final String DIGEST_ALG = &quot;SHA&quot;;
107     private static final int DIGEST_LEN = 20;
108 
109     // defined by JavaSoft
110     private static final String KEY_PROTECTOR_OID = &quot;1.3.6.1.4.1.42.2.17.1.1&quot;;
111 
112     // The password used for protecting/recovering keys passed through this
113     // key protector. We store it as a byte array, so that we can digest it.
114     private byte[] passwdBytes;
115 
116     private MessageDigest md;
117 
118 
119     /**
120      * Creates an instance of this class, and initializes it with the given
121      * password.
122      */
123     public KeyProtector(byte[] passwordBytes)
124         throws NoSuchAlgorithmException
125     {
126         if (passwordBytes == null) {
127            throw new IllegalArgumentException(&quot;password can&#39;t be null&quot;);
128         }
129         md = MessageDigest.getInstance(DIGEST_ALG);
130         this.passwdBytes = passwordBytes;
131     }
132 
133     /*
134      * Protects the given plaintext key, using the password provided at
135      * construction time.
136      */
137     public byte[] protect(Key key) throws KeyStoreException
138     {
139         int i;
140         int numRounds;
141         byte[] digest;
142         int xorOffset; // offset in xorKey where next digest will be stored
143         int encrKeyOffset = 0;
144 
145         if (key == null) {
146             throw new IllegalArgumentException(&quot;plaintext key can&#39;t be null&quot;);
147         }
148 
149         if (!&quot;PKCS#8&quot;.equalsIgnoreCase(key.getFormat())) {
150             throw new KeyStoreException(
151                 &quot;Cannot get key bytes, not PKCS#8 encoded&quot;);
152         }
153 
154         byte[] plainKey = key.getEncoded();
155         if (plainKey == null) {
156             throw new KeyStoreException(
157                 &quot;Cannot get key bytes, encoding not supported&quot;);
158         }
159 
160         // Determine the number of digest rounds
161         numRounds = plainKey.length / DIGEST_LEN;
162         if ((plainKey.length % DIGEST_LEN) != 0)
163             numRounds++;
164 
165         // Create a random salt
166         byte[] salt = new byte[SALT_LEN];
167         SecureRandom random = new SecureRandom();
168         random.nextBytes(salt);
169 
170         // Set up the byte array which will be XORed with &quot;plainKey&quot;
171         byte[] xorKey = new byte[plainKey.length];
172 
173         // Compute the digests, and store them in &quot;xorKey&quot;
174         for (i = 0, xorOffset = 0, digest = salt;
175              i &lt; numRounds;
176              i++, xorOffset += DIGEST_LEN) {
177             md.update(passwdBytes);
178             md.update(digest);
179             digest = md.digest();
180             md.reset();
181             // Copy the digest into &quot;xorKey&quot;
182             if (i &lt; numRounds - 1) {
183                 System.arraycopy(digest, 0, xorKey, xorOffset,
184                                  digest.length);
185             } else {
186                 System.arraycopy(digest, 0, xorKey, xorOffset,
187                                  xorKey.length - xorOffset);
188             }
189         }
190 
191         // XOR &quot;plainKey&quot; with &quot;xorKey&quot;, and store the result in &quot;tmpKey&quot;
192         byte[] tmpKey = new byte[plainKey.length];
193         for (i = 0; i &lt; tmpKey.length; i++) {
194             tmpKey[i] = (byte)(plainKey[i] ^ xorKey[i]);
195         }
196 
197         // Store salt and &quot;tmpKey&quot; in &quot;encrKey&quot;
198         byte[] encrKey = new byte[salt.length + tmpKey.length + DIGEST_LEN];
199         System.arraycopy(salt, 0, encrKey, encrKeyOffset, salt.length);
200         encrKeyOffset += salt.length;
201         System.arraycopy(tmpKey, 0, encrKey, encrKeyOffset, tmpKey.length);
202         encrKeyOffset += tmpKey.length;
203 
204         // Append digest(password, plainKey) as an integrity check to &quot;encrKey&quot;
205         md.update(passwdBytes);
206         Arrays.fill(passwdBytes, (byte)0x00);
207         passwdBytes = null;
208         md.update(plainKey);
209         digest = md.digest();
210         md.reset();
211         System.arraycopy(digest, 0, encrKey, encrKeyOffset, digest.length);
212 
213         // wrap the protected private key in a PKCS#8-style
214         // EncryptedPrivateKeyInfo, and returns its encoding
215         AlgorithmId encrAlg;
216         try {
217             encrAlg = new AlgorithmId(new ObjectIdentifier(KEY_PROTECTOR_OID));
218             return new EncryptedPrivateKeyInfo(encrAlg,encrKey).getEncoded();
219         } catch (IOException ioe) {
220             throw new KeyStoreException(ioe.getMessage());
221         }
222     }
223 
224     /*
225      * Recovers the plaintext version of the given key (in protected format),
226      * using the password provided at construction time.
227      */
228     public Key recover(EncryptedPrivateKeyInfo encrInfo)
229         throws UnrecoverableKeyException
230     {
231         int i;
232         byte[] digest;
233         int numRounds;
234         int xorOffset; // offset in xorKey where next digest will be stored
235         int encrKeyLen; // the length of the encrpyted key
236 
237         // do we support the algorithm?
238         AlgorithmId encrAlg = encrInfo.getAlgorithm();
239         if (!(encrAlg.getOID().toString().equals(KEY_PROTECTOR_OID))) {
240             throw new UnrecoverableKeyException(&quot;Unsupported key protection &quot;
241                                                 + &quot;algorithm&quot;);
242         }
243 
244         byte[] protectedKey = encrInfo.getEncryptedData();
245 
246         /*
247          * Get the salt associated with this key (the first SALT_LEN bytes of
248          * &lt;code&gt;protectedKey&lt;/code&gt;)
249          */
250         byte[] salt = new byte[SALT_LEN];
251         System.arraycopy(protectedKey, 0, salt, 0, SALT_LEN);
252 
253         // Determine the number of digest rounds
254         encrKeyLen = protectedKey.length - SALT_LEN - DIGEST_LEN;
255         numRounds = encrKeyLen / DIGEST_LEN;
256         if ((encrKeyLen % DIGEST_LEN) != 0) numRounds++;
257 
258         // Get the encrypted key portion and store it in &quot;encrKey&quot;
259         byte[] encrKey = new byte[encrKeyLen];
260         System.arraycopy(protectedKey, SALT_LEN, encrKey, 0, encrKeyLen);
261 
262         // Set up the byte array which will be XORed with &quot;encrKey&quot;
263         byte[] xorKey = new byte[encrKey.length];
264 
265         // Compute the digests, and store them in &quot;xorKey&quot;
266         for (i = 0, xorOffset = 0, digest = salt;
267              i &lt; numRounds;
268              i++, xorOffset += DIGEST_LEN) {
269             md.update(passwdBytes);
270             md.update(digest);
271             digest = md.digest();
272             md.reset();
273             // Copy the digest into &quot;xorKey&quot;
274             if (i &lt; numRounds - 1) {
275                 System.arraycopy(digest, 0, xorKey, xorOffset,
276                                  digest.length);
277             } else {
278                 System.arraycopy(digest, 0, xorKey, xorOffset,
279                                  xorKey.length - xorOffset);
280             }
281         }
282 
283         // XOR &quot;encrKey&quot; with &quot;xorKey&quot;, and store the result in &quot;plainKey&quot;
284         byte[] plainKey = new byte[encrKey.length];
285         for (i = 0; i &lt; plainKey.length; i++) {
286             plainKey[i] = (byte)(encrKey[i] ^ xorKey[i]);
287         }
288 
289         /*
290          * Check the integrity of the recovered key by concatenating it with
291          * the password, digesting the concatenation, and comparing the
292          * result of the digest operation with the digest provided at the end
293          * of &lt;code&gt;protectedKey&lt;/code&gt;. If the two digest values are
294          * different, throw an exception.
295          */
296         md.update(passwdBytes);
297         Arrays.fill(passwdBytes, (byte)0x00);
298         passwdBytes = null;
299         md.update(plainKey);
300         digest = md.digest();
301         md.reset();
302         for (i = 0; i &lt; digest.length; i++) {
303             if (digest[i] != protectedKey[SALT_LEN + encrKeyLen + i]) {
304                 throw new UnrecoverableKeyException(&quot;Cannot recover key&quot;);
305             }
306         }
307 
308         // The parseKey() method of PKCS8Key parses the key
309         // algorithm and instantiates the appropriate key factory,
310         // which in turn parses the key material.
311         try {
312             return PKCS8Key.parseKey(new DerValue(plainKey));
313         } catch (IOException ioe) {
314             throw new UnrecoverableKeyException(ioe.getMessage());
315         }
316     }
317 }
    </pre>
  </body>
</html>